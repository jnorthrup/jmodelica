// Generated from src/java-generated/org/jmodelica/modelica/parser/Modelica_all.parser
package org.jmodelica.modelica.parser;
 import org.jmodelica.modelica.compiler.*;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
import beaver.*;
import java.util.ArrayList;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ModelicaParser.beaver".
 */
public class ModelicaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short ANNOTATION = 2;
		static public final short STRING = 3;
		static public final short SEMICOLON = 4;
		static public final short COMMA = 5;
		static public final short IF = 6;
		static public final short RPAREN = 7;
		static public final short LPAREN = 8;
		static public final short PLUS = 9;
		static public final short MINUS = 10;
		static public final short FOR = 11;
		static public final short CONSTRAINEDBY = 12;
		static public final short INITIAL = 13;
		static public final short ELSE = 14;
		static public final short ELSEIF = 15;
		static public final short LBRACK = 16;
		static public final short ASSIGN = 17;
		static public final short RBRACE = 18;
		static public final short END_ID = 19;
		static public final short LBRACE = 20;
		static public final short UNSIGNED_NUMBER = 21;
		static public final short UNSIGNED_INTEGER = 22;
		static public final short TRUE = 23;
		static public final short FALSE = 24;
		static public final short TIME = 25;
		static public final short END = 26;
		static public final short COLON = 27;
		static public final short THEN = 28;
		static public final short LOOP = 29;
		static public final short RBRACK = 30;
		static public final short INPUT = 31;
		static public final short OUTPUT = 32;
		static public final short EXTERNAL = 33;
		static public final short PUBLIC = 34;
		static public final short PROTECTED = 35;
		static public final short EQUATION = 36;
		static public final short INITIAL_EQUATION = 37;
		static public final short ALGORITHM = 38;
		static public final short INITIAL_ALGORITHM = 39;
		static public final short CONNECTOR = 40;
		static public final short EXPANDABLE = 41;
		static public final short CLASS = 42;
		static public final short MODEL = 43;
		static public final short BLOCK = 44;
		static public final short TYPE = 45;
		static public final short PACKAGE = 46;
		static public final short FUNCTION = 47;
		static public final short RECORD = 48;
		static public final short NOT = 49;
		static public final short PARTIAL = 50;
		static public final short DISCRETE = 51;
		static public final short PARAMETER = 52;
		static public final short CONSTANT = 53;
		static public final short ENCAPSULATED = 54;
		static public final short OR = 55;
		static public final short AND = 56;
		static public final short WHEN = 57;
		static public final short FLOW = 58;
		static public final short REPLACEABLE = 59;
		static public final short END_IF = 60;
		static public final short LT = 61;
		static public final short LEQ = 62;
		static public final short GT = 63;
		static public final short GEQ = 64;
		static public final short EQ = 65;
		static public final short NEQ = 66;
		static public final short END_WHEN = 67;
		static public final short MULT = 68;
		static public final short DIV = 69;
		static public final short ELSEWHEN = 70;
		static public final short EXTENDS = 71;
		static public final short FINAL = 72;
		static public final short OUTER = 73;
		static public final short INNER = 74;
		static public final short WHILE = 75;
		static public final short RETURN = 76;
		static public final short POW = 77;
		static public final short END_FOR = 78;
		static public final short REDECLARE = 79;
		static public final short IMPORT = 80;
		static public final short CONNECT = 81;
		static public final short END_WHILE = 82;
		static public final short DOT = 83;
		static public final short EACH = 84;
		static public final short IN = 85;
		static public final short WITHIN = 86;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"ANNOTATION",
			"STRING",
			"SEMICOLON",
			"COMMA",
			"IF",
			"RPAREN",
			"LPAREN",
			"PLUS",
			"MINUS",
			"FOR",
			"CONSTRAINEDBY",
			"INITIAL",
			"ELSE",
			"ELSEIF",
			"LBRACK",
			"ASSIGN",
			"RBRACE",
			"END_ID",
			"LBRACE",
			"UNSIGNED_NUMBER",
			"UNSIGNED_INTEGER",
			"TRUE",
			"FALSE",
			"TIME",
			"END",
			"COLON",
			"THEN",
			"LOOP",
			"RBRACK",
			"INPUT",
			"OUTPUT",
			"EXTERNAL",
			"PUBLIC",
			"PROTECTED",
			"EQUATION",
			"INITIAL_EQUATION",
			"ALGORITHM",
			"INITIAL_ALGORITHM",
			"CONNECTOR",
			"EXPANDABLE",
			"CLASS",
			"MODEL",
			"BLOCK",
			"TYPE",
			"PACKAGE",
			"FUNCTION",
			"RECORD",
			"NOT",
			"PARTIAL",
			"DISCRETE",
			"PARAMETER",
			"CONSTANT",
			"ENCAPSULATED",
			"OR",
			"AND",
			"WHEN",
			"FLOW",
			"REPLACEABLE",
			"END_IF",
			"LT",
			"LEQ",
			"GT",
			"GEQ",
			"EQ",
			"NEQ",
			"END_WHEN",
			"MULT",
			"DIV",
			"ELSEWHEN",
			"EXTENDS",
			"FINAL",
			"OUTER",
			"INNER",
			"WHILE",
			"RETURN",
			"POW",
			"END_FOR",
			"REDECLARE",
			"IMPORT",
			"CONNECT",
			"END_WHILE",
			"DOT",
			"EACH",
			"IN",
			"WITHIN",
		};
	}
	static public class AltGoals {
		static public final short exp = 87;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjVGUOL4NMzgaxFTCzqzq3Gn8SXY1WJhYiBeeH5z0LStPLJAWOGS54a6X2HSI40REeO1R" +
		"JchCYHfHaLXG5CQwkxdRzRvsgkbNtTlTq3#pyp$Ty7tsUkdMgweItJjMjgdjxQ8ZM3UJcKQ" +
		"ApSileHRbvRfcKIBO#S9Jx459dSztcfObsz4gvt8TA6xNxqj7KXxQbBhG#$PNggJUrfNQXp" +
		"WvAJakAOsHN#bvs1N#RJxd5cZH7JzFHYaDBbbwd8RApeTjaPtgKzelg5YRng5VQY0bS0QGN" +
		"0QcLsu0fouY#jaIl8RrDpwCdFuEp5jQXzRsIitSnjNEwnOcsSBpSIlIdZRWstzwbpXuD1Bg" +
		"#j2Nhz0nfPwI#icUm6QBMKwvZQ6UadWNiNOR#zYnDz6UFtvJEeqsOoxTtkRD7lIWbEkPMSc" +
		"aBIrI3D5PkaViFZKVv6KrY9roto2sCazW$MC$f5YTHx$4dv5QAxHGNR29sfUFeUDd94j1q2" +
		"YKxqIzY1nh0EhLe#oXEj6lk8wTRd6WFhxGDzMKldNBBrDqc7g6ZnNlY0psRQFTGvwEWLYp2" +
		"NQXrbeavOgwO9zuIxyZUihVIBKMqf#EXiP9EOexl3UkL7fNTWAPRg3CVVLuaEojUrDA9pYi" +
		"T07oTIrFkPw#qDUWnhetsbUym6cNbQ33g5nbiqF3wsWVHAgUlXtjzxKFLie7v5JGdx6cDxA" +
		"P8h6tbH6UnYERBXOeFsdaz$Og#5d$BhSYja0lfDh6NE4ay81uAKgecIgAhLqB$b4T5djSpv" +
		"SEQH6$JTWJY#x1yJ#mXjgMZFAyFqdDqFtjzpwTyhtI6nokjB#9UWnO6pRBGwtSSttVOwx5H" +
		"huBOwpi#5V1whSUhUsPjrfelvuTz7ISVqXHw7OM#FWG9vNMKDwfhoxM3TPLkIVgtunbhclb" +
		"Nv2jvQqjxAwVx3Xcb4vUwGEcM8fheySfhU#PVbYy7dOCkGSUW8UWKh1Dq2xe7FI9oNI03Fh" +
		"SWJagt5D5TZZTzKFppe1$ooEeehzj3Gl5#NzUcUh4fwvQYFnnll2h#1Vb2n5u3OdUDbMElE" +
		"q96yRvKPtZjg7HBaTZ5ySQhub#IBqNiRGElrrav#XjTBtU4ZE9F5zrnKgd736y7tHrfjj8j" +
		"HRbFlLAzh1UxCVUYV97k5FlvzphzPENe6$gMbaD6yQhVVyqjaMrbMt6YR4itAjsIz87ZSqj" +
		"oI#XZvf#Jpz5Ij7c4s7boyFCSbpPaUa2yWlliEV6YNAnqIn6jy4eFGBiNSy$AP#bXn6uwNK" +
		"ttYGt5blGUhVJbGC#o$bCq4wlNIh6ds5ni8Vw2Y3nRckXshxGIz2Xpxylt#QJs4D9evjGAO" +
		"dM6qn2StjxdKZTeTCEu$fl6Gsf#xXEbMuhe0Q#anhKNUyIAgDTyx6#$vtv7N#TZlRSwUbpV" +
		"vTAMD5Dk2JtRrqTvRNlNfmAh$zwELrxf4RiEOqTx4plPgQ2tOEkFt1$XYgYzlgrMHFbMX8I" +
		"OpPRUzgd0Elo2vtLzHSnz7oSn3SbubOA6qXnQJtaLa#aFse0wKKTn5IsbGRAbR4dR8MAF8E" +
		"z7tQWxzQ1rQM$QHrQ8BMK5BK5wL4bvT2dDHSGUaO#74QkZ5JHFLciIwuZhwGPwJhOCiYZj8" +
		"$QbwS7wADN8n#5bfVWxhDRBMgQMT9Ei5IDDgPPcM4xqWbHjZBO3fkqusaFZBN9RODgM1bbC" +
		"iAMZ$MUvBL8loFH2NWjClHZJLLoguPRr5E54SWrJBJ3XQahN16jRBhTO76nvIpIGRf4xiSK" +
		"XiRQTxDue3b4Z80P0#aonHEmgdgIRnIAn5EL1zAcyHiXmHxuLfO6o8rhk5W$Bx#XOUJNJDV" +
		"HFTJMbgqNMSlGgZRPys7grM2w$0yqM6qTRw9Lmltv6$4kyAfUZxcLwYNwNRMGRxDTjKFwHb" +
		"i66mtGBIkWVMduL7qiIi#LLJ5TZLS3LbAuILPQZfK76yY5jBx#LszEjz2ncHgmbF1aIpzJ$" +
		"m0BYH4yWJezpdAwYGLWZhl8mZO3U3l8MN6yHNyeLYFsLJAfMNNNfIimXowauNHabyHNYj09" +
		"q9iO#qkB5wNCL9x4pwX0dqK##8Tz0dDv0#JEiObSwJF9cQDuiMkFQ89R91gplLp1TAIhLrP" +
		"IkG7GD5sm8V5T4IPq$EOqITyNQrhL43wkhk0brDu6xYP$RryLEU0Lsn1Hi88hWRgKb0lOHn" +
		"NTnNOgrVX3wEOtf2j5ANKrf6Z1PBeTUJOlHHV92bUXAqIU$XTuNosaX1JIDhg15SffOZ#Ld" +
		"1niX0hFbjDnyqG6rQhRP9uDfwjaSrmPQ36wXl9nfcbXNNKtfSc2ot09nl#N3EdLEds9M#6Y" +
		"BEvD#oVFfFNcvk1lpwGD4OXJFfyjfKD0IjMu#mLSE7xHy8bO2KRsSodGvOeshAKt5U1bEL2" +
		"DEKsDq8#RJZRm#ZOgsv7BXMb2X8W5CKytwD5lEm7oQ0OjjbKM7IHm8pIcWgPXFlucUiDk2Q" +
		"QhuaxgQKWlnvv1hW8KMKU8uPHZJUx6sAHQJFeE9hI3DcFXfOb7kSza2wMdOTPW6GsQ9Qf4B" +
		"nR$5MchlnhpwDseNgbhnHLbFJhj7ds74wNRlDAV1bA61Sc2uYwNaMIWlLBkObg9pH5zv0#f" +
		"km9cY3A$oAOz$KjbcB1iWPWCTuMpgUMLqur1MNXVBVzXtJr4Ik$2fPWZp6ucrvLsEmhTLTx" +
		"6jYJcPa#gKAoQ8yxmt8wsf7Vs5acAek93bpcUT1pNvldH9N2b6Y3F5sU9aSOeu23NwYK$AU" +
		"U0N5IDPfQvY05yFnLfsfwDGvaxsVtdknw2YSPp6fzAPeodYYqiXpal5AJGYjuXjNvVxKSw5" +
		"n1F5I0pYwpNgocV5cHvPgPd6$$Uvxyk8vorAnyoR1H5VH$3Luhn2d29VXLUbymHiBuQM5tq" +
		"wD1ppRRmn7qr7onf7uLZL68m$v7ue0#FphANlnI4HhmiYOpuTOpuCjKhdfTmFSbDushGGvV" +
		"wbhk9sTQKvGHjvXqTMwWxZSRXCbe7nDRQhDSxmVOcp#6entYXE2UhWLUdCnpwmCHqZDov4k" +
		"T$K5HZLzLp4yNQFhDJjnkCe6b46nWLiLsjyxViIv$3LOhmJS$9O85CwduinSZEqRkQ8zhDS" +
		"xf$k6hJ6VFn54sRIBw7yBsPsAMlV5dZtQL1I9HrB1rCLMsIDeBtlLOnbtyhAZsOrt0GrcnG" +
		"YEeJpyyprJJg8zN911vonhCmkOZmTAD$qYVOlYY$3Eh0Ij1MJV5$Y0iwlptscahX8N28FGF" +
		"a0HsYntA$UzJDn6TRrBnM9gRalGvalHL9UXvtsEdc9lApHU8tYU2cjQ#Mjd3olycA#DiWBH" +
		"1jv0IqKryhzgAlSpwCBB8TuuIfccDhxwI1nispFE#GleSmkydp4wtwVwB2Y#6hPulfYQvo0" +
		"5lfUnMriROwSZ3vF5ZF5BBalQlRrQ7B8jVEkayLZya#QnBsuMfa$mLONsEeY$Y6UQInUubc" +
		"E5tHeK$cwE4g#xdiLBt2#5Tgs4iU9bp7Bzq5v7qVYTSiXNYfVorpleuFaQz1xJJmjlmbbTX" +
		"5l85xt#KH75iNNKka4hUGoZDIRlbVSYRZcFX1lYtVbr#9ziL3kZPgz7Od58VSHNp$bqbVoc" +
		"zmNckHI92EJ#q9y9i$1EUmCyLtZQuPS9ex7kgEqHiWlvHVoSz#h$9fzsJNZFkmFUw5cBqVY" +
		"Xv3$Yii$CxzK$2gd6$eCoSfC5t$8quCWg9IBIk3IMA13IsXKi5PGxtiDkh8lY#j1uDeJDNi" +
		"w4WTOBjY0ouTpwJFvB$cZfc1JNAtyZ#AmtFjaFutTZyJp2pfMsFUgIwA5R1ssxe6QFHnnZU" +
		"OESMKMFSXej0PPcLrGqPzh8aHFUZo9hDOojluHUWv9RAAzv9Q6k7P7pUwEkCRZxDLzSajpI" +
		"vsChOcIN#TaehPyhzeYwZu9MmUYnZkHSet7sQlxo4z0eKnO4o6$pib4RVbUjSNSXwRfLRJk" +
		"XfhT776DnzahFgzmlp#4jWnbyFIS#pXEaFfOV#DBFnXFtzEFZCNQ8kV7UOdW#Xjg$kQ8Qpp" +
		"ENdrSeYQKQIekQukS7yzhAm$NhYZlweXhFCvUBIxPIhOIdK8Pu58rKT9IbhTQd5jRvFnuNZ" +
		"$sPiikAE$YY6iypbv3#O#LjfFHDL4IlHpljCIMKLiHhpFvUeTvWwXQ1w1cW2EkyJXxnTYOx" +
		"xSKPsLKAVmqVaOausr0Y2lFgpXLhwlSsXyr$HrnZSVPA$AVDJ5dvN#cKglfQLJbHTlOidpK" +
		"LpZlLMi$rFHpXDNKSiJNtJHlFpoRoSdm78#HwENFUnLd#Xwdw2qHPwkppDdWkfbyzSVnhwZ" +
		"vgoEkyJXxHVwJ9kQi$4ybupKc4YzZo$9nNvxauQWvt17NU9ozHZzEfb5KvzAfFggehQXNwa" +
		"1Rox#Zzk#EQFkG8$yQmnBAc4zZY8RHXXQHhnFngai78p$O4PqGSkHVaQSzil9fsjYOdklDD" +
		"VqiH3IFzVorNEdivl6MTkChJW3o84Ukf3bxzMAYTWKhdxTFi4Jta7PJLwFNtTYsvNol1o8$" +
		"q94hQSvUOsDaPPemXncZPwk0r$sHx#$8bJHdhp4iLgPnB7RcxkJhnMruNWSX7#J8bJHdhp4" +
		"ieGn$6aDqiZZQHSUt5VNAzz4Xg3t4aIjfpbvZM8oCEB8a5efWyMmLy7eeyaCTkPBcx3M6nS" +
		"Y8Ovk8nRDLmEjXo0zpv4gQizSO5YCZdYenOnAnsUlPYdfLOwI$VLHjOZ8kzjj78Zsksx5MN" +
		"VJRnuZrEf#yjsAa4ZweCpw6v1QBoUBwg0#qDkf3Z8pxGFa8bHnH7Qr5vpF7zU9wpOUVeKZh" +
		"XTBid#i7qGhLH#K3dtp$q#bURH7yIb4NzIgFfE$aaOvOOuNc$AltcKwpGkcLeWVt#svvjud" +
		"atR077azdT#jwhyNQkWSH#vJQq8KqcIwXAJHLorcA$QM47QD9SbB8tGt#IRvolPmaicn$al" +
		"OcMXhV2vntBMS9DGjyCb8JvKHwp72Jm9EvJkGMOhs95eV5vE6Qw1CL$CW9SaB8JLIykKxGB" +
		"UndWjCsdYU6fGa#5V4nNeuFkGcADzVnkeNzZ7VQnhF3DTwd8Zx6oN4XDrxnvZfEjx2VSKxR" +
		"U7QunlbKnCTOEJRanYdUNCVg5lOprcaRpmxNM9#A#3XNdXjoOnLlhkVg5lPphjCsdXskStq" +
		"gucEC71DovohUNCVe5lOpncaRpmxN69#A#1WjHuVS6CMRwsZTmdv6EstZsU4QxLCH7wFag9" +
		"0RhNXp7QLRsCyefsqyEroZV2hYOwGS6NAZ56#k8tKB#ndfj8rdXskaJqLyp9ApGcwauirrb" +
		"cvXFxESjl7iSCtooKhblbN9aQtDVIjdkQl3OAvfBMqypzBxZEBZUndl6ziPzS9xMT5zqDED" +
		"xL7OouXtBZBxtQ5sxpEV8RGdxtxOVQ3BUnbjeDkXEuXrbUKLSLGowuLyEhsZTDdoIk9dpCZ" +
		"tJzz5V9BCogmkvvPhMLKJ9IrbUQlbZtDkkTP6ouVqCzjS7YSjPVcebjML7$eMSyjLJPIqbE" +
		"L3hS9dd5P6henJIzD7sjFD6sdPmrBkAtNLumwkZX7ta1MMeFkeFb60roCTFdtblifzfUUCp" +
		"D0ydZbVnGaZ7V9HhJ2g6MXhxbFLAZPJDL7IKfQFQbbTfStsLnhfJ#EafImVrRAwIjktgMgY" +
		"fAKCpz5NNB7eixq28oTgIu#S$4#nUxJmMqGrxz5itoBQUzHyCEgLSO96fUbhfRvdSj$fkQ1" +
		"qctAd1HjJHUuxrbuIklnPrKH9UN0ynppabAwdpMsg9afQolA#Lg5rLoxHd7#DVUowUnAaJt" +
		"9aR9zaw#qr$6IfXQTn8lWJ7Hdj4sszlSQqhVm9u4zmPBHFiFNs6iRfHDQsyaF03t5aP8ROU" +
		"diDjRL5AtyS#ECS6PdZRBszXjhQefK$7lpnZepCyRRUNaDjRT7AuqbK7kl8o1nhw#qrrDOM" +
		"hVnWy8CT6Pd1jjvUGsrjqSeV0$uOHqRc65jlhw6sjcZbZmP$j2CZSxIjjzTGMrkqyaU1Fyg" +
		"HaJdArjjhgAqjHgJ3ZzwHIVw5DaVYTIJt8NRXGTowdR4LNOEcYo3KNoaIyYDdZj$8VkVPBx" +
		"3QG2PyToi$OktlFRGVnSclC##6VO#DVoUY#$UztpzM2$l7dsAxOrviydIBlGzO1TtSDq3#Z" +
		"IFJlszilRqQNVrP4Kh$NNl4P$FSByRZTFejzBYI$fNNKpjIXNGPhH0bUrfKj$meALsYCdLF" +
		"MIrTjM$oHs3L5qyojvJC#nTzTfMpcUC8XwV98PgJittopvg5BOlbZCUqoNlZNfKL$ZjBjFb" +
		"4LAPbPLMTjMQh4vRw6tXkNSubRNbk53Ehp8ECQYjXcQtVGmK#1lCzFfKU4Q5EnD7J$ScmSh" +
		"8ZRLbpaIkV9bqVZRJrEBU0ntb5xkx6tnXkncyChTswHkPMq#psR2QxVseckrkjibtxMPNxS" +
		"tLq6#$FpjmVkrQjId#yTUv$G7$sQgPn7zbCTYSqazr9pMJtZMQo#rRps1NTcidkQSraz#9c" +
		"idj3CzczevditjDCTXzl9hiVDfFT5Srazv$DPFVtvh4RUDzOojDmuZdDaQrLd2qpFqmbZxJ" +
		"yC5lFSiF8VUop2KklygvEHNjSUXSiMrT2HmvrP68mrDRhah5O5zgsEdXMaASuCcsds7fTAX" +
		"0PBLrUPChfrHgT$$CwylTydV3V$r7uBql$QGs8HOvplqdXk69lSVbZt#AI$6USL9r#xbDy$" +
		"7aqzrF0R#gBFoVRPyWWQLu2UPBYauZasPB$Bb5yB$ItBp$9NyFuK234JwuablDpt#p6di$r" +
		"CwUsfItBN#EawimpvA#DsR9jy9lN9ZjmwPSG6$jrOmI9H9p48YIDBE7zQqtIiSAJ#FAWoje" +
		"Antguw8MsuRuVDUhghr6vxDa9FpE3QbozlsA4XT$Y56JbR$mllT5MO2pLl$5U6gHfa5zMVT" +
		"Tb$ZTSItEBrRzbjcyu$FSW$2nE$li6LHSYd2iYttlnYCsBbUtxWzdH68jlekMmz1yI55059" +
		"R17Lc6dJD6RNCxmcJf9BR7sjy8#wii8xAsVKGDaEcElxKhhX7VUUjXvDw0DQIFQc3QXJV7C" +
		"lpcqji2pT2$wCwdeAusjQHiwa0wYW#aGFFiTIeVHuPWTHz2Hr9y6q2wqA#vmhR47xSdujeQ" +
		"L$M98BPzXrCfU7VZMa9eCrBQrdbjJPI6jzv1g$T98jTms8LBjzGrulOcgWMW0CFaMMXUnLm" +
		"w#ZXw#IgoBoJBmQRdQ6Buag1NmATrCMDiAjQk3xvK8leVAmlSopQPXG1R5zmXqtmE#MchXu" +
		"Hl6#FBzFWU$vU2xtSEt1CYcCxv5T0ETHgTxtWV0ZyMN0R9x41c5Rz#2tjygqxlml2ilWhrh" +
		"hpP66i55eVVpCOC6mwloteakfHFf93gPJg5JsK8vNkiyhvtWhxA0rrI1Fbkl#qBBUKrYDfN" +
		"ZDHdhQo6lkgyYzAhgNLyxhK9Vav6#plOYR7q#4ewnzVeaV6QCr$wUJ#MllBv#L73LyBqEo$" +
		"EQyhmcFQ$7qn0weIolrtbUjLRSwtbvNgTuNiKgUNt2ywhlcRZNX$AyYY9UbR$Fo$9A9Vlgr" +
		"fRekgozvairTRMDUisNjLwrdFQQBrMEryUApgRolCRx#ccJ8rnu3bjxYRAy3cloYjYurtzu" +
		"#vdU1PJND5Rq2iXNqbsydoNAyjhQywhaTmwztXZJdHbwrVBQg#wt2FUBrglazOBGwoKntM4" +
		"5lThLqaQcFAz3Oru7Xru78tRdqbYw4B4RIXVJf89URwGnl3kFe$4qWIOY8kLulIRcrQt#gX" +
		"Ute7mTdyhK2cAztiOdJUsr4gktEcMgtR#UruwcdZEZVQqq9nvbRoZiPGhsjH9zJNfzBU$C6" +
		"E$hSA#lTS2aVBQ6BPKNyXgrhwJAyLfHyCx9bwk5dFNQnynOvRKAyo#5yrKDxg5BACj#Mo9Y" +
		"bK3LHlqQBwr5xQa3hGtveNnMKUCLHTK7$Hk3aQeC8zOJilNU6RqttojzQ2eYhduPICstleX" +
		"O9pohJu8t4Tv5kzEjaDyhn7ItXqdaOQg4doJ7ISGmjJAZcFKmwJZfqsqbC2LXNs5ACwRNKA" +
		"ymjG8cUu#LmYJeXGAOfiAoijWo3vEzPpzcozE1QHWitm3Biz2$D31bKTF7sniV1QPx8DsF7" +
		"gSp8d6wEOBfpX3JSDnJSKotmRAAKX$wC8PfSeZfCleRxGRhFUbAkWhdJRqs9A2v3SwRFgQf" +
		"mAJwrm#hmXdirMAQ6S5qGOZf4lGlFqvgBZtACwDOdFHC7MRYL0dBoJ1E8eAf4fZKgFR3LSM" +
		"fPOYfLGIJA3DEyVaKZzDq4wSRl3YfLImVqmN091ZJ9I6cyoEOBWqn3IqmnnKUFSCVZc5opo" +
		"c3#Qvy4PZqKx2gRsdc#30JnGpDHru5J2cizVtWzsAEOYbCgbVvOwVNqLUnXiV7hXMDWDypw" +
		"GDQG0jnSkw923I0#j8dY40$j7q1p7quYXP$NyQluZG2ECyiYMauFLWmJayPYr5CxhdxGhPy" +
		"CJ2z2yjNmx88vzFvaR6x59YKhtv0T0OZifW65vbFXUFKkyZwrCV3f29nSRW#xMt6Cty#tH9" +
		"YKlF9NvyI4Ko9HZ4fD1VozUAYc7GK4o4cFSTrRn8HJ2bW4hncjWQc2tdllXWnsnqnQm2csY" +
		"QV$w8dR8t4pXFLF$TisYSy9#Zs$L3MxtdAUrvBH9vDjwA$i5SLisrfEzgUTg0TQIUWs9d#6" +
		"Zlh3cIlv27JRynq$3FcnABVcAbMNweUpnCDsFaonfQIBFncv2Wwcev1tBMSmcVj#FWoZEyi" +
		"EflEeP4qYaP3Og2Hx8FugE#6uc$sBCxMx7swmNd3QkBKskNZh0HERRiKJXtF1iQfngSmJbt" +
		"Rz7WEZ#1CvU4K7au2pi8Oh$R6NFd$xsAiYs0SdeUnhYoCTlrG60CWRWnZekWRm68O4n6CYJ" +
		"oC5uGOBoaJOwauglTLJSFOK0AZ6#lACZ7wyt5u0OpQMcCe1HrBntaOhuvWJ396RKMtKtX$n" +
		"t5TnBZwCYwr8bzkzDJLuheUUZDYQ#CTZU1JkBILGkDhJm89$YOkYgjLmNWrqDEXL9z8l4QW" +
		"vapKz45RUV6otlDngNS18z1o9ktU22uThuu6bufNNv3QE$gjLhn6WCu4#RWUPbpg6JG131r" +
		"nWYatNdMXLCVO$0huhakWhh5urNdn2dYi6Xl7L1wkH2Fpo$P7h6Qy1AALAB3lwlu9lXR7rP" +
		"5nFSkur7jaAoKYyUfZB7KiiMRqvtQ5As6Uk7nS$VFMZ3YklY6k$eph0SRL7tuBusf0tHoKI" +
		"gst$PaKBeLf6EHzNEkNnFLyY4llGAyRN1HA9IAu5bD2cazZoD1gvbSexU52IU72aqtO6iE5" +
		"ciZyGXcuMF9oew7ko71#eJoZm6dkPdUQWyITI3ZDuQhYTLy#BfpcW0jrPU025y4LQdYuJ4q" +
		"UBjHvk5Wcn5KeNl#pSLbKDBmfk6XoYEgoS1pLqtFPg8hZClDh3QvLmhKgyqlXmjMRNmNkni" +
		"65SD7GHkRN6CPbtjOr3PUL0kUjNnxYHjTL8zDulCow#j$1LNerzR2lyZXYDOtWmcwzckF8r" +
		"hSsRrqDBhRUpEFutukNz3vDNrTPAunNexFg$YYgakD8hlSyTcyt3KiPy$nUXwY9MEQM6g$O" +
		"izcrndATXvGb5M8kmPuV5oiPcKVrXR2KiVSfUnPBmV7ttZ8CL4zFHYzZT5kM6vUcpPUcp66" +
		"KzsdQ63K75hhVZsbpOJ6bCcTkysBHCxVyaVg$WwM9ixV4dgMGS5iLadbx0IxBTNp$nTzQHw" +
		"n7dot3NYbRtDwJtnZgxq3g#Dl7Y0$qgb4Vj5VSXzehOgjTpzZUsZksjs9VXhIDNygkU9JbC" +
		"r1BvGDvdd$rpQYD7qsYys9h8j6Kw2YYVMYZgw7wfjMYO7jw$JEjLR2NqZOO6zlGiGbHtCIH" +
		"yb54un#BbEs$vqF5$sOyVOS#w4xgorRxiGIUplWxaDQqkz7PEo$#1Rpm6CzpFf3tyVlX#s0" +
		"f#C2rg8z2dtW$rlXOusEDZ$yDFl9tHAvLRw5wynhLnrzBbGzStLjXuyFiCtlBlBrCVnjaj0" +
		"llCqNtGQUBVIRwxMrlhks3f9#IGYrZKt$$f7UVdbBlPIbpwkxDkryVPPbteQXb$qbIxq9xy" +
		"NdOxXh#3Z0b#Yp5Roe6wZxnTP#clAdmhOIHqT#shfOLy4soKlICO$zwjUIffUaZxNJpHzfx" +
		"JX7wEOLdUiRicYszsTiJDlM98gD7MePFNpOU$3rzlT8jy9I$LrF61ccrn#Q$OuLB9QsOEAe" +
		"HBX9z6b1uv6ZVqYD7LEmUBOpAzDtspToZOMzw5zFYrYtDEnjXrpUCN5FU2UvF1pWBfcr0Ky" +
		"SW6l#cMYYqxi92kKyYHLVjmjhc3Bj6Uuts$sTj6Vde7Hd9$yPU$L#yRXrHUsrq7U5TsEXZ5" +
		"uxiq6h7dUALUvRugofzrs$jQJI#PZPLNfyujlRxnrfbxOxviOdhnjVOrT5johYgzPdpeU6i" +
		"C1wbz4PIFMKRZ#QfFUfnIXIjhwlHybDsMJtDroq$IjBRnKf6gNvrTFqpkxJlPUpxby2CM6l" +
		"k1qVOVbkZpg#SHzynr7lpiA1bSxOrRR0SyyedQdrcB$h4qPXbvjMSQMtFtLpJc#UC$blMkd" +
		"pB2hVvg#f6BMlCii2d4ERI8yBdln9pdd7bpNcMwUdw69tpwcrQtADzcvRdiOmtXg7TdiNdr" +
		"XgxvQsUJRa$LqTtJN$#TywdDNRNs5rZTutT$qjsZPvwWzFeym1oTJQAVmUepqPvSg5TYphl" +
		"Ey3YgEEwfhIAks3vkgMVYLpVx3CHysK#AQz#PChfrHgTDJfgBXPR2wJxUmeABGnsdFVlsXp" +
		"NwFlOKBVmsn5#xkE$d2lmFCgbei$9eSGSUY0kISyKb7mfVFCSzWwbz#aThzIRd$lwDFfyhf" +
		"yvms#QYlLEI#htwqLjsIVotWNQp7Tg8JRswyQea5$#UqIDR4itHiuM$9nXROLZtLUDSTGFr" +
		"mmrPSzEA3D6sV7$Yh4Wcgb0CuskC6CSYmD$Tv2cMp52Nfb7J9VLYfd6YfcD$XKQvotrl$gG" +
		"ClA#eTxzLIlQUyl81tslZvPbxBlGOkMmj3THiFcv$7jW7QubzNzWKCExoBSaMcSaqXIYjVz" +
		"4jDOPgF#EgEFfgBi3TT1RvqNaGv5$ZXnoRMv3VY$ojucwzG8$3$mbu7SdgZiJ#N78do9gbG" +
		"0$3lckoAz33jrC5$Zu0lpxu4z4UXHG89VT4maosQ#9wjNlcg6z5hR5kiW1krE6g78CSlMhR" +
		"OyXFnfjEu27hNLoACDsjmPWMK7KkYFuESYFXEvSeXRjqQx#h$2DmKEla$gLEBHt#Wtv1v2R" +
		"ITIvEtZuQN4VKG9zffzGf$ugvnlKFqXKjI$oZr0t23pijlWtKSi1HEdp4QkfY6qBbASXxuR" +
		"s6v1E9afkWRw#WtRO30v3#oV87q0PyGhGXphWgG7#u7VOUO#e#cha68$gvP1Hl$Bs8zhHnu" +
		"OQo6o2$aE#Ig0E$ghgaJ0c5Pl1pq78$qoKmWfPdKPUXxYs0zR9o8$aqQVCFVp$n50m47QsH" +
		"peMxOXznQd8WQ7o9YICQxUt40#CVpVqknunxuwngTy8EKu2zHZ7xeX$$V784QDwzBrYByGh" +
		"m9n2xBeV1RuryX70lZdQW2zGlrkFkH2SWhQBqJ$ClSGnIAyWtGYVQ0$kGleIycfkO2pROyn" +
		"gDqMCqO$44QZ7cjvo8Vg5s0UtGWTvnPNe4#PhvdNC6VYjd80SSrBiY7Ye$xbRZTSJuDNlZg" +
		"ElLPYhLUXF0kNaBQXJTZ3sz3FaTYR#zTFgkv4GgrPh8SRx824UNH3JcbyXYxdP1QjlUXVq#" +
		"n7#JJrAglzb2l9LwfTJ4HEn1z9urCDk5MJRlmnRfy7duS2DkLw5zghpC9wO5msuNvAudohX" +
		"EmKiLUXp4cERt0fzmpokXDygZ4KIypNx1snCXsqLm$beUn8OteJzbOXxAoICVGVCqHQ7mjR" +
		"JQ4V$axEG4F$aH9Hn7tKY$gK$gePC$LUeK$TUM#IJK8svaNmM2VEo1#wB7YyX79ZFbIT11l" +
		"teWBdPuHVmY6bcF#3Q5dumBvFVWyUSJVuB$HiEt8X1gYTon3fr5kemxzjWRhR7lLo5#pZu5" +
		"ct8gu6l2zQ8QlIX1lTB2lCY1H#fQs1hV#Iu$wknzYGmNYtkH8BlshEHW2k5DIlH7pdcGm9h" +
		"ImhtL0BngCOyJU1#RjyLFEwDIiof3FnNen$Lw4C5vaarrhH45NBOgiPwKtqXofWlrLSWDXS" +
		"WnpWaW5sy0AnRWuTU9UxvAemfNG$R6AjApBbAtDkLm5M9#poDyKYezHHZcq4$gu6d1dYhCG" +
		"Ugbo9Xx6fm$sHGhjaDwHpSsnZV3Exl3EANGUogCOOTjm6FTI2BjQe6$Qcv2B40rYJ6lOsQv" +
		"nYBIipLAjmlDMyWVbXhgYlW7waAzs4QQruLrfequfa4dyPu90SZn$sP7ek4MALnFwJHjshS" +
		"JsduJghuO0tB8Cv9#6w5zI63#pU5VcRmt9327Eto37ZuM0jZKudreXBzIsFkLsFDo21s7Kv" +
		"0deBi0kJgdW7M3eXb1dsimQJBOEvtKNt5FTiUzcemrp9OVsgm7cOKReGkZRMaA$gTGL$ROz" +
		"wciHQbiVuaiKUbC5PT5Pw7WG7tNKhXn$neWpKaMudxg0SIzDkeNqCT0ZdqiIlMj1hiOnbWQ" +
		"elsZfY3MQo7cUUG5YDEk0TgqFSCxkks1u1$5JpMdROADyOhZVKiYpwrXQqirgIss5Eoc0lj" +
		"EYF7t6k7c6OHjtQO5sdCjIpMnNR0byRzaSNSReVxAmj#hGx0elOqnAa1$U#EVQOQOvF5$PZ" +
		"6U6QHgg2Nn9gInRsQnhtLOmOIvdxwTjJXVk#ATJ9x86GGm#wOLrciXsdSurdSrndSWncCQr" +
		"VCYopcGmzWwR41zaDWpi9E2ZPxO4rCupxBOhzP2zWocDyrQW#1htKm7xDO2xkZhJlk$HhuR" +
		"S0Usu0ngCQSQAFc8sBT5diFJjkKmXpEgBZZNiNfYr9OgrggjHbwsVdgLqTntw1lrOXH5cU6" +
		"Eenp5lCWY$KYgtnXtynY3BEuzxE8THRtNnRpFFiGxa#itnNmc$q1MB0NPB6$zi2zdEs7XFd" +
		"M0pgrbVhyajnJvwtdgDmcV2u7XgTTENsxpZFRcVnzdRTVtyfWQ$pSoLTKcVnIh#uHax$c#J" +
		"d8znjFwFS5#NKDRvhy3vrtKhzrZBCI7MhA#qJbAtwCbbl#ulXM1nYT9rnTTexZwIsZOsoBx" +
		"LnRvsxvsDBx5##BmFgP$YvQbvaKarcky#1EBmOxU7YlZyedl5WcRZ2wswiSuz7Rmxf7OKp1" +
		"QQRz79FVuTegEfWO$CNaWqn#lidlC$c2gCrAt8U9KPwFG$GPem9hU2NcSkKCrrRLAjOVd3r" +
		"RF6FygtDCBMImjxOPucJQu2oPm9eS7EhfNU7vtyB8JNPrsIUD7FORjL2gCsNLEuLYuYV4y4" +
		"Dde$Ex7c$#Czkri7OaJt3rlFz$4krJSgxZ1Ux11CuiAVIf2cjV4kk1#ldg0FCt#LKfFAKIR" +
		"EByKdMMsXTDUJJYCGp#i7PLuQoUn1cZ5dj2SBLkhn#WpXa69x1KOQrBlmOUDbBOmsgnNWSu" +
		"mwPEAEmlYRqXkGvqSBvEOHsimBwMkWhv1aw6pFsQmbcsHM$407j7nRQklSj6dhrdzPaoWxD" +
		"uDSvjYQBtKtdnoE3iN9DKE0qMd1ChpjHynODUtB169ZPpvUeZOt7jLDX#9SuLBM$r#ehuPH" +
		"77r2Qc$Vt6yRLQ6YshCq$hZOlBLn#ZyvPjNLqNxBkfHUN5esQWoNymzhnngjx3uu$Ar#qot" +
		"hGzfiSeFToKRp4siqwsQe2fEzp8l6rit6lgxuUDUiEdTPx#tSWiDkKAPo#Jq7dNfCwp3Quj" +
		"UxpnYRE92DS98uypL4qFLsuzBDgUm1vTuwqZDMT4sslkZSUXM59d7yUdHNvxLnEBAdLEmFs" +
		"VcM5aJHogSAy9F2TLBT5bzVmYFa7xJaR$8fshjQFxsaRNp8UCYLrNiyUcr7CIpfrTFpTbdB" +
		"63$TJvDOefczBvEYrqtXrdes2AvdlW$Wjmrk#1#wTgdDC9S6v9$ghFE1aybwNN1py8#Qt69" +
		"jhJM3lI4p3$bvKRlr89dzjZPNp4XlG52QI0r1Fe1#0N82r4UI7oJwY2NWF$6lAnU6ORInca" +
		"QYI1bK3G9AHBlNI9IV$8Iq5UtKoaJv4#HBe9QIBIdKXtG$Pk#BkLr9EnG0he6kJN89#ANAV" +
		"095r#bAfe2VAFKRUOAjLlIj3huCUXVXpmZcDUfJHIRLY#67x6GtO2SfqgwNJaSs5hBl9xaQ" +
		"jq5wSAkXtj7q5l2ihJaAjqXKbOoVdtzyu0VnLobQu4FvbJ1Gr7ceUwUSZlWnsTCaW9f3HI5" +
		"L8MIV2lN9s5zhCujoc5L65IG6UZ$21qSGBdtxev1$gtGVSsj5#7ycT88p5c3qFcHBIT27cT" +
		"Af22MAe8wq#2p1peO2T12kXaw9u2Em#WxbJmn$8lumWw3ln3g7i5CiT0L$tMzT78TLAyeAF" +
		"05qw2Za0wabC5fq7W1t5UGOU1FmmsL3eS$E6e#plomgd2fCBbWu7n49DcmDuCjCr0$Lka$W" +
		"#l02TrWLH15o6z3VvjvFSZln#vUfg#5loruAz7VZrozVj8Gy0F0Qz#g$PGKh#Igr85$uxKT" +
		"F3JmQlVRBm7kKhgbsT685U$y8Sd3Vw5mEUHFuyS9meaePxwaGJXIPH$5$Cbv2yXVuTJGDZr" +
		"aGGzZlnnvEf$k1#5V3GdzMl2X2G8J#H8WjJ$XF4agTyE9IH1wdzXU1NvPSWlG$uKygUGlyi" +
		"f8An4I8BUunGGJff8Wd$FSJxAMAsG13s3$1daxtCAw6QKRmQFdG19a7fZgduBNVrllySZns" +
		"w794YzwRe5EPu0aGIf$#z#5dAz80aw3$bvoDN$XdGQSZpn8WbI$tlA8kH3$n#vZH6P");
 // Generated from src/java-generated/org/jmodelica/modelica/parser/Modelica_all.parser
/**
	 * Error reporting class that creates an error message and delegates reporting the 
	 * message to a subclass.
	 */
	public abstract static class Report extends Parser.Events {

		/**
		 * Report an error with error message <code>msg</code>.
		 */
		protected abstract void report(Problem P);

		/**
		 * Creates an error message for when <code>token</code> is found unexpectedly. 
		 * Passes the error message to {@link #report(String)}.
		 * @param token		the unexpected symbol.
		 */
		public void syntaxError(Symbol token) {
			
			StringBuffer s = new StringBuffer();
			//s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
			if (token.value != null) {
				s.append("   Unexpected token: \"" + token.value + "\"");
			} else if (token.getId()<Terminals.NAMES.length)
				s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
			else 
				s.append("  *** Syntactic error");
			Problem p = new Problem("", s.toString(), Problem.Severity.ERROR, Problem.Kind.SYNTACTIC, Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
			
			report(p);
		}

		/**
		 * Creates an error message for when the scanner throws an exception.
		 * Passes the error message to {@link #report(String)}.
		 * @param e		the exception.
		 */
		public void scannerError(Scanner.Exception e) {
			/*
			StringBuffer s = new StringBuffer(e.getMessage());
			s.append(" at line ");
			s.append(e.line);
			s.append(", column ");
			s.append(e.column);
			*/
			Problem p = new Problem("", e.getMessage(), Problem.Severity.ERROR, Problem.Kind.LEXICAL, e.line, e.column);
			
			report(p);
		}
		
	}
	
	/**
	 * Error reporting class that throws a {@link CompilerException} on an error.
	 * Uses error message created by {@link Report}.
	 */
	public class AbortingReport extends Report {

		/**
		 * Throws a <code>ParserException</code> with <code>msg</code> as the message.
		 */
		@Override
		protected void report(Problem p) {
		  throw new ParserException(p);
		}
		
		
	}
	
	/**
	 * Error reporting class that collects error messages for later retrieval.
	 * Uses error message created by {@link Report}.
	 */
	public static class CollectingReport extends Report {

		private ArrayList<Problem> errors = new ArrayList<Problem>();

		/**
		 * Adds error message <code>msg</code> to list.
		 */ 
		@Override
		protected void report(Problem p) {
			errors.add(p);			
		}
		
		/**
		 * Get the list of errors. Returns a reference to the internal list, not a copy.
		 * @return a {@link java.util.Collection} with the reported error messages.
		 */
		public Collection<Problem> getErrors() {
			return errors;
		}
		
		/**
		 * Reset the list of errors.
		 */
		public void resetErrors() {
			errors = new ArrayList<Problem>();
		}
		
		/**
		 * Checks if any errors has been reported.
		 * @return <code>true</code> if the list contains any errors.
		 */
		public boolean hasErrors() {
			return !errors.isEmpty();
		}

	}

	{ report = new AbortingReport(); }  // As default, throw exception on errors.
	
	/**
	 * Set the error reporting class to use.
	 * @param report	a subclass of {@link Parser.Events} to use for reporting errors.
	 */
	public void setReport(Parser.Events report) {
		this.report = report;
	}
	
	public Parser.Events getReport() {
		return report;
	}
	
	private Map<Integer, Integer> lineBreakMap;
	
	public void setLineBreakMap(Map<Integer, Integer> map) {
	    lineBreakMap = map;
	}

	public String removeWhitespace(String str) {
		String str_res = str;
    	str_res = str_res.replaceAll("\\r", "");
    	str_res = str_res.replaceAll("\\n", "");
    	str_res = str_res.replaceAll(" ", "");
		return str_res;
	}

	public ModelicaParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 2: // source_root = 
			{
					 SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr;
			}
			case 3: // source_root = program.program
			{
					final Symbol _symbol_program = _symbols[offset + 1];
					final Program program = (Program) _symbol_program.value;
					 SourceRoot sr = new SourceRoot(program); 
       return sr;
			}
			case 4: // program = stored_definition.stored_definition
			{
					final Symbol _symbol_stored_definition = _symbols[offset + 1];
					final StoredDefinition stored_definition = (StoredDefinition) _symbol_stored_definition.value;
					 return new Program(new List().add(stored_definition));
			}
			case 5: // stored_definition = within_opt.within base_class_decl_list.base_class_decl_list
			{
					final Symbol _symbol_within = _symbols[offset + 1];
					final Opt within = (Opt) _symbol_within.value;
					final Symbol _symbol_base_class_decl_list = _symbols[offset + 2];
					final List base_class_decl_list = (List) _symbol_base_class_decl_list.value;
					 StoredDefinition def = new StoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
    	return def;
			}
			case 6: // stored_definition = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadDefinition();
			}
			case 7: // within = WITHIN.WITHIN parse_access_opt.parse_access SEMICOLON.SEMICOLON
			{
					final Symbol WITHIN = _symbols[offset + 1];
					final Symbol _symbol_parse_access = _symbols[offset + 2];
					final Opt parse_access = (Opt) _symbol_parse_access.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new Within(parse_access);
			}
			case 8: // base_class_decl_list = base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_base_class_decl = _symbols[offset + 1];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new List().add(base_class_decl);
			}
			case 9: // base_class_decl_list = base_class_decl_list.base_class_decl_list base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_base_class_decl_list = _symbols[offset + 1];
					final List base_class_decl_list = (List) _symbol_base_class_decl_list.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 2];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 base_class_decl_list.add(base_class_decl);
        return base_class_decl_list;
			}
			case 10: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction id_decl.start string_comment_opt.string_comment composition.composition END_ID.end
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol _symbol_start = _symbols[offset + 4];
					final IdDecl start = (IdDecl) _symbol_start.value;
					final Symbol _symbol_string_comment = _symbols[offset + 5];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_composition = _symbols[offset + 6];
					final Composition composition = (Composition) _symbol_composition.value;
					final Symbol end = _symbols[offset + 7];
					 String end_s = ((String)end.value).substring(3,((String)end.value).length());
        end_s = removeWhitespace(end_s);
        return new PN_FullClassDecl(
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            start,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            end_s);
			}
			case 11: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction id_decl.class_name ASSIGN.ASSIGN type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access array_subscripts_opt.array_subscripts class_modification_opt.class_modification comment.comment
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol _symbol_class_name = _symbols[offset + 4];
					final IdDecl class_name = (IdDecl) _symbol_class_name.value;
					final Symbol ASSIGN = _symbols[offset + 5];
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 6];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 7];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 8];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 9];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 10];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_class_modification = _symbols[offset + 11];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 12];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new PN_ShortClassDecl(
            new UnknownVisibilityType(),
            encapsulated, 
            partial, 
            restriction, 
            class_name, 
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            type_prefix_flow, 
            type_prefix_variability, 
            type_prefix_input_output, 
            class_access,
            array_subscripts, 
            class_modification, 
            comment);
			}
			case 12: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction EXTENDS.EXTENDS id_decl.start class_modification_opt.class_modification string_comment_opt.string_comment composition.composition END_ID.end
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol EXTENDS = _symbols[offset + 4];
					final Symbol _symbol_start = _symbols[offset + 5];
					final IdDecl start = (IdDecl) _symbol_start.value;
					final Symbol _symbol_class_modification = _symbols[offset + 6];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_string_comment = _symbols[offset + 7];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_composition = _symbols[offset + 8];
					final Composition composition = (Composition) _symbol_composition.value;
					final Symbol end = _symbols[offset + 9];
					 String end_s = ((String)end.value).substring(3,((String)end.value).length());
	    end_s = removeWhitespace(end_s);
        return new ExtendClassDecl(
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            start,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            class_modification,
            string_comment,
            composition,
            end_s);
			}
			case 13: // base_class_decl = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadClassDecl();
			}
			case 14: // partial = PARTIAL.PARTIAL
			{
					final Symbol PARTIAL = _symbols[offset + 1];
					 return new Partial();
			}
			case 15: // encapsulated = ENCAPSULATED.ENCAPSULATED
			{
					final Symbol ENCAPSULATED = _symbols[offset + 1];
					 return new Encapsulated();
			}
			case 16: // type_prefix_variability = DISCRETE.DISCRETE
			{
					final Symbol DISCRETE = _symbols[offset + 1];
					 return new Discrete();
			}
			case 17: // type_prefix_variability = PARAMETER.PARAMETER
			{
					final Symbol PARAMETER = _symbols[offset + 1];
					 return new Parameter();
			}
			case 18: // type_prefix_variability = CONSTANT.CONSTANT
			{
					final Symbol CONSTANT = _symbols[offset + 1];
					 return new Constant();
			}
			case 19: // type_prefix_input_output = INPUT.INPUT
			{
					final Symbol INPUT = _symbols[offset + 1];
					 return new Input();
			}
			case 20: // type_prefix_input_output = OUTPUT.OUTPUT
			{
					final Symbol OUTPUT = _symbols[offset + 1];
					 return new Output();
			}
			case 21: // restriction = CLASS.CLASS
			{
					final Symbol CLASS = _symbols[offset + 1];
					 return new MClass();
			}
			case 22: // restriction = MODEL.MODEL
			{
					final Symbol MODEL = _symbols[offset + 1];
					 return new Model();
			}
			case 23: // restriction = BLOCK.BLOCK
			{
					final Symbol BLOCK = _symbols[offset + 1];
					 return new Block();
			}
			case 24: // restriction = CONNECTOR.CONNECTOR
			{
					final Symbol CONNECTOR = _symbols[offset + 1];
					 return new Connector();
			}
			case 25: // restriction = EXPANDABLE.EXPANDABLE CONNECTOR.CONNECTOR
			{
					final Symbol EXPANDABLE = _symbols[offset + 1];
					final Symbol CONNECTOR = _symbols[offset + 2];
					 return new ExpandableConnector();
			}
			case 26: // restriction = TYPE.TYPE
			{
					final Symbol TYPE = _symbols[offset + 1];
					 return new MType();
			}
			case 27: // restriction = PACKAGE.PACKAGE
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					 return new MPackage();
			}
			case 28: // restriction = FUNCTION.FUNCTION
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					 return new Function();
			}
			case 29: // restriction = RECORD.RECORD
			{
					final Symbol RECORD = _symbols[offset + 1];
					 return new Record();
			}
			case 30: // final_ = FINAL.FINAL
			{
					final Symbol FINAL = _symbols[offset + 1];
					 return new Final();
			}
			case 31: // inner = INNER.INNER
			{
					final Symbol INNER = _symbols[offset + 1];
					 return new Inner();
			}
			case 32: // outer = OUTER.OUTER
			{
					final Symbol OUTER = _symbols[offset + 1];
					 return new Outer();
			}
			case 33: // replaceable = REPLACEABLE.REPLACEABLE
			{
					final Symbol REPLACEABLE = _symbols[offset + 1];
					 return new Replaceable();
			}
			case 34: // redeclare = REDECLARE.REDECLARE
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					 return new Redeclare();
			}
			case 35: // each = EACH.EACH
			{
					final Symbol EACH = _symbols[offset + 1];
					 return new Each();
			}
			case 36: // composition = composition_clauses.composition_clauses pn_external_clause_opt.pn_external_clause
			{
					final Symbol _symbol_composition_clauses = _symbols[offset + 1];
					final List composition_clauses = (List) _symbol_composition_clauses.value;
					final Symbol _symbol_pn_external_clause = _symbols[offset + 2];
					final Opt pn_external_clause = (Opt) _symbol_pn_external_clause.value;
					 return new Composition(composition_clauses,pn_external_clause);
			}
			case 37: // composition = elements.elements composition_clauses.composition_clauses pn_external_clause_opt.pn_external_clause
			{
					final Symbol _symbol_elements = _symbols[offset + 1];
					final List elements = (List) _symbol_elements.value;
					final Symbol _symbol_composition_clauses = _symbols[offset + 2];
					final List composition_clauses = (List) _symbol_composition_clauses.value;
					final Symbol _symbol_pn_external_clause = _symbols[offset + 3];
					final Opt pn_external_clause = (Opt) _symbol_pn_external_clause.value;
					 composition_clauses.insertChild(new PublicElementList(elements),0);
    return new Composition(composition_clauses,pn_external_clause);
			}
			case 38: // composition_clauses = 
			{
					 return new List();
			}
			case 39: // composition_clauses = composition_clause.composition_clause
			{
					final Symbol _symbol_composition_clause = _symbols[offset + 1];
					final Clause composition_clause = (Clause) _symbol_composition_clause.value;
					 return new List().add(composition_clause);
			}
			case 40: // composition_clauses = composition_clauses.composition_clauses composition_clause.composition_clause
			{
					final Symbol _symbol_composition_clauses = _symbols[offset + 1];
					final List composition_clauses = (List) _symbol_composition_clauses.value;
					final Symbol _symbol_composition_clause = _symbols[offset + 2];
					final Clause composition_clause = (Clause) _symbol_composition_clause.value;
					 return composition_clauses.add(composition_clause);
			}
			case 41: // elements = element.element
			{
					final Symbol _symbol_element = _symbols[offset + 1];
					final Element element = (Element) _symbol_element.value;
					 return new List().add(element);
			}
			case 42: // elements = elements.elements element.element
			{
					final Symbol _symbol_elements = _symbols[offset + 1];
					final List elements = (List) _symbol_elements.value;
					final Symbol _symbol_element = _symbols[offset + 2];
					final Element element = (Element) _symbol_element.value;
					 return elements.add(element);
			}
			case 43: // composition_clause = PUBLIC.PUBLIC
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					 return new PublicElementList(new List());
			}
			case 44: // composition_clause = PROTECTED.PROTECTED
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					 return new ProtectedElementList(new List());
			}
			case 45: // composition_clause = PUBLIC.PUBLIC elements.elements
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					final Symbol _symbol_elements = _symbols[offset + 2];
					final List elements = (List) _symbol_elements.value;
					 return new PublicElementList(elements);
			}
			case 46: // composition_clause = PROTECTED.PROTECTED elements.elements
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					final Symbol _symbol_elements = _symbols[offset + 2];
					final List elements = (List) _symbol_elements.value;
					 return new ProtectedElementList(elements);
			}
			case 47: // composition_clause = equation_clause.equation_clause
			{
					final Symbol _symbol_equation_clause = _symbols[offset + 1];
					final EquationClause equation_clause = (EquationClause) _symbol_equation_clause.value;
					 return equation_clause;
			}
			case 48: // composition_clause = algorithm_clause.algorithm_clause
			{
					final Symbol _symbol_algorithm_clause = _symbols[offset + 1];
					final AlgorithmClause algorithm_clause = (AlgorithmClause) _symbol_algorithm_clause.value;
					 return algorithm_clause;
			}
			case 49: // pn_external_clause = EXTERNAL.EXTERNAL string_wrapper_opt.string_wrapper pn_external_function_call_opt.pn_external_function_call annotation_opt.a1 SEMICOLON.SEMICOLON annotation_sc_opt.a2
			{
					final Symbol EXTERNAL = _symbols[offset + 1];
					final Symbol _symbol_string_wrapper = _symbols[offset + 2];
					final Opt string_wrapper = (Opt) _symbol_string_wrapper.value;
					final Symbol _symbol_pn_external_function_call = _symbols[offset + 3];
					final Opt pn_external_function_call = (Opt) _symbol_pn_external_function_call.value;
					final Symbol _symbol_a1 = _symbols[offset + 4];
					final Opt a1 = (Opt) _symbol_a1.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					final Symbol _symbol_a2 = _symbols[offset + 6];
					final Opt a2 = (Opt) _symbol_a2.value;
					 return new PN_ExternalClause(string_wrapper,pn_external_function_call,a1,a2);
			}
			case 50: // string_wrapper = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringWrapper(((String)s.value));
			}
			case 51: // annotation_sc = annotation.annotation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return annotation;
			}
			case 52: // pn_external_function_call = parse_access_eq.parse_access_eq ID.id LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol _symbol_parse_access_eq = _symbols[offset + 1];
					final ParseAccess parse_access_eq = (ParseAccess) _symbol_parse_access_eq.value;
					final Symbol id = _symbols[offset + 2];
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_arg_list = _symbols[offset + 4];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new PN_ExternalFunctionCall(new Opt(parse_access_eq),
	                                      new IdDecl(((String)id.value)),arg_list);
			}
			case 53: // pn_external_function_call = ID.id LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_arg_list = _symbols[offset + 3];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new PN_ExternalFunctionCall(new Opt(),
	                                      new IdDecl(((String)id.value)),arg_list);
			}
			case 54: // parse_access_eq = parse_access.parse_access ASSIGN.ASSIGN
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol ASSIGN = _symbols[offset + 2];
					 return parse_access;
			}
			case 55: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 5];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        return base_class_decl;
			}
			case 56: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer replaceable.replaceable base_class_decl.base_class_decl constraining_clause_opt.constraining_clause comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_replaceable = _symbols[offset + 5];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 6];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 7];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					final Symbol _symbol_comment = _symbols[offset + 8];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 9];
					 base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        base_class_decl.setReplaceableOpt(new Opt(replaceable));
        base_class_decl.setConstrainingClauseOpt(constraining_clause);
        base_class_decl.setConstrainingClauseComment(comment);
        return base_class_decl;
			}
			case 57: // element = extends_clause.extends_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_extends_clause = _symbols[offset + 1];
					final PN_ExtendsClause extends_clause = (PN_ExtendsClause) _symbol_extends_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return extends_clause;
			}
			case 58: // element = import_clause.import_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_import_clause = _symbols[offset + 1];
					final ImportClause import_clause = (ImportClause) _symbol_import_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return import_clause;
			}
			case 59: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access array_subscripts_opt.array_subscripts component_list.component_list SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 5];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 6];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 7];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 8];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 9];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_component_list = _symbols[offset + 10];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol SEMICOLON = _symbols[offset + 11];
					 return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            new Opt(),
            new Comment(new Opt(), new Opt()));
			}
			case 60: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer replaceable.replaceable type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access array_subscripts_opt.array_subscripts component_list.component_list constraining_clause_opt.constraining_clause comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_replaceable = _symbols[offset + 5];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 6];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 7];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 8];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 9];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 10];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_component_list = _symbols[offset + 11];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 12];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					final Symbol _symbol_comment = _symbols[offset + 13];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 14];
					 return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(replaceable),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            constraining_clause,comment);
			}
			case 61: // element = annotation.annotation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new ElementAnnotation(annotation);
			}
			case 62: // element = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BadElement();
			}
			case 63: // constraining_clause = CONSTRAINEDBY.CONSTRAINEDBY class_access.class_access class_modification_opt.class_modification
			{
					final Symbol CONSTRAINEDBY = _symbols[offset + 1];
					final Symbol _symbol_class_access = _symbols[offset + 2];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 3];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					 return new ConstrainingClause(class_access,class_modification);
			}
			case 64: // extends_clause = EXTENDS.EXTENDS class_access.class_access class_modification_opt.class_modification annotation_opt.annotation
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_class_access = _symbols[offset + 2];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 3];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_annotation = _symbols[offset + 4];
					final Opt annotation = (Opt) _symbol_annotation.value;
					 return new PN_ExtendsClause(class_access,class_modification,annotation);
			}
			case 65: // import_clause = IMPORT.IMPORT parse_access_simple.parse_access_simple comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_parse_access_simple = _symbols[offset + 2];
					final Access parse_access_simple = (Access) _symbol_parse_access_simple.value;
					final Symbol _symbol_comment = _symbols[offset + 3];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ImportClauseQualified(parse_access_simple,comment);
			}
			case 66: // import_clause = IMPORT.IMPORT parse_access_unqualified_simple.parse_access_unqualified_simple comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_parse_access_unqualified_simple = _symbols[offset + 2];
					final Access parse_access_unqualified_simple = (Access) _symbol_parse_access_unqualified_simple.value;
					final Symbol _symbol_comment = _symbols[offset + 3];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ImportClauseUnqualified(parse_access_unqualified_simple,comment);
			}
			case 67: // import_clause = IMPORT.IMPORT id_decl.alias ASSIGN.ASSIGN parse_access_simple.parse_access_simple comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_alias = _symbols[offset + 2];
					final IdDecl alias = (IdDecl) _symbol_alias.value;
					final Symbol ASSIGN = _symbols[offset + 3];
					final Symbol _symbol_parse_access_simple = _symbols[offset + 4];
					final Access parse_access_simple = (Access) _symbol_parse_access_simple.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ImportClauseRename(parse_access_simple,comment,alias);
			}
			case 68: // array_subscripts = LBRACK.LBRACK subscript_list.subscript_list RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_subscript_list = _symbols[offset + 2];
					final List subscript_list = (List) _symbol_subscript_list.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new ArraySubscripts(subscript_list);
			}
			case 69: // subscript_list = subscript.subscript
			{
					final Symbol _symbol_subscript = _symbols[offset + 1];
					final Subscript subscript = (Subscript) _symbol_subscript.value;
					 return new List().add(subscript);
			}
			case 70: // subscript_list = subscript_list.subscript_list COMMA.COMMA subscript.subscript
			{
					final Symbol _symbol_subscript_list = _symbols[offset + 1];
					final List subscript_list = (List) _symbol_subscript_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_subscript = _symbols[offset + 3];
					final Subscript subscript = (Subscript) _symbol_subscript.value;
					 subscript_list.add(subscript);
                                      return subscript_list;
			}
			case 71: // subscript = COLON.COLON
			{
					final Symbol COLON = _symbols[offset + 1];
					 return new ColonSubscript();
			}
			case 72: // subscript = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ExpSubscript(exp);
			}
			case 73: // component_list = pn_component_decl.pn_component_decl
			{
					final Symbol _symbol_pn_component_decl = _symbols[offset + 1];
					final PN_ComponentDecl pn_component_decl = (PN_ComponentDecl) _symbol_pn_component_decl.value;
					 return new List().add(pn_component_decl);
			}
			case 74: // component_list = component_list.component_list COMMA.COMMA pn_component_decl.pn_component_decl
			{
					final Symbol _symbol_component_list = _symbols[offset + 1];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_pn_component_decl = _symbols[offset + 3];
					final PN_ComponentDecl pn_component_decl = (PN_ComponentDecl) _symbol_pn_component_decl.value;
					 component_list.add(pn_component_decl);
                                                      return component_list;
			}
			case 75: // pn_component_decl = id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification conditional_attribute_opt.conditional_attribute comment.comment
			{
					final Symbol _symbol_comp_name = _symbols[offset + 1];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 3];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_conditional_attribute = _symbols[offset + 4];
					final Opt conditional_attribute = (Opt) _symbol_conditional_attribute.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new PN_ComponentDecl(comp_name,array_subscripts,modification,conditional_attribute,comment);
			}
			case 76: // conditional_attribute = IF.IF exp.exp
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ConditionalAttribute(exp);
			}
			case 77: // type_prefix_flow = FLOW.FLOW
			{
					final Symbol FLOW = _symbols[offset + 1];
					 return new Flow();
			}
			case 78: // equation_clause = EQUATION.EQUATION abstract_equation_opt_list.abstract_equation
			{
					final Symbol EQUATION = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new EquationClause(abstract_equation);
			}
			case 79: // equation_clause = INITIAL_EQUATION.INITIAL_EQUATION abstract_equation_opt_list.abstract_equation
			{
					final Symbol INITIAL_EQUATION = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 //System.out.println("equation_clause"); 
  					     for (int i=0;i<abstract_equation.getNumChild();i++)
  					     	((AbstractEquation)abstract_equation.getChild(i)).setAbstractEquationModifier(new Initial()); 
                                                 return new EquationClause(abstract_equation);
			}
			case 80: // algorithm_clause = ALGORITHM.ALGORITHM abstract_algorithm_list.abstract_algorithm_list
			{
					final Symbol ALGORITHM = _symbols[offset + 1];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 2];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					 return new AlgorithmClause(abstract_algorithm_list);
			}
			case 81: // algorithm_clause = INITIAL_ALGORITHM.INITIAL_ALGORITHM abstract_algorithm_list.abstract_algorithm_list
			{
					final Symbol INITIAL_ALGORITHM = _symbols[offset + 1];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 2];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					 for (int i=0;i<abstract_algorithm_list.getNumChild();i++)
  												     	((AbstractAlgorithm)abstract_algorithm_list.getChild(i)).setInitial(new Initial()); 
                                                     return new AlgorithmClause(abstract_algorithm_list);
			}
			case 82: // abstract_algorithm_list = 
			{
					 return new List();
			}
			case 83: // abstract_algorithm_list = abstract_algorithm.abstract_algorithm
			{
					final Symbol _symbol_abstract_algorithm = _symbols[offset + 1];
					final AbstractAlgorithm abstract_algorithm = (AbstractAlgorithm) _symbol_abstract_algorithm.value;
					 return new List().add(abstract_algorithm);
			}
			case 84: // abstract_algorithm_list = abstract_algorithm_list.abstract_algorithm_list abstract_algorithm.abstract_algorithm
			{
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 1];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					final Symbol _symbol_abstract_algorithm = _symbols[offset + 2];
					final AbstractAlgorithm abstract_algorithm = (AbstractAlgorithm) _symbol_abstract_algorithm.value;
					 abstract_algorithm_list.add(abstract_algorithm); 
                                                 return abstract_algorithm_list;
			}
			case 85: // modification = complete_modification.complete_modification
			{
					final Symbol _symbol_complete_modification = _symbols[offset + 1];
					final CompleteModification complete_modification = (CompleteModification) _symbol_complete_modification.value;
					 return complete_modification;
			}
			case 86: // modification = value_modification.value_modification
			{
					final Symbol _symbol_value_modification = _symbols[offset + 1];
					final ValueModification value_modification = (ValueModification) _symbol_value_modification.value;
					 return value_modification;
			}
			case 87: // complete_modification = class_modification.class_modification value_modification_opt.value_modification
			{
					final Symbol _symbol_class_modification = _symbols[offset + 1];
					final ClassModification class_modification = (ClassModification) _symbol_class_modification.value;
					final Symbol _symbol_value_modification = _symbols[offset + 2];
					final Opt value_modification = (Opt) _symbol_value_modification.value;
					 return new CompleteModification(class_modification,value_modification);
			}
			case 88: // value_modification = ASSIGN.ASSIGN exp.exp
			{
					final Symbol ASSIGN = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ValueModification(exp);
			}
			case 89: // value_modification = COLON.COLON ASSIGN.ASSIGN exp.exp
			{
					final Symbol COLON = _symbols[offset + 1];
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ValueModification(exp);
			}
			case 90: // class_modification = LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_argument_list = _symbols[offset + 2];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ClassModification(argument_list);
			}
			case 91: // argument_list = argument.argument
			{
					final Symbol _symbol_argument = _symbols[offset + 1];
					final Argument argument = (Argument) _symbol_argument.value;
					 return new List().add(argument);
			}
			case 92: // argument_list = argument_list.argument_list COMMA.COMMA argument.argument
			{
					final Symbol _symbol_argument_list = _symbols[offset + 1];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_argument = _symbols[offset + 3];
					final Argument argument = (Argument) _symbol_argument.value;
					 argument_list.add(argument); 
                                       return argument_list;
			}
			case 93: // argument = each_opt.each final__opt.final_ parse_access.parse_access modification_opt.modification string_comment_opt.string_comment
			{
					final Symbol _symbol_each = _symbols[offset + 1];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_parse_access = _symbols[offset + 3];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol _symbol_modification = _symbols[offset + 4];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_string_comment = _symbols[offset + 5];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					 return new ComponentModification(each, 
                                                    final_,
                                                    parse_access,
                                                    modification,
                                                    string_comment);
			}
			case 94: // argument = each_opt.each final__opt.final_ replaceable.replaceable base_class_decl.base_class_decl constraining_clause_opt.constraining_clause
			{
					final Symbol _symbol_each = _symbols[offset + 1];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 3];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 4];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 5];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
   							pa.setStart(base_class_decl.getName().getStart());
   							pa.setEnd(base_class_decl.getName().getEnd());
   							base_class_decl.setConstrainingClauseOpt(constraining_clause);
   							base_class_decl.setReplaceable(replaceable);
   							ClassRedeclare cdr = new ClassRedeclare(each,
                                                         final_,
                                                         pa,
                                                         base_class_decl); 
                            return cdr;
			}
			case 95: // argument = each_opt.each final__opt.final_ replaceable.replaceable type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment constraining_clause_opt.constraining_clause
			{
					final Symbol _symbol_each = _symbols[offset + 1];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 3];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 4];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 5];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 6];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 7];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_comp_name = _symbols[offset + 8];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 9];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 10];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 11];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 12];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setStart(comp_name.getStart());
   				pa.setEnd(comp_name.getEnd());
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment)),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
                                         return cdr;
			}
			case 96: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ base_class_decl.base_class_decl
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 4];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					 ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
                      pa.setStart(base_class_decl.getName().getStart());       
                      pa.setEnd(base_class_decl.getName().getEnd());       
                      base_class_decl.setRedeclare(new Redeclare());
                      pa.setStart(base_class_decl.getName().getStart());
                      ClassRedeclare cdr = new ClassRedeclare(each,
                                                              final_,
                                                              pa,
                                                              base_class_decl);
                      return cdr;
			}
			case 97: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 4];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 5];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 6];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 7];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_comp_name = _symbols[offset + 8];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 9];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 10];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 11];
					final Comment comment = (Comment) _symbol_comment.value;
					 ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setStart(comp_name.getStart());
   				pa.setEnd(array_subscripts.getEnd());
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment)),
                                                               new Opt(),
                                                               new Comment(new Opt(),new Opt()))); 
                 return cdr;
			}
			case 98: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ replaceable.replaceable base_class_decl.base_class_decl constraining_clause_opt.constraining_clause
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 4];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 5];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 6];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 base_class_decl.setConstrainingClauseOpt(constraining_clause);
                            base_class_decl.setReplaceable(replaceable);
                            ClassAccess ca = new ClassAccess(base_class_decl.getName().getID());
                            ca.setStart(base_class_decl.getName().getStart());
                            ca.setEnd(base_class_decl.getName().getEnd());
                             return new  ClassRedeclare(each,
                                                         final_,
                                                         ca,
                                                         base_class_decl);
			}
			case 99: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ replaceable.replaceable type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment constraining_clause_opt.constraining_clause
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 4];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 5];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 6];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 7];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 8];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_comp_name = _symbols[offset + 9];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 10];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 11];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 12];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 13];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
       pa.setStart(comp_name.getStart());
       pa.setEnd(comp_name.getEnd());
       PN_ComponentRedeclare cr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment)),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
        return cr;
			}
			case 100: // argument = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadArgument();
			}
			case 101: // annotation = ANNOTATION.ANNOTATION class_modification.class_modification
			{
					final Symbol ANNOTATION = _symbols[offset + 1];
					final Symbol _symbol_class_modification = _symbols[offset + 2];
					final ClassModification class_modification = (ClassModification) _symbol_class_modification.value;
					 return new ParseAnnotation(class_modification);
			}
			case 102: // abstract_equation = simple_expression.left ASSIGN.ASSIGN exp.right comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_left = _symbols[offset + 1];
					final Exp left = (Exp) _symbol_left.value;
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_right = _symbols[offset + 3];
					final Exp right = (Exp) _symbol_right.value;
					final Symbol _symbol_comment = _symbols[offset + 4];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new Equation(new Opt(),comment,left,right);
			}
			case 103: // abstract_equation = conditional_equation_e.conditional_equation_e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_conditional_equation_e = _symbols[offset + 1];
					final ConditionalEquationE conditional_equation_e = (ConditionalEquationE) _symbol_conditional_equation_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return conditional_equation_e;
			}
			case 104: // abstract_equation = for_clause_e.for_clause_e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_for_clause_e = _symbols[offset + 1];
					final ForClauseE for_clause_e = (ForClauseE) _symbol_for_clause_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return for_clause_e;
			}
			case 105: // abstract_equation = when_clause_e.when_clause_e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_when_clause_e = _symbols[offset + 1];
					final WhenClauseE when_clause_e = (WhenClauseE) _symbol_when_clause_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return when_clause_e;
			}
			case 106: // abstract_equation = CONNECT.CONNECT LPAREN.LPAREN parse_access.a COMMA.COMMA parse_access.b RPAREN.RPAREN comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol CONNECT = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Access b = (Access) _symbol_b.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ConnectClause(new Opt(), comment,a,b);
			}
			case 107: // abstract_equation = function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new EquationFunctionCall(new Opt(),comment,function_call);
			}
			case 108: // abstract_equation = function_call_simple.function_call_simple comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call_simple = _symbols[offset + 1];
					final FunctionCall function_call_simple = (FunctionCall) _symbol_function_call_simple.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new EquationFunctionCall(new Opt(),comment, function_call_simple);
			}
			case 109: // abstract_equation = annotation.annotation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new EquationAnnotation(new Opt(),new Comment(new Opt(), new Opt()), annotation);
			}
			case 110: // conditional_equation_e = IF.IF exp.ifexp THEN.THEN abstract_equation_opt_list.abstract_equation else_if_clause_e_opt_list.else_if_clause_e else_equations.else_equations END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final Exp ifexp = (Exp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_if_clause_e = _symbols[offset + 5];
					final List else_if_clause_e = (List) _symbol_else_if_clause_e.value;
					final Symbol _symbol_else_equations = _symbols[offset + 6];
					final List else_equations = (List) _symbol_else_equations.value;
					final Symbol END_IF = _symbols[offset + 7];
					final Symbol _symbol_comment = _symbols[offset + 8];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ConditionalEquationE(new Opt(), comment, ifexp,abstract_equation,else_if_clause_e,else_equations);
			}
			case 111: // else_if_clause_e = ELSEIF.ELSEIF exp.eiexp THEN.THEN abstract_equation_opt_list.abstract_equation
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_eiexp = _symbols[offset + 2];
					final Exp eiexp = (Exp) _symbol_eiexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new ElseIfClauseE(eiexp,abstract_equation);
			}
			case 112: // else_equations = 
			{
					 return new List();
			}
			case 113: // else_equations = ELSE.ELSE abstract_equation_opt_list.abstract_equation
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return abstract_equation;
			}
			case 114: // for_clause_e = FOR.FOR for_indices.for_indices LOOP.LOOP abstract_equation_opt_list.abstract_equation END_FOR.END_FOR comment.comment
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol END_FOR = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ForClauseE(new Opt(), comment, for_indices,abstract_equation);
			}
			case 115: // for_indices = for_index.for_index
			{
					final Symbol _symbol_for_index = _symbols[offset + 1];
					final ForIndex for_index = (ForIndex) _symbol_for_index.value;
					 return new List().add(for_index);
			}
			case 116: // for_indices = for_indices.for_indices COMMA.COMMA for_index.for_index
			{
					final Symbol _symbol_for_indices = _symbols[offset + 1];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_for_index = _symbols[offset + 3];
					final ForIndex for_index = (ForIndex) _symbol_for_index.value;
					 for_indices.add(for_index);
                                     return for_indices;
			}
			case 117: // for_index = id_decl.id_decl for_in_exp_opt.for_in_exp
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final IdDecl id_decl = (IdDecl) _symbol_id_decl.value;
					final Symbol _symbol_for_in_exp = _symbols[offset + 2];
					final Opt for_in_exp = (Opt) _symbol_for_in_exp.value;
					 ForIndex f = new ForIndex(new ForIndexDecl(new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new ParseAccess("Integer",new Opt()),
                                                              new Opt(),
                                                              new PublicVisibilityType(),
                                                              id_decl,
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt()),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt())),
                                                              for_in_exp); 
                          f.setStart(id_decl.getStart()); 
                          f.setEnd(for_in_exp.getEnd()); 
                          return f;
			}
			case 118: // for_in_exp = IN.IN exp.e
			{
					final Symbol IN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 119: // when_clause_e = WHEN.WHEN exp.wexp THEN.THEN abstract_equation_opt_list.abstract_equation else_when_clause_e_opt_list.else_when_clause_e END_WHEN.END_WHEN comment.comment
			{
					final Symbol WHEN = _symbols[offset + 1];
					final Symbol _symbol_wexp = _symbols[offset + 2];
					final Exp wexp = (Exp) _symbol_wexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_when_clause_e = _symbols[offset + 5];
					final List else_when_clause_e = (List) _symbol_else_when_clause_e.value;
					final Symbol END_WHEN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new WhenClauseE(new Opt(), comment, wexp,abstract_equation,else_when_clause_e);
			}
			case 120: // else_when_clause_e = ELSEWHEN.ELSEWHEN exp.ewexp THEN.THEN abstract_equation_opt_list.abstract_equation
			{
					final Symbol ELSEWHEN = _symbols[offset + 1];
					final Symbol _symbol_ewexp = _symbols[offset + 2];
					final Exp ewexp = (Exp) _symbol_ewexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new ElseWhenClauseE(ewexp,abstract_equation);
			}
			case 121: // abstract_algorithm = parse_access.parse_access COLON.COLON ASSIGN.ASSIGN exp.right comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol COLON = _symbols[offset + 2];
					final Symbol ASSIGN = _symbols[offset + 3];
					final Symbol _symbol_right = _symbols[offset + 4];
					final Exp right = (Exp) _symbol_right.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 return new Algorithm(new Opt(),comment,parse_access,right);
			}
			case 122: // abstract_algorithm = LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN COLON.COLON ASSIGN.ASSIGN function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_arg_list = _symbols[offset + 2];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol COLON = _symbols[offset + 4];
					final Symbol ASSIGN = _symbols[offset + 5];
					final Symbol _symbol_function_call = _symbols[offset + 6];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new AlgorithmFunctionAssign(new Opt(),comment,new OutputExpressionList(arg_list), function_call);
			}
			case 123: // abstract_algorithm = LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN COLON.COLON ASSIGN.ASSIGN function_call_simple.function_call_simple comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_arg_list = _symbols[offset + 2];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol COLON = _symbols[offset + 4];
					final Symbol ASSIGN = _symbols[offset + 5];
					final Symbol _symbol_function_call_simple = _symbols[offset + 6];
					final FunctionCall function_call_simple = (FunctionCall) _symbol_function_call_simple.value;
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new AlgorithmFunctionAssign(new Opt(), comment,new OutputExpressionList(arg_list), function_call_simple);
			}
			case 124: // abstract_algorithm = RETURN.RETURN comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new AlgorithmReturn(new Opt(),comment);
			}
			case 125: // abstract_algorithm = conditional_equation_a.conditional_equation_a SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_conditional_equation_a = _symbols[offset + 1];
					final ConditionalEquationA conditional_equation_a = (ConditionalEquationA) _symbol_conditional_equation_a.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return conditional_equation_a;
			}
			case 126: // abstract_algorithm = for_clause_a.for_clause_a SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_for_clause_a = _symbols[offset + 1];
					final ForClauseA for_clause_a = (ForClauseA) _symbol_for_clause_a.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return for_clause_a;
			}
			case 127: // abstract_algorithm = when_clause_a.when_clause_a SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_when_clause_a = _symbols[offset + 1];
					final WhenClauseA when_clause_a = (WhenClauseA) _symbol_when_clause_a.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return when_clause_a;
			}
			case 128: // abstract_algorithm = while_clause.while_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_while_clause = _symbols[offset + 1];
					final WhileClause while_clause = (WhileClause) _symbol_while_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return while_clause;
			}
			case 129: // abstract_algorithm = function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new AlgorithmFunctionCall(new Opt(),comment, function_call);
			}
			case 130: // abstract_algorithm = function_call_simple.function_call_simple comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call_simple = _symbols[offset + 1];
					final FunctionCall function_call_simple = (FunctionCall) _symbol_function_call_simple.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new AlgorithmFunctionCall(new Opt(),comment, function_call_simple);
			}
			case 131: // abstract_algorithm = annotation.annotation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new AlgorithmAnnotation(new Opt(),new Comment(new Opt(),new Opt()), annotation);
			}
			case 132: // conditional_equation_a = IF.IF exp.ifexp THEN.THEN abstract_algorithm_list.abstract_algorithm_list else_if_clause_a_opt_list.else_if_clause_a else_algorithms.else_algorithms END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final Exp ifexp = (Exp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 4];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					final Symbol _symbol_else_if_clause_a = _symbols[offset + 5];
					final List else_if_clause_a = (List) _symbol_else_if_clause_a.value;
					final Symbol _symbol_else_algorithms = _symbols[offset + 6];
					final List else_algorithms = (List) _symbol_else_algorithms.value;
					final Symbol END_IF = _symbols[offset + 7];
					final Symbol _symbol_comment = _symbols[offset + 8];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ConditionalEquationA(new Opt(), comment, ifexp,abstract_algorithm_list,else_if_clause_a,else_algorithms);
			}
			case 133: // else_if_clause_a = ELSEIF.ELSEIF exp.eiexp THEN.THEN abstract_algorithm_list.abstract_algorithm_list
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_eiexp = _symbols[offset + 2];
					final Exp eiexp = (Exp) _symbol_eiexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 4];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					 return new ElseIfClauseA(eiexp,abstract_algorithm_list);
			}
			case 134: // else_algorithms = 
			{
					 return new List();
			}
			case 135: // else_algorithms = ELSE.ELSE abstract_algorithm_list.abstract_algorithm_list
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 2];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					 return abstract_algorithm_list;
			}
			case 136: // for_clause_a = FOR.FOR for_indices.for_indices LOOP.LOOP abstract_algorithm_list.abstract_algorithm_list END_FOR.END_FOR comment.comment
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 4];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					final Symbol END_FOR = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ForClauseA(new Opt(), comment, for_indices,abstract_algorithm_list);
			}
			case 137: // when_clause_a = WHEN.WHEN exp.wexp THEN.THEN abstract_algorithm_list.abstract_algorithm_list else_when_clause_a_opt_list.else_when_clause_a END_WHEN.END_WHEN comment.comment
			{
					final Symbol WHEN = _symbols[offset + 1];
					final Symbol _symbol_wexp = _symbols[offset + 2];
					final Exp wexp = (Exp) _symbol_wexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 4];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					final Symbol _symbol_else_when_clause_a = _symbols[offset + 5];
					final List else_when_clause_a = (List) _symbol_else_when_clause_a.value;
					final Symbol END_WHEN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new WhenClauseA(new Opt(), comment, wexp,abstract_algorithm_list,else_when_clause_a);
			}
			case 138: // else_when_clause_a = ELSEWHEN.ELSEWHEN exp.ewexp THEN.THEN abstract_algorithm_list.abstract_algorithm_list
			{
					final Symbol ELSEWHEN = _symbols[offset + 1];
					final Symbol _symbol_ewexp = _symbols[offset + 2];
					final Exp ewexp = (Exp) _symbol_ewexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 4];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					 return new ElseWhenClauseA(ewexp,abstract_algorithm_list);
			}
			case 139: // while_clause = WHILE.WHILE exp.whileexp LOOP.LOOP abstract_algorithm_list.abstract_algorithm_list END_WHILE.END_WHILE comment.comment
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol _symbol_whileexp = _symbols[offset + 2];
					final Exp whileexp = (Exp) _symbol_whileexp.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_abstract_algorithm_list = _symbols[offset + 4];
					final List abstract_algorithm_list = (List) _symbol_abstract_algorithm_list.value;
					final Symbol END_WHILE = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new WhileClause(new Opt(),comment,whileexp,abstract_algorithm_list);
			}
			case 140: // exp = simple_expression.simple_expression
			{
					final Symbol _symbol_simple_expression = _symbols[offset + 1];
					final Exp simple_expression = (Exp) _symbol_simple_expression.value;
					 return simple_expression;
			}
			case 141: // exp = if_exp.if_exp
			{
					final Symbol _symbol_if_exp = _symbols[offset + 1];
					final IfExp if_exp = (IfExp) _symbol_if_exp.value;
					 return if_exp;
			}
			case 142: // if_exp = IF.IF exp.ifexp THEN.THEN exp.thenexp else_if_exp_opt_list.else_if_exp else_exp.else_exp
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final Exp ifexp = (Exp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_thenexp = _symbols[offset + 4];
					final Exp thenexp = (Exp) _symbol_thenexp.value;
					final Symbol _symbol_else_if_exp = _symbols[offset + 5];
					final List else_if_exp = (List) _symbol_else_if_exp.value;
					final Symbol _symbol_else_exp = _symbols[offset + 6];
					final Exp else_exp = (Exp) _symbol_else_exp.value;
					 return new IfExp(ifexp,thenexp,else_if_exp,else_exp);
			}
			case 143: // else_if_exp = ELSEIF.ELSEIF exp.eiexp THEN.THEN exp.thenexp
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_eiexp = _symbols[offset + 2];
					final Exp eiexp = (Exp) _symbol_eiexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_thenexp = _symbols[offset + 4];
					final Exp thenexp = (Exp) _symbol_thenexp.value;
					 return new ElseIfExp(eiexp,thenexp);
			}
			case 144: // else_exp = ELSE.ELSE exp.e
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 145: // simple_expression = log_exp.log_exp range_opt.r1 range_opt.r2
			{
					final Symbol _symbol_log_exp = _symbols[offset + 1];
					final Exp log_exp = (Exp) _symbol_log_exp.value;
					final Symbol _symbol_r1 = _symbols[offset + 2];
					final Opt r1 = (Opt) _symbol_r1.value;
					final Symbol _symbol_r2 = _symbols[offset + 3];
					final Opt r2 = (Opt) _symbol_r2.value;
					 if (r1.getNumChild()==0 && r2.getNumChild()==0)
                      	return log_exp;
                      else {
                      	RangeExp r = new RangeExp();
                      	r.addExp(log_exp);
                      	if (r1.getNumChild()>0)
                      		r.addExp((Exp)r1.getChildNoTransform(0));
                      	if (r2.getNumChild()>0)
                      		r.addExp((Exp)r2.getChildNoTransform(0));	
                      	return r;
                      }
			}
			case 146: // range = COLON.COLON log_exp.log_exp
			{
					final Symbol COLON = _symbols[offset + 1];
					final Symbol _symbol_log_exp = _symbols[offset + 2];
					final Exp log_exp = (Exp) _symbol_log_exp.value;
					 return log_exp;
			}
			case 147: // log_exp = log_exp.a OR.OR log_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new OrExp(a,b);
			}
			case 148: // log_exp = log_exp.a AND.AND log_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new AndExp(a,b);
			}
			case 149: // log_exp = NOT.NOT relation.a
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					 return new NotExp(a);
			}
			case 150: // log_exp = relation.relation
			{
					final Symbol _symbol_relation = _symbols[offset + 1];
					final Exp relation = (Exp) _symbol_relation.value;
					 return relation;
			}
			case 151: // relation = artm_exp.a LT.LT artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new LtExp(a,b);
			}
			case 152: // relation = artm_exp.a LEQ.LEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol LEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new LeqExp(a,b);
			}
			case 153: // relation = artm_exp.a GT.GT artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new GtExp(a,b);
			}
			case 154: // relation = artm_exp.a GEQ.GEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol GEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new GeqExp(a,b);
			}
			case 155: // relation = artm_exp.a EQ.EQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new EqExp(a,b);
			}
			case 156: // relation = artm_exp.a NEQ.NEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol NEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new NeqExp(a,b);
			}
			case 157: // relation = artm_exp.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					 return a;
			}
			case 158: // artm_exp = additive_exp.additive_exp
			{
					final Symbol _symbol_additive_exp = _symbols[offset + 1];
					final Exp additive_exp = (Exp) _symbol_additive_exp.value;
					 return additive_exp;
			}
			case 159: // additive_exp = multiplicative_exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 160: // additive_exp = additive_exp.e1 PLUS.PLUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new AddExp(e1, e2);
			}
			case 161: // additive_exp = additive_exp.e1 MINUS.MINUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new SubExp(e1, e2);
			}
			case 162: // multiplicative_exp = unary_exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 163: // multiplicative_exp = multiplicative_exp.e1 MULT.MULT unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new MulExp(e1, e2);
			}
			case 164: // multiplicative_exp = multiplicative_exp.e1 DIV.DIV unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new DivExp(e1, e2);
			}
			case 165: // unary_exp = pow_exp.pow_exp
			{
					final Symbol _symbol_pow_exp = _symbols[offset + 1];
					final Exp pow_exp = (Exp) _symbol_pow_exp.value;
					 return pow_exp;
			}
			case 166: // unary_exp = MINUS.MINUS unary_exp.unary_exp
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_unary_exp = _symbols[offset + 2];
					final Exp unary_exp = (Exp) _symbol_unary_exp.value;
					 return new NegExp(unary_exp);
			}
			case 167: // unary_exp = PLUS.PLUS unary_exp.unary_exp
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_unary_exp = _symbols[offset + 2];
					final Exp unary_exp = (Exp) _symbol_unary_exp.value;
					 return unary_exp;
			}
			case 168: // pow_exp = primary.primary
			{
					final Symbol _symbol_primary = _symbols[offset + 1];
					final Exp primary = (Exp) _symbol_primary.value;
					 return primary;
			}
			case 169: // pow_exp = primary.a POW.POW primary.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol POW = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return new PowExp(a,e);
			}
			case 170: // primary = UNSIGNED_NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new RealLitExp(((String)n.value));
			}
			case 171: // primary = UNSIGNED_INTEGER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new IntegerLitExp(((String)n.value));
			}
			case 172: // primary = TRUE.TRUE
			{
					final Symbol TRUE = _symbols[offset + 1];
					 return new BooleanLitExpTrue();
			}
			case 173: // primary = FALSE.FALSE
			{
					final Symbol FALSE = _symbols[offset + 1];
					 return new BooleanLitExpFalse();
			}
			case 174: // primary = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringLitExp(((String)s.value));
			}
			case 175: // primary = access_expression.access_expression
			{
					final Symbol _symbol_access_expression = _symbols[offset + 1];
					final AccessExp access_expression = (AccessExp) _symbol_access_expression.value;
					 return access_expression;
			}
			case 176: // primary = LPAREN.LPAREN exp.a RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return a;
			}
			case 177: // primary = LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_arg_list = _symbols[offset + 2];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new OutputExpressionList(arg_list);
			}
			case 178: // primary = function_call.function_call
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					 return function_call;
			}
			case 179: // primary = function_call_simple.function_call_simple
			{
					final Symbol _symbol_function_call_simple = _symbols[offset + 1];
					final FunctionCall function_call_simple = (FunctionCall) _symbol_function_call_simple.value;
					 return function_call_simple;
			}
			case 180: // primary = LBRACK.LBRACK matrix.matrix RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_matrix = _symbols[offset + 2];
					final Matrix matrix = (Matrix) _symbol_matrix.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return matrix;
			}
			case 181: // primary = LBRACE.LBRACE function_arguments.function_arguments RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_function_arguments = _symbols[offset + 2];
					final FunctionArguments function_arguments = (FunctionArguments) _symbol_function_arguments.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayConstructor(function_arguments);
			}
			case 182: // primary = TIME.TIME
			{
					final Symbol TIME = _symbols[offset + 1];
					 return new TimeExp();
			}
			case 183: // primary = END.END
			{
					final Symbol END = _symbols[offset + 1];
					 return new EndExp();
			}
			case 184: // function_call = parse_access.parse_access LPAREN.LPAREN function_arguments_opt.function_arguments RPAREN.RPAREN
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_function_arguments = _symbols[offset + 3];
					final Opt function_arguments = (Opt) _symbol_function_arguments.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new FunctionCall(parse_access,function_arguments);
			}
			case 185: // function_call_simple = ID.id LPAREN.LPAREN function_arguments_opt.function_arguments RPAREN.RPAREN
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_function_arguments = _symbols[offset + 3];
					final Opt function_arguments = (Opt) _symbol_function_arguments.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 ParseAccess p = new ParseAccess(((String)id.value),new Opt());
                                             p.setStart(function_arguments.getStart());
                                             p.setEnd(function_arguments.getEnd());
                                             return new FunctionCall(p,function_arguments);
			}
			case 186: // function_call_simple = INITIAL.INITIAL LPAREN.LPAREN function_arguments_opt.function_arguments RPAREN.RPAREN
			{
					final Symbol INITIAL = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_function_arguments = _symbols[offset + 3];
					final Opt function_arguments = (Opt) _symbol_function_arguments.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 ParseAccess p = new ParseAccess("initial",new Opt());
                                                p.setStart(function_arguments.getStart());
                                             	p.setEnd(function_arguments.getEnd());
                                                return new FunctionCall(p,function_arguments);
			}
			case 187: // function_arguments = arg_list_p.arg_list_p function_arguments_for_clause.function_arguments_for_clause
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol _symbol_function_arguments_for_clause = _symbols[offset + 2];
					final List function_arguments_for_clause = (List) _symbol_function_arguments_for_clause.value;
					 return new FunctionArguments(arg_list_p,function_arguments_for_clause, new List());
			}
			case 188: // function_arguments = arg_list_p.arg_list_p COMMA.COMMA named_arguments.named_arguments
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_named_arguments = _symbols[offset + 3];
					final List named_arguments = (List) _symbol_named_arguments.value;
					 return new FunctionArguments(arg_list_p,new List(),named_arguments);
			}
			case 189: // function_arguments = named_arguments.named_arguments
			{
					final Symbol _symbol_named_arguments = _symbols[offset + 1];
					final List named_arguments = (List) _symbol_named_arguments.value;
					 return new FunctionArguments(new List(),new List(),named_arguments);
			}
			case 190: // function_arguments_for_clause = 
			{
					 return new List();
			}
			case 191: // function_arguments_for_clause = FOR.FOR for_indices.for_indices
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					 return for_indices;
			}
			case 192: // named_arguments = named_argument.named_argument
			{
					final Symbol _symbol_named_argument = _symbols[offset + 1];
					final NamedArgument named_argument = (NamedArgument) _symbol_named_argument.value;
					 return new List().add(named_argument);
			}
			case 193: // named_arguments = named_arguments.named_arguments COMMA.COMMA named_argument.named_argument
			{
					final Symbol _symbol_named_arguments = _symbols[offset + 1];
					final List named_arguments = (List) _symbol_named_arguments.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_named_argument = _symbols[offset + 3];
					final NamedArgument named_argument = (NamedArgument) _symbol_named_argument.value;
					 return named_arguments.add(named_argument);
			}
			case 194: // named_argument = ID.id ASSIGN.ASSIGN exp.exp
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new NamedArgument(new ParseAccess(((String)id.value),new Opt()),exp);
			}
			case 195: // matrix = exp_list.exp_list
			{
					final Symbol _symbol_exp_list = _symbols[offset + 1];
					final ExpList exp_list = (ExpList) _symbol_exp_list.value;
					 Matrix m = new Matrix();
                                 m.addExpList(exp_list); 
                                 return m;
			}
			case 196: // matrix = matrix.matrix SEMICOLON.SEMICOLON exp_list.exp_list
			{
					final Symbol _symbol_matrix = _symbols[offset + 1];
					final Matrix matrix = (Matrix) _symbol_matrix.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					final Symbol _symbol_exp_list = _symbols[offset + 3];
					final ExpList exp_list = (ExpList) _symbol_exp_list.value;
					 matrix.addExpList(exp_list); 
                                 return matrix;
			}
			case 197: // exp_list = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 ExpList e = new ExpList();
                           e.addExp(exp); 
                           return e;
			}
			case 198: // exp_list = exp_list.exp_list COMMA.COMMA exp.exp
			{
					final Symbol _symbol_exp_list = _symbols[offset + 1];
					final ExpList exp_list = (ExpList) _symbol_exp_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 exp_list.addExp(exp); 
                           return exp_list;
			}
			case 199: // arg_list = 
			{
					 return new List();
			}
			case 200: // arg_list = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 //System.out.println("arg_list at line " + exp.beginLine());
                           return new List().add(exp);
			}
			case 201: // arg_list = arg_list.arg_list COMMA.COMMA exp.exp
			{
					final Symbol _symbol_arg_list = _symbols[offset + 1];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 arg_list.add(exp); 
                           return arg_list;
			}
			case 202: // arg_list_p = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 //System.out.println("arg_list at line " + exp.beginLine());
                           return new List().add(exp);
			}
			case 203: // arg_list_p = arg_list_p.arg_list_p COMMA.COMMA exp.exp
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 arg_list_p.add(exp); 
                           return arg_list_p;
			}
			case 204: // comment = string_comment_opt.string_comment annotation_opt.annotation
			{
					final Symbol _symbol_string_comment = _symbols[offset + 1];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_annotation = _symbols[offset + 2];
					final Opt annotation = (Opt) _symbol_annotation.value;
					 return new Comment(string_comment,annotation);
			}
			case 205: // string_comment = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringComment(((String)s.value));
			}
			case 206: // string_comment = string_comment.string_comment PLUS.PLUS STRING.s
			{
					final Symbol _symbol_string_comment = _symbols[offset + 1];
					final StringComment string_comment = (StringComment) _symbol_string_comment.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol s = _symbols[offset + 3];
					 string_comment.setComment(string_comment.getComment().concat(((String)s.value)));
                                    return string_comment;
			}
			case 207: // id_decl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdDecl(((String)id.value));
			}
			case 208: // access_expression = parse_access.parse_access
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					 return new AccessExp(parse_access);
			}
			case 209: // parse_access = parse_access_single.parse_access_single
			{
					final Symbol _symbol_parse_access_single = _symbols[offset + 1];
					final ParseAccess parse_access_single = (ParseAccess) _symbol_parse_access_single.value;
					 return parse_access_single;
			}
			case 210: // parse_access = parse_access_single.parse_access_single DOT.DOT parse_access.parse_access
			{
					final Symbol _symbol_parse_access_single = _symbols[offset + 1];
					final ParseAccess parse_access_single = (ParseAccess) _symbol_parse_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_parse_access = _symbols[offset + 3];
					final Access parse_access = (Access) _symbol_parse_access.value;
					 return new Dot(parse_access_single.getID(),parse_access_single,parse_access);
			}
			case 211: // parse_access_single = ID.id array_subscripts_opt.array_subscripts
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					 return new ParseAccess(((String)id.value),array_subscripts);
			}
			case 212: // parse_access_simple = parse_access_single_simple.parse_access_single_simple
			{
					final Symbol _symbol_parse_access_single_simple = _symbols[offset + 1];
					final ParseAccess parse_access_single_simple = (ParseAccess) _symbol_parse_access_single_simple.value;
					 return parse_access_single_simple;
			}
			case 213: // parse_access_simple = parse_access_single_simple.parse_access_single_simple DOT.DOT parse_access_simple.parse_access_simple
			{
					final Symbol _symbol_parse_access_single_simple = _symbols[offset + 1];
					final ParseAccess parse_access_single_simple = (ParseAccess) _symbol_parse_access_single_simple.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_parse_access_simple = _symbols[offset + 3];
					final Access parse_access_simple = (Access) _symbol_parse_access_simple.value;
					 return new Dot(parse_access_single_simple.getID(),parse_access_single_simple,parse_access_simple);
			}
			case 214: // parse_access_single_simple = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new ParseAccess(((String)id.value),new Opt());
			}
			case 215: // parse_access_unqualified_simple = parse_access_single_simple.parse_access_single_simple DOT.DOT MULT.MULT
			{
					final Symbol _symbol_parse_access_single_simple = _symbols[offset + 1];
					final ParseAccess parse_access_single_simple = (ParseAccess) _symbol_parse_access_single_simple.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol MULT = _symbols[offset + 3];
					 return parse_access_single_simple;
			}
			case 216: // parse_access_unqualified_simple = parse_access_single_simple.parse_access_single_simple DOT.DOT parse_access_unqualified_simple.parse_access_unqualified_simple
			{
					final Symbol _symbol_parse_access_single_simple = _symbols[offset + 1];
					final ParseAccess parse_access_single_simple = (ParseAccess) _symbol_parse_access_single_simple.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_parse_access_unqualified_simple = _symbols[offset + 3];
					final Access parse_access_unqualified_simple = (Access) _symbol_parse_access_unqualified_simple.value;
					 return new Dot("",parse_access_single_simple,parse_access_unqualified_simple);
			}
			case 217: // class_access = class_access_single.class_access_single
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					 return class_access_single;
			}
			case 218: // class_access = class_access_single.class_access_single DOT.DOT class_access.class_access
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_class_access = _symbols[offset + 3];
					final Access class_access = (Access) _symbol_class_access.value;
					 return new Dot("",class_access_single,class_access);
			}
			case 219: // class_access_single = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new ClassAccess(((String)id.value));
			}
			case 220: // constraining_clause_opt = 
			{
					 return new Opt();
			}
			case 221: // constraining_clause_opt = constraining_clause.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ConstrainingClause n = (ConstrainingClause) _symbol_n.value;
					 return new Opt(n);
			}
			case 222: // pn_external_function_call_opt = 
			{
					 return new Opt();
			}
			case 223: // pn_external_function_call_opt = pn_external_function_call.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final PN_ExternalFunctionCall n = (PN_ExternalFunctionCall) _symbol_n.value;
					 return new Opt(n);
			}
			case 224: // class_modification_opt = 
			{
					 return new Opt();
			}
			case 225: // class_modification_opt = class_modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ClassModification n = (ClassModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 226: // type_prefix_input_output_opt = 
			{
					 return new Opt();
			}
			case 227: // type_prefix_input_output_opt = type_prefix_input_output.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypePrefix n = (TypePrefix) _symbol_n.value;
					 return new Opt(n);
			}
			case 228: // type_prefix_variability_opt = 
			{
					 return new Opt();
			}
			case 229: // type_prefix_variability_opt = type_prefix_variability.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypePrefix n = (TypePrefix) _symbol_n.value;
					 return new Opt(n);
			}
			case 230: // else_when_clause_a_opt_list = 
			{
					 return new List();
			}
			case 231: // else_when_clause_a_opt_list = else_when_clause_a_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 232: // else_when_clause_a_list = else_when_clause_a.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElseWhenClauseA n = (ElseWhenClauseA) _symbol_n.value;
					 return new List().add(n);
			}
			case 233: // else_when_clause_a_list = else_when_clause_a_list.l else_when_clause_a.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ElseWhenClauseA n = (ElseWhenClauseA) _symbol_n.value;
					 return l.add(n);
			}
			case 234: // string_wrapper_opt = 
			{
					 return new Opt();
			}
			case 235: // string_wrapper_opt = string_wrapper.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final StringWrapper n = (StringWrapper) _symbol_n.value;
					 return new Opt(n);
			}
			case 236: // outer_opt = 
			{
					 return new Opt();
			}
			case 237: // outer_opt = outer.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Outer n = (Outer) _symbol_n.value;
					 return new Opt(n);
			}
			case 238: // abstract_equation_opt_list = 
			{
					 return new List();
			}
			case 239: // abstract_equation_opt_list = abstract_equation_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 240: // abstract_equation_list = abstract_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final AbstractEquation n = (AbstractEquation) _symbol_n.value;
					 return new List().add(n);
			}
			case 241: // abstract_equation_list = abstract_equation_list.l abstract_equation.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final AbstractEquation n = (AbstractEquation) _symbol_n.value;
					 return l.add(n);
			}
			case 242: // final__opt = 
			{
					 return new Opt();
			}
			case 243: // final__opt = final_.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Final n = (Final) _symbol_n.value;
					 return new Opt(n);
			}
			case 244: // value_modification_opt = 
			{
					 return new Opt();
			}
			case 245: // value_modification_opt = value_modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ValueModification n = (ValueModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 246: // conditional_attribute_opt = 
			{
					 return new Opt();
			}
			case 247: // conditional_attribute_opt = conditional_attribute.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ConditionalAttribute n = (ConditionalAttribute) _symbol_n.value;
					 return new Opt(n);
			}
			case 248: // annotation_sc_opt = 
			{
					 return new Opt();
			}
			case 249: // annotation_sc_opt = annotation_sc.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Annotation n = (Annotation) _symbol_n.value;
					 return new Opt(n);
			}
			case 250: // within_opt = 
			{
					 return new Opt();
			}
			case 251: // within_opt = within.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Within n = (Within) _symbol_n.value;
					 return new Opt(n);
			}
			case 252: // modification_opt = 
			{
					 return new Opt();
			}
			case 253: // modification_opt = modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Modification n = (Modification) _symbol_n.value;
					 return new Opt(n);
			}
			case 254: // else_if_clause_e_opt_list = 
			{
					 return new List();
			}
			case 255: // else_if_clause_e_opt_list = else_if_clause_e_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 256: // else_if_clause_e_list = else_if_clause_e.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElseIfClauseE n = (ElseIfClauseE) _symbol_n.value;
					 return new List().add(n);
			}
			case 257: // else_if_clause_e_list = else_if_clause_e_list.l else_if_clause_e.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ElseIfClauseE n = (ElseIfClauseE) _symbol_n.value;
					 return l.add(n);
			}
			case 258: // else_if_exp_opt_list = 
			{
					 return new List();
			}
			case 259: // else_if_exp_opt_list = else_if_exp_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 260: // else_if_exp_list = else_if_exp.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElseIfExp n = (ElseIfExp) _symbol_n.value;
					 return new List().add(n);
			}
			case 261: // else_if_exp_list = else_if_exp_list.l else_if_exp.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ElseIfExp n = (ElseIfExp) _symbol_n.value;
					 return l.add(n);
			}
			case 262: // else_when_clause_e_opt_list = 
			{
					 return new List();
			}
			case 263: // else_when_clause_e_opt_list = else_when_clause_e_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 264: // else_when_clause_e_list = else_when_clause_e.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElseWhenClauseE n = (ElseWhenClauseE) _symbol_n.value;
					 return new List().add(n);
			}
			case 265: // else_when_clause_e_list = else_when_clause_e_list.l else_when_clause_e.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ElseWhenClauseE n = (ElseWhenClauseE) _symbol_n.value;
					 return l.add(n);
			}
			case 266: // function_arguments_opt = 
			{
					 return new Opt();
			}
			case 267: // function_arguments_opt = function_arguments.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final FunctionArguments n = (FunctionArguments) _symbol_n.value;
					 return new Opt(n);
			}
			case 268: // else_if_clause_a_opt_list = 
			{
					 return new List();
			}
			case 269: // else_if_clause_a_opt_list = else_if_clause_a_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 270: // else_if_clause_a_list = else_if_clause_a.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ElseIfClauseA n = (ElseIfClauseA) _symbol_n.value;
					 return new List().add(n);
			}
			case 271: // else_if_clause_a_list = else_if_clause_a_list.l else_if_clause_a.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final ElseIfClauseA n = (ElseIfClauseA) _symbol_n.value;
					 return l.add(n);
			}
			case 272: // each_opt = 
			{
					 return new Opt();
			}
			case 273: // each_opt = each.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Each n = (Each) _symbol_n.value;
					 return new Opt(n);
			}
			case 274: // redeclare_opt = 
			{
					 return new Opt();
			}
			case 275: // redeclare_opt = redeclare.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Redeclare n = (Redeclare) _symbol_n.value;
					 return new Opt(n);
			}
			case 276: // range_opt = 
			{
					 return new Opt();
			}
			case 277: // range_opt = range.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Exp n = (Exp) _symbol_n.value;
					 return new Opt(n);
			}
			case 278: // string_comment_opt = 
			{
					 return new Opt();
			}
			case 279: // string_comment_opt = string_comment.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final StringComment n = (StringComment) _symbol_n.value;
					 return new Opt(n);
			}
			case 280: // inner_opt = 
			{
					 return new Opt();
			}
			case 281: // inner_opt = inner.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Inner n = (Inner) _symbol_n.value;
					 return new Opt(n);
			}
			case 282: // annotation_opt = 
			{
					 return new Opt();
			}
			case 283: // annotation_opt = annotation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Annotation n = (Annotation) _symbol_n.value;
					 return new Opt(n);
			}
			case 284: // for_in_exp_opt = 
			{
					 return new Opt();
			}
			case 285: // for_in_exp_opt = for_in_exp.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Exp n = (Exp) _symbol_n.value;
					 return new Opt(n);
			}
			case 286: // pn_external_clause_opt = 
			{
					 return new Opt();
			}
			case 287: // pn_external_clause_opt = pn_external_clause.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final PN_ExternalClause n = (PN_ExternalClause) _symbol_n.value;
					 return new Opt(n);
			}
			case 288: // encapsulated_opt = 
			{
					 return new Opt();
			}
			case 289: // encapsulated_opt = encapsulated.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Encapsulated n = (Encapsulated) _symbol_n.value;
					 return new Opt(n);
			}
			case 290: // type_prefix_flow_opt = 
			{
					 return new Opt();
			}
			case 291: // type_prefix_flow_opt = type_prefix_flow.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypePrefix n = (TypePrefix) _symbol_n.value;
					 return new Opt(n);
			}
			case 292: // array_subscripts_opt = 
			{
					 return new Opt();
			}
			case 293: // array_subscripts_opt = array_subscripts.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArraySubscripts n = (ArraySubscripts) _symbol_n.value;
					 return new Opt(n);
			}
			case 294: // partial_opt = 
			{
					 return new Opt();
			}
			case 295: // partial_opt = partial.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Partial n = (Partial) _symbol_n.value;
					 return new Opt(n);
			}
			case 296: // parse_access_opt = 
			{
					 return new Opt();
			}
			case 297: // parse_access_opt = parse_access.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return new Opt(n);
			}
			case 0: // $goal = source_root
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $exp exp
			{
				return _symbols[offset + 2];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
