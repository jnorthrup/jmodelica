/*
    Copyright (C) 2015 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
import org.jmodelica.util.formattedPrint.FormattingInfo;
import org.jmodelica.util.formattedPrint.FormattingItem;
import org.jmodelica.util.formattedPrint.EmptyFormattingItem;
import org.jmodelica.util.formattedPrint.FormattingLocator;
import org.jmodelica.util.formattedPrint.DefaultFormattingItem;
import org.jmodelica.util.formattedPrint.ScannedFormattingItem;
import java.io.ByteArrayOutputStream;
import java.io.PrintStream;
import beaver.Symbol;

aspect FormattedPrint {

    /**
     * Static printer instance.
     */
    static FormattedPrettyPrinter ASTNode.formattedPrettyPrinter = new FormattedPrettyPrinter();

	/**
	 * A pretty printer that prints the AST in code, with the old formatting.
	 */
	public class FormattedPrettyPrinter extends Printer {
		/**
		 * Creates a <code>FormattedPrettyPrinter</code>.
		 */
		public FormattedPrettyPrinter() {
			super("");
		}

		/**
		 * Takes an AST node and prints it using a <code>PrintStream</code>. The formatting that the code that
		 * generated this node is preserved.
		 * @param node the AST node to print.
		 * @param printStream the stream to which the node should be printed.
		 * @param ident not used.
		 */
		@Override
		@SuppressWarnings({"unchecked"})
		public void print(ASTNode node, CodeStream printStream, String ident) {
			node.doPrettyPrintFormatted(this, printStream);
		}

		public String op(FBinExp exp) {
			return operatorFormatted(exp);
		}

		public String operatorFormatted(FBinExp exp) {
			return exp.operatorFormatted();
		}
	}

	public class DefaultFormattingIndentation {
		private String indentation;
		private String currentIndentation;

		public DefaultFormattingIndentation(String indentation) {
			this.indentation = indentation;
			this.currentIndentation = "";
		}

		public void stepIn() {
			currentIndentation += indentation;
		}

		public void stepOut() {
			if (currentIndentation.length() >= indentation.length()) {
				currentIndentation = currentIndentation.substring(0, currentIndentation.length() - indentation.length());
			}
		}

		public String toString() {
			return currentIndentation;
		}
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// ADDING FORMATTING TO AST:
	//
	// This section of the aspect contains attributes and methods for adding formatting to the AST.
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	private FormattingInfo StoredDefinition.formatting = new FormattingInfo();
	protected FormattingItem SourceBaseNode.preFormatting = FormattingItem.NOT_FORMATTED;
	protected FormattingItem SourceBaseNode.insideFormatting = FormattingItem.NOT_FORMATTED;
	protected FormattingItem SourceBaseNode.postFormatting = FormattingItem.NOT_FORMATTED;

	public boolean SourceBaseNode.hasBeenFormatted() {
		return (preFormatting != FormattingItem.NOT_FORMATTED);
	}

	public void StoredDefinition.setFormatting(FormattingInfo formattingInfo) {
		formatting = formattingInfo;
	}

	/**
	 * Propagates the formatting information downwards in the AST if this has not already been done.
	 */
	public void ASTNode.propagateFormatting() {
		getParent().propagateFormatting();
	}

	@Override
	public void SourceBaseNode.propagateFormatting() {
		getParent().propagateFormatting();
	}

	@Override
	public void SourceRoot.propagateFormatting() {
		getProgram().propagateFormatting();
	}
	
	@Override
	public void Program.propagateFormatting() {
		for (StoredDefinition definition : getUnstructuredEntitys())
			definition.propagateFormatting();
	}
	
	@Override
	public void StoredDefinition.propagateFormatting() {
		if (formatting != null) {
			formatting.mergeAdjacentFormattingItems();
			propagateFormatting(formatting);
			formatting = null;
		}
		setDefaultFormatting(new DefaultFormattingIndentation("    "));
	}
	
	protected void ASTNode.propagateFormatting(FormattingInfo formattingInfo) {
		addFormattingInformation(formattingInfo);
		addFormattingRest(formattingInfo);
	}

	/**
	 * Adds formatting information to this AST node and all its children, which can then be used by the method
	 * <code>prettyPrintFormatted</code>.
	 * @param formattingInfo the information to use to format this AST node.
	 */	
	protected void ASTNode.addFormattingInformation(FormattingInfo formattingInfo) {
		for (ASTNode node : this)
			node.addFormattingInformation(formattingInfo);
	}

	inh boolean SourceBaseNode.shouldNotBeFormatted();
	eq ComponentRedeclare.getName().shouldNotBeFormatted() = true;
	eq ClassRedeclare.getName().shouldNotBeFormatted() = true;
	eq EnumClassDecl.getComponentDecl(int i).shouldNotBeFormatted() = !getComponentDecl(i).isEnumLiteral();
	eq BaseNode.getChild().shouldNotBeFormatted() = false;
	
	inh boolean SourceBaseNode.shouldOnlyFormatChildren();
	eq ClassRedeclare.getBaseClassDecl().shouldOnlyFormatChildren() = true;
	eq BaseNode.getChild().shouldOnlyFormatChildren() = false;
	
	@Override
	protected void SourceBaseNode.addFormattingInformation(FormattingInfo formattingInfo) {
		if (hasBeenFormatted() || shouldNotBeFormatted())
			return;
		
		if (formattingInfo != null && !shouldOnlyFormatChildren()) {
			addPreFormatting(formattingInfo);
			addPostFormatting(formattingInfo);
		}
		
		super.addFormattingInformation(formattingInfo);
	}

	@Override
	protected void FullClassDecl.addFormattingInformation(FormattingInfo formattingInfo) {
		super.addFormattingInformation(formattingInfo);
		
		if (formattingInfo != null) {
			for (Clause clause : originalComposition.getClauses()) {
				if (clause instanceof EquationClause || clause instanceof Algorithm) {
					clause.addPreFormatting(formattingInfo);
					clause.addPostFormatting(formattingInfo);
					clause.addInsideFormatting(formattingInfo);
				}
			}
		}
	}

	public void SourceBaseNode.addPreFormatting(FormattingInfo formattingInfo) {
		preFormatting = formattingInfo.getFrontAdjacentFormatting(this);
	}

	public void SourceBaseNode.addPostFormatting(FormattingInfo formattingInfo) {
		postFormatting = formattingInfo.getBackAdjacentFormatting(this);
	}

	@Override
	public void Comment.addPreFormatting(FormattingInfo formattingInfo) {
		preFormatting = FormattingItem.NO_FORMATTING;
	}

	@Override
	public void Comment.addPostFormatting(FormattingInfo formattingInfo) {
		postFormatting = FormattingItem.NO_FORMATTING;
	}

	public void ASTNode.addFormattingRest(FormattingInfo formattingInfo) {
		for (ASTNode childNode : this) {
			childNode.addFormattingRest(formattingInfo);
		}
	}
	
	@Override
	public void SourceBaseNode.addFormattingRest(FormattingInfo formattingInfo) {
		if (shouldNotBeFormatted())
			return;
		preFormatting = formattingInfo.addFormattingRest(preFormatting);
		postFormatting = formattingInfo.addFormattingRest(postFormatting);
		super.addFormattingRest(formattingInfo);
		addInsideFormatting(formattingInfo);
	}

	public void SourceBaseNode.addInsideFormatting(FormattingInfo formattingInfo) {
		if (insideFormatting != FormattingItem.NOT_FORMATTED)
			return;
		FormattingLocator locator = insideFormattingLocator();
		if (locator == null)
			return;
		insideFormatting = formattingInfo.getInsideFormatting(locator);
	}

	public FormattingLocator SourceBaseNode.insideFormattingLocator() {
		return null;
	}

	@Override
	public FormattingLocator IfExp.insideFormattingLocator() {
		return new FormattingLocator(FormattingLocator.Locator.START, getLine(getElseExp().getStart()), getColumn(getElseExp().getStart()) + 4);
	}

	@Override
	public FormattingLocator EndDecl.insideFormattingLocator() {
		return new FormattingLocator(FormattingLocator.Locator.START, getLine(getStart()), getColumn(getStart()) + 3);
	}

	@Override
	public FormattingLocator InitialEquationClause.insideFormattingLocator() {
		return new FormattingLocator(FormattingLocator.Locator.START, getLine(getStart()), getColumn(getStart()) + 7);
	}

	@Override
	public FormattingLocator Algorithm.insideFormattingLocator() {
		return new FormattingLocator(FormattingLocator.Locator.START, getLine(getStart()), getColumn(getStart()) + 7);
	}

    @Override
    public FormattingLocator ExpandableConnector.insideFormattingLocator() {
        return new FormattingLocator(FormattingLocator.Locator.START, getLine(getStart()), getColumn(getStart()) + 10);
    }

    @Override
    public FormattingLocator OperatorFunction.insideFormattingLocator() {
        return new FormattingLocator(FormattingLocator.Locator.START, getLine(getStart()), getColumn(getStart()) + 8);
    }

    @Override
    public FormattingLocator OperatorRecord.insideFormattingLocator() {
        return new FormattingLocator(FormattingLocator.Locator.START, getLine(getStart()), getColumn(getStart()) + 8);
    }

	@Override
	public FormattingLocator EnumClassDecl.insideFormattingLocator() {
		return new FormattingLocator(FormattingLocator.Locator.END, getLine(getSymbol().getStart()), getColumn(getSymbol().getStart()) - 1);
	}
	
	public FormattingLocator Within.insideFormattingLocator() {
		return new FormattingLocator(FormattingLocator.Locator.END, getLine(getEnd()), getColumn(getEnd()) - 1);
	}
	

	@Override
	public FormattingLocator ForStmt.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 4);
	}

	@Override
	public FormattingLocator ForClauseE.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 4);
	}

	@Override
	public FormattingLocator WhileStmt.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 6);
	}

	@Override
	public FormattingLocator IfEquation.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 3);
	}

	@Override
	public FormattingLocator IfStmt.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 3);
	}

	@Override
	public FormattingLocator WhenEquation.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 5);
	}

	@Override
	public FormattingLocator WhenStmt.insideFormattingLocator() {
		int line;
		int column;

		if (getComment().hasStringComment()) {
			StringComment stringComment = getComment().getStringComment();
			if (stringComment.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) stringComment.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) stringComment.preFormatting).getStartColumn();
			} else {
				line = getLine(stringComment.getStart());
				column = getColumn(stringComment.getStart());
			}
		} else if (getComment().hasAnnotation()) {
			Annotation annotation = getComment().getAnnotation();
			if (annotation.preFormatting.isScanned()) {
				line = ((ScannedFormattingItem) annotation.preFormatting).getStartLine();
				column = ((ScannedFormattingItem) annotation.preFormatting).getStartColumn();
			} else {
				line = getLine(annotation.getStart());
				column = getColumn(annotation.getStart());
			}
		} else {
			line = getLine(getEnd());
			column = getColumn(getEnd());
		}

		return new FormattingLocator(FormattingLocator.Locator.END, line, column - 5);
	}

	@Override
	public FormattingLocator FunctionCallEquation.insideFormattingLocator() {
		if (getNumLeft() == 0)
			return null;
		int start = getLeft(getNumLeft() - 1).getEnd();
		return new FormattingLocator(FormattingLocator.Locator.START, getLine(start), getColumn(start) + 2);
	}
	
	@Override
	public FormattingLocator FunctionCallStmt.insideFormattingLocator() {
		if (getNumLeft() == 0)
			return null;
		int start = getLeft(getNumLeft() - 1).getEnd();
		return new FormattingLocator(FormattingLocator.Locator.START, getLine(start), getColumn(start) + 2);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// DEFAULT FORMATTING:
	//
	// Here, some default formatting is set to different nodes in the AST. This is used for when the nodes do not
	// come from a scanned source file, but have been generated in other ways.
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	protected void ASTNode.setDefaultFormatting(DefaultFormattingIndentation indentation) {
		for (ASTNode node : this) {
			node.setDefaultFormatting(indentation);
		}
	}

	@Override
	protected void SourceBaseNode.setDefaultFormatting(DefaultFormattingIndentation indentation) {
		if (hasBeenFormatted()) {
			for (ASTNode node : this) {
				node.setDefaultFormatting(indentation);
			}
			return;
		}
		boolean addedIndentation = setDefaultFormattingHelper(indentation);
		for (ASTNode node : this) {
			node.setDefaultFormatting(indentation);
		}
		if (addedIndentation) {
			indentation.stepOut();
		}
	}

	protected boolean SourceBaseNode.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		return false;
	}

	@Override
	protected boolean Within.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		if (hasPackageName()) {
			getPackageName().preFormatting = new DefaultFormattingItem(" ");
		}
		postFormatting = new DefaultFormattingItem("\n");
		return false;
	}

	@Override
	protected boolean Encapsulated.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Partial.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Redeclare.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Final.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Inner.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Outer.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Replaceable.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Restriction.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean FullClassDecl.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		indentation.stepIn();
		if (hasStringComment()) {
			if (!getName().hasBeenFormatted()) {
				getName().postFormatting = new DefaultFormattingItem(indentation.toString());
			}
			if (!getStringComment().hasBeenFormatted()) {
				getStringComment().postFormatting = new DefaultFormattingItem("\n");
			}
		}

		for (Clause clause : originalComposition.getClauses()) {
			if ((clause instanceof EquationClause || clause instanceof Algorithm) && !clause.hasBeenFormatted()) {
				clause.setDefaultFormattingHelper(indentation);
			}
		}

		if (hasAnnotation()) {
		    Annotation annotation = getAnnotation();
			if (!annotation.hasBeenFormatted()) {
				annotation.preFormatting = new DefaultFormattingItem(indentation.toString());
			}
		}
		return true;
	}

	@Override
	protected boolean EquationClause.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		indentation.stepOut();
		preFormatting = new DefaultFormattingItem(indentation.toString());
		indentation.stepIn();
		insideFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean Algorithm.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		indentation.stepOut();
		preFormatting = new DefaultFormattingItem(indentation.toString());
		indentation.stepIn();
		insideFormatting = new DefaultFormattingItem(" ");
		if (getNumStatement() > 0) {
			getStatement(0).preFormatting = new DefaultFormattingItem("\n");
		}
		return false;
	}

	@Override
	protected boolean Statement.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		preFormatting = preFormatting.mergeItems(FormattingItem.Adjacency.BACK, new DefaultFormattingItem(indentation.toString()));
		postFormatting = postFormatting.mergeItems(FormattingItem.Adjacency.FRONT, new DefaultFormattingItem("\n"));
		return false;
	}

	@Override
	protected boolean ForStmt.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		super.setDefaultFormattingHelper(indentation);
		return false;
	}

	@Override
	protected boolean ForStmtList.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		if (getNumStmt() > 0) {
			getStmt(0).preFormatting = new DefaultFormattingItem("\n");
			getStmt(getNumStmt() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
		}
		indentation.stepIn();
		return true;
	}
	
	@Override
	protected boolean ForIndex.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		getForIndexDecl().getName().preFormatting = new DefaultFormattingItem(" ");
		getForIndexDecl().getName().postFormatting = new DefaultFormattingItem(" ");
		if (hasExp()) {
			getExp().postFormatting = new DefaultFormattingItem(" ");
		}
		return false;
	}

	@Override
	protected boolean WhileStmt.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		getTest().preFormatting = new DefaultFormattingItem(" ");
		getTest().postFormatting = new DefaultFormattingItem(" ");
		if (getNumWhileStmt() > 0) {
			getWhileStmt(0).preFormatting = new DefaultFormattingItem("\n");
			getWhileStmt(getNumWhileStmt() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
		}
		super.setDefaultFormattingHelper(indentation);
		indentation.stepIn();
		return true;
	}

	@Override
	protected boolean IfStmt.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		super.setDefaultFormattingHelper(indentation);
		indentation.stepIn();
		return true;
	}

	@Override
	protected boolean WhenStmt.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		super.setDefaultFormattingHelper(indentation);
		indentation.stepIn();
		return true;
	}

	@Override
	protected boolean IfWhenClause.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		getTest().preFormatting = new DefaultFormattingItem(" ");
		getTest().postFormatting = new DefaultFormattingItem(" ");
		if (getNumStatement() > 0) {
			getStatement(0).preFormatting = new DefaultFormattingItem("\n");
			indentation.stepOut();
			getStatement(getNumStatement() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
			indentation.stepIn();
		}
		return super.setDefaultFormattingHelper(indentation);
	}

	@Override
	protected boolean AbstractEquation.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		preFormatting = inheritFormatting(indentation);
		if (getComment().hasStringComment()) {
			getComment().getStringComment().preFormatting = new DefaultFormattingItem(" ");
		} else if (getComment().hasAnnotation()) {
			getComment().getAnnotation().preFormatting = new DefaultFormattingItem(" ");
		}
		postFormatting = postFormatting.mergeItems(FormattingItem.Adjacency.FRONT, new DefaultFormattingItem("\n"));
		return false;
	}

	private FormattingItem AbstractEquation.inheritFormatting(DefaultFormattingIndentation indentation) {
		if (getParent() instanceof List && getParent().getParent() instanceof FullClassDecl) {
			List<Clause> clauseList = (List<Clause>) ((FullClassDecl) getParent().getParent()).originalComposition.getClauses();

			for (Clause clause : clauseList) {
				if (clause instanceof EquationClause) {
					int thisIndex = ((EquationClause) clause).getAbstractEquations().getIndexOfChild(this);
					if (thisIndex > 0) {
						return ((EquationClause) clause).getAbstractEquations().getChild(thisIndex - 1).preFormatting.copyWhitepacesFromFormatting();
					} else if (thisIndex == 0) {
						return new DefaultFormattingItem("\n" + indentation.toString());
					}
				}
			}
		}

		return preFormatting.mergeItems(FormattingItem.Adjacency.BACK, new DefaultFormattingItem(indentation.toString()));
	}

	@Override
	protected boolean ForClauseE.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		if (getNumAbstractEquation() > 0) {
			getAbstractEquation(0).preFormatting = new DefaultFormattingItem("\n");
			getAbstractEquation(getNumAbstractEquation() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
		}
		super.setDefaultFormattingHelper(indentation);
		indentation.stepIn();
		return true;
	}

	@Override
	protected boolean IfWhenEquation.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		getTest().preFormatting = new DefaultFormattingItem(" ");
		getTest().postFormatting = new DefaultFormattingItem(" ");

		if (getNumAbstractEquation() > 0) {
			getAbstractEquation(0).preFormatting = new DefaultFormattingItem("\n");
			if (!hasElse()) {
				getAbstractEquation(getNumAbstractEquation() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
			}
		}

		if (getParent() instanceof Opt && getClass() == getParent().getParent().getClass()) {
			indentation.stepOut();
			super.setDefaultFormattingHelper(indentation);
			indentation.stepIn();
			if (!hasElse()) {
				indentation.stepOut();
				getAbstractEquation(getNumAbstractEquation() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
				indentation.stepIn();
			}
			postFormatting = FormattingItem.NO_FORMATTING;
			return false;
		}

		super.setDefaultFormattingHelper(indentation);
		indentation.stepIn();
		return true;
	}

	@Override
	protected boolean ElseEquation.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		indentation.stepOut();
		boolean addedIndentation = super.setDefaultFormattingHelper(indentation);
		indentation.stepIn();
		postFormatting = FormattingItem.NO_FORMATTING;

		if (getNumAbstractEquation() > 0) {
			getAbstractEquation(0).preFormatting = new DefaultFormattingItem("\n");
			indentation.stepOut();
			getAbstractEquation(getNumAbstractEquation() - 1).postFormatting = new DefaultFormattingItem(indentation.toString());
			indentation.stepIn();
		}

		return addedIndentation;
	}

    @Override
    protected boolean ExpandableConnector.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
        insideFormatting = new DefaultFormattingItem(" ");
        return false;
    }

    @Override
    protected boolean OperatorRecord.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
        insideFormatting = new DefaultFormattingItem(" ");
        return false;
    }

    @Override
    protected boolean OperatorFunction.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
        insideFormatting = new DefaultFormattingItem(" ");
        return false;
    }

	@Override
	protected boolean IfExp.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		if (getElseExp() instanceof IfExp) {
			insideFormatting = FormattingItem.NO_FORMATTING;
		} else {
			insideFormatting = new DefaultFormattingItem(" ");
		}

		getIfExp().preFormatting = new DefaultFormattingItem(" ");
		getIfExp().postFormatting = new DefaultFormattingItem(" ");
		getThenExp().preFormatting = new DefaultFormattingItem(" ");
		getThenExp().postFormatting = new DefaultFormattingItem(" ");
		return super.setDefaultFormattingHelper(indentation);
	}

	@Override
	protected boolean Each.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		postFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean ExtendsClause.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		preFormatting = new DefaultFormattingItem(" ");
		getSuper().preFormatting = new DefaultFormattingItem(" ");
		postFormatting = new DefaultFormattingItem("\n");
		return false;
	}

	@Override
	protected boolean ImportClause.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		preFormatting = new DefaultFormattingItem(" ");
		getPackageName().preFormatting = new DefaultFormattingItem(" ");
		if (getComment().hasStringComment() || getComment().hasAnnotation()) {
			getPackageName().postFormatting = new DefaultFormattingItem(" ");
		}
		postFormatting = new DefaultFormattingItem("\n");
		return false;
	}

	@Override
	protected boolean ComponentDecl.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		FormattingItem inheritedPreFormatting = inheritFormatting(indentation);
		if (hasRedeclare()) {
			getRedeclare().preFormatting = inheritedPreFormatting;
			getRedeclare().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasFinal()) {
			getFinal().preFormatting = inheritedPreFormatting;
			getFinal().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasInner()) {
			getInner().preFormatting = inheritedPreFormatting;
			getInner().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasOuter()) {
			getOuter().preFormatting = inheritedPreFormatting;
			getOuter().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasReplaceable()) {
			getReplaceable().preFormatting = inheritedPreFormatting;
			getReplaceable().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasTypePrefixFlow()) {
			getTypePrefixFlow().preFormatting = inheritedPreFormatting;
			getTypePrefixFlow().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasTypePrefixVariability()) {
			getTypePrefixVariability().preFormatting = inheritedPreFormatting;
			getTypePrefixVariability().postFormatting = new DefaultFormattingItem(" ");
		} else if (hasTypePrefixInputOutput()) {
			getTypePrefixInputOutput().preFormatting = inheritedPreFormatting;
			getTypePrefixInputOutput().postFormatting = new DefaultFormattingItem(" ");
		} else {
			getClassName().preFormatting = inheritedPreFormatting;
		}

		getClassName().postFormatting = new DefaultFormattingItem(" ");
		if (getComment().hasStringComment() || getComment().hasAnnotation()) {
			if (hasModification()) {
				getModification().postFormatting = new DefaultFormattingItem(" ");
			} else {
				getName().postFormatting = new DefaultFormattingItem(" ");
			}
		}
		postFormatting = new DefaultFormattingItem("\n");
		return false;
	}

	private FormattingItem ComponentDecl.inheritFormatting(DefaultFormattingIndentation indentation) {
		if (getParent() instanceof List && getParent().getParent() instanceof FullClassDecl) {
			List<Clause> clauseList = (List<Clause>) ((FullClassDecl) getParent().getParent()).originalComposition.getClauses();
			int thisIndex = clauseList.getIndexOfChild(this);
			if (thisIndex > 0 && clauseList.getChild(thisIndex - 1) instanceof ComponentDecl) {
				ComponentDecl componentToInheritFrom = (ComponentDecl) clauseList.getChild(thisIndex - 1);

				if (componentToInheritFrom.hasRedeclare()) {
					return componentToInheritFrom.getRedeclare().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasFinal()) {
					return componentToInheritFrom.getFinal().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasInner()) {
					return componentToInheritFrom.getInner().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasOuter()) {
					return componentToInheritFrom.getOuter().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasReplaceable()) {
					return componentToInheritFrom.getReplaceable().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasTypePrefixFlow()) {
					return componentToInheritFrom.getTypePrefixFlow().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasTypePrefixVariability()) {
					return componentToInheritFrom.getTypePrefixVariability().preFormatting.copyWhitepacesFromFormatting();
				} else if (componentToInheritFrom.hasTypePrefixInputOutput()) {
					return componentToInheritFrom.getTypePrefixInputOutput().preFormatting.copyWhitepacesFromFormatting();
				} else {
					return componentToInheritFrom.getClassName().preFormatting.copyWhitepacesFromFormatting();
				}
			}
		}
		return new DefaultFormattingItem(indentation.toString());
	}

	@Override
	protected boolean Comment.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		if (hasStringComment() && hasAnnotation()) {
			getStringComment().preFormatting = new DefaultFormattingItem(" ");
		}
		return false;
	}

	@Override
	protected boolean ParseAnnotation.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		getClassModification().preFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	@Override
	protected boolean EndDecl.setDefaultFormattingHelper(DefaultFormattingIndentation indentation) {
		insideFormatting = new DefaultFormattingItem(" ");
		return false;
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// PRETTY PRINT AST WITH PRESERVED FORMATTING:
	//
	// This section of the aspect contains methods used for printing the AST with its original formatting
	// preserved.
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	/**
	 * Pretty prints this AST node and all its children, with preserved formatting.
	 * @return a string, consisting of the formatted code printed from this AST node.
	 */
	public String ASTNode.prettyPrintFormatted() {
		OutputStream outputStream = new ByteArrayOutputStream();
		CodeStream printStream = new CodeStream(outputStream);
		prettyPrintFormatted(formattedPrettyPrinter, printStream);

		return outputStream.toString();
	}

	/**
	 * Pretty prints this AST node and all its childred, with preserved formatting.
	 * @param printer the printer to use when pretty printing.
	 * @param printStream the stream, to which the AST node should be printed.
	 */
	
	public void ASTNode.prettyPrintFormatted(Printer printer, CodeStream printStream) {
		propagateFormatting();
		doPrettyPrintFormatted(printer, printStream);
	}

	void ASTNode.doPrettyPrintFormatted(Printer printer, CodeStream printStream) {
		for (ASTNode childNode: this) {
			childNode.doPrettyPrintFormatted(printer, printStream);
		}
	}

	void SourceBaseNode.doPrettyPrintFormatted(Printer printer, CodeStream printStream) {
		printStream.print(preFormatting);
		prettyPrintFormattedHelper(printer, printStream);
		printStream.print(postFormatting);
	}

	void AbstractEquation.doPrettyPrintFormatted(Printer printer, CodeStream printStream) {
		printStream.print(preFormatting);
		prettyPrintFormattedHelper(printer, printStream);
		printStream.print(";");
		printStream.print(postFormatting);
	}

	void Statement.doPrettyPrintFormatted(Printer printer, CodeStream printStream) {
		printStream.print(preFormatting);
		prettyPrintFormattedHelper(printer, printStream);
		printStream.print(";");
		printStream.print(postFormatting);
	}

	void AlgorithmAnnotation.doPrettyPrintFormatted(Printer printer, CodeStream printStream) {
		printStream.print(getAnnotation().preFormatting);
		getAnnotation().prettyPrintFormattedHelper(printer, printStream);
		printStream.print(";");
		printStream.print(getAnnotation().postFormatting);
	}
	
	void SourceBaseNode.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		for (ASTNode childNode: this) {
			childNode.doPrettyPrintFormatted(printer, printStream);
		}
	}

	void StoredDefinition.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasWithin()) {
			getWithin().doPrettyPrintFormatted(printer, printStream);
		}
		for (Element element : getElements()) {
			printer.print(element, printStream, "");
		}
	}

	void Within.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("within");
		printStream.print(insideFormatting);
		if (hasPackageName()) {
			getPackageName().doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print(";");
	}

	void Encapsulated.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("encapsulated");
	}

	void Partial.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("partial");
	}

	void Redeclare.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("redeclare");
	}

	void Final.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("final");
	}

	void Inner.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("inner");
	}

	void Outer.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("outer");
	}

	void Replaceable.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("replaceable");
	}

	void Restriction.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(this);
	}

	void IdDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(getID());
	}

	void ExtendsClauseShortClass.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasTypePrefixInputOutput())
			getTypePrefixInputOutput().doPrettyPrintFormatted(printer, printStream);
		getSuper().doPrettyPrintFormatted(printer, printStream);

		if (hasArraySubscripts()) {
			getArraySubscripts().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasClassModification()) {
			getClassModification().doPrettyPrintFormatted(printer, printStream);
		}
		getComment().prettyPrintFormattedHelper(printer, printStream);
	}

	void Access.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(name());
	}

	void ArrayAccess.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(name());
		if (hasArraySubscripts()) {
			getArraySubscripts().doPrettyPrintFormatted(printer, printStream);
		}
	}

	void Dot.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getAccesss().prettyPrintWithSep(printer, printStream, null, ".");
	}

	void ArraySubscripts.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (getNumSubscript() == 0) {
			return;
		}

		printStream.print("[");
		for (int i = 0; i < getNumSubscript(); i++) {
			getSubscript(i).doPrettyPrintFormatted(printer, printStream);
			if (i + 1 < getNumSubscript()) {
				printStream.print(",");
			}
		}
		printStream.print("]");
	}

	void ArrayConstructor.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("{");
		getFunctionArguments().doPrettyPrintFormatted(printer, printStream);
		printStream.print("}");
	}

	void Matrix.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("[");
		for (int i = 0; i < getNumRow(); i++) {
			getRow(i).doPrettyPrintFormatted(printer, printStream);

			if (i + 1 < getNumRow()) {
				printStream.print(";");
			}
		}
		printStream.print("]");
	}

	void MatrixRow.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		for (int i = 0; i < getNumExp(); i++) {
			getExp(i).doPrettyPrintFormatted(printer, printStream);

			if (i + 1 < getNumExp()) {
				printStream.print(",");
			}
		}
	}    

	void ClassModification.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("(");
		if (getNumArgument() > 0) {
			getArgument(0).doPrettyPrintFormatted(printer, printStream);
		}
		for (int i = 1; i < getNumArgument(); i++) {
			printStream.print(",");
			getArgument(i).doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print(")");
	}

	void Each.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("each");
	}

	void ConstrainingClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("constrainedby");
		getAccess().doPrettyPrintFormatted(printer, printStream);
		if (hasClassModification()) {
			getClassModification().doPrettyPrintFormatted(printer, printStream);
		}
	}

	void ShortClassDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		prettyPrintFormattedHelper(printer, printStream, new Opt<Each>(), getFinalOpt());
		printStream.print(';');
	}
	
	void FullClassDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		prettyPrintFormattedHelper(printer, printStream, new Opt<Each>(), getFinalOpt());
	}
	
	void BaseClassDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream, Opt<Each> each_, Opt<Final> final_) {
		if (hasRedeclare()) {
			getRedeclare().doPrettyPrintFormatted(printer, printStream);
		}
		if (each_.getNumChild() == 1) {
			each_.getChild(0).doPrettyPrintFormatted(printer, printStream);
		}
		if (final_.getNumChild() == 1) {
			final_.getChild(0).doPrettyPrintFormatted(printer, printStream);
		}
		if (hasInner()) {
			getInner().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasOuter()) {
			getOuter().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasReplaceable()) {
			getReplaceable().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasEncapsulated()) {
			getEncapsulated().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasPartial()) {
			getPartial().doPrettyPrintFormatted(printer, printStream);
		}
		getRestriction().doPrettyPrintFormatted(printer, printStream);
		prettyPrintFormattedDecl(printer, printStream);
	}
	
	void BaseClassDecl.prettyPrintFormattedDecl(Printer printer, CodeStream printStream) {}

	void ShortClassDecl.prettyPrintFormattedDecl(Printer printer, CodeStream printStream) {
		getName().doPrettyPrintFormatted(printer, printStream);
		printStream.print("=");
		getExtendsClauseShortClass().doPrettyPrintFormatted(printer, printStream);
		if (hasConstrainingClause()) {
			getConstrainingClause().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasConstrainingClauseComment()) {
			getConstrainingClauseComment().doPrettyPrintFormatted(printer, printStream);
		}
	}
	void FullClassDecl.prettyPrintFormattedDecl(Printer printer, CodeStream printStream) {
		if (prettyPrintFormatedShouldHaveExtends())
			printStream.print("extends");
		getName().doPrettyPrintFormatted(printer, printStream);
		if (prettyPrintFormatedShouldHaveExtends() && getNumSuper() == 1 && getSuper(0).hasClassModification()) {
			getSuper(0).getClassModification().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasStringComment()) {
			getStringComment().doPrettyPrintFormatted(printer, printStream);
		}

		for (Clause clause : originalComposition.getClauses()) {
			clause.doPrettyPrintFormatted(printer, printStream);
		}

		if (hasExternalClause()) {
			getExternalClause().doPrettyPrintFormatted(printer, printStream);
		}
		
		getEndDecl().doPrettyPrintFormatted(printer, printStream);
	}

	syn boolean FullClassDecl.prettyPrintFormatedShouldHaveExtends() = false;
	eq ExtendClassDecl.prettyPrintFormatedShouldHaveExtends() = true;

	void EnumClassDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasEncapsulated()) {
			getEncapsulated().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasPartial()) {
			getPartial().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasRedeclare()) {
			getRedeclare().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasFinal()) {
			getFinal().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasInner()) {
			getInner().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasOuter()) {
			getOuter().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasReplaceable()) {
			getReplaceable().doPrettyPrintFormatted(printer, printStream);
		}
		getRestriction().doPrettyPrintFormatted(printer, printStream);
		getName().doPrettyPrintFormatted(printer, printStream);
		printStream.print('=');
		printStream.print(insideFormatting);
		printStream.print("enumeration");
		printStream.print('(');
		boolean first = true;
		for (ComponentDecl item : getComponentDecls()) {
			if (!item.isEnumLiteral())
				continue;
			if (!first)
				printStream.print(',');
			first = false;
			item.doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print(')');
		if (hasStringComment())
			getStringComment().doPrettyPrintFormatted(printer, printStream);
		if (hasAnnotation())
			getAnnotation().doPrettyPrintFormatted(printer, printStream);
		printStream.print(';');
	}
	
	public void FullClassDecl.addNewComponentDecl(ComponentDecl componentDecl) {
		Stack<Clause> clauseStack = new Stack<Clause>();

		for (int i = originalComposition.getNumClause() - 1; i >= 0; i--) {
			Clause clause = originalComposition.getClause(i);
			if (clause instanceof ComponentDecl && ((ComponentDecl) clause).isPublic() == componentDecl.isPublic()) {
				break;
			}
			clauseStack.push(clause);
			originalComposition.getClauses().removeChild(i);
		}

		originalComposition.addClause(componentDecl);

		while (!clauseStack.isEmpty()) {
			originalComposition.addClause(clauseStack.pop());
		}

		addComponentDecl(componentDecl);
	}

	public void FullClassDecl.addNewEquation(AbstractEquation equation) {
		for (int i = originalComposition.getNumClause() - 1; i >= 0; i--) {
			Clause clause = originalComposition.getClause(i);
			if (clause instanceof EquationClause && ((EquationClause) clause).getAbstractEquation(0).isInitial() == equation.isInitial()) {
				EquationClause equationClause = (EquationClause) clause;
				Stack<AbstractEquation> equationStack = new Stack<AbstractEquation>();
				boolean foundGoodPosition = false;
				for (int j = equationClause.getNumAbstractEquation() - 1; j >= 0; j--) {
					AbstractEquation currentEquation = equationClause.getAbstractEquation(j);
					if (currentEquation.getClass() == equation.getClass()) {
						equationStack.push(equation);
						foundGoodPosition = true;
						break;
					}
					equationStack.push(currentEquation);
					equationClause.getAbstractEquations().removeChild(j);
				}

				while (!equationStack.isEmpty()) {
					equationClause.addAbstractEquation(equationStack.pop());
				}
				if (!foundGoodPosition) {
					equationClause.addAbstractEquation(equation);
				}
				addEquation(equation);
				return;
			}
		}

		List<AbstractEquation> abstractEquationList = new List<AbstractEquation>();
		abstractEquationList.add(equation);
		originalComposition.addClause(new EquationClause(abstractEquationList));
		addEquation(equation);
	}

	void ExtendsClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("extends");
		getSuper().doPrettyPrintFormatted(printer, printStream);
		if (hasClassModification()) {
			getClassModification().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasAnnotation())
			getAnnotation().prettyPrintFormattedHelper(printer, printStream);
		printStream.print(";");
	}

	void ImportClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("import");
		getPackageName().doPrettyPrintFormatted(printer, printStream);
		getComment().doPrettyPrintFormatted(printer, printStream);
		printStream.print(";");
	}

	void ImportClauseUnqualified.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("import");
		getPackageName().doPrettyPrintFormatted(printer, printStream);
		printStream.print(".*");
		getComment().doPrettyPrintFormatted(printer, printStream);
		printStream.print(";");
	}

	void ImportClauseRename.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("import");
		getIdDecl().doPrettyPrintFormatted(printer, printStream);
		printStream.print("=");
		getPackageName().doPrettyPrintFormatted(printer, printStream);
		getComment().doPrettyPrintFormatted(printer, printStream);
		printStream.print(";");
	}

	void CompleteModification.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getClassModification().doPrettyPrintFormatted(printer, printStream);
		if (hasValueModification()) {
			getValueModification().doPrettyPrintFormatted(printer, printStream);
		}
	}

	void ValueModification.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("=");
		getExp().doPrettyPrintFormatted(printer, printStream);
	}

	void ElementModification.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasEach()) {
			getEach().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasFinal()) {
			getFinal().doPrettyPrintFormatted(printer, printStream);
		}
		getName().doPrettyPrintFormatted(printer, printStream);
		if (hasModification()) {
			getModification().doPrettyPrintFormatted(printer, printStream);
		}
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void ClassRedeclare.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getBaseClassDecl().prettyPrintFormattedHelper(printer, printStream, getEachOpt(), getFinalOpt());
	}

	void ComponentRedeclare.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getComponentDecl().prettyPrintFormattedHelper(printer, printStream, getEachOpt(), getFinalOpt());
	}

	void EquationClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("equation");

		for (AbstractEquation abstractEquation : getAbstractEquations()) {
			abstractEquation.doPrettyPrintFormatted(printer, printStream);
		}
	}
	
	void InitialEquationClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("initial");
		printStream.print(insideFormatting);
		super.prettyPrintFormattedHelper(printer, printStream);
	}

	void Algorithm.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasInitial()) {
			printStream.print("initial");
			printStream.print(insideFormatting);
		}
		printStream.print("algorithm");

		for (Statement statement : getStatements()) {
			statement.doPrettyPrintFormatted(printer, printStream);
		}
	}

	void BreakStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("break");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void ReturnStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("return");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void WhileStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("while");
		getTest().doPrettyPrintFormatted(printer, printStream);
		printStream.print("loop");
		for (Statement statement : getWhileStmts()) {
			statement.doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print("end" + insideFormatting + "while");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void ForStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("for");
		for (int i = 0; i < getNumForIndex(); i++) {
			getForIndex(i).doPrettyPrintFormatted(printer, printStream);
			if (i + 1 < getNumForIndex()) {
				printStream.print(",");
			}
		}
		printStream.print("loop");
		getForStmtList().doPrettyPrintFormatted(printer, printStream);
		printStream.print("end" + insideFormatting + "for");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}
	
	void ForStmtList.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		for (Statement stmt : getStmts()) {
			stmt.doPrettyPrintFormatted(printer, printStream);
		}
	}

	void WhenStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("when");
		for (int i = 0; i < getNumIfWhenClause(); i++) {
			getIfWhenClause(i).doPrettyPrintFormatted(printer, printStream);
			if (i + 1 < getNumIfWhenClause()) {
				printStream.print("elsewhen");
			}
		}
		printStream.print("end" + insideFormatting + "when");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void IfStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("if");
		for (int i = 0; i < getNumIfWhenClause(); i++) {
			getIfWhenClause(i).doPrettyPrintFormatted(printer, printStream);
			if (i + 1 < getNumIfWhenClause()) {
				printStream.print("elseif");
			}
		}
		if (hasElseClause()) {
			getElseClause().doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print("end" + insideFormatting + "if");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}
	
	void ElseClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("else");
		for (Statement stmt : getStmts()) {
			stmt.doPrettyPrintFormatted(printer, printStream);
		}
	}

	
	void IfWhenClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getTest().doPrettyPrintFormatted(printer, printStream);
		printStream.print("then");
		for (Statement statement : getStatements()) {
			statement.doPrettyPrintFormatted(printer, printStream);
		}
	}

	void AssignStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getLeft().doPrettyPrintFormatted(printer, printStream);
		printStream.print(":=");
		getRight().doPrettyPrintFormatted(printer, printStream);
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void FunctionCallStmt.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (getNumLeft() > 0) {
			printStream.print('(');
			boolean first = true;
			for (FunctionCallLeft left : getLefts()) {
				if (!first)
					printStream.print(',');
				first = false;
				left.doPrettyPrintFormatted(printer, printStream);
			}
			printStream.print(')');
			printStream.print(insideFormatting);
			printStream.print(":=");
		}
		getFunctionCall().doPrettyPrintFormatted(printer, printStream);
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void Equation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getLeft().doPrettyPrintFormatted(printer, printStream);
		printStream.print("=");
		getRight().doPrettyPrintFormatted(printer, printStream);
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void ConnectClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("connect");
		printStream.print("(");
		getConnector1().doPrettyPrintFormatted(printer, printStream);
		printStream.print(",");
		getConnector2().doPrettyPrintFormatted(printer, printStream);
		printStream.print(")");
		getComment().doPrettyPrintFormatted(printer, printStream);
	}

	void FunctionCallEquation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (getNumLeft() > 0) {
			printStream.print("(");
			for (int i = 0 ; i < getNumLeft(); i++) {
				getLeft(i).doPrettyPrintFormatted(printer, printStream);
				if (i + 1 < getNumLeft()) {
					printStream.print(",");
				}
			}
			printStream.print(')');
			printStream.print(insideFormatting);
			printStream.print('=');
		}
		getCall().doPrettyPrintFormatted(printer, printStream);
	}

	void ForClauseE.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("for");
		for (int i = 0; i < getNumForIndex(); i++) {
			getForIndex(i).doPrettyPrintFormatted(printer, printStream);
			if (i + 1 < getNumForIndex()) {
				printStream.print(",");
			}
		}
		printStream.print("loop");
		for (AbstractEquation abstractEquation : getAbstractEquations()) {
			abstractEquation.doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print("end" + insideFormatting + "for");
	}

	void ForIndex.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getForIndexDecl().getName().doPrettyPrintFormatted(printer, printStream);
		if (hasExp()) {
			printStream.print("in");
			getExp().doPrettyPrintFormatted(printer, printStream);
		}
	}

	abstract void IfWhenElseEquation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream, boolean elseIfWhen);
	syn String IfWhenEquation.keyword();
	eq IfEquation.keyword() = "if";
	eq WhenEquation.keyword() = "when";

	void IfWhenEquation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		prettyPrintFormattedHelper(printer, printStream, false);
	}

	void IfWhenEquation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream, boolean elseIfWhen) {
		if (elseIfWhen) {
			printStream.print(preFormatting);
			printStream.print("else");
		}
		printStream.print(keyword());
		getTest().doPrettyPrintFormatted(printer, printStream);
		printStream.print("then");
		for (AbstractEquation abstractEquation : getAbstractEquations()) {
			abstractEquation.doPrettyPrintFormatted(printer, printStream);
		}
		if (hasElse()) {
			getElse().prettyPrintFormattedHelper(printer, printStream, true);
		}
		if (!elseIfWhen) {
			printStream.print("end" + insideFormatting + keyword());
		} else {
			printStream.print(postFormatting);
		}
	}

	void ElseEquation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream, boolean elseIf) {
		printStream.print(preFormatting);
		printStream.print("else");
		for (AbstractEquation abstractEquation : getAbstractEquations()) {
			abstractEquation.doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print(postFormatting);
	}

	void FunctionCall.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getName().doPrettyPrintFormatted(printer, printStream);
		printStream.print("(");
		if (hasFunctionArguments()) {
			getFunctionArguments().doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print(")");
	}

	void PartialFunctionCall.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("function");
		super.prettyPrintFormattedHelper(printer, printStream);
	}

	void FunctionArguments.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		Iterator<ASTNode> it = new ChainedIterator<ASTNode>(getExps().iterator(), getNamedArguments().iterator());
		while (it.hasNext()) {
			ASTNode node = it.next();
			node.doPrettyPrintFormatted(printer, printStream);
			if (it.hasNext())
				printStream.print(',');
		}
	}

	void NamedArgument.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getName().doPrettyPrintFormatted(printer, printStream);
		printStream.print("=");
		getExp().doPrettyPrintFormatted(printer, printStream);
	}

	public void ColonSubscript.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(':');
	}

	void RealLitExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(getUNSIGNED_NUMBER());
	}

	void IntegerLitExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(getUNSIGNED_INTEGER());
	}

	public void TimeExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("time");
	}

	public void EndExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("end");
	}

	void StringLitExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("\"" + getSTRING() + "\"");
	}

	void BooleanLitExpTrue.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("true");
	}

	void BooleanLitExpFalse.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("false");
	}

	void NegExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("-");
		getExp().doPrettyPrintFormatted(printer, printStream);
	}

	void NotExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("not");
		getExp().doPrettyPrintFormatted(printer, printStream);
	}

	void DerExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("der(");
		getExp().doPrettyPrintFormatted(printer, printStream);
		printStream.print(")");
	}

	void RangeExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		for (int i = 0; i < getNumExp(); i++) {
			getExp(i).doPrettyPrintFormatted(printer, printStream);
			if (i + 1 < getNumExp()) {
				printStream.print(":");
			}
		}
	}

	void IfExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("if");
		getIfExp().doPrettyPrintFormatted(printer, printStream);
		printStream.print("then");
		getThenExp().doPrettyPrintFormatted(printer, printStream);
		printStream.print(getElseExp().preFormatting);
		printStream.print("else");
		printStream.print(insideFormatting);
		getElseExp().prettyPrintFormattedHelper(printer, printStream);
		printStream.print(getElseExp().postFormatting);
	}

	void IterExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getExp().doPrettyPrintFormatted(printer, printStream);
		boolean first = true;
		printStream.print("for");
		for (ForIndex index : getForIndexs()) {
			if (!first)
				printStream.print(',');
			first = false;
			index.doPrettyPrintFormatted(printer, printStream);
		}
	}
	void BinExp.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getLeft().doPrettyPrintFormatted(printer, printStream);
		printStream.print(operatorFormatted());
		getRight().doPrettyPrintFormatted(printer, printStream);
	}

	syn String BinExp.operatorFormatted();
	eq LtExp.operatorFormatted()     = "<";
	eq LeqExp.operatorFormatted()    = "<=";
	eq GtExp.operatorFormatted()     = ">";
	eq GeqExp.operatorFormatted()    = ">=";
	eq EqExp.operatorFormatted()     = "==";
	eq NeqExp.operatorFormatted()    = "<>";
	eq OrExp.operatorFormatted()     = "or";
	eq AndExp.operatorFormatted()    = "and";
	eq AddExp.operatorFormatted()    = "";
	eq SubExp.operatorFormatted()    = "-";
	eq MulExp.operatorFormatted()    = "*";
	eq DivExp.operatorFormatted()    = "/";
	eq PowExp.operatorFormatted()    = "^";
	eq DotAddExp.operatorFormatted() = ".+";
	eq DotSubExp.operatorFormatted() = ".-";
	eq DotMulExp.operatorFormatted() = ".*";
	eq DotDivExp.operatorFormatted() = "./";
	eq DotPowExp.operatorFormatted() = ".^";

	void ComponentDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		prettyPrintFormattedHelper(printer, printStream, new Opt<Each>(), getFinalOpt());
		printStream.print(";");
	}

	void ComponentDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream, Opt<Each> each_, Opt<Final> final_) {
		if (hasRedeclare()) {
			getRedeclare().doPrettyPrintFormatted(printer, printStream);
		}
		if (each_.getNumChild() == 1) {
			each_.getChild(0).doPrettyPrintFormatted(printer, printStream);
		}
		if (final_.getNumChild() == 1) {
			final_.getChild(0).doPrettyPrintFormatted(printer, printStream);
		}
		if (hasInner()) {
			getInner().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasOuter()) {
			getOuter().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasReplaceable()) {
			getReplaceable().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasTypePrefixFlow()) {
			getTypePrefixFlow().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasTypePrefixVariability()) {
			getTypePrefixVariability().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasTypePrefixInputOutput()) {
			getTypePrefixInputOutput().doPrettyPrintFormatted(printer, printStream);
		}

		printer.print(getClassName(), printStream, "");
		if (hasVarArraySubscripts()) {// TODO: Try to keep type array subscripts in typeArraySubscripts()
			ArraySubscripts as = new ArraySubscripts();
			for (Subscript s : getVarArraySubscripts().getSubscripts()) {
				if (s.getStart() < getName().getStart())
					as.addSubscript((Subscript)s.fullCopy());
			}
			if (as.getNumSubscript() > 0)
				as.doPrettyPrintFormatted(printer, printStream);
		}
		
		prettyPrintFormattedDecl(printer, printStream);
		
		if (hasConstrainingClause()) {
			printer.print(getConstrainingClause(), printStream, "");
		}
	}

	void SiblingComponentDecl.doPrettyPrintFormatted(Printer printer, CodeStream printStream) {
		if (getSiblings().get(0) == this)
			super.doPrettyPrintFormatted(printer, printStream);
	}
	
	void ComponentDecl.prettyPrintFormattedDecl(Printer printer, CodeStream printStream) {
		getName().doPrettyPrintFormatted(printer, printStream); 
		if (hasVarArraySubscripts()) {// TODO: Try to keep type array subscripts in typeArraySubscripts()
			ArraySubscripts as = new ArraySubscripts();
			for (Subscript s : getVarArraySubscripts().getSubscripts()) {
				if (s.getStart() > getName().getStart())
					as.addSubscript((Subscript)s.fullCopy());
			}
			if (as.getNumSubscript() > 0)
				as.doPrettyPrintFormatted(printer, printStream);
		}
		if (hasModification()) {
			getModification().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasConditionalAttribute()) {
			getConditionalAttribute().doPrettyPrintFormatted(printer, printStream);
		}

		getComment().doPrettyPrintFormatted(printer, printStream);
		getCCComment().doPrettyPrintFormatted(printer, printStream);
		
	}
	
	void SiblingComponentDecl.prettyPrintFormattedDecl(Printer printer, CodeStream printStream) {
		boolean first = true;
		for (SiblingComponentDecl sibling : getSiblings()) {
			if (!first)
				printStream.print(',');
			sibling.prettyPrintFormattedSiblingDecl(printer, printStream, first);
			first = false;
		}
	}
	
	void SiblingComponentDecl.prettyPrintFormattedSiblingDecl(Printer printer, CodeStream printStream, boolean first) {
		if (!first)
			printStream.print(preFormatting);
		super.prettyPrintFormattedDecl(printer, printStream);
		if (!first)
			printStream.print(postFormatting);
	}
	
	void EnumLiteralDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		getName().doPrettyPrintFormatted(printer, printStream);
		getComment().doPrettyPrintFormatted(printer, printStream);
	}
	
	syn String TypePrefix.formattedToString();
	eq Flow.formattedToString()			= "flow";
	eq Stream.formattedToString()		= "stream";
	eq Continuous.formattedToString()	= "continuous";
	eq Discrete.formattedToString()		= "discrete";
	eq Parameter.formattedToString()	= "parameter";
	eq Constant.formattedToString()		= "constant";
	eq Input.formattedToString()		= "input";
	eq Output.formattedToString()		= "output";

	void TypePrefix.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print(formattedToString());
	}

	void ConditionalAttribute.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("if");
		getExp().doPrettyPrintFormatted(printer, printStream);
	}

	void Comment.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasStringComment()) {
			getStringComment().doPrettyPrintFormatted(printer, printStream);
		}
		if (hasAnnotation()) {
			getAnnotation().doPrettyPrintFormatted(printer, printStream);
		}
	}

	void StringComment.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("\"");
		printStream.print(getComment());
		printStream.print("\"");
	}

	void ParseAnnotation.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("annotation");
		getClassModification().doPrettyPrintFormatted(printer, printStream);
	}

	void EndDecl.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("end" + insideFormatting + getEndID() + ";");
	}

	syn String FBinExp.operatorFormatted();
	eq FLtExp.operatorFormatted()     = "<";
	eq FLeqExp.operatorFormatted()    = "<=";
	eq FGtExp.operatorFormatted()     = ">";
	eq FGeqExp.operatorFormatted()    = ">=";
	eq FEqExp.operatorFormatted()     = "==";
	eq FNeqExp.operatorFormatted()    = "<>";
	eq FOrExp.operatorFormatted()     = "or";
	eq FAndExp.operatorFormatted()    = "and";
	eq FAddExp.operatorFormatted()    = "";
	eq FSubExp.operatorFormatted()    = "-";
	eq FMulExp.operatorFormatted()    = "*";
	eq FDivExp.operatorFormatted()    = "/";
	eq FPowExp.operatorFormatted()    = "^";
	eq FDotAddExp.operatorFormatted() = ".+";
	eq FDotSubExp.operatorFormatted() = ".-";
	eq FDotMulExp.operatorFormatted() = ".*";
	eq FDotDivExp.operatorFormatted() = "./";
	eq FDotPowExp.operatorFormatted() = ".^";

	void ExternalClause.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print("external");
		if (hasExternalLanguage())
			getExternalLanguage().doPrettyPrintFormatted(printer, printStream);
		if (hasExternalFunctionCall())
			getExternalFunctionCall().doPrettyPrintFormatted(printer, printStream);
		if (hasAnnotation())
			getAnnotation().doPrettyPrintFormatted(printer, printStream);
		printStream.print(';');
	}
	
	void ExternalFunctionCall.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		if (hasReturnVar()) {
			getReturnVar().doPrettyPrintFormatted(printer, printStream);
			printStream.print('=');
		}
		getFunctionName().doPrettyPrintFormatted(printer, printStream);
		printStream.print('(');
		boolean first = true;
		for (Exp arg : getArgs()) {
			if (!first)
				printStream.print(',');
			first = false;
			arg.doPrettyPrintFormatted(printer, printStream);
		}
		printStream.print(')');
	}
	
	void ExternalLanguage.prettyPrintFormattedHelper(Printer printer, CodeStream printStream) {
		printStream.print('"');
		printStream.print(getLanguage());
		printStream.print('"');
	}
	
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// MISCELLANEOUS:
	//
	// This section of the aspect contains attributes and methods for misscellaneous activities which are related
	// to pretty printing with preserved formatting.
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////

	void ASTNode.copyFormattingFrom(ASTNode node) {
		if (this.getClass() != node.getClass())
			return;
		if (numChildren() != node.numChildren())
			return;
		for (int i = 0; i < numChildren(); i++) {
			getChild(i).copyFormattingFrom(node.getChild(i));
		}
	}

	void List.copyFormattingFrom(ASTNode node) { // This code is strange...
		if (this.getClass() != node.getClass())
			return;
	}

	void SourceBaseNode.copyFormattingFrom(ASTNode node) {
		if (this.getClass() != node.getClass())
			return;
		SourceBaseNode bn = (SourceBaseNode) node;
		node.propagateFormatting();
		preFormatting = bn.preFormatting;
		postFormatting = bn.postFormatting;
		super.copyFormattingFrom(node);
	}

	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	// DEBUGGING:
	//
	// This section of the aspect contains attributes and methods that can be used for debugging pretty printing
	// with preserved formatting.
	//
	///////////////////////////////////////////////////////////////////////////////////////////////////////////////
	syn int ASTNode.numberOfDefaultFormattingItems() {
		int result = 0;
		for (ASTNode node : this) {
			result += node.numberOfDefaultFormattingItems();
		}
		return result;
	}

	eq SourceBaseNode.numberOfDefaultFormattingItems() {
		int result = 0;
		if (!preFormatting.isScanned() && !preFormatting.isEmptyDefault()) {
			++result;
		}
		if (!insideFormatting.isScanned() && !insideFormatting.isEmptyDefault()) {
			++result;
		}
		if (!postFormatting.isScanned() && !postFormatting.isEmptyDefault()) {
			++result;
		}
		for (ASTNode node : this) {
			result += node.numberOfDefaultFormattingItems();
		}
		return result;
	}

	syn ArrayList<SourceBaseNode> ASTNode.nonScannedNodes() {
		ArrayList<SourceBaseNode> result = new ArrayList<SourceBaseNode>();
		for (ASTNode node : this) {
			result.addAll(node.nonScannedNodes());
		}
		return result;
	}

	eq SourceBaseNode.nonScannedNodes() {
		ArrayList<SourceBaseNode> result = new ArrayList<SourceBaseNode>();
		if (!preFormatting.isScanned() && !preFormatting.isEmptyDefault()) {
			result.add(this);
		} else if (!insideFormatting.isScanned() && !insideFormatting.isEmptyDefault()) {
			result.add(this);
		} else if (!postFormatting.isScanned() && !postFormatting.isEmptyDefault()) {
			result.add(this);
		}
		for (ASTNode node : this) {
			result.addAll(node.nonScannedNodes());
		}
		return result;
	}

	syn SourceBaseNode ASTNode.ownsFormattingItem(int startLine, int startColumn) {
		SourceBaseNode owner = null;
		for (ASTNode node : this) {
			owner = node.ownsFormattingItem(startLine, startColumn);
			if (owner != null) {
				return owner;
			}
		}

		return null;
	}

	eq SourceBaseNode.ownsFormattingItem(int startLine, int startColumn) {
		if (preFormatting.isScanned() && ((ScannedFormattingItem) preFormatting).getStartLine() == startLine && ((ScannedFormattingItem) preFormatting).getStartColumn() == startColumn) {
			return this;
		}
		if (insideFormatting.isScanned() && ((ScannedFormattingItem) insideFormatting).getStartLine() == startLine && ((ScannedFormattingItem) insideFormatting).getStartColumn() == startColumn) {
			return this;
		}
		if (postFormatting.isScanned() && ((ScannedFormattingItem) postFormatting).getStartLine() == startLine && ((ScannedFormattingItem) postFormatting).getStartColumn() == startColumn) {
			return this;
		}

		SourceBaseNode owner = null;
		for (ASTNode node : this) {
			owner = node.ownsFormattingItem(startLine, startColumn);
			if (owner != null) {
				return owner;
			}
		}

		return null;
	}
}