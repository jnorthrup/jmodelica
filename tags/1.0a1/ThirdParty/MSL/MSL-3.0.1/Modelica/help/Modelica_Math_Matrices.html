<HTML>
<HEAD>
<TITLE>Modelica.Math.Matrices</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Library of functions operating on matrices&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Matrices<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Math.Matrices"></A><A HREF="Modelica_Math.html#Modelica.Math"
>Modelica.Math</A>.Matrices</H2>
<B>Library of functions operating on matrices</B>
<P>
<H3>Information</H3>
<PRE></pre>
<h4>Library content</h4>
<p>
This library provides functions operating on matrices:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><i>Function</i></th>
      <th><i>Description</i></th>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual"
>isEqual</a>(M1, M2)</td>
      <td valign="top">Determines whether two matrices have the same size and elements</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm"
>norm</a>(A)</td>
      <td valign="top">1-, 2- and infinity-norm of matrix A</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.sort"
>sort</a>(M)</td>
      <td valign="top">Sort rows or columns of matrix in ascending or descending order</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>solve</a>(A,b)</td>
      <td valign="top">Solve real system of linear equations A*x=b with a b vector</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>solve2</a>(A,B)</td>
      <td valign="top">Solve real system of linear equations A*X=B with a B matrix</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares"
>leastSquares</a>(A,b)</td>
      <td valign="top">Solve overdetermined or underdetermined real system of <br>
          linear equations A*x=b in a least squares sense</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</a>(A,a,B,b)</td>
      <td valign="top">Solve a linear equality constrained least squares problem:<br>
          min|A*x-a|^2 subject to B*x=b</td>
  </tr>
  <tr><td valign="top">(LU,p,info) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>LU</a>(A)</td>
      <td valign="top">LU decomposition of square or rectangular matrix</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>LU_solve</a>(LU,p,b)</td>
      <td valign="top">Solve real system of linear equations P*L*U*x=b with a<br>
          b vector and an LU decomposition from "LU(..)"</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>LU_solve2</a>(LU,p,B)</td>
      <td valign="top">Solve real system of linear equations P*L*U*X=B with a<br>
          B matrix and an LU decomposition from "LU(..)"</td>
  </tr>
  <tr><td valign="top">(Q,R,p) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.QR"
>QR</a>(A)</td>
      <td valign="top"> QR decomposition with column pivoting of rectangular matrix (Q*R = A[:,p]) </td>
  </tr>
  <tr><td valign="top">eval = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>eigenValues</a>(A)<br>
          (eval,evec) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>eigenValues</a>(A)</td>
      <td valign="top"> Compute eigenvalues and optionally eigenvectors<br>
           for a real, nonsymmetric matrix </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>eigenValueMatrix</a>(eigen)</td>
      <td valign="top"> Return real valued block diagonal matrix J of eigenvalues of 
            matrix A (A=V*J*Vinv) </td>
  </tr>
  <tr><td valign="top">sigma = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>singularValues</a>(A)<br>
      (sigma,U,VT) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>singularValues</a>(A)</td>
      <td valign="top"> Compute singular values and optionally left and right singular vectors </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.det"
>det</a>(A)</td>
      <td valign="top"> Determinant of a matrix (do <b>not</b> use; use rank(..))</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.inv"
>inv</a>(A)</td>
      <td valign="top"> Inverse of a matrix </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>rank</a>(A)</td>
      <td valign="top"> Rank of a matrix </td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.balance"
>balance</a>(A)</td>
      <td valign="top">Balance a square matrix to improve the condition</td>
  </tr>
  <tr><td valign="top"><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.exp"
>exp</a>(A)</td>
      <td valign="top"> Compute the exponential of a matrix by adaptive Taylor series<br> 
           expansion with scaling and balancing</td>
  </tr>
  <tr><td valign="top">(P, G) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExp"
>integralExp</a>(A,B)</td>
      <td valign="top"> Compute the exponential of a matrix and its integral</td>
  </tr>
  <tr><td valign="top">(P, G, GT) = <A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExpT"
>integralExpT</a>(A,B)</td>
      <td valign="top"> Compute the exponential of a matrix and two integrals</td>
  </tr>
</table>
 
<p>
Most functions are solely an interface to the external LAPACK library
(<a href="http://www.netlib.org/lapack">http://www.netlib.org/lapack</a>).
The details of this library are described in:
</p>
 
<dl>
<dt>Anderson E., Bai Z., Bischof C., Blackford S., Demmel J., Dongarra J.,
    Du Croz J., Greenbaum A., Hammarling S., McKenney A., and Sorensen D.:</dt>
<dd> <b>Lapack Users' Guide</b>.
     Third Edition, SIAM, 1999.</dd>
</dl>
 
<h4>See also</h4>
<A HREF="Modelica_Math_Vectors.html#Modelica.Math.Vectors"
>Vectors</a>

<pre>
</PRE><P>
Extends from <A HREF="Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.isEqual" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.isEqual"
>isEqual</A>
</TD><TD>Compare whether two Real matrices are identical</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.norm" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.norm"
>norm</A>
</TD><TD>Returns the norm of a matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.sort" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.sort"
>sort</A>
</TD><TD>Sort rows or columns of matrix in ascending or descending order</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>solve</A>
</TD><TD>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>solve2</A>
</TD><TD>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.leastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.leastSquares"
>leastSquares</A>
</TD><TD>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.equalityLeastSquares" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.equalityLeastSquares"
>equalityLeastSquares</A>
</TD><TD>Solve a linear equality constrained least squares problem</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.LU" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>LU</A>
</TD><TD>LU decomposition of square or rectangular matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.LU_solve" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>LU_solve</A>
</TD><TD>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.LU_solve2" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>LU_solve2</A>
</TD><TD>Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.QR" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.QR"
>QR</A>
</TD><TD>QR decomposition of a square matrix with column pivoting (A(:,p) = Q*R)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.eigenValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>eigenValues</A>
</TD><TD>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.eigenValueMatrix" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>eigenValueMatrix</A>
</TD><TD>Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.singularValues" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>singularValues</A>
</TD><TD>Compute singular values and left and right singular vectors</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.det" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.det"
>det</A>
</TD><TD>Determinant of a matrix (computed by LU decomposition)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.inv" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.inv"
>inv</A>
</TD><TD>Inverse of a matrix (try to avoid, use function solve(..) instead)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.rank" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>rank</A>
</TD><TD>Rank of a matrix (computed with singular values)</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.balance" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.balance"
>balance</A>
</TD><TD>Balancing of matrix A to improve the condition of A</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.exp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.exp"
>exp</A>
</TD><TD>Compute the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.integralExp" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExp"
>integralExp</A>
</TD><TD>Computation of the transition-matrix phi and its integral gamma</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Vectors.isEqualS.png" ALT="Modelica.Math.Matrices.integralExpT" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.integralExpT"
>integralExpT</A>
</TD><TD>Computation of the transition-matrix phi and the integral gamma and gamma1</TD></TR>
<TR><TD><IMG SRC="Modelica.Math.Matrices.LAPACKS.png" ALT="Modelica.Math.Matrices.LAPACK" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Math_Matrices_LAPACK.html#Modelica.Math.Matrices.LAPACK"
>LAPACK</A>
</TD><TD>Interface to LAPACK library (should usually not directly be used but only indirectly via Modelica.Math.Matrices)</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isEqual<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.isEqual" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.isEqual"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.isEqual</H2>
<B>Compare whether two Real matrices are identical</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>isEqual</b>(M1, M2);
Matrices.<b>isEqual</b>(M1, M2, eps=0);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Matrices.isEqual(M1, M2)</code>" returns <b>true</b>, 
if the two Real matrices M1 and M2 have the same dimensions and 
the same elements. Otherwise the function
returns <b>false</b>. Two elements e1 and e2 of the two matrices
are checked on equality by the test "abs(e1-e2) &le; eps", where "eps"
can be provided as third argument of the function. Default is "eps = 0".
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A1[2,2] = [1,2; 3,4];
  Real A2[3,2] = [1,2; 3,4; 5,6];
  Real A3[2,2] = [1,2, 3,4.0001];
  Boolean result;
<b>algorithm</b>
  result := Matrices.isEqual(M1,M2);     // = <b>false</b>
  result := Matrices.isEqual(M1,M3);     // = <b>false</b>
  result := Matrices.isEqual(M1,M1);     // = <b>true</b>
  result := Matrices.isEqual(M1,M3,0.1); // = <b>true</b>
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Vectors.html#Modelica.Math.Vectors.isEqual"
>Vectors.isEqual</a>, 
<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual"
>Strings.isEqual</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>M1[:, :]</TD><TD>First matrix</TD></TR>
<TR><TD>M2[:, :]</TD><TD>Second matrix (may have different size as M1</TD></TR>
<TR><TD>eps</TD><TD>Two elements e1 and e2 of the two matrices are identical if abs(e1-e2) &lt;= eps</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>= true, if matrices have the same size and the same elements</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE norm<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.norm" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.norm"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.norm</H2>
<B>Returns the norm of a matrix</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>norm</b>(A);
Matrices.<b>norm</b>(A, p=2);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call "<code>Matrices.norm(A)</code>" returns the
2-norm of matrix A, i.e., the largest singular value of A.<br>
The function call "<code>Matrices.norm(A, p)</code>" returns the
p-norm of matrix A. The only allowed values for p are</p>
<ul>
<li> "p=1": the largest column sum of A</li>
<li> "p=2": the largest singular value of A</li> 
<li> "p=Modelica.Constants.inf": the largest row sum of A</li>
</ul>
<p>
Note, for any matrices A1, A2 the following inequality holds:
</p>
<blockquote><pre>
Matrices.<b>norm</b>(A1+A2,p) &le; Matrices.<b>norm</b>(A1,p) + Matrices.<b>norm</b>(A2,p)
</pre></blockquote>
<p>
Note, for any matrix A and vector v the following inequality holds:
</p>
<blockquote><pre>
Vectors.<b>norm</b>(A*v,p) &le; Matrices.<b>norm</b>(A,p)*Vectors.<b>norm</b>(A,p)
</pre></blockquote>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Input matrix</TD></TR>
<TR><TD>p</TD><TD>Type of p-norm (only allowed: 1, 2 or Modelica.Constants.inf)</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>p-norm of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sort<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.sort" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.sort"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.sort</H2>
<B>Sort rows or columns of matrix in ascending or descending order</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
           sorted_M = Matrices.<b>sort</b>(M);
(sorted_M, indices) = Matrices.<b>sort</b>(M, sortRows=true, ascending=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>sort</b>(..) sorts the rows of a Real matrix M
in ascending order and returns the result in sorted_M.
If the optional argument "sortRows" is <b>false</b>, the columns
of the matrix are sorted.
If the optional argument "ascending" is <b>false</b>, the rows or
columns are sorted in descending order. In the optional second
output argument, the indices of the sorted rows or columns with respect
to the original matrix are given, such that
</p>
<pre>
   sorted_M = <b>if</b> sortedRow <b>then</b> M[indices,:] <b>else</b> M[:,indices];
</pre>
<h4>Example</h4>
<blockquote><pre>
  (M2, i2) := Matrices.sort([2, 1,  0;
                             2, 0, -1]);
       -> M2 = [2, 0, -1;
                2, 1, 0 ];
          i2 = {2,1};
</pre></blockquote>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>M[:, :]</TD><TD>Matrix to be sorted</TD></TR>
<TR><TD>sortRows</TD><TD>= true if rows are sorted, otherwise columns</TD></TR>
<TR><TD>ascending</TD><TD>= true if ascending order, otherwise descending order</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>sorted_M[size(M, 1), size(M, 2)]</TD><TD>Sorted matrix</TD></TR>
<TR><TD>indices[if sortRows then size(M, 1) else size(M, 2)]</TD><TD>sorted_M = if sortRows then M[indices,:] else M[:,indices]</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.solve"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.solve</H2>
<B>Solve real system of linear equations A*x=b with a b vector (Gaussian elemination with partial pivoting)</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
<p>
If a unique solution <b>x</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b[3] = {10,22,12};
  Real x[3];
<b>algorithm</b>
  x := Matrices.solve(A,b);  // x = {3,2,1}
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of A*x = b</TD></TR>
<TR><TD>b[size(A, 1)]</TD><TD>Vector b of A*x = b</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(b, 1)]</TD><TD>Vector x such that A*x = b</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.solve2"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.solve2</H2>
<B>Solve real system of linear equations A*X=B with a B matrix (Gaussian elemination with partial pivoting)</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>solve2</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear system of equations
</p>
<blockquote>
<p>
<b>A</b>*<b>X</b> = <b>B</b>
</p>
</blockquote>
<p>
If a unique solution <b>X</b> does not exist (since <b>A</b> is singular),
an exception is raised.
</p>
<p>
Note, the solution is computed with the LAPACK function "dgesv",
i.e., by Gaussian elemination with partial pivoting.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real B[3,2] = [10, 20;
                 22, 44;
                 12, 24];
  Real X[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X := Matrices.solve2(A, B1);  /* X = [3, 6;
                                        2, 4;
                                        1, 2] */
</pre></blockquote>
 
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve2"
>Matrices.LU_solve2</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix A of A*X = B</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>Matrix B of A*X = B</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Matrix X such that A*X = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE leastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.leastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.leastSquares"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.leastSquares</H2>
<B>Solve overdetermined or underdetermined real system of linear equations A*x=b in a least squares sense (A may be rank deficient)</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>leastSquares</b>(A,b);
</pre></blockquote>
<h4>Description</h4>
<p>
A linear system of equations A*x = b has no solutions or infinitely
many solutions if A is not square. Function "leastSquares" returns
a solution in a least squarse sense:
</p>
<pre>
  size(A,1) &gt; size(A,2):  returns x such that |A*x - b|^2 is a minimum
  size(A,1) = size(A,2):  returns x such that A*x = b
  size(A,1) &lt; size(A,2):  returns x such that |x|^2 is a minimum for all 
                          vectors x that fulfill A*x = b
</pre>
<p>
Note, the solution is computed with the LAPACK function "dgelsx",
i.e., QR or LQ factorization of A with column pivoting. 
If A does not have full rank,
the solution is not unique and from the infinitely many solutions
the one is selected that minimizes both |x|^2 and |A*x - b|^2.
</p>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix A</TD></TR>
<TR><TD>b[size(A, 1)]</TD><TD>Vector b</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(A, 2)]</TD><TD>Vector x such that min|A*x-b|^2 if size(A,1) &gt;= size(A,2) or min|x|^2 and A*x=b, if size(A,1) &lt; size(A,2)</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE equalityLeastSquares<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.equalityLeastSquares" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.equalityLeastSquares"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.equalityLeastSquares</H2>
<B>Solve a linear equality constrained least squares problem</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
x = Matrices.<b>equalityLeastSquares</b>(A,a,B,b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the
solution <b>x</b> of the linear equality-constrained least squares problem:
</p>
<blockquote>
<p>
min|<b>A</b>*<b>x</b> - <b>a</b>|^2 over <b>x</b>, subject to <b>B</b>*<b>x</b> = <b>b</b>
</p>
</blockquote>
 
<p>
It is required that the dimensions of A and B fulfill the following
relationship:
</p>
 
<blockquote>
size(B,1) &le; size(A,2) &le; size(A,1) + size(B,1)
</blockquote>
 
<p>
Note, the solution is computed with the LAPACK function "dgglse"
using the generalized RQ factorization under the assumptions that
B has full row rank (= size(B,1)) and the matrix [A;B] has
full column rank (= size(A,2)). In this case, the problem
has a unique solution.
</p>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Minimize |A*x - a|^2</TD></TR>
<TR><TD>a[size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[:, size(A, 2)]</TD><TD>subject to B*x=b</TD></TR>
<TR><TD>b[size(B, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(A, 2)]</TD><TD>solution vector</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.LU" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.LU"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.LU</H2>
<B>LU decomposition of square or rectangular matrix</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(LU, pivots)       = Matrices.<b>LU</b>(A);
(LU, pivots, info) = Matrices.<b>LU</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
LU decomposition of a "Real[m,n]" matrix A, i.e.,
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b> = <b>A</b>
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
Matrices <b>L</b> and <b>U</b> are stored in the returned
matrix <code>LU</code> (the diagonal of <b>L</b> is not stored).
With the companion function 
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>,
this decomposition can be used to solve
linear systems (<b>P</b>*<b>L</b>*<b>U</b>)*<b>x</b> = <b>b</b> with different right
hand side vectors <b>b</b>. If a linear system of equations with
just one right hand side vector <b>b</b> shall be solved, it is
more convenient to just use the function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>.
</p>
<p>
The optional third (Integer) output argument has the following meaning:
<table border=0 cellspacing=0 cellpadding=2>
  <tr><td valign="top">info = 0:</td
      <td valign="top">successful exit</td></tr>
  <tr><td valign="top">info &gt; 0:</td>
      <td valign="top">if info = i, U[i,i] is exactly zero. The factorization
          has been completed, <br> 
          but the factor U is exactly
          singular, and division by zero will occur<br> if it is used
          to solve a system of equations.</td></tr>
</table>
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU_solve"
>Matrices.LU_solve</a>, 
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>,
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Square or rectangular matrix</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[size(A, 1), size(A, 2)]</TD><TD>L,U factors (used with LU_solve(..))</TD></TR>
<TR><TD>pivots[min(size(A, 1), size(A, 2))]</TD><TD>pivot indices (used with LU_solve(..))</TD></TR>
<TR><TD>info</TD><TD>Information</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.LU_solve" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.LU_solve"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.LU_solve</H2>
<B>Solve real system of linear equations P*L*U*x=b with a b vector and an LU decomposition (from LU(..))</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, b);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>x</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>x</b> = <b>b</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve</code>
it is possible to efficiently solve linear systems
with different right hand side vectors. If a linear system of equations with
just one right hand side vector shall be solved, it is
more convenient to just use the function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>.
</p>
<p>
If a unique solution <b>x</b> does not exist (since the 
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real b1[3] = {10,22,12};
  Real b2[3] = { 7,13,10};
  Real    LU[3,3];
  Integer pivots[3];
  Real    x1[3];
  Real    x2[3];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  x1 := Matrices.LU_solve(LU, pivots, b1);  // x1 = {3,2,1}
  x2 := Matrices.LU_solve(LU, pivots, b2);  // x2 = {1,0,2}
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>, 
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>,
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>b[size(LU, 1)]</TD><TD>Right hand side vector of P*L*U*x=b</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>x[size(b, 1)]</TD><TD>Solution vector such that P*L*U*x = b</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE LU_solve2<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.LU_solve2" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.LU_solve2"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.LU_solve2</H2>
<B>Solve real system of linear equations P*L*U*X=B with a B matrix and an LU decomposition (from LU(..))</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>LU_solve</b>(LU, pivots, B);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the
solution <b>X</b> of the linear systems of equations
</p>
<blockquote>
<p>
<b>P</b>*<b>L</b>*<b>U</b>*<b>X</b> = <b>B</b>;
</p>
</blockquote>
<p>
where <b>P</b> is a permutation matrix (implicitely
defined by vector <code>pivots</code>),
<b>L</b> is a lower triangular matrix with unit
diagonal elements (lower trapezoidal if m &gt; n), and
<b>U</b> is an upper triangular matrix (upper trapezoidal if m &lt; n).
The matrices of this decomposition are computed with function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a> that
returns arguments <code>LU</code> and <code>pivots</code>
used as input arguments of <code>Matrices.LU_solve2</code>.
With <code>Matrices.LU</code> and <code>Matrices.LU_solve2</code>
it is possible to efficiently solve linear systems
with different right hand side <b>matrices</b>. If a linear system of equations with
just one right hand side matrix shall be solved, it is
more convenient to just use the function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>Matrices.solve2</a>.
</p>
<p>
If a unique solution <b>X</b> does not exist (since the 
LU decomposition is singular), an exception is raised.
</p>
<p>
The LU factorization is computed
with the LAPACK function "dgetrf",
i.e., by Gaussian elemination using partial pivoting
with row interchanges. Vector "pivots" are the
pivot indices, i.e., for 1 &le; i &le; min(m,n), row i of 
matrix A was interchanged with row pivots[i].
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real B1[3] = [10, 20;
                22, 44;
                12, 24];
  Real B2[3] = [ 7, 14;
                13, 26;
                10, 20];
  Real    LU[3,3];
  Integer pivots[3];
  Real    X1[3,2];
  Real    X2[3,2];
<b>algorithm</b>
  (LU, pivots) := Matrices.LU(A);
  X1 := Matrices.LU_solve2(LU, pivots, B1);  /* X1 = [3, 6;
                                                      2, 4;
                                                      1, 2] */
  X2 := Matrices.LU_solve2(LU, pivots, B2);  /* X2 = [1, 2;
                                                      0, 0;
                                                      2, 4] */
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.LU"
>Matrices.LU</a>, 
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve2"
>Matrices.solve2</a>,
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>LU[:, size(LU, 1)]</TD><TD>L,U factors of Matrices.LU(..) for a square matrix</TD></TR>
<TR><TD>pivots[size(LU, 1)]</TD><TD>Pivots indices of Matrices.LU(..)</TD></TR>
<TR><TD>B[size(LU, 1), :]</TD><TD>Right hand side matrix of P*L*U*X=B</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>X[size(B, 1), size(B, 2)]</TD><TD>Solution matrix such that P*L*U*X = B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE QR<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.QR" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.QR"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.QR</H2>
<B>QR decomposition of a square matrix with column pivoting (A(:,p) = Q*R)</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(Q,R,p) = Matrices.<b>QR</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns the QR decomposition of
a rectangular matrix <b>A</b> (the number of columns of <b>A</b>
must be less than or equal to the number of rows):
</p>
<blockquote>
<p>
<b>Q</b>*<b>R</b> = <b>A</b>[:,<b>p</b>]
</p>
</blockquote>
<p>
where <b>Q</b> is a rectangular matrix that has orthonormal columns and
has the same size as A (<b>Q</b><sup>T</sup><b>Q</b>=<b>I</b>),
<b>R</b> is a square, upper triangular matrix and <b>p</b> is a permutation
vector. Matrix <b>R</b> has the following important properties:
</p>
<ul>
<li> The absolute value of a diagonal element of <b>R</b> is the largest
     value in this row, i.e.,
     abs(R[i,i]) &ge; abs(R[i,j]).</li>
<li> The diagonal elements of <b>R</b> are sorted according to size, such that
     the largest absolute value is abs(R[1,1]) and
     abs(R[i,i]) &ge; abs(R[j,j]) with i &lt; j. </li>
</ul>
<p>
This means that if abs(R[i,i]) &le; &epsilon; then abs(R[j,k]) &le; &epsilon;
for j &ge; i, i.e., the i-th row up to the last row of <b>R</b> have
small elements and can be treated as being zero. 
This allows to, e.g., estimate the row-rank
of <b>R</b> (which is the same row-rank as <b>A</b>). Furthermore,
<b>R</b> can be partitioned in two parts
</p>
<blockquote>
<pre>
   <b>A</b>[:,<b>p</b>] = <b>Q</b> * [<b>R</b><sub>1</sub>, <b>R</b><sub>2</sub>;
                 <b>0</b>,  <b>0</b>]
</pre>
</blockquote>
<p>
where <b>R</b><sub>1</sub> is a regular, upper triangular matrix. 
</p>
<p>
Note, the solution is computed with the LAPACK functions "dgeqpf"
and "dorgqr", i.e., by Housholder transformations with
column pivoting. If <b>Q</b> is not needed, the function may be
called as: <code>(,R,p) = QR(A)</code>.
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real R[3,3];
<b>algorithm</b>
  (,R) := Matrices.QR(A);  // R = [-7.07.., -4.24.., -3.67..;
                                    0     , -1.73.., -0.23..;
                                    0     ,  0     ,  0.65..];
</pre></blockquote>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Rectangular matrix with size(A,1) &gt;= size(A,2)</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Q[size(A, 1), size(A, 2)]</TD><TD>Rectangular matrix with orthonormal columns such that Q*R=A[:,p]</TD></TR>
<TR><TD>R[size(A, 2), size(A, 2)]</TD><TD>Square upper triangular matrix</TD></TR>
<TR><TD>p[size(A, 2)]</TD><TD>Column permutation vector</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.eigenValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.eigenValues"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.eigenValues</H2>
<B>Compute eigenvalues and eigenvectors for a real, nonsymmetric matrix</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
                eigenvalues = Matrices.<b>eigenValues</b>(A);
(eigenvalues, eigenvectors) = Matrices.<b>eigenValues</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the eigenvalues and 
optionally the (right) eigenvectors of a square matrix 
<b>A</b>. The first column of "eigenvalues" contains the real and the
second column contains the imaginary part of the eigenvalues.
If the i-th eigenvalue has no imaginary part, then eigenvectors[:,i] is
the corresponding real eigenvector. If the i-th eigenvalue
has an imaginary part, then eigenvalues[i+1,:] is the conjugate complex
eigenvalue and eigenvectors[:,i] is the real and eigenvectors[:,i+1] is the
imaginary part of the eigenvector of the i-th eigenvalue.
With function 
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>Matrices.eigenValueMatrix</a>,
a real block diagonal matrix is constructed from the eigenvalues 
such that 
</p>
<blockquote>
<pre>
A = eigenvectors * eigenValueMatrix(eigenvalues) * inv(eigenvectors)
</pre>
</blockquote>
<p>
provided the eigenvector matrix "eigenvectors" can be inverted
(an inversion is possible, if all eigenvalues are different
and no eigenvalue is zero).
</p>
<h4>Example</h4>
<blockquote><pre>
  Real A[3,3] = [1,2,3; 
                 3,4,5;
                 2,1,4];
  Real eval;
<b>algorithm</b>
  eval := Matrices.eigenValues(A);  // eval = [-0.618, 0; 
                                    //          8.0  , 0;
                                    //          1.618, 0];
</pre>
</blockquote>
<p>
i.e., matrix A has the 3 real eigenvalues -0.618, 8, 1.618.
</p>
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValueMatrix"
>Matrices.eigenValueMatrix</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.singularValues"
>Matrices.singularValues</a>
<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>Matrix</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>eigenvalues[size(A, 1), 2]</TD><TD>Eigenvalues of matrix A (Re: first column, Im: second column)</TD></TR>
<TR><TD>eigenvectors[size(A, 1), size(A, 2)]</TD><TD>Real-valued eigenvector matrix</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE eigenValueMatrix<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.eigenValueMatrix" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.eigenValueMatrix"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.eigenValueMatrix</H2>
<B>Return real valued block diagonal matrix J of eigenvalues of matrix A (A=V*J*Vinv)</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>eigenValueMatrix</b>(eigenvalues);
</pre></blockquote>
<h4>Description</h4>
<p>
The function call returns a block diagonal matrix <b>J</b>
from the the two-column matrix <code>eigenvalues</code>
(computed by function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>).
Matrix <code>eigenvalues</code> must have the real part of the
eigenvalues in the first column and the imaginary part in the
second column. If an eigenvalue i has a vanishing imaginary
part, then <b>J</b>[i,i] = eigenvalues[i,1], i.e., the diagonal
element of <b>J</b> is the real eigenvalue. 
Otherwise, eigenvalue i and conjugate complex eigenvalue i+1
are used to construct a 2 by 2 diagonal block of <b>J</b>:
</p>
<blockquote>
<pre>
  J[i  , i]   := eigenvalues[i,1];
  J[i  , i+1] := eigenvalues[i,2];
  J[i+1, i]   := eigenvalues[i+1,2];
  J[i+1, i+1] := eigenvalues[i+1,1];
</pre>
</blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>eigenValues[:, 2]</TD><TD>Eigen values from function eigenValues(..) (Re: first column, Im: second column)</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>J[size(eigenValues, 1), size(eigenValues, 1)]</TD><TD>Real valued block diagonal matrix with eigen values (Re: 1x1 block, Im: 2x2 block)</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE singularValues<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.singularValues" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.singularValues"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.singularValues</H2>
<B>Compute singular values and left and right singular vectors</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
         sigma = Matrices.<b>singularValues</b>(A);
(sigma, U, VT) = Matrices.<b>singularValues</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function computes the singular values and optionally the
singular vectors of matrix A. Basically the singular
value decomposition of A is computed, i.e.,
</p>
<blockquote><pre>
<b>A</b> = <b>U</b> <b><font face="Symbol">S</font></b> <b>V</b><sup>T</sup>
  = U*Sigma*VT
</blockquote></pre>
<p>
where <b>U </b>and <b>V</b> are orthogonal matrices (<b>UU</b><sup>T</sup>=<b>I,
</b><b>VV</b><sup>T</sup>=<b>I</b>). <b><font face="Symbol">S
</font></b> = diag(<font face="Symbol">s</font><sub>i</sub>) 
has the same size as matrix A with nonnegative diagonal elements 
in decreasing order and with all other elements zero
(<font face="Symbol">s</font><sub>1</sub> is the largest element). The function
returns the singular values <font face="Symbol">s</font><sub>i</sub>
in vector <tt>sigma</tt> and the orthogonal matrices in
matrices <tt>U</tt> and <tt>V</tt>.
</p>
<h4>Example</h4>
<blockquote><pre>
  A = [1, 2,  3,  4;
       3, 4,  5, -2;
      -1, 2, -3,  5];
  (sigma, U, VT) = singularValues(A);
  results in:
     sigma = {8.33, 6.94, 2.31}; 
  i.e.
     Sigma = [8.33,    0,    0, 0;
                 0, 6.94,    0, 0;
                 0,    0, 2.31, 0]
</pre></blockquote>
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.eigenValues"
>Matrices.eigenValues</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>sigma[min(size(A, 1), size(A, 2))]</TD><TD>Singular values</TD></TR>
<TR><TD>U[size(A, 1), size(A, 1)]</TD><TD>Left orthogonal matrix</TD></TR>
<TR><TD>VT[size(A, 2), size(A, 2)]</TD><TD>Transposed right orthogonal matrix </TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE det<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.det" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.det"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.det</H2>
<B>Determinant of a matrix (computed by LU decomposition)</B><p>
<H3>Information</H3>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Matrices.<b>det</b>(A);
</pre></blockquote>
<h4>Description</h4>
<p>
This function call returns the determinant of matrix A
computed by a LU decomposition.
Usally, this function should never be used, because
there are nearly always better numerical algorithms
as by computing the determinant. E.g., use function
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>Matrices.rank</a>
to compute the rank of a matrix.
<h4>See also</h4>
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.rank"
>Matrices.rank</a>,
<A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices.solve"
>Matrices.solve</a>
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>Determinant of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE inv<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.inv" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.inv"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.inv</H2>
<B>Inverse of a matrix (try to avoid, use function solve(..) instead)</B><p>
<H3>Information</H3>
<PRE></pre>
  
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>invA[size(A, 1), size(A, 2)]</TD><TD>Inverse of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE rank<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.rank" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.rank"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.rank</H2>
<B>Rank of a matrix (computed with singular values)</B><p>
<H3>Information</H3>
<PRE></pre>
  
<pre></PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, :]</TD><TD>Matrix</TD></TR>
<TR><TD>eps</TD><TD>If eps &gt; 0, the singular values are checked against eps; otherwise eps=max(size(A))*norm(A)*Modelica.Constants.eps is used</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>result</TD><TD>Rank of matrix A</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE balance<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.balance" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.balance"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.balance</H2>
<B>Balancing of matrix A to improve the condition of A</B><p>
<H3>Information</H3>
<PRE></pre>
<p>
The function transformates the matrix A, so that the norm of the i-th column
is nearby the i-th row. (D,B)=Matrices.balance(A) returns a vector D, such
that B=inv(diagonal(D))*A*diagonal(D) has better condition. The elements of D 
are multiples of 2. Balancing attempts to make the norm of each row equal to the
norm of the belonging column. <br>
Balancing is used to minimize roundoff errors inducted
through large matrix calculations like Taylor-series approximation
or computation of eigenvalues.
</p>
<b>Example:</b><br><br>
<pre>       - A = [1, 10,  1000; .01,  0,  10; .005,  .01,  10]
       - Matrices.norm(A, 1);
         = 1020.0
       - (T,B)=Matrices.balance(A)
       - T
         = {256, 16, 0.5}
       - B
         =  [1,     0.625,   1.953125;
             0.16,  0,       0.3125;
             2.56,  0.32,   10.0]
       - Matrices.norm(B, 1);
         = 12.265625
</pre>
<p>
The Algorithm is taken from
<dl>
<dt>H. D. Joos, G. Grbel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
which based on the balanc function from EISPACK.
</p>
 
<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>D[size(A, 1)]</TD><TD>diagonal(D)=T is transformation matrix, such that
          T*A*inv(T) has smaller condition as A</TD></TR>
<TR><TD>B[size(A, 1), size(A, 1)]</TD><TD>Balanced matrix (= diagonal(D)*A*inv(diagonal(D)))</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE exp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.exp" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.exp"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.exp</H2>
<B>Compute the exponential of a matrix by adaptive Taylor series expansion with scaling and balancing</B><p>
<H3>Information</H3>
<PRE></pre>
<p>This function computes</p>
<pre>                            (<b>A</b>T)^2   (<b>A</b>T)^3 
     <font size=4> <b>&Phi;</b></font> = e^(<b>A</b>T) = <b>I</b> + <b>A</b>T + ------ + ------ + ....
                              2!       3!
</pre>
<p>where e=2.71828..., <b>A</b> is an n x n matrix with real elements and T is a real number, 
e.g., the sampling time.
<b>A</b> may be singular. With the exponential of a matrix it is, e.g., possible
to compute the solution of a linear system of differential equations</p>
<pre>    der(<b>x</b>) = <b>A</b>*<b>x</b>   ->   <b>x</b>(t0 + T) = e^(<b>A</b>T)*x(t0) 
</pre>
<p>
The function is called as
<pre>     Phi = Matrices.exp(A,T);</pre>
or 
<pre>       M = Matrices.exp(A);
</pre>
what calculates M as the exponential of matrix A.
</p>
<p><b>Algorithmic details:</b></p>
<p>The algorithm is taken from </p>
<dl>
<dt>H. D. Joos, G. Gruebel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
<p>The following steps are performed to calculate the exponential of A:</p>
<ol>
  <li>Matrix <b>A</b> is balanced <br>
  (= is transformed with a diagonal matrix <b>D</b>, such that inv(<b>D</b>)*<b>A</b>*<b>D</b> 
  has a smaller condition as <b>A</b>).</li>
  <li>The scalar T is divided by a multiple of 2 such that norm(
       inv(<b>D</b>)*<b>A</b>*<b>D</b>*T/2^k ) &lt; 0.5. Note, that (1) and (2) are implemented such that no round-off errors 
  are introduced.</li>
  <li>The matrix from (2) is approximated by explicitly performing the Taylor 
  series expansion with a variable number of terms. 
  Truncation occurs if a new term does no longer contribute to the value of <b>&Phi;</b>
  from the previous iteration.</li>
  <li>The resulting matrix is transformed back, by reverting the steps of (2) 
  and (1).</li>
</ol>
<p>In several sources it is not recommended to use Taylor series expansion to 
calculate the exponential of a matrix, such as in 'C.B. Moler and C.F. Van Loan: 
Nineteen dubious ways to compute the exponential of a matrix. SIAM Review 20, 
pp. 801-836, 1979' or in the documentation of m-file expm2 in Matlab version 6 
(http://www.MathWorks.com) where it is stated that 'As a practical numerical 
method, this is often slow and inaccurate'. These statements are valid for a 
direct implementation of the Taylor series expansion, but <i>not</i> for the 
implementation variant used in this function. 
</p>
 
<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>T</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>phi[size(A, 1), size(A, 1)]</TD><TD>= exp(A*T)</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE integralExp<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.integralExp" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.integralExp"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.integralExp</H2>
<B>Computation of the transition-matrix phi and its integral gamma</B><p>
<H3>Information</H3>
<PRE></pre>
<p>
The function uses a Taylor series expansion with Balancing and
scaling/squaring to approximate the integral <b>&Psi;</b> of the matrix
exponential <b>&Phi;</b>=e^(AT):
</p>
<pre>                                 AT^2   A^2 * T^3          A^k * T^(k+1)
        <b>&Psi;</b> = int(e^(As))ds = IT + ---- + --------- + ... + --------------
                                  2!        3!                (k+1)!
</pre>
<p>
<b>&Phi;</b> is calculated through <b>&Phi;</b> = I + A*<b>&Psi;</b>, so A may be singular. <b>&Gamma;</b> is
simple <b>&Psi;</b>*B.
</p>
<p>The algorithm runs in the following steps: </p>
<ol>
  <li>Balancing</li>
  <li>Scaling</li>
  <li>Taylor series expansion</li>
  <li>Re-scaling</li>
  <li>Re-Balancing</li>
</ol>
<p>Balancing put the bad condition of a square matrix <i>A</i> into a diagonal
transformation matrix <i>D</i>. This reduce the effort of following calculations.
Afterwards the result have to be re-balanced by transformation D*A<small>transf</small>
 *inv(D).<br>
Scaling halfen T&nbsp; k-times, until the norm of A*T is less than 0.5. This
garantees minumum rounding errors in the following series
expansion. The re-scaling based on the equation&nbsp; exp(A*2T) = exp(AT)^2.
The needed re-scaling formula for psi thus becomes:</p>
<pre>         <b>&Phi;</b> = <b>&Phi;</b>'*<b>&Phi;</b>'
   I + A*<b>&Psi;</b> = I + 2A*<b>&Psi;</b>' + A^2*<b>&Psi;</b>'^2
         <b>&Psi;</b> = A*<b>&Psi;</b>'^2 + 2*<b>&Psi;</b>'
</pre>
<p>
where psi' is the scaled result from the series expansion while psi is the
re-scaled matrix.
</p>
<p>
The function is normally used to discretize a state-space system as the
zero-order-hold equivalent:
</p>
<pre>      x(k+1) = <b>&Phi;</b>*x(k) + <b>&Gamma;</b>*u(k)
        y(k) = C*x(k) + D*u(k)
</pre>
<p>
The zero-order-hold sampling, also known as step-invariant method, gives
exact values of the state variables, under the assumption that the control
signal u is constant between the sampling instants. Zero-order-hold sampling
is discribed in
</p>
<dl>
<dt>K. J. Astroem, B. Wittenmark:
<dd><b>Computer Controlled Systems - Theory and Design</b><br>
    Third Edition, p. 32
</dl>
<pre><b>Syntax:</b>
      (phi,gamma) = Matrices.expIntegral(A,B,T)
                       A,phi: [n,n] square matrices
                     B,gamma: [n,m] input matrix
                           T: scalar, e.g. sampling time
</pre>
<p>
The Algorithm to calculate psi is taken from
<dl>
<dt>H. D. Joos, G. Gruebel:
<dd><b>RASP'91 Regulator Analysis and Synthesis Programs</b><br>
    DLR - Control Systems Group 1991
</dl>
</p>
 
<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>T</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>phi[size(A, 1), size(A, 1)]</TD><TD>= exp(A*T)</TD></TR>
<TR><TD>gamma[size(A, 1), size(B, 2)]</TD><TD>= integral(phi)*B</TD></TR>
</TABLE>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE integralExpT<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Math.Matrices.isEqualI.png" ALT="Modelica.Math.Matrices.integralExpT" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Math.Matrices.integralExpT"></A><A HREF="Modelica_Math_Matrices.html#Modelica.Math.Matrices"
>Modelica.Math.Matrices</A>.integralExpT</H2>
<B>Computation of the transition-matrix phi and the integral gamma and gamma1</B><p>
<H3>Information</H3>
<PRE></pre>
<p>
The function calculates the matrices phi,gamma,gamma1 through the equation:
</p>
<pre>                                 [ A B 0 ]
[phi gamma gamma1] = [I 0 0]*exp([ 0 0 I ]*T)
                                 [ 0 0 0 ]
</pre>
<pre>
<b>Syntax:</b><br>
      (phi,gamma,gamma1) = Matrices.ExpIntegral2(A,B,T)
                     A,phi: [n,n] square matrices
            B,gamma,gamma1: [n,m] matrices
                         T: scalar, e.g. sampling time
</pre>
<p>
The matrices define the discretized first-order-hold equivalent of
a state-space system:
<pre>      x(k+1) = phi*x(k) + gamma*u(k) + gamma1/T*(u(k+1) - u(k))
</pre>
The first-order-hold sampling, also known as ramp-invariant method, gives
more smooth control signals as the ZOH equivalent. First-order-hold sampling
is discribed in
<dl>
<dt>K. J. Astroem, B. Wittenmark:
<dd><b>Computer Controlled Systems - Theory and Design</b><br>
    Third Edition, p. 256
</dl>
</p>
 
<pre>
</PRE>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>A[:, size(A, 1)]</TD><TD>&nbsp;</TD></TR>
<TR><TD>B[size(A, 1), :]</TD><TD>&nbsp;</TD></TR>
<TR><TD>T</TD><TD>&nbsp;</TD></TR>
</TABLE>
<H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>phi[size(A, 1), size(A, 1)]</TD><TD>= exp(A*T)</TD></TR>
<TR><TD>gamma[size(A, 1), size(B, 2)]</TD><TD>= integral(phi)*B</TD></TR>
<TR><TD>gamma1[size(A, 1), size(B, 2)]</TD><TD>= integral((T-t)*exp(A*t))*B</TD></TR>
</TABLE>
<address>HTML-documentation generated by <a href="http://www.dynasim.se/">Dymola</a> Thu Jan 29 17:27:00 2009.
</address></BODY>
</HTML>
