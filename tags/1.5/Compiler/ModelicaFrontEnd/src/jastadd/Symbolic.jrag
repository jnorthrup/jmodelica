/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect EquationSolve {
	
	syn boolean FAbstractEquation.isSolved(String name) {
		return !(solution(name) instanceof FNoExp);
	}
	
	syn nta FExp FAbstractEquation.solution(String name) {
		return new FNoExp();
	}
	
	eq FWhenEquation.solution(String name) {
		if (getNumFAbstractEquation()>1) {
			return null;
		} else {
			return getFAbstractEquation(0).solution(name);
		}
	}
	
	eq FEquation.solution(String name) {
		// Only handle this special case of the unknown occurring once
		if (nbrUses(name)!=1) {
			return new FNoExp();
		}
		
		// Get terms
		ArrayList<FExp> t = terms();
		
		FExp theTerm = null;
		// Find term
		//System.out.println("Equation:\n" + prettyPrint(""));			
		for (FExp e : t) {
			//System.out.println("Term" + (e.isNegativeTerm()? "(-): ": "(+): ") + e.prettyPrint(""));
			if (e.nbrUses(name)==1) {
				theTerm = e;
			}
		}
		//System.out.println("Found term" + (theTerm.isNegativeTerm()? "(-): ": "(+): ") + theTerm.prettyPrint(""));	
		
		FExp sol = null;
		// Build new AST for the remaining terms
		for (FExp e : t) {
			if (e!=theTerm) {
				FExp ee = (FExp)e.fullCopy();
				// Set references from the new tree to the original one
				ee.traverseSymbolic(e); 
				if (!e.isNegativeTerm()) {
				  	ee = new FNegExp(ee);
				}
				if (sol==null) {
					sol = ee;
				} else {
				    sol = new FAddExp(sol,ee);				  	
				}
			}
		}
		
		// TODO: the handling of pre expressions will be made more consistent
		// with derivative expressions - then this special handling will be
		// simplified.
		if (theTerm.isIdentifier(name) || (theTerm instanceof FPreExp)) {
			if (theTerm.isNegativeTerm()) {
				sol = new FNegExp(sol);
			}
		} else if (theTerm.isMulTerm(name)>0) {
			// not so hard
			sol = new FNoExp();
		} else if (theTerm.isDivTerm(name)) {
			// actually not so hard either...
			sol = new FNoExp();
		} else {
			// probably very hard, can't solve this.
			sol = new FNoExp();
	    }
		//System.out.println("** " + sol.prettyPrint(""));
		return sol;
	}
	
	// Get terms
	syn ArrayList<FExp> FEquation.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().terms());
		t.addAll(getRight().terms());
		return t;
	}
	
	syn ArrayList<FExp> FExp.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.add(this);
		return t;
	}
	
	eq FDotAddExp.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().terms());
		t.addAll(getRight().terms());
		return t;
	}

	eq FDotSubExp.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().terms());
		t.addAll(getRight().terms());
		return t;
	}
	
	inh boolean FExp.isNegativeTerm();
	eq FDotSubExp.getRight().isNegativeTerm() = !isNegativeTerm();
	eq FEquation.getRight().isNegativeTerm() = true;
	eq FEquation.getLeft().isNegativeTerm() = false;
	eq Root.getChild().isNegativeTerm() = false;
	
	// Classification of terms
	syn boolean FExp.isIdentifier(String name) = false;
	eq FIdUseExp.isIdentifier(String name) = name.equals(name());
	
	syn int FExp.isMulTerm(String name) = 0;
	eq FDotMulExp.isMulTerm(String name) {
		if (getLeft().isIdentifier(name)) {
			return 1;
		} else if (getRight().isIdentifier(name)) {
			return 2;
		} else {
			return 0;
		}
	}

	syn boolean FExp.isDivTerm(String name) = false;
	eq FDotDivExp.isDivTerm(String name) {
		if (getLeft().isIdentifier(name)) {
			return true;
		} else {
			return false;
		}
	}

	syn boolean FExp.isNegTerm(String name) = false;
	eq FNegExp.isNegTerm(String name) = getFExp().isIdentifier(name);
	
	syn int FEquation.nbrUses(String name) {
		return getLeft().nbrUses(name) + getRight().nbrUses(name);
	}
	
	syn int ASTNode.nbrUses(String name) {
		int n = 0;
		for (int i=0;i<getNumChild();i++) {
			n += getChild(i).nbrUses(name);
		}
		return n;
	}
	
	eq FIdUseExp.nbrUses(String name) = name.equals(name())? 1: 0;
	eq FDerExp.nbrUses(String name) = name.equals(name())? 1: 0;
	eq FPreExp.nbrUses(String name) = name.equals(name())? 1: 0;
	
	public FRelExp FRelExp.originalFRelExp = null;
	public FSampleExp FSampleExp.originalFSampleExp = null;
	public void ASTNode.traverseSymbolic(ASTNode e) {
		for (int i=0;i<getNumChild();i++) {
			getChild(i).traverseSymbolic(e.getChild(i));
		}
	}

	public void FRelExp.traverseSymbolic(ASTNode e) {
		originalFRelExp = (FRelExp)e;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).traverseSymbolic(e.getChild(i));
		}
	}

	public void FSampleExp.traverseSymbolic(ASTNode e) {
		originalFSampleExp = (FSampleExp)e;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).traverseSymbolic(e.getChild(i));
		}
	}
	
}


aspect Derivatives {

	public FAbstractEquation FAbstractEquation.diff(String name) {
		return null;
	}
	
	public FAbstractEquation FEquation.diff(String name) {
		return dynamicFAbstractEquation(new FEquation(getLeft().diff(name),
			getRight().diff(name)));
	}

	public FExp FExp.diff(String name, int n) {
		FExp e = diff(name);
			
		int i = n-1;
		while (i>0) {
			e = e.diff(name,n-1);
		}
			
		return e;

	}

	public FExp FExp.diff(String name) {
		return dynamicFExp(new FNoExp());
	}
	
	public FExp FAddExp.diff(String name) {
		return dynamicFExp(new FAddExp(getLeft().diff(name),
			getRight().diff(name)));
	}

	public FExp FSubExp.diff(String name) {
		return dynamicFExp(new FSubExp(getLeft().diff(name),
			getRight().diff(name)));
	}

	public FExp FMulExp.diff(String name) {
		return dynamicFExp(new FAddExp(
		    new FMulExp((FExp)getLeft().fullCopy(),getRight().diff(name)),
			new	FMulExp(getLeft().diff(name),(FExp)getRight().fullCopy())));
	}

	public FExp FDivExp.diff(String name) {
		return dynamicFExp(new FDivExp(new FSubExp(
		    new FMulExp((FExp)getLeft().fullCopy(),getRight().diff(name)),
			new	FMulExp(getLeft().diff(name),(FExp)getRight().fullCopy())),
			new	FPowExp((FExp)getRight().fullCopy(),new FIntegerLitExp("2"))));
	}

	public FExp FPowExp.diff(String name) {
		FExp exponent;
		FExp e;
		if (getRight().variability().constantVariability()) {
			double exponentValue = getRight().ceval().realValue();
			if (exponentValue==2.0) {
				e = (FExp)getLeft().fullCopy();
			} else {
				exponent = new FRealLitExp((getRight().ceval().realValue()-1) + "");
				e = new FPowExp((FExp)getLeft().fullCopy(),exponent);	
			}
		} else {
			exponent = new FSubExp((FExp)getRight().fullCopy(),new FIntegerLitExp("1"));
			e = new FPowExp((FExp)getLeft().fullCopy(),exponent);
		}
			
		return dynamicFExp(new FMulExp(new FMulExp((FExp)getRight().fullCopy(),
		                        e),getLeft().diff(name)));	
	}

	public FExp FSinExp.diff(String name) {
		return dynamicFExp(new FMulExp(new FCosExp((FExp)getFExp().fullCopy()),
			getFExp().diff(name)));
	}

	public FExp FIdUseExp.diff(String name) {	
		if (variability().parameterOrLess()) {
			return dynamicFExp(new FRealLitExp("0"));		
		} else if (name.equals("time")) {
			return dynamicFExp(new FDerExp((FIdUse)getFIdUse().fullCopy()));
		} else if (name.equals(name())) {
			return dynamicFExp(new FRealLitExp("1"));
		} else {
			return dynamicFExp(new FRealLitExp("0"));
		}
	}
	
	public FExp FDerExp.diff(String name) {	
		if (name.equals("time")) {
			return dynamicFExp(new FHDerExp((FIdUse)getFIdUse().fullCopy(),2));
		} else if (name.equals(name())) {
			return dynamicFExp(new FRealLitExp("1"));
		} else {
			return dynamicFExp(new FRealLitExp("0"));
		}
	}

	public FExp FHDerExp.diff(String name) {	
		if (name.equals("time")) {
			return dynamicFExp(new FHDerExp((FIdUse)getFIdUse().fullCopy(),getOrder()+1));
		} else if (name.equals(name())) {
			return dynamicFExp(new FRealLitExp("1"));
		} else {
			return dynamicFExp(new FRealLitExp("0"));
		}
	}
	
	public FExp FLitExp.diff(String name) {
		return dynamicFExp(new FRealLitExp("0"));
	}
}
