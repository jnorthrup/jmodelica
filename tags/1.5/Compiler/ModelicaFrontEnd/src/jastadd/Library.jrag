/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.io.*;
import java.util.HashSet;
import java.util.ArrayList;
import java.util.Collections;

import org.jmodelica.modelica.parser.*;

aspect Library {
	
	syn lazy List InstProgramRoot.getInstLibClassDeclList() = new List();
	
	public static final String LibNode.PACKAGE_FILE = "package.mo";
	public static final String LibNode.PACKAGE_ORDER_FILE = "package.order";
	
	syn lazy StoredDefinition LibNode.getStoredDefinition() {
		
		/* If structured
		 		a. Read all files
		 		b. Check for package.mo
		 		c. Parse package.mo
		 		d. Read all .mo files
		 		e. Add LibNodes to the LibClassDecl
		 		f. Return the LibClassDecl
		   If unstructured
		   		a. Parse the .mo file
		   		b. Return the resulting FullClassDecl  	 
		*/
	
		//log.debug("LibNode.getStoredDefinition: "+ getName() + " enter");
	    
	    
		if (getStructured()) {
			String dirName = getFileName();
			File baseDir = new File(dirName);
			File packageFile = new File(baseDir, PACKAGE_FILE);
			try {
				
				if (packageFile.isFile()) {
				    log.info("Reading file: " + packageFile);
				    ParserHandler ph = new ParserHandler();
				    SourceRoot sr = ph.parseFile(packageFile.getPath());
				    StoredDefinition entity = sr.getProgram().getUnstructuredEntity(0);
				    FullClassDecl fcd = (FullClassDecl)entity.getElement(0);
		   			entity.setFileName(packageFile.getPath());
		   			LibClassDecl lcd = new LibClassDecl(fcd);
		   				   				   			
		   			/* Obtain a list of all files
	   				   get the corresponding package for each file
	   				   and add to list of TypeDefs */
	   			
	   				List libnodes = new List();
	   			
	   				File[] filesUnStructured = baseDir.listFiles(new UnStructuredEntriesFilenameFilter());
	   				log.debug("Scanning directory: " + dirName);
	   				log.debug(" Unstructured entries: ");
	   				for (File file : filesUnStructured) {
	   					log.debug("  " + file);
	   					log.debug("*** " + fileBaseName(file));
   						libnodes.add(new LibNode(file, false));	
	   				}
	   				
	   				File[] dirs = baseDir.listFiles();
	   				log.debug(" Structured entries: ");
		   			for (File dir : dirs) {
		   				if (dir.isDirectory()){
		   					log.debug("  " +dir);
		   					log.debug("*** " + dir.getName());
		   							   						   					
	   						// Check if the directory contains a package.mo
	   						// if not, do not add a LibNode
							File subPackageFile = new File(dir, PACKAGE_FILE);
							
	   						if (subPackageFile.isFile()) {
		   						libnodes.add(new LibNode(dir, true));
							} else {
								log.debug("*** " + dir.getName() + " Not added: no package.mo present");
							}
						}
	   			
		   			}
					lcd.setLibNodeList(libnodes);
					
					File orderFile = new File(baseDir, PACKAGE_ORDER_FILE);
					if (orderFile.isFile()) {
						BufferedReader in = new BufferedReader(new FileReader(orderFile));
						java.util.List<String> order = new ArrayList<String>();
						String line;
						while ((line = in.readLine()) != null)
							order.add(line);
						lcd.setOrder(order);
					}
					
					entity.setElement(lcd, 0);
					//log.debug("LibNode.getStoredDefinition: "+ getName() + " exit1");
	   				return entity;
	   			}
			} catch (ParserException e) {
				e.getProblem().setFileName(getFileName());
				log.error(e.getProblem().toString());
				return createErrorStoredDefinition();		        
			} catch (Exception e) {
				String msg = "Error when parsing file: '" + packageFile + "':\n" + 
						"   " + e.getClass().getName() + "\n";
				if (e.getMessage() != null)
					msg = msg + "   " + e.getMessage();
				log.error(msg);
				log.stackTrace(e);
				return createErrorStoredDefinition();		        
			} 		
			
		} else {
			try {
				log.info("Reading file: " + getFileName() + "...");
				ParserHandler ph = new ParserHandler();
				SourceRoot sr = ph.parseFile(getFileName());
				for (StoredDefinition sd : sr.getProgram().getUnstructuredEntitys()) {
					sd.setFileName(getFileName());
				}
				//log.debug("LibNode.getStoredDefinition: "+ getName() + " exit2");
				return sr.getProgram().getUnstructuredEntity(0);
			} catch (ParserException e) {
				e.getProblem().setFileName(getFileName());
				log.error(e.getProblem().toString()+"\n");
				return createErrorStoredDefinition();		        
			} catch (Exception e) {
				String msg = "Error when parsing file: '" + getFileName() + "':\n" + 
						"   " + e.getClass().getName() + "\n";
				if (e.getMessage() != null)
					msg = msg + "   " + e.getMessage();
				log.error(msg);
				log.stackTrace(e);
				return createErrorStoredDefinition();		        
			} 
		}
		return null;
	}
	
	/**
	 * Gets the name of the file, without file extension.
	 */
	public static String LibNode.fileBaseName(File f) {
		String name = f.getName();
		int p = name.lastIndexOf('.');
		return (p > 0) ? name.substring(0, p) : name;
	}
	
	/**
	 * Check if a path points to a structured library.
	 */
	public static boolean LibNode.isStructuredLib(File f) {
		return f.isDirectory() && new File(f, PACKAGE_FILE).isFile();
	}
	
	public LibNode.LibNode(File loc, boolean structured) {
		this(loc.getPath(), structured ? loc.getName() : fileBaseName(loc), structured);
	}
	
	private java.util.List<String> LibClassDecl.order = Collections.emptyList();
	
	public void LibClassDecl.setOrder(java.util.List<String> order) {
		this.order = order;
	}
	
	private StoredDefinition LibNode.createErrorStoredDefinition() {
		BadClassDecl bcd = new BadClassDecl();
		bcd.setName(new IdDecl("_ErrorClassDecl_in_lib"));
		StoredDefinition sd = new StoredDefinition(new Opt(), new List());
		sd.addElement(bcd);
		return sd;		        
	}
	
	public LibNode.LibNode(String fileName, String name, boolean structured) {
		this(fileName,name,structured,"Unknown");
		
	}
	
	public LibClassDecl.LibClassDecl(FullClassDecl fcd) {
		assignFields(fcd);            
	}
	
	public void LibClassDecl.assignFields(FullClassDecl fcd) {
		setVisibilityType(fcd.getVisibilityType());
		setEncapsulatedOpt(fcd.getEncapsulatedOpt());
		setPartialOpt(fcd.getPartialOpt());
		setRestriction(fcd.getRestriction());
		setName(fcd.getName());
		setRedeclareOpt(fcd.getRedeclareOpt());
		setFinalOpt(fcd.getFinalOpt());
		setInnerOpt(fcd.getInnerOpt());
		setOuterOpt(fcd.getOuterOpt());
		setReplaceableOpt(fcd.getReplaceableOpt());
		setConstrainingClauseOpt(fcd.getConstrainingClauseOpt());
	    setConstrainingClauseCommentOpt(fcd.getConstrainingClauseCommentOpt());
		setStringCommentOpt(fcd.getStringCommentOpt());
		setEquationList(fcd.getEquationList());
		setAlgorithmList(fcd.getAlgorithmList());
		setSuperList(fcd.getSuperList());
		setImportList(fcd.getImportList());
		setClassDeclList(fcd.getClassDeclList());
		setComponentDeclList(fcd.getComponentDeclList());
		setAnnotationList(fcd.getAnnotationList());
		setExternalClauseOpt(fcd.getExternalClauseOpt());
		setEndName(fcd.getEndName());		                     
	}
	
	eq LibClassDecl.getLibNode().enclosingClassDecl() = this; 	
	eq LibClassDecl.getLibNode().classNamePrefix() = classNamePrefix().equals("")?
                                                      name(): classNamePrefix() + "." + name();
                                                      
	public LibClassDecl FullClassDecl.createLibClassDecl() {
		return new LibClassDecl(this);
	}
	
	syn lazy List Program.getLibNodeList() {
        List libnodes = new List();
        
        String modelicaPath = root().options.getStringOption("MODELICAPATH");
        log.info("MODELICAPATH = " + modelicaPath);
        String extraPath = root().options.getStringOption("extra_lib_dirs");
        log.info("extra_lib_dirs = " + extraPath);
        StringBuilder buf = new StringBuilder(modelicaPath);
        if (!extraPath.startsWith(File.pathSeparator) && !extraPath.equals(""))
        	buf.append(File.pathSeparator);
        buf.append(extraPath);
           
        // For each directory detect all libraries
        for (String pathElement : buf.toString().split(File.pathSeparator)) {
            try {
                File baseDir = new File(pathElement);
                if (baseDir.listFiles() == null) 
                    continue;
                
                // Get all Unstructured entities:
                File[] filesUnStructured = baseDir.listFiles(new UnStructuredEntriesFilenameFilter());
                
                for (File file : filesUnStructured){
                    String name = LibNode.fileBaseName(file); 
                    libnodes.add(new LibNode(file, false));            
                }
                
                for (File dir : baseDir.listFiles()) {
                    if (LibNode.isStructuredLib(dir))
                    	libnodes.add(new LibNode(dir, true));
                }
                
            } catch (Exception e) {
                // TODO: Replace with a good log.debug or just pass the exception on, 
                // perhaps wrapped in a RuntimeException
                System.err.println(e.getMessage());
                e.printStackTrace();
            }       
        }
        
        // Add extra libraries specified in PACKAGEPATHS
		try {
			String packagePath = root().options.getStringOption("PACKAGEPATHS");
			for (String pathElement : packagePath.split(File.pathSeparator)) {
				if (!pathElement.equals("")) {
					File dir = new File(pathElement);
	                libnodes.add(new LibNode(dir, true));
				}
			}
		} catch (OptionRegistry.UnknownOptionException e1) {
		}
       
         
        return libnodes;

	}
	
	static class UnStructuredEntriesFilenameFilter implements FilenameFilter {
	
			public boolean accept(File dir, String name) {
				
				if (name.equals(LibNode.PACKAGE_FILE))
					return false;
				
				return name.endsWith(".mo");
			}
		
		}
	
}