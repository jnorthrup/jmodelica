/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.ArrayList;
import java.util.Map;
import java.util.HashMap;

aspect Connections {

	/* Machinery to manage connection sets */

	public ConnectionSetManager FClass.connectionSetManager = new ConnectionSetManager();
	
	public ConnectionSetManager FClass.getConnectionSetManager() {
		return connectionSetManager;
	}

	public void FClass.genConnectionEquations() {
		log.debug("<<<FClass.genConnectionEquations()");
		ArrayList<ConnectionSet> l = connectionSetManager.getConnectionSetList();
		log.debug("<<<FClass.genConnectionEquations(): "+ l.size() + " sets in manager");
		//getConnectionSetManager().printConnectionSets();
		//System.out.println(connectionSetManager.printConnectionSets());
		
		for (ConnectionSet set : l) 
			set.generateEquations(getFEquationBlock(0));
		connectionSetManager.disconnectFromInstanceTree();
	}
		
	public void ASTNode.enableStreamsRewrite() {
		for (ASTNode n : this)
			n.enableStreamsRewrite();
	}
	
	public void FStreamBuiltIn.enableStreamsRewrite() {
		super.enableStreamsRewrite();
		rewriteStreams = true;
		is$Final = false;
	}
	
	protected boolean FStreamBuiltIn.rewriteStreams = false;

	
	/**
	 * \brief Rewrite the inSteam operator to equations. 
	 */
	rewrite FInStream {
		when (rewriteStreams) to FExp {
			// Always look for an inside occurrance of the stream variable.
			// If the variable is in an inside-inside connection, then
			// rewrite to an access. If it occurs in an inside-outside connection
			// rewrite to a new inStream operator operating on the outside
			// stream variable in the same connection set.
			String name = ((FIdUseExp) getFExp()).getFIdUse().getFQName().fullCopy().name();
			ConnectionSet cs = myFClass().getConnectionSetManager().getConnectionSet(name, false);
			if (cs != null && cs.canCreateInStreamExp()) {
				return cs.createInStreamExp(name);
			} else {
				// TODO: should throw an exception here, but this situation is detected *after* this rewrite
				this.rewriteStreams = false;
				return this;
			}
		}
	}

	rewrite FActualStream {
		when (rewriteStreams) to FExp {
			// 1) Get the stream variable name prefix
			FQName var_name = ((FIdUseExp)getFExp()).getFIdUse().getFQName();
			FQName prefix = var_name.copyPrefix();
			ArrayList<ConnectionSetEntry> cses = 
				myFClass().getConnectionSetManager().getFlowVariables(prefix.name());
			if (cses.size()==1) { // This condition should be checked earlier
				// 2) Get the name of the flow variable of the connector,
				//    there should only be one.
				FQName flow_var_name = cses.get(0).getFQName();
				// 3) Generate the expression
				FInStream then_exp = new FInStream(var_name.createFIdUseExp());
				then_exp.rewriteStreams = true; // Enable further rewrite of the inStream operator.
				FIdUseExp else_exp = var_name.createFIdUseExp();
				FGtExp guard = new FGtExp(flow_var_name.createFIdUseExp(),new FRealLitExp(0));
				FIfExp if_exp = new FIfExp(guard,then_exp,else_exp);
				return new FNoEventExp(if_exp);
			}
			throw new UnsupportedOperationException("Rewriting actualStream() for '" + var_name.name() + 
					"': found " + cses.size() + " matching flow variables");
		}
	}

	
	public abstract class ConnectionSet extends TreeSet<ConnectionSetEntry> {
		
		protected ConnectionSet(ConnectionSetEntry e) {
			add(e);
		}
		
		public static ConnectionSet create(ConnectionSetEntry e) {
			if (e.isFlow())
				return new FlowConnectionSet(e);
			else if (e.isStream())
				return new StreamConnectionSet(e);
			else 
				return new PotentialConnectionSet(e);
		}
		
		public void disconnectFromInstanceTree() {
			for (ConnectionSetEntry e : this)
				e.disconnectFromInstanceTree();
		}
		
		public int getNumInside() {
			int nInside = 0;
			for (ConnectionSetEntry cse : this) {
				if (cse.isInside()) {
					nInside++;
				}
			}
			return nInside;
		}
		
		public int getNumOutside() {
			int nOutside = 0;
			for (ConnectionSetEntry cse : this) {
				if (cse.isOutside()) {
					nOutside++;
				}
			}
			return nOutside;			
		}

		public ConnectionSetEntry getConnectionSetEntry(String name, boolean outside) {
			for (ConnectionSetEntry cse : this) {
				if (cse.equals(name, outside)) {
					return cse;
				}
			}
			return null;
		}
		
		/**
		 * Check if a rewrite expression can be generated for an inStream() on a variable in this set.
		 * 
		 * Default implementation returns false, since inStream() only applies to stream connecton sets.
		 */
		public boolean canCreateInStreamExp() {
			return false;
		}
		
		/**
		 * Create rewrite expression for an inStream() on a variable in this set.
		 * 
		 * Only valid for stream connecton sets.
		 * 
		 * @param name  the name of the variable to generate name for
		 */
		public FExp createInStreamExp(String name) {
			throw new UnsupportedOperationException();
		}
		
		/**
		 * Generate equations for this set.
		 * 
		 * @param eb  equation block to add equations to
		 */
		public abstract void generateEquations(FEquationBlock eb);
		
		/**
		 * Return all ConnectionSetEntrys corresponding to flow variables based
		 * on a name prefix. This method is useful when generating expressions
		 * for actualStream operators when the name of the flow variable in a
		 * stream connector is needed.
		 */
		public ArrayList<ConnectionSetEntry> getFlowVariables(String prefix) {
			return new ArrayList<ConnectionSetEntry>(0);
		}
		
		public int numStreamVariables() {
			int n_stream_vars = 0;
			for (ConnectionSetEntry e : this) {
				if (e.isStream()) {
					n_stream_vars++;
				}
			}
			return n_stream_vars;
		}
		
		public String toString() {
			StringBuffer str = new StringBuffer();
			
			str.append("Connection set (");
			str.append(typeString());
			str.append("): {");
			String set_str = super.toString();
			str.append(set_str.substring(1, set_str.length() - 1));
			str.append("}\n");
			return str.toString();
		}
		
		protected abstract String typeString();
		
	}
	
	public class FlowConnectionSet extends ConnectionSet {
		
		public FlowConnectionSet(ConnectionSetEntry e) {
			super(e);
		}
		
		public String typeString() {
			return "flow";
		}
		
		public ArrayList<ConnectionSetEntry> getFlowVariables(String prefix) {
			ArrayList<ConnectionSetEntry> cses = new ArrayList<ConnectionSetEntry>();
			for (ConnectionSetEntry cse : this) 
				if (cse.prefix().equals(prefix)) 
					cses.add(cse);
			return cses;
		}

		public void generateEquations(FEquationBlock eb) {
			FExp e = null;
			for (ConnectionSetEntry cse : this) 
				e = cse.createFIdUseExp().appendSum(e, cse.isOutside());
			FExp zero = first().getVar().size().createZeroFExp();
			eb.addFAbstractEquationNoTransform(new FEquation(e, zero));	
		}

	}
	
	public class StreamConnectionSet extends ConnectionSet {
		
		public StreamConnectionSet(ConnectionSetEntry e) {
			super(e);
		}
		
		public String typeString() {
			return "stream";
		}

		public void generateEquations(FEquationBlock eb) {
			// If the connection set has two member one being inside
			// and one being outside an additional equation should
			// be generated.
			if (size() == 2 && first().isOutside() != last().isOutside()) {
				FExp e1 = first().createFIdUseExp();
				FExp e2 = last().createFIdUseExp();
				eb.addFAbstractEquationNoTransform(new FEquation(e1, e2));
			}
		}
		
		/**
		 * Check if a rewrite expression can be generated for an inStream() on a variable in this set.
		 */
		public boolean canCreateInStreamExp() {
			return size() <= 2 && getNumInside() >= 1;
		}
		
		/**
		 * Create rewrite expression for an inStream() on a variable in this set.
		 * 
		 * @param name  the name of the variable to generate name for
		 */
		public FExp createInStreamExp(String name) {
			int N = getNumInside(); // # of inside
			if (size() == 1)
				return new FIdUseExp(name);
			boolean inFirst = first().equals(name, false);
			ConnectionSetEntry containing = inFirst ? first() : last();
			ConnectionSetEntry select;
			int nOutside = getNumOutside();
			if (nOutside == 1)
				select = first().isOutside() ? first() : last();
			else
				select = inFirst ? last() : first();
			FExp res = select.createFIdUseExp(name, containing);
			if (nOutside == 1) {
				FInStream fis = new FInStream(res);
				fis.rewriteStreams = true;
				res = fis;
			}
			return res;
		}
		
	}
	
	public class PotentialConnectionSet extends ConnectionSet {
		
		public PotentialConnectionSet(ConnectionSetEntry e) {
			super(e);
		}
		
		public String typeString() {
			return "potential";
		}

		public void generateEquations(FEquationBlock eb) {
			FExp e1 = null;
			for (ConnectionSetEntry cse : this) {
				FExp e2 = cse.createFIdUseExp();
				if (e1 != null)
					eb.addFAbstractEquationNoTransform(new FEquation(e1, e2));
				e1 = e2;
			}
		}
		
	}
	

	public class ConnectionSetManager {
	
		private ArrayList<ConnectionSet> list = new ArrayList<ConnectionSet>();
		private Map<ConnectionSetEntry, ConnectionSet> entryMap = new HashMap<ConnectionSetEntry, ConnectionSet>();
		
		public ArrayList<ConnectionSet> getConnectionSetList() {
			return list;
		}
			
		public void addInsideFlowVar(InstComponentDecl var1, FQName namePrefix1) {
			ConnectionSetEntry cse = new ConnectionSetEntry(var1, false, namePrefix1);
			
			if (getConnectionSet(cse) == null) {
				ConnectionSet set = ConnectionSet.create(cse);
				list.add(set);
				entryMap.put(cse, set);
			}
		}
		
		public void addVars(InstComponentDecl var1, boolean outside1, FQName namePrefix1,
		                    InstComponentDecl var2, boolean outside2, FQName namePrefix2) {

//			log.debug("ConnectionSetManager.addVars");
		
//		    System.out.println(namePrefix1.name()+" . "+var1.name() + " outside: " + outside1);
//		    System.out.println(namePrefix2.name()+" . "+var2.name() + " outside: " + outside2);
		
			// Don't add parameters or constants to connection set
			if (var1.variability().parameterOrLess() || var2.variability().parameterOrLess()) 
				return;
			
			ConnectionSetEntry cse1 = new ConnectionSetEntry(var1, outside1, namePrefix1);
			ConnectionSetEntry cse2 = new ConnectionSetEntry(var2, outside2, namePrefix2);	

			ConnectionSet setA = getConnectionSet(cse1);
			ConnectionSet setB = getConnectionSet(cse2);
			
			if (setA != null && setB != null) {
				if (setA != setB)
					merge(setA, setB);
			} else if (setA != null && setB == null) {
				add(setA, cse2);
			} else if (setA == null && setB != null) {
				add(setB, cse1);
			} else if (setA == null && setB == null) {
				join(cse1, cse2);
			}
		}
		
		private void join(ConnectionSetEntry entryA, ConnectionSetEntry entryB) {
			ConnectionSet set = ConnectionSet.create(entryA);
			set.add(entryB);
			list.add(set);
			entryMap.put(entryA, set);
			entryMap.put(entryB, set);
		}
		
		private void add(ConnectionSet set, ConnectionSetEntry entry) {
			set.add(entry);
			entryMap.put(entry, set);
		}
		
		private void merge(ConnectionSet setA, ConnectionSet setB) {
			if (setA.size() < setB.size()) {
				ConnectionSet tmp = setA;
				setA = setB;
				setB = tmp;
			}
			for (ConnectionSetEntry entry : setB)
				entryMap.put(entry, setA);
			setA.addAll(setB);
			list.remove(setB);
		}
		
		public ConnectionSet getConnectionSet(ConnectionSetEntry cse) {
			return entryMap.get(cse);
		}

		public ConnectionSet getConnectionSet(String name, boolean outside) {
			for (ConnectionSet set : list) {
				if (set.getConnectionSetEntry(name,outside)!=null) {
					return set;
				}		
			}
			return null;
		}

		public ArrayList<ConnectionSetEntry> getFlowVariables(String prefix) {
			ArrayList<ConnectionSetEntry> cses = new ArrayList<ConnectionSetEntry>();
			for (ConnectionSet set : list) {
				cses.addAll(set.getFlowVariables(prefix));		
			}
			return cses;
		}
		
		public void disconnectFromInstanceTree() {
			for (ConnectionSet set : list)
				set.disconnectFromInstanceTree();
		}
		
		public String printConnectionSets() {
		
			StringBuffer str = new StringBuffer();
			
			str.append("Connection sets: " + list.size() + " sets\n");
			
			// Print connection sets 
			for(ConnectionSet set : list) {
				str.append(set);
			}

			return str.toString();
		}
	}

	
	public class ConnectionSetEntry implements Comparable<ConnectionSetEntry> {
	
		private InstComponentDecl cd;
		private boolean outside;
		private boolean stream;
		private boolean flow;
		private FQName fqName;
		private String prefix;
		private String str;
		private String[] scalarNames;
		//private boolean flow;
		
		public ConnectionSetEntry(InstComponentDecl cd, boolean outside, FQName fqName) {
			//log.debug("Created ConnectionSetEntry: " + cd.getName().getID());
			this.cd = cd;
			this.outside = outside;
			this.fqName = fqName;
			prefix = null;
			flow = cd.getComponentDecl().isFlow();
			stream = cd.getComponentDecl().isStream();
		}
		
		public void disconnectFromInstanceTree() {
			cd = null;
		}
	
		public boolean isOutside() {
			return outside;
		}

		public boolean isInside() {
			return !outside;
		}

		public InstComponentDecl getVar() {
			return cd;
		}
		
		public boolean isFlow() {
			return flow;
		}

		public boolean isStream() {
			return stream;
		}
		
		public String name() {
		   return fqName.name();
		}
		
		public String prefix() {
			if (prefix == null) 
				prefix = fqName.copyPrefix().name();
			return prefix;
		}
		
		public boolean equals(String name, boolean outside) {
			if (outside != this.outside)
				return false;
			if (scalarNames != null) {
				for (String scalarName : scalarNames)
					if (name.equals(scalarName))
						return true;
				return false;
			} else {
				return name.equals(name());
			}
		}
		
		public String toString() {
			if (str == null)
				str = fqName + (outside ? " (o)" : " (i)");
			return str;
		}
		
		public FQName getFQName() {
			return fqName;
		}

		public FExp createFIdUseExp() {
			return fqName.createFIdUseExp();
		}

		/**
		 * Create an FIdUseExp that is an acces to a variable in this entry, that is connected to 
		 * the variable named <code>name</code> in <code>other</code>.
		 */
		public FExp createFIdUseExp(String name, ConnectionSetEntry other) {
			if (other == this)
				return new FIdUseExp(name); 
			if (scalarNames == null || other.scalarNames == null)
				return createFIdUseExp();
			int i;
			for (i = 0; i < other.scalarNames.length && !other.scalarNames[i].equals(name); i++);
			return (i < scalarNames.length) ? new FIdUseExp(scalarNames[i]) : createFIdUseExp();
		}

		public int hashCode() {
			return toString().hashCode();
		}
		
		
		public boolean equals(Object o) {
			if (o instanceof ConnectionSetEntry) {
				return toString().equals(o.toString());
			}
			return false;
		}
	
		public int compareTo(ConnectionSetEntry cse) {
			return toString().compareTo(cse.toString());
		}
	
	}
	
	
	public void InstAccess.connectTo(InstAccess right, FQName prefix, ConnectionSetManager csm) {
		FQName leftName  = flattenAndResolveIndices(prefix);
		FQName rightName = right.flattenAndResolveIndices(prefix);
		
		boolean leftOutside  = isOutsideConnector();
		boolean rightOutside = right.isOutsideConnector();
		
		if (isArray()) {
			Indices leftInd = indices();
			Indices rightInd = right.indices();
			Iterator<Index> leftIter = leftInd.iterator();
			Iterator<Index> rightIter = rightInd.iterator();
			InstComponentDecl leftComp  = lookupEvaluatingIndices();
			InstComponentDecl rightComp = right.lookupEvaluatingIndices();
			while (leftIter.hasNext()) {
				Index leftI = leftInd.translate(leftIter.next());
				Index rightI = rightInd.translate(rightIter.next());
				FQName leftCellName = leftName.copyReplacingSubscripts(leftI);
				FQName rightCellName = rightName.copyReplacingSubscripts(rightI);
				InstComponentDecl leftCompCell = leftComp.findCell(leftI, leftI.ndims() - leftComp.ndims());
				InstComponentDecl rightCompCell = rightComp.findCell(rightI, rightI.ndims() - rightComp.ndims());
				leftCompCell.connectTo(leftOutside, leftCellName, rightCompCell, rightOutside, rightCellName, csm);
			}
		} else {
			InstComponentDecl leftComp  = lookupEvaluatingIndices();
			InstComponentDecl rightComp = right.lookupEvaluatingIndices();
			leftComp.connectTo(leftOutside, leftName, rightComp, rightOutside, rightName, csm);
		}
	}
	
	public void InstComponentDecl.connectTo(boolean leftOutside, FQName leftName, 
			InstComponentDecl rightComp, boolean rightOutside, FQName rightName, ConnectionSetManager csm) {
		SortedSet<InstComponentDecl> rightChildren = rightComp.containedInstComponents();
		for (InstComponentDecl leftComp2 : containedInstComponents()) {
			InstComponentDecl rightComp2 = rightChildren.tailSet(leftComp2).first();
			FQName leftName2  = leftComp2.flattenedAccess(leftName);
			FQName rightName2 = rightComp2.flattenedAccess(rightName);
			leftComp2.connectTo(leftOutside, leftName2, rightComp2, rightOutside, rightName2, csm);
		}
	}

	public void InstPrimitive.connectTo(boolean leftOutside, FQName leftName, 
			InstComponentDecl rightComp, boolean rightOutside, FQName rightName, ConnectionSetManager csm) {
		csm.addVars(this, leftOutside, leftName, rightComp, rightOutside, rightName);
	}
	
	syn InstComponentDecl InstComponentDecl.findCell(Index i, int j) = 
		(j < i.ndims()) ? getInstComponentDecl(i.get(j) - 1).findCell(i, j + 1) : this;
	eq InstPrimitive.findCell(Index i, int j) = this;

	syn boolean InstAccess.isOutsideConnector() = getFirstInstAccess().myInstComponentDecl().isConnector();
	
	syn boolean InstComponentDecl.isConnector() = myInstClass().isConnector();
	
	
	public void FAbstractEquation.buildConnectionSets(FQName prefix, ConnectionSetManager csm) { }
	
	public void FIfEquation.buildConnectionSets(FQName prefix, ConnectionSetManager csm) {
		try {
			if (getTest().ceval().booleanValue())
				for (FAbstractEquation equ : getFAbstractEquations())
				    equ.buildConnectionSets(prefix, csm);
		} catch (ConstantEvaluationException e) {
		}
	}
	
	public void InstForClauseE.buildConnectionSets(FQName prefix, ConnectionSetManager csm) {
		Indices indices = Indices.create(getInstForIndexs());
		for (Index i : indices) {
			int j = 0;
			int[] ii = indices.translate(i).index();
			for (InstForIndex fi : getInstForIndexs()) {
				fi.getInstPrimitive().setEvaluationValue(new CValueInteger(ii[j]), null);
				j++;
			}
			for (FAbstractEquation equ : getFAbstractEquations())
			    equ.buildConnectionSets(prefix, csm);
		}
	}
	
	public void FConnectClause.buildConnectionSets(FQName prefix, ConnectionSetManager csm) {
		if (!getConnector1().isDisabled() && !getConnector2().isDisabled()) {
			InstAccess left  = getConnector1().getInstAccess();
			InstAccess right = getConnector2().getInstAccess();
			left.connectTo(right, prefix, csm);
		}
	}

}