import org.jmodelica.ide.helpers.Maybe;
import org.jmodelica.ide.namecomplete.CompletionComment;
import org.jmodelica.ide.namecomplete.CompletionFilter;
import java.util.ArrayList;

aspect Semantic {

    /**
     * @return true iff. ASTNode contains point (line, col).
     */
    public boolean ASTNode.containsPoint(IDocument d, int offset) {
        
        int line, col;
        try {

            line = d.getLineOfOffset(offset);
            col = offset - d.getLineOffset(line);
            line++; // go from 0-based to 1-based line number
        
        } catch (BadLocationException e) { return false; }
        
        
        boolean beginsBefore = 
            getBeginLine() == line && getBeginColumn() <= col ||
            getBeginLine() < line;
        
        boolean endsAfter = 
            getEndLine() == line && getEndColumn() >= col ||
            getEndLine() > line;
        
        return beginsBefore && endsAfter;
    }    
    
       
    /**
     * Return class declaration at offset. Favour inner classes over outer.
     * Ignores short class declarations.
     */
    syn Maybe<ClassDecl> ASTNode.getClassDeclAt(IDocument d, int offset);
    
    eq ASTNode.getClassDeclAt(IDocument d, int offset) {
        for (ASTNode<?> child : this) {
            Maybe<ClassDecl> rec = child.getClassDeclAt(d, offset);  
            if (rec.hasValue())
                return rec;
        }
        return Maybe.Nothing(ClassDecl.class);
        
    }
    
    eq FullClassDecl.getClassDeclAt(IDocument d, int offset) {
        return super.getClassDeclAt(d, offset)
                    .orElse(Maybe.fromBool(this, containsPoint(d, offset)));
    }
    
    /**
     * Return access at offset. Favour left child of Dot nodes over the Dot
     * node itself, but not the right child. I.e. (where ^ marks the offset)

     *  ...qualifi^ed.name      returns "qualified", while
     *  ...qualified.na^me      returns "qualified.name"
     *     
     */
    syn Maybe<Access> ASTNode.getAccessAt(IDocument d, int offset); 
    
    eq ASTNode.getAccessAt(IDocument d, int offset) {
        for (ASTNode<?> child : this) {
            Maybe<Access> rec = child.getAccessAt(d, offset);  
            if (rec.hasValue())
                return rec;
        }
        return Maybe.Nothing(Access.class);
    }
    
    eq Dot.getAccessAt(IDocument d, int offset) {
        if (!containsPoint(d, offset))
            return Maybe.Nothing(Access.class);
        return getLeft().getAccessAt(d, offset).orElse(Maybe.Just(this));
    }
    
    eq Access.getAccessAt(IDocument d, int offset) {
        if (containsPoint(d, offset))
            return Maybe.Just(this);
        return Maybe.Nothing(Access.class);
    }
    
    
    syn ArrayList<InstNode> InstNode.completionNodes() = new ArrayList<InstNode>();
    
    /**
     * Completion proposals for InstClassDecl:s are all classes and
     * (constant) components.
     */
    eq InstClassDecl.completionNodes() {
        ArrayList<InstNode> completions = new ArrayList<InstNode>();
        completions.addAll(instClassDecls());
        completions.addAll(instComponentDecls());
        return completions;
    }
    
    /**
     * Completion proposals for InstComponentDecl:s are only components. 
     */
    eq InstComponentDecl.completionNodes() = 
        new ArrayList<InstNode>(instComponentDecls()); 

    /**
     * Returns a list of completion suggestions for <code>decl</code>, filtering
     * out suggestions not matching <code>filter</code>.
     * 
     * @param access access to give completions for
     * @param filter Filter for matches
     * @return list of suggestions
     */   
    public ArrayList<InstNode> InstNode.completionProposals(
            CompletionFilter filter) {

        ArrayList<InstNode> proposals = new ArrayList<InstNode>();

        for (InstNode node : completionNodes())
            if (filter.matches(node.name()))
                proposals.add(node);
        
        return proposals;
    }

}

/**
 * Get the string comment from classes to display in the content assist. 
 */
aspect ComletionComment {
    
    syn CompletionComment InstNode.proposalComment() = CompletionComment.NULL;
    eq InstClassDecl.proposalComment() = new CompletionComment(myInstClass().getClassDecl().stringComment());
    
    syn String ASTNode.stringComment() = null;
    eq FullClassDecl.stringComment() = hasStringComment() ? getStringComment().getComment() : null;
    
}

/**
 *  Finds location of referencing node for the things we are interested 
 *  in cross referencing.
 */
aspect CrossReference {
    
    /**
     * Get referencing node.
     */
    syn HashSet<IJastAddNode> ASTNode.getReference();
    
    eq ComponentAccess.getReference()
        = lookupComponent(getID());
    
    eq ClassAccess.getReference()
        = lookupClass(getID());
    
    eq ASTNode.getReference() = new HashSet<IJastAddNode>();
    
    /**
     * Finding the source node of given declaration for lookup.
     * TODO: why is this not working?
     */
    inh StoredDefinition ASTNode.getStoredDefinition();
    eq StoredDefinition.getChild().getStoredDefinition() = this;
    eq ASTNode.getChild().getStoredDefinition() = null;
}

//TODO: remove. only for debugging
aspect NADebugging {    
    
    public void ASTNode.debugNN(String ind) {
        System.out.printf("%s%s: (%d,%d)-(%d,%d), (%d-%d)\n", ind, 
                this.getNodeName(), 
                this.getBeginLine(),   this.getBeginColumn(),
                this.getEndLine(),     this.getEndColumn(),
                this.getBeginOffset(), this.getEndOffset());
    }
    
    public void ASTNode.printASTqq(String ind) {
        this.debugNN(ind);
        for (ASTNode node : this) 
            node.printASTqq(ind + "  ");
    }
  
}
