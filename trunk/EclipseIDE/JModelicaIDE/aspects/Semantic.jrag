import org.jmodelica.ide.helpers.Maybe;
import org.jmodelica.ide.namecomplete.CompletionComment;
import org.jmodelica.ide.namecomplete.CompletionFilter;
import java.util.ArrayList;

/**
 *  Find the ASTNode corresponding to a certain position in the source code. 
 */
aspect LookupFromSource {

    syn boolean ASTNode.hasCompletions() = false;
    eq ClassDecl.hasCompletions() = true;
    
    syn Maybe<ASTNode<T>> ASTNode.getNodeAt(IDocument d, int offset);

    /**
     * @return true iff. ASTNode contains point (line, col).
     */
    public boolean ASTNode.containsPoint(int line, int col) {
        
        boolean beginsBefore = 
            getBeginLine() == line && getBeginColumn() <= col ||
            getBeginLine() < line;
        
        boolean endsAfter = 
            getEndLine() == line && getEndColumn() >= col ||
            getEndLine() > line;
        
        return beginsBefore && endsAfter;
    }    
    
    /** 
     * Returns the ASTNode at line <code>line</code>, column <code>col</code>.
     * Looks through the entire AST to find the best match.
     */
    eq ASTNode.getNodeAt(IDocument d, int offset) {
        
        int line, col;
        try {
            line = d.getLineOfOffset(offset);
            col = offset - d.getLineOffset(line);
        } catch (BadLocationException e) { 
            return null; 
        }
        
        ASTNode result = null;
        
        if (hasCompletions() && containsPoint(line, col))
            result = this;
        
        for (ASTNode node : this) { 
            // recurse down the tree
            ASTNode tmp = (ASTNode)node.getNodeAt(d, offset).value(); 
            if (tmp != null)
                result = tmp;
        }

        return new Maybe<ASTNode<T>>(result);
    }
    
    syn ArrayList<InstNode> InstNode.completionNodes() = new ArrayList<InstNode>();
    
    /**
     * Completion proposals for InstClassDecl:s are all classes and
     * (constant) components.
     */
    eq InstClassDecl.completionNodes() {
        ArrayList<InstNode> completions = new ArrayList<InstNode>();
        completions.addAll(instClassDecls());
        completions.addAll(instComponentDecls());
        return completions;
    }
    
    /**
     * Completion proposals for InstComponentDecl:s are only components. 
     */
    eq InstComponentDecl.completionNodes() = 
        new ArrayList<InstNode>(instComponentDecls()); 

    /**
     * Returns a list of completion suggestions for <code>decl</code>, filtering
     * out suggestions not matching <code>filter</code>.
     * 
     * @param access access to give completions for
     * @param filter Filter for matches
     * @return list of suggestions
     */   
    public ArrayList<InstNode> InstNode.completionProposals(
            CompletionFilter filter) {

        ArrayList<InstNode> proposals = new ArrayList<InstNode>();

        for (InstNode node : completionNodes())
            if (filter.matches(node.name()))
                proposals.add(node);
        
        return proposals;
    }

}

/**
 * Get the string comment from classes to display in the content assist. 
 */
aspect ComletionComment {
    
    syn CompletionComment InstNode.proposalComment() = CompletionComment.NULL;
    eq InstClassDecl.proposalComment() = new CompletionComment(myInstClass().getClassDecl().stringComment());
    
    syn String ASTNode.stringComment() = null;
    eq FullClassDecl.stringComment() = hasStringComment() ? getStringComment().getComment() : null;
    
}

/**
 *  Finds location of referencing node for the things we are interested 
 *  in cross referencing.
 */
aspect CrossReference {
    
    /**
     * Get referencing node.
     */
    syn HashSet<IJastAddNode> ASTNode.getReference();
    
    eq ComponentAccess.getReference()
        = lookupComponent(getID());
    
    eq ClassAccess.getReference()
        = lookupClass(getID());
    
    eq ASTNode.getReference() = new HashSet<IJastAddNode>();
    
    /**
     * Finding the source node of given declaration for lookup.
     * TODO: why is this not working?
     */
    inh StoredDefinition ASTNode.getStoredDefinition();
    eq StoredDefinition.getChild().getStoredDefinition() = this;
    eq ASTNode.getChild().getStoredDefinition() = null;
}

//TODO: remove. only for debugging
aspect NADebugging {    
    
    public void ASTNode.debugNN(String ind) {
        System.out.printf("%s%s: (%d,%d)-(%d,%d), (%d-%d)\n", ind, 
                this.getNodeName(), 
                this.getBeginLine(),   this.getBeginColumn(),
                this.getEndLine(),     this.getEndColumn(),
                this.getBeginOffset(), this.getEndOffset());
    }
    
    public void ASTNode.printASTqq(String ind) {
        this.debugNN(ind);
        for (ASTNode node : this) 
            node.printASTqq(ind + "  ");
    }
  
}
