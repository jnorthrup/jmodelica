import org.jmodelica.icons.CoordinateSystem;
import org.jmodelica.icons.Placement;
import org.jmodelica.icons.Transformation;
import org.jmodelica.icons.Types;
import org.jmodelica.icons.Types.LinePattern;
import org.jmodelica.icons.Types.FillPattern;
import org.jmodelica.icons.Types.BorderPattern;
import org.jmodelica.icons.Types.Smooth;
import org.jmodelica.icons.Types.Arrow;
import org.jmodelica.icons.Types.TextStyle;
import org.jmodelica.icons.Types.TextAlignment;
import org.jmodelica.icons.drawing.IconConstants.Context;
import org.jmodelica.icons.Layer;
import org.jmodelica.icons.Extent;
import org.jmodelica.icons.FilledRectShape;
import org.jmodelica.icons.FilledShape;
import org.jmodelica.icons.GraphicItem;
import org.jmodelica.icons.Ellipse;
import org.jmodelica.icons.Line;
import org.jmodelica.icons.Point;
import org.jmodelica.icons.Text;
import org.jmodelica.icons.Rectangle;
import org.jmodelica.icons.Polygon;
import org.jmodelica.icons.Color;
import org.jmodelica.icons.Bitmap;
import org.jmodelica.icons.exceptions.FailedConstructionException;
import org.jmodelica.icons.exceptions.NotEnoughParametersException;
import java.lang.IllegalArgumentException;


aspect AnnotationParsing {
	
	public class AnnotationNode {
		
		/**
		* Creates the icon layer represented by this AnnotationNode. 
		* @return icon layer if annotationNode exist else a NO_LAYER 
		*/
		public Layer createIconLayer() {
			Layer layer;
			if (forPath("Icon").exists()) {
				layer = new Layer(
						forPath("Icon/coordinateSystem").createCoordinateSystem(), 
						forPath("Icon/graphics").createGraphics()
				); 
			}else {
				layer = Layer.NO_LAYER;
			}
			return layer;
		}
		/**
		* Creates the diagram layer represented by this AnnotationNode.
		* @return diagram layer if annotationNode exist else a NO_LAYER 
		*/
		public Layer createDiagramLayer() {
			Layer layer;
			if (forPath("Diagram").exists()) {
				layer =  new Layer(
						forPath("Diagram/coordinateSystem").createCoordinateSystem(), 
						forPath("Diagram/graphics").createGraphics()
				);
			} else {
				layer = Layer.NO_LAYER;
			}
			return layer;
		}
		/**
		* Creates a Placement represented by this AnnotationNode.
		* @param context for which layer transformation is to be set for the component.   
		* @return placement
		* @throws NotEnoughParametersException if too few parameters are provided for palcement.
		* @throws FailedConstructionExceptionException if placement annotatioNode does not exist. 
		*/
		public Placement createPlacement(Context context) 
				throws FailedConstructionException, NotEnoughParametersException {
			AnnotationNode placementAnnotation = forPath("Placement");
			if(placementAnnotation.exists()) {
				boolean visible = false;
				Transformation diagramTransformation = null;
				Transformation iconTransformation = null;
				for (AnnotationNode a : placementAnnotation) {
					if (a.name().equals("transformation")) {
						diagramTransformation = a.createTransformation();
					} else if (a.name().equals("iconTransformation")) {	
						iconTransformation = a.createTransformation();
					} else if (a.name().equals("visible")) {
						visible = a.bool();
					}
				}
				if(diagramTransformation != null) {
					if(iconTransformation != null) {
						if (context.equals(Context.ICON)) {
							return new Placement(visible, iconTransformation);
						} else {
							return new Placement(visible, diagramTransformation);
						}
					}
					else {
						return new Placement(visible, diagramTransformation);
					}
				}
				throw new NotEnoughParametersException("Placement");
			}
			throw new FailedConstructionException("Placement");
		}
		
		public boolean hasPlacement() {
			return forPath("Placement").exists();
		}
		/**
		* Creates a Transformation represented by this AnnotationNode.
		* @return the created transformation.
		* @throws NotEnoughParametersException if the extent parameter was not given.
		* @throws FailedConstructionExceptionException if transformation annotatioNode does not exist. 
		*/
		private Transformation createTransformation() 
			throws FailedConstructionException, NotEnoughParametersException {
			Transformation transformation = new Transformation();
			boolean extentSet = false;
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("extent")) {
						transformation.setExtent(a.createExtent());
						extentSet = true;
					} else if (a.name().equals("origin")) {
						transformation.setOrigin(a.createOrigin());
					} else if (a.name().equals("rotation")) {
						transformation.setRotation(a.createRotation());
					}
				} catch(FailedConstructionException e) {
				}
			}
			if (!extentSet) {
				throw new NotEnoughParametersException("Transformation");
			}
			return transformation;
		}
		/**
		* Creates a Coordinatesystem represented by this AnnotationNode.
		* @return the created CoordinateSystem if the annotationNode exists else a 
		* deafult Coordinatesystem according to MLS. 
		*/
		private CoordinateSystem createCoordinateSystem() {
			if (!exists()) {
				return CoordinateSystem.DEFAULT_COORDINATE_SYSTEM;
			}
			CoordinateSystem co = new CoordinateSystem();
			for(AnnotationNode c : this) {
				try {
					if (c.name().equals("preserveAspectRatio")) {
						co.setPreserveAspectRatio(c.bool());
					}else if (c.name().equals("extent")) {
						co.setExtent(c.createExtent());
					}else if (c.name().equals("grid")) {
						co.setGrid(c.createGrid());	
					} else if (c.name().equals("initialScale")) {
						//co.setInitialScale(c.real());
					}
				} catch (FailedConstructionException e) {
				}catch(IllegalArgumentException ie) {
				}
			}
			return co;
		}
		/**
		* Return the grid attribute represented by this AnnotationNode.
		* @return a grid vector.
		* @throws FailedConstructionException if grid vector was null.	
		* */
		private double[] createGrid() 
			throws FailedConstructionException, NotEnoughParametersException, IllegalArgumentException {
			if(realVector() != null) {
				double[] grid = realVector();
				return grid;
			}
			throw new FailedConstructionException("Grid");
		}
		
		/**
		* Creates a list with the graphics attribute represented by this AnnotationNode.
		* @return the created list.		
		* */
		private ArrayList<GraphicItem> createGraphics() {
			ArrayList<GraphicItem> items = new ArrayList<GraphicItem>();
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("Line")) {
						items.add(a.createLine());
					}
					else if (a.name().equals("Rectangle")) {
						items.add(a.createRectangle());
					}
					else if (a.name().equals("Polygon")) {
						items.add(a.createPolygon());
					}
					else if (a.name().equals("Ellipse")) {
						items.add(a.createEllipse());
					}
					else if (a.name().equals("Text")) {
						items.add(a.createText());
					} 
					else if (a.name().equals("Bitmap")) {
						items.add(a.createBitmap());
					}
				} catch (FailedConstructionException e) {
				}
			}
			return items;
		}
	
		/**
		* Create a FilledShape that is represented by this AnnotationNode uses 
		* 	default values for the attributes if the attributes are not set.
		* @return the created FilledShape
		*/
		private FilledShape createFilledShape(FilledShape filledShape) {
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("lineColor")) {
						filledShape.setLineColor(a.createColor());
					}
					else if (a.name().equals("pattern")) {
						filledShape.setLinePattern(a.createLinePattern());
					}
					else if (a.name().equals("fillColor")) {
						filledShape.setFillColor(a.createColor());
					}
					else if (a.name().equals("fillPattern")) {
						filledShape.setFillPattern(a.createFillPattern());
					} 
					else if (a.name().equals("lineThickness")) {
						filledShape.setLineThickness(a.createLineThickness());
					}
				} catch (FailedConstructionException e){
					
				}
			}
			return (FilledShape)createGraphicItem(filledShape);
		}
		
		/**
		* Create a GraphicItem object that is represented by this AnnotationNode.
		* @param graphicItem
		* @return the created Graphic item
		*/
		private GraphicItem createGraphicItem(GraphicItem graphicItem) {
			for (AnnotationNode a : this) {
				if (a.name().equals("visible")) {
					graphicItem.setVisible(a.bool());
				} else if (a.name().equals("origin")) {
					try {
						graphicItem.setOrigin(a.createOrigin());
					}catch (FailedConstructionException e) {}
				} else if (a.name().equals("rotation")) {
					graphicItem.setRotation(a.createRotation());
				}
			}
			return graphicItem;
		}
		/**
		* Create a FilledShape that is represented by this AnnotationNode. 
		* @param FilledRectShape
		* @return the created FilledShape
		* @throws NotEnoughParametersException if the extent parameter was not given.
		*/
		private FilledShape createFilledRectShape(FilledRectShape filledRectShape) 
				throws FailedConstructionException, NotEnoughParametersException {
			
			for (AnnotationNode a : this) {
				if (a.name().equals("extent")) {
					filledRectShape.setExtent(a.createExtent());
					return createFilledShape(filledRectShape);
				}
			}
			throw new NotEnoughParametersException("FilledRectShape");
		}
	
		/**
		* Create an Ellipse primitive that is represented by this AnnotationNode. 
		* @return the created Ellipse primitive
		* @throws NotEnoughParametersException if the extent parameter was not given.
		*/
		private Ellipse createEllipse()
				throws FailedConstructionException, NotEnoughParametersException {
			Ellipse ellipse = new Ellipse();
			ellipse = (Ellipse)createFilledRectShape(ellipse);
			for (AnnotationNode a : this) {
				if (a.name().equals("startAngle")) {
					ellipse.setStartAngle(a.createStartAngle());
				} else if (a.name().equals("endAngle")) {
					ellipse.setStartAngle(a.createEndAngle());
				}
			}
			return ellipse;
		}
		/**
		* Create a Bitmap primitive that is represented by this AnnotationNode uses 
		* @return the created Bitmap primitive
		* @throws NotEnoughParametersException if the extent, file name or image source 
		* 	parameters were not given.
		*/
		private Bitmap createBitmap() 
		throws FailedConstructionException, NotEnoughParametersException {
			Bitmap bitmap = new Bitmap();
			bitmap = (Bitmap)createGraphicItem(bitmap);
			boolean extentSet = false;
			boolean fileNameSet = false;
			boolean imageSourceSet = false;
			for (AnnotationNode a : this) {
				if (a.name().equals("extent")) {
					bitmap.setExtent(a.createExtent());
					extentSet = true;
				} else if (a.name().equals("fileName")) {
					bitmap.setFileName(a.string());
					fileNameSet = true;
				} else if (a.name().equals("imageSource")) {
					bitmap.setImageSource(a.string());
					imageSourceSet = true;
				}
			}
			if (!extentSet || !(fileNameSet || imageSourceSet)) {
				throw new NotEnoughParametersException("Bitmap");
			}
			return bitmap;
		}

		/**
		* Create a Line primitive that is represented by this AnnotationNode uses 
		* 	default values for the attributes if the attributes are not set.
		* @return the created Line primitive
		* @throws NotEnoughParametersException if two points were not given.
		*/
		private Line createLine() 
				throws FailedConstructionException, NotEnoughParametersException {
			Line line = new Line();
			line = (Line)createGraphicItem(line);
			boolean pointsSet = false;
			for (AnnotationNode a : this) {
				if (a.name().equals("points")) {
					line.setPoints(a.createPoints());
					pointsSet = true;
				} else if (a.name().equals("color")) {
					try {
						line.setColor(a.createColor());
					} catch(FailedConstructionException e) {}
				} else if (a.name().equals("thickness")) {
					try {
						line.setThickness(a.createThickness());
					} catch(FailedConstructionException e) {}
				} else if (a.name().equals("pattern")) {
					try {
						line.setLinePattern(a.createLinePattern());
					} catch(FailedConstructionException e) {}
				} else if (a.name().equals("smooth")) {
					try {
						line.setSmooth(a.createSmooth());
					} catch(FailedConstructionException e) {}
				} else if (a.name().equals("arrow")) {
					try {
						line.setArrow(a.createArrow());
					} catch(FailedConstructionException e) {}
				} else if (a.name().equals("arrowSize")) {
					try {
						line.setArrowSize(a.createArrowSize());
					} catch(FailedConstructionException e) {}
				}
			}
			if (!pointsSet) {
				throw new NotEnoughParametersException("Line");
			}
			return line;
		}
	
		/**
		* Create the Point object represented by this AnnotationNode.
		* @return the created Point
		* @throws FailedConstructionException if the provided data is anything else than 2 real numbers.
		*/
		private Point createPoint() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createPoint();
				}
			}
			double[] vector = realVector();
			if (vector == null) {
				throw new FailedConstructionException("Point");
			} else if (vector.length != 2) {
				throw new FailedConstructionException("Point");
			}
			return new Point(vector[0], vector[1]);
		}
	
		/**
		* Creates a origin represented by this AnnotationNode.
		* @return the created origin.
		* @throws FailedConstructionException if the creating Point object fails.
		*/
		private Point createOrigin() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createOrigin();
				}
			}
			try {
				return createPoint();
			} catch(FailedConstructionException e) {
				throw new FailedConstructionException("Origin");
			}
		}
		
		/**
		* Create the arrow parameter represented by this AnnotationNode.
		* @return the created arrow.
		* @throws FailedConstructionException if the data provided is anything else than 2 
		* String objects, or if one of the String objects doesn't match a legal Arrow value. 
		*/
		private Arrow[] createArrow() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createArrow();
				}
			}
			ArrayList<String> strings = stringList();
			if (strings == null) {
				throw new FailedConstructionException("Arrow");
			} else if (strings.size() != 2) {
				throw new FailedConstructionException("Arrow");
			}
			Arrow[] arrow = new Arrow[2];
			for (int i = 0; i < 2; i++) {
				String s = strings.get(i);
				arrow[i] = Arrow.valueOf(
					s.substring(s.indexOf(".")+1).toUpperCase()
				);
				if (arrow[i] == null) {
					throw new FailedConstructionException("Arrow");
				}
			}
			return arrow;
		}
		/**
		* Return rotaion value for this AnnotationNode.
		* @return rotation
		*/
		private double createRotation() {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createRotation();
				}
			}
			return real();
		}
		/**
		* Return thickness value for this AnnotationNode.
		* @return thickness
		* @throws FailedConstructionException if thickness < 0.
		*/
		private double createThickness() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createThickness();
				}
			}
			double thickness = real();
			if (thickness >= 0) {
				return thickness;
			} else throw new FailedConstructionException("Thickness");
		}
		/**
		* Return line thickness value for this AnnotationNode.
		* @return line thickness
		* @throws FailedConstructionException if line thickness < 0.
		*/
		private double createLineThickness() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createLineThickness();
				}
			}
			return createThickness();
		}
		/**
		* Return arrow size value for this AnnotationNode.
		* @return arrow size
		* @throws FailedConstructionException if size < 0.
		*/
		private double createArrowSize() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createArrowSize();
				}
			}
			double size = real();
			if (size >= 0) {
				return size;
			} else throw new FailedConstructionException("Arrow size");
		}	
		/**
		* Return radius value for this AnnotationNode.
		* @return radius
		* @throws FailedConstructionException if radius < 0.
		*/
		private double createRadius() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createRadius();
				}
			}
			double radius = real();
			if (radius >= 0) {
				return radius;
			}
			throw new IllegalArgumentException("Illegal value radius");
		}
		/**
		* Return start angle value for this AnnotationNode.
		* @return start angle
		*/
		private double createStartAngle() { 
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createStartAngle();
				}
			}
			return real();
		}
		/**
		* Return end angle value for this AnnotationNode.
		* @return end angle
		*/
		private double createEndAngle() { 
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createEndAngle();
				}
			}
			return real();
		}
		
		/**
		* Creates the Rectangle primitive represented by this AnnotationNode.
		* @return the created Rectangle.
		* @throws FailedConstructionException if the construction of one of its component fails.
		* @throws NotEnoughParametersException if the extent parameter is not provided.
		*/
		private Rectangle createRectangle()
				throws FailedConstructionException, NotEnoughParametersException {
			Rectangle rect = new Rectangle();
			rect = (Rectangle)createFilledRectShape(rect);
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("borderPattern")) {
						rect.setBorderPattern(a.createBorderPattern());
					} else if (a.name().equals("radius")) {
						rect.setRadius(a.createRadius());
					}
				}catch(FailedConstructionException e) {
				}catch(IllegalArgumentException ia) {
				}
			}
			return rect;
		}
		
		
		/**
		* Returns the Text primitive represented by this AnnotationNode.
		* @return the created Text primitive.
		* @throws FailedConstructionException if the construction of one of its parameters
		* fails.
		* @throws NotEnoughParametersException if either the extent or the textString
		* parameter was not provided.
		*/
		private Text createText()
				throws FailedConstructionException, NotEnoughParametersException {
			Text text = new Text();
			text = (Text)createFilledRectShape(text);
			boolean textStringSet = false;
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("textStyle")) {
						text.setTextStyle(a.createTextStyle()); 
					} else if (a.name().equals("fontSize")) {
						text.setFontSize(a.createFontSize());
					} else if (a.name().equals("fontName")) {
						text.setFontName(a.createFontName());
					} else if (a.name().equals("textString")) {
						if(a.string() != null) {	
							text.setTextString(a.string());
							textStringSet = true;
						}
					} else if (a.name().equals("horizontalAlignment")) {
						text.setHorizontalAlignment(a.createHorizontalAlignment());
					}
				}
				catch(FailedConstructionException e) {
				}
			}
			if (!textStringSet) {
				throw new NotEnoughParametersException("Text");
			}
			return text;
		}
		
		/**
		* Returns the Polygon primitive represented by this AnnotationNode.
		* @return the created Polygon
		* @throws NotEnoughParametersException if no points parameter was given.
		* @throws FailedConstructionException if construction of points failes.
		*/
		private Polygon createPolygon()
				throws FailedConstructionException, NotEnoughParametersException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createPolygon();
				}
			}
			Polygon polygon = new Polygon();
			polygon = (Polygon)createFilledShape(polygon);
			boolean pointsSet = false;
			for (AnnotationNode a : this) {
				if (a.name().equals("points")) {
					polygon.setPoints(a.createPoints());
					pointsSet = true;
				} else if (a.name().equals("smooth")) {
					try {
						polygon.setSmooth(a.createSmooth());
					} catch (FailedConstructionException e) {}
				}
			}
			if (!pointsSet) {
				throw new NotEnoughParametersException("Polygon");
			}
			return polygon;
		}
		
		/**
		* Returns the horizontalAlignment value represented by this AnnotationNode.
		* @return TextAlignment
		* @throws FailedConstructionException if an illegal TextAlignment value was found.
		*/
		private TextAlignment createHorizontalAlignment() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createHorizontalAlignment();
				}
			}
			String alignmentStr = string();
			if (alignmentStr == null) {
				throw new FailedConstructionException("TextAlignment");
			}
			TextAlignment alignment = null;
			try {
				alignment = TextAlignment.valueOf(
					alignmentStr.substring(
						alignmentStr.indexOf(".")+1,
						alignmentStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("TextAlignment");
			}
			return alignment;
		}
		
		/**
		* Returns the fillPattern value represented by this AnnotationNode.
		* @return fillpattern
		* @throws FailedConstructionException if no String value was given or
		* if an illegal fillPattern value was given. 
		*/
		private FillPattern createFillPattern()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createFillPattern();
				}
			}
			String patternStr = string();
			if (patternStr == null) {
				throw new FailedConstructionException("FillPattern");
			}
			FillPattern pattern = null;
			try {
				pattern = FillPattern.valueOf(
					patternStr.substring(
						patternStr.indexOf(".")+1,
						patternStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("FillPattern");
			}
			return pattern; 
		}
		
		/**
		* Returns the linePattern value represented by the given AnnotationNode.
		* @return pattern
		* @throws FailedConstructionException if no String value was given or
		* if an illegal linePattern value was given. 
		*/
		private LinePattern createLinePattern()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createLinePattern();
				}
			}
			String patternStr = string();
			if (patternStr == null) {
				throw new FailedConstructionException("LinePattern");
			}
			LinePattern pattern = null;
			try {
				pattern = LinePattern.valueOf(
					patternStr.substring(
						patternStr.indexOf(".")+1,
						patternStr.length()
					).toUpperCase()
				);
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("LinePattern");
			}
			return pattern; 
		}
		
		/**
		* Returns the borderPattern value represented by this AnnotationNode.
		* @return borderpattern
		* @throws FailedConstructionException if no String value was given or
		* if an illegal borderPattern value was given. 
		*/
		private BorderPattern createBorderPattern()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createBorderPattern();
				}
			}
			String patternStr = string();
			if (patternStr == null) {
				throw new FailedConstructionException("BorderPattern");
			}
			BorderPattern pattern = null;
			try {
				pattern = BorderPattern.valueOf(
					patternStr.substring(
						patternStr.indexOf(".")+1,
						patternStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("BorderPattern");
			}
			return pattern; 
		}
		
		/**
		* Returns the smooth value represented by this AnnotationNode.
		* @return smooth value
		* @throws FailedConstructionException if no String value was given or
		* if an illegal smooth value was given. 
		*/
		private Smooth createSmooth()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createSmooth();
				}
			}
			String smoothStr = string();
			if (smoothStr == null) {
				throw new FailedConstructionException("Smooth");
			}
			Smooth smooth = null;
			try {
				smooth = Smooth.valueOf(
					smoothStr.substring(
						smoothStr.indexOf(".")+1,
						smoothStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("Smooth");
			}
			return smooth; 
		}
		
		/**
		* Returns the textStyle value represented by this AnnotationNode.
		* @return textstyle
		* @throws FailedConstructionException If too many modifications are found or if
		* any of the string values doesn't match a legal TextStyle.
		*/
		private ArrayList<Types.TextStyle> createTextStyle()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createTextStyle();
				}
			}
			ArrayList<Types.TextStyle> textStyle = new ArrayList<Types.TextStyle>();
			ArrayList<String> stringList = stringList();
			if(stringList == null)
			{
				throw new FailedConstructionException("ConstructTextstyle");
			}
			int i = 0;
			try {
				for(String s : stringList)
				{
					textStyle.add(i,Types.TextStyle.valueOf(
							s.substring(
									s.indexOf(".")+1,
									s.length()
							).toUpperCase()
					));
					i++;
				}
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("TextStyle");
			}
			return textStyle;
		}
		
		/**
		* Returns the fontName parameter that is represented by this AnnotationNode.
		* @return fontname
		*/
		private String createFontName()
		{	
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createFontName();
				}
			}
			return string();
		}
		
		/**
		* Returns the fontSize value represented by this AnnotationNode.
		* @return font size
		* @throws FailedConstructionException if the font size is less than zero.
		*/
		private int createFontSize()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createFontSize();
				}
			}
			int fontSize = (int)real();
			if (fontSize >= 0) {
				return fontSize;
			} 
			throw new FailedConstructionException("Font size");
		}
		
		/**
		* Create color represented by this AnnotationNode.
		* @return Color
		* @throws FailedConstructionException if anything else than 3 values were given 
		* 	or if each value in the vector is value < 0 or value > 255.
		*/
		private Color createColor() 
			throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createColor();
				}
			}
			double[] vector = realVector();
			if (vector != null) {
				if (vector.length != 3) {
					throw new FailedConstructionException("Color");
				} else {
					for(int i = 0; i < 3; i++) {
						if(vector[i] < 0 || vector[i]> 255) { 
							throw new FailedConstructionException("Color");
						}
					}
				}
			} else {
				throw new FailedConstructionException("Color");
			}
			return new Color((int)vector[0], (int)vector[1], (int)vector[2]);
		}
		
		/**
		* Creates a list of points represented by this AnnotationNode.
		* @return the created list of points
		* @throws FailedConstructionException if no values were given.
		*/
		private ArrayList<Point> createPoints() 
			throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createPoints();
				}
			}
			ArrayList<Point> points = new ArrayList<Point>();
			double[][] matrix = realMatrix();
			if(matrix != null) { 
				for (int i = 0; i < matrix.length; i++) {
					if(matrix[i] == null) {	
						continue;
					} 
					if(matrix[i].length > 1) {
						points.add(new Point(
							matrix[i][0], 
							matrix[i][1]
						));
					} 
				}
			} else {
				throw new NotEnoughParametersException("points");
			}
			return points;
		}
		
		/**
		* Returns the extent represented by this AnnotationNode.
		* @throws FailedConstructionException if too few or too many values are given. 
		*/
	
		private Extent createExtent() 
			throws FailedConstructionException, NotEnoughParametersException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createExtent();
				}
			}
			ArrayList<Point> points = createPoints();
			if (points.size() < 2) {
				throw new NotEnoughParametersException("extent");
			}
			return new Extent(points.get(0), points.get(1));
		}
	}
}