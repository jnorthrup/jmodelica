import org.jmodelica.icons.mls.CoordinateSystem;
import org.jmodelica.icons.mls.Placement;
import org.jmodelica.icons.mls.Transformation;
import org.jmodelica.icons.mls.Types;
import org.jmodelica.icons.mls.Types.LinePattern;
import org.jmodelica.icons.mls.Types.FillPattern;
import org.jmodelica.icons.mls.Types.BorderPattern;
import org.jmodelica.icons.mls.Types.Smooth;
import org.jmodelica.icons.mls.Types.Arrow;
import org.jmodelica.icons.mls.Types.TextStyle;
import org.jmodelica.icons.mls.Types.TextAlignment;
import org.jmodelica.icons.IconConstants.Context;
import org.jmodelica.icons.mls.Layer;
import org.jmodelica.icons.mls.Extent;
import org.jmodelica.icons.mls.FilledRectShape;
import org.jmodelica.icons.mls.FilledShape;
import org.jmodelica.icons.mls.GraphicItem;
import org.jmodelica.icons.mls.Ellipse;
import org.jmodelica.icons.mls.Line;
import org.jmodelica.icons.mls.Point;
import org.jmodelica.icons.mls.Text;
import org.jmodelica.icons.mls.Rectangle;
import org.jmodelica.icons.mls.Polygon;
import org.jmodelica.icons.mls.Color;
import org.jmodelica.icons.mls.Bitmap;
import org.jmodelica.icons.exceptions.FailedConstructionException;
import org.jmodelica.icons.exceptions.NotEnoughParametersException;
import java.lang.IllegalArgumentException;

aspect AnnotationParsing {
	public class AnnotationNode {
		public Layer createIconLayer(String path) {
			Layer layer;
			if (forPath("Icon").exists()) {
				layer = new Layer(
						forPath("Icon/coordinateSystem").createCoordinateSystem(), 
						forPath("Icon/graphics").createGraphics(path)
				); 
			}else {
				layer = Layer.NO_LAYER;
			}
			return layer;
		}
	
		public Layer createDiagramLayer(String path) {
			Layer layer;
			if (forPath("Diagram").exists()) {
				layer =  new Layer(
						forPath("Diagram/coordinateSystem").createCoordinateSystem(), 
						forPath("Diagram/graphics").createGraphics(path)
				);
			} else {
				layer = Layer.NO_LAYER;
			}
			return layer;
		}
	//	TODO
	//	vi borde kolla context innan man anropar 
	//	diagramTransformation/iconTransformation
		public Placement createPlacement(Context context) 
				throws FailedConstructionException, NotEnoughParametersException {
			AnnotationNode placementAnnotation = forPath("Placement");
			if(placementAnnotation.exists()) {
				boolean visible = false;
				Transformation diagramTransformation = null;
				Transformation iconTransformation = null;
				for (AnnotationNode a : placementAnnotation) {
					if (a.name().equals("transformation")) {
						diagramTransformation = a.createTransformation();
					} else if (a.name().equals("iconTransformation")) {	
						iconTransformation = a.createTransformation();
					} else if (a.name().equals("visible")) {
						visible = a.bool();
					}
				}
				if(diagramTransformation != null) {
					if(iconTransformation != null) {
						if (context.equals(Context.ICON)) {
							return new Placement(visible, iconTransformation);
						} else {
							return new Placement(visible, diagramTransformation);
						}
					}
					else {
						return new Placement(visible, diagramTransformation);
					}
				}
				throw new NotEnoughParametersException("Placement");
			}
			throw new FailedConstructionException("Placement");
		}
		
		public boolean hasPlacement() {
			return forPath("Placement").exists();
		}
		//TODO vill man ha defaultextent i transformation??
		//nu skapas ej transformation om extent inte finns eller är fel
		private Transformation createTransformation() 
			throws FailedConstructionException, NotEnoughParametersException {
			Transformation transformation = new Transformation(null);
			boolean extentSet = false;
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("extent")) {
						transformation.setExtent(a.createExtent());
						extentSet = true;
					} else if (a.name().equals("origin")) {
						transformation.setOrigin(a.createOrigin());
					} else if (a.name().equals("rotation")) {
						transformation.setRotation(a.createRotation());
					}
				} catch(FailedConstructionException e) {
					System.out.println(e.getMessage());
				}
			}
			if (!extentSet) {
				throw new NotEnoughParametersException("Transformation");
			}
			return transformation;
		}
	
		private CoordinateSystem createCoordinateSystem() {
			if (!exists()) {
				return CoordinateSystem.DEFAULT_COORDINATE_SYSTEM;
			}
			CoordinateSystem co = new CoordinateSystem();
			for(AnnotationNode c : this) {
				try {
					if (c.name().equals("preserveAspectRatio")) {
						co.setPreserveAspectRatio(c.bool());
					}else if (c.name().equals("extent")) {
						co.setExtent(c.createExtent());
					}else if (c.name().equals("grid")) {
						//TODO hur ska vi använda Grid?
						co.setGrid(c.createGrid());	
					} else if (c.name().equals("initialScale")) {
						//TODO läs initialScale
						//co.setInitialScale(c.real());
					}
				} catch (FailedConstructionException e) {
					System.out.println(e.getMessage());
				}catch(IllegalArgumentException ie) {
					System.out.println(ie.getMessage());
				}
			}
			return co;
		}
	//	TODO fixa färdig när vi vet hur grid ska användas
		private double[] createGrid() 
			throws FailedConstructionException, NotEnoughParametersException, IllegalArgumentException {
			if(realVector() != null) {
				double[] grid = realVector();
				return grid;
			}
			throw new FailedConstructionException("Grid");
		}
		
		/**
		* Returns the graphics attribute represented by the given AnnotationNode.
		* @param graphicsAnnotation
		* @return
		* @throws FailedConstructionException if the construction of one of its primitives fails.
		* @throws NotEnoughParametersException if too few parameters are provided for one of its primitives.
		*/
		private ArrayList<GraphicItem> createGraphics(String path) {
			ArrayList<GraphicItem> items = new ArrayList<GraphicItem>();
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("Line")) {
						items.add(a.createLine());
					}
					else if (a.name().equals("Rectangle")) {
						items.add(a.createRectangle());
					}
					else if (a.name().equals("Polygon")) {
						items.add(a.createPolygon());
					}
					else if (a.name().equals("Ellipse")) {
						items.add(a.createEllipse());
					}
					else if (a.name().equals("Text")) {
						items.add(a.createText());
					} 
					else if (a.name().equals("Bitmap")) {
						items.add(a.createBitmap(path));
					}
				} catch (FailedConstructionException e) {
					System.out.println(e);
				}
			}
			return items;
		}
	
		/**
		* Returns the FilledShape object that is represented by the given AnnotationNode.
		* @param filledRectShapeAnnotation
		* @param filledRectShape The FilledRectShape object to store the values in.
		* @return
		* @throws FailedConstructionException if the construction of one of its primitives fails.
		*/
		private FilledShape createFilledShape(FilledShape filledShape) 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("lineColor")) {
						filledShape.setLineColor(a.createColor());
					}
					else if (a.name().equals("pattern")) {
						filledShape.setLinePattern(a.createLinePattern());
					}
					else if (a.name().equals("fillColor")) {
						filledShape.setFillColor(a.createColor());
					}
					else if (a.name().equals("fillPattern")) {
						filledShape.setFillPattern(a.createFillPattern());
					} else if (a.name().equals("lineThickness")) {
						filledShape.setLineThickness(a.createLineThickness());
					}
				} catch (FailedConstructionException e){
					System.out.println(e.getMessage());
				}
			}
			return (FilledShape)createGraphicItem(filledShape);
		}
		
		/**
		* Rerurns the GraphicItem object that is represented by this AnnotationNode.
		* @param graphicItemAnnotation
		* @param graphicItem
		* @return
		* @throws FailedConstructionException if the construction of one of its prarameters fails.
		*/
		private GraphicItem createGraphicItem(GraphicItem graphicItem) {
			for (AnnotationNode a : this) {
				if (a.name().equals("visible")) {
					graphicItem.setVisible(a.bool());
				} else if (a.name().equals("origin")) {
					try {
						graphicItem.setOrigin(a.createOrigin());
					}catch (FailedConstructionException e) {}
				} else if (a.name().equals("rotation")) {
					graphicItem.setRotation(a.createRotation());
				}
			}
			return graphicItem;
		}
		private FilledShape createFilledRectShape(FilledRectShape filledRectShape) 
				throws FailedConstructionException, NotEnoughParametersException {
			
			for (AnnotationNode a : this) {
				if (a.name().equals("extent")) {
					filledRectShape.setExtent(a.createExtent());
					return createFilledShape(filledRectShape);
				}
			}
			throw new NotEnoughParametersException("FilledRectShape");
		}
	
		/**
		* Returns the Ellipse primitive that is represented by the given AnnotationNode.
		* @param ellipseAnnotation
		* @return
		* @throws FailedConstructionException if the construction of one of its primitives fails.
		* @throws NotEnoughParametersException if the extent parameter was not given.
		*/
		private Ellipse createEllipse()
				throws FailedConstructionException, NotEnoughParametersException {
			Ellipse ellipse = new Ellipse();
			ellipse = (Ellipse)createFilledRectShape(ellipse);
			for (AnnotationNode a : this) {
				if (a.name().equals("startAngle")) {
					ellipse.setStartAngle(a.createStartAngle());
				} else if (a.name().equals("endAngle")) {
					ellipse.setStartAngle(a.createEndAngle());
				}
			}
			return ellipse;
		}
	
		private Bitmap createBitmap(String path) 
				throws FailedConstructionException, NotEnoughParametersException {
			Bitmap bitmap = new Bitmap();
			bitmap = (Bitmap)createGraphicItem(bitmap);
			boolean extentSet = false;
			boolean fileNameSet = false;
			boolean imageSourceSet = false;
			for (AnnotationNode a : this) {
				if (a.name().equals("extent")) {
					bitmap.setExtent(a.createExtent());
					extentSet = true;
				} else if (a.name().equals("fileName")) {
					bitmap.setFileName(a.string(), path);
					fileNameSet = true;
				} else if (a.name().equals("imageSource")) {
					bitmap.setImageSource(a.string());
					imageSourceSet = true;
				}
			}
			if (!extentSet || !(fileNameSet || imageSourceSet)) {
				throw new NotEnoughParametersException("Bitmap");
			}
			return bitmap;
		}
		
		private Line createLine() 
				throws FailedConstructionException, NotEnoughParametersException {
			Line line = new Line();
			line = (Line)createGraphicItem(line);
			boolean pointsSet = false;
			for (AnnotationNode a : this) {
				if (a.name().equals("points")) {
					line.setPoints(a.createPoints());
					pointsSet = true;
				} else if (a.name().equals("color")) {
					line.setColor(a.createColor());
				} else if (a.name().equals("thickness")) {
					line.setThickness(a.createThickness());
				} else if (a.name().equals("pattern")) {
					line.setLinePattern(a.createLinePattern());
				} else if (a.name().equals("smooth")) {
					line.setSmooth(a.createSmooth());
				} else if (a.name().equals("arrow")) {
					line.setArrow(a.createArrow());
				} else if (a.name().equals("arrowSize")) {
					line.setArrowSize(a.createArrowSize());
				}
			}
			if (!pointsSet) {
				throw new NotEnoughParametersException("Line");
			}
			return line;
		}
	
		/**
		* Returns the Point object that is represented by this AnnotationNode.
		* @param pointAnnotation
		* @return
		* @throws FailedConstructionException if the provided data is anything else than 2 real numbers.
		*/
		private Point createPoint() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createPoint();
				}
			}
			double[] vector = realVector();
			if (vector == null) {
				throw new FailedConstructionException("Point");
			} else if (vector.length != 2) {
				throw new FailedConstructionException("Point");
			}
			return new Point(vector[0], vector[1]);
		}
	
		/**
		* Returns the origin parameter that is represented by this AnnotationNode.
		* @param originAnnotation
		* @return
		* @throws FailedConstructionException if the construction of the MLSPoint object fails.
		*/
		private Point createOrigin() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createOrigin();
				}
			}
			try {
				return createPoint();
			} catch(FailedConstructionException e) {
				throw new FailedConstructionException("Origin");
			}
		}
		
		/**
		* Returns the arrow parameter that is represented by the given AnnotationNode.
		* @param arrowAnnotation
		* @return
		* @throws FailedConstructionException if the data provided is anything else than 2 
		* String objects, or if one of the String objects doesn't match a legal Arrow value. 
		*/
		private Arrow[] createArrow() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createArrow();
				}
			}
			ArrayList<String> strings = stringList();
			if (strings == null) {
				throw new FailedConstructionException("Arrow");
			} else if (strings.size() != 2) {
				throw new FailedConstructionException("Arrow");
			}
			Arrow[] arrow = new Arrow[2];
			for (int i = 0; i < 2; i++) {
				String s = strings.get(i);
				arrow[i] = Arrow.valueOf(
					s.substring(s.indexOf(".")+1).toUpperCase()
				);
				if (arrow[i] == null) {
					throw new FailedConstructionException("Arrow");
				}
			}
			return arrow;
		}
		
		private double createRotation() {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createRotation();
				}
			}
			return real();
		}
		
		private double createThickness() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createThickness();
				}
			}
			double thickness = real();
			if (thickness >= 0) {
				return thickness;
			} else throw new FailedConstructionException("Thickness");
		}
		
		private double createLineThickness() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createLineThickness();
				}
			}
			return createThickness();
		}
		
		private double createArrowSize() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createArrowSize();
				}
			}
			double size = real();
			if (size >= 0) {
				return size;
			} else throw new FailedConstructionException("Arrow size");
		}	
		
		private double createRadius() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createRadius();
				}
			}
			double radius = real();
			if (radius >= 0) {
				return radius;
			}
			throw new IllegalArgumentException("Illegal value radius");
		}
		
		private double createStartAngle() { 
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createStartAngle();
				}
			}
			return real();
		}
		
		private double createEndAngle() { 
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createEndAngle();
				}
			}
			return real();
		}
		
		/**
		* Returns the Rectangle primitive represented by the given AnnotationNode.
		* @param rectangleAnnotation
		* @return
		* @throws FailedConstructionException if the construction of one of its component fails.
		* @throws NotEnoughParametersException if the extent parameter is not provided.
		*/
		private Rectangle createRectangle()
				throws FailedConstructionException, NotEnoughParametersException {
			Rectangle rect = new Rectangle();
			rect = (Rectangle)createFilledRectShape(rect);
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("borderPattern")) {
						rect.setBorderPattern(a.createBorderPattern());
					} else if (a.name().equals("radius")) {
						rect.setRadius(a.createRadius());
					}
				}catch(FailedConstructionException e) {
					System.out.println(e.getMessage());
				}catch(IllegalArgumentException ia) {
					System.out.println(ia.getMessage());
				}
			}
			return rect;
		}
		
		
		/**
		* Returns the Text primitive that is represented by the given AnnotationNode.
		* @param textAnnotation
		* @return
		* @throws FailedConstructionException if the construction of one of its parameters
		* fails.
		* @throws NotEnoughParametersException if either the extent or the textString
		* parameter was not provided.
		*/
		//TODO fånga exceptions
		private Text createText()
				throws FailedConstructionException, NotEnoughParametersException {
			Text text = new Text();
			text = (Text)createFilledRectShape(text);
			boolean textStringSet = false;
			for (AnnotationNode a : this) {
				try {
					if (a.name().equals("textStyle")) {
						text.setTextStyle(a.createTextStyle()); 
					} else if (a.name().equals("fontSize")) {
						text.setFontSize(a.createFontSize());
					} else if (a.name().equals("fontName")) {
						text.setFontName(a.createFontName());
					} else if (a.name().equals("textString")) {
						if(a.string() != null) {	
							text.setTextString(a.string());
							textStringSet = true;
						}
					} else if (a.name().equals("horizontalAlignment")) {
						text.setHorizontalAlignment(a.createHorizontalAlignment());
					}
				}
				catch(FailedConstructionException e) {
					System.out.println(e.getMessage());
				}
			}
			if (!textStringSet) {
				throw new NotEnoughParametersException("Text");
			}
			return text;
		}
		
		/**
		* Returns the Polygon primitive that is represented by this AnnotationNode.
		* @param polygonAnnotation
		* @return
		* @throws FailedConstructionException if the construction of one of its primitives and
		* parameters fails.
		* @throws NotEnoughParametersException if no points parameter was given.
		*/
		private Polygon createPolygon()
				throws FailedConstructionException, NotEnoughParametersException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createPolygon();
				}
			}
			Polygon polygon = new Polygon();
			polygon = (Polygon)createFilledShape(polygon);
			boolean pointsSet = false;
			for (AnnotationNode a : this) {
				if (a.name().equals("points")) {
					polygon.setPoints(a.createPoints());
					pointsSet = true;
				} else if (a.name().equals("smooth")) {
					polygon.setSmooth(a.createSmooth());
				}
			}
			if (!pointsSet) {
				throw new NotEnoughParametersException("Polygon");
			}
			return polygon;
		}
		
		/**
		* Returns the horizontalAlignment parameter represented by this AnnotationNode.
		* @param horizontalAlignmentAnnotation
		* @return
		* @throws FailedConstructionException if an illegal TextAlignment value was found.
		*/
		private TextAlignment createHorizontalAlignment() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createHorizontalAlignment();
				}
			}
			String alignmentStr = string();
			if (alignmentStr == null) {
				throw new FailedConstructionException("TextAlignment");
			}
			TextAlignment alignment = null;
			try {
				alignment = TextAlignment.valueOf(
					alignmentStr.substring(
						alignmentStr.indexOf(".")+1,
						alignmentStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("TextAlignment");
			}
			return alignment;
		}
		
		/**
		* Returns the fillPattern parameter represented by the given AnnotationNode.
		* @param fillPatternAnnotation
		* @return
		* @throws FailedConstructionException if no String value was given or
		* if an illegal fillPattern value was given. 
		*/
		private FillPattern createFillPattern()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createFillPattern();
				}
			}
			String patternStr = string();
			if (patternStr == null) {
				throw new FailedConstructionException("FillPattern");
			}
			FillPattern pattern = null;
			try {
				pattern = FillPattern.valueOf(
					patternStr.substring(
						patternStr.indexOf(".")+1,
						patternStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("FillPattern");
			}
			return pattern; 
		}
		
		/**
		* Returns the linePattern parameter represented by the given AnnotationNode.
		* @param linePatternAnnotation
		* @return
		* @throws FailedConstructionException if no String value was given or
		* if an illegal linePattern value was given. 
		*/
		private LinePattern createLinePattern()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createLinePattern();
				}
			}
			String patternStr = string();
			if (patternStr == null) {
				throw new FailedConstructionException("LinePattern");
			}
			LinePattern pattern = null;
			try {
				pattern = LinePattern.valueOf(
					patternStr.substring(
						patternStr.indexOf(".")+1,
						patternStr.length()
					).toUpperCase()
				);
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("LinePattern");
			}
			return pattern; 
		}
		
		/**
		* Returns the borderPattern parameter represented by the given AnnotationNode.
		* @param borderPatternAnnotation
		* @return
		* @throws FailedConstructionException if no String value was given or
		* if an illegal borderPattern value was given. 
		*/
		private BorderPattern createBorderPattern()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createBorderPattern();
				}
			}
			String patternStr = string();
			if (patternStr == null) {
				throw new FailedConstructionException("BorderPattern");
			}
			BorderPattern pattern = null;
			try {
				pattern = BorderPattern.valueOf(
					patternStr.substring(
						patternStr.indexOf(".")+1,
						patternStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				System.out.println("Illegalargumnet borderPattern");
				throw new FailedConstructionException("BorderPattern");
			}
			return pattern; 
		}
		
		/**
		* Returns the smooth parameter represented by the given AnnotationNode.
		* @param smoothAnnotation
		* @return
		* @throws FailedConstructionException if no String value was given or
		* if an illegal smooth value was given. 
		*/
		private Smooth createSmooth()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createSmooth();
				}
			}
			String smoothStr = string();
			if (smoothStr == null) {
				throw new FailedConstructionException("Smooth");
			}
			Smooth smooth = null;
			try {
				smooth = Smooth.valueOf(
					smoothStr.substring(
						smoothStr.indexOf(".")+1,
						smoothStr.length()
					).toUpperCase()
				); 
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("Smooth");
			}
			return smooth; 
		}
		
		/**
		* Returns the textStyle parameter that is represented by this AnnotationNode.
		* @param textStyleAnnotation
		* @return
		* @throws FailedConstructionException If too many modifications are found or if
		* any of the string values doesn't match a legal TextStyle.
		*/
		private ArrayList<Types.TextStyle> createTextStyle()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createTextStyle();
				}
			}
			ArrayList<Types.TextStyle> textStyle = new ArrayList<Types.TextStyle>();
			ArrayList<String> stringList = stringList();
			if(stringList == null)
			{
				throw new FailedConstructionException("ConstructTextstyle");
			}
			int i = 0;
			try {
				for(String s : stringList)
				{
					textStyle.add(i,Types.TextStyle.valueOf(s.toUpperCase()));
					i++;
				}
			} catch (IllegalArgumentException e) {
				throw new FailedConstructionException("TextStyle");
			}
			return textStyle;
		}
		
		/**
		* Returns the fontName parameter that is represented by this AnnotationNode.
		* @param fontName
		* @return
		*/
		private String createFontName()
		{	
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createFontName();
				}
			}
			return string();
		}
		
		/**
		* Returns the fontSize parameter that is represented by this AnnotationNode.
		* @param fontSizeAnnotation
		* @return
		* @throws FailedConstructionException If the font size is less than zero.
		*/
		private int createFontSize()
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createFontSize();
				}
			}
			int fontSize = (int)real();
			if (fontSize >= 0) {
				return fontSize;
			} 
			throw new FailedConstructionException("Font size");
		}
		
		/**
		* Returns the color parameter represented by the given AnnotationNode.
		* @param colorAnnotation
		* @return
		* @throws FailedConstructionException if anything else than 3 values were given.
		*/
		private Color createColor() 
				throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createColor();
				}
			}
			double[] vector = realVector();
			if (vector != null) {
				if (vector.length != 3) {
					throw new FailedConstructionException("Color");
				}
			} else {
				throw new FailedConstructionException("Color");
			}
			return new Color((int)vector[0], (int)vector[1], (int)vector[2]);
		}
		
		/**
		* Returns the points parameter represented by the given AnnotationNode.
		* @param pointsAnnotation
		* @return
		* @throws FailedConstructionException if no values were given.
		*/
		private ArrayList<Point> createPoints() 
			throws FailedConstructionException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createPoints();
				}
			}
			ArrayList<Point> points = new ArrayList<Point>();
			double[][] matrix = realMatrix();
			if(matrix != null) { 
				for (int i = 0; i < matrix.length; i++) {
					if(matrix[i] == null) {	
						continue;
					} 
					if(matrix[i].length > 1) {
						points.add(new Point(
							matrix[i][0], 
							matrix[i][1]
						));
					} 
				}
			} else {
				throw new NotEnoughParametersException("points");
			}
			return points;
		}
		
		/**
		* Returns the extent parameter represented by the given AnnotationNode.
		* @throws FailedConstructionException if too few or too many values are given. 
		*/
	
		private Extent createExtent() 
			throws FailedConstructionException, NotEnoughParametersException {
			for (AnnotationNode a : this) {
				if (a.name().equals("DynamicSelect")) {
					return a.iterator().next().createExtent();
				}
			}
			ArrayList<Point> points = createPoints();
			if (points.size() < 2) {
				throw new NotEnoughParametersException("extent");
			}
			return new Extent(points.get(0), points.get(1));
		}
	}
}