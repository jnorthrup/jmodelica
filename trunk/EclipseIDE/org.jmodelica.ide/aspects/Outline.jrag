/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
import org.jmodelica.ide.ui.ImageLoader;
import java.util.Arrays;
import org.jmodelica.ide.outline.LibrariesList;

aspect Outline {
	/*
	 * Show interesting nodes
	 */
	eq Element.showInContentOutline() = !isError();
	eq ExtendsClause.showInContentOutline() = false;
	eq ImportClause.showInContentOutline() = false;
	eq InstClassDecl.showInContentOutline() = true;
	eq InstComponentDecl.showInContentOutline() = true;
	
	/*
	 * Don't traverse into error nodes.
	 */
	eq BadDefinition.hasVisibleChildren() = false;
	eq BadClassDecl.hasVisibleChildren() = false;
	eq BadElement.hasVisibleChildren() = false;
	eq BadArgument.hasVisibleChildren() = false;
	
	/*
	 * Set labels of interesting nodes
	 */
	eq BaseClassDecl.contentOutlineLabel() = getRestriction().toString() + " " + getName().getID();
	eq ComponentDecl.contentOutlineLabel() = getName().getID() + " : " + getClassName().typeString() + typePrefixes();
	eq BadDefinition.contentOutlineLabel() = "";
	eq LibNode.contentOutlineLabel() = getName();
	eq InstClassDecl.contentOutlineLabel() = getClassDecl().contentOutlineLabel();
	eq InstComponentDecl.contentOutlineLabel() = getComponentDecl().contentOutlineLabel();
	
	syn String Access.typeString() = getID();
	eq Dot.typeString() = getLeft().typeString() + "." + getRight().typeString();
	syn String ComponentDecl.typePrefixes() {
		StringBuilder buf = new StringBuilder();
		if (hasTypePrefixFlow()) {
			buf.append(", ");
			buf.append(getTypePrefixFlow());
		}
		if (hasTypePrefixVariability()) {
			buf.append(", ");
			buf.append(getTypePrefixVariability());
		}
		if (hasTypePrefixInputOutput()) {
			buf.append(", ");
			buf.append(getTypePrefixInputOutput());
		}
		return buf.toString();
	}
	
	/**
	 * Return the node that corresponds to the part of the code that we want to 
	 * select when selecting this node in the outline.
	 * @jastadd.client-api
	 */
	syn ASTNode ASTNode.getSelectionNode() = this;
	eq BaseClassDecl.getSelectionNode() = getName();
	eq ComponentDecl.getSelectionNode() = getName();
	eq InstClassDecl.getSelectionNode() = getClassDecl().getSelectionNode();
	eq InstComponentDecl.getSelectionNode() = getComponentDecl().getSelectionNode();
	
	/**
	 * Return the image to show for this node in outline.
	 * @jastadd.client-api
	 */
	eq ClassDecl.contentOutlineImage() = ImageLoader.getClassImage(getClassIconName(), false, false);
	eq InstClassDecl.contentOutlineImage() = ImageLoader.getClassImage(getClassIconName(), false, true);
	eq InstComponentDecl.contentOutlineImage() = ImageLoader.getClassImage(getClassIconName(), true, true);
	eq ComponentDecl.contentOutlineImage() = ImageLoader.getFrequentImage(ImageLoader.COMPONENT_IMAGE);
	
	/**
	 * Return the class type for the node as defined by <pre>ImageLoader.*_CLASS</pre>, if applicable.
	 * @jastadd.client-api
	 */
	syn String ASTNode.getClassIconName() = null;
	eq BaseClassDecl.getClassIconName() = getRestriction().getClassIconName();
	eq InstClassDecl.getClassIconName() = getClassDecl().getClassIconName();
	eq InstComponentDecl.getClassIconName() = myInstClass().getClassIconName();
	eq InstPrimitive.getClassIconName() = ImageLoader.CLASS_CLASS;
	eq Block.getClassIconName() = ImageLoader.BLOCK_CLASS;
	eq MClass.getClassIconName() = ImageLoader.CLASS_CLASS;
	eq Connector.getClassIconName() = ImageLoader.CONNECTOR_CLASS;
	eq Function.getClassIconName() = ImageLoader.FUNCTION_CLASS;
	eq Model.getClassIconName() = ImageLoader.MODEL_CLASS;
	eq MPackage.getClassIconName() = ImageLoader.PACKAGE_CLASS;
	eq Record.getClassIconName() = ImageLoader.RECORD_CLASS;
	eq MType.getClassIconName() = ImageLoader.TYPE_CLASS;

	/*
	 * Lets us reorder nodes in outline. Higher category means show node later in tree.
	 */
	syn int ASTNode.outlineCategory()  = 0;
	eq BaseClassDecl.outlineCategory() = -1;
	eq InstClassDecl.outlineCategory() = -1;
	eq LibClassDecl.outlineCategory()  = name().equals("Modelica") && isTopLevel() ? -2 : -1;
	
	/*
     * To be able to sort nodes by declared order. We only need this for nodes that are shown in an outline.
     */
    syn int ASTNode.declareOrder()      = 0;
    eq ComponentDecl.declareOrder()     = myDeclaredIndex();
    eq InstComponentDecl.declareOrder() = myDeclaredIndex();
    eq InstClassDecl.declareOrder()     = myDeclaredIndex();
    eq ClassDecl.declareOrder()         = declaredIndex(this);
    
    inh int ClassDecl.declaredIndex(ClassDecl cd);
    eq FullClassDecl.getChild().declaredIndex(ClassDecl cd) {
    	if (cd.classesIndex() < 0)
    		classes();
    	return cd.classesIndex();
    }
    eq Program.getLibNode(int i).declaredIndex(ClassDecl cd)            = i;
    eq Program.getUnstructuredEntity(int i).declaredIndex(ClassDecl cd) = i + getNumLibNode();
    eq Program.getChild().declaredIndex(ClassDecl cd)                   = 0;
    eq BadDefinition.getChild().declaredIndex(ClassDecl cd)             = 0;

    inh int InstNode.myDeclaredIndex();
    inh int ClassDecl.myDeclaredIndex();
    inh int ComponentDecl.myDeclaredIndex();
    eq InstRoot.getInstClassDecl(int i).myDeclaredIndex()      = i;
    eq InstNode.getInstClassDecl(int i).myDeclaredIndex()      = i;
    eq InstNode.getInstComponentDecl(int i).myDeclaredIndex()  = i;
    eq FullClassDecl.getComponentDecl(int i).myDeclaredIndex() = i;
    eq BaseNode.getChild().myDeclaredIndex()                   = 0;
    
    // To compare nodes for opening paths and setting selections
    syn String ASTNode.outlineId()   = Integer.toHexString(hashCode());
    eq BaseClassDecl.outlineId()     = name();
    eq ComponentDecl.outlineId()     = name();
    eq InstClassDecl.outlineId()     = name();
    eq InstComponentDecl.outlineId() = name();

	syn lazy org.jmodelica.ide.outline.LibrariesList SourceRoot.librariesList() = 
		new org.jmodelica.ide.outline.LibrariesList(this);
	
	private org.jmodelica.ide.outline.LibrariesList ClassDecl.librariesList;
	public org.jmodelica.ide.outline.LibrariesList ASTNode.getLibrariesList() {
		return null;
	}
	public org.jmodelica.ide.outline.LibrariesList ClassDecl.getLibrariesList() {
		return librariesList;
	}
	public void ASTNode.setLibrariesList(org.jmodelica.ide.outline.LibrariesList librariesList) {
	}
	public void ClassDecl.setLibrariesList(org.jmodelica.ide.outline.LibrariesList librariesList) {
		this.librariesList = librariesList;
	}
	
	eq SourceRoot.hasVisibleChildren() {
		for (StoredDefinition file : getProgram().getUnstructuredEntitys()) 
			if (file.getElements().getNumChild() > 0)
				return true;
		return librariesList().hasFiltered();
	}
	eq SourceRoot.outlineChildren() {
    	ArrayList list = new ArrayList();
    	org.jmodelica.ide.outline.LibrariesList libs = librariesList();
    	list.add(libs);
    	list.addAll(getProgram().getUnstructuredEntitys().outlineChildren());
    	if (libs.hasFiltered())
    		list.addAll(Arrays.asList(libs.getFiltered()));
     	return list;
	}
	
	eq LibNode.hasVisibleChildren() = getStoredDefinition().getNumElement() > 0;
	
	eq LibClassDecl.outlineChildren() = classes();
	
   	eq InstNode.hasVisibleChildren() {
   		/* Don't descend into error nodes. */
   		if (isError())
   			return false;
    	if (showInContentOutline()) 
       		return true;
    	return getInstClassDecls().hasVisibleChildren() || getInstComponentDecls().hasVisibleChildren();
   	}
   	eq InstNode.outlineChildren() {
    	ArrayList list = new ArrayList();
    	list.addAll(getInstClassDecls().outlineChildren());
    	list.addAll(getInstComponentDecls().outlineChildren());
     	return list;
   	}
	
	/*
	 * Explorer needs separate hasVisibleChildren, since it may need to load libraries.
	 */
	syn lazy boolean ClassDecl.hasClasses() = false;
	eq FullClassDecl.hasClasses() = getNumClassDecl() > 0;
	eq LibClassDecl.hasClasses() {
		if (super.hasClasses())
			return true;
		for (LibNode ln : getLibNodes()) {
			if (ln.getStoredDefinition().getNumElement() > 0)
				return true;
		}
		return false;
	}
	
	/*
	 * For opening files from instance tree.
	 */
	syn String ASTNode.containingFileName() = fileName();
	eq InstClassDecl.containingFileName() = getClassDecl().fileName();
	eq InstComponentDecl.containingFileName() = getComponentDecl().fileName();
	
	/*
	 * Prune uninteresting parts of tree.
	 */
	eq AbstractEquation.hasVisibleChildren() = false;
//	eq AbstractAlgorithm.hasVisibleChildren() = false;
	eq Access.hasVisibleChildren() = false;
	eq Annotation.hasVisibleChildren() = false;
	eq ComponentDecl.hasVisibleChildren() = false;
}