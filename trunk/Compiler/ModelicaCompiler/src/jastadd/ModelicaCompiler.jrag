/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.OutputStream;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.lang.InterruptedException;
import java.lang.StringBuilder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.logging.ConsoleHandler;
import java.util.logging.Handler;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.logging.StreamHandler;
import java.util.zip.ZipOutputStream;
import java.util.zip.ZipEntry;
import java.util.Set;
import java.util.Iterator;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPathExpressionException;

import org.jmodelica.util.ModelicaLogger;
import org.jmodelica.util.OptionRegistry;
import org.jmodelica.util.OptionRegistry.UnknownOptionException;
import org.jmodelica.util.StreamGobbler;
import org.xml.sax.SAXException;

aspect ModelicaCompilerMain {
 
/**
 * 
 * Main compiler class which bundles the tasks needed to compile a Modelica
 * model.
 * <p>
 * There are two usages with this class:
 * -# Compile in one step either from the command line or by calling the static 
 * method <compileModel> in your own class.
 * -# Split compilation into several steps by calling the static methods
 * in your own class.
 * <p>
 * Use (1) for a simple and compact way of compiling a Modelica model. As a
 * minimum, provide the modelfile name and class name as command line arguments.
 * Optional arguments are XML template and c template files which are needed for
 * code generation. If any of these are ommitted no code generation will be
 * performed.
 * <p>
 * Command line example without code generation:<br>
 * <code>org.jmodelica.applications.ModelicaCompiler myModels/models.mo models.model1</code>
 * <p>
 * Command line example with code generation: <br>
 * <code>org.jmodelica.applications.ModelicaCompiler myModels/models.mo models.model1
 * XMLtemplate1.xml XMLtemplate2.xml cppTemplate.cpp</code>
 * <p>
 * Logging can be set with the optional argument -log=i, w or e where:
 * <p>
 *  - -d : log debug, info, warning and error messages
 * 	- -i : log info, warning and error messages
 * 	- -w : log warning and error messages (default if the log option is not used)
 * 	- -e : log error messages only
 * <p>
 * Example with log level set to INFO: <br>
 * <code>org.jmodelica.applications.ModelicaCompiler -i myModels/models.mo 
 * models.model1</code>
 * <p>
 * The logs will be printed to standard out.
 * <p>
 * 
 * For method (2), the compilation steps are divided into 4 tasks which can be
 * used via the methods:
 * -# parseModel (source code -> attributed source representation)  
 * -# instantiateModel (source representation -> instance model) 
 * -# flattenModel (instance model -> flattened model) 
 * -# generateCode (flattened model -> c code and XML code)
 * <p>
 * They must be called in this order. Use provided methods to get/set logging
 * level.
 * 
 */
public class ModelicaCompiler {
	protected static final String CONSOLE_LOG_NAME = ModelicaCompiler.class.getName() + ".console";
	protected static final String STREAM_LOG_NAME = ModelicaCompiler.class.getName() + ".stream";
	protected static ModelicaLogger log = ModelicaLoggers.getConsoleLogger(CONSOLE_LOG_NAME);
	
	public static final String DEBUG = "d";
	public static final String INFO = "i";
	public static final String WARNING = "w";
	public static final String ERROR = "e";
	public static final String INHERITED = "inh";
	protected static final HashMap<String, Level> levels = new HashMap<String, Level>();
	
	// This should be two static blocks, but jastadd ignores those, so this is a workaround
	private static void staticBlocks() {
		if (levels.isEmpty()) { // Using this as check if this is run already
			levels.put(DEBUG,   Level.FINE);
			levels.put(INFO,    Level.INFO);
			levels.put(WARNING, Level.WARNING);
			levels.put(ERROR,   Level.SEVERE);
			ASTNode.log = log;
		}
	}
	public static final String DEFAULT_LEVEL = ERROR;
	
	protected String xmlTpl;
	protected String xmlValuesTpl;
	protected String cTemplatefile;
	
	private OptionRegistry options = null;
	private DiagnosticsGenerator diagGenerator = null;
	
	protected static LinkedList<CompilationHooks> globalHooksList = new LinkedList<CompilationHooks>();
	protected LinkedList<CompilationHooks> hooksList = new LinkedList<CompilationHooks>(globalHooksList);
	protected static CCompilerDelegator cCompiler = new GCCcompilerDelegator();
	protected IErrorHandler errorHandler = null;
	
	protected static String jmodelicaHome = System.getenv("JMODELICA_HOME");
	
	protected File tempDir = null;
	protected File outDir = null;
	protected File sourceDir = null;
	protected File resourceDir = null;
	
	public ModelicaCompiler(OptionRegistry options, String xmlTpl, String xmlValuesTpl, String cTemplatefile) {
		staticBlocks();
		this.options = options;
		this.xmlTpl = xmlTpl;
		this.xmlValuesTpl = xmlValuesTpl;
		this.cTemplatefile = cTemplatefile;
	}
	
	public ModelicaCompiler(OptionRegistry options) {
		this();
		this.options = options;
	}
	
	protected ModelicaCompiler() {
		staticBlocks();
		defaultTemplatePathsJMU();
	}

	public void defaultOptionsFMUME() {
		setBooleanOption("generate_ode", true);
		setBooleanOption("generate_dae", false);	
		setBooleanOption("equation_sorting", true);
		setBooleanOption("generate_fmi_me_xml", true);
		setBooleanOption("generate_fmi_cs_xml", false);
		setBooleanOption("generate_xml_equations", false);
	}

	public void defaultOptionsFMUCS() {
		setBooleanOption("generate_ode", true);
		setBooleanOption("generate_dae", false);	
		setBooleanOption("equation_sorting", true);
		setBooleanOption("generate_fmi_me_xml", true);
		setBooleanOption("generate_fmi_cs_xml", true);
		setBooleanOption("generate_xml_equations", false);
	}
	
	public void defaultTemplatePathsJMU() {
		defaultTemplatePaths("jmodelica");
	}
	
	public void defaultTemplatePathsFMUME() {
		defaultTemplatePaths("fmi_me");
	}

	public void defaultTemplatePathsFMUCS() {
		defaultTemplatePaths("fmi_cs");
	}
	
	protected void defaultTemplatePaths(String prefix) {
		// give templates default values based on $JMODELICA_HOME
		File dir = getTemplatesDir();
		if (prefix.equals("jmodelica")) {
			this.xmlTpl = new File(dir, prefix + "_model_description.tpl").getPath();
			this.xmlValuesTpl = new File(dir, "jmodelica_model_values.tpl").getPath();
			this.cTemplatefile = new File(dir, "jmi_modelica_template.c").getPath();
		} else if (prefix.equals("fmi_me")) {
			this.xmlTpl = new File(dir, "fmi_model_description.tpl").getPath();
			this.xmlValuesTpl = new File(dir, "jmodelica_model_values.tpl").getPath();
			this.cTemplatefile = new File(dir, "fmi_me_modelica_template.c").getPath();
		} else if (prefix.equals("fmi_cs")) {
			this.xmlTpl = new File(dir, "fmi_model_description.tpl").getPath();
			this.xmlValuesTpl = new File(dir, "jmodelica_model_values.tpl").getPath();
			this.cTemplatefile = new File(dir, "fmi_cs_modelica_template.c").getPath();
		}  
	}

	/**
	 * Sets the direcory new temporary files are created in. 
	 * The default value is <code>null</code>, and is interpreted as the current working directory.
	 */
	public void setTempFileDir(File temp) {
		tempDir = temp;
	}
	
	public void setOutDir(File out) {
		outDir = out;
		sourceDir = new File(outDir, "sources");
		resourceDir = new File(outDir, "resources");
		sourceDir.mkdirs();
		resourceDir.mkdir();
	}
	
	public void setSubOutDir(String out) {
		setOutDir(new File(tempDir, out));
	}
	
	public void setRandomOutDir() {
		try {
			File out = File.createTempFile("jmc", "out", tempDir);
			out.delete();
			setOutDir(out);
		} catch (IOException e) {
			// TODO: this should result in an error message about not being able to write to output dir
			e.printStackTrace();
		}
	}
	
	public void deleteOutDir() {
		if (outDir != null)
			recursiveDelete(outDir);
		outDir = null;
		sourceDir = null;
		resourceDir = null;
	}
	
	protected void recursiveDelete(File dir) {
		for (File f : dir.listFiles()) {
			if (f.isDirectory())
				recursiveDelete(f);
			else
				f.delete();
		}
		dir.delete();
	}
	
	protected static File getTemplatesDir() {
		return new File(jmodelicaHome, "CodeGenTemplates");
	}
	
	public static CCompilerDelegator getCCompiler() {
		return cCompiler;
	}
	
	public static void setCCompiler(CCompilerDelegator cCompiler) {
		ModelicaCompiler.cCompiler = cCompiler;
	}
	
	public static String getJModelicaHome() {
		return jmodelicaHome;
	}
	
	public static void setJModelicaHome(String jmHome) {
		jmodelicaHome = jmHome;
	}
	
	public static void addGlobalCompilationHooks(CompilationHooks hooks) {
		globalHooksList.add(hooks);
	}
	
	public static void removeGlobalCompilationHooks(CompilationHooks hooks) {
		globalHooksList.remove(hooks);
	}
	
	public void addCompilationHooks(CompilationHooks hooks) {
		hooksList.add(hooks);
	}
	
	public void removeCompilationHooks(CompilationHooks hooks) {
		hooksList.remove(hooks);
	}
	
	public IErrorHandler getErrorHandler() {
		return errorHandler;
	}
	
	/**
	 * Set the error handler to use for collection errors.
	 * Passing <code>null</code> resets to default.
	 */
	public void setErrorHandler(IErrorHandler eh) {
		errorHandler = eh;
	}
	
	/**
	 * Throws a {@link CompilationAbortedException} if any hooks class signals an abort.
	 */
	protected void hookCheckAbort() {
		for (CompilationHooks hooks : hooksList) {
			if (hooks.shouldAbort()) {
				log.info("Compilation aborted.");
				throw new CompilationAbortedException();
			}
		}
	}
	
	/**
	 * Calls the hook to be called after the supplied code files are parsed.
	 */
	protected void hookFilesParsed(SourceRoot sr) {
		for (CompilationHooks hooks : hooksList)
			hooks.filesParsed(sr);
	}
	
	/**
	 * Calls the hook to be called after the error checks on the instantiated 
	 * model are finished without errors.
	 */
	protected void hookModelInstantiatied(InstClassDecl icd) {
		for (CompilationHooks hooks : hooksList)
			hooks.modelInstantiatied(icd);
	}
	
	/**
	 * Calls the hook to be called after the model is flattened.
	 */
	protected void hookModelFlattened(FClass fc) {
		for (CompilationHooks hooks : hooksList)
			hooks.modelFlattened(fc);
	}
	
	/**
	 * Calls the hook to be called after transformations are applied to the model.
	 */
	protected void hookModelTransformed(FClass fc) {
		for (CompilationHooks hooks : hooksList)
			hooks.modelTransformed(fc);
	}
	
	/**
	 * Calls the hook to be called after error checks of the flat model are 
	 * finished without errors.
	 */
	protected void hookFlatModelChecked(FClass fc) {
		for (CompilationHooks hooks : hooksList)
			hooks.flatModelChecked(fc);
	}
	
	/**
	 * Calls the hook to be called after output code is generated.
	 */
	protected void hookCodeGenerated() {
		for (CompilationHooks hooks : hooksList)
			hooks.codeGenerated();
	}
	
	/**
	 * Calls the hook to be called after the generated C code is compiled.
	 */
	protected void hookCodeCompiled() {
		for (CompilationHooks hooks : hooksList)
			hooks.codeCompiled();
	}
	
	/**
	 * Calls the hook to be called after the FMU is packed.
	 */
	protected void hookFmuPacked(String path) {
		for (CompilationHooks hooks : hooksList)
			hooks.fmuPacked(path);
	}
	
	public String getStringOption(String key) throws UnknownOptionException {
		return options.getStringOption(key);
	}
	
	public void setStringOption(String key, String value) throws UnknownOptionException {
		options.setStringOption(key,value);
	}
	
	public int getIntegerOption(String key) throws UnknownOptionException {
		return options.getIntegerOption(key);
	}
	
	public void setIntegerOption(String key, int value) throws UnknownOptionException {
		options.setIntegerOption(key, value);
	}
	
	public double getRealOption(String key) throws UnknownOptionException {
		return options.getRealOption(key);
	}
	
	public void setRealOption(String key, double value) throws UnknownOptionException {
		options.setRealOption(key, value);
	}
	
	public boolean getBooleanOption(String key) throws UnknownOptionException{
		return options.getBooleanOption(key);
	}
	
	public void setBooleanOption(String key, boolean value) throws UnknownOptionException {
		options.setBooleanOption(key, value);
	}

	public void setDiagnosticsGenerator(DiagnosticsGenerator diagGenerator) {
		this.diagGenerator = diagGenerator;
	}

	public DiagnosticsGenerator getDiagnosticsGenerator() {
		return this.diagGenerator;
	}
	
	public String getOptionDescription(String key) throws UnknownOptionException {
		return options.getDescription(key);
	}

	/**
	 * Returns the modelicapath attribute set for this compiler instance.
	 * 
	 * @return Reference to the modelicapath attribute. 
	 * 
	 */
	public String getModelicapath() {
		return options.getStringOption("MODELICAPATH");
	}
	
	/**
	 * Set the modelicapath attribute.
	 * 
	 * @param path The new modelicapath.
	 */
	public void setModelicapath(String path) {
		options.addStringOption("MODELICAPATH", path);
	}
	
	/**
	 * Returns the XML model description template file path set for this compiler instance.
	 * 
	 * @return Reference to the XML variables template file path attribute. 
	 * 
	 */
	public String getXMLTpl() {
		return this.xmlTpl;
	}

	/**
	 * Set the XML model description template file path attribute.
	 * 
	 * @param template The new XML variables template file path.
	 */
	public void setXMLTpl(String template) {
		this.xmlTpl = template;
	}
	
	/**
	 * Returns the XML values template file path set for this compiler instance.
	 * 
	 * @return Reference to the XML values template file path attribute.
	 * 
	 */
	public String getXMLValuesTpl() {
		return this.xmlValuesTpl;
	}

	/**
	 * Set the XML values template file path attribute.
	 * 
	 * @param template The new XML values template file path.
	 */
	public void setXMLValuesTpl(String template) {
		this.xmlValuesTpl = template;
	}

	/**
	 * Returns the c template file path set for this compiler instance.
	 * 
	 * @return Reference to the c template file path attribute. 
	 * 
	 */
	public String getCTemplate() {
		return this.cTemplatefile;
	}
	
	/**
	 * Set the c template file path attribute.
	 * 
	 * @param template The new c template file path.
	 */
	public void setCTemplate(String template) {
		this.cTemplatefile = template;
	}

	protected final static int NUM_USED_MEMORY_SLOTS = 6;
	protected long[] usedMem = new long[NUM_USED_MEMORY_SLOTS];
	protected int numUsedMemFilled;
	protected long timeCompilationStarted;

	/**
	 * \brief Initilize vars gathering debug information about compilation.
	 * 
	 * Should be called before compilation process begins.
	 */
	protected void resetCompilationInfo() {
		timeCompilationStarted = System.currentTimeMillis();
		numUsedMemFilled = 0;
	}
	
	/**
	 * \brief Log debug information about compilation.
	 * 
	 * Should be called after compilation process ends.
	 */
	protected void logCompilationInfo() {
		long time = System.currentTimeMillis() - timeCompilationStarted;
		double time2 = Math.round(time / 10.0) / 100.0;
		log.debug("Compilation took " + time2 + " s");
		
		noteUsedMemory();  // Needed if an exception occurred
		if (numUsedMemFilled > 1) {
			log.debug("Changes in memory use:");
			log.debug(" parseModel():       " + ASTNode.formatMem((int) (usedMem[1] - usedMem[0])));
		}
		if (numUsedMemFilled > 3)
			log.debug(" instantiateModel(): " + ASTNode.formatMem((int) (usedMem[3] - usedMem[2])));
		if (numUsedMemFilled > 5)
			log.debug(" flattenModel():     " + ASTNode.formatMem((int) (usedMem[5] - usedMem[4])));
	}
	
	/**
	 * \brief Saves away the current amount of memory used.
	 */
	protected void noteUsedMemory() {
		if (numUsedMemFilled < NUM_USED_MEMORY_SLOTS)
			usedMem[numUsedMemFilled++] = RUNTIME.totalMemory() - RUNTIME.freeMemory();
	}
	private static final Runtime RUNTIME = Runtime.getRuntime();

	/**
	 * \brief Save a dump of the memory use of an AST.
	 * 
	 * The dump will be saved in a file named <code>"size_" + type + ".txt"</code>.
	 * 
	 * @param root  the root of the AST to dump memory use for
	 * @param type  a one-word description of the tree to dump
	 */
	protected void dumpMemoryUseFile(ASTNode root, String type) throws FileNotFoundException {
		dumpMemoryUseFile(root, type, type);
	}

	/**
	 * \brief Save a dump of the memory use of an AST.
	 * 
	 * The dump will be saved in a file named <code>"size_" + name + ".txt"</code>.
	 * 
	 * @param root  the root of the AST to dump memory use for
	 * @param type  a short description of the tree to dump
	 * @param name  the variable part of the file name
	 */
	protected void dumpMemoryUseFile(ASTNode root, String type, String name) 
			throws FileNotFoundException {
		String file = "size_" + name + ".txt";
		log.debug("Dumping " + type + " tree to '" + file + "'...");
		long time = System.currentTimeMillis();
		root.dumpMemoryUse(file, true, 25, 2 * 1024);
		time = Math.round((System.currentTimeMillis() - time) / 1000.0);
		log.debug(" Dumped tree in " + time + "s");
	}

	/**
	 * \brief Save a dump of the number of AST nodes created of each type.
	 * 
	 * ASTNode must be changed to inherit ProfilingNode for node type counting to work.
	 * 
	 * @param file  the name of the file to save dump to
	 */
	protected void dumpNodeCountFile(String file) throws FileNotFoundException {
		if (ProfilingNode.class.isAssignableFrom(ASTNode.class)) {
			log.debug("Dumping counts of created nodes to '" + file + "'...");
			PrintStream out = new PrintStream(file);
			ProfilingNode.printInfo(out, ProfilingNode.SORT_COUNT_DESC);
			out.close();
		} else {
			log.debug("ASTNode must inherit ProfilingNode for node type counting to work.");
		}
	}
	
	/**
	 * \brief Compiles a model and creates a JMU.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a JMU.
	 * 
	 * Convenience metod, equivalent to compileJMU(className, fileName, "model", ".").
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 */
	public void compileJMU(String className, String fileName[]) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileJMU(className, fileName, "model", ".");
	}
	
	/**
	 * \brief Compiles a model and creates a JMU.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a JMU.
	 * 
	 * Convenience metod, equivalent to compileJMU(className, fileName, "model", compileTo).
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param compileTo Specify location of the compiled JMU. Directory will be created if it does not exist.
	 */
	public void compileJMU(String className, String fileName[], String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileJMU(className, fileName, "model", compileTo);
	}
	
	/**
	 * \brief Compiles a model and creates a JMU.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a JMU.
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param target The build target. Valid options are 'model', 'model_noad', 'algorithms' and 'ipopt'.
	 * @param compileTo Specify location of the compiled JMU. Directory will be created if it does not exist.
	 */
	public void compileJMU(String className, String fileName[], String target, String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileUnit(className, fileName, target, compileTo, "JMU");
	}

	/**
	 * \brief Compiles a model and creates an FMU for Model Exchange.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a FMU.
	 * 
	 * Convenience metod, equivalent to compileFMUME(className, fileName, ".").
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 */
	public void compileFMUME(String className, String fileName[]) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileFMU(className, fileName, "model_fmume", ".");
	}

	/**
	 * \brief Compiles a model and creates an FMU for Co-simulation.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a FMU.
	 * 
	 * Convenience metod, equivalent to compileFMUCS(className, fileName, ".").
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 */
	public void compileFMUCS(String className, String fileName[]) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileFMU(className, fileName, "model_fmucs", ".");
	}

	/**
	 * \brief Compiles a model and creates an FMU for Model Exchange.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a FMU.
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param compileTo Specify location of the compiled FMU. Directory will be created if it does not exist.
	 */
	public void compileFMUME(String className, String fileName[], String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileFMU(className, fileName, "model_fmume", compileTo);
	}

	/**
	 * \brief Compiles a model and creates an FMU for Co-simulation.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a FMU.
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param compileTo Specify location of the compiled FMU. Directory will be created if it does not exist.
	 */
	public void compileFMUCS(String className, String fileName[], String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		compileFMU(className, fileName, "model_fmucs", compileTo);
	}

	/**
	 * \brief Compiles a model and creates an FMU.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a FMU.
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param target The build target. Valid options are 'model_noad', 'model_fmume' and 'model_fmucs'.
	 * @param compileTo Specify location of the compiled FMU. Directory will be created if it does not exist.
	 */
	public void compileFMU(String className, String fileName[], String target, String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		// Always set certain options when compiling an FMU
		// First save these options in temp options registry to reset when compiling has finished
		OptionRegistry tempOptions = new OptionRegistry(options);
		
		// use fmi file templates and set the correct options so that XML file will be FMI compliant
		if (target.equals("model_noad") || target.equals("model_fmume")) {
			defaultOptionsFMUME();
			defaultTemplatePathsFMUME();	
			compileUnit(className, fileName, target, compileTo, "FMUME");
		} else 	if (target.equals("model_fmucs")) {
			defaultOptionsFMUCS();
			defaultTemplatePathsFMUCS();	
			compileUnit(className, fileName, target, compileTo, "FMUCS");
		}		
		
		// set back all options
		options.copyAllOptions(tempOptions);
	}

	/**
	 * \brief Compiles a JMU or FMU (helper function for compileJMU and compileFMU).
	 * 
	 * @param unitType "JMU", "FMUME" or "FMUCS".
	 */
	private void compileUnit(String className, String fileName[], String target, String compileTo, String unitType) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		// Set output dir
		if (outDir == null)
			setRandomOutDir();
		
		// compile mo-file + generate code
		FClass fc = compileModel(fileName, className);
		
		// compile c code
		hookCheckAbort();
		String cFileName = FClass.convertClassNameToUnderscore(className);
		getCCompiler().compileCCode(cFileName, target, outDir, fc.externalLibraries(), fc.externalLibraryDirectories(), fc.externalIncludeDirectories());
		hookCodeCompiled();
		
		// package JMU
		packUnit(className, compileTo, unitType);
		deleteOutDir();
	}
	
	/**
	 * \brief Packs either a JMU or FMU (helper function for compileUnit).
	 * 
	 * @param className Name of model class that was compiled (will determine file names).
	 * @param path Location on file system where the packed file should be saved (created if does not exist).
	 * @param unitType "JMU" or "FMU".
	 */
	protected void packUnit(String className, String path, String unitType) {
		File dirPath = new File(path);
		if (!dirPath.isDirectory()) 
			dirPath.mkdirs();
		
		String mMangledName = FClass.convertClassNameToUnderscore(className);
		
		// Create the new archive
		int BUFFER_SIZE = 2048;
		try {
			hookCheckAbort();
			File unitFile = new File(dirPath, mMangledName + "." + getUnitSuffix(unitType));
			FileOutputStream dest = new FileOutputStream(unitFile);
			ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(dest));
			out.setMethod(ZipOutputStream.DEFLATED);
			zipDir(outDir, out);
			out.close();
			hookFmuPacked(unitFile.getAbsolutePath());
		} catch(CompilationAbortedException e) {
			deleteOutDir();
			throw e;
		} catch(Exception e) {
			// TODO: Make sure this is logged or reported properly
		}
		
		// remove files
		deleteOutDir();
	}

	private static final int ZIP_BUFFER_SIZE = 2048;

	/**
	 * Write all files in a directory and its subdirectories to a zip stream.
	 * 
	 * @param dir     directory to zip
	 * @param out     zip stream to write to
	 */
	protected void zipDir(File dir, ZipOutputStream out) {
		zipDir(dir, out, null);
	}

	/**
	 * Write all files in a directory and its subdirectories to a zip stream.
	 * 
	 * @param dir     directory to zip
	 * @param out     zip stream to write to
	 * @param zipDir  directory within the zip file to write to, or <code>null</code> for the root
	 */
	protected void zipDir(File dir, ZipOutputStream out, File zipDir) {
		zipDir(dir, out, zipDir, new byte[ZIP_BUFFER_SIZE]);
	}
	
	/**
	 * Write all files in a directory and its subdirectories to a zip stream.
	 * 
	 * @param dir     directory to zip
	 * @param out     zip stream to write to
	 * @param zipDir  directory within the zip file to write to, or <code>null</code> for the root
	 * @param buffer  buffer to use when writing files
	 */
	private void zipDir(File dir, ZipOutputStream out, File zipDir, byte[] buffer) {
		for (File f : dir.listFiles()) {
			File fz = new File(zipDir, f.getName());
			if (f.isDirectory()) {
				zipDir(f, out, fz, buffer);
			} else {
				try {
					FileInputStream in = new FileInputStream(f);
					out.putNextEntry(new ZipEntry(fz.getPath()));
					for (int n; (n = in.read(buffer, 0, buffer.length)) != -1; ) 
					   out.write(buffer, 0, n);
					in.close();
				} catch (FileNotFoundException e) {
					// Should only occur in weird cases - ignore and skip this file
				} catch (IOException e) {
					// TODO: this should result in an error message about failing to zip file
					e.printStackTrace();
				}
	        }
		}
	}
	
	/**
	 * Gets the file suffix for a given unit type. 
	 * 
	 * Should be updated when new unit types are added.
	 */
	protected String getUnitSuffix(String unitType) {
		// JMU -> jmu, FMUME -> fmu, FMUCS -> fmu
		return unitType.substring(0, 3).toLowerCase();
	}

	/**
	 * Compiles a Modelica model. A model file name and class must be provided.
	 * Prints an error and returns without completion if, for example, a file 
	 * can not be found or if the parsing fails. Supports multiple model files.
	 * 
	 * @param name
	 *            Array of names of the model files.
	 * @param cl
	 *            The name of the class in the model file to compile.
	 * @throws beaver.Parser.Exception
	 *             If there was an Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing, instantiation
	 *             or flattening.
	 * @throws FileNotFoundException
	 *             If the model file can not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver
	 *             exception.)
	 * @throws IOException
	 *             If there was an error creating the .mof file.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to parse, instantiate or flatten is not
	 *             found.
	 * 
	 */
	public FClass compileModel(String name[], String cl)
	  throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		log.info("======= Compiling model =======");
		resetCompilationInfo();
		
		SourceRoot sr = null;
		FClass fc = null;
		try {

			// build source tree
			sr = parseModel(name);
//			dumpMemoryUseFile(sr, "source");  // TODO: add command-line arg for this

			if (sr.options.getBooleanOption("generate_html_diagnostics")) {
				setDiagnosticsGenerator(new DiagnosticsGenerator(cl));
			}

			// compute instance tree
			InstClassDecl icl = instantiateModel(sr, cl);
			//icl.dumpTree("");
//			dumpMemoryUseFile(icl, "instance");
			
			// flattening
			fc = flattenModel(icl);
//			dumpMemoryUseFile(fc, "flat");

			// Generate code?
			if (this.getXmlTpl(fc) != null && this.getXmlValuesTpl(fc) !=null && this.getCTemplatefile(fc) != null) 
				generateCode(fc);
		} finally {
			logCompilationInfo();
			// The node count requires changeing ASTNode.java by hand - see dumpNodeCountFile()
//			dumpNodeCountFile("node_count.txt");
//			dumpMemoryUseFile(sr, "final source", "source2");
		}

		if (sr.options.getBooleanOption("generate_html_diagnostics")) {
			getDiagnosticsGenerator().finalize();
			setDiagnosticsGenerator(null);
		}

		log.info("====== Model compiled successfully =======");
		
		return fc;
	}

	/**
	 * 
	 * Parses a model and returns a reference to the root of the source tree.
	 * Options related to the compilation are also loaded here and added to the
	 * source tree representation.
	 * 
	 * @param name
	 *            The name of the model file.
	 *            
	 * @return The root of the source tree.
	 * 
	 * @throws beaver.Parser.Exception
	 *             If there was an Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing.
	 * @throws FileNotFoundException
	 *             If the model file can not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver exception.)
	 */
	private SourceRoot parseModel(String name) 
	  throws FileNotFoundException, IOException, beaver.Parser.Exception, CompilerException{
//		ModelicaParser parser = new ModelicaParser();
//		ModelicaParser.CollectingReport report = new ModelicaParser.CollectingReport();
//		parser.setReport(report);
//		Reader reader = new FileReader(name);
//		ModelicaScanner scanner = new ModelicaScanner(new BufferedReader(reader));
	/*
		if (report.hasErrors()) {
			CompilerException ce = new CompilerException();
			for (Problem p : report.getErrors()) {
				ce.addProblem(p);
			}
			throw ce;
		}
		*/
		ParserHandler ph = new ParserHandler();
		log.info("Parsing " + name + "...");
		SourceRoot sr;
		try {
//			sr = (SourceRoot) parser.parse(scanner);
			sr = ph.parseFile(name);
			if (errorHandler != null)
				sr.setErrorHandler(errorHandler);
		} catch (ParserException e) {
			e.getProblem().setFileName(name);
			CompilerException ce = new CompilerException();
			ce.addProblem(e.getProblem());
			throw ce;
		}
		//loadOptions(sr);
		for (StoredDefinition sd : sr.getProgram().getUnstructuredEntitys()) {
			sd.setFileName(name);
		}
		return sr;
	}

	/**
	 * 
	 * Parses a set of files and returns a reference to the root of a source tree
     * where the content of all files is contained. Each file is parsed using
     * the parseModel method.
	 * 
	 * @param names
	 *            An array of file names.
	 *            
	 * @return The root of the source tree.
	 * 
	 * @throws beaver.Parser.Exception
	 *             If there was a Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing.
	 * @throws FileNotFoundException
	 *             If the model file could not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver exception.)
	 */
	public SourceRoot parseModel(String names[]) 
	  throws FileNotFoundException, IOException, beaver.Parser.Exception, CompilerException{
		hookCheckAbort();
		noteUsedMemory();
		
		SourceRoot sr = new SourceRoot(new Program());
		sr.options.copyAllOptions(this.options);
		for (String name : names) {
			SourceRoot sr_tmp = parseModel(name);
			for(StoredDefinition sd : sr_tmp.getProgram().getUnstructuredEntitys()) 
				sr.getProgram().addUnstructuredEntity(sd);
		}
		
		hookFilesParsed(sr);
		noteUsedMemory();
		
		return sr;
	}
	
	/**
	 * 
	 * Computes a model instance tree from a source tree. Some error checks such
	 * as type checking is performed during the computation.
	 * 
	 * @param sr
	 *            The reference to the model source root.
	 * @param cl
	 *            The name of the class in the model file to compile.
	 * 
	 * @return The instance node corresponding to the instantiated model.
	 * 
	 * @throws CompilerException
	 *             If errors have been found during the instantiation.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to instantiate is not found.
	 */
	public InstClassDecl instantiateModel(SourceRoot sr, String cl) 
		throws ModelicaClassNotFoundException, CompilerException {
		hookCheckAbort();
		noteUsedMemory();
		
		InstProgramRoot ipr = sr.getProgram().getInstProgramRoot();
		ipr.options = new OptionRegistry(sr.options);
		
		if (sr.options.getBooleanOption("compliance_as_warning"))
			sr.setErrorHandler(new ComplianceWarnErrorHandler(sr.getErrorHandler()));
		
		log.info("Checking for errors...");
		Collection<Problem> problems = ipr.checkErrorsInInstClass(cl);
		if (problems.size()>0) {
			handleCompilerProblems(problems);
		}
		
		InstClassDecl icd = ipr.simpleLookupInstClassDecl(cl);
		
		hookModelInstantiatied(icd);
		noteUsedMemory();
		
		return icd;
	}
	
	protected void handleCompilerProblems(Collection<Problem> problems) throws CompilerException{
		ArrayList<Problem> warnings = new ArrayList<Problem>();
		ArrayList<Problem> errors = new ArrayList<Problem>();
		for (Problem p : problems) {
			if (p.severity() == Problem.Severity.ERROR) 
				errors.add(p);
			else
				warnings.add(p);
		}
		
		if (this.options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeProblems(problems);
		}
		
		if (errors.size() > 0 || (warnings.size() > 0 && options.getBooleanOption("halt_on_warning"))) {
			// there are errors -> add errors and possible warnings and throw exception or
			// there are only warnings but compiler option sais throw exception			
			
			CompilerException ce = new CompilerException();
			for (Problem e : errors) 
				ce.addProblem(e);
			for (Problem w: warnings) 
				ce.addProblem(w);
			throw ce;
		} else {
			// there are only warnings and halt_on_warning = false so just send them to logger
			log.warning("------- Compiler Warnings -------");
			for (Problem p:warnings) 
				log.warning(p.toString());
			log.warning("--------------------------------");
		}
	}
	
	/**
	 * \brief Create a new FClass object.
	 * 
	 * Override for subclasses needing a subclass of FClass.
	 * 
	 * @param icd  the instance class to be flattened, for use by subclasses
	 */
	protected FClass createFClass(InstClassDecl icd) {
		return new FClass();
	}
	
	/**
	 * Create a flat tree with an empty FClass and return the FClass.
	 * 
	 * @param icl       the instance class to be flattened
	 * @param flatFile  path to the file to report any errors on
	 */
	public FClass createFlatTree(InstClassDecl icl, String flatFile) {
		FlatRoot flatRoot = new FlatRoot();
		flatRoot.setFileName(flatFile);
		FClass fc = createFClass(icl);
		flatRoot.setFClass(fc);
		flatRoot.options = new OptionRegistry(icl.root().options);
		// TODO: We should change how the checkErrors() method works, 
		//       since it relies on the behaviour of DefaultErrorHandler
		IErrorHandler eh = icl.root().getErrorHandler();
		if (!(eh instanceof DefaultErrorHandler))
			flatRoot.setErrorHandler(eh);
		return fc;
	}
	
	/**
	 * Computes the flattened model representation from a model instance.
	 * 
	 * @param icd
	 *            A reference to the model instance node.
	 * 
	 * @return FClass object representing the flattened model.
	 * 
	 * @throws CompilerException
	 *             If errors have been found during the flattening.
	 * @throws IOException
	 *             If there was an error creating the .mof file.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to flatten is not found.
	 */
	public FClass flattenModel(InstClassDecl icl) 
			throws CompilerException, ModelicaClassNotFoundException, IOException {
		hookCheckAbort();
		noteUsedMemory();
		
		File flatFile = new File(resourceDir, icl.qualifiedName() + ".mof");
		FClass fc = createFlatTree(icl, flatFile.getPath());
		
		log.info("Flattening model...");
		icl.flattenInstClassDecl(fc);
		
		hookModelFlattened(fc);
		hookCheckAbort();
		
		//fc.dumpTree("");
		// Output the untransformed flattened model
		log.debug("Creating raw .mof file...");
		PrintStream out = new PrintStream(flatFile);
		fc.prettyPrint_MC(out, "");
	   	out.close();
	   	log.debug("... raw .mof file created.");

		log.info("Raw flattened model:");		
		log.info(fc.prettyPrint(""));

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeRawFlattenedModel(fc);
		}
		
		fc.transformCanonical();
		
		hookModelTransformed(fc);
		hookCheckAbort();
				
		log.debug("Creating transformed .mof file...");
		out = new PrintStream(new File(resourceDir, icl.qualifiedName() + "_transformed.mof"));
	   	fc.prettyPrint_MC(out, "");
	   	out.close();
	   	log.debug("... transformed .mof file created.");
	    
		log.info("Diagnostics for transformed flattened model:");		
		log.info(fc.diagnostics());
		
		log.info("Transformed flattened model:");		
		log.info(fc.prettyPrint(""));

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeTransformedFlattenedModel(fc);
		}

		Collection<Problem> problems = fc.errorCheck();

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeProblems(problems);
		}

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeDiagnostics(fc);
		}

		if (problems.size() > 0) 
			handleCompilerProblems(problems);

		hookFlatModelChecked(fc);
		noteUsedMemory();

		return fc;
	}
	
	/**
	 * \brief Create a new XMLGenerator object.
	 * 
	 * Override for subclasses needing another subclass of XMLGenerator.
	 */
	protected XMLGenerator createXMLGenerator(FClass fc) {
		return new XMLGenerator(new PrettyPrinter(), '$', fc);
	}
	
	/**
	 * \brief Create a new XMLValueGenerator object.
	 * 
	 * Override for subclasses needing another subclass of XMLValueGenerator.
	 */
	protected XMLValueGenerator createXMLValueGenerator(FClass fc) {
		return new XMLValueGenerator(new PrettyPrinter(), '$', fc);
	}
	
	/**
	 * \brief Create a new CGenerator object.
	 * 
	 * Override for subclasses needing another subclass of CGenerator.
	 */
	protected CGenerator createCGenerator(FClass fc) {
		return new CADGenerator(new PrettyPrinter(), '$', fc);
	}

	/**
	 * \brief get the XML template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getXmlTpl(FClass fc) {
		return this.xmlTpl;
	}

	/**
	 * \brief get the XML values template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getXmlValuesTpl(FClass fc) {
		return this.xmlValuesTpl;
	}

	/**
	 * \brief get the C template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getCTemplatefile(FClass fc) {
		return this.cTemplatefile;
	}
	
	/**
	 * 
	 * Generates XML and c code for a flattened model represented as an instance
	 * of FClass using template files. The XML variables, XML values and c files
	 * are given the default names <modelname>.xml, <modelname>_values.xml and 
	 * <modelname>.c respectively.
	 * 
	 * @param fc
	 *            The FClass instance for which the code generation should be
	 *            computed.
	 * @throws FileNotFoundException
	 *             If either of the three template files can not be found.
	 */
	public void generateCode(FClass fc) throws FileNotFoundException {
		hookCheckAbort();
		log.info("Generating code...");
		String name = fc.nameUnderscore();
		
		XMLGenerator xmlgenerator = createXMLGenerator(fc);
		String output = new File(outDir, "modelDescription.xml").getPath();
		xmlgenerator.generate(getXmlTpl(fc), output);

		XMLValueGenerator valuegenerator = createXMLValueGenerator(fc);
		output = new File(resourceDir, name + "_values.xml").getPath();
		valuegenerator.generate(getXmlValuesTpl(fc), output);
		
		CGenerator cgenerator = createCGenerator(fc);
		output = new File(sourceDir, name + ".c").getPath();
		cgenerator.generate(getCTemplatefile(fc), output);

		hookCodeGenerated();
		log.debug("... code generated.");
	}
	
	/**
	 * Use the specified logger.
	 * 
	 * Retains the current log level.
	 */
	public static void setLogger(ModelicaLogger log) {
		Level l = (log == null) ? null : log.getLevel();
		ModelicaCompiler.log = log;
		if (l != null)
			log.setLevel(l);
	}
	
	/**
	 * Use the default logger.
	 * 
	 * Retains the current log level.
	 */
	public static void setDefaultLogger() {
		setLogger(ModelicaLoggers.getConsoleLogger(CONSOLE_LOG_NAME));
	}
	
	/**
	 * Create and use a logger that logs to a stream.
	 * 
	 * Retains the current log level.
	 */
	public static void setStreamLogger(OutputStream stream) {
		setLogger(ModelicaLoggers.getStreamLogger(STREAM_LOG_NAME, stream));
	}
	
	/**
	 * Close and disconnect any stream connected to the stream logger.
	 */
	public static void closeStreamLogger() {
		ModelicaLoggers.closeStreamLogger(STREAM_LOG_NAME);
	}
	
	/**
	 * Sets logging to the level specified. Valid values are:
	 * ModelicaCompiler.DEBUG, ModelicaCompiler.INFO, ModelicaCompiler.WARNING or ModelicaCompiler.ERROR
	 * 
	 * Default log level setting is ERROR. Messages will be printed to the
	 * standard out.
	 * 
	 * @param level
	 *            The level of logging to use as of now.
	 */
	public static void setLogLevel(String level) {
		setLogLevel(log, level);
	}
	
	/**
	 * Returns the log level that is currently set.
	 * 
	 * @return Log level setting for this class.
	 */
	public static String getLogLevel() {
		return getLogLevel(log);
	}
	
	/**
	 * Sets logging to the level specified. Valid values are:
	 * ModelicaCompiler.DEBUG, ModelicaCompiler.INFO, ModelicaCompiler.WARNING or ModelicaCompiler.ERROR
	 * 
	 * Default log level setting is ERROR. Messages will be printed to the
	 * standard out.
	 * 
	 * @param level
	 *            The level of logging to use as of now.
	 */
	public static void setLogLevel(ModelicaLogger logger, String level) {
		if (logger != null) {
			Level lv = levels.get(level);
			if (lv == null)
				lv = levels.get(DEFAULT_LEVEL);
			log.setLevel(lv);
		}
	}
	
	/**
	 * Returns the log level that is currently set.
	 * 
	 * @return Log level setting for this class.
	 */
	public static String getLogLevel(ModelicaLogger logger) {
		Level lv = logger != null ? logger.getLevel() : null;
		return lv != null ? lv.toString() : ModelicaCompiler.INHERITED;
	}
	
	/**
	 * Sets logging to the level specified. Valid values are:
	 * ModelicaCompiler.DEBUG, ModelicaCompiler.INFO, ModelicaCompiler.WARNING or ModelicaCompiler.ERROR
	 * 
	 * Default log level setting is ERROR. Messages will be printed to the
	 * standard out.
	 * 
	 * @param level
	 *            The level of logging to use as of now.
	 */
	public static void setLogLevel(String logger, String level) {
		setLogLevel(ModelicaLoggers.getLogger(logger), level);
	}
	
	/**
	 * Returns the log level that is currently set.
	 * 
	 * @return Log level setting for this class.
	 */
	public static String getLogLevel(String logger) {
		return getLogLevel(ModelicaLoggers.getLogger(logger));
	}
	
	/**
	 * Executes the given command as a separate process, writing any output to the logger.
	 */
	public static int loggedProcess(String[] cmd, String[] env, File workDir) {
		try {
			Process proc = Runtime.getRuntime().exec(cmd, env, workDir);
			
			// Eat any output
            new StreamGobbler(proc.getErrorStream(), log.warningStream()).start();            
            new StreamGobbler(proc.getInputStream(), log.infoStream()).start();
                                   
            // Wait for process to finish and return result
            return proc.waitFor();
            
		} catch (IOException e) {
		} catch (InterruptedException e) {
		}
		return 1;
	}
	
	protected static Hashtable<String, String> extractProgramArguments(String[] args, int pos) {
		Hashtable<String, String> programargs = new Hashtable<String,String>();		
		
		while(pos < args.length && argumentIsOption(args[pos])) {
			addOptionToMap(programargs, args[pos]);
			pos++;
		}
		return programargs;
	}

	private static void addOptionToMap(Hashtable<String, String> programargs, String arg) {
		String[] parts = arg.trim().substring(1).split("=");
		programargs.put(parts[0], (parts.length > 1) ? parts[1] : "");
	}

	private static boolean argumentIsOption(String arg) {
		return arg.trim().startsWith("-");
	}
	
	private void setOptions(Hashtable<String, String> programarguments, String modelicapath) {
		String filesep = File.separator;
		String optionsfile = null;
		//look for options.xml in $JMODELICA_HOME/Options/ and program arguments
		if (programarguments.get("optfile") != null) {
			optionsfile = programarguments.get("optfile");
		} else {
			optionsfile = jmodelicaHome+filesep+"Options"+filesep+"options.xml";
		}

		try {
			options = new OptionRegistry(optionsfile);
		} catch(Exception e) {
			log.warning("The options XML file could not be loaded, using defaults.");
			log.stackTrace(e);
			options = new OptionRegistry();
		}
		
		//add modelicapath to optionregistry
		if (modelicapath == null) {
			//modelicapath was not set in program arguments -> check envir variable or via JMODELICA_HOME
			if (System.getenv("MODELICAPATH") != null) { 
				modelicapath=System.getenv("MODELICAPATH");
			} else {
				modelicapath=jmodelicaHome+filesep+"ThirdParty"+filesep+"MSL";
			}
		}
		options.addStringOption("MODELICAPATH", modelicapath);
	}
	
	protected void setArguments(String compilerName, String[] args, Hashtable<String, String> programarguments) 
		throws JModelicaHomeNotFoundException {
		// check that JMODELICA_HOME exists
		if (jmodelicaHome == null) 
			throw new JModelicaHomeNotFoundException("The environment variable JMODELICA_HOME has not been set.");
		
		if (args.length < 1) {
			log.error(compilerName + " expects the command line arguments: \n" +
					"[<options>] [-fmume|-fmucs|-jmu] <file name> <class name> [<templates>]\n" +
					" where options could be: \n" +
					"  -log=<d or i or w or e> \n" +
					"  -modelicapath=<path to modelica library> \n" +
					"  -optfile=<path to XML options file> \n" + 
					" and templates, if given, should be (in order): \n" + 
					"  xml model description template \n" +
					"  xml model values template \n" + 
					"  c template \n" +
					" If no target type option is given, -jmu is assumed.");
			System.exit(1);
		}
		
		int arg = 0;
		String modelicapath = null;
		
		//log option
		String level = programarguments.get("log");
		setLogLevel(log, (level != null) ? level : ModelicaCompiler.ERROR);

		//modelicapath option
		modelicapath = programarguments.get("modelicapath");
		
		arg = programarguments.size();
		if (args.length < arg+2) {
			log.error(compilerName + " expects a file name and a class name as command line arguments.");
			System.exit(1);
		}
		
		// set templates and options		
		if (args.length >= arg+5) {
			this.xmlTpl = args[arg+2];
			this.xmlValuesTpl = args[arg+3];
			this.cTemplatefile = args[arg+4];
		}
		
		// set options
		this.setOptions(programarguments, modelicapath);
	}
	
	public static void main(String[] args) {
		// TODO: Add a class representing the arguments of the program, with getX methods for arguments.
		// Get any program options set
		Hashtable<String, String> programarguments = extractProgramArguments(args, 0);
		// create an empty compiler
		ModelicaCompiler mc = new ModelicaCompiler();
		// set arguments
		try {
			mc.setArguments("ModelicaCompiler", args, programarguments);
		} catch(JModelicaHomeNotFoundException e) {
			mc.handleException(e);
		}
		// Compile model
		mc.compileModelFromCommandLine(args, programarguments);
	}
	
	/**
	 * \brief Compile model given in command line options and  and print any error messages.
	 */
	protected void compileModelFromCommandLine(String[] args, Hashtable<String, String> programarguments) {
		// Get files and class
		int arg = programarguments.size();
		String[] name = splitFiles(args[arg]);
		String cl = args[arg+1];
		
		// Compile model
		try {
			if (programarguments.containsKey("fmume"))
				compileFMUME(cl, name);
			else if (programarguments.containsKey("fmucs"))
				compileFMUCS(cl, name);
			else
				compileJMU(cl, name);
		} catch  (ModelicaClassNotFoundException e){
			log.error("Could not find the class "+ cl);
			System.exit(1);
		} catch (CompilerException ce) {
			StringBuilder str = new StringBuilder();
			str.append(ce.getProblems().size() + " errors found:\n");
			for (Problem p : ce.getProblems()) 
				str.append(p.toString()+"\n");
			log.error(str.toString());
			System.exit(1);
		} catch (FileNotFoundException e) {
			log.error("Could not find file: " + e.getMessage());
			System.exit(1);
		} catch (OutOfMemoryError e) {
			log.error("Out of memory. Please set the memory limit of the JVM higher.");
			System.exit(1);
		} catch (Throwable e) {
			handleException(e);
		}
	}
	
	/**
	 * Split the argument containing the list of files into an array of filenames.
	 */
	protected String[] splitFiles(String arg) {
		ArrayList<String> res = new ArrayList<String>();
		for (String part : arg.split(","))
			if (!part.equals(""))
				res.add(part);
		return res.toArray(new String[res.size()]);
	}
		
	/**
	 * \brief Log error message for exception and exit.
	 */
	protected void handleException(Throwable e, String msg) {
		if (e.getMessage() != null)
			msg += ": " + e.getMessage();
		log.error(msg);
		log.stackTrace(e);
		System.exit(1);
	}
	
	/**
	 * \brief Log error message for exception and exit.
	 */
	protected void handleException(Throwable e) {
		handleException(e, "Unknown program error");
	}

	/**
	 *     Helper function. Returns string describing the platform on which jmodelica 
	 *     is run. 
	 *     
	 *     Possible return values::
	 *     win32
	 *     win64
	 *     darwin32
	 *     darwin64
	 *     linux32
	 *     linux64
	 */
	public static String getPlatform() {
		String platform = "";
		
		String sunPltform = System.getProperty("os.name");
		if (sunPltform.startsWith("Windows")) {
			platform = "win";
		} else if (sunPltform.startsWith("Mac")) {
			platform = "darwin";
		} else {
			// assume linux
			platform ="linux";
		}
		
		String architecture = System.getProperty("os.arch");
		if (architecture.endsWith("64")) {
			platform = platform+"64";
		} else {
			platform = platform+"32";
		}
		
		return platform;
	}
	
	/**
	 * Class which can be used to fetch static loggers with different purposes.
	 * 
	 * This is an attempt to have a general Logger class which contains loggers
	 * for different purposes. It is then possible to have each logger specially
	 * configured for its indended use. Right now there is only one logger class
	 * which is a console logger. It has a specific loglevel and a certain
	 * formatting. Another useful logger could be a filelogger which has a
	 * loglevel and an output formatting which suits logging to file.
	 * 
	 */
	public static class ModelicaLoggers {
		
		public static final HashMap<String, ModelicaLogger> logs = new HashMap<String, ModelicaLogger>();
		
		/**
		 * Returns a logger with a certain name which prints logs to the
		 * console. If the name is encountered for the first time a new logger
		 * is created, otherwise the already created logger with the specific
		 * name is returned. The log outputs are formatted to suit a console.
		 * The default log level is Level.WARNING.
		 * 
		 * @param name  The name of the logger.
		 * @return A logger which prints log messages to the console.
		 */
		public static ModelicaLogger getConsoleLogger(String name) {
			ModelicaLogger ml = logs.get(name);
			if (ml == null) {
				Logger l = Logger.getLogger(name);
				l.setUseParentHandlers(false);
				ConsoleHandler ch = new ConsoleHandler();
				// Dont limit log level for handler, we do that in logger
				ch.setLevel(Level.FINEST);
				ch.setFormatter(new ConsoleFormatter());
				l.addHandler(ch);
				l.setLevel(Level.WARNING);
				ml = new LoggerInModelicaLogger(l);
				logs.put(name, ml);
			}
			return ml;
		}
		
		/**
		 * Creates a generic logger that logs to an output stream.
		 * If the name is encountered for the first time a new logger 
		 * is created, otherwise the already created logger with the specific
		 * name is set to use the given stream and returned.
		 * The default log level is Level.WARNING.
		 * 
		 * @param name     the name of the logger
		 * @param stream   the stream to write to
		 * @return A logger which prints log messages to an output stream.
		 */
		public static ModelicaLogger getStreamLogger(String name, OutputStream stream) {
			Logger l = Logger.getLogger(name);
			l.setUseParentHandlers(false);
			for (Handler h : l.getHandlers())
				l.removeHandler(h);
			StreamHandler sh = new StreamHandler(stream, new ConsoleFormatter());
			l.addHandler(sh);
			l.setLevel(Level.WARNING);
			
			ModelicaLogger ml = logs.get(name);
			if (ml == null) {
				ml = new LoggerInModelicaLogger(l);
				logs.put(name, ml);
			}
			return ml;
		}
		
		/**
		 * Close and disconnect all streams connected to the named logger.
		 */
		public static void closeStreamLogger(String name) {
			if (logs.get(name) != null) {
				Logger l = Logger.getLogger(name);
				for (Handler h : l.getHandlers()) {
					if (h instanceof StreamHandler) {
						l.removeHandler(h);
						h.close();
					}
				}
			}
		}
		
		/**
		 * Returns a previously created logger. If no logger with 
		 * the specified name exists, <code>null</code> is returned.
		 * 
		 * @param name  The name of the logger.
		 */
		public static ModelicaLogger getLogger(String name) {
			return logs.get(name);
		}
		
		/**
		 * Private formatting helper class for the console logger. Formats
		 * log messages to suit a console output.
		 * 
		 */
		private static class ConsoleFormatter extends SimpleFormatter {
			public ConsoleFormatter() {
				super();
			}
			@Override
			public String format(LogRecord record) {
				return record.getMessage()+"\n";
			}
		
		}
		
		/**
		 * \brief Wrapper class to make java.util.logging.Logger conform to ModelicaLogger.
		 */
		private static class LoggerInModelicaLogger extends ModelicaLogger {
			
			private Logger logger;
			
			public LoggerInModelicaLogger(Logger logger) {
				this.logger = logger;
			}
			
		    /**
		     * \brief Log <code>message</code> on log level <code>level</code>.
		     * 
		     * This implementation delegates to the selected Logger.
		     */
		    public void log(Level level, String message) {
		    	logger.log(level, message);
		    }
		    
		    /**
		     * \brief Get the current log level.
		     * 
		     * This implementation delegates to the selected Logger.
		     */
		    public Level getLevel() { 
		    	return logger.getLevel(); 
		    }
		    
		    /**
		     * \brief Set the current log level.
		     * 
		     * This implementation delegates to the selected Logger.
		     */
		    public void setLevel(Level lv) { 
		    	logger.setLevel(lv);
		    }
			
		}
	}
}

}

aspect CompilationHelpers {
	
/**
 * Interface for hooking into the compilation process.
 * 
 * Trees passed as arguments may be altered, but implementer must take care 
 * not to break compilation in this way.
 */
public interface CompilationHooks {
	/**
	 * Returns <code>true</code> if the compilation should be aborted.
	 * 
	 * May be called at any time, and is guaranteed to be called before each 
	 * compilation step with a separate method in this interface.
	 * 
	 * If compilation is aborted before it is finished, a 
	 * {@link CompilationAbortedException} is thrown.
	 */
	public boolean shouldAbort();
	
	/**
	 * Called after the supplied code files are parsed.
	 */
	public void filesParsed(SourceRoot sr);
	
	/**
	 * Called after the error checks on the instantiated model are finished without errors.
	 * 
	 * Since the instance tree is built lazily, this step can not be broken up.
	 */
	public void modelInstantiatied(InstClassDecl icd);
	
	/**
	 * Called after the model is flattened.
	 */
	public void modelFlattened(FClass fc);
	
	/**
	 * Called after transformations are applied to the flat model.
	 */
	public void modelTransformed(FClass fc);
	
	/**
	 * Called after error checks of the flat model are finished without errors.
	 */
	public void flatModelChecked(FClass fc);
	
	/**
	 * Called after output code is generated.
	 */
	public void codeGenerated();
	
	/**
	 * Called after the generated C code is compiled.
	 */
	public void codeCompiled();
	
	/**
	 * Called after the FMU is packed.
	 */
	public void fmuPacked(String path);
}

public class JModelicaHomeNotFoundException extends Exception {
	public JModelicaHomeNotFoundException() {
	}
	public JModelicaHomeNotFoundException(String msg) {
		super(msg);
	}
}

public class CcodeCompilationException extends RuntimeException {
	public CcodeCompilationException() {
	}
	public CcodeCompilationException(String msg) {
		super(msg);
	}
}

/**
 * Thrown when a compilation is aborted through a CompilationHooks.
 */
public class CompilationAbortedException extends RuntimeException {
	public CompilationAbortedException() {
	}
	public CompilationAbortedException(String msg) {
		super(msg);
	}
}

public interface CCompilerDelegator {
	
	public void compileCCode(String fileName, String target, File workDir, 
			HashSet<String> ext_libs, HashSet<String> ext_lib_dirs, HashSet<String> ext_incl_dirs);
	
}

public class GCCcompilerDelegator implements CCompilerDelegator {
	
	public GCCcompilerDelegator() {
	}

	
	public void compileCCode(String fileName, String target, File workDir, 
			HashSet<String> ext_libs, HashSet<String> ext_lib_dirs, HashSet<String> ext_incl_dirs) {
		String filesep = File.separator;
		String jmodelicaHome = ModelicaCompiler.getJModelicaHome();
		String makefile = jmodelicaHome + filesep + "Makefiles" + filesep + "MakeFile";
		String platformDir = ModelicaCompiler.getPlatform();
		
		// make arguments
		String file_name = "FILE_NAME=" + fileName;
		String jmodelica_home = "JMODELICA_HOME=" + jmodelicaHome;
		String cppad_home = "CPPAD_HOME=" + System.getenv("CPPAD_HOME");
		String ipopt_home = "IPOPT_HOME=" + System.getenv("IPOPT_HOME");
		String sundials_home = "SUNDIALS_HOME=" + System.getenv("SUNDIALS_HOME");
		String platform = "PLATFORM=" + platformDir;
		
		// external library directories
		StringBuilder extLibDirs_sb = new StringBuilder();
		for (String libDir : ext_lib_dirs) {
			File f = new File(libDir, platformDir);
			if (f.isDirectory()) {
				extLibDirs_sb.append(f.getPath());
			} else {
				extLibDirs_sb.append(libDir);
			}
			extLibDirs_sb.append(" ");
		}
		String extLibDirs = null;
		if (ext_lib_dirs.size()!=0) {
			extLibDirs = "EXT_LIB_DIRS=\"" + extLibDirs_sb.toString().trim() + "\"";
		}

		// external libraries
		StringBuilder extLibs_sb = new StringBuilder();
		for (String lib:ext_libs) {
			extLibs_sb.append(lib+" ");
		}

		String extLibs = null;
		if (ext_libs.size()!=0) {		
			extLibs = "EXT_LIBS=\"" + extLibs_sb.toString().trim() + "\"";
		}

		// external include directories
		StringBuilder extInclDirs_sb = new StringBuilder();
		for (String libDir:ext_incl_dirs) {
			extInclDirs_sb.append(libDir + " ");
		}
		String extInclDirs = null;
		if (ext_incl_dirs.size()!=0) {
			extInclDirs = "EXT_INC_DIRS=\"" + extInclDirs_sb.toString().trim() + "\"";
		}
		
		// Generate make call
		String make = "make";
		String compiler = null;
		String ar = null;
		if (platformDir.startsWith("win")) {
			String mingw_bin = System.getenv("MINGW_HOME") + filesep + "bin";
			make = mingw_bin + filesep + "mingw32-make";
			compiler = "CXX=" + mingw_bin + filesep + "g++";
			ar = "AR=" + mingw_bin + filesep + "ar";
		}
			
		String[] cmd = new String[] {
			make, "-f", makefile, compiler, ar, target, file_name, platform, jmodelica_home, 
			cppad_home, ipopt_home, sundials_home, extLibDirs, extLibs, extInclDirs 
		};
		ArrayList<String> cmdList = new ArrayList<String>(cmd.length);
		for (String c : cmd)
			if (c != null)
				cmdList.add(c);
		cmd = cmdList.toArray(new String[cmdList.size()]);
	
		// execute make
		if (ModelicaCompiler.loggedProcess(cmd, null, workDir) != 0)
			throw new CcodeCompilationException("Compilation of generated C code failed.");
	}
}

}
