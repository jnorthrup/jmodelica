/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileReader;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.io.Reader;
import java.io.StringWriter;
import java.lang.InterruptedException;
import java.lang.StringBuilder;
import java.util.Arrays;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.LinkedList;
import java.util.logging.ConsoleHandler;
import java.util.logging.Level;
import java.util.logging.LogManager;
import java.util.logging.LogRecord;
import java.util.logging.Logger;
import java.util.logging.SimpleFormatter;
import java.util.zip.ZipOutputStream;
import java.util.zip.ZipEntry;
import java.util.Set;
import java.util.Iterator;

import javax.xml.parsers.ParserConfigurationException;
import javax.xml.xpath.XPathExpressionException;

import org.jmodelica.util.OptionRegistry;
import org.jmodelica.util.OptionRegistry.UnknownOptionException;
import org.xml.sax.SAXException;

aspect ModelicaCompilerMain {
 
/**
 * 
 * Main compiler class which bundles the tasks needed to compile a Modelica
 * model.
 * <p>
 * There are two usages with this class:
 * -# Compile in one step either from the command line or by calling the static 
 * method <compileModel> in your own class.
 * -# Split compilation into several steps by calling the static methods
 * in your own class.
 * <p>
 * Use (1) for a simple and compact way of compiling a Modelica model. As a
 * minimum, provide the modelfile name and class name as command line arguments.
 * Optional arguments are XML template and c template files which are needed for
 * code generation. If any of these are ommitted no code generation will be
 * performed.
 * <p>
 * Command line example without code generation:<br>
 * <code>org.jmodelica.applications.ModelicaCompiler myModels/models.mo models.model1</code>
 * <p>
 * Command line example with code generation: <br>
 * <code>org.jmodelica.applications.ModelicaCompiler myModels/models.mo models.model1
 * XMLtemplate1.xml XMLtemplate2.xml cppTemplate.cpp</code>
 * <p>
 * Logging can be set with the optional argument -log=i, w or e where:
 * <p>
 *  - -d : log debug, info, warning and error messages
 * 	- -i : log info, warning and error messages
 * 	- -w : log warning and error messages (default if the log option is not used)
 * 	- -e : log error messages only
 * <p>
 * Example with log level set to INFO: <br>
 * <code>org.jmodelica.applications.ModelicaCompiler -i myModels/models.mo 
 * models.model1</code>
 * <p>
 * The logs will be printed to standard out.
 * <p>
 * 
 * For method (2), the compilation steps are divided into 4 tasks which can be
 * used via the methods:
 * -# parseModel (source code -> attributed source representation)  
 * -# instantiateModel (source representation -> instance model) 
 * -# flattenModel (instance model -> flattened model) 
 * -# generateCode (flattened model -> c code and XML code)
 * <p>
 * They must be called in this order. Use provided methods to get/set logging
 * level.
 * 
 */
public class ModelicaCompiler {
	protected static final String CONSOLE_LOG_NAME = ModelicaCompiler.class.getName() + ".console";
	protected static final ModelicaLogger log = ModelicaLoggers.getConsoleLogger(CONSOLE_LOG_NAME);
	
	public static final String DEBUG = "d";
	public static final String INFO = "i";
	public static final String WARNING = "w";
	public static final String ERROR = "e";
	public static final String INHERITED = "inh";
	protected static final HashMap<String, Level> levels = new HashMap<String, Level>();
	
	// This should be two static blocks, but jastadd ignores those, so this is a workaround
	private static void staticBlocks() {
		if (levels.isEmpty()) { // Using this as check if this is run already
			levels.put(DEBUG,   Level.FINE);
			levels.put(INFO,    Level.INFO);
			levels.put(WARNING, Level.WARNING);
			levels.put(ERROR,   Level.SEVERE);
			ASTNode.log = log;
		}
	}
	public static final String DEFAULT_LEVEL = ERROR;
	
	protected String xmlTpl;
	protected String xmlValuesTpl;
	protected String cTemplatefile;
	
	private OptionRegistry options = null;
	private DiagnosticsGenerator diagGenerator = null;
	
	protected LinkedList<CompilationHooks> hooksList = new LinkedList<CompilationHooks>();
	
	protected static CCompilerDelegator cCompiler = new GCCcompilerDelegator();
	
	protected static String jmodelicaHome = System.getenv("JMODELICA_HOME");
	
	public ModelicaCompiler(OptionRegistry options, String xmlTpl, String xmlValuesTpl, String cTemplatefile) {
		staticBlocks();
		this.options = options;
		this.xmlTpl = xmlTpl;
		this.xmlValuesTpl = xmlValuesTpl;
		this.cTemplatefile = cTemplatefile;
	}
	
	public ModelicaCompiler(OptionRegistry options) {
		this();
		this.options = options;
	}
	
	protected ModelicaCompiler() {
		staticBlocks();
		defaultTemplatePathsJMU();
	}
	
	public void defaultTemplatePathsJMU() {
		defaultTemplatePaths("jmodelica");
	}
	
	public void defaultTemplatePathsFMU() {
		defaultTemplatePaths("fmi");
	}
	
	protected void defaultTemplatePaths(String prefix) {
		// give templates default values based on $JMODELICA_HOME
		File dir = getTemplatesDir();
		this.xmlTpl = new File(dir, prefix + "_model_description.tpl").getPath();
		this.xmlValuesTpl = new File(dir, "jmodelica_model_values.tpl").getPath();
		this.cTemplatefile = new File(dir, "jmi_modelica_template.c").getPath();
	}

	
	protected static File getTemplatesDir() {
		return new File(jmodelicaHome, "CodeGenTemplates");
	}
	
	public static CCompilerDelegator getCCompiler() {
		return cCompiler;
	}
	
	public static void setCCompiler(CCompilerDelegator cCompiler) {
		ModelicaCompiler.cCompiler = cCompiler;
	}
	
	public static String getJModelicaHome() {
		return jmodelicaHome;
	}
	
	public static void setJModelicaHome(String jmHome) {
		jmodelicaHome = jmHome;
	}
	
	public void addCompilationHooks(CompilationHooks hooks) {
		hooksList.add(hooks);
	}
	
	public void removeCompilationHooks(CompilationHooks hooks) {
		hooksList.remove(hooks);
	}
	/**
	 * Throws a {@link CompilationAbortedException} if any hooks class signals an abort.
	 */
	public void hookCheckAbort() {
		for (CompilationHooks hooks : hooksList) {
			if (hooks.shouldAbort()) {
				log.info("Compilation aborted.");
				throw new CompilationAbortedException();
			}
		}
	}
	
	/**
	 * Calls the hook to be called after the supplied code files are parsed.
	 */
	public void hookFilesParsed(SourceRoot sr) {
		for (CompilationHooks hooks : hooksList)
			hooks.filesParsed(sr);
	}
	
	/**
	 * Calls the hook to be called after the error checks on the instantiated 
	 * model are finished without errors.
	 */
	public void hookModelInstantiatied(InstClassDecl icd) {
		for (CompilationHooks hooks : hooksList)
			hooks.modelInstantiatied(icd);
	}
	
	/**
	 * Calls the hook to be called after the model is flattened.
	 */
	public void hookModelFlattened(FClass fc) {
		for (CompilationHooks hooks : hooksList)
			hooks.modelFlattened(fc);
	}
	
	/**
	 * Calls the hook to be called after transformations are applied to the model.
	 */
	public void hookModelTransformed(FClass fc) {
		for (CompilationHooks hooks : hooksList)
			hooks.modelTransformed(fc);
	}
	
	/**
	 * Calls the hook to be called after error checks of the flat model are 
	 * finished without errors.
	 */
	public void hookFlatModelChecked(FClass fc) {
		for (CompilationHooks hooks : hooksList)
			hooks.flatModelChecked(fc);
	}
	
	/**
	 * Calls the hook to be called after output code is generated.
	 */
	public void hookCodeGenerated() {
		for (CompilationHooks hooks : hooksList)
			hooks.codeGenerated();
	}
	
	/**
	 * Calls the hook to be called after the generated C code is compiled.
	 */
	public void hookCodeCompiled() {
		for (CompilationHooks hooks : hooksList)
			hooks.codeCompiled();
	}
	
	/**
	 * Calls the hook to be called after the FMU is packed.
	 */
	public void hookFmuPacked(String path) {
		for (CompilationHooks hooks : hooksList)
			hooks.fmuPacked(path);
	}
	
	public String getStringOption(String key) throws UnknownOptionException {
		return options.getStringOption(key);
	}
	
	public void setStringOption(String key, String value) throws UnknownOptionException {
		options.setStringOption(key,value);
	}
	
	public int getIntegerOption(String key) throws UnknownOptionException {
		return options.getIntegerOption(key);
	}
	
	public void setIntegerOption(String key, int value) throws UnknownOptionException {
		options.setIntegerOption(key, value);
	}
	
	public double getRealOption(String key) throws UnknownOptionException {
		return options.getRealOption(key);
	}
	
	public void setRealOption(String key, double value) throws UnknownOptionException {
		options.setRealOption(key, value);
	}
	
	public boolean getBooleanOption(String key) throws UnknownOptionException{
		return options.getBooleanOption(key);
	}
	
	public void setBooleanOption(String key, boolean value) throws UnknownOptionException {
		options.setBooleanOption(key, value);
	}

	public void setDiagnosticsGenerator(DiagnosticsGenerator diagGenerator) {
		this.diagGenerator = diagGenerator;
	}

	public DiagnosticsGenerator getDiagnosticsGenerator() {
		return this.diagGenerator;
	}
	
	public String getOptionDescription(String key) throws UnknownOptionException {
		return options.getDescription(key);
	}

	/**
	 * Returns the modelicapath attribute set for this compiler instance.
	 * 
	 * @return Reference to the modelicapath attribute. 
	 * 
	 */
	public String getModelicapath() {
		return options.getStringOption("MODELICAPATH");
	}
	
	/**
	 * Set the modelicapath attribute.
	 * 
	 * @param path The new modelicapath.
	 */
	public void setModelicapath(String path) {
		options.addStringOption("MODELICAPATH", path);
	}
	
	/**
	 * Returns the XML model description template file path set for this compiler instance.
	 * 
	 * @return Reference to the XML variables template file path attribute. 
	 * 
	 */
	public String getXMLTpl() {
		return this.xmlTpl;
	}

	/**
	 * Set the XML model description template file path attribute.
	 * 
	 * @param template The new XML variables template file path.
	 */
	public void setXMLTpl(String template) {
		this.xmlTpl = template;
	}
	
	/**
	 * Returns the XML values template file path set for this compiler instance.
	 * 
	 * @return Reference to the XML values template file path attribute.
	 * 
	 */
	public String getXMLValuesTpl() {
		return this.xmlValuesTpl;
	}

	/**
	 * Set the XML values template file path attribute.
	 * 
	 * @param template The new XML values template file path.
	 */
	public void setXMLValuesTpl(String template) {
		this.xmlValuesTpl = template;
	}

	/**
	 * Returns the c template file path set for this compiler instance.
	 * 
	 * @return Reference to the c template file path attribute. 
	 * 
	 */
	public String getCTemplate() {
		return this.cTemplatefile;
	}
	
	/**
	 * Set the c template file path attribute.
	 * 
	 * @param template The new c template file path.
	 */
	public void setCTemplate(String template) {
		this.cTemplatefile = template;
	}

	protected final static int NUM_USED_MEMORY_SLOTS = 6;
	protected long[] usedMem = new long[NUM_USED_MEMORY_SLOTS];
	protected int numUsedMemFilled;
	protected long timeCompilationStarted;

	/**
	 * \brief Initilize vars gathering debug information about compilation.
	 * 
	 * Should be called before compilation process begins.
	 */
	protected void resetCompilationInfo() {
		timeCompilationStarted = System.currentTimeMillis();
		numUsedMemFilled = 0;
	}
	
	/**
	 * \brief Log debug information about compilation.
	 * 
	 * Should be called after compilation process ends.
	 */
	protected void logCompilationInfo() {
		long time = System.currentTimeMillis() - timeCompilationStarted;
		double time2 = Math.round(time / 10.0) / 100.0;
		log.debug("Compilation took " + time2 + " s");
		
		noteUsedMemory();  // Needed if an exception occurred
		if (numUsedMemFilled > 1) {
			log.debug("Changes in memory use:");
			log.debug(" parseModel():       " + ASTNode.formatMem((int) (usedMem[1] - usedMem[0])));
		}
		if (numUsedMemFilled > 3)
			log.debug(" instantiateModel(): " + ASTNode.formatMem((int) (usedMem[3] - usedMem[2])));
		if (numUsedMemFilled > 5)
			log.debug(" flattenModel():     " + ASTNode.formatMem((int) (usedMem[5] - usedMem[4])));
	}
	
	/**
	 * \brief Saves away the current amount of memory used.
	 */
	protected void noteUsedMemory() {
		if (numUsedMemFilled < NUM_USED_MEMORY_SLOTS)
			usedMem[numUsedMemFilled++] = RUNTIME.totalMemory() - RUNTIME.freeMemory();
	}
	private static final Runtime RUNTIME = Runtime.getRuntime();

	/**
	 * \brief Save a dump of the memory use of an AST.
	 * 
	 * The dump will be saved in a file named <code>"size_" + type + ".txt"</code>.
	 * 
	 * @param root  the root of the AST to dump memory use for
	 * @param type  a one-word description of the tree to dump
	 */
	protected void dumpMemoryUseFile(ASTNode root, String type) throws FileNotFoundException {
		dumpMemoryUseFile(root, type, type);
	}

	/**
	 * \brief Save a dump of the memory use of an AST.
	 * 
	 * The dump will be saved in a file named <code>"size_" + name + ".txt"</code>.
	 * 
	 * @param root  the root of the AST to dump memory use for
	 * @param type  a short description of the tree to dump
	 * @param name  the variable part of the file name
	 */
	protected void dumpMemoryUseFile(ASTNode root, String type, String name) 
			throws FileNotFoundException {
		String file = "size_" + name + ".txt";
		log.debug("Dumping " + type + " tree to '" + file + "'...");
		long time = System.currentTimeMillis();
		root.dumpMemoryUse(file, true, 25, 2 * 1024);
		time = Math.round((System.currentTimeMillis() - time) / 1000.0);
		log.debug(" Dumped tree in " + time + "s");
	}

	/**
	 * \brief Save a dump of the number of AST nodes created of each type.
	 * 
	 * ASTNode must be changed to inherit ProfilingNode for node type counting to work.
	 * 
	 * @param file  the name of the file to save dump to
	 */
	protected void dumpNodeCountFile(String file) throws FileNotFoundException {
		if (ProfilingNode.class.isAssignableFrom(ASTNode.class)) {
			log.debug("Dumping counts of created nodes to '" + file + "'...");
			PrintStream out = new PrintStream(file);
			ProfilingNode.printInfo(out, ProfilingNode.SORT_COUNT_DESC);
			out.close();
		} else {
			log.debug("ASTNode must inherit ProfilingNode for node type counting to work.");
		}
	}
	
	/**
	 * \brief Compiles a model and creates a JMU.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a JMU.
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param target The build target. Valid options are 'model', 'model_noad', 'algorithms' and 'ipopt'.
	 * @param compileTo Specify location of the compiled JMU. Directory will be created if it does not exist.
	 */
	public void compileJMU(String className, String fileName[], String target, String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		log.info("START COMPILING JMU...");	
		this.compileUnit(className, fileName, target, compileTo, "JMU");
		log.info("...COMPILING JMU finished");
	}

	/**
	 * \brief Compiles a model and creates a FMU.
	 * 
	 * Compiles a model (parsing, instantiating, flattening, code generation and 
	 * binary file compilation) and packs the result in a FMU.
	 * 
	 * @param className Name of model class in the model file to compile.
	 * @param fileName Array of model file paths.
	 * @param target The build target. Currently only "model_noad" is supported. 
	 * @param compileTo Specify location of the compiled FMU. Directory will be created if it does not exist.
	 */
	public void compileFMU(String className, String fileName[], String target, String compileTo) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		log.info("START COMPILING FMU...");
		
		// Always set certain options when compiling an FMU
		// First save these options in temp options registry to reset when compiling has finished
		OptionRegistry tempOptions = new OptionRegistry();
		tempOptions.copyAllOptions(options);
		
		setBooleanOption("generate_ode", true);
		setBooleanOption("generate_dae", false);	
		setBooleanOption("equation_sorting", true);
		// use fmi file templates and set the correct options so that XML file will be FMI compliant
		defaultTemplatePathsFMU();
		setBooleanOption("generate_fmi_xml", true);
		setBooleanOption("generate_xml_equations", false);
		this.compileUnit(className, fileName, target, compileTo, "FMU");
		
		// set back all options
		options.copyAllOptions(tempOptions);
		
		log.info("...COMPILING FMU finished");
	}

	/**
	 * \brief Compiles a JMU or FMU (helper function for compileJMU and compileFMU).
	 * 
	 * @param unitType "JMU" or "FMU".
	 */
	private void compileUnit(String className, String fileName[], String target, String compileTo, String unitType) 
		throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		// compile mo-file + generate code
		FClass fc = compileModel(fileName, className);
		
		// compile c code
		hookCheckAbort();
		String cFileName = className.replace(".", "_");
		this.getCCompiler().compileCCode(cFileName, target, fc.externalLibraries(), fc.externalLibraryDirectories(), fc.externalIncludeDirectories());
		hookCodeCompiled();
		
		// package JMU
		this.packUnit(className, compileTo, unitType);		
	}
	
	/**
	 * \brief Packs either a JMU or FMU (helper function for compileUnit).
	 * 
	 * @param className Name of model class that was compiled (will determine file names).
	 * @param path Location on file system where the packed file should be saved (created if does not exist).
	 * @param unitType "JMU" or "FMU".
	 */
	private void packUnit(String className, String path, String unitType) {
		String filesep = File.separator;
		File dirPath = new File(path);
		if (!dirPath.isDirectory()) {
			dirPath.mkdirs();
		}
		
		String mName = className;
		String mMangledName = className.replace(".", "_");
		
		// Look for operating system and architecture
		String platform = getPlatform();
		String suffix;
		if (platform.startsWith("win")) {
			suffix = ".dll";
		} else if (platform.startsWith("darwin")) {
			suffix = ".dylib";
		} else {
			suffix = ".so";
		}
		
		// original files
		String[] files = new String[6];
		files[0] = mMangledName + ".xml";
		files[1] = mMangledName + ".c";
		files[2] = mName + ".mof";
		files[3] = mName + "_transformed.mof";
		files[4] = mMangledName + "_values.xml";
		files[5] = mMangledName + suffix;
		
		// file destinations
		String[] zipEntries = new String[6];
		zipEntries[0] = "modelDescription.xml";
		zipEntries[1] = "sources" + filesep + mMangledName + ".c";
		zipEntries[2] = "resources" + filesep + mName + ".mof";
		zipEntries[3] = "resources" + filesep + mName + "_transformed.mof";
		zipEntries[4] = "resources" + filesep + mMangledName + "_values.xml";
		zipEntries[5] = "binaries" + filesep + platform + filesep + mMangledName + suffix;
		
		// Create the new archive
		int BUFFER = 2048;
		try {
			hookCheckAbort();

			File unitFile = new File(dirPath, mMangledName + "." + unitType.toLowerCase());
			BufferedInputStream origin = null;
			FileOutputStream dest = new FileOutputStream(unitFile);
			ZipOutputStream out = new ZipOutputStream(new BufferedOutputStream(dest));
			out.setMethod(ZipOutputStream.DEFLATED);
			
			byte data[] = new byte[BUFFER];
			
			for (int i = 0; i < files.length; i++) {
				FileInputStream fi = new FileInputStream(files[i]);
				origin = new BufferedInputStream(fi, BUFFER);
				
				ZipEntry entry = new ZipEntry(zipEntries[i]);
				out.putNextEntry(entry);
				
				int count;
	            while ((count = origin.read(data, 0, BUFFER)) != -1) {
	               out.write(data, 0, count);
	            }
	            origin.close();
			}
			
			out.close();
			hookFmuPacked(unitFile.getAbsolutePath());
		} catch(CompilationAbortedException e) {
		} catch(Exception e) {
			// TODO: Make sure this is logged or reported properly
		}
		
		// remove files
		File f = null;
		for (int i = 0; i < files.length; i++) {
			f = new File(files[i]);
			f.delete();
		}
	}
		
	/**
	 * Compiles a Modelica model. A model file name and class must be provided.
	 * Prints an error and returns without completion if, for example, a file 
	 * can not be found or if the parsing fails. Supports multiple model files.
	 * 
	 * @param name
	 *            Array of names of the model files.
	 * @param cl
	 *            The name of the class in the model file to compile.
	 * @throws beaver.Parser.Exception
	 *             If there was an Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing, instantiation
	 *             or flattening.
	 * @throws FileNotFoundException
	 *             If the model file can not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver
	 *             exception.)
	 * @throws IOException
	 *             If there was an error creating the .mof file.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to parse, instantiate or flatten is not
	 *             found.
	 * 
	 */
	public FClass compileModel(String name[], String cl)
	  throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		log.info("======= Compiling model =======");
		resetCompilationInfo();
		
		SourceRoot sr = null;
		FClass fc = null;
		try {

			// build source tree
			sr = parseModel(name);
//			dumpMemoryUseFile(sr, "source");  // TODO: add command-line arg for this

			if (sr.options.getBooleanOption("generate_html_diagnostics")) {
				setDiagnosticsGenerator(new DiagnosticsGenerator(cl));
			}

			// compute instance tree
			InstClassDecl icl = instantiateModel(sr, cl);
			//icl.dumpTree("");
//			dumpMemoryUseFile(icl, "instance");
			
			// flattening
			fc = flattenModel(icl);
//			dumpMemoryUseFile(fc, "flat");

			// Generate code?
			if (this.getXmlTpl(fc) != null && this.getXmlValuesTpl(fc) !=null && this.getCTemplatefile(fc) != null) 
				generateCode(fc);
		} finally {
			logCompilationInfo();
			// The node count requires changeing ASTNode.java by hand - see dumpNodeCountFile()
//			dumpNodeCountFile("node_count.txt");
//			dumpMemoryUseFile(sr, "final source", "source2");
		}

		if (sr.options.getBooleanOption("generate_html_diagnostics")) {
			getDiagnosticsGenerator().finalize();
			setDiagnosticsGenerator(null);
		}

		log.info("====== Model compiled successfully =======");
		
		return fc;
	}

	/**
	 * 
	 * Parses a model and returns a reference to the root of the source tree.
	 * Options related to the compilation are also loaded here and added to the
	 * source tree representation.
	 * 
	 * @param name
	 *            The name of the model file.
	 *            
	 * @return The root of the source tree.
	 * 
	 * @throws beaver.Parser.Exception
	 *             If there was an Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing.
	 * @throws FileNotFoundException
	 *             If the model file can not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver exception.)
	 */
	private SourceRoot parseModel(String name) 
	  throws FileNotFoundException, IOException, beaver.Parser.Exception, CompilerException{
//		ModelicaParser parser = new ModelicaParser();
//		ModelicaParser.CollectingReport report = new ModelicaParser.CollectingReport();
//		parser.setReport(report);
//		Reader reader = new FileReader(name);
//		ModelicaScanner scanner = new ModelicaScanner(new BufferedReader(reader));
	/*
		if (report.hasErrors()) {
			CompilerException ce = new CompilerException();
			for (Problem p : report.getErrors()) {
				ce.addProblem(p);
			}
			throw ce;
		}
		*/
		ParserHandler ph = new ParserHandler();
		log.info("Parsing " + name + "...");
		SourceRoot sr;
		try {
//			sr = (SourceRoot) parser.parse(scanner);
			sr = ph.parseFile(name);
		} catch (ParserException e) {
			e.getProblem().setFileName(name);
			CompilerException ce = new CompilerException();
			ce.addProblem(e.getProblem());
			throw ce;
		}
		//loadOptions(sr);
		for (StoredDefinition sd : sr.getProgram().getUnstructuredEntitys()) {
			sd.setFileName(name);
		}
		return sr;
	}

	/**
	 * 
	 * Parses a set of files and returns a reference to the root of a source tree
     * where the content of all files is contained. Each file is parsed using
     * the parseModel method.
	 * 
	 * @param names
	 *            An array of file names.
	 *            
	 * @return The root of the source tree.
	 * 
	 * @throws beaver.Parser.Exception
	 *             If there was a Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing.
	 * @throws FileNotFoundException
	 *             If the model file could not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver exception.)
	 */
	public SourceRoot parseModel(String names[]) 
	  throws FileNotFoundException, IOException, beaver.Parser.Exception, CompilerException{
		hookCheckAbort();
		noteUsedMemory();
		
		SourceRoot sr = new SourceRoot(new Program());
		sr.options.copyAllOptions(this.options);
		for (String name : names) {
			SourceRoot sr_tmp = parseModel(name);
			for(StoredDefinition sd : sr_tmp.getProgram().getUnstructuredEntitys()) 
				sr.getProgram().addUnstructuredEntity(sd);
		}
		
		hookFilesParsed(sr);
		noteUsedMemory();
		
		return sr;
	}
	
	/**
	 * 
	 * Computes a model instance tree from a source tree. Some error checks such
	 * as type checking is performed during the computation.
	 * 
	 * @param sr
	 *            The reference to the model source root.
	 * @param cl
	 *            The name of the class in the model file to compile.
	 * 
	 * @return The instance node corresponding to the instantiated model.
	 * 
	 * @throws CompilerException
	 *             If errors have been found during the instantiation.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to instantiate is not found.
	 */
	public InstClassDecl instantiateModel(SourceRoot sr, String cl) 
		throws ModelicaClassNotFoundException, CompilerException {
		hookCheckAbort();
		noteUsedMemory();
		
		InstProgramRoot ipr = sr.getProgram().getInstProgramRoot();
		ipr.options = new OptionRegistry(sr.options);
		
		if (sr.options.getBooleanOption("compliance_as_warning"))
			sr.setErrorHandler(new ComplianceWarnErrorHandler(sr));
		
		log.info("Checking for errors...");
		Collection<Problem> problems = ipr.checkErrorsInInstClass(cl);
		if (problems.size()>0) {
			handleCompilerProblems(problems);
		}
		
		InstClassDecl icd = ipr.simpleLookupInstClassDecl(cl);
		
		hookModelInstantiatied(icd);
		noteUsedMemory();
		
		return icd;
	}
	
	protected void handleCompilerProblems(Collection<Problem> problems) throws CompilerException{
		ArrayList<Problem> warnings = new ArrayList<Problem>();
		ArrayList<Problem> errors = new ArrayList<Problem>();
		for (Problem p : problems) {
			if (p.severity() == Problem.Severity.ERROR) 
				errors.add(p);
			else
				warnings.add(p);
		}
		
		if (this.options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeProblems(problems);
		}
		
		if (errors.size() > 0 || (warnings.size() > 0 && options.getBooleanOption("halt_on_warning"))) {
			// there are errors -> add errors and possible warnings and throw exception or
			// there are only warnings but compiler option sais throw exception			
			
			CompilerException ce = new CompilerException();
			for (Problem e : errors) 
				ce.addProblem(e);
			for (Problem w: warnings) 
				ce.addProblem(w);
			throw ce;
		} else {
			// there are only warnings and halt_on_warning = false so just send them to logger
			log.warning("------- Compiler Warnings -------");
			for (Problem p:warnings) 
				log.warning(p.toString());
			log.warning("--------------------------------");
		}
	}
	
	/**
	 * \brief Create a new FClass object.
	 * 
	 * @param icd A reference to a instance class - in compiler extensions
	 * it may be useful to be able to extract the kind of class is being
	 * instantiated: model, block etc.
	 * 
	 * Override for subclasses needing a subclass of FClass.
	 */
	protected FClass createFClass(InstClassDecl icd) {
		return new FClass();
	}
	
	/**
	 * Computes the flattened model representation from a model instance.
	 * 
	 * @param icd
	 *            A reference to the model instance node.
	 * 
	 * @return FClass object representing the flattened model.
	 * 
	 * @throws CompilerException
	 *             If errors have been found during the flattening.
	 * @throws IOException
	 *             If there was an error creating the .mof file.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to flatten is not found.
	 */
	public FClass flattenModel(InstClassDecl icl) 
			throws CompilerException, ModelicaClassNotFoundException, IOException {
		hookCheckAbort();
		noteUsedMemory();
		
		FlatRoot flatRoot = new FlatRoot();
		flatRoot.setFileName(icl.qualifiedName()+".mof");
		FClass fc = createFClass(icl);
		flatRoot.setFClass(fc);
		flatRoot.options = new OptionRegistry(icl.root().options);
		
		log.info("Flattening model...");
		icl.flattenInstClassDecl(fc);
		
		hookModelFlattened(fc);
		hookCheckAbort();
		
		//fc.dumpTree("");
		// Output the untransformed flattened model
		log.debug("Creating raw .mof file...");
		PrintStream out = new PrintStream(icl.qualifiedName() + ".mof");
		fc.prettyPrint(out, "");
	   	out.close();
	   	log.debug("... raw .mof file created.");

		log.info("Raw flattened model:");		
		log.info(fc.prettyPrint(""));

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeRawFlattenedModel(fc);
		}
		
		fc.transformCanonical();
		
		hookModelTransformed(fc);
		hookCheckAbort();
				
		log.debug("Creating transformed .mof file...");
		out = new PrintStream(icl.qualifiedName() + "_transformed.mof");
	   	fc.prettyPrint(out, "");
	   	out.close();
	   	log.debug("... transformed .mof file created.");
	    
		log.info("Diagnostics for transformed flattened model:");		
		log.info(fc.diagnostics());
		
		log.info("Transformed flattened model:");		
		log.info(fc.prettyPrint(""));

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeTransformedFlattenedModel(fc);
		}

		Collection<Problem> problems = fc.errorCheck();

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeProblems(problems);
		}

		if (fc.root().options.getBooleanOption("generate_html_diagnostics") &&
		    getDiagnosticsGenerator()!=null) {
			getDiagnosticsGenerator().writeDiagnostics(fc);
		}

		if (problems.size() > 0) 
			handleCompilerProblems(problems);

		hookFlatModelChecked(fc);
		noteUsedMemory();

		return fc;
	}
	
	/**
	 * \brief Create a new XMLGenerator object.
	 * 
	 * Override for subclasses needing another subclass of XMLGenerator.
	 */
	protected XMLGenerator createXMLGenerator(FClass fc) {
		return new XMLGenerator(new PrettyPrinter(), '$', fc);
	}
	
	/**
	 * \brief Create a new XMLValueGenerator object.
	 * 
	 * Override for subclasses needing another subclass of XMLValueGenerator.
	 */
	protected XMLValueGenerator createXMLValueGenerator(FClass fc) {
		return new XMLValueGenerator(new PrettyPrinter(), '$', fc);
	}
	
	/**
	 * \brief Create a new CGenerator object.
	 * 
	 * Override for subclasses needing another subclass of CGenerator.
	 */
	protected CGenerator createCGenerator(FClass fc) {
		return new CADGenerator(new PrettyPrinter(), '$', fc);
	}

	/**
	 * \brief get the XML template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getXmlTpl(FClass fc) {
		return this.xmlTpl;
	}

	/**
	 * \brief get the XML values template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getXmlValuesTpl(FClass fc) {
		return this.xmlValuesTpl;
	}

	/**
	 * \brief get the C template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getCTemplatefile(FClass fc) {
		return this.cTemplatefile;
	}
	
	/**
	 * 
	 * Generates XML and c code for a flattened model represented as an instance
	 * of FClass using template files. The XML variables, XML values and c files
	 * are given the default names <modelname>.xml, <modelname>_values.xml and 
	 * <modelname>.c respectively.
	 * 
	 * @param fc
	 *            The FClass instance for which the code generation should be
	 *            computed.
	 * @throws FileNotFoundException
	 *             If either of the three template files can not be found.
	 */
	public void generateCode(FClass fc) throws FileNotFoundException {
		hookCheckAbort();
		log.info("Generating code...");
		
		XMLGenerator xmlgenerator = createXMLGenerator(fc);
		String output = fc.nameUnderscore() + ".xml";
		xmlgenerator.generate(getXmlTpl(fc), output);

		XMLValueGenerator valuegenerator = createXMLValueGenerator(fc);
		output = fc.nameUnderscore() + "_values.xml";
		valuegenerator.generate(getXmlValuesTpl(fc), output);
		
		CGenerator cgenerator = createCGenerator(fc);
		output = fc.nameUnderscore() + ".c";
		cgenerator.generate(getCTemplatefile(fc), output);

		hookCodeGenerated();
		log.debug("... code generated.");
	}
	
	/**
	 * Sets logging to the level specified. Valid values are:
	 * ModelicaCompiler.DEBUG, ModelicaCompiler.INFO, ModelicaCompiler.WARNING or ModelicaCompiler.ERROR
	 * 
	 * Default log level setting is ERROR. Messages will be printed to the
	 * standard out.
	 * 
	 * @param level
	 *            The level of logging to use as of now.
	 */
	public static void setLogLevel(ModelicaLogger logger, String level) {
		if (logger != null) {
			Level lv = levels.get(level);
			if (lv == null)
				lv = levels.get(DEFAULT_LEVEL);
			log.setLevel(lv);
		}
	}
	
	/**
	 * Returns the log level that is currently set.
	 * 
	 * @return Log level setting for this class.
	 */
	public static String getLogLevel(ModelicaLogger logger) {
		Level lv = logger != null ? logger.getLevel() : null;
		return lv != null ? lv.toString() : ModelicaCompiler.INHERITED;
	}
	
	/**
	 * Sets logging to the level specified. Valid values are:
	 * ModelicaCompiler.DEBUG, ModelicaCompiler.INFO, ModelicaCompiler.WARNING or ModelicaCompiler.ERROR
	 * 
	 * Default log level setting is ERROR. Messages will be printed to the
	 * standard out.
	 * 
	 * @param level
	 *            The level of logging to use as of now.
	 */
	public static void setLogLevel(String logger, String level) {
		setLogLevel(ModelicaLoggers.getLogger(logger), level);
	}
	
	/**
	 * Returns the log level that is currently set.
	 * 
	 * @return Log level setting for this class.
	 */
	public static String getLogLevel(String logger) {
		return getLogLevel(ModelicaLoggers.getLogger(logger));
	}
	
	protected static Hashtable<String, String> extractProgramArguments(String[] args, int pos) {
		Hashtable<String, String> programargs = new Hashtable<String,String>();		
		
		while(pos < args.length && argumentIsOption(args[pos])) {
			addOptionToMap(programargs, args[pos]);
			pos++;
		}
		return programargs;
	}

	private static void addOptionToMap(Hashtable<String, String> programargs, String arg) {
		String[] parts = arg.trim().substring(1).split("=");
		programargs.put(parts[0], (parts.length > 1) ? parts[1] : null);
	}

	private static boolean argumentIsOption(String arg) {
		arg = arg.trim();
		return !arg.equals("") && arg.startsWith("-");
	}
	
	private void setOptions(Hashtable<String, String> programarguments, String modelicapath) {
		String filesep = File.separator;
		String optionsfile = null;
		//look for options.xml in $JMODELICA_HOME/Options/ and program arguments
		if (programarguments.get("optfile") != null) {
			optionsfile = programarguments.get("optfile");
		} else {
			optionsfile = jmodelicaHome+filesep+"Options"+filesep+"options.xml";
		}

		try {
			options = new OptionRegistry(optionsfile);
		} catch(Exception e) {
			log.warning("The options XML file could not be loaded, using defaults.");
			log.stackTrace(e);
			options = new OptionRegistry();
		}
		
		//add modelicapath to optionregistry
		if (modelicapath == null) {
			//modelicapath was not set in program arguments -> check envir variable or via JMODELICA_HOME
			if (System.getenv("MODELICAPATH") != null) { 
				modelicapath=System.getenv("MODELICAPATH");
			} else {
				modelicapath=jmodelicaHome+filesep+"ThirdParty"+filesep+"MSL";
			}
		}
		options.addStringOption("MODELICAPATH", modelicapath);
	}
	
	protected void setArguments(String compilerName, String[] args, Hashtable<String, String> programarguments) 
		throws JModelicaHomeNotFoundException {
		// check that JMODELICA_HOME exists
		if (jmodelicaHome == null) {
			throw new JModelicaHomeNotFoundException("The environment variable JMODELICA_HOME has not been set.");
		}
		
		String filesep = File.separator;
		if (args.length < 1) {
			log.error(compilerName + " expects the command line arguments: \n" +
					"[-options] <file name> <class name> [<xml model description template> <xml model values template> <c template>]\n" +
					"where options could be: \n" +
					"-log=<d or i or w or e> \n" +
					"-modelicapath=<path to modelica library> \n" +
					"-optfile=<path to XML options file>");
			System.exit(1);
		}
		
		int arg = 0;
		String modelicapath = null;
		
		//log option
		if (programarguments.get("log") != null) {
			setLogLevel(log, programarguments.get("log"));
		} else {
			setLogLevel(log, ModelicaCompiler.ERROR);
		}
		//modelicapath option
		modelicapath = programarguments.get("modelicapath");
		
		arg = programarguments.size();
		if (args.length < arg+2) {
			log.error(compilerName + " expects a file name and a class name as command line arguments.");
			System.exit(1);
		}
		
		// set templates and options		
		if (args.length >= arg+5) {
			this.xmlTpl = args[arg+2];
			this.xmlValuesTpl = args[arg+3];
			this.cTemplatefile = args[arg+4];
		}
		
		// set options
		this.setOptions(programarguments, modelicapath);
	}
	
	public static void main(String[] args) {
		// TODO: Add a class representing the arguments of the program, with getX methods for arguments.
		// Get any program options set
		Hashtable<String, String> programarguments = extractProgramArguments(args, 0);
		// create an empty compiler
		ModelicaCompiler mc = new ModelicaCompiler();
		// set arguments
		try {
			mc.setArguments("ModelicaCompiler", args, programarguments);
		} catch(JModelicaHomeNotFoundException e) {
			mc.handleException(e);
		}
		// Compile model
		mc.compileModelFromCommandLine(args, programarguments);
	}
	
	/**
	 * \brief Compile model given in command line options and  and print any error messages.
	 */
	protected void compileModelFromCommandLine(String[] args, Hashtable<String, String> programarguments) {
		// Get files and class
		int arg = programarguments.size();
		String[] name = splitFiles(args[arg]);
		String cl = args[arg+1];
		
		// Compile model
		try {
			compileModel(name, cl);
		} catch  (ModelicaClassNotFoundException e){
			log.error("Could not find the class "+ cl);
			System.exit(1);
		} catch (CompilerException ce) {
			StringBuilder str = new StringBuilder();
			str.append(ce.getProblems().size() + " errors found:\n");
			for (Problem p : ce.getProblems()) 
				str.append(p.toString()+"\n");
			log.error(str.toString());
			System.exit(1);
		} catch (FileNotFoundException e) {
			log.error("Could not find file: " + e.getMessage());
			System.exit(1);
		} catch (OutOfMemoryError e) {
			log.error("Out of memory. Please set the memory limit of the JVM higher.");
			System.exit(1);
		} catch (Throwable e) {
			handleException(e);
		}
	}
	
	/**
	 * Split the argument containing the list of files into an array of filenames.
	 */
	protected String[] splitFiles(String arg) {
		ArrayList<String> res = new ArrayList<String>();
		for (String part : arg.split(","))
			if (!part.equals(""))
				res.add(part);
		return res.toArray(new String[res.size()]);
	}
		
	/**
	 * \brief Log error message for exception and exit.
	 */
	protected void handleException(Throwable e, String msg) {
		if (e.getMessage() != null)
			msg += ": " + e.getMessage();
		log.error(msg);
		log.stackTrace(e);
		System.exit(1);
	}
	
	/**
	 * \brief Log error message for exception and exit.
	 */
	protected void handleException(Throwable e) {
		handleException(e, "Unknown program error");
	}

	/**
	 *     Helper function. Returns string describing the platform on which jmodelica 
	 *     is run. 
	 *     
	 *     Possible return values::
	 *     win32
	 *     win64
	 *     darwin32
	 *     darwin64
	 *     linux32
	 *     linux64
	 */
	public static String getPlatform() {
		String platform = "";
		
		String sunPltform = System.getProperty("os.name");
		if (sunPltform.startsWith("Windows")) {
			platform = "win";
		} else if (sunPltform.startsWith("Mac")) {
			platform = "darwin";
		} else {
			// assume linux
			platform ="linux";
		}
		
		String architecture = System.getProperty("os.arch");
		if (architecture.endsWith("64")) {
			platform = platform+"64";
		} else {
			platform = platform+"32";
		}
		
		return platform;
	}
	
	/**
	 * Class which can be used to fetch static loggers with different purposes.
	 * 
	 * This is an attempt to have a general Logger class which contains loggers
	 * for different purposes. It is then possible to have each logger specially
	 * configured for its indended use. Right now there is only one logger class
	 * which is a console logger. It has a specific loglevel and a certain
	 * formatting. Another useful logger could be a filelogger which has a
	 * loglevel and an output formatting which suits logging to file.
	 * 
	 */
	protected static class ModelicaLoggers {
		
		public static final HashMap<String, ModelicaLogger> logs = new HashMap<String, ModelicaLogger>();
		
		/**
		 * Returns a logger with a certain name which prints logs to the
		 * console. If the name is encountered for the first time a new logger
		 * is created otherwise the already created logger with the specific
		 * name is returned. The log outputs are formatted to suit a console.
		 * The default log level is Level.WARNING.
		 * 
		 * @param name  The name of the logger.
		 * @return A logger which prints log messages to the console.
		 */
		public static ModelicaLogger getConsoleLogger(String name) {
			ModelicaLogger ml = logs.get(name);
			if (ml == null) {
				Logger l = Logger.getLogger(name);
				l.setUseParentHandlers(false);
				ConsoleHandler ch = new ConsoleHandler();
				// Dont limit log level for handler, we do that in logger
				ch.setLevel(Level.FINEST);
				ch.setFormatter(new ConsoleFormatter());
				l.addHandler(ch);
				l.setLevel(Level.WARNING);
				ml = new LoggerInModelicaLogger(l);
				logs.put(name, ml);
			}
			return ml;
		}
		
		/**
		 * Returns a previously created logger. If no logger with 
		 * the specified name exists, <code>null</code> is returned.
		 * 
		 * @param name  The name of the logger.
		 */
		public static ModelicaLogger getLogger(String name) {
			return logs.get(name);
		}
		
		/**
		 * Private formatting helper class for the console logger. Formats
		 * log messages to suit a console output.
		 * 
		 */
		private static class ConsoleFormatter extends SimpleFormatter {
			public ConsoleFormatter() {
				super();
			}
			@Override
			public String format(LogRecord record) {
				return record.getMessage()+"\n";
			}
		
		}
		
		/**
		 * \brief Wrapper class to make java.util.logging.Logger conform to ModelicaLogger.
		 */
		private static class LoggerInModelicaLogger extends ModelicaLogger {
			
			private Logger logger;
			
			public LoggerInModelicaLogger(Logger logger) {
				this.logger = logger;
			}
			
		    /**
		     * \brief Log <code>message</code> on log level <code>level</code>.
		     * 
		     * This implementation delegates to the selected Logger.
		     */
		    public void log(Level level, String message) {
		    	logger.log(level, message);
		    }
		    
		    /**
		     * \brief Get the current log level.
		     * 
		     * This implementation delegates to the selected Logger.
		     */
		    public Level getLevel() { 
		    	return logger.getLevel(); 
		    }
		    
		    /**
		     * \brief Set the current log level.
		     * 
		     * This implementation delegates to the selected Logger.
		     */
		    public void setLevel(Level lv) { 
		    	logger.setLevel(lv);
		    }
			
		}
	}
}

}

aspect CompilationHelpers {
	
/**
 * Interface for hooking into the compilation process.
 * 
 * Trees passed as arguments may be altered, but implementer must take care 
 * not to break compilation in this way.
 */
public interface CompilationHooks {
	/**
	 * Returns <code>true</code> if the compilation should be aborted.
	 * 
	 * May be called at any time, and is guaranteed to be called before each 
	 * compilation step with a separate method in this interface.
	 * 
	 * If compilation is aborted before it is finished, a 
	 * {@link CompilationAbortedException} is thrown.
	 */
	public boolean shouldAbort();
	
	/**
	 * Called after the supplied code files are parsed.
	 */
	public void filesParsed(SourceRoot sr);
	
	/**
	 * Called after the error checks on the instantiated model are finished without errors.
	 * 
	 * Since the instance tree is built lazily, this step can not be broken up.
	 */
	public void modelInstantiatied(InstClassDecl icd);
	
	/**
	 * Called after the model is flattened.
	 */
	public void modelFlattened(FClass fc);
	
	/**
	 * Called after transformations are applied to the flat model.
	 */
	public void modelTransformed(FClass fc);
	
	/**
	 * Called after error checks of the flat model are finished without errors.
	 */
	public void flatModelChecked(FClass fc);
	
	/**
	 * Called after output code is generated.
	 */
	public void codeGenerated();
	
	/**
	 * Called after the generated C code is compiled.
	 */
	public void codeCompiled();
	
	/**
	 * Called after the FMU is packed.
	 */
	public void fmuPacked(String path);
}

public class JModelicaHomeNotFoundException extends Exception {
	public JModelicaHomeNotFoundException() {
	}
	public JModelicaHomeNotFoundException(String msg) {
		super(msg);
	}
}

public class CcodeCompilationException extends RuntimeException {
	public CcodeCompilationException() {
	}
	public CcodeCompilationException(String msg) {
		super(msg);
	}
}

/**
 * Thrown when a compilation is aborted through a CompilationHooks.
 */
public class CompilationAbortedException extends RuntimeException {
	public CompilationAbortedException() {
	}
	public CompilationAbortedException(String msg) {
		super(msg);
	}
}

public interface CCompilerDelegator {
	
	public void compileCCode(String fileName, String target, HashSet<String> ext_libs, 
			HashSet<String> ext_lib_dirs, HashSet<String> ext_incl_dirs);
	
}

public class GCCcompilerDelegator implements CCompilerDelegator {
	
	public GCCcompilerDelegator() {
	}

	
	public void compileCCode(String fileName, String target, HashSet<String> ext_libs, 
			HashSet<String> ext_lib_dirs, HashSet<String> ext_incl_dirs) {
		String filesep = File.separator;
		String jmodelicaHome = ModelicaCompiler.getJModelicaHome();
		// make settings
		String makefile = jmodelicaHome + filesep + "Makefiles" + filesep + "MakeFile";
		
		// make arguments
		String file_name = "FILE_NAME=" + fileName;
		String jmodelica_home = "JMODELICA_HOME=" + jmodelicaHome;
		String cppad_home = "CPPAD_HOME=" + System.getenv("CPPAD_HOME");
		String ipopt_home = "IPOPT_HOME=" + System.getenv("IPOPT_HOME");
		String sundials_home = "SUNDIALS_HOME=" + System.getenv("SUNDIALS_HOME");
		
		String platformDir = ModelicaCompiler.getPlatform();
		
		// external library directories
		StringBuilder extLibDirs_sb = new StringBuilder();
		for (String libDir:ext_lib_dirs) {
			File f = new File(libDir + filesep + platformDir);
			if (f.isDirectory()) {
				extLibDirs_sb.append(f.getPath());
			} else {
				extLibDirs_sb.append(libDir);
			}
			extLibDirs_sb.append(" ");
		}
		String extLibDirs = "";
		if (ext_lib_dirs.size()!=0) {
			extLibDirs = "EXT_LIB_DIRS=\"" + extLibDirs_sb.toString().trim() + "\"";
		}

		// external libraries
		StringBuilder extLibs_sb = new StringBuilder();
		for (String lib:ext_libs) {
			extLibs_sb.append(lib+" ");
		}

		String extLibs = "";
		if (ext_libs.size()!=0) {		
			extLibs = "EXT_LIBS=\"" + extLibs_sb.toString().trim() + "\"";
		}

		// external include directories
		StringBuilder extInclDirs_sb = new StringBuilder();
		for (String libDir:ext_incl_dirs) {
			extInclDirs_sb.append(libDir + " ");
		}
		String extInclDirs = "";
		if (ext_incl_dirs.size()!=0) {
			extInclDirs = "EXT_INC_DIRS=\"" + extInclDirs_sb.toString().trim() + "\"";
		}

		// Generate make call
		String[] cmd;
		if (platformDir.startsWith("win")) {
			cmd = new String[14];
			
			String mingw_bin = System.getenv("MINGW_HOME") + filesep + "bin";
			String make = mingw_bin + filesep + "mingw32-make";
			String compiler = "CXX=" + mingw_bin + filesep + "g++";
			String ar = "AR=" + mingw_bin + filesep + "ar";
			
			cmd[0] = make;
			cmd[1] = "-f";
			cmd[2] = makefile;
			cmd[3] = compiler;
			cmd[4] = ar;
			cmd[5] = target;
			cmd[6] = file_name;
			cmd[7] = jmodelica_home;
			cmd[8] = cppad_home;
			cmd[9] = ipopt_home;
			cmd[10] = sundials_home;
			cmd[11] = extLibDirs;
			cmd[12] = extLibs;
			cmd[13] = extInclDirs;
			
		} else {
			cmd = new String[12];
			
			String make = "make";
			
			cmd[0] = make;
			cmd[1] = "-f";
			cmd[2] = makefile;
			cmd[3] = target;
			cmd[4] = file_name;
			cmd[5] = jmodelica_home;
			cmd[6] = cppad_home;
			cmd[7] = ipopt_home;
			cmd[8] = sundials_home;
			cmd[9] = extLibDirs;
			cmd[10] = extLibs;
			cmd[11] = extInclDirs;
		}
				
		// execute make
		Runtime rt = Runtime.getRuntime();
		
		String cmd_str = "";
		for (int i=0; i<cmd.length; i++) {
			cmd_str += cmd[i];
			cmd_str += " ";	
		}

//		System.out.println("*** "+ Arrays.toString(cmd)+" ***");
		System.out.println("*** "+ cmd_str+" ***");
		try {
			Process proc = rt.exec(cmd_str);
			
            // any error message?
            StreamGobbler errorGobbler = new 
                StreamGobbler(proc.getErrorStream(), "ERR");            
            
            // any output?
            StreamGobbler outputGobbler = new 
                StreamGobbler(proc.getInputStream(), "OUT");
                
            // kick them off
            errorGobbler.start();
            outputGobbler.start();
                                    
            // any error???
            int retcode = proc.waitFor();
		
			if (retcode != 0) {
				throw new CcodeCompilationException("Return code was: "+retcode);
			}
		} catch (IOException e) {
			e.printStackTrace();
		} 
		catch (InterruptedException e) {
			e.printStackTrace();
		}
	}
}

class StreamGobbler extends Thread
{
    private InputStream is;
    private String type;
    private OutputStream os;
    
    public StreamGobbler(InputStream is, String type) {
        this(is, type, null);
    }
    
    public StreamGobbler(InputStream is, String type, OutputStream redirect){
        this.is = is;
        this.type = type;
        this.os = redirect;
    }
    
    public void run() {
        try {
            PrintWriter pw = null;
            if (os != null)
                pw = new PrintWriter(os);
                
            InputStreamReader isr = new InputStreamReader(is);
            BufferedReader br = new BufferedReader(isr);
            String line = null;
            while ((line = br.readLine()) != null) {
                if (pw != null)
                    pw.println(line);
                System.out.println(type + ">" + line);
            }
            if (pw != null)
                pw.flush();
        } catch (IOException ioe) {
            ioe.printStackTrace();  
        }
    }
}


}
