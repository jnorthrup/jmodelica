/*
    Copyright (C) 2009-2017 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect GenerateEventIndicators {

    public class FClass {

        /**
         * Transforms equations and algorithms. Currently the following transformations exist:
         * <ul>
         * <li>{@link AlgorithmIndicatorGenerator}; generates event indicators for algorithm statements.</li>
         * <li>{@link EventIndicatorGenerator}; generates event indicators for equations.</li>
         * </ul>
         */ 
        public class GenerateEventIndicators extends Transformation {

            @Override
            public void perform() {
                OptionRegistry options = myOptions();

                java.util.List<? extends FAlgorithm> algorithms = algorithms();
                java.util.List<? extends FAbstractEquation> equations = equations();
                equations.removeAll(algorithms);

                Transformer.visitAlgorithms(algorithms, new AlgorithmIndicatorGenerator(FClass.this, options));
                // EquationTransformer.visit(equations, new IndicatorTransformer(options));
                flushAllRecursive();
            }
        }
    }

    /**
     * Visitor pattern for inserting new equtions or statements into a flat tree.
     */
    public abstract class Transformer<T> {
        protected OptionRegistry options;
        protected boolean equationEventIndicators;
        protected boolean eventOutputVars;

        /**
         * Constructs an {@code Transformer} with a reference to an {@link OptionRegistry}.
         * 
         * @param options
         *          The option registry.
         */
        public Transformer(OptionRegistry options) {
            this.options = options;
            this.equationEventIndicators = options.getBooleanOption("equation_event_indicators");
            this.eventOutputVars = options.getBooleanOption("event_output_vars");
        }

        /**
         * Starting point for the equation transformer.
         * 
         * @param equations
         *          The equations to transform.
         * @param tf
         *          The {@link Transformer} to transform {@code equations}.
         */
        public static void visitEquations(Collection<? extends FAbstractEquation> equations, Transformer tf) {
            for (FAbstractEquation eqn : equations) {
                tf.visit(eqn);
            }
        }

        /**
         * Starting point for the algorithm transformer.
         * 
         * @param algorithms
         *          The algorithms to transform.
         * @param tf
         *          The {@link AlgorithmTransformer} to transform {@code algs}.
         */
        public static void visitAlgorithms(Collection<? extends FAlgorithm> algorithms, AlgorithmTransformer tf) {
            for (FAlgorithm alg : algorithms) {
                tf.visit(alg);
            }
        }

        /**
         * Visits {@code item}.
         */ 
        public void visit(T item) {
            transform(item);
        }

        /**
         * Transforms an equation or a statement, depending on {@code T}.
         */ 
        public abstract void transform(T item);
    }

    /**
     * Transformer class for statements.
     */ 
    public abstract class StatementTransformer extends Transformer<FStatement> {

        /**
         * Constructs an {@code StatementTransformer} with a reference to an {@link OptionRegistry}.
         * 
         * @param options
         *          The option registry.
         */
        public StatementTransformer(OptionRegistry options) {
            super(options);
        }

        @Override
        public void visit(FStatement stmt) {
            transform(stmt);
        }

        /**
         * Visits an {@code FForStmt}.
         * 
         * @param stmt
         *          The statement to visit.
         */ 
        public void visit(FForStmt stmt) {
            stmt.setForStmtList(visit(stmt.getForStmts()));
            transform(stmt);
        }

        /**
         * Visits an {@code FWhileStmt}.
         * 
         * @param stmt
         *          The statement to visit.
         */ 
        public void visit(FWhileStmt stmt) {
            stmt.setWhileStmtList(visit(stmt.getWhileStmts()));
            transform(stmt);
        }

        /**
         * Visits an {@code FIfStmt}.
         * 
         * @param stmt
         *          The statement to visit.
         */ 
        public void visit(FIfStmt stmt) {
            for (FIfWhenClause clause : stmt.getFIfWhenClauses()) {
                clause.setFStatementList(visit(clause.getFStatements()));
            }
            stmt.setElseStmtList(visit(stmt.getElseStmts()));
            transform(stmt);
        }

        /**
         * Visits an {@code FWhenStmt}.
         * 
         * @param stmt
         *          The statement to visit.
         */ 
        public void visit(FWhenStmt stmt) {
            for (FIfWhenClause clause : stmt.getFIfWhenClauses()) {
                clause.setFStatementList(visit(clause.getFStatements()));
            }
            transform(stmt);
        }

        /**
         * Visits a list of {@code FStatement}s.
         * 
         * @param stmts
         *          The statements to visit.
         */ 
        public List<FStatement> visit(List<FStatement> stmts) {
            for (FStatement stmt : stmts) {
                visit(stmt);
            }
            return stmts;
        }
    }

    /**
     * Transforms statements in algorithms.
     */ 
    public abstract class AlgorithmTransformer extends StatementTransformer {

        /**
         * Constructs an {@code AlgorithmTransformer} with a reference to an {@link OptionRegistry}.
         * 
         * @param options
         *          The option registry.
         */
        public AlgorithmTransformer(OptionRegistry options) {
            super(options);
        }

        /*
         * Queue for keeping track of transformed {@code FAlgorithm} blocks.
         * <p>
         * The most recently inserted (index {@code blocks.size() - 1}) block belongs to the {@link FAlgorithm}
         * being transformed.
         */
        private java.util.List<ArrayList<FStatement>> blocks = new ArrayList<ArrayList<FStatement>>();

        /**
         * Adds a statement to the algorithm block currently being transformed.
         *
         * @param stmt
         *          The statement to add.
         */
        protected void add(FStatement stmt) {
            blocks.get(blocks.size() - 1).add(stmt);
        }

        /**
         * Adds statements to the algorithm block currently being transformed.
         * Convenience method for calling {@link #add(FStatement)} on each element in {@code stmts}.
         *
         * @param stmts
         *          The statements to add.
         */
        protected void addAll(Collection<? extends FStatement> stmts) {
            for (FStatement stmt : stmts) {
                add(stmt);
            }
        }

        /**
         * Transforms an algorithm.
         *
         * @param alg
         *          The algorithm to transform.
         */
        public boolean transform(FAlgorithm alg) {
            return true;
        }

        @Override
        public void transform(FStatement stmt) {
            add(stmt);
        }

        /**
         * Visits an {@code FAlgorithm}.
         * 
         * @param alg
         *          The algorithm to visit.
         */
        public void visit(FAlgorithm alg) {
            blocks.add(new ArrayList<FStatement>());

            if (transform(alg)) {
                for (FStatement stmt : alg.getFStatements()) {
                    stmt.acceptTransform(this);
                }
            } else {
                for (FStatement stmt : alg.getFStatements()) {
                    add(stmt);
                }
            }
            alg.setFStatementList(new List<FStatement>(blocks.remove(blocks.size() - 1)));
        }

        @Override
        public List<FStatement> visit(List<FStatement> stmts) {
            blocks.add(new ArrayList<FStatement>());
            for (FStatement stmt : stmts) {
                stmt.acceptTransform(this);
            }
            return new List<FStatement>(blocks.remove(blocks.size() - 1));
        }

    }

    /**
     * Generates initial statements and indicator statements for relational expressions.
     *
     * TODO: Expression dependency is checked twice, possibly expensive. Cache result?
     */
    public class AlgorithmIndicatorGenerator extends AlgorithmTransformer {
        private FClass fClass;
        private java.util.List<FAbstractEquation> addedEquations;

        /**
         * Constructs an {@code AlgorithmIndicatorGenerator} with a reference to an {@link OptionRegistry}.
         *
         * @param options
         *          The option registry.
         */
         public AlgorithmIndicatorGenerator(FClass fClass, OptionRegistry options) {
            super(options);
            this.fClass = fClass;
            this.addedEquations = new ArrayList<FAbstractEquation>();
         }

        /**
         * Add generated equation to be added to the flat class.
         *
         * @param eqn
         *          The equation to be added.
         */
        public void addEquation(FAbstractEquation eqn) {
            addedEquations.add(eqn);
        }

        @Override
        public void visit(FAlgorithm alg) {
            super.visit(alg);
            fClass.getFAbstractEquationList().addAll(addedEquations);
            addedEquations.clear();
        }

        /**
         * Add indicator statement if the indicator could be changed by the algorithm (i.e. referenced in LHS),
         * otherwise an equation for it should be added.
         *
         * @param alg
         *          The algorithm to transform.
         */
        @Override
        public boolean transform(FAlgorithm alg) {

            for (FRelExp exp : alg.relExpInEquation()) {

                if (exp.dependsOn(alg.referencedFVariablesInLHS())) {
                    exp.genIndicator(eventOutputVars);

                    if (exp.needsIndicatorInit()) {
                        add(exp.indicatorInitStmt());
                    }
                } else if (!exp.isTimeEventGenerating() && equationEventIndicators) {
                    exp.genIndicator(eventOutputVars);
                }
            }
            return true;
        }

        /**
         * Add indicator statement if the indicator could be changed by the algorithm (i.e. referenced in LHS),
         * otherwise an equation for it should be added.
         *
         * @param stmt
         *          The statement to transform.
         */
        @Override
        public void transform(FStatement stmt) {

            for (FRelExp exp : stmt.relExpInStmt()) {
                if (exp.dependsOn(stmt.myFAlgorithm().referencedFVariablesInLHS())) {
                    add(exp.indicatorStmt());
                } else if (exp.hasIndicator() && equationEventIndicators) {
                    addEquation(exp.indicatorEquation());
                }
            }
            add(stmt);
        }

    }

    /**
     * Checks whether or not this relational expression requires an initialization statement.
     */
    inh boolean FRelExp.needsIndicatorInit();
    eq Root.getChild().needsIndicatorInit()                = false;
    eq FAlgorithm.getChild().needsIndicatorInit()          = false;
    eq FForStmt.getForStmt().needsIndicatorInit()          = true;
    eq FIfStmt.getElseStmt().needsIndicatorInit()          = true;
    eq FIfWhenClause.getFStatement().needsIndicatorInit()  = true;
    eq FWhileStmt.getWhileStmt().needsIndicatorInit()      = true;

    /**
     * Creates an assign equation for the indicator.
     */
    syn FAbstractEquation FRelExp.indicatorEquation() = new FEquation(getIndicator().fullCopy(), indicatorExp());

    /**
     * Creates an assign statement for the indicator.
     */
    syn FStatement FRelExp.indicatorStmt() = new FAssignStmt(getIndicator().fullCopy(), indicatorExp());

    /**
     * Creates an initialization statement for the indicator.
     */
    syn FStatement FRelExp.indicatorInitStmt() = new FAssignStmt(getIndicator().fullCopy(), new FIntegerLitExp(1));

    /**
     * Checks whether or not an expression depends on any variable in a collection of them.
     *
     * @param fvs
     *          The {@link FVariable}s to which to check for dependency.
     */
    syn boolean FExp.dependsOn(Collection<FVariable> fvs) {
        for (FVariable fv : lookupFVariablesInSet(findFIdUseExpsInTree())) {
            if (fvs.contains(fv)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Creates an indicator for this FRelExp.
     */
    public void FRelExp.genIndicator(boolean output) {
        FVariable v = new FRealVariable(new FPublicVisibilityType(), fContinuous(),
                new FQNameFull(calcIndicatorVarName()));

        if (output) {
            v.setFTypePrefixInputOutput(new FOutput());
        }

        myFClass().addFVariable(v);
        setIndicator(v.createUseExp());
    }

    /**
     * Generates an expression for the event indicator.
     */
    syn FExp FRelExp.indicatorExp() {
        FExp res = new FSubExp(getLeft(), getRight());
        if (myOptions().getBooleanOption("event_indicator_scaling")) {
            res = new FDivExp(res, nominal());
        }
        return res;
    }

    /* ====================== *
     *  Transform equations.  *
     * ====================== */

    /**
     * Transforms this {@link FAbstractEquation} using an {@link EquationTransformer}.
     * 
     * @param tf
     *          The transformer to transform {@code this} with.
     */ 
    // public void FAbstractEquation.acceptTransform(EquationTransformer tf)   { tf.visit(this); }

    /* ======================= *
     *  Transform statements.  *
     * ======================= */

    /**
     * Transforms this {@link FStatement} using an {@link StatementTransformer}.
     * 
     * @param tf
     *          The transformer to transform {@code this} with.
     */
    public void FStatement.acceptTransform(StatementTransformer tf)      { tf.visit(this); }

    /**
     * Transforms this {@link FAlgorithm} using an {@link AlgorithmTransformer}.
     * 
     * @param tf
     *          The transformer to transform {@code this} with.
     */
    public void FAlgorithm.acceptTransform(AlgorithmTransformer tf)      { tf.visit(this); }

    @Override
    public void FAssignStmt.acceptTransform(StatementTransformer tf)     { tf.visit(this); }

    @Override
    public void FIfStmt.acceptTransform(StatementTransformer tf)         { tf.visit(this); }

    @Override
    public void FForStmt.acceptTransform(StatementTransformer tf)        { tf.visit(this); }

    @Override
    public void FWhileStmt.acceptTransform(StatementTransformer tf)      { tf.visit(this); }

    @Override
    public void FWhenStmt.acceptTransform(StatementTransformer tf)       { tf.visit(this); }
}
