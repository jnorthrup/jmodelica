/*
    Copyright (C) 2016 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.jmodelica.util.tarjan.SimpleTarjan;
import org.jmodelica.util.tarjan.TarjanComponent;


aspect PreBlockHandling {

    public abstract class AbstractBiPGraph<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> {

        public static final PreVariableContributor PRE_VARIABLE_CONTRIBUTOR = new PreVariableContributor();

        /**
         * Contributor that ensures ensures the following:
         * - That discrete variables are bound with their pre variable uses.
         * - All equations which contains an event generating expression must
         *   be in the same block as all downstream equations which have a
         *   reference pre(x) where x is assigned by any of the equations on 
         *   the downstream path. 
         */
        public static class PreVariableContributor extends SCCContributor {

            /**
             * Merges equations which assign discrete variables with all
             * equations which references pre of the assigned variable.
             */
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> members(E equation, AbstractBiPGraph<E, V, ?> graph) {
                Collection<E> depends = Collections.emptyList();
                return depends;
            }
    
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> sameBlockMembers(E equation, AbstractBiPGraph<E, V, ?> graph) {
                return Collections.emptyList();
            }
    
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Map<E, Collection<? extends Object>> memberSets(E equation, AbstractBiPGraph<E, V, ?> graph) {
                return Collections.emptyMap();
            }
    
            /**
             * Ensures that event generating equations are merged with all
             * downstream equations which have pre references.
             */
//            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<TarjanComponent<C>> mergeComponents(Collection<C> blocks) {
                // Compute variable to block map
                Map<FAbstractVariable, C> varToBlockMap = computeVarToBlockMap(blocks);
                // Add link between discrete variables and their pre usages
                Map<C, Collection<C>> linkedDeclAndPres = linkVarDeclAndPreUse(blocks, varToBlockMap);
                Map<C, Collection<C>> predecessors1 = TarjanComponent.computePredecessorsMap(blocks);
                PreTarjan<C> t1 = new PreTarjan<C>(predecessors1, linkedDeclAndPres);
                Collection<TarjanComponent<C>> preBlocks = t1.tarjan(blocks);
                // Compute predecessors
                Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> predecessors2 =
                        TarjanComponent.computePredecessorsMap(preBlocks);
                // Propagate event info
                Map<TarjanComponent<C>, Boolean> containsOrSucceedsEvents = computeContainsOrSucceedsEvents(preBlocks, predecessors2);
                // Find blocks which needs to be merged
                Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> blocksToMerge = computeBlocksToMerge(preBlocks, predecessors2,
                        containsOrSucceedsEvents, varToBlockMap.keySet());
                PreTarjan<TarjanComponent<C>> t2 = new PreTarjan<TarjanComponent<C>>(predecessors2, blocksToMerge);
                Collection<TarjanComponent<TarjanComponent<C>>> preBlocks2 = t2.tarjan(preBlocks);
                preBlocks = mergeSubComponents(preBlocks2);
                return  preBlocks;
            }
            
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<FAbstractVariable, C> computeVarToBlockMap(Collection<C> components) {
                Map<FAbstractVariable, C> res = new HashMap<FAbstractVariable, C>();
                for (C component : components) {
                    for (E eqn : component) {
                        if (eqn.isMeta()) {
                            continue;
                        }
                        res.put(eqn.getMatching().getVariable(), component);
                    }
                }
                return res;
            }

            /**
             * For each component, this method determines if it is event
             * generating of depends on event generating equations. 
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<TarjanComponent<C>, Boolean> computeContainsOrSucceedsEvents(Collection<TarjanComponent<C>> components,
                    Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> predecessors) {
                Map<TarjanComponent<C>, Boolean> containsOrSucceedsEvents = new HashMap<TarjanComponent<C>, Boolean>();
                for (TarjanComponent<C> component : components) {
                    checkComponentForEventEqs(component, containsOrSucceedsEvents, predecessors);
                }
                return containsOrSucceedsEvents;
            }

            /**
             * Helper
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            boolean checkComponentForEventEqs(TarjanComponent<C> component, Map<TarjanComponent<C>, Boolean> containsOrSucceedsEventEq,
                    Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> predecessors) {
                Boolean res = containsOrSucceedsEventEq.get(component);
                if (res != null) {
                    return res;
                }
                res = false;
                for (TarjanComponent<C> predecessor : predecessors.get(component)) {
                    if (checkComponentForEventEqs(predecessor, containsOrSucceedsEventEq, predecessors)) {
                        res = true;
                        break;
                    }
                }
                if (!res) {
                    for (C block : component) {
                        for (E eqn : block.getMembers()) {
                            if (eqn.getEquation().generatesEvents() || eqn.getEquation().isSampleEquation()) {
                                res = true;
                                break;
                            }
                        }
                    }
                }
                containsOrSucceedsEventEq.put(component, res);
                return res;
            }

            /**
             * Computes which components needs to be merged. The result
             * contains a map with an entry for each component that needs to be
             * merged. It maps to the collection of components thatn needs to
             * be merged.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> computeBlocksToMerge(
                    Collection<TarjanComponent<C>> components, Map<TarjanComponent<C>,
                    Collection<TarjanComponent<C>>> predecessors,
                    Map<TarjanComponent<C>, Boolean> containsOrSucceedsEventEq, Set<FAbstractVariable> inBlockSet) {
                Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> blocksToMerge = new HashMap<TarjanComponent<C>, Collection<TarjanComponent<C>>>();
                for (TarjanComponent<C> component : components) {
                    computeBlocksToMerge(component, false, blocksToMerge, containsOrSucceedsEventEq, predecessors,
                            inBlockSet);
                }
                Iterator<Map.Entry<TarjanComponent<C>, Collection<TarjanComponent<C>>>> it = blocksToMerge.entrySet().iterator();
                ASTNode.log.debug(new LinkedHashSet<Collection<TarjanComponent<C>>>(blocksToMerge.values()));
                while (it.hasNext()) {
                    Map.Entry<TarjanComponent<C>, Collection<TarjanComponent<C>>> entry = it.next();
                    if (entry.getValue().size() <= 1) {
                        it.remove();
                    }
                }
                return blocksToMerge;
            }

            /**
             * Helper
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<TarjanComponent<C>> computeBlocksToMerge(TarjanComponent<C> component, boolean force,
                    Map<TarjanComponent<C>, Collection<TarjanComponent<C>>> blocksToMerge,
                    Map<TarjanComponent<C>, Boolean> containsOrSucceedsEvents, Map<TarjanComponent<C>,
                    Collection<TarjanComponent<C>>> predecessors,
                    Set<FAbstractVariable> inBlockSet) {
                if (!containsOrSucceedsEvents.get(component)) {
                    return Collections.<TarjanComponent<C>>emptyList();
                }
                Collection<TarjanComponent<C>> res = blocksToMerge.get(component);
                if (res != null && (res.size() > 0 || !force)) {
                    return res;
                }
                res = null;
                boolean containsPre = containsActivePre(component, inBlockSet);
                if (containsPre || force) {
                    for (TarjanComponent<C> predecessor : predecessors.get(component)) {
                        Collection<TarjanComponent<C>> predecessorRes = computeBlocksToMerge(predecessor, true, blocksToMerge,
                                containsOrSucceedsEvents, predecessors, inBlockSet);
                        if (predecessorRes.isEmpty()) {
                            continue;
                        } else if (res == null) {
                            res = predecessorRes;
                        } else if (predecessorRes != res) {
                            // We need to merge the two! We do this by repointing
                            // all to current res
                            res.addAll(predecessorRes);
                            for (TarjanComponent<C> c : predecessorRes) {
                                blocksToMerge.put(c, res);
                            }
                        }
                    }
                    if (res == null) {
                        // If no predecessor had any event generating equation,
                        // then res is null and we need to create a new list
                        res = new ArrayList<TarjanComponent<C>>();
                    }
                    res.add(component);
                } else {
                    res = Collections.emptyList();
                }
                blocksToMerge.put(component, res);
                return res;
            }

            /**
             * Helper which determines if an equation contains an active pre
             * reference. It's active if the discrete variable is in the graph.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            boolean containsActivePre(TarjanComponent<C> component, Set<FAbstractVariable> inBlockSet) {
                for (C block : component) {
                    for (E eqn : block) {
                        for (FVariable var : eqn.getEquation().discretePreVariables()) {
                            FAbstractVariable nonPre = var.myNonPreVariable();
                            if (inBlockSet.contains(nonPre)) {
                                return true;
                            }
                        }
                    }
                }
                return false;
            }

            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<C, Collection<C>> linkVarDeclAndPreUse(Collection<C> components,
                    Map<FAbstractVariable, C> varToBlockMap) {
                Map<C, Collection<C>> blocksToMerge = new HashMap<C, Collection<C>>();
                for (C component : components) {
                    Collection<C> res = blocksToMerge.get(component);
                    for (E eqn : component) {
                        for (FVariable var : eqn.getEquation().discretePreVariables()) {
                            FAbstractVariable nonPre = var.myNonPreVariable();
                            C other = varToBlockMap.get(nonPre);
                            Collection<C> otherRes = blocksToMerge.get(other);
                            if (res == null && otherRes == null) {
                                res = new ArrayList<C>();
                                res.add(component);
                                blocksToMerge.put(component, res);
                                res.add(other);
                                blocksToMerge.put(other, res);
                            } else if (res == null) {
                                res = otherRes;
                                res.add(component);
                                blocksToMerge.put(component, res);
                            } else if (otherRes == null) {
                                res.add(other);
                                blocksToMerge.put(other, res);
                            } else if (res != otherRes) {
                                // We need to merge the two! We do this by repointing
                                // all to current res
                                res.addAll(otherRes);
                                for (C c : otherRes) {
                                    blocksToMerge.put(c, res);
                                }
                            } else {
                                // Do nothing, both are in res already!
                            }
                        }
                    }
                }
                return blocksToMerge;
            }

            /**
             * Merges components which needs to be in the same block.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<TarjanComponent<C>> mergeSubComponents(Collection<TarjanComponent<TarjanComponent<C>>> preBlocks2) {
                Collection<TarjanComponent<C>> components = new ArrayList<TarjanComponent<C>>();
                for (TarjanComponent<TarjanComponent<C>> preBlock2 : preBlocks2) {
                    Iterator<TarjanComponent<C>> it = preBlock2.iterator();
                    TarjanComponent<C> newComponent = it.next();
                    while (it.hasNext()) {
                        TarjanComponent<C> component = it.next();
                        newComponent.mergeWith(component);
                    }
                    
                    if (preBlock2.getMembers().size() > 1) {
                        
                    } else {
                    }
                    components.add(newComponent);
                }
                Collection<TarjanComponent<C>> newComponents = new ArrayList<TarjanComponent<C>>();
                for (TarjanComponent<C> component : components) {
                    if (component.getMembers().size() > 1) {
                        boolean containsNestedDiscrete = false;
                        for (C subComponent : component) {
                            if (subComponent.getMembers().size() == 1) {
                                continue;
                            }
                            for (E eqn : subComponent) {
                                if (!eqn.isMeta() && !eqn.getMatching().getVariable().isContinuous()) {
                                    // If the matched variable and in effect the
                                    // equation is discrete, then we need to
                                    // extract all sub-blocks into one block.
                                    containsNestedDiscrete = true;
                                    break;
                                }
                            }
                        }
                        if (containsNestedDiscrete) {
                            // Merge!
                            Iterator<C> it = component.iterator();
                            C newSubComponent = it.next();
                            while (it.hasNext()) {
                                C mergeComponent = it.next();
                                newSubComponent.mergeWith(mergeComponent);
                            }
                            TarjanComponent<C> newComponent = new TarjanComponent<C>();
                            newComponent.addPredecessors(component.getPredecessors());
                            newComponent.addMember(newSubComponent);
                            component = newComponent;
                        }
                    }
                    newComponents.add(component);
                }
                return newComponents;
            }

            private static class PreTarjan<C extends TarjanComponent<?>> extends SimpleTarjan<C> {

                private final Map<C, Collection<C>> predecessors;
                private final Map<C, Collection<C>> blocksToMerge;

                public PreTarjan(Map<C, Collection<C>> predecessors, Map<C, Collection<C>> blocksToMerge) {
                    this.predecessors = predecessors;
                    this.blocksToMerge = blocksToMerge;
                }

                @Override
                protected void addPredecessors(C n, Collection<C> predecessors) {
                    predecessors.addAll(this.predecessors.get(n));
                }

                @Override
                protected void forceIntoSame(C n, Collection<C> members) {
                    Collection<C> mergeList = blocksToMerge.get(n);
                    if (mergeList != null) {
                        members.addAll(mergeList);
                    }
                }
            }

            private static class PreSCCBlock<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> extends SCCBlock<E, V> {
                
                private final Collection<C> components = new ArrayList<C>();
                
                public PreSCCBlock(TarjanComponent<C> components) {
                    this.components.addAll(components.getMembers());
                    for (C component : components) {
                        for (E eqn : component) {
                            addMember(eqn);
                        }
                        addPredecessors(component.getPredecessors());
                    }
                }
                
                
//                @Override
//                public AbstractEquationBlock createEquationBlock(EquationBlockFactory.BlockProducer producer, OptionRegistry options, boolean isInitial) {
//                    Collection<AbstractEquationBlock> subBlocks = new ArrayList<AbstractEquationBlock>();
//                    for (C subComponent : components) {
//                        AbstractEquationBlock subBlock = subComponent.createEquationBlock(producer, options, isInitial);
//                        if (!subBlock.isSimple() && subBlock.discreteRealVariables_C().size() > 0) {
//                            throw new BLTException("...");
//                        }
//                        subBlocks.add(subBlock);
//                    }
//                    return new PrePropagationEquationBlock(producer, computeBlockDependency(), subBlocks);
//                }
            }
        }

    }
    
    private static <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>, T extends BLT>
    T EquationBlockFactory.computeBLTWithPreMerge(OptionRegistry options, BlockProducer producer, T blt,
            Collection<C> components) {
        Collection<TarjanComponent<C>> tarjanRes = AbstractBiPGraph.PRE_VARIABLE_CONTRIBUTOR.mergeComponents(components);
        for (TarjanComponent<C> block : tarjanRes) {
            if (block.getMembers().size() == 1) {
                blt.add(block.iterator().next().createEquationBlock(producer, options, false));
            } else {
                SCCBlock<E, V> aggr  = new SCCBlock<E, V>();
                for (C subBlock : block) {
                    for (E eqn : subBlock) {
                        aggr.addMember(eqn);
                    }
                    aggr.addPredecessors(subBlock.getPredecessors());
                }
                BiPGraph g = new BiPGraph(aggr.getMembers(), false);
                Collection<SCCBlock<Eq, Var>> sortedBlocks = g.tarjan(options, false);
                blt.add(new PrePropagationEquationBlock(producer, aggr.computeBlockDependency(), computeInnerBLT(options, producer, new BLT(), false, false, false, sortedBlocks)));
            }
        }
        return blt;
    }


    

}
