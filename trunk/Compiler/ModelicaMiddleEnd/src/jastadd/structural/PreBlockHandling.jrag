/*
    Copyright (C) 2016 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.jmodelica.util.tarjan.SimpleTarjan;
import org.jmodelica.util.tarjan.TarjanComponent;


aspect PreBlockHandling {

    public abstract class AbstractBiPGraph<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> {

        public static final PreVariableContributor PRE_VARIABLE_CONTRIBUTOR = new PreVariableContributor();

        /**
         * Contributor that ensures ensures the following:
         * - That discrete variables are bound with their pre variable uses.
         * - All equations which contains an event generating expression must
         *   be in the same block as all downstream equations which have a
         *   reference pre(x) where x is assigned by any of the equations on 
         *   the downstream path. 
         */
        private static class PreVariableContributor extends SCCContributor {

            /**
             * Merges equations which assign discrete variables with all
             * equations which references pre of the assigned variable.
             */
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> members(E equation, AbstractBiPGraph<E, V, ?> graph) {
                Collection<E> depends = Collections.emptyList();
                for (FVariable var : equation.getEquation().discretePreVariables()) {
                    FAbstractVariable nonPre = var.myNonPreVariable();
                    if (nonPre.isUnknown())
                        continue;
                    V v = graph.getVariable(nonPre.name());
                    if (v == null)
                        continue;
                    if (depends.isEmpty())
                        depends = new ArrayList<E>();
                    depends.add(v.getMatching());
                }
                if (!equation.isMeta()) {
                    V var = equation.getMatching();
                    FVariable fVar = var.getVariable();
                    if (fVar.isDiscrete()) {
                        FAbstractVariable preVar = fVar.myPreVariable();
                        for (FIdUseExp exp : preVar.uses()) {
                            FAbstractEquation fae = exp.myFEquation().outermostEnclosingEquation();
                            if (fae == null || fae.isPrePropagationEquation() != null)
                                continue;
                            Collection<E> eqns = graph.getEquations(fae);
                            if (eqns != null) {
                                if (depends.isEmpty())
                                    depends = new ArrayList<E>();
                                depends.addAll(eqns);
                            }
                        }
                    }
                }
                return depends;
            }
    
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> sameBlockMembers(E equation, AbstractBiPGraph<E, V, ?> graph) {
                return Collections.emptyList();
            }
    
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Map<E, Collection<? extends Object>> memberSets(E equation, AbstractBiPGraph<E, V, ?> graph) {
                return Collections.emptyMap();
            }
    
            /**
             * Ensures that event generating equations are merged with all
             * downstream equations which have pre references.
             */
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<C> mergeComponents(Collection<C> components, AbstractBiPGraph<E, V, ?> graph) {
                ASTNode.log.debug(components);
                Map<C, Collection<C>> predecessors = TarjanComponent.computePredecessorsMap(components);
                Map<C, Boolean> containsOrSucceedsEvents = computeContainsOrSucceedsEvents(components, predecessors);
                ASTNode.log.debug(containsOrSucceedsEvents);
                Map<C, Collection<C>> blocksToMerge = computeBlocksToMerge(components, predecessors,
                        containsOrSucceedsEvents, graph);
                ASTNode.log.debug(new LinkedHashSet<Collection<C>>(blocksToMerge.values()));
                Collection<C> newComponents = mergeComponents(components, predecessors, blocksToMerge);
                ASTNode.log.debug(newComponents);
                return newComponents;
            }

            /**
             * For each component, this method determines if it is event
             * generating of depends on event generating equations. 
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<C, Boolean> computeContainsOrSucceedsEvents(Collection<C> components, Map<C, Collection<C>> predecessors) {
                Map<C, Boolean> containsOrSucceedsEvents = new HashMap<C, Boolean>();
                for (C component : components) {
                    checkComponentForEventEqs(component, containsOrSucceedsEvents, predecessors);
                }
                return containsOrSucceedsEvents;
            }

            /**
             * Helper
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            boolean checkComponentForEventEqs(C component, Map<C, Boolean> containsOrSucceedsEventEq,
                    Map<C, Collection<C>> predecessors) {
                Boolean res = containsOrSucceedsEventEq.get(component);
                if (res != null) {
                    return res;
                }
                res = false;
                for (C predecessor : predecessors.get(component)) {
                    if (checkComponentForEventEqs(predecessor, containsOrSucceedsEventEq, predecessors)) {
                        res = true;
                        break;
                    }
                }
                if (!res) {
                    for (E eqn : component.getMembers()) {
                        if (eqn.getEquation().generatesEvents() || eqn.getEquation().isSampleEquation()) {
                            res = true;
                            break;
                        }
                    }
                }
                containsOrSucceedsEventEq.put(component, res);
                return res;
            }

            /**
             * Computes which components needs to be merged. The result
             * contains a map with an entry for each component that needs to be
             * merged. It maps to the collection of components thatn needs to
             * be merged.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<C, Collection<C>> computeBlocksToMerge(Collection<C> components, Map<C, Collection<C>> predecessors,
                    Map<C, Boolean> containsOrSucceedsEventEq, AbstractBiPGraph<E, V, ?> graph) {
                Map<C, Collection<C>> blocksToMerge = new HashMap<C, Collection<C>>();
                for (C component : components) {
                    computeBlocksToMerge(component, false, blocksToMerge, containsOrSucceedsEventEq, predecessors, graph);
                }
                Iterator<Map.Entry<C, Collection<C>>> it = blocksToMerge.entrySet().iterator();
                ASTNode.log.debug(new LinkedHashSet<Collection<C>>(blocksToMerge.values()));
                while (it.hasNext()) {
                    Map.Entry<C, Collection<C>> entry = it.next();
                    if (entry.getValue().size() <= 1) {
                        it.remove();
                    }
                }
                return blocksToMerge;
            }

            /**
             * Helper
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<C> computeBlocksToMerge(C component, boolean force, Map<C, Collection<C>> blocksToMerge,
                    Map<C, Boolean> containsOrSucceedsEvents, Map<C, Collection<C>> predecessors, AbstractBiPGraph<E, V, ?> graph) {
                if (!containsOrSucceedsEvents.get(component)) {
                    return Collections.emptyList();
                }
                Collection<C> res = blocksToMerge.get(component);
                if (res != null && (res.size() > 0 || !force)) {
                    return res;
                }
                res = null;
                boolean containsPre = containsActivePre(component, graph);
                if (containsPre || force) {
                    for (C predecessor : predecessors.get(component)) {
                        Collection<C> predecessorRes = computeBlocksToMerge(predecessor, true, blocksToMerge,
                                containsOrSucceedsEvents, predecessors, graph);
                        if (predecessorRes.isEmpty()) {
                            continue;
                        } else if (res == null) {
                            res = predecessorRes;
                        } else if (predecessorRes != res) {
                            // We need to merge the two! We do this by repointing
                            // all to current res
                            res.addAll(predecessorRes);
                            for (C c : predecessorRes) {
                                blocksToMerge.put(c, res);
                            }
                        }
                    }
                    if (res == null) {
                        // If no predecessor had any event generating equation,
                        // then res is null and we need to create a new list
                        res = new ArrayList<C>();
                    }
                    res.add(component);
                } else {
                    res = Collections.emptyList();
                }
                blocksToMerge.put(component, res);
                return res;
            }

            /**
             * Helper which determines if an equation contains an active pre
             * reference. It's active if the discrete variable is in the graph.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            boolean containsActivePre(C block, AbstractBiPGraph<E, V, ?> graph) {
                for (E eqn : block) {
                    for (FVariable var : eqn.getEquation().discretePreVariables()) {
                        FAbstractVariable nonPre = var.myNonPreVariable();
                        if (nonPre.isUnknown())
                            continue;
                        V v = graph.getVariable(nonPre.name());
                        if (v != null) {
                            return true;
                        }
                    }
                }
                return false;
            }

            /**
             * Merges components which needs to be in the same block. This is
             * done by calling tarjan.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<C> mergeComponents(Collection<C> components, Map<C, Collection<C>> predecessors,
                    Map<C, Collection<C>> blocksToMerge) {
                PreTarjan<E, V, C> t = new PreTarjan<E, V, C>(predecessors, blocksToMerge);
                Collection<TarjanComponent<C>> tarjanRes = t.tarjan(components);
                Collection<C> newComponents = new ArrayList<C>();
                for (TarjanComponent<C> component : tarjanRes) {
                    Iterator<C> it = component.iterator();
                    C newComponent = it.next();
                    while (it.hasNext()) {
                        C mergeComponent = it.next();
                        newComponent.mergeWith(mergeComponent);
                    }
                    newComponents.add(newComponent);
                }
                return newComponents;
            }

            private static class PreTarjan<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> extends SimpleTarjan<C> {

                private final Map<C, Collection<C>> predecessors;
                private final Map<C, Collection<C>> blocksToMerge;

                public PreTarjan(Map<C, Collection<C>> predecessors, Map<C, Collection<C>> blocksToMerge) {
                    this.predecessors = predecessors;
                    this.blocksToMerge = blocksToMerge;
                }

                @Override
                protected void addPredecessors(C n, Collection<C> predecessors) {
                    predecessors.addAll(this.predecessors.get(n));
                }

                @Override
                protected void forceIntoSame(C n, Collection<C> members) {
                    Collection<C> mergeList = blocksToMerge.get(n);
                    if (mergeList != null) {
                        members.addAll(mergeList);
                    }
                }
            }
        }

    }

}
