/*
    Copyright (C) 2016 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.jmodelica.util.tarjan.SimpleTarjan;
import org.jmodelica.util.tarjan.TarjanComponent;


aspect PreBlockHandling {

    public abstract class AbstractBiPGraph<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> {

        public static final PreVariableContributor PRE_VARIABLE_CONTRIBUTOR = new PreVariableContributor();

        /**
         * Contributor that ensures ensures the following:
         * - That discrete variables are bound with their pre variable uses.
         * - All equations which contains an event generating expression must
         *   be in the same block as all downstream equations which have a
         *   reference pre(x) where x is assigned by any of the equations on 
         *   the downstream path. 
         */
        public static class PreVariableContributor extends SCCContributor {

            /**
             * Merges equations which assign discrete variables with all
             * equations which references pre of the assigned variable.
             */
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> members(E equation, AbstractBiPGraph<E, V, ?> graph) {
                Collection<E> depends = Collections.emptyList();
//                for (FVariable var : equation.getEquation().discretePreVariables()) {
//                    FAbstractVariable nonPre = var.myNonPreVariable();
//                    if (nonPre.isUnknown())
//                        continue;
//                    V v = graph.getVariable(nonPre.name());
//                    if (v == null)
//                        continue;
//                    if (depends.isEmpty())
//                        depends = new ArrayList<E>();
//                    depends.add(v.getMatching());
//                }
//                if (!equation.isMeta()) {
//                    V var = equation.getMatching();
//                    FVariable fVar = var.getVariable();
//                    if (fVar.isDiscrete()) {
//                        FAbstractVariable preVar = fVar.myPreVariable();
//                        for (FIdUseExp exp : preVar.uses()) {
//                            FAbstractEquation fae = exp.myFEquation().outermostEnclosingEquation();
//                            if (fae == null || fae.isPrePropagationEquation() != null)
//                                continue;
//                            Collection<E> eqns = graph.getEquations(fae);
//                            if (eqns != null) {
//                                if (depends.isEmpty())
//                                    depends = new ArrayList<E>();
//                                depends.addAll(eqns);
//                            }
//                        }
//                    }
//                }
                return depends;
            }
    
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> sameBlockMembers(E equation, AbstractBiPGraph<E, V, ?> graph) {
                return Collections.emptyList();
            }
    
            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Map<E, Collection<? extends Object>> memberSets(E equation, AbstractBiPGraph<E, V, ?> graph) {
                return Collections.emptyMap();
            }
    
            /**
             * Ensures that event generating equations are merged with all
             * downstream equations which have pre references.
             */
//            @Override
            public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<TarjanComponent<C>> mergeComponents(Collection<C> components) {
                // Compute variable to block map
                Map<FAbstractVariable, C> varToBlockMap = computeVarToBlockMap(components);
                // Compute predecessors
                Map<C, Collection<C>> predecessors = TarjanComponent.computePredecessorsMap(components);
                // Propagate event info
                Map<C, Boolean> containsOrSucceedsEvents = computeContainsOrSucceedsEvents(components, predecessors);
                // Add link between discrete variables and their pre usages
                Map<C, Collection<C>> linkedDeclAndPres = linkVarDeclAndPreUse(components, varToBlockMap);
                // Find blocks which needs to be merged
                Map<C, Collection<C>> blocksToMerge = computeBlocksToMerge(components, predecessors,
                        containsOrSucceedsEvents, varToBlockMap, linkedDeclAndPres);
                for (Map.Entry<C, Collection<C>> declAndPres : linkedDeclAndPres.entrySet()) {
                    if (!blocksToMerge.containsKey(declAndPres.getKey())) {
                        blocksToMerge.put(declAndPres.getKey(), declAndPres.getValue());
                    }
                }
                PreTarjan<E, V, C> t = new PreTarjan<E, V, C>(predecessors, blocksToMerge);
                Collection<TarjanComponent<C>> preBlocks = t.tarjan(components);
                preBlocks = mergeSubComponents(preBlocks);
                return  preBlocks;
            }
            
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<FAbstractVariable, C> computeVarToBlockMap(Collection<C> components) {
                Map<FAbstractVariable, C> res = new HashMap<FAbstractVariable, C>();
                for (C component : components) {
                    for (E eqn : component) {
                        if (eqn.isMeta()) {
                            continue;
                        }
                        res.put(eqn.getMatching().getVariable(), component);
                    }
                }
                return res;
            }

            /**
             * For each component, this method determines if it is event
             * generating of depends on event generating equations. 
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<C, Boolean> computeContainsOrSucceedsEvents(Collection<C> components, Map<C, Collection<C>> predecessors) {
                Map<C, Boolean> containsOrSucceedsEvents = new HashMap<C, Boolean>();
                for (C component : components) {
                    checkComponentForEventEqs(component, containsOrSucceedsEvents, predecessors);
                }
                return containsOrSucceedsEvents;
            }

            /**
             * Helper
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            boolean checkComponentForEventEqs(C component, Map<C, Boolean> containsOrSucceedsEventEq,
                    Map<C, Collection<C>> predecessors) {
                Boolean res = containsOrSucceedsEventEq.get(component);
                if (res != null) {
                    return res;
                }
                res = false;
                for (C predecessor : predecessors.get(component)) {
                    if (checkComponentForEventEqs(predecessor, containsOrSucceedsEventEq, predecessors)) {
                        res = true;
                        break;
                    }
                }
                if (!res) {
                    for (E eqn : component.getMembers()) {
                        if (eqn.getEquation().generatesEvents() || eqn.getEquation().isSampleEquation()) {
                            res = true;
                            break;
                        }
                    }
                }
                containsOrSucceedsEventEq.put(component, res);
                return res;
            }

            /**
             * Computes which components needs to be merged. The result
             * contains a map with an entry for each component that needs to be
             * merged. It maps to the collection of components thatn needs to
             * be merged.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<C, Collection<C>> computeBlocksToMerge(Collection<C> components, Map<C, Collection<C>> predecessors,
                    Map<C, Boolean> containsOrSucceedsEventEq, Map<FAbstractVariable, C> varToBlockMap,
                    Map<C, Collection<C>> linkedDeclAndPres) {
                Map<C, Collection<C>> blocksToMerge = new HashMap<C, Collection<C>>();
                for (C component : components) {
                    computeBlocksToMerge(component, false, blocksToMerge, containsOrSucceedsEventEq, predecessors,
                            varToBlockMap, linkedDeclAndPres);
                }
                Iterator<Map.Entry<C, Collection<C>>> it = blocksToMerge.entrySet().iterator();
                ASTNode.log.debug(new LinkedHashSet<Collection<C>>(blocksToMerge.values()));
                while (it.hasNext()) {
                    Map.Entry<C, Collection<C>> entry = it.next();
                    if (entry.getValue().size() <= 1) {
                        it.remove();
                    }
                }
                return blocksToMerge;
            }

            /**
             * Helper
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<C> computeBlocksToMerge(C component, boolean force, Map<C, Collection<C>> blocksToMerge,
                    Map<C, Boolean> containsOrSucceedsEvents, Map<C, Collection<C>> predecessors,
                    Map<FAbstractVariable, C> varToBlockMap, Map<C, Collection<C>> linkedDeclAndPres) {
                if (!containsOrSucceedsEvents.get(component)) {
                    return Collections.emptyList();
                }
                Collection<C> res = blocksToMerge.get(component);
                if (res != null && (res.size() > 0 || !force)) {
                    return res;
                }
                res = null;
                boolean containsPre = containsActivePre(component, varToBlockMap);
                if (containsPre || force) {
                    Collection<C> cPredecessors;
                    Collection<C> declAndPres = linkedDeclAndPres.get(component);
                    if (declAndPres != null) {
                        cPredecessors = new LinkedHashSet<C>();
                        cPredecessors.addAll(predecessors.get(component));
                        for (C member : declAndPres) {
                            cPredecessors.addAll(predecessors.get(member));
                        }
                        cPredecessors.removeAll(declAndPres);
                    } else {
                        cPredecessors = predecessors.get(component);
                    }
                    
                    for (C predecessor : cPredecessors) {
                        Collection<C> predecessorRes = computeBlocksToMerge(predecessor, true, blocksToMerge,
                                containsOrSucceedsEvents, predecessors, varToBlockMap, linkedDeclAndPres);
                        if (predecessorRes.isEmpty()) {
                            continue;
                        } else if (res == null) {
                            res = predecessorRes;
                        } else if (predecessorRes != res) {
                            // We need to merge the two! We do this by repointing
                            // all to current res
                            res.addAll(predecessorRes);
                            for (C c : predecessorRes) {
                                blocksToMerge.put(c, res);
                            }
                        }
                    }
                    if (res == null) {
                        // If no predecessor had any event generating equation,
                        // then res is null and we need to create a new list
                        res = new ArrayList<C>();
                    }
                    res.add(component);
                    if (declAndPres != null) {
                        for (C member : declAndPres) {
                            if (!res.contains(member)) {
                                res.add(member);
                                blocksToMerge.put(member, res);
                            }
                        }
                    }
                } else {
                    res = Collections.emptyList();
                }
                blocksToMerge.put(component, res);
                return res;
            }

            /**
             * Helper which determines if an equation contains an active pre
             * reference. It's active if the discrete variable is in the graph.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            boolean containsActivePre(C block, Map<FAbstractVariable, C> varToBlockMap) {
                for (E eqn : block) {
                    for (FVariable var : eqn.getEquation().discretePreVariables()) {
                        FAbstractVariable nonPre = var.myNonPreVariable();
                        if (varToBlockMap.get(nonPre) != null) {
                            return true;
                        }
                    }
                }
                return false;
            }

            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Map<C, Collection<C>> linkVarDeclAndPreUse(Collection<C> components,
                    Map<FAbstractVariable, C> varToBlockMap) {
                Map<C, Collection<C>> blocksToMerge = new HashMap<C, Collection<C>>();
//                Map<E, C> eqnToBlockMap = new HashMap<E, C>();
//                for (C component : components) {
//                    for (E eqn : component) {
//                        eqnToBlockMap.put(eqn, component);
//                    }
//                }
                for (C component : components) {
                    Collection<C> res = blocksToMerge.get(component);
                    for (E eqn : component) {
                        for (FVariable var : eqn.getEquation().discretePreVariables()) {
                            FAbstractVariable nonPre = var.myNonPreVariable();
//                            if (nonPre.isUnknown())
//                                continue;
//                            V v = graph.getVariable(nonPre.name());
//                            if (v == null)
//                                continue;
//                            E otherEqn = v.getMatching();
                            C other = varToBlockMap.get(nonPre);//eqnToBlockMap.get(otherEqn);
                            Collection<C> otherRes = blocksToMerge.get(other);
                            if (res == null && otherRes == null) {
                                res = new ArrayList<C>();
                                res.add(component);
                                blocksToMerge.put(component, res);
                                res.add(other);
                                blocksToMerge.put(other, res);
                            } else if (res == null) {
                                res = otherRes;
                                res.add(component);
                                blocksToMerge.put(component, res);
                            } else if (otherRes == null) {
                                res.add(other);
                                blocksToMerge.put(other, res);
                            } else if (res != otherRes) {
                                // We need to merge the two! We do this by repointing
                                // all to current res
                                res.addAll(otherRes);
                                for (C c : otherRes) {
                                    blocksToMerge.put(c, res);
                                }
                            } else {
                                // Do nothing, both are in res already!
                            }
                        }
                    }
                }
                return blocksToMerge;
            }

            /**
             * Merges components which needs to be in the same block.
             */
            private <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>>
            Collection<TarjanComponent<C>> mergeSubComponents(Collection<TarjanComponent<C>> components) {
                Collection<TarjanComponent<C>> newComponents = new ArrayList<TarjanComponent<C>>();
                for (TarjanComponent<C> component : components) {
                    if (component.getMembers().size() > 1) {
                        boolean containsNestedDiscrete = false;
                        for (C subComponent : component) {
                            if (subComponent.getMembers().size() == 1) {
                                continue;
                            }
                            for (E eqn : subComponent) {
                                if (!eqn.isMeta() && !eqn.getMatching().getVariable().isReal()) {
                                    // Yes this is a strange way to check if it
                                    // is real, but this is how it is done in
                                    // other parts of the BLT/graph parts.
                                    containsNestedDiscrete = true;
                                    break;
                                }
                            }
                        }
                        if (containsNestedDiscrete) {
                            // Merge!
                            Iterator<C> it = component.iterator();
                            C newSubComponent = it.next();
                            while (it.hasNext()) {
                                C mergeComponent = it.next();
                                newSubComponent.mergeWith(mergeComponent);
                            }
                            TarjanComponent<C> newComponent = new TarjanComponent<C>();
                            newComponent.addPredecessors(component.getPredecessors());
                            newComponent.addMember(newSubComponent);
                            component = newComponent;
                        }
                    }
                    newComponents.add(component);
                }
                return newComponents;
            }

            private static class PreTarjan<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> extends SimpleTarjan<C> {

                private final Map<C, Collection<C>> predecessors;
                private final Map<C, Collection<C>> blocksToMerge;

                public PreTarjan(Map<C, Collection<C>> predecessors, Map<C, Collection<C>> blocksToMerge) {
                    this.predecessors = predecessors;
                    this.blocksToMerge = blocksToMerge;
                }

                @Override
                protected void addPredecessors(C n, Collection<C> predecessors) {
                    predecessors.addAll(this.predecessors.get(n));
                }

                @Override
                protected void forceIntoSame(C n, Collection<C> members) {
                    Collection<C> mergeList = blocksToMerge.get(n);
                    if (mergeList != null) {
                        members.addAll(mergeList);
                    }
                }
            }

            private static class PreSCCBlock<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> extends SCCBlock<E, V> {
                
                private final Collection<C> components = new ArrayList<C>();
                
                public PreSCCBlock(TarjanComponent<C> components) {
                    this.components.addAll(components.getMembers());
                    for (C component : components) {
                        for (E eqn : component) {
                            addMember(eqn);
                        }
                        addPredecessors(component.getPredecessors());
                    }
                }
                
                
//                @Override
//                public AbstractEquationBlock createEquationBlock(EquationBlockFactory.BlockProducer producer, OptionRegistry options, boolean isInitial) {
//                    Collection<AbstractEquationBlock> subBlocks = new ArrayList<AbstractEquationBlock>();
//                    for (C subComponent : components) {
//                        AbstractEquationBlock subBlock = subComponent.createEquationBlock(producer, options, isInitial);
//                        if (!subBlock.isSimple() && subBlock.discreteRealVariables_C().size() > 0) {
//                            throw new BLTException("...");
//                        }
//                        subBlocks.add(subBlock);
//                    }
//                    return new PrePropagationEquationBlock(producer, computeBlockDependency(), subBlocks);
//                }
            }
        }

    }
    
    private static <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>, T extends BLT>
    T EquationBlockFactory.computeBLTWithPreMerge(OptionRegistry options, BlockProducer producer, T blt,
            Collection<C> components) {
        Collection<TarjanComponent<C>> tarjanRes = AbstractBiPGraph.PRE_VARIABLE_CONTRIBUTOR.mergeComponents(components);
        for (TarjanComponent<C> block : tarjanRes) {
            if (block.getMembers().size() == 1) {
                blt.add(block.iterator().next().createEquationBlock(producer, options, false));
            } else {
                SCCBlock<E, V> aggr  = new SCCBlock<E, V>();
                for (C subBlock : block) {
                    for (E eqn : subBlock) {
                        aggr.addMember(eqn);
                    }
                    aggr.addPredecessors(subBlock.getPredecessors());
                }
                BiPGraph g = new BiPGraph(aggr.getMembers(), false);
                Collection<SCCBlock<Eq, Var>> sortedBlocks = g.tarjan(options, false);
                blt.add(new PrePropagationEquationBlock(producer, aggr.computeBlockDependency(), computeBLT(options, producer, new BLT(), false, false, false, sortedBlocks)));
            }
        }
        return blt;
    }


    

}
