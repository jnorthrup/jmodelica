import java.util.Collections;

/*
    Copyright (C) 2009-2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect OverdeterminedInitialSystem {
    
    public abstract class AbstractBiPGraph{
        /**
         * Goes through the list of unmatched equations and tries to determine
         * if it is redundant. Al list of equations that should be removed is
         * returned if all unmatched equations are found to be redundent.
         */
        public Set<FAbstractEquation> overdeterminedInitialSystem() {
            ASTNode.log.info("Analysing initial system for redundant equations to remove.");
            OISVariableEvaluator evaluator = new OISVariableEvaluator();
            boolean allIsGood = true;
            for (E eqn : unmatchedEquationsIterable()) {
                ASTNode.log.info("Checking unmatched equation %s", eqn);
                FAbstractEquation equation = eqn.getEquation();
                if (!equation.isInitial()) {
                    ASTNode.log.info("  Not an initial equation");
                    allIsGood = false;
                } else if (eqn.getEquation().OIS_consistencyCheck(evaluator)) {
                    ASTNode.log.info("  Consistent");
                } else {
                    allIsGood = false;
                    ASTNode.log.info("  Unable to verify or different values were calculated");
                }
            }
            if (!allIsGood) {
                ASTNode.log.info("Unable to verify all unmatched initial equations");
                return Collections.emptySet();
            }
            Set<FAbstractEquation> results = new HashSet<FAbstractEquation>();
            ASTNode.log.info("All seems to be ok, removing:");
            for (E eqn : unmatchedEquationsIterable()) {
                ASTNode.log.info("  %s", eqn);
                results.add(eqn.getEquation());
                removeEquation(eqn);
            }
            return results;
        }
        
        /**
         * Variable evaluator that is used during analyse of overdetermined
         * initial system.
         */
        public class OISVariableEvaluator implements VariableEvaluator {
            
            private Set<CommonVariableDecl> evaluationStack = new HashSet<CommonVariableDecl>();
            private Map<CommonVariableDecl, CValue> evaluationCache = new LinkedHashMap<CommonVariableDecl, CValue>();
            
            @Override
            public CValue ceval(CommonVariableDecl variable) {
                ASTNode.log.info(variable.name());
                CValue val = evaluationCache.get(variable);
                if (val != null)
                    return val;
                if (evaluationStack.contains(variable)) {
                    val = CValue.UNKNOWN;
                } else {
                    try {
                        evaluationStack.add(variable);
                        V var = getVariable(variable.name());
                        if (var == null) {
                            val = CValue.UNKNOWN;
                        } else {
                            val = var.OIS_ceval(this);
                        }
                    } catch (ConstantEvaluationException e) {
                        val = CValue.UNKNOWN;
                    } finally {
                        evaluationStack.remove(variable);
                    }
                }
                evaluationCache.put(variable, val);
                return val;
            }
            
            @Override
            public CValue ceval(CommonVariableDecl variable, Index i) {
                return CValue.UNKNOWN;
            }
        }
    }
    
    public abstract class AbstractVar {
        /**
         * Used for evaluation of variables during analyse of overdetermined
         * initial system.
         */
        public CValue OIS_ceval(VariableEvaluator evaluator) {
            if (getMatching() == null)
                return CValue.UNKNOWN;
            return getMatching().getEquation().OIS_ceval(evaluator, getVariable());
        }
    }
    
    /**
     * Used for evaluation of equations during analyse of overdetermined
     * initial system.
     * Tries to solve and determine the value of the provided variable.
     * Returns CValue.UNKNOWN or exception on failure.
     */
    syn CValue FAbstractEquation.OIS_ceval(VariableEvaluator evaluator, FVariable var) = CValue.UNKNOWN;
    eq FEquation.OIS_ceval(VariableEvaluator evaluator, FVariable var) = solution(var).ceval(evaluator);
    
    /**
     * Used for evaluation of equations during analyse of overdetermined
     * initial system.
     * Tries to validate the equation and ensuring that the left hand side is
     * equal to the right hand side.
     */
    syn boolean FAbstractEquation.OIS_consistencyCheck(VariableEvaluator evaluator) = false;
    eq FEquation.OIS_consistencyCheck(VariableEvaluator evaluator) {
        try {
            CValue left = getLeft().ceval(evaluator);
            CValue right = getRight().ceval(evaluator);
            return type().equ(left, right).booleanValue();
        } catch (ConstantEvaluationException e) {
            return false;
        }
    }
    
}