/*
    Copyright (C) 2009-2017 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//import java.util.ArrayDeque;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Queue;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Collections;
import java.util.Iterator;

import org.jmodelica.util.collections.ListMap;
import org.jmodelica.util.collections.LinkedHashListMap;
import org.jmodelica.util.ErrorCheckType;
import org.jmodelica.util.munkres.DenseMunkresProblem;
import org.jmodelica.util.munkres.IntegerCost;


/* This causes conflicts
import org.jmodelica.graphs.EquationSystem;
import org.jmodelica.graphs.Equation;
import org.jmodelica.graphs.Variable;
*/

/**
 * Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

    /**
     * Transform the raw flattened model into a structured form.
     * 
     * Currently, the following operations are performed:
     *  <ul>
     *    <li> Binding equations for variables are converted into regular
     *         equations by calling genBindingEquations().
     *    <li> For each non-function algorithm:
     *         <ul>
     *                any assigned variables as outputs and any used 
     *                variables as inputs.
     *           <li> The original algorithm is replaced with a call to 
     *                the generated function.
     *         </ul>
     *    <li> The model is scalarized, i.e., all array declarations and
     *         equations are replaced by scalar declarations and equations
     *    <li> Alias variables are eliminated from the model.
     *    <li> Derivative variables are generated and inserted in the
     *         list of FVariables by calling setFDerivativeVariables().
     *    <li> Generate initial equations based on start attribute.
     *    <li> Sort dependent parameters.
     *  </ul>
     */

    /**
     *  transformCanonicalBase contains all transformation that should be
     *  done by both the Modelica and the Optimica compilers.
     */
    public void FClass.transformCanonicalBase() {
        for (Transformation t : getTransformations()) {
            t.apply();
        }
    }

    public void FClass.transformCanonicalCleanup() {
        removeUnusedFunctionsAndRecords();
        root().flushAllRecursive();
        for (FRecordDecl rec : getFRecordDecls())
            rec.clearBindingEquations();
    }
    
    public class FClass {
        
        /**
         * List that contains all transformations that has been registered.
         * This list is initialized by setupTransformations()
         */
        private java.util.List<Transformation> transformations;
        
        /**
         * Method that initializes the transformations list. This method should
         * called before each operation on the list. Internal check prevents
         * multiple initializations.
         */
        private void setupTransformations() {
            if (transformations != null)
                return;
            transformations = new ArrayList<Transformation>();
            transformations.add(new enableIfEquationElimination());
            transformations.add(new genAlgorithmFunctionsIfSet());
            transformations.add(new genInitArrayStatements());
            transformations.add(new scalarize());
            transformations.add(new MakeReinitedVarsStates());
            transformations.add(new enableIfEquationElimination());
            transformations.add(new enableStreamsRewrite());
            transformations.add(new ExtractEventGeneratingExpressions());
            transformations.add(new GenerateEventIndicators());
            transformations.add(new convertWhenToIf());
            transformations.add(new FunctionInliningIfSet());
            transformations.add(new setFDerivativeVariables());
            transformations.add(new addFPreVariables());
            transformations.add(new enableIfEquationRewrite());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new variabilityPropagationIfSet());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new eliminateLinearEquations());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new enableExpandedInStreamRewrite());
            transformations.add(new evaluateAsserts());
            transformations.add(new enableSemiLinearRewrite());
            transformations.add(new eliminateEqualSwitches());
            transformations.add(new genInitialEquations());
            transformations.add(new addStateInitialEquationsIfSet());
            transformations.add(new setFDerivativeVariablesPreBLT());
            transformations.add(new indexReduction());
            transformations.add(new LateFunctionInliningIfSet());
            transformations.add(new commonSubexpressionEliminationIfSet());
            transformations.add(new addFPreVariables());
            transformations.add(new aliasEliminationIfSet());
            transformations.add(new eliminateLinearEquations());
            transformations.add(new sortDependentParameters());
            transformations.add(new addRuntimeOptionParameters());
            transformations.add(new computeMatchingsAndBLT());
        }

        /**
         * This method returns the list of transformations. This method should
         * be used when retreiving the list of transformations since it ensures
         * that the list is initialized.
         */
        private Collection<Transformation> getTransformations() {
            setupTransformations();
            return transformations;
        }

        /**
         * Adds a transformation to the list of transformations. The
         * transformation is added after each occurance of <code>after<code>.
         * The transformation is not added if no occurances of 
         * <code>after<code> is found.
         */
        private <T extends Transformation> T addTransformationAfter(T transformation, String after) {
            setupTransformations();
            ListIterator<Transformation> it = transformations.listIterator();
            while (it.hasNext()) {
                Transformation other = it.next();
                if (other.name().equals(after))
                    it.add(transformation);
            }
            return transformation;
        }

        /**
         * Base class for transformations on the flat tree.
         */
        public abstract class Transformation {

            private String option;

            /**
             * Create a transformation with default settings:
             * <ul>
             * <li>Not coupled to a compiler option.</li>
             * </ul>
             */
            public Transformation() {
                this(null);
            }

            /**
             * Create a transformation with specific settings.
             * 
             * @param option  boolean option the transfomation depends on (null for none)
             */
            public Transformation(String option) {
                this.option = option;
            }

            /**
             * Perform the transformation.
             */
            public abstract void perform();

            /**
             * Determine if this transformation should be perfomed.
             * 
             * Defaults to true if this transformation does not depend on an option or the option is true.
             */
            public boolean active() {
                return (option == null) || myOptions().getBooleanOption(option);
            }

            /**
             * The name of this transformation.
             * 
             * Defaults to the name of the class.
             */
            public String name() {
                return getClass().getSimpleName();
            }

            /**
             * Apply this transformation, if active.
             * 
             * Subclasses should not override this method.
             */
            public void apply() {
                if (active()) {
                    try {
                        beginStep(name());
                        log.info("Applying transformation: " + name() + "...");
                        perform();
                    } finally {
                        completedTransformationSteps++;
                        lastCompletedTransformationStep = name();
                        endStep(name());
                    }
                    transformationStepDebug();
                }
            }

            /**
             * Flushes tree and discards calculated information.
             * 
             * Call this method at the end of perform() if it changed the tree.
             */
            void change() {
                setDAEBLT(BLT.EMPTY_BLT);
                setDAEInitBLT(BLT.EMPTY_BLT);
                DAEBiPGraph = null;
                root().flushAllRecursiveClearFinal();
            }
            
            @Override
            public String toString() {
                return getClass().getSimpleName() + ", operating on:\n\n" + FClass.this;
            }
        }

    }

    /**
     * Perform transformation step debug operations that are activated.
     */
    public void FClass.transformationStepDebug() {
        generateStepMof();
        sanityCheck();
    }

    /**
     * Generate a .mof file with the current flat tree.
     */
    public void FClass.generateStepMof() {
        String value = myOptions().getStringOption("debug_transformation_steps");
        if ("full".equals(value)) {
            TRANSFORMATION_STEP_DIR.mkdir();
            TRANSFORMATION_STEP_HTML_DIR.mkdir();
            String fileName = String.format("%02d_%s.mof", completedTransformationSteps, lastCompletedTransformationStep);
            String htmlFileName = String.format("%02d_%s.html", completedTransformationSteps, lastCompletedTransformationStep);
            File file = new File(TRANSFORMATION_STEP_DIR, fileName);
            File htmlFile = new File(TRANSFORMATION_STEP_HTML_DIR, htmlFileName);
            log.debug("Writing flat tree after step " + lastCompletedTransformationStep + " to " + fileName);
            try {
                CodeStream out = new CodeStream(file);
                CodeStream htmlOut = new CodeStream(htmlFile);
                sourcePrettyPrint(out, "");
                htmlSourcePrettyPrint(htmlOut, "");
                out.close();
                htmlOut.close();
            } catch (IOException e) {
                log.warning("Failed to write step info to file " + file);
            }
        }
        if ("full".equals(value) || "diag".equals(value)) {
            TRANSFORMATION_STEP_DIR.mkdir();
            String fileName = String.format("%02d_%s.txt", completedTransformationSteps, lastCompletedTransformationStep);
            File file = new File(TRANSFORMATION_STEP_DIR, fileName);
            log.debug("Writing diag after step " + lastCompletedTransformationStep + " to " + fileName);
            try {
                CodeStream out = new CodeStream(file);
                out.print(modelDiagnostics());
                out.close();
            } catch (IOException e) {
                log.warning("Failed to write step info to file " + file);
            }
            root().flushAllRecursiveClearFinal();
        }
    }
    
    private static final File FClass.TRANSFORMATION_STEP_DIR = new File("transformation_steps");
    private static final File FClass.TRANSFORMATION_STEP_HTML_DIR = new File("transformation_steps_html");

    private int FClass.completedTransformationSteps = 0;
    private String FClass.lastCompletedTransformationStep = "flattening";

	/**
	 * After scalarization, binding expressions on members of record declarations are no longer needed. 
	 */
	public void FRecordDecl.clearBindingEquations() {
		for (FVariable fv : getFVariables())
		    if (fv.modifiableInRecord)
		        fv.setBindingExpOpt(new Opt());
	}

    protected boolean FClass.doneTransformCanonical = false;
    
    public void FClass.transformCanonical() {
        if (doneTransformCanonical)
            return;
        doneTransformCanonical = true;
        beginStep("transformCanonical()");

        transformCanonicalBase();
        

        root().flushAllRecursive();	
        transformCanonicalCleanup();
        getDAEBLT().errorCheck(this);
        getDAEInitBLT().errorCheck(this);

        endStep("transformCanonical()");
    }

    syn lazy Set<FVariable> FVariable.initDependsOn() {
        if (myDAEInitEquationBlock() != null)
            return myDAEInitEquationBlock().dependsOn();
        else
            return new LinkedHashSet<FVariable>();
    }

    syn lazy Set<FVariable> FVariable.dependsOn() {
        if (myDAEEquationBlock() != null)
            return myDAEEquationBlock().dependsOn();
        else
            return new LinkedHashSet<FVariable>();
    }

    syn lazy AbstractEquationBlock FVariable.myDAEEquationBlock() =
            myFClass().getDAEFVariableEquationBlockMap().get(this);

    private HashMap<FVariable, AbstractEquationBlock> FClass.daeFVariableEquationBlockMap =
            new HashMap<FVariable, AbstractEquationBlock>();

    syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEFVariableEquationBlockMap() {
        transformCanonical();
        return daeFVariableEquationBlockMap;
    }

    private HashMap<FAbstractEquation, AbstractEquationBlock> FClass.daeEquationEquationBlockMap =
            new HashMap<FAbstractEquation, AbstractEquationBlock>();

    syn HashMap<FAbstractEquation,AbstractEquationBlock> FClass.getDAEFEquationEquationBlockMap() {
        transformCanonical();
        return daeEquationEquationBlockMap;
    }

    syn lazy AbstractEquationBlock FVariable.myDAEInitEquationBlock() = 
            myFClass().getDAEInitFVariableEquationBlockMap().get(this);

    private HashMap<FVariable,AbstractEquationBlock> FClass.daeInitFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();
    syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEInitFVariableEquationBlockMap() {
        transformCanonical();
        return daeInitFVariableEquationBlockMap;
    }

    private HashMap<FAbstractEquation,AbstractEquationBlock> FClass.daeInitEquationEquationBlockMap = new HashMap<FAbstractEquation,AbstractEquationBlock>();
    syn HashMap<FAbstractEquation,AbstractEquationBlock> FClass.getDAEInitEquationEquationBlockMap() {
        transformCanonical();
        return daeInitEquationEquationBlockMap;
    }

    private ArrayList<FAbstractEquation> FClass.daeUnmatchedEquations = new ArrayList<FAbstractEquation>();
    syn ArrayList<FAbstractEquation> FClass.getDAEUnmatchedEquations() {
        transformCanonical();
        return daeUnmatchedEquations;
    }

    private ArrayList<FVariable> FClass.daeUnmatchedVariables = new ArrayList<FVariable>();
    syn ArrayList<FVariable> FClass.getDAEUnmatchedVariables() {
        transformCanonical();
        return daeUnmatchedVariables;
    }

    private ArrayList<FAbstractEquation> FClass.daeInitUnmatchedEquations = new ArrayList<FAbstractEquation>();
    syn ArrayList<FAbstractEquation> FClass.getDAEInitUnmatchedEquations() {
        transformCanonical();
        return daeInitUnmatchedEquations;
    }

    private ArrayList<FVariable> FClass.daeInitUnmatchedVariables = new ArrayList<FVariable>();
    syn ArrayList<FVariable> FClass.getDAEInitUnmatchedVariables() {
        transformCanonical();
        return daeInitUnmatchedVariables;
    }

    private BLT FClass.daeBLT = BLT.EMPTY_BLT;
    public BLT FClass.getDAEBLT() {
        transformCanonical();
        return daeBLT;
    }
    
    public void FClass.setDAEBLT(BLT newBLT) {
        daeBLT = newBLT;
        daeFVariableEquationBlockMap = new HashMap<FVariable, AbstractEquationBlock>();
        daeEquationEquationBlockMap = new HashMap<FAbstractEquation, AbstractEquationBlock>();

        for (AbstractEquationBlock eb : daeBLT) {
            for (FVariable fv : eb.allVariables()) {
                daeFVariableEquationBlockMap.put(fv,eb);
            }

            for (FAbstractEquation equation : eb.allEquations()) {
            	daeEquationEquationBlockMap.put(equation, eb);
            }
        }

        if (newBLT == BLT.EMPTY_BLT)
            daeStructuredBLT = BLT.EMPTY_BLT;
        else
            daeStructuredBLT = new StructuredBLT(this, daeBLT);
    }

    private StructuredBLT FClass.daeStructuredBLT = BLT.EMPTY_BLT;

    public StructuredBLT FClass.getDAEStructuredBLT() {
        transformCanonical();
        return daeStructuredBLT;
    }

    private BLT FClass.daeInitBLT = BLT.EMPTY_BLT;

    public BLT FClass.getDAEInitBLT() {
        transformCanonical();
        return daeInitBLT;
    }

    public void FClass.setDAEInitBLT(BLT newBLT) {
        daeInitBLT = newBLT;
        daeInitFVariableEquationBlockMap = new HashMap<FVariable, AbstractEquationBlock>();
        daeInitEquationEquationBlockMap = new HashMap<FAbstractEquation, AbstractEquationBlock>();

        for (AbstractEquationBlock eb : daeInitBLT) {
            for (FVariable fv : eb.allVariables()) {
                daeInitFVariableEquationBlockMap.put(fv,eb);
            }

            for (FAbstractEquation equation : eb.allEquations()) {
                daeInitEquationEquationBlockMap.put(equation, eb);
            }
        }
        daeInitBLT.computeDependencies();
    }

    syn boolean FClass.onlyInitBLT() = getDAEBLT() == BLT.EMPTY_BLT && getDAEInitBLT() != BLT.EMPTY_BLT;

    syn boolean FClass.shouldPerformMatchingsAndBLT() = true;

    public class FClass {
        /**
         * Run matchings and BLT.
         */
        public class computeMatchingsAndBLT extends Transformation {
            public computeMatchingsAndBLT() {
                super("automatic_add_initial_equations");
            }

            @Override
            public boolean active() {
                return super.active() && shouldPerformMatchingsAndBLT();
            }

            @Override
            public void perform() {
                computeMatchingsAndBLT();
                complianceCheckBLT();
                breakOnErrors();
            }
        }
    }
    
    public void FClass.complianceCheckBLT() {
        getDAEBLT().complianceCheck(ErrorCheckType.COMPILE, myOptions());
        getDAEInitBLT().complianceCheck(ErrorCheckType.COMPILE, myOptions());
    }
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_NORMAL = 
            EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
                    BiPGraph.VarType.ALGEBRAIC_VARIABLES);
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_REAL = 
            EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
                    BiPGraph.VarType.CONTINUOUS_ALGEBRAIC_VARIABLES);
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_INIT = 
            EnumSet.of(BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
                    BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
                    BiPGraph.VarType.NON_FIXED_PARAMETERS);
    
    private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_ALL = 
            EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
                    BiPGraph.VarType.ALGEBRAIC_VARIABLES, 
                    BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
                    BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
                    BiPGraph.VarType.NON_FIXED_PARAMETERS);
    
    private BiPGraph FClass.computeMatchedDAEBiPGraph() {
        BiPGraph g = new BiPGraph();
        g.addVariables(this, VAR_TYPES_NORMAL);
        g.addEquations(equations(), VAR_TYPES_NORMAL);
        g.maximumMatching(true);
        daeUnmatchedVariables.clear();
        for (Var var : g.getUnmatchedVariables())
            daeUnmatchedVariables.add(var.getVariable());
        daeUnmatchedEquations.clear();
        for (Eq ee : g.getUnmatchedEquations())
            daeUnmatchedEquations.add(ee.getEquation());
        return g;
    }
    
    private BiPGraph FClass.DAEBiPGraph = null;
    
    /**
     * The symbolic equation sorting and canonicalization proceeds in the
     * following steps:
     * 
     * - The DAE system consisting of the DAE equations with algebraics and
     *   derivatives treated as unknowns is matched to obtain a pairing
     *   between equations and variables. Discrete and continuous algebraic
     *   variables are treated equally in this respect.
     *
     * - If a perfect matching is found, i.e., if there are no unmatched
     *   equations or variables, the BLT algoritm is applied to compute
     *   a sequence of stron components, corresponding to systems of equations.
     * 
     * - Having computed a matching and transformed the DAE into BLT form, 
     *   the DAE initialization system is analyzed:
     *    - The differentiated variables are added to the set of unknown 
     *      variables of the system.
     *    - The pre variables are added to the set of unknown variables of the
     *      system.
     *    - The initial equations are added to the set of equations of the 
     *      system. This includes equations resulting from start values with
     *      a corresonding fixed attribute set to true.
     *    - When clauses are analyzed: if a when clause is explicitly enabled by
     *      the initial() operator (whatever this means...), the when clause 
     *      is excluded, otherwhise the equation pre(x) = x is added, where x 
     *      is the variable that is solved for in the when clause.
     *      
     * - The matching algoritm is applied to the updated graph. Notice that it
     *   is important that the result of the DAE matching is used as a starting
     *   point: using this approach, derivatives and algebraics will remain
     *   matched if possible and additional equations are added, if needed,
     *   for differentiated variables. If there are 
     *   unmatched equations, the transformation sequence terminates. If there
     *   are unmatched variables, then additional initial equations are added 
     *   in order to obtained a balanced system. For continuous variables, 
     *   equations such as x = x.start are added, whereas for discrete variables
     *   equations such as pre(x) = x.start are added.
     *
     *  - Finally, the BLT algorithm is applied to the resulting perfect
     *    matchibng for the DAE initialization system.
     */
    private void FClass.computeMatchingsAndBLT() {
        // Make sure that we don't do this if any errors have been reported
        breakOnErrors();

        log.verbose("Flat tree before matching and BLT:");
        log.verbose(this);

        BiPGraph g;
        if (DAEBiPGraph == null) {
            g = computeMatchedDAEBiPGraph();
            log.verbose("DAE BiPGraph");
            log.verbose(g);
            log.verbose("DAE BiPGraph matching");
            log.verbose(g.printMatchingObj());
        } else {
            g = DAEBiPGraph;
            DAEBiPGraph = null;
        }
		
        log.verbose(g);
        
        // If no complete matching found, then fail
        if (!g.isComplete()) {
            checkStructure();
            breakOnErrors();
        } 

        // Perform BLT
        if (myOptions().getBooleanOption("equation_sorting") &&
                !myOptions().getBooleanOption("generate_only_initial_system") &&
                g.isComplete()) {
            BLT daeBLT;
            try {
                daeBLT = g.computeDAEBLT(myOptions());
                if (blockFunctionExtraction(daeBLT, g)) {
                    daeBLT = g.computeDAEBLT(myOptions());
                }
            } catch (BLTException e) {
                error(e.getMessage());
                return;
            }
            setDAEBLT(daeBLT);
            log.verbose(getDAEStructuredBLT());
            log.verbose(getDAEBLT());
        } else {
            setDAEBLT(BLT.EMPTY_BLT);
        }
        
        g.removeVariables(dynamicAlgebraicVariables());
        
        // Find matching for the initialization system
        g.addVariables(this, VAR_TYPES_INIT);
        g.addEquations(equations(), VAR_TYPES_INIT);
        g.setAsInitialSystem();
        
        // Replace when equations
        java.util.List<FAbstractEquation> equationsToReplace = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : equations()) {
            if (e.replacedAtInitialization()) {
                equationsToReplace.add(e);
            }
        }
        
        Set<FAbstractVariable> existingPrePropagationLikeInitialEquations = new HashSet<FAbstractVariable>();
        for (FAbstractEquation eqn : initialEquations()) {
            FAbstractVariable var = eqn.isPrePropagationEquation();
            if (var != null)
                existingPrePropagationLikeInitialEquations.add(var);
        }
        
        Map<FAbstractVariable, FAbstractEquation> prePropagationEquations = new HashMap<FAbstractVariable, FAbstractEquation>();
        // Loop over all equations to replace
        for (FAbstractEquation equationToReplace : equationsToReplace) {
            
            // How many equations are there in this when clause?
            List<FAbstractEquation> newEquations = equationToReplace.getInitialEquations();
            
            // Put the Equations in an ArrayList rather than a List
            // TODO: There are probably more elegant ways to do this...
            java.util.List<FAbstractEquation> newEquations_ = new ArrayList<FAbstractEquation>();
            for (FAbstractEquation e : newEquations) {
                FAbstractVariable var = e.isPrePropagationEquation();
                if (var == null) {
                    newEquations_.add(e);
                } else {
                    if (existingPrePropagationLikeInitialEquations.contains(var))
                        continue;
                    boolean hasOthers = false;
                    boolean assignedInAllBranches = false;
                    for (FIdUseExp exp : var.uses()) {
                        FAbstractEquation eqn = exp.myFEquation();
                        if (eqn == null || eqn == e || eqn == equationToReplace || !(eqn.inEquationSection() || eqn.inInitialEquationSection()))
                            continue;
                        hasOthers = true;
                        if (eqn.assignedInAllBranches(var))
                            assignedInAllBranches = true;
                    }
                    
                    if (!hasOthers || assignedInAllBranches)
                        prePropagationEquations.put(var, e);
                    else
                        newEquations_.add(e);
                }
            }
            
            // - equationToReplace is an FAbstractEquation that should be replaced
            // - newEquations contains the new equations that replaces the equationToReplace
            // - Note that newEquations may contain several equations
            
            java.util.List<Eq> eq_list = new ArrayList<Eq>(g.getEquations(equationToReplace));
            
            for (Eq eqq : eq_list) {
                g.removeEquation(eqq);
            }
            
            if (!eq_list.isEmpty())
                g.addEquations(newEquations_, VAR_TYPES_ALL, eq_list.get(0).getName() + "_init_", new Enumerator(1));
        }
        
        log.verbose(g);
        
        g.addEquations(initialEquations(), VAR_TYPES_ALL);
        
        g.maximumMatching(false, prePropagationEquations.keySet());
        log.verbose("Init DAE BiPGraph");
        log.verbose(g);
        log.verbose("Init BiPGraph matching");
        log.verbose(g.printMatchingObj());
        
        g = overdeterminedInitialSystem(g);
        
        // Add initial equations if needed
        if (g.getUnmatchedEquations().isEmpty() && myOptions().getBooleanOption("automatic_add_initial_equations")) {
            for (Var var : g.getUnmatchedVariables()) {
                FVariable fv = var.getVariable();
                FAbstractEquation fe = prePropagationEquations.remove(fv);
                if (fe == null && fv.isPreVariable())
                    fe = prePropagationEquations.remove(fv.myNonPreVariable());
                if (fe == null) {
                    FIdUseExp lhs = fv.isPreVariable() ? fv.createFPreExp() : fv.createUseExp();
                    FExp rhs = fv.startAttributeSet() ? fv.startAttributeExp() : fv.type().zeroLiteral();
                    fe = new FEquation(lhs, rhs);
                    fe.setLocationNoTree(fv);
                    addFInitialEquation(fe);
                }
                g.addEquations(Collections.singletonList(fe), VAR_TYPES_ALL);
            }
            root().flushAllRecursive();
            
            g.maximumMatching(false);
            log.verbose("Init DAE BiPGraph after addition of initial equations");
            log.verbose(g);
            log.verbose("Init BiPGraph matching after addition of initial equations");
            log.verbose(g.printMatchingObj());
        }
        
        numIgnoredPrePropagationEquations = prePropagationEquations.size() 
                + existingPrePropagationLikeInitialEquations.size();
        
        for (Var var : g.getUnmatchedVariables()) {
            daeInitUnmatchedVariables.add(var.getVariable());
        }
        
        for (Eq ee : g.getUnmatchedEquations()) {
            daeInitUnmatchedEquations.add(ee.getEquation());
        }
        
        collectErrors(ErrorCheckType.COMPILE);
        breakOnErrors();
        
        if (myOptions().getBooleanOption("equation_sorting") && g.isComplete()) {
            g.tarjanReset();
            BLT daeInitBLT;
            try {
                daeInitBLT = g.computeInitDAEBLT(myOptions());
                if (blockFunctionExtraction(daeInitBLT, g)) {
                    daeInitBLT = g.computeInitDAEBLT(myOptions());
                }
            } catch (BLTException e) {
                error(e.getMessage());
                return;
            }
            setDAEInitBLT(daeInitBLT);
            log.verbose(daeInitBLT);
        } else {
            setDAEInitBLT(BLT.EMPTY_BLT);
        }
    }
    
    syn FAbstractVariable FAbstractEquation.isPrePropagationEquation() = null;
    eq FEquation.isPrePropagationEquation() {
        FAbstractVariable left = getLeft().isAccess() ? getLeft().asFIdUse().myFV() : null;
        FAbstractVariable right = getRight().isAccess() ? getRight().asFIdUse().myFV() : null;
        return left == right ? left : null;
    }
    
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	public void FClass.checkStructure() {
		if (myOptions().getBooleanOption("enable_structural_diagnosis")) {
			StringBuffer err_str = new StringBuffer("The system is structurally singular. ");
			if (writeUnmatchedElements(err_str, getDAEUnmatchedVariables(), getDAEUnmatchedEquations())) 
				error(err_str.toString());
			err_str = new StringBuffer("The initialization system is structurally singular. ");
			if (writeUnmatchedElements(err_str, getDAEInitUnmatchedVariables(), getDAEInitUnmatchedEquations())) 
				error(err_str.toString());
		}
	}
	
	public static boolean FClass.writeUnmatchedElements(StringBuffer str, Collection<FVariable> unmatchedVariables, Collection<FAbstractEquation> unmatchedEquations) {
		boolean unbalanced = false;
		if (!unmatchedVariables.isEmpty()) {
			str.append("The following varible(s) could not be matched to any equation:\n");
			for (FVariable fv : unmatchedVariables) {
				str.append("     " + fv.name());
				str.append("\n");
			}
			unbalanced = true;
		}
		
		if (!unmatchedEquations.isEmpty()) {
			if (unbalanced) 
				str.append("\n  ");
			str.append("The following equation(s) could not be matched to any variable:\n");
			for (FAbstractEquation ee : unmatchedEquations) {
				str.append(ee.prettyPrint("    "));
				str.append("\n");
			}
			unbalanced = true;
		}
		return unbalanced;
	}
	
    public class FClass {
        public class genAlgorithmFunctionsIfSet extends Transformation {
            public genAlgorithmFunctionsIfSet() {
                super("algorithms_as_functions");
            }
            
            public void perform() {
                genAlgorithmFunctions();
            }
        }
    }
	
	/**
	 * Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		for (FAlgorithm alg : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FQName funcName = new FQNameString(alg.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FIdUseExp use : alg.FIdUseExpsInRHS()) {
				FAbstractVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FIdUseExp use : alg.FIdUseExpsInLHS()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
            List<FStatement> stmts = new List<FStatement>();
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
                    ffv.setFQName(new FQNameString(name));
					
					// Create and add binding expression for output
                    stmts.add(new FAssignStmt(bothInVars.get(i).createUseExp(), ffv.createUseExp()));
				}
			}
			
            for (FStatement stmt : alg.getFStatements()) {
                stmts.add(stmt);
            }
            alg.setFStatementList(stmts);
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
            FType type = FFunctionType.create(funcName.name(), outVars, this);
            FFunctionCall call = new FFunctionCall(funcName.createFIdUse(), args, type);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFQName().createFFunctionCallLeft());
			replaceEquation(alg, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			alg.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, alg, new List<FAttribute>()));
		}
	}

	/**
	 * Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		getFAbstractEquations().replaceChild(oldEq, newEq);
	}
	
	/**
	 * Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FQName.createFFunctionCallLeft() {
		FQName fqn = fullCopy();
		fqn.removeFArraySubscripts();
		return new FFunctionCallLeft(new Opt(new FIdUseExp(fqn)));
	}

	/**
	 * Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return createFPreExp();
			if (isContinuous())
				return createStartAttributeExp();
		}
		return createUseExp();
	}
	
	/**
	 * Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(TypePrefixInputOutput.OUTPUT);
	}

	/**
	 * Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(TypePrefixInputOutput.INPUT);
	}

	/**
	 * Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(TypePrefixInputOutput io) {
		FType type = (FType) type().fullCopy();
		return new FFunctionVariable(io, type, new Opt(), getFQName().fullCopy());
	}

    public static final SimpleProblemProducer ASTNode.DIFFERENTIATED_DISCRETE_VARIABLE =
            new SimpleErrorProducer("DIFFERENTIATED_DISCRETE_VARIABLE", ProblemKind.SEMANTIC,
                    "Unable to differentiate the variable %s which is declared or infered to be discrete");
	
    public class FClass {
        
        public setFDerivativeVariables setFDerivativeVariables = new setFDerivativeVariables();
        
        /**
         * Remake all FDerivativeVariables.
         */
        public class setFDerivativeVariables extends Transformation {
            protected Set<FVariable> variablesToVisit() {
                return new LinkedHashSet<FVariable>(differentiatedRealVariablesFilteredSet());
            }
            
            public void perform() {
                ArrayList<FVariable> l = new ArrayList<FVariable>();
                for (FVariable fv : getFVariables()) {
                    if (!fv.isDerivativeVariable()) {
                        l.add(fv);
                    }
                }
                for (FVariable fv : variablesToVisit()) {
                    if (fv.isDiscrete()) {
                        DIFFERENTIATED_DISCRETE_VARIABLE.invoke(fv, fv.name());
                    }
                    l.add(fv.createFDerivativeVariable());
                }
                setFVariableList(new List<FVariable>(l));
                root().flushAllRecursive();
                breakOnErrors();
            }
        }
        
        /**
         * Used by index reduction when removing derivatives of state select
         * prefer variables.
         */
        private Set<FVariable> ssPreferVars = null;
        
        /**
         * Add derivative variables to the list of FVariables.
         * Derivative variable is added for a variable of either of the following is true:
         *  - Occurres differentiated
         *  - Have StateSelect always or prefer
         */
        public class setFDerivativeVariablesPreBLT extends setFDerivativeVariables {
            @Override
            protected Set<FVariable> variablesToVisit() {
                ssPreferVars = new HashSet<FVariable>();
                Set<FVariable> fvsToVisit = super.variablesToVisit();
                boolean indexReductionActive = myOptions().getBooleanOption("index_reduction");
                for (FVariable fv : variables()) {
                    if (!fv.isReal()) {
                        continue;
                    }
                    FRealVariable.StateSelect ss = ((FRealVariable)fv).stateSelectAttribute();
                    if (!(ss == FRealVariable.StateSelect.ALWAYS
                            || ss == FRealVariable.StateSelect.PREFER && indexReductionActive)) {
                        continue;
                    }
                    if (ss == FRealVariable.StateSelect.PREFER && !fvsToVisit.contains(fv)) {
                        ssPreferVars.add(fv);
                    }
                    fvsToVisit.add(fv);
                }
                return fvsToVisit;
            }
        }
    }

    public void FClass.addFDerivativeVariables(Collection<FVariable> fvs) {
        for (FVariable fv : fvs)
            addFVariable(fv);
        root().flushAllRecursive();
    }

	public FAbstractDerivativeVariable FVariable.createFDerivativeVariable() {
	    throw new UnsupportedOperationException("Trying to create a derivative variable from the non real variable " + name() + "! Java class type: '" + getClass().getSimpleName() + "'");
	}

    @Override
    public FAbstractDerivativeVariable FRealVariable.createFDerivativeVariable() {
        FAbstractDerivativeVariable fdv;
        if (isDynamicState()) {
            FDynamicDerivativeVariable var = new FDynamicDerivativeVariable();
            var.setSet(dynamicStateSet());
            fdv = var;
        } else {
            fdv = new FDerivativeVariable();
        }
        fdv.setVisibilityType(getVisibilityType());
        fdv.setTypePrefixVariability(getTypePrefixVariability());
        fdv.setTypePrefixInputOutput(TypePrefixInputOutput.NONE);
        fdv.setFQName(getFQName().fullCopy());
        fdv.setOrder(order() + 1);
        fdv.setMeIntegrated(this);
        this.setMeDifferentiated(fdv);
        fdv = dynamicVariable(fdv);
        FAttribute ssAttr = findAttributeLocal(FAttribute.STATE_SELECT);
        if (ssAttr != null) {
            StateSelect ss = stateSelectAttribute();
            if (ss == StateSelect.NEVER || ss == StateSelect.AVOID)
                fdv.addFAttribute(ssAttr.fullCopy());
        }
        return fdv;
    }

    public class FClass {
        /**
         * Add pre variables to the list of FVariables, one for each
         * discrete variable and one for each continuous variable that is 
         * used in a pre() expression in an initial equation.
         */
        public class addFPreVariables extends Transformation {
            public void perform() {
                ArrayList<FVariable> l = new ArrayList<FVariable>();
                for (FVariable fv : discreteVariables()) 
                    if (fv.myPreVariable().isUnknown())
                        l.add(fv.createPreVariable());
                for (FVariable fv : continuousVariablesUsedInPreInInitial())
                    if (fv.myPreVariable().isUnknown())
                        l.add(fv.createPreVariable());
                for (FVariable fv : l) 
                    addFVariableNoTransform(fv);
                root().flushAllRecursive();
            }
        }
    }
    
    syn lazy Collection<FVariable> FClass.continuousVariablesUsedInPreInInitial() {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        getFInitialEquations().gatherContinuousVariablesUsedInPre(res);
        return new ArrayList<FVariable>(res);
    }
    
    public void ASTNode.gatherContinuousVariablesUsedInPre(Set<FVariable> res) {
        for (ASTNode n : this) 
            n.gatherContinuousVariablesUsedInPre(res);
    }
    
    public void FPreExp.gatherContinuousVariablesUsedInPre(Set<FVariable> res) {
        FAbstractVariable fv = getFIdUse().myFV();
        if (fv.isContinuous())
            res.add((FVariable) fv);
    }
    
	
	/**
	 * Create a pre variable for this variable.
	 */
	abstract public FVariable FVariable.createPreVariable();
	
	public FVariable FRealVariable.createPreVariable() {
		return new FPreRealVariable(this);
	}
	
	public FVariable FIntegerVariable.createPreVariable() {
		return new FPreIntegerVariable(this);
	}
	
	public FVariable FEnumVariable.createPreVariable() {
		return new FPreEnumVariable(this);
	}
	
	public FVariable FBooleanVariable.createPreVariable() {
		return new FPreBooleanVariable(this);
	}
	
	public FVariable FStringVariable.createPreVariable() {
		return new FPreStringVariable(this);
	}
	
	public FVariable FRecordVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}
	
	public FVariable FExternalObjectVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}


    public class FClass {
        /**
         * Generate initial equations from variables with fixed start
         * attributes.
         * 
         * Intitial equations corresponding to explicitly set start attributes of 
         * differentiated variables are also generated, without taking the fixed
         * attribute into account.
         */
        public class genInitialEquations extends Transformation {
            public void perform() {
                // TODO: Isn't there always a value for fv.startAttributeExp() now?
                for (FVariable fv : variables()) {
                    boolean generate = false;
                    if (!myOptions().getBooleanOption("state_initial_equations") &&
                            fv.isDifferentiatedVariable() && (fv.isFixed() ||
                            myOptions().getBooleanOption("state_start_values_fixed")))
                        generate = true;
                    else if (!myOptions().getBooleanOption("state_initial_equations") &&
                            fv.isAlgebraicContinousRealVariable() && fv.isFixed())
                        generate = true;
                    else if (fv.isDiscrete() && fv.isFixed()) {
                        generate = true;
                    }
                    
                    if (generate) {
                        FExp lhs = fv.setLocationOf(fv.isDiscrete() ? fv.createFPreExp() : fv.createUseExp());
                        FExp rhs = fv.setLocationOf(fv.startAttributeSet() ? fv.startAttributeExp().fullCopy() : fv.type().zeroLiteral());
                        addFInitialEquation(new FEquation(lhs, rhs));
                    }
                }
                root().flushAllRecursive();
            }
        }
    }

    public class FClass {
        /**
         * Perform alias elimination if it is activated.
         */
        public class aliasEliminationIfSet extends Transformation {
            public aliasEliminationIfSet() {
                super("eliminate_alias_variables");
            }
            
            public void perform() {
                genAlias();
                propagateDerivativeBindings();
                sortAliasVariables(false);
                sortAliasEquations();
                enableAliasRewrite();
                change();
                removeUnusedTemporaries();
                mergeEquivalentRecords();
                insertTempsInLHS();
                remoteRedundantInitialEquations();
                change();
            }
            
            public void propagateDerivativeBindings() {
                // Collect derivative binding equations, however only if we are going
                // to perform index reduction!
                if (myOptions().getBooleanOption("propagate_derivatives")) {
                    for (FAbstractEquation equation : getFAbstractEquations()) {
                        if (!equation.isAliasEquation()) {
                            equation.propagateDerivativeBindings();
                        }
                    }
                }
            }
        }
        
        public aliasEliminationIfSet aliasElimination = new aliasEliminationIfSet();
    }
	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	public boolean FAbstractEquation.aliasClassified = false;
	public boolean FAbstractEquation.classifiedAsAlias = false;
	
    /**
     * Detection of alias variables in equations
     * 
     * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
     * as alias equations and an AliasPair object is returned.
     */
    public AliasPair FEquation.aliasVariables() {
        AliasPair res = null;
        if (!containsActiveAnnotations()) // This equation should not be alias-removed if it is marked as residual!
            res = aliasVariables(true);
        aliasClassified = true;
        classifiedAsAlias = res != null;
        return res;
    }

    public AliasPair FEquation.aliasVariables(boolean checkVariables) {
        return aliasVariables(getLeft(), getRight(), 1, checkVariables);
    }

    syn boolean FAbstractEquation.potentialAliasEquation() = false;
    eq FEquation.potentialAliasEquation() = aliasVariables(false) != null;
    
    /**
     * Determine if two expressions would form an alias pair if on the left and right sides of 
     * an equation.
     * 
     * @param e1    an expression that would form one side of the equation
     * @param e2    an expression that would form the other side of the equation
     * @param sign  alias sign is multiplied with this - useful for e.g. 0 = x + y
     */
    public static AliasPair ASTNode.aliasVariables(FExp e1, FExp e2, int sign, boolean checkVariables) {
        FVariable fv1 = e1.variableThatCanBeAlias();
        FVariable fv2 = e2.variableThatCanBeAlias();
        if (fv1 != null && fv2 != null) {  // x = y, etc.
            if (!checkVariables || e1.canBeAlias() && e2.canBeAlias() 
                    && e1.type().typeAliasCompatible(e2.type()) 
                    && e1.variability().aliasCompatible(e2.variability())) {
                boolean negated = e1.aliasSign() * e2.aliasSign() * sign < 0;
                return new AliasPair(fv1, fv2, negated);
            } else {
                return null;
            }
        } else {                          // 0 = x + y, etc
            FExp eqZero = null;
            if (e1.isLiteralZero()) {
                eqZero = e2;
            } else if (e2.isLiteralZero()) {
                eqZero = e1;
            } if (eqZero != null) {
                return eqZero.aliasVariables(checkVariables);
            } else {
                return null;
            }
        }
    }

    public boolean TypePrefixVariability.aliasCompatible(TypePrefixVariability that) {
        return this.equals(that);
    }
	
    /**
     * Detection of alias variables in expressions
     * 
     * Only valid when in an equation that gives that the value of this expression is always 0.
     */
    public AliasPair FExp.aliasVariables(boolean checkVariables) {
        return null;
    }

    public AliasPair FDotAddExp.aliasVariables(boolean checkVariables) {
        return aliasVariables(getLeft(), getRight(), -1, checkVariables);
    }

    public AliasPair FDotSubExp.aliasVariables(boolean checkVariables) {
        return aliasVariables(getLeft(), getRight(), 1, checkVariables);
    }

    syn boolean FExp.canBeAlias() = false;
    eq FIdUseExp.canBeAlias()     = myFV().canBeAlias();
    eq FDerExp.canBeAlias()       = false;
    eq FNegExp.canBeAlias()       = getFExp().canBeAlias();

    syn boolean FAbstractVariable.canBeAlias() = false;
    // TODO: Use meDifferentiated instead of myDerivativeVariable()
    eq FVariable.canBeAlias() = !getFQName().myDerFV(order() + 1).isDummyDerivativeVariable() 
            && !isPreVariable() && !isNonDummyDerivativeVariable()
            && !isInput() && !isOutput();

    syn int FExp.aliasSign() = 1;
    eq FNegExp.aliasSign()   = -getFExp().aliasSign();

    syn FVariable FExp.variableThatCanBeAlias() = null;
    eq FNegExp.variableThatCanBeAlias()         = getFExp().variableThatCanBeAlias();
    eq FIdUseExp.variableThatCanBeAlias() {
        FAbstractVariable fav = myFV();
        if (fav.isFVariable()) {
            return fav.asFVariable();
        } else {
            return null;
        }
    }

	syn boolean FExp.isLiteralExp() = false;
	eq FLitExp.isLiteralExp()       = true;
	
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	// If an equation has been classified, the result needs to be cached 
	// in order to avoid reclassification after alias rewrites.
	eq FEquation.isAliasEquation() = aliasClassified? classifiedAsAlias: aliasVariables()!=null;
	
	/**
	 * Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		if (aliasManager == null) {
			aliasManager = new AliasManager();
		}
		for (FAbstractEquation equation : getFAbstractEquations()) {
			// Iterate over all equations
			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
			// Check all alias equations, also those that that have been
			// checked before.
			equation.aliasClassified = false; 
			if (equation.isAliasEquation()) 
				aliasManager.addAliasVariables(equation.aliasVariables());
		}
        if (myOptions().getBooleanOption("eliminate_alias_parameters")) {
            for (FAbstractEquation equation : getParameterEquations()) {
                equation.aliasClassified = false; 
                if (equation.isAliasEquation()) 
                    aliasManager.addAliasVariables(equation.aliasVariables());
            }
        }
        if (myOptions().getBooleanOption("eliminate_alias_constants")) {
            Map<String, FVariable> firstOccurencesReal = new HashMap<String, FVariable>();
            Map<String, FVariable> firstOccurencesNonReal = new HashMap<String, FVariable>();
            for (FVariable fv : getFVariables()) {
                fv.classifyAliasConstant(aliasManager, firstOccurencesReal, firstOccurencesNonReal);
            }
        }
        aliasManager.reportAliasErrors(this);
	}
	
    public void FVariable.classifyAliasConstant(AliasManager aliasManager, 
            Map<String, FVariable> firstOccurencesReal, 
            Map<String, FVariable> firstOccurencesNonReal) {
        if (variability().knownParameterOrLess() && hasBindingExp()) {
            Map<String, FVariable> firstOccurences = isReal() ? firstOccurencesReal : firstOccurencesNonReal;
            String s = getBindingExp().toString();
            FVariable first = firstOccurences.get(s);
            if (first != null) {
                aliasManager.addAliasVariables(new AliasPair(first, this, false));
            } else {
                firstOccurences.put(s, this);
            }
        }
    }

    /**
     * Eliminate alias variables from the flat model.
     * 
     * The non-alias variables are kept in the list FClass.FVariableList but the
     * alias variables are moved to FClass.AliasVariablesList.
     */
    public void FClass.sortAliasVariables(boolean recompute) {
        ArrayList<FVariable> nonAliasVars = new ArrayList<FVariable>();
        ArrayList<FVariable> aliasVars    = new ArrayList<FVariable>();
        if (recompute) {
            for (FVariable fv : getAliasVariables()) {
                fv.aliasSort(nonAliasVars, aliasVars);
            }
        } else {
            for (FVariable fv : getAliasVariables()) {
                aliasVars.add(fv);
            }
        }
        for (FVariable fv : getFVariables()) {
             fv.aliasSort(nonAliasVars, aliasVars);
        }
        setFVariableList(new List(nonAliasVars));
        setAliasVariableList(new List(aliasVars));
    }

    /**
     * Eliminate alias equation from the flat model.
     */
    public void FClass.sortAliasEquations() {
        ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
        ArrayList<FAbstractEquation> pEqns = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation equation : getFAbstractEquations()) {
            if (!equation.isAliasEquation()) {
                eqns.add(equation);
            }
        }
        if (myOptions().getBooleanOption("eliminate_alias_parameters")) {
            for (FAbstractEquation equation : getParameterEquations()) { 
                if (!equation.isAliasEquation()) {
                    pEqns.add(equation);
                }
            }
            setParameterEquationList(new List(pEqns));
        }
        setFAbstractEquationList(new List(eqns));
    }

    /**
     * Adds this variable to <code>aliasVars</code>, if it is an alias, or 
     * <code>nonAliasVars</code>, if it is not.
     */
    public void FVariable.aliasSort(ArrayList<FVariable> nonAliasVars, ArrayList<FVariable> aliasVars) {
        if (isAlias()) {
            aliasVars.add(this);
        } else if (aliasSortKeep()) { 
            nonAliasVars.add(this);
            this.propagateAttributesFromAlias();
        }
    }
    
    /**
     * A derivative variable of an alias is removed, if there is no suitable 
     * alias derivative variable one is created. 
     */
    public void FDerivativeVariable.aliasSort(ArrayList<FVariable> nonAliasVars, ArrayList<FVariable> aliasVars) {
        FVariable itg = getMeIntegrated();
        if (itg.isAlias()) {
            FVariable alias = itg.alias();
            if (alias.getMeDifferentiated() == null) {
                FVariable fdv = alias.createFDerivativeVariable();
                alias.setMeDifferentiated(fdv);
                fdv.setMeIntegrated(alias);
                nonAliasVars.add(fdv);
            }
        } else {
            super.aliasSort(nonAliasVars, aliasVars);
        }
    }
    
    /**
     * If this is a pre variable of an alias it should be left out/removed.
     */
    syn boolean FVariable.aliasSortKeep() = !isPreVariable() || !myNonPreVariable().isAlias();
    
	
	public void ASTNode.enableAliasRewrite() {
		for (ASTNode n : this)
			n.enableAliasRewrite();
	}
	
	public void FIdUseExp.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	public void FAssignStmt.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
    public void FInternalAttribute.enableAliasRewrite() {
        // We do not want to rewrite attributes that are of reference type
        if (!getType().name().equals("*"))
            super.enableAliasRewrite();
    }
	
	public void FFunctionDecl.enableAliasRewrite() {
	}
	
	boolean FIdUseExp.rewriteAlias = false;
	boolean FAssignStmt.rewriteAlias = false;

    /**
     * FIdUses referring to alias variables need to be changed to 
     * FIdUses referring to their alias targets. 
     * 
     * This is done by rewrites which are activated once FIdUseExp.rewriteAlias
     * is true. Notice that in order for the rewrite to be enable, the is$final
     * field of FIdUseExp needs to be set to false: this is done by the recursive
     * method ASTNode.flushAllRecursiveClearFinal. 
     */
    rewrite FIdUseExp {
        when (rewriteAlias) to FExp {
            if (myFV().isFVariable() && myFV().isAlias()) {
                FVariable fv = (FVariable) myFV();
                FIdUseExp new_exp = fv.alias().createUseExp();
                new_exp.setLocationNoTree(this);
                new_exp.addLocation(fv);
                new_exp.setOriginalVariable(this, fv);
                new_exp.rewriteAlias = true;
                if (fv.isNegated()) 
                    return new FNegExp(new_exp);
                else
                    return new_exp;
            }
            FAbstractEquation eqn = myFEquation();
            if (eqn != null && !eqn.potentialAliasEquation()
                    && myFV().derivativeEquivalent() != null
                    && order() == 0 && inEquationSection()
                    && !inWhen() && !inFunctionCallLeft()) {
                FVariable var = myFV().derivativeEquivalent();
                FIdUseExp exp =  var.getMeDifferentiated().createUseExp();
                exp.setOriginalVariable(this, var);
                if (var.isAlias())
                    exp.rewriteAlias = true;
                return exp;
            } else {
                rewriteAlias = false;
                return this;
            }
        }
    }

    rewrite FPreExp {
        when (rewriteAlias) to FExp {
            if (myNonPreFV().isFVariable() && myNonPreFV().isAlias()) {
                FVariable fv = (FVariable) myNonPreFV();
                FIdUseExp new_exp = fv.alias().createFPreExp();
                new_exp.setOriginalVariable(this, fv);
                if (fv.isNegated()) 
                    return new FNegExp(new_exp);
                else
                    return new_exp;
            } else {
                rewriteAlias = false;
                return this;
            }
        }
    }

    rewrite FAssignStmt {
        when (rewriteAlias && getLeft() instanceof FIdUseExp) to FAssignStmt {
            FIdUseExp left = (FIdUseExp) getLeft();
            if (left.myFV().isFVariable() && left.myFV().isAlias()) {
                FVariable fv = (FVariable) left.myFV();
                FIdUseExp exp = fv.alias().createUseExp();
                setLeft(exp);
                exp.setOriginalVariable(left, fv);
                if (fv.isNegated()) 
                    setRight(new FNegExp(getRight()));
                return this;
            } else {
                rewriteAlias = false;
                return this;
            }
        }
    }

    /**
     * FDerExps referring to alias variables need to be changed to 
     * FDerExps referring to their alias targets. 
     * 
     * This is done by rewrites which are activated once FIdUseExp.rewriteAlias
     * is true. Notice that in order for the rewrite to be enable, the is$final
     * field of FIdUseExp needs to be set to false: this is done by the recursive
     * method ASTNode.flushAllRecursiveClearFinal. 
     */
    rewrite FAbstractDerExp {
        when (rewriteAlias && getFIdUse().myFV().isFVariable() && (myFV().isAlias() || getFIdUse().myFV().isAlias())) to FExp {
            if (myFV().isAlias()) {
                FVariable fv = (FVariable) myFV();
                FIdUseExp new_exp = fv.alias().createUseExp();
                new_exp.setOriginalVariable(this, fv);
                if (myFV().isNegated()) 
                    return new FNegExp(new_exp);
                else
                    return new_exp;
            } else {
                FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
                FAbstractDerExp new_exp = createEmptyNode();
                new_exp.setFIdUse(new FIdUse(new_name));
                new_exp.setOrder(order());
                new_exp.setOriginalVariable(this, getFIdUse().myFV());
                if (getFIdUse().myFV().isNegated())
                    return new FNegExp(new_exp);
                else
                    return new_exp;
            }
        }
    }

    public void FIdUseExp.setOriginalVariable(FIdUseExp oldExp, FAbstractVariable var) {
        setOriginalVariable(computeOriginalVariable(oldExp, var));
    }
    private static String FIdUseExp.computeOriginalVariable(FIdUseExp oldExp, FAbstractVariable var) {
        if (!oldExp.getOriginalVariable().isEmpty()) {
            return oldExp.getOriginalVariable();
        }
        while (var.isTemporary()) {
            AliasManager.AliasVariable av = var.asFVariable().myFClass().getAliasManager().getAliasVariable(var.asFVariable());
            if (av.getTempAssignRight() != null) {
                var = av.getTempAssignRight();
            } else {
                return null;
            }
            
        }
        return var.name();
    }
    
    syn FAbstractVariable FIdUseExp.myOriginalFV() = myFClass().lookupFV(getOriginalVariable());
    
    /*
     * Rewrite derivatives of parameters to zeros.
     */
    rewrite FAbstractDerExp {
        when (getFIdUse().myFV().isFVariable() && getFIdUse().myFV().variability().parameterOrLess()) to FExp {
            return new FRealLitExp(0.0);
        }
    }

    /**
     * Remove all unused temporary variables, and inline temporaries only used once.
     */
    public void FClass.removeUnusedTemporaries() {
        ArrayList<FVariable> temps = tempVariables();
        Collection<FVariable> tempsToRemove = new ArrayList<FVariable>();
        int oldSize = Integer.MAX_VALUE;
        while (temps.size() < oldSize) {
            ArrayList<FVariable> temps2 = new ArrayList<FVariable>(temps.size());
            for (FVariable fv : temps) {
                if (!fv.inlineUses()) {
                    temps2.add(fv);
                } else {
                    tempsToRemove.add(fv);
                }
            }
            oldSize = temps.size();
            temps = temps2;
        }
        
        ArrayList<FVariable> vars = new ArrayList<FVariable>();
        for (FVariable fv : getFVariables())
            if (!fv.isTemporary())
                vars.add(fv);
        for (FVariable fv : temps)
            vars.add(fv);
        
        removeMarkedEqns();
        setFVariableList(new List(vars));
        
        Set<FVariable> aliasVarsToRemove = new HashSet<FVariable>();
        
        for (FVariable fv : tempsToRemove) {
            aliasVarsToRemove.addAll(getAliasManager().removeTemporaryVariableSet(fv));
        }
        
        ArrayList<FVariable> newAliasVars = new ArrayList<FVariable>();
        for (FVariable fv : getAliasVariables()) {
            if (!aliasVarsToRemove.contains(fv)) {
                newAliasVars.add(fv);
            }
        }
        setAliasVariableList(new List(newAliasVars));
    }

    /**
     * Check if this is a temporary variable that should be eliminated.
     */
    syn boolean FVariable.shouldEliminateTemporary() = 
        isTemporary() && 
        nonDefiningUses().size() <= 1 && 
        definingUses().size() <= 1 && 
        !isPreVariable() && myPreVariable().isUnknown() && 
        (definingUses().isEmpty() || !definingUses().iterator().next().myFEquation().generatesEvents()) && 
        !isDifferentiatedVariable() && !isDerivativeVariable();

	/**
	 * Inline all non-defining uses of variable, and remove equation defining it.
	 * 
	 * NB: This assumes that the variable and any equations marked for removal will be removed.
	 */
    public boolean FVariable.inlineUses() {
        if (!shouldEliminateTemporary()) {
            return false;
        }
		FExp value;
		if (hasBindingExp()) {
			value = getBindingExp();
		} else {
			if (definingUses().isEmpty())
                return nonDefiningUses().isEmpty();
			FAbstractEquation eqn = definingUses().iterator().next().myFEquation();
            if (eqn instanceof FEquation) {
                value = ((FEquation) eqn).getRight();
                eqn.markForRemoval();
            } else if (eqn instanceof FFunctionCallEquation) {
                return inlineUsesFunctionCallLeft();
            } else {
                return false;
            }
		}
		
		if (nonDefiningUses().isEmpty())
			value.removeFromUses();
		value.parent = null;
		
		for (FIdUseExp use : nonDefiningUses())
			use.replaceMe(value.unboundCopy());
        return true;
	}
	
    public boolean FVariable.inlineUsesFunctionCallLeft() {
        FIdUseExp defineUse = definingUses().iterator().next();
        FExp value;
        if (nonDefiningUses().size() > 0) {
            List<FAbstractEquation> defineEqnList = defineUse.myFEquation().myFAbstractEquationList();
            FIdUseExp nonDefineUse = nonDefiningUses().iterator().next();
            value = nonDefineUse.inlineUsesFunctionCallLeft();
            if (value == null || defineEqnList == null || defineEqnList != value.myFEquation().myFAbstractEquationList()) {
                return false;
            }
            value.myFEquation().markForRemoval();
        } else {
            value = new FNoExp();
        }
        
        definingUses().remove(defineUse);
        defineUse.replaceMe(value);
        return true;
    }
    
    inh FIdUseExp FIdUseExp.inlineUsesFunctionCallLeft();
    eq BaseNode.getChild().inlineUsesFunctionCallLeft()  = null;
    eq FEquation.getRight().inlineUsesFunctionCallLeft() = getLeft().getEquationLeftInlineUse();
    
    syn FIdUseExp FExp.getEquationLeftInlineUse() = null;
    eq FIdUseExp.getEquationLeftInlineUse()       = this;
    eq FAbstractDerExp.getEquationLeftInlineUse() = null;
    eq FPreExp.getEquationLeftInlineUse()         = null;
    
	/**
	 * Flag for removing equation.
	 */
	public boolean FAbstractEquation.markedForRemoval = false;
	
    public void FAbstractEquation.markForRemoval() {
        markedForRemoval = true;
    }
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FExp.removeFromUses() {
		for (FExp e : childFExps())
			e.removeFromUses();
	}
	
	public void FIdUseExp.removeFromUses() {
		FAbstractVariable var = myFV();
		var.uses().remove(this);
		var.definingUses().remove(this);
		var.nonDefiningUses().remove(this);
		getFIdUse().getFQName().removeFromUses();
	}
	
	/**
	 * Remove all uses in expressions in array subscripts from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FQName.removeFromUses() {}
	
	public void FQNameFull.removeFromUses() {
		for (FQNamePart p : getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.removeFromUses();
	}
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FSubscript.removeFromUses() {}
	
	public void FExpSubscript.removeFromUses() {
		getFExp().removeFromUses();
	}
	
	/**
	 * Remove all equations with <code>markedForRemoval == true</code>. 
	 */
	public void FClass.removeMarkedEqns() {
		setFInitialEquationList(removeMarkedEqns(getFInitialEquations()));
		setParameterEquationList(removeMarkedEqns(getParameterEquations()));
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	/**
	 * Create a copy of the list with all equations with <code>markedForRemoval == true</code> removed. 
	 */
	protected static List<FAbstractEquation> ASTNode.removeMarkedEqns(List<FAbstractEquation> list) {
		List<FAbstractEquation> res = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : list) {
			if (!eqn.markedForRemoval) {
				eqn.removeMarkedEqns();
				res.add(eqn);
			}
		}
		return res;
	}
	
	/**
	 * Remove all contained equations with <code>markedForRemoval == true</code>. 
	 */
	public void FAbstractEquation.removeMarkedEqns() {}
	
	public void FForClauseE.removeMarkedEqns() {
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	public void FIfWhenElseEquation.removeMarkedEqns() {
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	public void FIfWhenEquation.removeMarkedEqns() {
		super.removeMarkedEqns();
		if (hasElse())
			getElse().removeMarkedEqns();
	}
	
	/**
	 * Remove records that are equivalent, and update uses. 
	 */
	public void FClass.mergeEquivalentRecords() {
		computeEquivalentRecords();
		activateEquivalentRecordUseRewrite();
		List<FRecordDecl> list = new List<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			if (rec.equivalentRecordToKeep)
				list.add(rec);
		setFRecordDeclList(list);
	}

    public void FClass.computeEquivalentRecords() {
        ArrayList<FRecordType> distinctTypes = new ArrayList<>();
        ArrayList<FRecordDecl> keptDecl = new ArrayList<>();
        equivalentRecordComponentOrderMap = new HashMap<>();
        for (FRecordDecl rec : getFRecordDecls()) {
            boolean found = false;
            FRecordType type = rec.type();
            for (int i = 0; !found && i < distinctTypes.size(); i++) {
                FRecordType other = distinctTypes.get(i);
                /* TODO: Also check that this type is not used in any external functions.
                 *       If it is, do not remove it (if the one chosen to be kept isn't used 
                 *       in an external, keep this one instead). */
                if (type.typeCompatible(other)) {
                    found = true;
                    rec.equivalentRecordGroup = i;
                    type.addComponentReorderFrom(other, equivalentRecordComponentOrderMap);
                }
            }
            if (!found) {
                rec.equivalentRecordToKeep = true;
                rec.equivalentRecordGroup = distinctTypes.size();
                distinctTypes.add(type);
                keptDecl.add(rec);
            }
        }
        equivalentRecordMap = new HashMap<>();
        for (FRecordDecl rec : getFRecordDecls())
            equivalentRecordMap.put(rec.name(), keptDecl.get(rec.equivalentRecordGroup));
    }

    public void FRecordType.addComponentReorderFrom(FRecordType other, Map<String, int[]> map) {
        Map<String,Integer> myOrder = new HashMap<>();
        for (int i = 0, n = getNumComponent(); i < n; i++) {
            myOrder.put(getComponent(i).getName(), i);
        }
        
        int[] order = new int[getNumComponent()];
        boolean different = false;
        for (int i = 0, n = other.getNumComponent(); i < n; i++) {
            int j = myOrder.get(other.getComponent(i).getName());
            order[i] = j;
            if (i != j) {
                different = true;
            }
        }
        
        if (different) {
            map.put(name(), order);
        }
    }

    protected Map<String,FRecordDecl> FClass.equivalentRecordMap;
    protected Map<String,int[]> FClass.equivalentRecordComponentOrderMap;

	public boolean FRecordDecl.equivalentRecordToKeep = false;
	public int FRecordDecl.equivalentRecordGroup = -1;
	
	public void ASTNode.activateEquivalentRecordUseRewrite() {
		for (ASTNode n : this)
			n.activateEquivalentRecordUseRewrite();
	}
    
    public void FRecordType.activateEquivalentRecordUseRewrite() {
        super.activateEquivalentRecordUseRewrite();
        rewriteEquivalentRecord = true;
        is$Final = false;
    }
    
	public void FRecordVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	public void FRecordConstructor.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
    private boolean FRecordType.rewriteEquivalentRecord        = false;
	private boolean FRecordVariable.rewriteEquivalentRecord    = false;
	private boolean FRecordConstructor.rewriteEquivalentRecord = false;
	
    rewrite FRecordType {
        when (rewriteEquivalentRecord) to FType {
            return myFClass().createEquivalentRecordType(this);
		}
	}
	
	rewrite FRecordVariable {
		when (rewriteEquivalentRecord)
		to FRecordVariable {
			rewriteEquivalentRecord = false;
			setRecord(myFClass().createEquivalentRecordFQName(getRecord()));
			flushAll();
			return this;
		}
	}

    rewrite FRecordConstructor {
        when (rewriteEquivalentRecord)
        to FRecordConstructor {
            rewriteEquivalentRecord = false;
            FQName old = getRecord().getFQName();
            getRecord().setFQName(myFClass().createEquivalentRecordFQName(old));
            int[] order = myFClass().getEquivalentRecordComponentOrder(old);
            if (order != null) {
                List<FExp> args = new List<>();
                for (int i : order) {
                    args.add(getArg(i));
                }
                setArgList(args);
            }
            flushAll();
            return this;
        }
    }

	public FQName FClass.createEquivalentRecordFQName(FQName old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.getFQName().fullCopy() : old;
	}

    public int[] FClass.getEquivalentRecordComponentOrder(FQName old) {
        return equivalentRecordComponentOrderMap.get(old.name());
    }

	public FType FClass.createEquivalentRecordType(FType old) {
        FRecordDecl rec = equivalentRecordMap.get(old.name());
        if (rec == null) {
            return old;
        }
        FType t = rec.type().fullCopy();
        t.transferSizes(old);
        return t;
    }
    
    public void FType.transferSizes(FType t) {
        if (!t.isUnknown()) {
            setSize(t.getSize());
        }
    }
    
    public void FRecordType.transferSizes(FType t) {
        super.transferSizes(t);
        if (!t.isUnknown() && !t.isNoType()) {
            FRecordType rt = (FRecordType) t;
            for (int i = 0; i < getNumComponent(); i++) {
                getComponent(i).getFType().transferSizes(rt.getComponent(i).getFType());
            }
        }
    }
    
    public void FClass.insertTempsInLHS() {
        for (FAbstractEquation equation : getParameterEquations()) {
            equation.insertTempsInLHS(this, true);
        }
        for (FAbstractEquation equation : getFAbstractEquations()) {
            equation.insertTempsInLHS(this, false);
        }
    }
    
    public void FAbstractEquation.insertTempsInLHS(FClass fClass, boolean param) {}
    
    @Override
    public void FFunctionCallEquation.insertTempsInLHS(FClass fClass, boolean param) {
        for (FFunctionCallLeft left : getLefts()) {
            left.insertTempsInLHS(fClass, param);
        }
    }
    
    public void FFunctionCallLeft.insertTempsInLHS(FClass fClass, boolean param) {
        if (hasFExp()) {
            getFExp().insertTempsInLHS(fClass, param);
        }
    }
    
    public void FExp.insertTempsInLHS(FClass fClass, boolean param) {
        String tempName = calcTempVarName();
        TypePrefixVariability v;
        if (param) {
            v = Variability.FIXEDPARAMETER;
        } else {
            v = type().funcOutputVariability();
        }
        fClass.addFVariable(type().createTempFVariable(new FQNameString(tempName), v));
        replaceMe(new FIdUseExp(tempName));
        FEquation e = new FEquation(this, new FIdUseExp(tempName));
        if (param) {
            fClass.addParameterEquation(e);
        } else {
            fClass.addFEquation(e);
        }
    }
    
    @Override
    public void FNoExp.insertTempsInLHS(FClass fClass, boolean param) {
        
    }
    
    @Override
    public void FIdUseExp.insertTempsInLHS(FClass fClass, boolean param) {
        
    }
    
    @Override
    public void FArray.insertTempsInLHS(FClass fClass, boolean param) {
        for (FExp fExp : getFExps()) {
            fExp.insertTempsInLHS(fClass, param);
        }
    }
    
    @Override
    public void FRecordConstructor.insertTempsInLHS(FClass fClass, boolean param) {
        for (FExp fExp : getArgs()) {
            fExp.insertTempsInLHS(fClass, param);
        }
    }
    
    public void FClass.remoteRedundantInitialEquations() {
        ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
        // Remove alias equations.
        for (FAbstractEquation equation : getFInitialEquations()) {
            if (!equation.isSameVariableEquality()) {
                eqns.add(equation);
            }
        }
        setFInitialEquationList(new List(eqns));
    }
    
    syn boolean FAbstractEquation.isSameVariableEquality() = false;
    eq FEquation.isSameVariableEquality() = getLeft().isAccess() && getRight().isAccess()
            && getLeft().asFIdUseExp().myFV() == getRight().asFIdUseExp().myFV()
            && !getLeft().asFIdUseExp().myFV().isUnknown();

}

aspect ParameterSorting {

	/**
	 * Index of equation during equation sorting.
	 */
	public int FAbstractEquation.sortingIndex = -1;
	
	public class FAbstractEquation {
		public static class SortingIndexComparator implements Comparator<FAbstractEquation> {
			public int compare(FAbstractEquation o1, FAbstractEquation o2) {
				return o1.sortingIndex - o2.sortingIndex;
			}
		}
	}
	
	public class FVariable {
		public static class SortingIndexComparator implements Comparator<FVariable> {
			public int compare(FVariable o1, FVariable o2) {
				return o1.parameterEquation().sortingIndex - o2.parameterEquation().sortingIndex;
			}
		}
	}
	
	/**
	 * Creates a TreeSet that can hold FAbstractEquations, sorted by their sortingIndex.
	 */
	public static TreeSet<FAbstractEquation> FAbstractEquation.sortingSet() {
		return new TreeSet<FAbstractEquation>(new SortingIndexComparator());
	}
	
	/** 
	 * Sorts a list of FVariables according to the sortingIndex of their equation.
	 */
	public static void FVariable.sortParameters(java.util.List<FVariable> vars) {
		Collections.sort(vars, new SortingIndexComparator());
	}

    public class FClass {
        /**
         * Sort dependent parameter equations.
         * 
         * This is a simple implementation of Kahn's topological sorting algorithm.
         * This implementation will most likely be replaced by other graph 
         * algorithms later on.
         */
        public class sortDependentParameters extends Transformation {
            public void perform() {
                sortDependentParameters();
            }
        }
    }

    /**
     * Sort dependent parameter equations.
     * 
     * This is a simple implementation of Kahn's topological sorting algorithm.
     * This implementation will most likely be replaced by other graph 
     * algorithms later on.
     */
    public void FClass.sortDependentParameters() {
        // Check that all independent parameters can be evaluated.
        for (FVariable var : getFVariables()) {
            TypePrefixVariability variability = var.variability();
            if (variability.parameterVariability() && var.hasBindingExp()) {
                FExp bExp = var.getBindingExp();
                if (!bExp.isLiteralExp() && !var.isExternalObject()) {
                    FExp literal = null;
                    try {
                        CValue cval = bExp.ceval();
                        if (cval.hasBuildLiteral()) {
                            literal = cval.buildLiteral();
                        }
                    } catch (ConstantEvaluationException e) {}
                    if (literal != null) {
                        var.setBindingExp(literal);
                    } else {
                        FAbstractEquation fae = new FEquation(var.createUseExp(), bExp);
                        addParameterEquationNoTransform(fae);
                        var.removeBindingExp();
                        parameterEquationsMap().put(var, fae);
                    }
                }
            }
        }
		// Get the list of parameter equations and set up preliminary data.
		ArrayList<FAbstractEquation> eqns = getParameterEquations().toArrayList();
		
		// Check if there is any dependent parameters that can be made independent.
		Iterator<FAbstractEquation> it = eqns.iterator();
		while (it.hasNext()) {
			FAbstractEquation eqn = it.next();
			if (eqn != null && eqn.isIndependentParameterEquation()) {
				try {
					eqn.revertToBindingExp();
					it.remove();
				} catch (ConstantEvaluationException e) {
					// Doh, we were unable to evaluate the expression
				}
			}
		}
		int n_eqns = eqns.size();
		List<FVariable> vars = getFVariables();
		int n_vars = getNumFVariable();
		for (int i = 0; i < n_eqns; i++)
			eqns.get(i).sortingIndex = i;
		for (FVariable fv : vars)
			fv.parameterEquation();  // Calculate these before changing anything
		
		
		// Set up data structures for the adjacency graph.
		ArrayList<HashSet<FAbstractEquation>> toNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		ArrayList<HashSet<FAbstractEquation>> fromNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		for (int i = 0; i < n_eqns; i++) {
			toNodes.add(new HashSet<FAbstractEquation>());
			fromNodes.add(new HashSet<FAbstractEquation>());
		}
		
		// For each equation
		for (FAbstractEquation eqn : eqns) {
			// Retrieve all variables referenced in right hand side
            Set<FVariable> deps = eqn.variableDependenciesRHS();
			// Build the actual adjacency graph.
			for (FVariable fv : deps) {
				FAbstractEquation depEqn = fv.parameterEquation();
				if (depEqn != null && depEqn.sortingIndex >= 0) {
					toNodes.get(depEqn.sortingIndex).add(eqn);		
					fromNodes.get(eqn.sortingIndex).add(depEqn);
				}
			}
		}	
				
		// Sort using algorithm described at
		// http://en.wikipedia.org/wiki/Topological_sorting
		List<FAbstractEquation> L = new List<FAbstractEquation>();
		Queue<FAbstractEquation> S = new ArrayDeque<FAbstractEquation>();
		
		// Add all nodes without incoming edges to S
		for (int i = 0; i < n_eqns; i++) 
			if (fromNodes.get(i).isEmpty()) 
				S.add(eqns.get(i));
		
		// Repeat while S is not empty
		int si = 0;
		int n_indep = 0;
		while (S.size() > 0) {
			// Remove a node n from S
			FAbstractEquation n = S.remove();
			L.add(n);
			// For each node m with an edge e from n to m (in original order)
			Set<FAbstractEquation> nodes = FAbstractEquation.sortingSet();
			nodes.addAll(toNodes.get(n.sortingIndex));
			for (FAbstractEquation m : nodes) {
				// Remove edge e from fromNodes
				fromNodes.get(m.sortingIndex).remove(n);
				// If m has no incoming edges add m to S
				if (fromNodes.get(m.sortingIndex).isEmpty()) 
					S.add(m);
			}
			// Remove e from toNodes
			toNodes.get(n.sortingIndex).clear();
			// Done with n - update sortingIndex
			n.sortingIndex = si++;
		}
		
		// Not possible to find an ordering without cycles?
		if (L.getNumChild() != eqns.size() - n_indep) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		} else {
			// Replace old parameter equation list
			setParameterEquationList(L);
			
			// Rearrange parameters in same order as parameter equations
			ArrayList<FVariable> depParams = new ArrayList<FVariable>(n_eqns);
            for (FAbstractEquation fae : L) {
                depParams.addAll(fae.referencedFVariablesInLHS());
            }
			ArrayList<Integer> depParamIndices = new ArrayList<Integer>(n_eqns);
			for (int i = 0; i < n_vars; i++) {
				FVariable fv = vars.getChild(i);
				if (fv.hasParameterEquation()) {
                    depParamIndices.add(new Integer(i));
                }
            }
            
			for (int i = 0; i < depParams.size(); i++)
				vars.setChild(depParams.get(i), depParamIndices.get(i).intValue());
	
			// Flush AST since the structure has changed.
				root().flushAllRecursive();
			
			// Remove any binding expressions of variables with parameter equations
			for (FAbstractEquation eqn : L)
				eqn.removeBindingExpOfAssignedVars();
		}
	}
	
	/**
	 * Remove binding expression of variables assigned in this equation.
	 */
	public void FAbstractEquation.removeBindingExpOfAssignedVars() {}

	public void FEquation.removeBindingExpOfAssignedVars() {
		getLeft().removeBindingExpOfReferencedVars();
	}
	
	public void FFunctionCallEquation.removeBindingExpOfAssignedVars() {
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
				left.getFExp().removeBindingExpOfReferencedVars();
	}
	
	/**
	 * Remove binding expression of variables referenced in this expression.
	 */
	public void FExp.removeBindingExpOfReferencedVars() {
		for (FExp e : childFExps())
			e.removeBindingExpOfReferencedVars();
	}
	
	public void FIdUseExp.removeBindingExpOfReferencedVars() {
		getFIdUse().myFV().removeBindingExp();
	}
	
	/**
	 * Remove binding expression of this variable.
	 */
	public void FAbstractVariable.removeBindingExp() {}
	
	public void FVariable.removeBindingExp() {
		if (hasBindingExp())
			setBindingExpOpt(new Opt());
	}
	
	/**
	 * Test if this should be the binding expression of an independent parameter instead.
	 */
	syn boolean FAbstractEquation.isIndependentParameterEquation() = false;
	eq FEquation.isIndependentParameterEquation() = 
		getLeft().isFlatParameterUse() && getRight().isIndependentParameterExp();
	
	/**
	 * Test if this is a use of a parameter (in the flat tree).
	 */
	syn boolean FExp.isFlatParameterUse()   = false;
	eq FIdUseExp.isFlatParameterUse()       = getFIdUse().isFlatParameterUse();
	syn boolean FIdUse.isFlatParameterUse() = myFV().isParameter();
	
	/**
	 * Convert this parameter equation to a binding expression.
	 */
	public void FAbstractEquation.revertToBindingExp() {}
	public void FEquation.revertToBindingExp() throws ConstantEvaluationException {
		FVariable fv = (FVariable) ((FIdUseExp) getLeft()).getFIdUse().myFV();
		fv.setBindingExp(getRight().ceval().buildLiteral());
	}

}

aspect DummyDerivatives {

    rewrite FDerExp {
        when (myFV().isDummyDerivativeVariable()) to FDummyDerExp {
            return new FDummyDerExp(getFIdUse(), getOriginalVariable(), order());
        }
    }

    public void ASTNode.enableFHDerRewrite() {
        for (ASTNode n : this)
            n.enableFHDerRewrite();
    }

    public void FDerExp.enableFHDerRewrite() {
        rewriteFHDer = true;
        is$Final = false;
    }

    boolean FDerExp.rewriteFHDer = false;

    public void FDerivativeVariable.enableFHDerRewrite() {
        rewriteFHDer = true;
        is$Final = false;
    }

    boolean FDerivativeVariable.rewriteFHDer = false;

    rewrite FDerExp {
        when (rewriteFHDer && order() > 1) to FDerExp 
        new FDerExp(getFIdUse().getFQName().createDerPrefixedName(order() - 1));
    }

}

aspect TransformCanonicalErrorCheck {
	
	/**
	 * The number of DAE equations corresponds to the equivalent scalar number
	 * of equations.
	 */
	syn int FClass.numDAEEquations() = numScalarEquations();
	
	/**
	 * The number of equations in the DAE initialization system originating 
	 * from the DAE should be the same as the equivalent scalar number of
	 * equations. The equations may differ, however, due to inactive when
	 * clauses.
	 */
	syn int FClass.numDAEEquationsAtInitialization() 
		= numScalarEquationsAtInitialization();
	
	/**
	 * The number of unknown variables in the DAE corresponds to the number
	 * of real algebraic variables plus the number of derivative variables
	 * plus the number of discrete variables.
	 */
	syn int FClass.numDAEVariables() = 
        numNormalAlgebraicContinousRealVariables() + 
		numDerivativeVariables() + numDiscreteVariables();
	
    /**
     * This field is populated by computeMatchingsAndBLT, there are some models
     * where the initial system is defined so that pre propgation equations
     * such as x = pre(x) can't be inserted. These equations are then ignored
     * which must be accounted for during balance computations.
     */
    private int FClass.numIgnoredPrePropagationEquations = 0;

	/**
	 * The number of equations in the DAE initialization system is the 
	 * number of scalar DAE equations plus the number of scalar initial
	 * equations.
	 */	
	syn int FClass.numDAEInitEquations() = numDAEEquationsAtInitialization() + 
        numInitialScalarEquations() - numIgnoredPrePropagationEquations;
	
	/**
	 * The number of unknowns in the DAE initialization system is the 
	 * number of unknowns in the DAE system plus the number of differentiated
        * variables plus the number of (pre) discrete variables.
        */
       syn int FClass.numDAEInitVariables() = numDAEVariables() +
               numDifferentiatedRealVariables() + numDiscretePreVariables() +
               numInitialParameters() + numDynamicStates() - numDynamicAlgebraicVariables();

       public void FClass.checkFClassDimensions() {
               // Check dimensions of DAE
		int n_eq_F = numDAEEquations();
		int n_vars_F = numDAEVariables();
		if (n_eq_F != n_vars_F) 
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numDAEInitEquations();
		int n_vars_F0 = numDAEInitVariables();
		if (n_eq_F0 > n_vars_F0) 
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		
	}
	
	public void FClass.collectErrors(ErrorCheckType checkType) {
		checkFClassDimensions();
		checkStructure();
		allChecks(checkType);
	}
}

aspect FlushFClass {
	/**
	 * Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FExps in order to enable rewrites of such nodes after elimination 
	 * of alias variables and after function inlining.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}
	
	public void FExp.flushAllRecursiveClearFinal() {
		super.flushAllRecursiveClearFinal();
		is$Final = false;
	}

	/**
	 * Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (ASTNode n : noTransform()) {
			n.flushAllRecursive();
		}
	}
	
	/**
	 * Flush model AST and enable rewrites of FIdUseExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
	/**
	 * Traverse entire tree, forcing any pending rewrites to occur.
	 */
	public void ASTNode.forceRewrites() {
        for (ASTNode n : this) 
            n.forceRewrites();
	}
	
}



aspect Tearing {
	
	
}


aspect StateInitialEquations {

    public class FClass {
        public class addStateInitialEquationsIfSet extends Transformation {
            // Constraints: after alias elimination (see #), before BLT
            
            public addStateInitialEquationsIfSet() {
                super("state_initial_equations");
            }
            
            public void perform() {
                addStateInitialEquations();
            }
        }
    }

    public void FClass.addStateInitialEquations() {
        setFInitialEquationList(new List());
        
        for (FVariable fv : differentiatedRealVariables()) {
            FQName nameToAdd = fv.getFQName().copyAndAddPrefix("_start_");
            FRealVariable fvToAdd = new FRealVariable(VisibilityType.PUBLIC, Variability.FIXEDPARAMETER, nameToAdd);
            if (fv.startAttributeSet())
                fvToAdd.setBindingExp(fv.startAttributeExp().ceval().buildLiteral());
            else
                fvToAdd.setBindingExp(fv.type().zeroLiteral());
            addFVariable(fvToAdd);
            FEquation eqnToAdd = new FEquation(fv.createUseExp(), fvToAdd.createUseExp());
            addFInitialEquation(eqnToAdd);
            flushAllRecursive();
        }
    }

}

aspect SemiLinear {

    public class FClass {
        public class enableSemiLinearRewrite extends Transformation {
            private boolean changed = false;
            
            public void perform() {
                setFAbstractEquationList(transform(getFAbstractEquations()));
                setFInitialEquationList(transform(getFInitialEquations()));
                setParameterEquationList(transform(getParameterEquations()));
                
                // Change all remaining semiLinear exps to if exps.
                Set<FSemiLinearExp> fsls = collectSemiLinearExps();
                changed = changed || fsls.size() > 0;
                for (FSemiLinearExp exp: fsls)
                    exp.replaceMe(exp.asIfExp());
                
                if (changed) {
                    change();
                }
            }
            
            /**
             * Applies zero flow transformations to a list of equations.
             */
            private List<FAbstractEquation> transform(List<FAbstractEquation> equations) {
                ListMap<String, FEquation> rule1 = new LinkedHashListMap<String, FEquation>();
                ArrayList<FEquation> rule2 = new ArrayList<FEquation>();
                List<FAbstractEquation> newEquations = new List<FAbstractEquation>();
                
                // Find zero flow equations
                for (FAbstractEquation equation : equations) {
                    if (equation.isConstantZeroFlow()) {
                        rule2.add((FEquation) equation);
                    } else if (equation.isZeroFlowForm()) {
                        FEquation e = (FEquation) equation;
                        rule1.add(e.zeroFlowGetKey(), e);
                    }
                }
                
                // Chained zero flow transformations (Rule 1)
                for (java.util.List<FEquation> l : rule1.values()) {
                    if (l.size() > 1) {
                        transformChain(newEquations, buildChain(l));
                        changed = true;
                    }
                }
                
                changed = changed || rule2.size() > 0;
                
                // Constant zero flow transformations (Rule 2)
                for (FEquation equation : rule2) {
                    equation.setLeft(equation.zeroFlowGetPos());
                    equation.setRight(equation.zeroFlowGetNeg());
                }
                
                List<FAbstractEquation> res = removeMarkedEqns(equations);
                res.addAll(newEquations);
                return res;
            }
            
            /**
             * Order the equations in <code>l</code> by matching the slopes in
             * the semiLinear expressions. If any equation cannot be ordered an
             * error is given.
             */
            private ArrayList<FEquation> buildChain(java.util.List<FEquation> l) {
                ArrayList<FEquation> chain = new ArrayList<FEquation>();
                FEquation eq1 = l.remove(0);
                chain.add(eq1);
                
                boolean change = true;
                while (change) {
                    change = false;
                    Iterator<FEquation> it = l.iterator();
                    while (it.hasNext()) {
                        FEquation eq2 = it.next();
                        if (addToChain(chain, eq2)) {
                            change = true;
                            it.remove();
                        }
                    }
                }
                
                if (l.size() > 0) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Could not construct zero flow chain for a set of semilinear equations."
                            + " This leads to an undetermined system. Involved equations:\n");
                    
                    for (FEquation e : chain) {
                        sb.append(e.prettyPrint(""));
                        sb.append("\n");
                    }
                    for (FEquation e : l) {
                        sb.append(e.prettyPrint(""));
                        sb.append("\n");
                    }
                    
                    l.get(0).error(sb.toString());
                }
                return chain;
            }
            
            /**
             * Add an equation to the chain if the slopes match
             */
            private boolean addToChain(ArrayList<FEquation> chain, FEquation equation) {
                FExp pos = equation.zeroFlowGetPos();
                FExp neg = equation.zeroFlowGetNeg();
                FExp chainNeg = chain.get(chain.size()-1).zeroFlowGetNeg();
                FExp chainPos = chain.get(0).zeroFlowGetPos();
                
                if (chainNeg.prettyPrint("").equals(pos.prettyPrint(""))) {
                    chain.add(equation);
                    return true;
                } else if (chainPos.prettyPrint("").equals(neg.prettyPrint(""))) {
                    chain.add(0, equation);
                    return true;
                }
                return false;
            }
            
            /**
             * Build new equations to represent the chain of semiLinears
             */
            private void transformChain(List<FAbstractEquation> newEquations, ArrayList<FEquation> chain) {
                for (FEquation e : chain)
                    e.markedForRemoval = true;
                
                FEquation first = chain.get(0);
                FEquation last  = chain.remove(chain.size()-1);
                FExp chainPos   = first.zeroFlowGetPos();
                FExp chainNeg   = last.zeroFlowGetNeg();
                FExp chainX     = first.zeroFlowGetX();
                
                // S(1) = if X >= 0 SA else SB
                newEquations.add(new FEquation(
                        first.zeroFlowGetNeg().fullCopy(), 
                        new FIfExp(new FGeqExp(chainX.fullCopy(), new FIntegerLitExp(0)),
                                chainPos.fullCopy(),
                                chainNeg.fullCopy()
                                )));
                
                // S(n+1) = S(n)
                FEquation pre_e = null;
                for (FEquation e : chain) {
                    if (pre_e != null)
                        newEquations.add(new FEquation(e.zeroFlowGetNeg().fullCopy(), pre_e.zeroFlowGetNeg().fullCopy()));
                    pre_e = e;
                }
                
                // Y = semiLinear(X,SA,SB)
                FExp slExp = new FSemiLinearExp(chainX.fullCopy(), chainPos.fullCopy(), chainNeg.fullCopy());
                newEquations.add(new FEquation(
                        first.zeroFlowGetLeft().fullCopy(),
                        slExp.negated(first.zeroFlowNegated())
                        ));
            }
        }
    }
    
    syn boolean FAbstractEquation.isZeroFlowForm() = false;
    eq FEquation.isZeroFlowForm() { 
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return l.isZeroFlowForm(r) || r.isZeroFlowForm(l);
    }
    
    syn boolean FExp.isZeroFlowForm(FExp other) = false;
    eq FIdUseExp.isZeroFlowForm(FExp other) = other.isSemiLinear(); 
    
    syn boolean FAbstractEquation.isConstantZeroFlow() = false;
    eq FEquation.isConstantZeroFlow() { 
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        
        if (l.isZeroLiteral() && r.isSemiLinear()) {
            return ((FSemiLinearExp) r).getX().isZeroLiteral();
        }
        if (r.isZeroLiteral() && l.isSemiLinear()) {
            return ((FSemiLinearExp) l).getX().isZeroLiteral();
        }
        
        return false;
    }
    
    syn FIdUseExp FEquation.zeroFlowGetLeft() {
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return (FIdUseExp) (l.isSemiLinear() ? r : l);
    } 
    
    syn FSemiLinearExp FEquation.zeroFlowGetRight() {
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return (FSemiLinearExp) (l.isSemiLinear() ? l : r);
    } 
    syn FExp FEquation.zeroFlowGetX()     = zeroFlowGetRight().getX().stripNegations();
    syn FExp FEquation.zeroFlowGetPos()   = zeroFlowGetRight().getX().isNegated() ? zeroFlowGetRight().getNegSlope() : zeroFlowGetRight().getPosSlope();
    syn FExp FEquation.zeroFlowGetNeg()   = zeroFlowGetRight().getX().isNegated() ? zeroFlowGetRight().getPosSlope() : zeroFlowGetRight().getNegSlope();
    
    syn boolean FEquation.zeroFlowNegated() = isNegated() ^ zeroFlowGetRight().getX().isNegated();
    
    syn String FEquation.zeroFlowGetKey() {
        StringBuilder sb = new StringBuilder();
        if (zeroFlowNegated())
            sb.append("-");
        sb.append(zeroFlowGetLeft().prettyPrint(""));
        sb.append("$");
        sb.append(zeroFlowGetX().prettyPrint(""));
        return sb.toString();
    }
    
	
	syn boolean FExp.isSemiLinear() = false;
	eq FSemiLinearExp.isSemiLinear() = true;

    syn FExp FSemiLinearExp.asIfExp() {
        FExp exp = new FIfExp(new FGeqExp(getX().treeCopy(), new FIntegerLitExp(0)),
            new FMulExp(getX().treeCopy(), getPosSlope().treeCopy()),
            new FMulExp(getX().treeCopy(), getNegSlope().treeCopy()));
        if (isSmoothInSemiLinear()) {
            exp = new FNoEventExp(exp);
        }
        return exp;
    }

    /**
     * Checks if this expression allows a semiLinear() with it as argument to be smooth(0, ...).
     */
    syn boolean FExp.isSmoothInSemiLinear()  = false;
    eq FIdUseExp.isSmoothInSemiLinear()      = true;
    eq FLitExp.isSmoothInSemiLinear()        = true;
    eq FSmoothExp.isSmoothInSemiLinear()     = true;
    eq FNegExp.isSmoothInSemiLinear()        = getFExp().isSmoothInSemiLinear();
    eq FSemiLinearExp.isSmoothInSemiLinear() = 
        getX().isSmoothInSemiLinear() && getPosSlope().isSmoothInSemiLinear() && getNegSlope().isSmoothInSemiLinear();

	/**
	 * Collects semiLinear expressions.
	 */
	coll HashSet<FSemiLinearExp> FClass.collectSemiLinearExps() 
		[new HashSet<FSemiLinearExp>()] with add root FClass;
	FSemiLinearExp contributes this
		to FClass.collectSemiLinearExps()
		for myFClass();
}


aspect ReinitStates {
    
    public class FClass {
        /**
         * Transformation for marking up variables that have reinit() applied on them as states
         * (by setting stateSelect=always).
         */
        public class MakeReinitedVarsStates extends Transformation {
            public void perform() {
                for (FAbstractEquation eqn : getFAbstractEquations())
                    eqn.makeReinitedVarsStates();
            }
        }
    }
    
    /**
     * Mark all variables reinited in this equation as states.
     */
    public void FAbstractEquation.makeReinitedVarsStates() {}
    
    public void FIfWhenElseEquation.makeReinitedVarsStates() {
        for (FAbstractEquation e : getFAbstractEquations())
            e.makeReinitedVarsStates();
    }
    
    public void FIfWhenEquation.makeReinitedVarsStates() {
        super.makeReinitedVarsStates();
        if (hasElse())
            getElse().makeReinitedVarsStates();
    }
    
    public void FFunctionCallEquation.makeReinitedVarsStates() {
        getCall().makeReinitedVarsStates();
    }
    
    /**
     * It this is a reinit(), mark reinited variable as state.
     */
    public void FAbstractFunctionCall.makeReinitedVarsStates() {}

    /**
     * Mark reinited variable as state.
     */
    public void FReinit.makeReinitedVarsStates() {
        getVar().markReferencedVarAsState();
    }
    
    /**
     * Mark referenced variable as state.
     * 
     * Only valid for variable accesses, default implementation throws exception.
     */
    public void FExp.markReferencedVarAsState() {
        throw new UnsupportedOperationException();
    }
    
    /**
     * Mark referenced variable as state.
     */
    public void FIdUseExp.markReferencedVarAsState() {
        myFV().markAsState();
    }
    
    /**
     * Mark this variable as a state, by setting stateSelect=always.
     */
    public void FAbstractVariable.markAsState() {
        throw new UnsupportedOperationException();
    }
    
    public void FVariable.markAsState() {
        FAttribute newA = new FInternalAttribute(FAttribute.STATE_SELECT, new FEnumLitExp(FAttribute.STATE_SELECT_TYPE, "always"));
        FAttribute oldA = findAttributeLocal(FAttribute.STATE_SELECT);
        if (oldA != null) {
            oldA.replaceMe(newA);
            addFAttribute(oldA);
        } else {
            addFAttribute(newA);
        }
    }
    
}

aspect FunctionAndRecordCleanup {
    /**
     * Remove unused function and record declarations from the flat model.
     */
    public void FClass.removeUnusedFunctionsAndRecords() {
        beginStep("removeUnusedFunctionsAndRecords()");
        for (FFunctionDecl decl : getFFunctionDecls())
            decl.resetUsedIndicator();
        for (FRecordDecl decl : getFRecordDecls())
            decl.resetUsedIndicator();
        getFVariables().markUsedFunctionsAndRecords();
        getFInitialEquations().markUsedFunctionsAndRecords();
        getParameterEquations().markUsedFunctionsAndRecords();
        getFAbstractEquations().markUsedFunctionsAndRecords();
        getDynamicStateManager().markUsedFunctionsAndRecords();
        List<FFunctionDecl> funcs = new List<FFunctionDecl>();
        for (FFunctionDecl func : getFFunctionDecls())
            if (func.functionIsUsed())
                funcs.add(func);
        setFFunctionDeclList(funcs);
        List<FRecordDecl> records = new List<FRecordDecl>();
        for (FRecordDecl decl : getFRecordDecls())
            if (decl.isRecordUsed())
                records.add(decl);
        setFRecordDeclList(records);
        endStep("removeUnusedFunctionsAndRecords()");
    }
    
    public class FFunctionDecl {
        public enum UseType{
            NONE(false, false),
            ALIAS_ATTRIBUTE_USE(false, false),
            ANNOTATION_DERIVATIVE(true, false),
            DIRECT(true, true);
            
            private final boolean normalUse;
            private final boolean derivativeUse;
            UseType(boolean normalUse, boolean derivativeUse) {
                this.normalUse = normalUse;
                this.derivativeUse = derivativeUse;
            }
            public boolean normalUse() {
                return normalUse;
            }
            public boolean derivativeUse() {
                return derivativeUse;
            }
            
            public UseType combine(UseType other) {
                return compareTo(other) > 0 ? this : other;
            }
        }
    }
    
    private UseType FFunctionDecl.functionUsed = UseType.NONE;
    
    public void FFunctionDecl.resetUsedIndicator() {
        functionUsed = UseType.NONE;
    }
    
    /**
     * Has this function been marked as used?
     */
    syn boolean FFunctionDecl.functionIsUsed() = functionUsed != UseType.NONE;
    
    /**
     * Has this function been marked as used?
     */
    syn boolean FFunctionDecl.functionIsUsedAsDerivative() = functionUsed.derivativeUse();
    
    private boolean FRecordDecl.recordUsed = false;
    
    public void FRecordDecl.resetUsedIndicator() {
        recordUsed = false;
    }
    
    syn boolean FRecordDecl.isRecordUsed() = recordUsed;
    
    /**
     * Mark all called functions as used.
     */
    public final void ASTNode.markUsedFunctionsAndRecords() {
        markUsedFunctionsAndRecords(FFunctionDecl.UseType.DIRECT);
    }
    public void ASTNode.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        for (ASTNode node : this)
            node.markUsedFunctionsAndRecords(type);
    }
    
    @Override
    public void FVariable.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        AliasManager.AliasSet set = aliasSet();
        if (type != FFunctionDecl.UseType.ALIAS_ATTRIBUTE_USE && set != null)
            for (AliasManager.AliasVariable alias : set)
                if (alias.getFVariable() != this)
                    alias.getFVariable().markUsedFunctionsAndRecords(FFunctionDecl.UseType.ALIAS_ATTRIBUTE_USE);
        super.markUsedFunctionsAndRecords(type);
    }
    
    public void FExternalObjectVariable.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        super.markUsedFunctionsAndRecords(type);
        getDestructorCall().markUsedFunctionsAndRecords(type);
    }
    
    @Override
    public void FFunctionCall.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        myFCallable().markUsedFunctionsAndRecords(type);
        super.markUsedFunctionsAndRecords(type);
    }
    
    public interface FCallable {
        public void markUsedFunctionsAndRecords(FFunctionDecl.UseType type);
    }
    
    @Override
    public void FFunctionDecl.markUsedFunctionsAndRecords(UseType type) {
        UseType oldType = functionUsed;
        functionUsed = functionUsed.combine(type);
        if (functionUsed != oldType) {
            markUsedFunctionsAndRecordsExtra(type);
            super.markUsedFunctionsAndRecords(functionUsed);
        }
    }
    
    public void FFunctionDecl.markUsedFunctionsAndRecordsExtra(UseType type) {
        // Hook to facilitate extensions
    }
    
    @Override
    public void FFunctionVariable.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        super.markUsedFunctionsAndRecords(type);
        if (type().isFunction()) {
            myFCallable().markUsedFunctionsAndRecords(type);
        }
    }
    
    @Override
    public void FType.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        super.markUsedFunctionsAndRecords(type);
        getSize().markUsedFunctionsAndRecords(type);
    }
    
    public void Size.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        
    }
    
    @Override
    public void MutableSize.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        for (FExp e : exps)
            if (e != null)
                e.markUsedFunctionsAndRecords(type);
    }
    
    @Override
    public void FRecordType.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        super.markUsedFunctionsAndRecords(type);
        myFRecordDecl().markUsedFunctionsAndRecords(type);
    }
    
    @Override
    public void FRecordConstructor.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        super.markUsedFunctionsAndRecords(type);
        getRecord().myFRecordDecl().markUsedFunctionsAndRecords(type);
    }
    
    @Override
    public void FRecordDecl.markUsedFunctionsAndRecords(FFunctionDecl.UseType type) {
        if (!recordUsed) {
            recordUsed = true;
            super.markUsedFunctionsAndRecords(type);
        }
    }
    
}
