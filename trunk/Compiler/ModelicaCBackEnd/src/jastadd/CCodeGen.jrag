/*
Copyright (C) 2009 Modelon AB
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.PrintStream;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;

aspect CCodeGen {
	
	class CPrettyPrinter extends Printer {
		
		public CPrettyPrinter() {
			super("    ");
		}
		
 		public void print(ASTNode node, PrintStream str, String indent) { 
 			node.prettyPrint_C(this, str, indent); 
 		}
  		
  		public String op(FBinExp e) { return e.op_C(); }
	}
	
	static CPrettyPrinter ASTNode.printer_C = new CPrettyPrinter();
	
	public String ASTNode.prettyPrint_C(String indent) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		PrintStream str = new PrintStream(os);
		prettyPrint_C(str,indent);
		return os.toString();
	}

	public void ASTNode.prettyPrint_C(PrintStream str, String indent) {
 		prettyPrint_C(printer_C, str, indent);
	}

	public void ASTNode.prettyPrint_C(Printer p, PrintStream str, String indent) {
 		prettyPrint(p, str, indent);
	}
	
	public void FDotPowExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		int exponent = 100;
		if (getRight().variability().constantVariability() && getRight().type().isInteger()) 
			exponent = getRight().ceval().intValue();
		if (exponent < 10 && exponent > -10) {
			str.print("(");
			String op = (exponent > 0) ? " * " : " / ";
			exponent = Math.abs(exponent);
			str.print("1.0");
			for (int i = 0; i < exponent; i++) {
				str.print(op);
				str.print("(");
				p.print(getLeft(), str, indent); 
				str.print(")");
			}
			str.print(")");
		} else {
			str.print("pow(");
			p.print(getLeft(),str,indent); 
			str.print(",");
			p.print(getRight(),str,indent);
			str.print(")");
		}
	}
	
	public void FMinMaxExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("jmi_" + builtInName() + "(");
		p.print(getX(), str, indent); 
		str.print(", ");
		p.print(getY(), str, indent);
		str.print(")");
	}
		
	public void FDerExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("(");
			str.print(myFV().name_C());
			str.print("*sf(");
			str.print(myFV().valueReference());
			str.print("))");
		} else {
			str.print(myFV().name_C());
		}
	}

	public void FDummyDerExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("(");
			str.print(myFV().name_C());
			str.print("*sf(");
			str.print(myFV().valueReference());
			str.print("))");
		} else {
			str.print(myFV().name_C());
		}
	}

	public void FPreExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (myFV().isReal() && !inFunction() && 
				root().options.getBooleanOption("enable_variable_scaling")) {
			str.print("(");
			str.print("pre" + ((FIdUseExp)getFExp()).myFV().name_C());
			str.print("*sf(");
			str.print(((FIdUseExp)getFExp()).myFV().valueReference());
			str.print("))");
		} else {
			str.print("pre" + ((FIdUseExp)getFExp()).myFV().name_C());
		}
	}
	
	public void FSampleExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("jmi_sample(jmi,");
		p.print(getOffset(),str,"");
		str.print(",");
		p.print(getInterval(),str,"");
		str.print(")");
	}
	
	public void FTimeExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("_time");
	}
	
	public void FEnumIntegerExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		p.print(getFExp(), str, indent);
	}
	
	public void FEnumLitExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (inIfCondition()) 
			str.print("AD_WRAP_LITERAL(");
		str.print(ceval().intValue());
		if (inIfCondition()) 
			str.print(")");
	}
	
	public void FIdUseExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (isArray() && keepAsArray()) {
			str.print(getFIdUse().toString_C(p));
		} else {
			if (myFV().isReal() && !inFunction() && 
					root().options.getBooleanOption("enable_variable_scaling")) {
				str.print("(");
				p.print(getFIdUse(), str, indent);
				str.print("*sf(");
				str.print(myFV().valueReference());
				str.print("))");
			} else {
				p.print(getFIdUse(), str, indent);
			}
		}
	}
	
	inh boolean FIdUse.isAssignUse();
	eq InstNode.getChild().isAssignUse()          = false;
	eq FClass.getChild().isAssignUse()            = false;
	eq FIdUseExp.getChild().isAssignUse()         = false;
	eq FFunctionCallLeft.getChild().isAssignUse() = true;
	eq FAssignStmt.getChild().isAssignUse()       = true;
	
	syn String FIdUse.name_C() = toString_C(printer_C);
	
	syn String FIdUse.toString_C(Printer p) {
		String type = myFV().funcArrayType(isAssignUse());
		if (myFV().inRecord() && inFunction()) 
			return myRecordFV().genRecordUse_C(p, getFQName(), type);
		else
			return myFV().genUse_C(p, getFQName().getLastFArraySubscripts(), type);
	}
	
	public void FIdUse.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print(toString_C(p));
	}
	
	public String AbstractFVariable.genUse_C(Printer p, FArraySubscripts fas, String type) {
		return name_C();
	}
	
	public String FFunctionArray.genUse_C(Printer p, FArraySubscripts fas, String type) {
		if (fas == null)
			return name_C();
		else
			return fas.genFunctionArrayUse_C(p, name_C(), type);
	}
	
	public String FArraySubscripts.genFunctionArrayUse_C(Printer p, String name, String type) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();	
		PrintStream str = new PrintStream(os);
		str.print("jmi_array_");
		str.print(type);
		str.print("_");
		str.print(getNumFSubscript());
		str.print("(");
		str.print(name);
		str.print(", ");
		getFSubscripts().prettyPrintWithSep(p, str, "", ", ");
		str.print(")");
		return os.toString();
	}
	
	public String AbstractFVariable.genRecordUse_C(Printer p, FQName name, String type) {
		FQNamePart part = name.getFQNamePart(0);
		FArraySubscripts fas = part.hasFArraySubscripts() ? part.getFArraySubscripts() : null;
		String res = genUse_C(p, fas, C_ARRAY_RECORD);
		for (int i = 1, n = name.getNumFQNamePart(); i < n; i++) {
			part = name.getFQNamePart(i);
			res = res + "->" + part.getName();
			if (part.hasFArraySubscripts()) {
				String curType = (n - i > 1 ? C_ARRAY_RECORD : type);
				res = part.getFArraySubscripts().genFunctionArrayUse_C(p, res, curType);
			}
		}
		return res;
	}	
	
	public void FFunctionCall.prettyPrint_C(Printer p, PrintStream str, String indent) {
		boolean exp = functionCallIsExp();
		if (!exp)
			str.print(indent);
		str.print(getName().funcNameUnderscore(exp ? C_SUFFIX_EXP : C_SUFFIX_DEF));
		str.print("(");
		String sep = "";
		for (FExp arg : getArgs()) {
			str.print(sep);
			arg.genArgument_C(p, str, indent);
			sep = ", ";
		}
		if (!exp) {
			int tot = myOutputs().size();
			int lefts = myLefts().size();
			for (int i = 0; i < tot; i++) {
				str.print(sep);
				if (i < lefts)
					myLefts().get(i).genArgument_C(str);
				else
					str.print("NULL");
				sep = ", ";
			}
		}
		str.print(")");
	}
	
	public String FunctionReturnDefinition.getDeclaredType_C() {
		if (outputs.size() > 0) 
			return outputs.get(0).type_C();
		else
			return "void";
	}
	
	public void FunctionReturnDefinition.printReturnForExp_C(PrintStream str, String indent) {
		str.print(indent);
		str.print("return");
		if (outputs.size() > 0) { 
			str.print(" ");
			str.print(outputs.get(0).name_C());
		}
		str.print(";\n");
	}
	
	public void FunctionReturnDefinition.printDeclarationForExp_C(Printer p, PrintStream str, String indent) {
		if (outputs.size() > 0) 
			outputs.get(0).genVarDecls_C(p, str, indent);
	}
	
	public void FunctionReturnDefinition.printReturnWrite_C(PrintStream str, String indent) {
		for (FFunctionVariable v : outputs) 
			v.printReturnWrite_C(str, indent);
	}
	
	private void FFunctionDecl.prettyPrintHead_C(Printer p, PrintStream str, String indent, 
			String type, String suffix, boolean returnArgs) {
		str.print(indent);
		str.print(type);
		str.print(" ");
		str.print(getFQName().funcNameUnderscore(suffix));
		str.print("(");
		String sep = "";
		for (FFunctionVariable v : myInputs()) {
			str.print(sep);
			v.printArgument_C(str);
			sep = ", ";
		}
		if (returnArgs) {
			for (FFunctionVariable v : myOutputs()) {
				str.print(sep);
				v.printReturnArgument_C(str);
				sep = ", ";
			}
		}
		str.print(")");
	}
	
	private void FFunctionDecl.prettyPrintWrappedCall_C(PrintStream str, String indent) {
		str.print(indent);
		str.print(getFQName().funcNameUnderscore(C_SUFFIX_DEF));
		str.print("(");
		String sep = "";
		for (FFunctionVariable v : myInputs()) {
			str.print(sep);
			str.print(v.name_C());
			sep = ", ";
		}
		if (myOutputs().size() > 0) {
			str.print(sep);
			str.print("&");
			str.print(myOutputs().get(0).name_C());
			for (int i = myOutputs().size() - 1; i > 0; i--)
				str.print(", NULL");
		}
		str.print(");\n");
	}
	
	public void FFunctionDecl.genHeader_C(PrintStream str, String indent) {
		prettyPrintHead_C(printer_C, str, indent, "void", C_SUFFIX_DEF, true);
		str.print(";\n");
    	if (generateExpFunction()) {
    		String type = returnDefinition().getDeclaredType_C();
			prettyPrintHead_C(printer_C, str, indent, type, C_SUFFIX_EXP, false);
			str.print(";\n");
    	}
	}
	
	public void FFunctionDecl.prettyPrint_C(Printer p, PrintStream str, String indent) {
		String next = p.indent(indent);
		// Print definition
		prettyPrintHead_C(p, str, indent, "void", C_SUFFIX_DEF, true);
		str.print(" {\n");
		// TODO: Check if there are any dynamic declarations first
		str.print(next + "JMI_DYNAMIC_INIT()\n");
		genVarDecls_C(p, str, p.indent(indent));
		for (FFunctionVariable ffv : myNonInputs())
			p.print(ffv, str, next);
		for (FFunctionVariable ffv : myOutputs())
			ffv.printNullOutputReplacement_C(p, str, next);
    	p.print(getFAlgorithmBlock(), str, next);
    	str.print(indent);
    	str.print("}\n\n");
    	
    	// Print wrapper for expressions
    	if (generateExpFunction()) {
	    	String type = returnDefinition().getDeclaredType_C();
			prettyPrintHead_C(p, str, indent, type, C_SUFFIX_EXP, false);
			str.print(" {\n");
			returnDefinition().printDeclarationForExp_C(p, str, next);
			prettyPrintWrappedCall_C(str, next);
			returnDefinition().printReturnForExp_C(str, next);
	    	str.print(indent);
	    	str.print("}\n\n");
    	}
	}
	
	/**
	 * \brief Check if we need to generate a wrapper for expressions for this function.
	 */
	syn boolean FFunctionDecl.generateExpFunction() = hasOutputs() && !isComposite();
	
	syn String FRecordDecl.name_C()      = getFQName().lastFQNamePart().getName() + "_" + 
										       recordIndex() + "_" + C_SUFFIX_RECORD;
	syn String FRecordDecl.nameArray_C() = name_C() + C_SUFFIX_ARRAY;
	syn String FRecordType.name_C()      = myFRecordDecl().name_C();
	syn String FRecordType.nameArray_C() = myFRecordDecl().nameArray_C();
	
	// TODO: Handle arrays of records and arrays in records
	public void FRecordDecl.prettyPrint_C(Printer p, PrintStream str, String indent) {
		// Record type (struct)
		str.print(indent);
		str.print("typedef struct _");
		str.print(name_C());
		str.print(" {\n");
		String next = p.indent(indent);
		for (FVariable fv : getFVariables())
			fv.printInRecord_C(p, str, next);
		str.print(indent);
		str.print("} ");
		str.print(name_C());
		str.print(";\n");
		
		// Array record type
		str.print(indent);
		str.print("JMI_RECORD_ARRAY_TYPE(");
		str.print(name_C());
		str.print(", ");
		str.print(nameArray_C());
		str.print(")\n\n");
	}
	
	public void FVariable.printInRecord_C(Printer p, PrintStream str, String indent) {
		str.print(indent);
		str.print(type_C());
		str.print(" ");
		str.print(nameUnderscore());
		str.print(";\n");
	}
	
	// Suffixes that are used with variables in JMI: size, var, arr, rec
	public static final String ASTNode.C_SUFFIX_DEF      = "def";
	public static final String ASTNode.C_SUFFIX_EXP      = "exp";
	public static final String ASTNode.C_SUFFIX_RECORD   = "r";
	public static final String ASTNode.C_SUFFIX_INDEX    = "i";
	public static final String ASTNode.C_SUFFIX_VARIABLE = "v";
	public static final String ASTNode.C_SUFFIX_ARRAY    = "a";
	public static final String ASTNode.C_SUFFIX_RETURN   = "o";
	public static final String ASTNode.C_SUFFIX_NULL     = "n";

	public static final String ASTNode.C_ARRAY_RECORD    = "rec";
	public static final String ASTNode.C_ARRAY_REFERENCE = "ref";
	public static final String ASTNode.C_ARRAY_VALUE     = "val";
	
	syn String AbstractFVariable.funcArrayType(boolean assign) = 
		isRecord() ? C_ARRAY_RECORD : (assign ? C_ARRAY_REFERENCE : C_ARRAY_VALUE);

	syn lazy String AbstractFVariable.name_C() = null;
	eq FVariable.name_C()           = isForIndex() ? 
			                                    nameUnderscore() + '_' + C_SUFFIX_INDEX :
			                              '_' + nameUnderscore() + '_' + variableIndex();
	eq FPreRealVariable.name_C()    =  "pre_" + nameUnderscore() + '_' + variableIndex();
	eq FPreBooleanVariable.name_C() =  "pre_" + nameUnderscore() + '_' + variableIndex();
	eq FPreIntegerVariable.name_C() =  "pre_" + nameUnderscore() + '_' + variableIndex();
	eq FPreStringVariable.name_C()  =  "pre_" + nameUnderscore() + '_' + variableIndex();
	eq FPreEnumVariable.name_C()    =  "pre_" + nameUnderscore() + '_' + variableIndex();

	eq FFunctionVariable.name_C() = nameUnderscore() + "_" + C_SUFFIX_VARIABLE;
	eq FFunctionArray.name_C()    = nameUnderscore() + "_" + C_SUFFIX_ARRAY;
	
	syn String FFunctionVariable.nameReturn_C() = 
		isRecord() ? name_C() : (getFQName().nameUnderscore() + "_" + C_SUFFIX_RETURN);
	syn String FFunctionArray.nameReturn_C()    = name_C();
	
	syn String AbstractFVariable.type_C() = type().type_C();
	syn String FFunctionCallLeft.type_C() = type().type_C();
	
	syn String FType.type_C() = isArray() ? arrayType_C() : scalarType_C();
	
	syn String FType.argType_C() = type_C();
	syn String FPrimitiveType.argType_C() = "jmi_ad_var_t";
	syn String FIntegerType.argType_C() = "jmi_int_t";
	
	syn String FType.scalarType_C() = "jmi_ad_var_t";
	eq FRecordType.scalarType_C()   = name_C() + "*";
	
	syn String FType.arrayType_C() = "jmi_array_t*";
	eq FRecordType.arrayType_C()   = nameArray_C() + "*";

	syn String FFunctionVariable.typeReturn_C() = isRecord() ? type_C() : (type_C() + "*");
	eq FFunctionArray.typeReturn_C()            = type_C();
	
	public void FFunctionVariable.printReturnArgument_C(PrintStream str) {
		str.print(typeReturn_C());
		str.print(" ");
		str.print(nameReturn_C());
	}
	
	public void FFunctionVariable.printReturnWrite_C(PrintStream str, String indent) {
		if (!isRecord()) {
			str.print(indent);
			str.print("if (");
			str.print(nameReturn_C());
			str.print(" != NULL) *");
			str.print(nameReturn_C());
			str.print(" = ");
			str.print(name_C());
			str.print(";\n");
		}
	}
	
	public void FFunctionArray.printReturnWrite_C(PrintStream str, String indent) {}
	
	public void FFunctionVariable.printArgument_C(PrintStream str) {
		str.print(type_C());
		str.print(" ");
		str.print(name_C());
	}
	
	private FExp FFunctionVariable.dummyFExp = null;
	
	public void FFunctionVariable.printDeclOrInit_C(
			Printer p, PrintStream str, String indent, String name, boolean decl) {
		// This is a rather ugly hack, but we temporarily need an FExp that is in the tree
		if (!hasBindingExp()) {
			if (dummyFExp == null) 
				dummyFExp = new FNoExp();
			setBindingExp(dummyFExp);
		}
		if (decl)
			type().printDecl_C(p, str, indent, name, getBindingExp());
		else
			type().printInit_C(p, str, indent, name, getBindingExp());
		if (dummyFExp != null)
			setBindingExpOpt(new Opt());
	}	
	
	public void FFunctionVariable.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (!isOutput() || !isRecord())
			printDeclOrInit_C(p, str, indent, name_C(), false);
	}
	
	public void FFunctionArray.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (!isOutput()) 
			printDeclOrInit_C(p, str, indent, name_C(), false);
	}
	
	public void FFunctionVariable.printNullOutputReplacement_C(Printer p, PrintStream str, String indent) {
		if (isComposite()) {
			String name_C = name_C();
			String name_r = name_C + C_SUFFIX_NULL;
			String next = p.indent(indent);
			str.print(indent + "if (" + name_C + " == NULL) {\n");
			printDeclOrInit_C(p, str, next, name_r, false);
			str.print(next + name_C + " = " + name_r + ";\n");
			str.print(indent + "}\n");
		}
	}
	
	syn String FType.arrayMacroType_C() = "JMI_ARRAY";
	eq FRecordType.arrayMacroType_C()   = "JMI_RECORD_ARRAY";
	
	syn String FType.arrayDeclExtraArgs_C() = "";
	eq FRecordType.arrayDeclExtraArgs_C()   = name_C() + ", " + nameArray_C() + ", ";
	
	syn String FType.arrayInitExtraArgs_C() = "";
	eq FRecordType.arrayInitExtraArgs_C()   = name_C() + ", ";
	
	public void FType.printDecl_C(Printer p, PrintStream str, String indent, String name, FExp src) {
		if (isArray()) {
			boolean unknown = size().isUnknown();
			str.format("%s%s_%s(%s%s, ", indent, arrayMacroType_C(), 
					(unknown ? "DYNAMIC" : "STATIC"), arrayDeclExtraArgs_C(), name);
			if (!unknown) {
				size().printNumElements_C(p, str, indent, src);
				str.print(", ");
			}
			str.print(ndims() + ")\n");
		} else {
			str.print(indent + type_C() + " " + name + ";\n");
		}
	}
	
	public void FType.printInit_C(Printer p, PrintStream str, String indent, String name, FExp src) {
		if (isArray()) {
			boolean unknown = size().isUnknown();
			str.format("%s%s_%s_INIT_%d(%s%s, ", indent, arrayMacroType_C(), 
					(unknown ? "DYNAMIC" : "STATIC"), ndims(), arrayInitExtraArgs_C(), name);
			if (unknown) {
				size().printNumElements_C(p, str, indent, src);
				str.print(", ");
			}
			size().printDimensions_C(p, str, indent, src);
			str.print(")\n");
		}
	}
	
	public void FRecordType.printDecl_C(Printer p, PrintStream str, String indent, String name, FExp src) {
		if (isArray()) {
			super.printDecl_C(p, str, indent, name, src);
			String pre = "jmi_array_rec_" + ndims() + "(" + name + ", ";
			for (Index i : indices()) // TODO: this doesn't work for the dynamic case
				printChildDecls_C(p, str, indent, pre + i.toUnclosedString() + ")", src);
		} else {
			str.print(indent + "JMI_RECORD_STATIC(" + name_C() + ", " + name + ")\n");
			printChildDecls_C(p, str, indent, name, src);
		}
	}
	
	public void FRecordType.printInit_C(Printer p, PrintStream str, String indent, String name, FExp src) {
		if (isArray()) {
			super.printInit_C(p, str, indent, name, src);
			String pre = "jmi_array_rec_" + ndims() + "(" + name + ", ";
			for (Index i : indices()) // TODO: this doesn't work for the dynamic case
				printChildInits_C(p, str, indent, pre + i.toUnclosedString() + ")", src);
		} else {
			printChildInits_C(p, str, indent, name, src);
		}
	}
	
	private Map<String,String> FExp.recordChildTempNameMap = null;
	
	public Map<String,String> FExp.recordChildTempNames() {
		if (recordChildTempNameMap == null)
			recordChildTempNameMap = new HashMap<String,String>();
		return recordChildTempNameMap;
	}
	
	public void FRecordType.printChildDecls_C(Printer p, PrintStream str, String indent, String name, FExp src) {
		for (FRecordComponentType comp : getComponents()) {
			if (comp.getFType().isComposite()) {
				String compName = name + "->" + comp.getName();
				String tempName = "tmp_" + nextTempNbr_C();
				src.recordChildTempNames().put(compName, tempName);
				comp.getFType().printDecl_C(p, str, indent, tempName, src);
			}
		}
	}
	
	public void FRecordType.printChildInits_C(Printer p, PrintStream str, String indent, String name, FExp src) {
		for (FRecordComponentType comp : getComponents()) {
			if (comp.getFType().isComposite()) {
				String compName = name + "->" + comp.getName();
				String tempName = src.recordChildTempNames().get(compName);
				comp.getFType().printInit_C(p, str, indent, tempName, src);
				str.print(indent + compName + " = " + tempName + ";\n");
			}
		}
	}

	public void Size.printNumElements_C(Printer p, PrintStream str, String indent, FExp src) {
		str.print(numElements());
	}

	public void Size.printDimensions_C(Printer p, PrintStream str, String indent, FExp src) {
		str.print(toUnclosedString());
	}
	
	public void MutableSize.printNumElements_C(Printer p, PrintStream str, String indent, FExp src) {
		if (isUnknown()) {
			FQName empty = new FQName();
			// TODO: do we really need to flatten here?
			FExp numElem = src.dynamicFExp(createNumElementsFExp().flatten(empty));
			p.print(numElem, str, indent);
		} else {
			super.printNumElements_C(p, str, indent, src);
		}
	}
	
	public void MutableSize.printDimensions_C(Printer p, PrintStream str, String indent, FExp src) {
		if (isUnknown()) {
			FQName empty = new FQName();
			for (int i = 0; i < size.length; i++) {
				if (i > 0)
					str.print(", ");
				if (exps[i] == null) {
					str.print(size[i]);
				} else {
					// TODO: do we really need to flatten here?
					FExp exp = src.dynamicFExp(exps[i].flatten(empty));
					p.print(exp, str, indent);
				}
			}
		} else {
			super.printDimensions_C(p, str, indent, src);
		}
	}
	
	public void ASTNode.genVarDecls_C(Printer p, PrintStream str, String indent) {
		for (ASTNode node : this)
			node.genVarDecls_C(p, str, indent);
	}
	
	public void FFunctionVariable.genVarDecls_C(Printer p, PrintStream str, String indent) {
		if (!isInput()) {
			String suffix = (isOutput() && isComposite()) ? C_SUFFIX_NULL : "";
			printDeclOrInit_C(p, str, indent, name_C() + suffix, true);
		}
	}
	
	public void FExp.genVarDecls_C(Printer p, PrintStream str, String indent) {
		if (isArray() && !size().isUnknown())
			getArray().genVarDecls_C(p, str, indent);
		else
			super.genVarDecls_C(p, str, indent);
	}
	
	public void FFunctionCall.genVarDecls_C(Printer p, PrintStream str, String indent) {
		super.genVarDecls_C(p, str, indent);
		for (FExp arg : getArgs()) 
			arg.genTempInputDecl_C(p, str, indent);
	}
	
	public void FFunctionCallLeft.genVarDecls_C(Printer p, PrintStream str, String indent) {
		super.genVarDecls_C(p, str, indent);
		if (hasFExp())
			getFExp().genTempOutputDecl_C(p, str, indent);
	}
	
	public void FExp.genTempInputDecl_C(Printer p, PrintStream str, String indent) {
		if (isComposite() && !keepAsArray()) 
			type().printDecl_C(p, str, indent, tempName_C(), this);
	}
	
	public void FExp.genTempOutputDecl_C(Printer p, PrintStream str, String indent) {}
	
	public void FArray.genTempOutputDecl_C(Printer p, PrintStream str, String indent) {
		type().printDecl_C(p, str, indent, tempName_C(), this);
	}
	
	public void FRecordConstructor.genTempOutputDecl_C(Printer p, PrintStream str, String indent) {
		type().printDecl_C(p, str, indent, tempName_C(), this);
	}

	
	public void FExternalStmt.genVarDecls_C(Printer p, PrintStream str, String indent) {
		super.genVarDecls_C(p, str, indent);
		getFExternalLanguage().genVarDecls_C(p, str, indent, this);
	}
	
	public void FExternalLanguage.genVarDecls_C(
			Printer p, PrintStream str, String indent, FExternalStmt stmt) {}
	
	public void FFortran77ExternalLanguage.genVarDecls_C(
			Printer p, PrintStream str, String indent, FExternalStmt stmt) {
		for (FExp arg: stmt.getArgs()) 
			if (arg.ndims() > 1) // We need temp var if we have >2 dimensions
				arg.type().printDecl_C(p, str, indent, arg.tempName_C(), arg);				
	}
	
	
	public void FAlgorithmBlock.prettyPrint_C(Printer p, PrintStream str, String indent) {
		p.print(getFStatements(), str, indent);
	}
	
	public void FFunctionCallStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (!getCall().isIgnored()) {
			genTempVars_C(p, str, indent);
			str.print(indent);
			p.print(getCall(), str, "");
			str.print(";\n");
		}
	}

	public void FAssignStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		genTempVars_C(p, str, indent);
		str.print(indent);
		p.print(getLeft(), str, indent);
		str.print(" = ");
		p.print(getRight(), str, indent);
		str.print(";\n");
	}
	
	public void FReturnStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		returnDefinition().printReturnWrite_C(str, indent);
		// TODO: Check if there are any dynamic declarations first
		str.print(indent + "JMI_DYNAMIC_FREE()\n");
		str.print(indent + "return;\n");
	}
	
	public void FIfWhenStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		for (FIfWhenClause clause : getFIfWhenClauses())
			clause.getTest().genTempVars_C(p, str, indent);
		str.print(indent);
		getFIfWhenClauses().prettyPrintWithSep(p, str, indent, indent + "} else ");
		prettyPrintElse_C(p, str, indent);
		str.print(indent);
		str.print("}\n");
	}
	
	protected void FIfWhenStmt.prettyPrintElse_C(Printer p, PrintStream str, String indent) {}
	
	protected void FIfStmt.prettyPrintElse_C(Printer p, PrintStream str, String indent) {
		if (getNumElseStmt() > 0) {
			str.print(indent);
			str.print("} else {\n");
			p.print(getElseStmts(), str, p.indent(indent));
		}
	}
	
	public void FIfWhenClause.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("if (");
		p.print(getTest(), str, indent);
		str.print(") {\n");
		p.print(getFStatements(), str, p.indent(indent));
	}
	
	public void FWhileStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		getTest().genTempVars_C(p, str, indent);
		str.print(indent);
		str.print("while (");
		p.print(getTest(), str, "");
		str.print(") {\n");
		p.print(getWhileStmts(), str, p.indent(indent));
		str.print("}\n");		
	}
	
	public void FForStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		getIndex().genTempVars_C(p, str, indent);
		getIndex().printForArrayDecl_C(p, str, indent);
		str.print(indent);
		str.print("for (");
		p.print(getIndex(), str, indent);
		str.print(") {\n");
		getIndex().printForArrayNext_C(p, str, p.indent(indent));
		p.print(getForStmts(), str, p.indent(indent));
		str.print(indent);		
		str.print("}\n");		
	}
	
	public void FForIndex.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (hasFExp()) 
			getFExp().printForIndex_C(p, str, indent, getFVariable().name_C());
	}
	
	// TODO: Declare in genVarDecls_C instead
	public void FForIndex.printForArrayDecl_C(Printer p, PrintStream str, String indent) {
		if (needsForArray()) {
			str.print(indent);
			str.print("jmi_ad_var_t ");
			str.print(getFVariable().name_C());
			str.print("a[] = { ");
			getFExp().getArray().getFExps().prettyPrintWithSep(p, str, indent, ", ");
			str.print(" };\n");
		}
	}
	
	// TODO: Declare in genVarDecls_C instead
	public void FForIndex.printForArrayNext_C(Printer p, PrintStream str, String indent) {
		if (needsForArray()) {
			String name = getFVariable().name_C();
			str.print(indent);
			str.print("jmi_ad_var_t ");
			str.print(name);
			str.print(" = ");
			str.print(name);
			str.print("a[");
			str.print(name);
			str.print("i];\n");
		}
	}
	
	syn boolean FForIndex.needsForArray() = hasFExp() && getFExp().needsForArray();
	syn boolean FExp.needsForArray()      = true;
	eq FRangeExp.needsForArray()          = false;
	
	public void FRangeExp.printForIndex_C(Printer p, PrintStream str, String indent, String name) {
		boolean hasStep = getNumFExp() > 2;
		str.print("jmi_ad_var_t ");
		str.print(name);
		str.print(" = ");
		p.print(getFExp(0), str, indent);
		str.print("; ");
		str.print(name);
		str.print(" <= ");
		p.print(getFExp(hasStep ? 2 : 1), str, indent);
		str.print("; ");
		str.print(name);
		str.print(" += ");
		if (hasStep) 
			p.print(getFExp(1), str, indent);
		else
			str.print("1");
	}
	
	public void FExp.printForIndex_C(Printer p, PrintStream str, String indent, String name) {
		str.print("int ");
		str.print(name);
		str.print("i = 0; ");
		str.print(name);
		str.print("i < ");
		str.print(size().numElements());
		str.print("; ");
		str.print(name);
		str.print("i++");
	}
	
	public void FSizeExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		getFExp().prettyPrintSize_C(p, str, indent, dimension());
	}
	
	public void FExp.prettyPrintSize_C(Printer p, PrintStream str, String indent, int dim) {}
	
	public void FIdUseExp.prettyPrintSize_C(Printer p, PrintStream str, String indent, int dim) {
		str.print("jmi_array_size(");
		p.print(getFIdUse(), str, indent);
		str.print(", ");
		str.print(dim);
		str.print(")");
	}
	
	syn String FBinExp.op_C() = op();
	eq FDotAddExp.op_C() = " + ";
	eq FDotSubExp.op_C() = " - ";
	eq FDotMulExp.op_C() = " * ";
	eq FDotDivExp.op_C() = " / ";

	public void FDotDivExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("jmi_divide(");
		p.print(getLeft(),str,indent);
		str.print(","); 
		p.print(getRight(),str,indent);
		str.print(","); 
		str.print("\"Divide by zero: "+prettyPrint("")+"\")");
	}
	
	public void FIfExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		
		int end_parenthesis = 1;
		
		str.print("(COND_EXP_EQ(");
		p.print(getIfExp(),str,indent);
		str.print(",JMI_TRUE,");
		p.print(getThenExp(),str,indent);
		str.print(",");
		for (FElseIfExp el_if : getFElseIfExps()) {
			end_parenthesis++;

			str.print("(COND_EXP_EQ(");
			p.print(el_if.getIfExp(),str,indent);
			str.print(",JMI_TRUE,");
			p.print(el_if.getThenExp(),str,indent);
			str.print(",");			
		}
		p.print(getElseExp(),str,indent);
		for (int i=0;i<end_parenthesis*2;i++) {
			str.print(")");
		}
	}
	
	public void FAbsExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("jmi_abs(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}

	public void FNoEventExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		p.print(getFExp(), str, indent);
	}

	public void FSmoothExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		p.print(getFExp(), str, indent);
	}

	public void FInitialExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("_atInitial");
	}
	
	public void FIntegerExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("jmi_real_to_integer(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}
	
	syn String FBoolBinExp.macro_C();
	eq FEqExp.macro_C()  = "COND_EXP_EQ";
	eq FNeqExp.macro_C() = "COND_EXP_EQ";
	eq FLtExp.macro_C()  = "COND_EXP_LT";
	eq FLeqExp.macro_C() = "COND_EXP_LE";
	eq FGtExp.macro_C()  = "COND_EXP_GT";
	eq FGeqExp.macro_C() = "COND_EXP_GE";
	eq FAndExp.macro_C() = "LOG_EXP_AND";
	eq FOrExp.macro_C()  = "LOG_EXP_OR";
	
	syn boolean FRelExp.relIsInverted_C() = false;
	eq FNeqExp.relIsInverted_C() = true;
	
	public void FRelExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (inNoEventExp() || !isRealComparison()) {
			str.print(macro_C()+"(");
			p.print(getLeft(), str, indent);
			str.print(", ");
			p.print(getRight(), str, indent);
			str.print(relIsInverted_C() ? ", JMI_FALSE, JMI_TRUE)" : ", JMI_TRUE, JMI_FALSE)");
		} else {
			if (inEquationSection()) {
				str.print("_sw");
				str.print("(" + relExpInEquationsIndex() + ")");
			} else {
				str.print("_sw_init");
				str.print("(" + relExpInInitialEquationsIndex() + ")");
			}
		}
	}
	
	public void FLogBinExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print(macro_C());
		str.print("(");
		p.print(getLeft(), str, indent);
		str.print(", ");
		p.print(getRight(), str, indent);
		str.print(")");
	}
	
	public void FNotExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("LOG_EXP_NOT(");
		p.print(getFExp(), str, indent);
		str.print(")");
	}
			 	
	public void FRealLitExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (inIfCondition()) 
			str.print("AD_WRAP_LITERAL(");
		str.print(getUNSIGNED_NUMBER());
		if (inIfCondition()) 
			str.print(")");
	}

	public void FIntegerLitExp.prettyPrint_C(Printer p, PrintStream str, String indent) {
		if (inIfCondition()) 
			str.print("AD_WRAP_LITERAL(");
		str.print(getUNSIGNED_INTEGER());
		if (inIfCondition()) 
			str.print(")");
	}
	
	public void FBooleanLitExpTrue.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("JMI_TRUE");
	}
	
	public void FBooleanLitExpFalse.prettyPrint_C(Printer p, PrintStream str, String indent) {
		str.print("JMI_FALSE");
	}
	
	public void FExternalStmt.prettyPrint_C(Printer p, PrintStream str, String indent) {
		// Must generate extern function declaration for Fortran 77
		getFExternalLanguage().genFuncDecl(p, str, indent, this);
		
		// Generate temp arrays for all array inputs and outputs
		// and transpose array for if array is input (Fortran 77 only)
		getFExternalLanguage().genPreFuncCall(p, str, indent, this);
		
		// return variable?
		if(hasReturnVar()) {
			String ret = getReturnVar().name_C();
			str.print(indent);
			str.print(ret+" = ");
		} else {
			str.print(indent);
		}
		
		// print function call
		getFExternalLanguage().genFuncCall(p, str, indent, this);
		
		// If there are any output arrays, transpose these before returning (Fortran 77 only)
		getFExternalLanguage().genPostFuncCall(p, str, indent, this);
	}
	
	public void FExternalLanguage.genPreFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt){}
	
	public void FFortran77ExternalLanguage.genPreFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt) {
		// generate temp arrays if there are any array inputs or outputs with dim > 1
		
		for (FExp arg: stmt.getArgs()) {
			// We need to transpose (before, after, or both) if we have >2 dimensions
			if (arg.ndims() > 1) {
				
				// generate tempname
				String tempName = arg.tempName_C();
				FType type = arg.type();
				// create static or dynamic temp array
				type.printInit_C(p, str, indent, tempName, arg);				
				
				// check if array is input
				if (arg instanceof FIdUseExp && ((FIdUseExp)arg).myFV() instanceof FFunctionVariable) {
					FIdUseExp fid = (FIdUseExp)arg;
					FFunctionVariable ffv = (FFunctionVariable)fid.myFV();
					
					if (ffv.isInput()) {
						// is input array...
						// ...then perform transformation
						str.print(indent + "jmi_transpose_matrix(");
						p.print(arg, str, indent);
						str.print(", ");
						p.print(arg, str, indent);
						str.print("->var");
						str.print(", " + tempName + "->var");
						str.print(");\n");
					}
				}
			}			
		}
	}
	
	public void FExternalLanguage.genPostFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt) {}
	
	public void FFortran77ExternalLanguage.genPostFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt) {
		for (FExp arg: stmt.getArgs()) {
			// We need to transpose (before, after, or both) if we have >2 dimensions
			if (arg.ndims() > 1) {			
				
				// check if array is output
				if (arg instanceof FIdUseExp && ((FIdUseExp)arg).myFV() instanceof FFunctionVariable) {
					FIdUseExp fid = (FIdUseExp)arg;
					FFunctionVariable ffv = (FFunctionVariable)fid.myFV();
					
					if (ffv.isOutput()) {
						String tempName = arg.tempName_C();
						// is output array...
						// ...then perform transformation
						str.print(indent + "jmi_transpose_matrix(");
						p.print(arg, str, indent);
						str.print(", ");
						p.print(arg, str, indent);
						str.print("->var");
						str.print(", " + tempName + "->var");
						str.print(");\n");
						
						// copy result in temp array to output array
						str.print(indent);
						p.print(arg, str, indent);
						str.print("->var = ");
						str.print(tempName + "->var;\n");
					}
				}
			}			
		}		
	}
	
	public void FExternalLanguage.genFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt) {}
	
	public void FCExternalLanguage.genFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt) {
		str.print(stmt.getName()+"(");
		String prefix = "";
		
		for (FExp arg : stmt.getArgs()) {
			str.print(prefix);
			
			if (arg instanceof FIdUseExp && ((FIdUseExp)arg).myFV() instanceof FFunctionVariable) {
				FIdUseExp fid = (FIdUseExp)arg;
				FFunctionVariable ffv = (FFunctionVariable)fid.myFV();
				
				if (ffv.isOutput() && !arg.isArray()) {
					str.print("&");
				}
			}
			p.print(arg, str, indent);
			
			if (arg.isArray()) {
				str.print("->var");
			}
			prefix = ", ";
		}
		
		str.print(");\n");
	}
	
	public void FFortran77ExternalLanguage.genFuncCall(Printer p, PrintStream str, String indent, FExternalStmt stmt) {
		str.print(stmt.getName()+"_(");
		String prefix = "";
		
		for (FExp arg : stmt.getArgs()) {
			str.print(prefix);

			if (arg.isArray()) {
				// array
				if (arg instanceof FIdUseExp && ((FIdUseExp)arg).myFV() instanceof FFunctionVariable) {
					FIdUseExp fid = (FIdUseExp)arg;
					FFunctionVariable ffv = (FFunctionVariable)fid.myFV();
					
					if (ffv.isInput() && arg.ndims() > 1) {
						// if is input argument and dim > 1 - use temp array (which has been transposed)
						str.print(arg.tempName_C() + "->var");
						
					} else {
						// array has dim <= 1 or is output argument = use "real" array (perform the transpose after the function call)
						p.print(arg, str, indent);
						str.print("->var");
					}
				}
				
			} else {
				// not array
				str.print("&");	
				p.print(arg, str, indent);
			}
			
			prefix = ", ";
		}
		
		str.print(");\n");		
	}
	
	public void FExternalLanguage.genFuncDecl(Printer p, PrintStream str, String indent, FExternalStmt stmt) {}
	
	public void FFortran77ExternalLanguage.genFuncDecl(Printer p, PrintStream str, String indent, FExternalStmt stmt) {
		str.print(indent);
		str.print("extern ");
		if (stmt.hasReturnVar()) {
			FType type = stmt.getReturnVar().type();
			String retType = type.type_C();
			str.print(retType + " ");
		} else {
			str.print("void ");
		}

		str.print(stmt.getName()+"_(");
		
		String prefix = "";
		for (FExp arg : stmt.getArgs()) {
			str.print(prefix);
			FType type = arg.type();
			str.print(type.argType_C());			
			str.print("*");
			prefix = ", ";
		}
		str.print(");\n");
	}
	
	public void ASTNode.genTempVars_C(Printer p, PrintStream str, String indent) {
		for (ASTNode node : this)
			node.genTempVars_C(p, str, indent);
	}
	
	public void FExp.genTempVars_C(Printer p, PrintStream str, String indent) {
		if (isArray() && !size().isUnknown())
			getArray().genTempVars_C(p, str, indent);
		else
			super.genTempVars_C(p, str, indent);
	}
	
	public void FFunctionCall.genTempVars_C(Printer p, PrintStream str, String indent) {
		getArgs().genTempVars_C(p, str, indent);
		for (FExp arg : getArgs()) 
			arg.genTempInput_C(p, str, indent);
	}
	
	public void FFunctionCallLeft.genTempVars_C(Printer p, PrintStream str, String indent) {
		if (hasFExp())
			getFExp().genTempOutput_C(p, str, indent);
	}
	
	syn lazy String FExp.tempName_C() {
		return "tmp_" + nextTempNbr_C();
	}
	
	private int FClass.nextTempNbr_C        = 1;
	private int FFunctionDecl.nextTempNbr_C = 1;
	
	inh int FExp.nextTempNbr_C();
	inh int FType.nextTempNbr_C();
	eq InstNode.getChild().nextTempNbr_C()      = 0;
	eq FClass.getChild().nextTempNbr_C()        = nextTempNbr_C++;
	eq FFunctionDecl.getChild().nextTempNbr_C() = nextTempNbr_C++;
	
	public void FExp.genTempInput_C(Printer p, PrintStream str, String indent) {
		if (isComposite() && !keepAsArray()) {
			String name = tempName_C();
			type().printInit_C(p, str, indent, name, this);
			type().genTempInputAssigns_C(p, str, indent, name, this);
		}
	}
	
	public void FType.genTempInputAssigns_C(
			Printer p, PrintStream str, String indent, String name, FExp exp) {
		if (isArray()) {
			String type = isRecord() ? C_ARRAY_RECORD : C_ARRAY_REFERENCE;
			String pre = "jmi_array_" + type + "_" + ndims() + "(" + name + ", ";
			Array arr = exp.getArray();
			for (Index i : arr.indices()) {
				String cellName = pre + i.toUnclosedString() + ")";
				genTempInputCellAssigns_C(p, str, indent, cellName, arr.get(i));
			}
		} else {
			genTempInputCellAssigns_C(p, str, indent, name, exp);
		}
	}
	
	public void FType.genTempInputCellAssigns_C(
			Printer p, PrintStream str, String indent, String name, FExp exp) {
		str.print(indent + name + " = ");
		p.print(exp, str, indent);
		str.print(";\n");
	}
	
	public void FRecordType.genTempInputCellAssigns_C(
			Printer p, PrintStream str, String indent, String name, FExp exp) {
		for (FRecordComponentType comp : getComponents()) {
			String compName = name + "->" + comp.getName();
			FExp compExp = exp.extractRecordComponentExp(comp.getName());
			comp.getFType().genTempInputAssigns_C(p, str, indent, compName, compExp);
		}
	}
	
	// TODO: maybe this should be moved to front-end
	public FExp FExp.extractRecordComponentExp(String name) {
		throw new UnsupportedOperationException(getClass().getSimpleName() + " shouldn't have record type.");
	}
	
	public FExp FIdUseExp.extractRecordComponentExp(String name) {
		FIdUseExp res = fullCopy();
		res.getFIdUse().getFQName().addFQNamePart(name);
		return dynamicFExp(res);
	}
	
	public FExp FRecordConstructor.extractRecordComponentExp(String name) {
		return getArg(getRecord().myFRecordDecl().indexOf(name));
	}
	
	public void FExp.genTempOutput_C(Printer p, PrintStream str, String indent) {}
	
	public void FArray.genTempOutput_C(Printer p, PrintStream str, String indent) {
		type().printInit_C(p, str, indent, tempName_C(), this);
	}
	
	public void FRecordConstructor.genTempOutput_C(Printer p, PrintStream str, String indent) {
		type().printInit_C(p, str, indent, tempName_C(), this);
	}

	
	public void AbstractEquationBlock.genBlockResidualFunction_C(int block_counter, boolean inInit, String indent, PrintStream str) {
		str.print("static int dae_" + (inInit? "init_": "") + "block_"+block_counter+"(jmi_t* jmi, jmi_real_t* x, jmi_real_t* residual, int init) {\n");
		str.print("  jmi_real_t** res = &residual;\n");	
		genVarDecls_C(str, indent); // TODO: wrong indent (but so has rest of func...)
		str.print("  if (init==JMI_BLOCK_INITIALIZE) {\n");
		int var_counter = 0;
		// Loop over all active variables and write their value to x	
		for (FVariable fv : blockResidualVariables_C()) {
			str.print("    x["+var_counter+"] = " + fv.name_C() + ";\n");
			var_counter++;
		}
		str.print("  } else if (init==JMI_BLOCK_EVALUATE) {\n");
		// Loop over all active variables and write the values in x to the z vector
		var_counter = 0;
		for (FVariable fv : blockResidualVariables_C()) {
			str.print("    " + fv.name_C() + " = x["+var_counter+"];\n");
			var_counter++;
		}
		
		genBlockResidualFunctionBeforeEqns_C(indent, str);
		// Write the residual expressions
		int equation_counter = 0;
		for (FAbstractEquation e : blockResidualEquations_C()) {
			e.genResidual_C(equation_counter,indent,str);				
			equation_counter += e.numScalarEquations();
		}
		genBlockResidualFunctionAfterEqns_C(indent, str);
		str.print("  }\n");
		str.print("  return 0;\n}\n\n");
	}
	
	public void SolvedScalarBlock.genBlockResidualFunction_C(int block_counter, boolean inInit, String indent, PrintStream str) {
	}
	
	protected void AbstractEquationBlock.genVarDecls_C(PrintStream str, String indent) {
		for (ASTNode n : blockResidualNodes_C())
			n.genVarDecls_C(ASTNode.printer_C, str, indent);
	}
	
	protected void SolvedScalarBlock.genVarDecls_C(PrintStream str, String indent) {
		solution().genVarDecls_C(ASTNode.printer_C, str, indent);
	}
	
	public ArrayList<ASTNode> AbstractEquationBlock.blockResidualNodes_C() {
		ArrayList<ASTNode> res = new ArrayList<ASTNode>(blockResidualVariables_C());
		res.addAll(blockResidualEquations_C());
		return res;
	}
	
	public ArrayList<ASTNode> MixedEquationBlock.blockResidualNodes_C() {
		ArrayList<ASTNode> res = super.blockResidualNodes_C();
		res.addAll(discreteEquations());
		return res;
	}
	
	public ArrayList<ASTNode> TornEquationBlock.blockResidualNodes_C() {
		ArrayList<ASTNode> res = new ArrayList<ASTNode>(variables());
		res.addAll(equations());
		return res;
	}
	
	public ArrayList<FVariable> AbstractEquationBlock.blockResidualVariables_C() {
		return activeVariables();
	}
	
	public ArrayList<FVariable> MixedEquationBlock.blockResidualVariables_C() {
		return activeContinuousVariables();
	}
	
	public ArrayList<FAbstractEquation> AbstractEquationBlock.blockResidualEquations_C() {
		return equations();
	}
	
	public ArrayList<FAbstractEquation> MixedEquationBlock.blockResidualEquations_C() {
		return continuousEquations();
	}
	
	public ArrayList<FAbstractEquation> TornEquationBlock.blockResidualEquations_C() {
		return unsolvedEquations();
	}
	
	public void AbstractEquationBlock.genBlockResidualFunctionAfterEqns_C(String indent, PrintStream str) {
	}
	
	public void MixedEquationBlock.genBlockResidualFunctionAfterEqns_C(String indent, PrintStream str) {
		str.print("  } else if (init==JMI_BLOCK_EVALUATE_NON_REALS) {\n");
		// Loop over all active variables and write the values in x to the z vector
		// Write the residual expressions
		for (FAbstractEquation ae : discreteEquations()) {
			FEquation e = (FEquation)ae;
			str.print(" ");
			e.getLeft().prettyPrint_C(str,"");
			str.print(" = ");
			e.getRight().prettyPrint_C(str,"");
			str.print(";\n");
		}
	}
	
	public void AbstractEquationBlock.genBlockResidualFunctionBeforeEqns_C(String indent, PrintStream str) {
	}
	
	public void TornEquationBlock.genBlockResidualFunctionBeforeEqns_C(String indent, PrintStream str) {
		// Loop over all solved equations and write the expressions  
		for (MatchingPair mp: getSolvedPairs()){
			mp.getEquation().genSolvedBlock_C(mp.getFVariable(), indent, str);	
        }
	}
	
	public void AbstractEquationBlock.genBlockAddCall_C(int block_counter, boolean inInit, String indent, PrintStream str) {
	} 

	public void EquationBlock.genBlockAddCall_C(int block_counter, boolean inInit, String indent, PrintStream str) {
		str.print(indent + "jmi_dae_" + (inInit? "init_": "") + 
		"add_equation_block(*jmi,dae_" + (inInit? "init_": "") + "block_" + 
		block_counter + ", NULL," + activeVariables().size() + ",0," + 
		block_counter + " );\n");
	} 

	public void MixedEquationBlock.genBlockAddCall_C(int block_counter, boolean inInit, String indent, PrintStream str) {
		str.print(indent + "jmi_dae_" + (inInit? "init_": "") + 
		"add_equation_block(*jmi,dae_" + (inInit? "init_": "") + "block_" + 
		block_counter + ", NULL," + activeContinuousVariables().size() + "," + 
		activeDiscreteVariables().size() + "," + 
		block_counter + " );\n");
	} 
		
	public void AbstractEquationBlock.genBlock_C(int i, boolean inInitial, String indent, PrintStream str) {
		String var = inInitial ? "dae_init_block_residuals" : "dae_block_residuals";
		str.format("%sjmi_kinsol_solve(jmi->%s[%d]);\n", indent, var, i);
	}

	public void SolvedScalarBlock.genBlock_C(int i, boolean inInitial, String indent, PrintStream str) {	
		equations().get(0).genSolvedBlock_C(activeVariables().get(0),indent,str);
	}

	public void FAbstractEquation.genSolvedBlock_C(FVariable v, String indent, PrintStream str) {}
	
	public void FEquation.genSolvedBlock_C(FVariable v, String indent, PrintStream str) {
		FExp sol = solution(v.name());
		sol.genTempVars_C(printer_C, str, indent);
		str.format("%s%s = ", indent, v.name_C());
		sol.prettyPrint_C(str, indent);
		str.print(";\n");		
	}
	
	public void FWhenEquation.genSolvedBlock_C(FVariable v, String indent, PrintStream str) {
		/* 
		  if (guard and !pre(guard)) {
		  	_x = _pre_x + 1;
		  }
		*/
		for (FExp g : guards()) {		
			g.genTempVars_C(printer_C, str, indent);
			str.format("%s_guards(%d) = ", indent, g.guardExpInEquationsIndex());
			g.prettyPrint_C(str,"");
			str.print(";\n");
		}
		int i = guards().size();
		str.print("  if(");
		for (FExp g : guards()) {
			if (i>1) {
				str.print("LOG_EXP_OR(");
			}		
			str.print("COND_EXP_EQ(LOG_EXP_AND(_guards(");
			str.print(g.guardExpInEquationsIndex());
			str.print("),LOG_EXP_NOT(_pre_guards(");
			str.print(g.guardExpInEquationsIndex());
			str.print("))),JMI_TRUE,JMI_TRUE,JMI_FALSE)");
			if (i>1) {
				str.print(",\n    ");
			}		
			i--;
		}		
		for (int j = 0;j<guards().size()-1;j++) {
			str.print(")");
		}
		str.print(") {\n");
		for (FAbstractEquation fe : getFAbstractEquations()) {
			fe.genSolvedBlock_C(v,indent,str);
		}
		str.print("  } else {\n");
		str.print(indent);
		str.print(v.name_C());
		str.print(" = ");
		str.print("pre");
		str.print(v.name_C());
		str.print(";\n");
		str.print(indent);
		str.print("}\n");
	}
	
	
	public void FAbstractEquation.genResidual_C(int i, String indent, PrintStream str) {}
	
	public void FEquation.genResidual_C(int i, String indent, PrintStream str) {
		genTempVars_C(printer_C, str, indent);
		str.print(indent + "(*res)[" + i + "] = ");
		getRight().prettyPrint_C(str,"");
		str.print(" - (");
		getLeft().prettyPrint_C(str,"");
		str.print(");\n");
	}
	
	public void FFunctionCallEquation.genResidual_C(int i, String indent, PrintStream str) {
		if (!getCall().isIgnored()) {
			genTempVars_C(printer_C, str, indent);
			for (FFunctionCallLeft l : getLefts()) {
				l.setBaseIndex(i);
				l.genTempVar_C(indent, str);
			}
			getCall().prettyPrint_C(str, indent);
			str.print(";\n");
			for (FFunctionCallLeft l : getLefts())
				l.genWriteBack_C(str, indent);
		}
	}

	public void FAbstractEquation.genAssignment_C(String indent, PrintStream str) {}
	
	public void FEquation.genAssignment_C(String indent, PrintStream str) {
		genTempVars_C(printer_C, str, indent);
		str.print(indent);
		FIdUseExp left = (FIdUseExp)getLeft();
		left.getFIdUse().prettyPrint_C(str,"");
//		getLeft().prettyPrint_C(str,"");
		str.print(" = (");
		getRight().prettyPrint_C(str,"");
		str.print(")");
		if (left.myFV().isReal() && root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("/sf(");
			str.print(left.myFV().valueReference());
			str.print(")");
		}
		str.print(";\n");
	}

	public void FFunctionCallEquation.genAssignment_C(String indent, PrintStream str) {
		if (!getCall().isIgnored()) {
			genTempVars_C(printer_C, str, indent);
			int i = 0;
			for (FFunctionCallLeft l : getLefts()) {
				l.setBaseIndex(i);
				l.genTempVar_C(indent, str);
			}
			getCall().prettyPrint_C(str, indent);
			str.print(";\n");
			for (FFunctionCallLeft l : getLefts())
				l.genWriteBackAssignment_C(str, indent);
		}
	}

	private int FFunctionCallLeft.equationIndex = -1;
	public void FFunctionCallLeft.setBaseIndex(int i) {
		equationIndex = i + myIndex();
	}
	syn String FFunctionCallLeft.name_C() {
		// TODO: use getFExp().tempName_C() instead of first case as well?
		if (equationIndex >= 0 && !getFExp().isComposite()) {
			StringBuilder b = new StringBuilder();
			b.append("tmp_var_");
			b.append(equationIndex);
			return b.toString();
		} else if (equationIndex < 0 || getFExp().keepAsArray()) {
			return ((FIdUseExp) getFExp()).getFIdUse().name_C();
		} else {
			return getFExp().tempName_C();
		}
	}
	
	// TODO: Declare in genVarDecls_C instead
	public void FFunctionCallLeft.genTempVar_C(String indent, PrintStream str) {
		if (hasFExp() && !getFExp().isComposite()) {
			str.print(indent);
			str.print(type_C());
			str.print(" ");
			str.print(name_C());
			str.print(";\n");
		}
	}
	
	public void FFunctionCallLeft.genArgument_C(PrintStream str) {
		if (hasFExp()) {
			if (!getFExp().isComposite())
				str.print("&");
			str.print(name_C());
		} else {
			str.print("NULL");
		}
	}
	
	public void FFunctionCallLeft.genWriteBack_C(PrintStream str, String indent) {
		if (hasFExp()) 
			getFExp().type().genWriteBack_C(str, indent, name_C(), getFExp(), equationIndex);
	}
	
	public void FType.genWriteBack_C(PrintStream str, String indent, String name, FExp exp, int index) {
		if (isArray()) {
			String type = isRecord() ? C_ARRAY_RECORD : C_ARRAY_VALUE;
			String pre = String.format("jmi_array_%s_%d(%s, ", type, ndims(), name);
			Array arr = exp.getArray();
			for (Index i : arr.indices()) {
				String cellName = pre + i.toUnclosedString() + ")";
				genCellWriteBack_C(str, indent, cellName, arr.get(i), index++);
			}
		} else {
			genCellWriteBack_C(str, indent, name, exp, index);
		}
	}
	
	public void FType.genCellWriteBack_C(PrintStream str, String indent, String name, FExp exp, int index) {
		exp.genWriteBack_C(str, indent, name, index);
	}
	
	public void FRecordType.genCellWriteBack_C(PrintStream str, String indent, String name, FExp exp, int index) {
		for (FRecordComponentType comp : getComponents()) {
			String compName = name + "->" + comp.getName();
			FExp compExp = exp.extractRecordComponentExp(comp.getName());
			comp.getFType().genWriteBack_C(str, indent, compName, compExp, index++);
		}
	}
	
	public void FExp.genWriteBack_C(PrintStream str, String indent, String name, int index) {
		str.print(indent);
		str.print("(*res)[");
		str.print(index);
		str.print("] = ");
		str.print(name);
		str.print(" - (");
		prettyPrint_C(str, "");
		str.print(");\n");
	}
	
	public void FFunctionCallLeft.genWriteBackAssignment_C(PrintStream str, String indent) {
		if (hasFExp()) 
			getFExp().type().genWriteBackAssignment_C(str, indent, name_C(), getFExp());
	}
	
	public void FType.genWriteBackAssignment_C(PrintStream str, String indent, String name, FExp exp) {
		if (isArray()) {
			String type = isRecord() ? C_ARRAY_RECORD : C_ARRAY_VALUE;
			String pre = String.format("jmi_array_%s_%d(%s, ", type, ndims(), name);
			Array arr = exp.getArray();
			for (Index i : arr.indices()) {
				String cellName = pre + i.toUnclosedString() + ")";
				genCellWriteBackAssignment_C(str, indent, cellName, arr.get(i));
			}
		} else {
			genCellWriteBackAssignment_C(str, indent, name, exp);
		}
	}
	
	public void FType.genCellWriteBackAssignment_C(PrintStream str, String indent, String name, FExp exp) {
		exp.genWriteBackAssignment_C(str, indent, name);
	}
	
	public void FRecordType.genCellWriteBackAssignment_C(PrintStream str, String indent, String name, FExp exp) {
		for (FRecordComponentType comp : getComponents()) {
			String compName = name + "->" + comp.getName();
			FExp compExp = exp.extractRecordComponentExp(comp.getName());
			comp.getFType().genWriteBackAssignment_C(str, indent, compName, compExp);
		}
	}

	public void FExp.genWriteBackAssignment_C(PrintStream str, String indent, String name) {
		str.print(indent);
		FIdUseExp e = (FIdUseExp)this;
		e.getFIdUse().prettyPrint_C(str,"");
//		prettyPrint_C(str, "");
		str.print(" = (");
		str.print(name);
		str.print(")");
		if (e.myFV().isReal() && root().options.getBooleanOption("enable_variable_scaling") && !inFunction()) {
			str.print("/sf(");
			str.print(e.myFV().valueReference());
			str.print(")");
		}
		str.print(";\n");
	}
	
	public void FExp.genArgument_C(Printer p, PrintStream str, String indent) {
		if (isComposite() && !keepAsArray())
			str.print(tempName_C());
		else
			p.print(this, str, indent);
	}

	public void FRelExp.genResidual_C(int i, String indent, PrintStream str) {
		str.print(indent + "(*res)[" + i + "] = ");
		getRight().prettyPrint_C(str,"");
		str.print(" - (");
		getLeft().prettyPrint_C(str,"");
		str.print(");\n");
	}	

	public void FGtExp.genResidual_C(int i, String indent, PrintStream str) {
		str.print(indent + "(*res)[" + i + "] = ");
		getLeft().prettyPrint_C(str,"");
		str.print(" - (");
		getRight().prettyPrint_C(str,"");
		str.print(");\n");
	}	

	public void FGeqExp.genResidual_C(int i, String indent, PrintStream str) {
		str.print(indent + "(*res)[" + i + "] = ");
		getLeft().prettyPrint_C(str,"");
		str.print(" - (");
		getRight().prettyPrint_C(str,"");
		str.print(");\n");
	}	
	
	public void FRealVariable.genStartAttributeResidual_C(int i, String indent, PrintStream str) {
		if (!(this instanceof FDerivativeVariable)) {
			str.print(indent + "(*res)[" + i + "] = ");
			if (startAttributeSet()) {
				if (root().options.getBooleanOption("enable_variable_scaling")) {
					str.print("(");
					startAttributeExp().prettyPrint_C(str,"");					
					str.print(")");
					str.print("/sf(");
					str.print(valueReference());
					str.print(")");
				} else {
					startAttributeExp().prettyPrint_C(str,"");					
				}
			} else {
				str.print("0.0");
			}
			str.print(" - ");
			str.print(name_C());	
			str.print(";\n");
		}
	}
	
	public void FVariable.genStartValue_C(String indent, PrintStream str) {}
	
	public void FRealVariable.genStartValue_C(String indent, PrintStream str) {
		str.print(indent);
		str.print(name_C()+ " = ");
		if (isIndependentParameter() || useBindingExpAsStart()) {
			str.print(ceval().realValue());
		} else {
			str.print(startAttribute());
		}
		str.print(";\n");
	}
	
	public void FIntegerVariable.genStartValue_C(String indent, PrintStream str) {
		str.print(indent);
		str.print(name_C()+ " = ");
		if (isIndependentParameter() || useBindingExpAsStart()) {
			str.print(ceval().intValue());
		} else {
			str.print(startAttribute());
		}
		str.print(";\n");
	}
	
	public void FBooleanVariable.genStartValue_C(String indent, PrintStream str) {
		str.print(indent);
		str.print(name_C()+ " = ");
		if (isIndependentParameter() || useBindingExpAsStart()) {
			str.print(ceval().booleanValue() ? "JMI_TRUE" : "JMI_FALSE");
		} else {
			str.print(startAttribute() ? "JMI_TRUE" : "JMI_FALSE");
		}
		str.print(";\n");
	}

	public void FEnumVariable.genStartValue_C(String indent, PrintStream str) {
		str.print(indent);
		str.print(name_C()+ " = ");
		if (isIndependentParameter() || useBindingExpAsStart()) {
			str.print(ceval().intValue());
		} else {
			str.print(startAttribute());
		}
		str.print(";\n");
	}
	
	public void FStringVariable.genStartValue_C(String indent, PrintStream str) {
		str.print(indent);
		str.print(name_C()+ " = ");
		if (isIndependentParameter() || useBindingExpAsStart()) {
			str.print(ceval().stringValue());
		} else {
			str.print(startAttribute());
		}
		str.print(";\n");
	}
	
	public void BLT.genOdeDerivativeBlocks(PrintStream str) {
		int block_counter = 0;
		for (AbstractEquationBlock block : this) {
			block.genBlock_C(block_counter,false,"  ",str); 
            if (!block.isSolvable()) {
				block_counter++;
            }
		}
	}
	
	public ArrayList<AbstractEquationBlock> BLT.getAllBlocks() {
		return this;
	}
	
	public void BLT.genVarDecls_C(PrintStream str, String indent) {
		for (AbstractEquationBlock eb : getAllBlocks())
			eb.genVarDecls_C(str, indent);
	}

	public void StructuredBLT.genOdeDerivativeBlocks(PrintStream str) {
		int block_counter = 0;			
		str.append("/************* ODE section *********/\n");	
		// Loop over all derivatives
		for (AbstractEquationBlock eb : getOdeBlocks()) {
			eb.genBlock_C(block_counter,false,"  ",str);
			block_counter += eb.isSolvable()? 0: 1; 			
		}
		str.append("/************ Real outputs *********/\n");	
		for (AbstractEquationBlock eb : getRealOutputBlocks()) {
			eb.genBlock_C(block_counter,false,"  ",str);
			block_counter += eb.isSolvable()? 0: 1; 			
		}
		str.append("/****Integer and boolean outputs ***/\n");	
		for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
			eb.genBlock_C(block_counter,false,"  ",str);
			block_counter += eb.isSolvable()? 0: 1; 			
		}
		str.append("/**** Other variables ***/\n");	
		for (AbstractEquationBlock eb : getOtherBlocks()) {
			eb.genBlock_C(block_counter,false,"  ",str);
			block_counter += eb.isSolvable()? 0: 1; 			
		}
	}
}
