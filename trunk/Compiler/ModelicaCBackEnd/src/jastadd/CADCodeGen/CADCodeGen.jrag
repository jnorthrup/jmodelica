/*
Copyright (C) 2009 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.PrintStream;
import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
/*
 * This aspect is used to generate AD code used when generating jacobians
 * for ODE and DAE systems and for blocks that require iteration. The functionality
 * in this class is called from CADGenerator that derives what is called from
 * the compiler options set by the user. 
 *
 * When adding new AD code remember to check that the variables are declared
 * at the start of functions etc. in order to retain c89 compliance. 
 *  
 */


aspect CADCodeGen {

    /**
     * Static printer instance.
     */
    static CADPrettyPrinter ASTNode.printer_CAD = new CADPrettyPrinter();

    public class CADPrettyPrinter extends CodePrinter {

        public CADPrettyPrinter() {
            this(null, false, Homotopy.HOMOTOPY, true);
        }

        private CADPrettyPrinter(AbstractEquationBlock block, boolean inInitialSystem, Homotopy homotopyType, 
                boolean writeSwitches) {
            super(block, inInitialSystem, homotopyType, writeSwitches);
        }

        @Override
        protected CodePrinter createPrinter(AbstractEquationBlock block, boolean inInitialSystem, Homotopy homotopyType,
                boolean writeSwitches) {
            return new CADPrettyPrinter(block, inInitialSystem, homotopyType, writeSwitches);
        }

        @Override
        public void print(ASTNode node, CodeStream str, String indent) {
            node.prettyPrint_CAD(this, str, indent); 
        }

        @Override
        public void printVarDecls(ASTNode node, CodeStream str, String indent) {
            node.genVarDecls_CAD(this, str, indent);
        }

        @Override
        public void printDecl(ASTNode node, CodeStream str, String indent, Set<ASTNode> visited, Collection<FVariable> forVariables, boolean solved) {
            node.printDecl_C(this, str, indent, visited, forVariables, solved);
        }

        @Override
        public void printPreSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempVars_CAD(this, str, indent);
        }

        @Override
        public void printPostSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempFree_CAD(this, str, indent);
        }
        
        @Override
        public TypePrinter_C createDeclPrinter(CodeStream str) {
            return new DeclPrinter_CAD(this, str);
        }
        
        @Override
        public TypePrinter_C createInitPrinter(CodeStream str) {
            return new InitPrinter_CAD(this, str);
        }
        
        @Override
        public TypePrinter_C createInitSetPrinter(CodeStream str) {
            return createInitPrinter(str);
        }

        @Override
        public void genBlockResidualCall(AbstractEquationBlock block, CodeStream str, String indent) {
            block.genBlockResidualCall_CAD(this, str, indent);
        }

        @Override
        public void genSolved(FAbstractEquation node, CodeStream str, String indent,
                Set<FAbstractEquation> visited, Collection<FVariable> forVariables, Collection<Integer> forIndices) {
            node.genBlock_CAD(this, str, indent, visited, forVariables, forIndices);
        }

        @Override
        public void genResidual(FAbstractEquation node, CodeStream str, String indent, Enumerator enumerator,
                Set<FAbstractEquation> visited, Set<Integer> forIndices) {
            node.genResidual_CAD(this, enumerator, indent, str, visited, forIndices);
        }
    }

	public String ASTNode.prettyPrint_CAD(String indent) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		CodeStream str = new CodeStream(os);
		prettyPrint_CAD(str,indent);
		return os.toString();
	}

	public void ASTNode.prettyPrint_CAD(CodeStream str, String indent) {
 		prettyPrint_CAD(printer_CAD, str, indent);
	}

	// Default implementation is to use the standard C printer
	public void ASTNode.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
 		prettyPrint_C(p, str, indent);
	}
		
	private int FClass.adIndex = 0;
	
	//Assign a unique AD-index for each node that is printed
	public int FClass.nextADIndex() {
		return adIndex++;
	}
	
	syn lazy int FExp.adIndex() = myFClass().nextADIndex();
	
	syn String FExp.varName_CAD() = "v_" + adIndex();
	eq FIdUseExp.varName_CAD() = inFunction() ? getFIdUse().varName_CAD() : prettyPrint_C("");
	
	syn String FExp.derName_CAD() = "d_" + adIndex();
	eq FIdUseExp.derName_CAD() {
		if (inFunction())
			return getFIdUse().derName_CAD();
		else if (!shouldBeDifferentiated())
			return zeroValue_CAD();
		else
			return String.format("%s[jmi_get_index_from_value_ref(%d)-jmi->offs_real_dx]", getSeedName(), myFV().valueReference());
	}
	
	syn String FExp.getSeedName() = "(*dz)";
	
	@Override
	public void FIdUse.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		str.print(varName_CAD());
	}
	
	syn String FIdUse.varName_CAD() = toString_var_CAD(printer_CAD);
	
	syn String FIdUse.derName_CAD() = toString_der_CAD(printer_CAD);
	
	syn String FExp.zeroValue_CAD() = type().isString() ? "\"\"" : "AD_WRAP_LITERAL(0)";
	
	/**
	 *Print CAD code for value for record use in statement in function. 
	 */
	public String FQName.genRecordUse_var_CAD(CodePrinter p, FAbstractVariable fv, String type) {
		throw new UnsupportedOperationException();
	}	
	
    @Override
	public String FQNameFull.genRecordUse_var_CAD(CodePrinter p, FAbstractVariable fv, String type) {
		FQNamePart part = getFQNamePart(0);
		FArraySubscripts fas = part.hasFArraySubscripts() ? part.getFArraySubscripts() : null;
		String res = fv.genUse_var_CAD(p, fas, C_ARRAY_RECORD);
		for (int i = 1, n = getNumFQNamePart(); i < n; i++) {
			part = getFQNamePart(i);
			res = res + "->" + part.getName();
			if (part.hasFArraySubscripts()) {
				String curType = (n - i > 1 ? C_ARRAY_RECORD : type);
				res = part.getFArraySubscripts().genFunctionArrayUse_C(p, res, curType);
			}
		}
		return res;
	}
	
	/**
	 *Print CAD code for for derivative record use in statement in function. 
	 */
	public String FQName.genRecordUse_der_CAD(CodePrinter p, FAbstractVariable fv, String type) {
		throw new UnsupportedOperationException();
	}	
	
    @Override
	public String FQNameFull.genRecordUse_der_CAD(CodePrinter p, FAbstractVariable fv, String type) {
		FQNamePart part = getFQNamePart(0);
		FArraySubscripts fas = part.hasFArraySubscripts() ? part.getFArraySubscripts() : null;
		String res = fv.genUse_der_CAD(p, fas, C_ARRAY_RECORD);
		for (int i = 1, n = getNumFQNamePart(); i < n; i++) {
			part = getFQNamePart(i);
			res = res + "->" + part.getName();
			if (part.hasFArraySubscripts()) {
				String curType = (n - i > 1 ? C_ARRAY_RECORD : type);
				res = part.getFArraySubscripts().genFunctionArrayUse_C(p, res, curType);
			}
		}
		return res;
	}
	
	syn String FIdUse.toString_var_CAD(CodePrinter p) {
		String type = myFV().funcArrayType(isAssignUse());
		if (myFV().inRecord() && inFunction()) {
			return getFQName().genRecordUse_var_CAD(p, getFQName().myOutermostFV(), type);
		} else {
			return myFV().genUse_var_CAD(p, getFQName().getFArraySubscripts(), type);
		}
	}
	
	syn String FIdUse.toString_der_CAD(CodePrinter p) {
		String type = myFV().funcArrayType(isAssignUse());
		if (myFV().inRecord() && inFunction()) {
			return getFQName().genRecordUse_der_CAD(p, getFQName().myOutermostFV(), type);
		} else {
			return myFV().genUse_der_CAD(p, getFQName().getFArraySubscripts(), type);
		}
	}
	
	public String FAbstractVariable.genUse_var_CAD(CodePrinter p, FArraySubscripts fas, String type) {
		if (shouldBeDifferentiated())
			return varName_CAD();
		else
			return name_C();
	}
	
	public String FAbstractVariable.genUse_der_CAD(CodePrinter p, FArraySubscripts fas, String type) {
		return derName_CAD();
		
	}
	
    @Override
	public String FFunctionArray.genUse_var_CAD(CodePrinter p, FArraySubscripts fas, String type) {
		if (fas == null)
			return varName_CAD();
		else
			return fas.genFunctionArrayUse_var_CAD(p, varName_CAD(), type);
	}
	
    @Override
	public String FFunctionArray.genUse_der_CAD(CodePrinter p, FArraySubscripts fas, String type) {
		if (fas == null)
			return derName_CAD();
		else
			return fas.genFunctionArrayUse_der_CAD(p, derName_CAD(), type);
	}
	
	public String FArraySubscripts.genFunctionArrayUse_var_CAD(CodePrinter p, String name, String type) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();	
		CodeStream str = new CodeStream(os);
		str.print("jmi_array_");
		str.print(type);
		str.print("_");
		str.print(getNumFSubscript());
		str.print("(");
		str.print(name);
		str.print(", ");
		getFSubscripts().prettyPrintWithSep(printer_C, str, "", ", ");
		str.print(")");
		return os.toString();
	}
	
	public void FSubscript.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		throw new UnsupportedOperationException();
	}
	
    @Override
	public void FExpSubscript.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		getFExp().prettyPrint_C(p,str,indent);
	}
	
    @Override
	public void FIntegerSubscript.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		str.print(getValue());
	}
	
	public String FArraySubscripts.genFunctionArrayUse_der_CAD(CodePrinter p, String name, String type) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();	
		CodeStream str = new CodeStream(os);
		str.print("jmi_array_");
		str.print(type);
		str.print("_");
		str.print(getNumFSubscript());
		str.print("(");
		str.print(name);
		str.print(", ");
		getFSubscripts().prettyPrintWithSep(printer_C, str, "", ", ");
		str.print(")");
		return os.toString();
	}
	
	/*-------------------------------------------------------------------------
	 * CAD code for FExp resides bellow
	 *-----------------------------------------------------------------------*/
	
    @Override
	public void FExp.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		genVar_CAD(p, str, indent);
	}
	
	syn boolean FExp.autoGenChildADStatements_CAD() = true;
	eq FIfExp.autoGenChildADStatements_CAD()        = false;
	eq FRelExp.autoGenChildADStatements_CAD()       = !generatesEvent();
	eq FFunctionCall.autoGenChildADStatements_CAD() = false;
	
	syn boolean FExp.autoGenChildVarDecls_CAD() = autoGenChildADStatements_CAD();
	eq FIfExp.autoGenChildVarDecls_CAD()        = true;

	@Override
	public void FExp.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        if (autoGenChildADStatements_CAD()) {
            super.genTempVars_CAD(p, str, indent);
        }
        genADStatement_CAD(p , str, indent);
    }
	
	/**
	 * Determines if the expression type genereates ad statments
	 */
	syn boolean FExp.hasADStatement_CAD()      = type() != null;
	eq FIdUseExp.hasADStatement_CAD()          = false;
	eq FLitExp.hasADStatement_CAD()            = false;
	eq FRangeExp.hasADStatement_CAD()          = false;
	eq FRecordConstructor.hasADStatement_CAD() = false;
	
	/**
	 * The var expression for this type will be inlined if true
	 */
	inh boolean FExp.inlineVar_CAD();
	eq BaseNode.getChild().inlineVar_CAD() = true;
	eq FExp.getChild().inlineVar_CAD()     = false;
    eq FArray.getChild().inlineVar_CAD()   = true;

	/**
	 * The der expression for this type will be inlined if true
	 */
	inh boolean FExp.inlineDer_CAD();
	eq BaseNode.getChild().inlineDer_CAD() = true;
	eq FExp.getChild().inlineDer_CAD()     = false;
    eq FArray.getChild().inlineDer_CAD()   = true;

	/**
	 * Generates var expression or prints reference to evaluated expression
	 */
	public void FExp.genVar_CAD(CodePrinter p, CodeStream str, String indent) {
		if (inlineVar_CAD())
			genVarExp_CAD(p, str, indent);
		else
			str.print(varName_CAD());
	}
	
	/**
	 * Generates der expression or prints reference to evaluated expression
	 */
	public void FExp.genDer_CAD(CodePrinter p, CodeStream str, String indent) {
		if (!shouldBeDifferentiated())
			str.print(zeroValue_CAD());
		else if (inlineDer_CAD())
			genDerExp_CAD(p, str, indent);
		else
			str.print(derName_CAD());
	}
	
	/**
	 * Generates ad statment for this FExp
	 */
	public void FExp.genADStatement_CAD(CodePrinter p, CodeStream str, String indent) {
		if (!hasADStatement_CAD())
			return;
		if (!inlineVar_CAD()) {
			str.print(indent);
			str.print(varName_CAD());
			str.print(" = ");
			genVarExp_CAD(p, str, indent);
			str.print(";\n");
		}
		if (shouldBeDifferentiated() && !inlineDer_CAD()) {
			str.print(indent);
			str.print(derName_CAD());
			str.print(" = ");
			genDerExp_CAD(p, str, indent);
			str.print(";\n");
		}
	}
	
	/**
	 * Genereates the var expression that calculates the value of this node
	 */
	public void FExp.genVarExp_CAD(CodePrinter p, CodeStream str, String indent) {
		prettyPrint_C(p, str, indent);
	}
	
	/**
	 * Genereates the der expression that calculates the derivative value of this node
	 * The default implementation will throw an error and all subclasses that are 
	 * continouos must implement this method.
	 */
	public void FExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
		throw new UnsupportedOperationException("FExp.genADStatement_CAD() have to be overrided if type have continuous variablity, type=" + getClass().getSimpleName());
	}

    syn boolean FLitExp.inlineVar_CAD() = true;

    @Override
    public void FIdUseExp.genVarExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print(varName_CAD());
    }

    @Override
    public void FIdUseExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print(derName_CAD());
    }
    syn boolean FIdUseExp.inlineVar_CAD() = true;
    syn boolean FIdUseExp.inlineDer_CAD() = true;

    @Override
    public void FMinMaxExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getX().genVar_CAD(p, str, indent);
        str.format(" %s ", compareSign_CAD());
        getY().genVar_CAD(p, str, indent);
        str.print(" ? ");
        getX().genDer_CAD(p, str, indent);
        str.print(" : ");
        getY().genDer_CAD(p, str, indent);
    }
    
    syn String FMinMaxExp.compareSign_CAD();
    eq FMinExp.compareSign_CAD() = "<";
    eq FMaxExp.compareSign_CAD() = ">";

    @Override
    public void FSinExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * cos(");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FCosExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * -sin(");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FTanExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" / (cos(");
        getFExp().genVar_CAD(p, str, indent);
        str.print(") * cos(");
        getFExp().genVar_CAD(p, str, indent);
        str.print("))");
    }

    @Override
    public void FAsinExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" / sqrt(1 - ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(" * ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FAcosExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print("- ");
        getFExp().genDer_CAD(p, str, indent);
        str.print(" / sqrt(1 - ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(" * ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FAtanExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" / (1 + ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(" * ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FAtan2Exp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print("(");
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * ");
        getY().genVar_CAD(p, str, indent);
        str.print(" - ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(" * ");
        getY().genDer_CAD(p, str, indent);
        str.print(") / (");
        getY().genVar_CAD(p, str, indent);
        str.print(" * ");
        getY().genVar_CAD(p, str, indent);
        str.print(" + ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(" * ");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FSinhExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * cosh(");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FCoshExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * sinh(");
        getFExp().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FTanhExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * (1 - ");
        genVar_CAD(p, str, indent);
        str.print(" * ");
        genVar_CAD(p, str, indent);
        str.print(")");
    }
    syn boolean FTanhExp.inlineVar_CAD() = false;

    @Override
    public void FLogExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" / ");
        getFExp().genVar_CAD(p, str, indent);
    }

    @Override
    public void FLog10Exp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * log10(exp(1)) / ");
        getFExp().genVar_CAD(p, str, indent);
    }

    @Override
    public void FExpExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" * ");
        genVar_CAD(p, str, indent);
    }
    syn boolean FExpExp.inlineVar_CAD() = false;

    @Override
    public void FDotPowExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getLeft().genVar_CAD(p, str, indent);
        str.print(" == 0 ? 0 : (");
        genVar_CAD(p, str, indent);
        str.print(" * (");
        getRight().genDer_CAD(p, str, indent);
        str.print(" * log(jmi_abs(");
        getLeft().genVar_CAD(p, str, indent);
        str.print(")) + ");
        getRight().genVar_CAD(p, str, indent);
        str.print(" * ");
        getLeft().genDer_CAD(p, str, indent);
        str.print(" / ");
        getLeft().genVar_CAD(p, str, indent);
        str.print("))");
    }
    syn boolean FDotPowExp.inlineVar_CAD() = false;

    @Override
    public void FSqrtExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
        str.print(" / (2 * ");
        genVar_CAD(p, str, indent);
        str.print(")");
    }
    syn boolean FSqrtExp.inlineVar_CAD() = false;

    @Override
    public void FDotDivExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print("(");
        getLeft().genDer_CAD(p, str, indent);
        str.print(" * ");
        getRight().genVar_CAD(p, str, indent);
        str.print(" - ");
        getLeft().genVar_CAD(p, str, indent);
        str.print(" * ");
        getRight().genDer_CAD(p, str, indent);
        str.print(") / (");
        getRight().genVar_CAD(p, str, indent);
        str.print(" * ");
        getRight().genVar_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FDotMulExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getLeft().genDer_CAD(p, str, indent);
        str.print(" * ");
        getRight().genVar_CAD(p, str, indent);
        str.print(" + ");
        getLeft().genVar_CAD(p, str, indent);
        str.print(" * ");
        getRight().genDer_CAD(p, str, indent);
    }

    @Override
    public void FDotAddExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getLeft().genDer_CAD(p, str, indent);
        str.print(" + ");
        getRight().genDer_CAD(p, str, indent);
    }

    @Override
    public void FDotSubExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getLeft().genDer_CAD(p, str, indent);
        str.print(" - ");
        getRight().genDer_CAD(p, str, indent);
    }

    @Override
    public void FAbsExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genVar_CAD(p, str, indent);
        str.print(" >= 0 ? ");
        getFExp().genDer_CAD(p, str, indent);
        str.print(" : -");
        getFExp().genDer_CAD(p, str, indent);
    }

    @Override
    public void FNegExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print("- (");
        getFExp().genDer_CAD(p, str, indent);
        str.print(")");
    }

    @Override
    public void FNoEventExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent){
        getFExp().genDer_CAD(p, str, indent);
    }
    eq FNoEventExp.getChild().inlineVar_CAD() = true;
    eq FNoEventExp.getChild().inlineDer_CAD() = true;

    @Override
    public void FTimeExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.format("%s[jmi->offs_t]", getSeedName());
    }
    syn boolean FTimeExp.inlineVar_CAD() = true;
    syn boolean FTimeExp.inlineDer_CAD() = true;

    @Override
    public void FSmoothExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().genDer_CAD(p, str, indent);
    }
    eq FSmoothExp.getChild().inlineVar_CAD() = true;
    eq FSmoothExp.getChild().inlineDer_CAD() = true;

    public void FDelayExp.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().prettyPrint_CAD(p, str, indent);
    }

    @Override
    public void FInStreamEpsExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print("0");
    }
    syn boolean FInStreamEpsExp.inlineVar_CAD() = true;
    syn boolean FInStreamEpsExp.inlineDer_CAD() = true;


	/**
	 * If expressions need special handling during CAD since it is not possible to
	 * write if expressions as a single statment.
	 */
	@Override
	public void FIfExp.genADStatement_CAD(CodePrinter p, CodeStream str, String indent) {
		String innerIndent = p.indent(indent);
		getIfExp().genTempVars_CAD(p, str, indent);
		
		str.print(indent);
		str.print("if (");
		getIfExp().genVar_CAD(p, str, indent);
		str.print(") {\n");
		
		getThenExp().genTempVars_CAD(p, str, innerIndent);
		
		str.print(innerIndent);
		genVar_CAD(p, str, indent);
		str.print(" = ");
		getThenExp().genVar_CAD(p, str, indent);
		str.print(";\n");
		
		if (shouldBeDifferentiated()) {
			str.print(innerIndent);
			genDer_CAD(p, str, indent);
			str.print(" = ");
			getThenExp().genDer_CAD(p, str, indent);
			str.print(";\n");
		}
		str.print(indent);
		str.print("} else {\n");
		
		getElseExp().genTempVars_CAD(p, str, innerIndent);
		
		str.print(innerIndent);
		genVar_CAD(p, str, indent);
		str.print(" = ");
		getElseExp().genVar_CAD(p, str, indent);
		str.print(";\n");
		
		if (shouldBeDifferentiated()) {
			str.print(innerIndent);
			genDer_CAD(p, str, indent);
			str.print(" = ");
			getElseExp().genDer_CAD(p, str, indent);
			str.print(";\n");
		}
		
		str.print(indent);
		str.print("}\n");
	}
	syn boolean FIfExp.inlineVar_CAD() = false;
	syn boolean FIfExp.inlineDer_CAD() = false;
	eq FIfExp.getIfExp().inlineVar_CAD() = true;
	
	/**
	 *  General method used to print function calls.
	 * Assumes that a function is called as: f(<inputs>,<outputs>) where inputs and outputs are ordered as
	 * variables first and then derivatives (only if the variable is of type real, if not inputs will be ommitted
	 * and outputs will be called with NULL argument). 
	 * Scenarios:
	 * x = f(y) The function is an expression. If the function has more then one output then then unused outputs
	 * will be filled with NULL arguments,
	 * <outs> = f(<ins>). The function is not an expression. The input arguments are then generated from the 
	 * FFunctionCallLeft belonging to this function. For unused outputs NULL argument is used.  
	 */
    @Override
	public void FFunctionCall.genADStatement_CAD(CodePrinter p, CodeStream str, String indent) {
		boolean exp = functionCallIsExp();
		
		str.print(indent);
		str.print(funcNameUnderscore("der_AD"));
		str.print("(");
		String sep = "";
		for (FExp arg : getArgs()) {
			str.print(sep);
            arg.genTempArg(((CADPrettyPrinter)p).ExecStep_var, str, indent);
			sep = ", ";
		}
		for (FExp arg : getArgs()) {
            if (arg.myCorrespondingInput().asFAbstractVariable().shouldBeDifferentiated()) {
				str.print(sep);
                arg.genTempArg(((CADPrettyPrinter)p).ExecStep_der, str, indent);
				sep = ", ";
			}
		}
        ArrayList<FFunctionVariable> outputs = myCallOutputs();
		if (!exp){
			// The function is not an expression, generate arguments from my FFunctionCallLeft
			int lefts = myLefts().size();
			for (int i = 0; i < outputs.size(); i++) {
				str.print(sep);
				if (i < lefts) {
					if (outputs.get(i).shouldBeDifferentiated())
						myLefts().get(i).genArgument_var_CAD(str);
					else
						myLefts().get(i).genArgument_C(str);
                } else if (i == 0 && lefts == 0 && isFunctionCallArg()) {
                    if (outputs.get(i).shouldBeDifferentiated())
                        str.print(tempName_var_CAD());
                    else
                        str.print(tempName_C());
				} else {
					str.print("NULL");
				}
				sep = ", ";
			}
			for (int i = 0; i < outputs.size(); i++) {
				if (!outputs.get(i).shouldBeDifferentiated())
					continue;
				str.print(sep);
				if (i < lefts)
					myLefts().get(i).genArgument_der_CAD(str);
                else if (i == 0 && lefts == 0 && isFunctionCallArg())
                    str.print(tempName_der_CAD());
				else
					str.print("NULL");
				sep = ", ";
			}
		} else {
			boolean first = true;
			for (FFunctionVariable output : outputs) {
				str.print(sep);
				sep = ", ";
				if (first) {
					str.print("&");
					genVar_CAD(p, str, indent);
				} else {
					str.print("NULL");
				}
				first = false;
			}
			first = true;
			for (FFunctionVariable output : outputs) {
				if (!output.shouldBeDifferentiated())
					continue;
				str.print(sep);
				sep = ", ";
				if (first && shouldBeDifferentiated()) {
					str.print("&");
					genDer_CAD(p, str, indent);
				} else {
					str.print("NULL");
				}
				first = false;
			}
		}
		str.print(");\n");
	}
	syn boolean FFunctionCall.inlineVar_CAD() = false;
	syn boolean FFunctionCall.inlineDer_CAD() = false;

    /*-------------------------------------------------------------------------
     * CAD code for Equations and blocks resides bellow
     *-----------------------------------------------------------------------*/

    /**
     * Generates AD-code for a single equation. Empty implementation for FAbtractEquation,
     * other types implement their specific functionality.
     * Note that methods called assumes that variables are already declared. 
     * 
     * TODO: Some of the code in these functions are duplicated from the corresponding C codegen!
     * 
     * @param enumerator  An enumerator that is used to number the residual equations
     * @param indent      Indentation
     * @param str         Output stream
     * @param visited     A list that contains all visisted equations.
     *    Used by FFunctionCallEquation so that only one function call is generated.
     */
    public void FAbstractEquation.genResidual_CAD(CodePrinter p, Enumerator enumerator, String indent, CodeStream str, Set<FAbstractEquation> visited, Set<Integer> forIndices) {}

    @Override
    public void FEquation.genResidual_CAD(CodePrinter p, Enumerator enumerator, String indent, CodeStream str, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        boolean firstVisit = visited == null ? true : visited.add(this);
        if(!shouldBeDifferentiated()){
            genResidual_C(printer_C, str, indent, enumerator, null, null);
            return;
        }
        int index = enumerator.peek();
        
        CStatement.Residual.print(this, p, str, indent, enumerator);
        
        str.print(indent);
        str.print("(*dF)[");
        str.print(index);
        str.print("] = ");
        getRight().genDer_CAD(printer_CAD, str, indent);
        str.print(" - (");
        getLeft().genDer_CAD(printer_CAD, str, indent);
        str.print(");\n");
    }

    /**
     * Generates AD-code for a FunctionCallEquation, i.e. an equation of the sort <outs> = f(<ins>). 
     * FFunctionCallLeft is looped over and their base index is set to i. This is needed since the call 
     * has several outputs which need to be aware of which index in the residual and dF vector that they should fill.
     * The call is then made and the variables are set. Then a write back function, which prints the residual code is called.
     * 
     * @see FAbstractEquation#genResidual_CAD(CodePrinter p, Enumerator, String, CodeStream, Set, Collection)
     */
    @Override
    public void FFunctionCallEquation.genResidual_CAD(CodePrinter p, Enumerator enumerator, String indent, CodeStream str, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        boolean firstVisit = visited == null ? true : visited.add(this);
        if (!getCall().isIgnored()) {
            if (firstVisit) {
                p.printPreSteps(this, str, indent);
            }
            Enumerator indexCounter = new Enumerator();
            for (FFunctionCallLeft l : getLefts())
                l.genWriteBack_CAD(str, indent, enumerator, forIndices, indexCounter);
        }
    }

    @Override
    public void FIfWhenElseEquation.genResidual_CAD(CodePrinter p, Enumerator enumerator, String indent, CodeStream str, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        genIfStart_C(printer_CAD, str, indent);
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Set<Integer> fis = new HashSet<Integer>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                fis.add(n - i);
                n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genResidual_CAD(p, enumerator, printer_CAD.indent(indent), str, visited, fis);
            }
            i += equation.numScalarEquations();
        }
    }

    @Override
    public void FIfWhenEquation.genResidual_CAD(CodePrinter p, Enumerator enumerator, String indent, CodeStream str, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        if (!isElse()) {
            boolean firstVisit = visited == null ? true : visited.add(this);
            if (firstVisit)
                genTempVars_CAD(printer_CAD, str, indent);
        }
        Enumerator enumCopy = enumerator.copy();
        super.genResidual_CAD(p, enumerator, indent, str, visited, forIndices);
        if (hasElse())
            getElse().genResidual_CAD(p, enumCopy, indent, str, visited, forIndices);
        genIfEnd_C(printer_CAD, str, indent);
    }


    //Methods to handle blocks starts here
    /**
     * Code for generating residual equation blocks. The default implementation
     * produces block and use dispatch methods to genereate block dependent code.
     * Block types should overide this function and provide an empty implementation
     * if no block is necessary.
     * 
     * TODO: Some of the code in these functions are duplicated from the corresponding C codegen!
     * 
     * @param inInitial    Specfies wether the block is initial or not
     * @param outerIndent  The outer indent. The indent should be indented
     *    once more for the statments inside the block.
     * @param str          Output stream
     */
    public void AbstractEquationBlock.genBlockResidualFunction_CAD(CodePrinter p, CodeStream str, String outerIndent) {
        if (!hasResidualFunction())
            return;
        for (AbstractEquationBlock subBlock : genBlockResidualFunction_subBlocks_C())
            subBlock.genBlockResidualFunction_CAD(p, str, outerIndent);
        
        str.format("%sstatic int dae_%sblock_dir_der_%d(jmi_t* jmi, jmi_real_t* x, jmi_real_t* dx,jmi_real_t* residual, jmi_real_t* dRes, int evaluation_mode) {\n",
                outerIndent, (p.inInitialSystem() ? "init_" : ""), getSequenceNumber());
        
        String indent = ASTNode.printer_CAD.indent(outerIndent);
        String innerIndent = ASTNode.printer_CAD.indent(indent);
        
        String label = getLabel();
        if (label == null) {
            label = getClass().getSimpleName();
        }
        str.format("%s/***** %s: %s *****/\n", indent, p.inInitialSystem() ? "Init block" : "Block", label);
        
        genVarDecls(p, str, indent, null);
        
        str.print(indent);
        str.println("jmi_real_t** res = &residual;");
        ASTNode.genFunctionStart(str, indent);
        str.print(indent);
        str.println("jmi_real_t** dF = &dRes;");
        str.print(indent);
        str.println("jmi_real_t** dz;");
        
        str.print(indent);
        str.println("if (evaluation_mode == JMI_BLOCK_INITIALIZE) {");
        int var_counter = 0;
        // Loop over all unsolved variables and write their value to x  
        for (FVariable fv : localUnsolvedVariables()) {
            str.print(innerIndent);
            str.println("x["+var_counter+"] = " + fv.name_C() + ";");
            var_counter++;
        }
        str.print(innerIndent);
        str.println("return 0;");
        
        // If we should evaluate the block Jacobian, then use dz_active_variables as seed
        str.print(indent);
        str.println("} else if (evaluation_mode == JMI_BLOCK_EVALUATE) {");
        str.print(innerIndent);
        str.println("dz = jmi->dz_active_variables;");
        // Loop over all active variables and write the values in x to the z vector
        var_counter = 0;
        // Iteration is over the unsolved variables. 
        for (FVariable fv : localUnsolvedVariables()) {
            str.print(innerIndent);
            str.println("(*dz)[ jmi_get_index_from_value_ref(" + fv.valueReference() + ")-jmi->offs_real_dx] = dx[" + var_counter + "];");
            str.print(innerIndent);
            str.println(fv.name_C() + " = x["+var_counter+"];");
            var_counter++;
        }
        
        // If we should evaluate the right hand side use global dz as seed
        str.print(indent);
        str.println("} else if (evaluation_mode == JMI_BLOCK_EVALUATE_INACTIVE) {");
        str.print(innerIndent);
        str.println("dz = jmi->dz;");
        
        // If we should write back directional derivatives then global use dz as seed
        str.print(indent);
        str.println("} else if (evaluation_mode == JMI_BLOCK_WRITE_BACK) {");
        str.print(innerIndent);
        str.println("dz = jmi->dz;");
        // Code that stores the evaluated dz
        // dz entries for the solved variables are updated below as well
        var_counter = 0;
        for (FVariable fv : localUnsolvedVariables()) {
            str.print(innerIndent);
            str.println("(*dz)[jmi_get_index_from_value_ref(" + fv.valueReference() + ")-jmi->offs_real_dx] = -(*dF)[" + var_counter + "];");
            var_counter++;
        }
        str.print(indent);
        str.println("} else {");
        str.print(innerIndent);
        str.println("return -1;");
        str.print(indent);
        str.println("}");
        
        Set<FAbstractEquation> visitedList = new HashSet<FAbstractEquation>();
        // Generate dz_i seeds from solved equations and variables
        genBlockResidualFunctionBeforeEqns_CAD(p, str, indent, visitedList);
        
        str.print(indent);
        str.println("if (evaluation_mode == JMI_BLOCK_EVALUATE_INACTIVE || evaluation_mode == JMI_BLOCK_EVALUATE) {");
        
        // AD-code for residual equations
        genResidualPart(p, str, innerIndent, new Enumerator(), visitedList);
        
        // Reset all variables. global dz is updated elsewhere and dz_active should
        // always be reset so as not to cause incorrect seeds
        for (FVariable fv : localUnsolvedVariables()) {
            str.print(innerIndent);
            str.println("(*dz)[jmi_get_index_from_value_ref(" + fv.valueReference() + ")-jmi->offs_real_dx] = 0;");
        }
        
        str.print(indent);
        str.println("}");
        str.print(indent);
        ASTNode.genFunctionEnd(str, indent);
        str.print(outerIndent);
        str.println("}");
        str.println();
    }

    /**
     * Used to generate seeds w.r.t. the unsolved variables in a TornEquationBlock. 
     * @param p          used for dispatching
     * @param indent     used to get a consistently formated c-code
     * @param str        the c-code is written to this stream
     * @param visited    a set that contains all visited equations. Might be null!
     */
    public abstract void AbstractEquationBlock.genBlockResidualFunctionBeforeEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited);

    @Override
    public void EquationBlock.genBlockResidualFunctionBeforeEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
        for (AbstractEquationBlock aeb : solvedBlocks())
            aeb.genBlockResidualFunctionBeforeSubEqns_CAD(p, str, indent, visited);
    }

//    @Override
//    public void TornEquationBlock.genBlockResidualFunctionBeforeEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
//        for (AbstractEquationBlock aeb : solvedBlocks())
//            aeb.genBlockResidualFunctionBeforeSubEqns_CAD(p, str, indent, visited);
//    }

    @Override
    public void AbstractSubBLTBlock.genBlockResidualFunctionBeforeEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
        throw new UnsupportedOperationException("AbstractSubBLTBlock.genBlockResidualFunctionBeforeEqns_CAD() is not implemented!");
    }

    @Override
    public void SimpleEquationBlock.genBlockResidualFunctionBeforeEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
        if (genBlockEnabled())
            p.genSolved(equation(), str, indent, visited, allLocalVariables(), assignedIndices());
    }

    /**
     * Sub method for generating seeds w.r.t the unsolved variables.
     * 
     * Neccessary for numerically solved scalar equations.
     * Default implementation dispatches to regular before method.
     * 
     * @param indent    indentation that should be used
     * @param str       output stream
     * @param inInitial Indicates wether a initial block is generated
     * @param visited   a set that contains all visited equations. Might be null!
     */
    public void AbstractEquationBlock.genBlockResidualFunctionBeforeSubEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
        genBlockResidualFunctionBeforeEqns_CAD(p, str, indent, visited);
    }

    @Override
    public void NumericallySolvedScalarEquationBlock.genBlockResidualFunctionBeforeSubEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
        p.genBlockResidualCall(this, str, indent);
    }

    @Override
    public void EquationBlock.genBlockResidualFunctionBeforeSubEqns_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited) {
        p.genBlockResidualCall(this, str, indent);
    }
    /**
     * Generates AD code for this equation and a variable in it . Typically called from within 
     * a solved block when printing AD code. Empty standard implementation and other blocks override. 
     * 
     * @param indent        indentation that should be used
     * @param str           output stream
     * @param visited       a set that contains all visited equations. Might be null!
     * @param forVariables  variables to generate assignments for.
     * @param forIndices    indices to generate assignments for.
     */
    public void FAbstractEquation.genBlock_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {}

    @Override
    public void FEquation.genBlock_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        //TODO: Contains duplicated code from c
        FVariable v = forVariables.iterator().next();
        FExp solution = solution(v);
        if(v.shouldBeDifferentiated()){
            printer_CAD.printPreSteps(solution, str, indent);
            str.print(indent + v.name_C() + " = ");
            solution.genVar_CAD(printer_CAD, str, indent);
            str.print(";\n");
            str.print(indent + "(*dz)[jmi_get_index_from_value_ref(" + v.valueReference() + ")-jmi->offs_real_dx] = ");
            solution.genDer_CAD(printer_CAD, str, indent);
            str.print(";\n");
            printer_CAD.printPostSteps(solution, str, indent);
        } else {
            printer_CAD.printPreSteps(solution, str, indent);
            str.format("%s%s = ", indent, v.name_C());
            solution.genVar_CAD(printer_CAD, str, indent);
            str.print(";\n");
            printer_CAD.printPostSteps(solution, str, indent);
        }
    }

    // TODO: Duplicated from C, can be improved!
    @Override
    public void FFunctionCallEquation.genBlock_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null ? true : visited.add(this);
        if (!getCall().isIgnored()) {
            if (firstVisit)
                printer_CAD.printPreSteps(this, str, indent);
            int i = 0;
            for (FFunctionCallLeft l : getLefts()) {
                l.setEquationIndex(i++);
                l.genWriteBackAssignment_CAD(str, indent, new HashSet<FVariable>(forVariables));
            }
            if (firstVisit)
                printer_CAD.printPostSteps(this, str, indent);
        }
    }

    private int FFunctionCallLeft.equationIndex = -1;
    public void FFunctionCallLeft.setBaseIndex(int i) {
        equationIndex = i + myIndex();
    }
    public void FFunctionCallLeft.setEquationIndex(int i) {
        equationIndex = i;
    }

    // TODO: Duplicated from C, can be improved!
    @Override
    public void FIfWhenElseEquation.genBlock_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        genIfStart_C(printer_CAD, str, indent);
        Iterator<FVariable> fvIt = forVariables.iterator();
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        String innerIndent = p.indent(indent);
        for (FAbstractEquation equation : getFAbstractEquations()) {
            ArrayList<Integer> fis   = new ArrayList<Integer>();
            ArrayList<FVariable> fvs = new ArrayList<FVariable>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                    fis.add(n - i);
                    fvs.add(fvIt.next());
                    n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genBlock_CAD(p, str, innerIndent, visited, fvs, fis);
            }
            i += equation.numScalarEquations();
        }
    }

    @Override
    public void FIfWhenEquation.genBlock_CAD(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null ? true : visited.add(this);
        if (!isElse() && firstVisit)
            printer_CAD.printPreSteps(this, str, indent);
        super.genBlock_CAD(p, str, indent, visited, forVariables, forIndices);
        if (hasElse())
            getElse().genBlock_CAD(p, str, indent, visited, forVariables, forIndices);
        genIfEnd_C(printer_CAD, str, indent);
        if (!isElse() && firstVisit)
            printer_CAD.printPostSteps(this, str, indent);
    }

    public class CADPrettyPrinter {
        @Override
        public void printWriteBackAssignment(CodeStream str, String indent, FCompositeWriteBackNode node,
                Collection<FVariable> forVariables) {
            WriteBackAssignmentPrinter var_p = new WriteBackAssignmentPrinter_var(forVariables);
            WriteBackAssignmentPrinter der_p = new WriteBackAssignmentPrinter_der(forVariables);
            var_p.print(str, indent, node.getFExp().type(), node.varWriteBackName_CAD(), node.getFExp());
            der_p.print(str, indent, node.getFExp().type(), node.derWriteBackName_CAD(), node.getFExp());
        }

        public class WriteBackAssignmentPrinter_var extends CodePrinter.WriteBackAssignmentPrinter {
            
            protected WriteBackAssignmentPrinter_var(Collection<FVariable> forVariables) {
                super(false, forVariables);
            }

            @Override
            public void printCellUse(CodeStream str, String indent, String name, FIdUseExp use) {
                use.genWriteBackAssignment_var_CAD(str, indent, name, forVariables);
            }
        }

        public class WriteBackAssignmentPrinter_der extends CodePrinter.WriteBackAssignmentPrinter {

            protected WriteBackAssignmentPrinter_der(Collection<FVariable> forVariables) {
                super(false, forVariables);
            }
    
            @Override
            public void printCellUse(CodeStream str, String indent, String name, FIdUseExp use) {
                use.genWriteBackAssignment_der_CAD(str, indent, name, forVariables);
            }
        }
    }
    
    public interface FCompositeWriteBackNode {
        public String varWriteBackName_CAD();
        public String derWriteBackName_CAD();
    }

    @Override
    public String FFunctionCallLeft.varWriteBackName_CAD() {
        return varName_CAD();
    }
    @Override
    public String FFunctionCallLeft.derWriteBackName_CAD() {
        return derName_CAD();
    }
    @Override
    public String FSubscriptedExp.varWriteBackName_CAD() {
        return getFExp().tempName_var_CAD();
    }
    @Override
    public String FSubscriptedExp.derWriteBackName_CAD() {
        return getFExp().tempName_der_CAD();
    }

    public void FFunctionCallLeft.genWriteBackAssignment_CAD(CodeStream str, String indent, Collection<FVariable> forVariables){
        if (hasFExp()) {
            printer_CAD.printWriteBackAssignment(str, indent, this, forVariables);
        }
    }

    public void FIdUseExp.genWriteBackAssignment_var_CAD(CodeStream str, String indent, String name, Collection<FVariable> forVariables) {
        if (forVariables != null && !forVariables.contains(myFV()))
            return; // This variable is not in the set of variables to generate code for.
        str.print(indent);
        str.print(varName_CAD());
        str.print(" = ");
        str.print(name + ";\n");
    }

    public void FIdUseExp.genWriteBackAssignment_der_CAD(CodeStream str, String indent, String name, Collection<FVariable> forVariables) {
        if (forVariables != null && !forVariables.contains(myFV()) || !shouldBeDifferentiated())
            return; // This variable is not in the set of variables to generate code for.
        str.print(indent);
        str.print(derName_CAD());
        str.print(" = ");
        str.print(name + ";\n");
    }
    
    /**
     * Generates AD code for this block. If a block needs iteration then
     * increase a counter, the counter is used to determine the index of the
     * the iteration-block that needs to be called. 
     * Note that called methods assumes that variables are already declared.
     * 
     * @param str  the c-code is written to this stream
     * 
     * TODO: Redundant, refactor!
     */
    public void BLT.genOdeDerivativeBlocks_CAD(CodePrinter p, CodeStream str, String indent) {
        for (AbstractEquationBlock block : this) {
            block.genSolvedInBLT(p, str, indent);
        }
    }

    /**
     * The central method used when generating ODE Jacobians. Calls methods to 
     * generate AD code for different block types:
     * ODEBlocks, Real output blocks, integer and boolean output blocks and other blocks.
     * Blocks that need iteration are called from here. 
     * Note that called methods assumes that variables are already declared.
     * 
     * @param str  the c-code is written to this stream
     * TODO: Redundant, refactor!
     */
    @Override
    public void StructuredBLT.genOdeDerivativeBlocks_CAD(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%s/*********** ODE section ***********/", indent);
        // Loop over all derivatives
        for (AbstractEquationBlock eb : getOdeBlocks()) {
            eb.genSolvedInBLT(p, str, indent);
        }
        str.formatln("%s/*********** Real outputs **********/", indent);
        for (AbstractEquationBlock eb : getRealOutputBlocks()) {
            eb.genSolvedInBLT(p, str, indent);
        }
        str.formatln("%s/*** Integer and boolean outputs ***/", indent);
        for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
            eb.genSolvedInBLT(p, str, indent);
        }
        str.formatln("%s/********* Other variables *********/", indent);
        for (AbstractEquationBlock eb : getOtherBlocks()) {
            eb.genSolvedInBLT(p, str, indent);
        }
    }

    //Methods to handle function calls starts here

    /**
     * Iterates over the ASTNode:s and generates temporary AD variables 
     * in arrays etc. which are currently not supported in AD. 
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p       use CADPrettyPrinter for p.print to call prettyPrint_CAD 
     * @param str     the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    //TODO: duplicated!
    public void ASTNode.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        // Call genTempVars_C?
        for (ASTNode node : this){
            p.printPreSteps(node, str, indent);
        }
    }
    
    //TODO: duplicated!
    public void ASTNode.genTempFree_CAD(CodePrinter p, CodeStream str, String indent) {
        // Call genTempVars_C?
        for (ASTNode node : this){
            p.printPostSteps(node, str, indent);
        }
    }

    //TODO: duplicated!
    @Override
    public void FAbstractEquation.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPreSteps(node, str, indent);
    }
    
    //TODO: duplicated!
    @Override
    public void FAbstractEquation.genTempFree_CAD(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPostSteps(node, str, indent);
    }

    // TODO: Why are these different than c?
    @Override
    public void FIfWhenElseEquation.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {}
    @Override
    public void FIfWhenEquation.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        super.genTempVars_CAD(p, str, indent);
        if (hasElse())
            p.printPreSteps(getElse(), str, indent);
    }
    
    @Override
    public void FIfWhenElseEquation.genTempFree_CAD(CodePrinter p, CodeStream str, String indent) {}
    @Override
    public void FIfWhenEquation.genTempFree_CAD(CodePrinter p, CodeStream str, String indent) {
        super.genTempFree_CAD(p, str, indent);
        if (hasElse())
            p.printPostSteps(getElse(), str, indent);
    }

    /**
     * Used to generate expressions in the argument of a function call. Also used to
     * generate temporary records and arrays used as inputs. 
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p       use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str     the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    @Override
    public void FFunctionCall.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        getArgs().genTempArg(p.PreStep, str, indent);
        if (isFunctionCallArg()) {
            type().printInit_C(p, str, indent, tempName_var_CAD(), this);
            type().printInit_C(p, str, indent, tempName_der_CAD(), this);
        }
        // This seems strage, why is there a spearate genADStatement_CAD?
        genADStatement_CAD(p, str, indent);
        getArgs().genTempArg(p.PostStep, str, indent);
    }

	@Override
	public void FAssert.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(getTest(), str, indent);
		// TODO: why prettyPrint_C here?
		prettyPrint_C(p, str, indent);
        p.printPostSteps(getTest(), str, indent);
	}
	
	eq FAssert.getChild().inlineVar_CAD() = true;
	
	@Override
	public void FStringAddExp.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
	    super.genTempVars_CAD(p, str, indent);
	    // TODO: Shouldn't be needed?
	    genTempVars_C(p, str, indent);
	}
	
	eq FStringAddExp.getChild().inlineVar_CAD() = true;
    
    @Override
    public void FArraySubscripts.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {}
    
    /**
     * Iterates over the ASTNode:s and generates variable declarations. 
     * Can be called at e.g. the start of functions for c89-compliance. 
     * Note that the methods used to print the regular AD code typically
     * assumes that variables are already declared.  
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p       use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str     the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    public void ASTNode.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this)
            node.genVarDecls_CAD(p, str, indent);
    }

    @Override
    public void FAbstractEquation.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                node.genVarDecls_CAD(p, str, indent);
    }
    
    /**
     * No variables should be declared for this expression. 
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str  the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    @Override
    public void FIdUseExp.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {}

    /**
     * No variables should be declared for this expression. 
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str  the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    @Override
    public void FLitExp.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {}

	/**
	 * Declares a regular and a derivate variable for this expression. jmi_real_t
	 * is a type that describes floating point numbers. Calls the overridden
	 * method in order to continue iteration over that  ASTNode:s
	 * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
	 * @param str  the c-code is written to this stream
	 * @param indent  used to get a consistently formated c-code
	 */
	@Override
	public void FExp.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
		if (hasADStatement_CAD()) {
			if (!inlineVar_CAD()) {
				str.print(indent);
				str.print("jmi_real_t ");
				str.println(varName_CAD() + ";");
			}
			if (shouldBeDifferentiated() && !inlineDer_CAD()) {
				str.print(indent);
				str.print("jmi_real_t ");
				str.println(derName_CAD() + ";");
			}
		}
		if (autoGenChildVarDecls_CAD())
			super.genVarDecls_CAD(p, str, indent);
	}

    /**
     * Declares a regular and a derivate variable for this expression. jmi_real_t
     * is a type that describes floating point numbers. Calls the overridden
     * method in order to continue iteration over that  ASTNode:s
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str  the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    @Override
    public void FArray.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        p.printVarDecls(getFExps(), str, indent);
    }
    
    @Override
    public void FArray.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(getFExps(), str, indent);
    }
    
    @Override
    public void FSubscriptedExp.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().printDecls_CAD(p, str, indent, getFExp().tempName_var_CAD(), getFExp().tempName_der_CAD());
    }
    
    @Override
    public void FSubscriptedExp.genTempVars_CAD(CodePrinter p, CodeStream str, String indent) {
        getFExp().type().printInit_C(p, str, indent, getFExp().tempName_var_CAD(), this);
        getFExp().type().printInit_C(p, str, indent, getFExp().tempName_der_CAD(), this);
        p.printTempInputAssigns(str, indent, getFExp());
    }
    
    @Override
    public void FSubscriptedExp.genVarExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print(getFArraySubscripts().genFunctionArrayUse_C(p, getFExp().tempName_var_CAD(), C_ARRAY_VALUE));
    }
    
    @Override
    public void FSubscriptedExp.genDerExp_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print(getFArraySubscripts().genFunctionArrayUse_C(p, getFExp().tempName_der_CAD(), C_ARRAY_VALUE));
    }

    @Override
    syn boolean FSubscriptedExp.inlineVar_CAD() = true;
    @Override
    syn boolean FSubscriptedExp.inlineDer_CAD() = true;

    /**
     * Generates temporary input variables for arrays and records.
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * TODO: Declare in genTempForFunc instead.
     * 
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str  the c-code is written to this stream 
     * @param indent  used to get a consistently formated c-code
     */
    @Override
    public void FFunctionCall.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        if (functionCallIsExp()) {
            str.print(indent);
            str.print("jmi_real_t ");
            str.println(varName_CAD() + ";");
            if (shouldBeDifferentiated()) {
                str.print(indent);
                str.print("jmi_real_t ");
                str.println(derName_CAD() + ";");
            }
        }
        getArgs().genTempArg(p.DeclStep, str, indent);
    }

    @Override
    public void FStringAddExp.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_CAD(p, str, indent);
        genVarDecls_C(p, str, indent);
    }

    /**
     * Currently unsopported functionality. 
     * 
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     * 
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str  the c-code is written to this stream 
     * @param indent  used to get a consistently formated c-code
     */
    @Override
    public void FFunctionVariable.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        if (!shouldBeDifferentiated()) {
            genVarDecls_C(p, str, indent);
        } else if (!isInput()) {
            String suffix = (isOutput() && isComposite()) ? C_SUFFIX_NULL : "";
            TypePrinter_C dp = p.createDeclPrinter(str);
            dp.setSubDecls(true);
            print(dp, varName_CAD() + suffix, indent);
            dp.setSubDecls(false);
            print(dp, derName_CAD() + suffix, indent);
        }
    }

    protected void FExp.printDecls_CAD(CodePrinter p, CodeStream str, String indent, String varName, String derName) {
        TypePrinter_C dp = p.createDeclPrinter(str);
        dp.reset(varName, this, size(), false, indent);
        dp.setSubDecls(true);
        type().print(dp);
        dp.reset(derName, this, size(), false, indent);
        dp.setSubDecls(false);
        type().print(dp);
    }
    
    public class DeclPrinter_CAD extends DeclPrinter_C {
        public DeclPrinter_CAD(CodePrinter p, CodeStream str) {
            super(p, str);
        }
        public void printArray(FType type) {
            if (subDecls)
                type.size().genVarDecls_C(p, str, indent(), src);
            super.printArray(type);
        }
    }
    public class InitPrinter_CAD extends InitPrinter_C {
        public InitPrinter_CAD(CodePrinter p, CodeStream str) {
            super(p, str);
        }
        public void printArray(FType type) {
            type.size().genTempVars_C(p, str, indent(), src);
            super.printArray(type);
        }
    }


    /*
     * TODO: This method is a duplicate from c-codegen. Should be refactored!
     */
    @Override
    public void FForIndex.genVarDecls_CAD(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_CAD(p, str, indent);
        String name = getFVariable().name_C();
        str.format("%sjmi_real_t %s;\n", indent, name);
        getFExp().genForIndexExtraVarDecls_C(p, str, indent, name);
    }
    
	/**
	 * Used to assign a unique temporary variable for this expression.	
	 */
	syn lazy String FExp.tempName_var_CAD() {
		return "tmp_var_" + myFClass().nextTempNbr_var_CAD();
	}
	
	/**
	 * Used to assign a unique temporary derivative variable for this expression.
	 */
	syn lazy String FExp.tempName_der_CAD() {
		return "tmp_der_" + myFClass().nextTempNbr_der_CAD();
	}
	
	private int FClass.tmpNbr_var = 0;
	
	/**
	 * Is called when assigning unique temporary variables. Increment index by one for each expression. 
	 */
	public int FClass.nextTempNbr_var_CAD() {
		return tmpNbr_var++;
	}
	
	private int FClass.tmpNbr_der = 0;
	
	/**
	 * Is called when assigning unique temporary derivative variables. Increment index by one for each expression. 
	 */
	public int FClass.nextTempNbr_der_CAD() {
		return tmpNbr_der++;
	}

    public class CADPrettyPrinter {
        
        @Override
        public void printTempInputAssigns(CodeStream str, String indent, FExp exp) {
            funcCallInArgPrinter.print(str, indent, exp.type(), exp.tempName_var_CAD(), exp);
            funcCallInArgPrinter_der.print(str, indent, exp.type(), exp.tempName_der_CAD(), exp);
        }
        
        protected final FuncCallInArgPrinter funcCallInArgPrinter_der = new FuncCallInArgPrinter_der();
        
        public class FuncCallInArgPrinter_der extends FuncCallInArgPrinter {
            
            public FuncCallInArgPrinter_der() {
                super(false);
            }
            
            @Override
            public void printCellExp(CodeStream str, String indent, String name, FExp exp) {
                exp.genTempInputCellAssigns_der_CAD(CADPrettyPrinter.this, str, indent, name);
            }
        }
    }

    public class CADPrettyPrinter {
        @Override
        public void printWriteBackResidual(CodeStream str, String indent, FFunctionCallLeft left,
                Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
            WriteBackResidualPrinter var_p = new WriteBackResidualPrinter_var(enumerator, forIndices, indexCounter);
            WriteBackResidualPrinter der_p = new WriteBackResidualPrinter_der(enumerator.copy(), forIndices, indexCounter.copy());
            var_p.print(str, indent, left.getFExp().type(), left.varName_CAD(), left.getFExp());
            der_p.print(str, indent, left.getFExp().type(), left.derName_CAD(), left.getFExp());
        }

        public class WriteBackResidualPrinter_var extends CodePrinter.WriteBackResidualPrinter {
            
            protected WriteBackResidualPrinter_var(Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
                super(enumerator, forIndices, indexCounter);
            }

            @Override
            public void printCellUse(CodeStream str, String indent, String name, FIdUseExp use) {
                use.genWriteBackResidual_var_CAD(str, indent, name, enumerator, forIndices, indexCounter);
            }
        }

        public class WriteBackResidualPrinter_der extends CodePrinter.WriteBackResidualPrinter {

            protected WriteBackResidualPrinter_der(Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
                super(enumerator, forIndices, indexCounter);
            }
    
            @Override
            public void printCellUse(CodeStream str, String indent, String name, FIdUseExp use) {
                use.genWriteBackResidual_der_CAD(str, indent, name, enumerator, forIndices, indexCounter);
            }
        }
    }

    /**
     * Used when generating the residual for a FFunctionCallEquation. The equationindex
     * determines which entry in the residual, res[], and directional derivative, dF[], that
     * the expressions contained in this FFunctionCallLeft fills. 
     * 
     * @param str  the c-code is written to this stream
     * @param indent  used to get a consistently formated c-code
     */
    public void FFunctionCallLeft.genWriteBack_CAD(CodeStream str, String indent, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
        if (hasFExp()) {
            if (getFExp().type().shouldBeDifferentiated()) {
                printer_CAD.printWriteBackResidual(str, indent, this, enumerator, forIndices, indexCounter);
            } else {
                printer_C.printWriteBackResidual(str, indent, this, enumerator, forIndices, indexCounter);
            }
        }
    }

    public void FIdUseExp.genWriteBackResidual_var_CAD(CodeStream str, String indent, String name, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
        int index = indexCounter.next();
        if (forIndices.size() == 0 || forIndices.contains(index)) {
            // This variable is in the set of variables to generate code for.
            str.print(indent);
            str.print("(*res)[");
            str.print(enumerator.next());
            str.print("] = ");
            str.print(name);
            str.print(" - (");
            str.print(varName_CAD());
            str.print(");\n");
        }
    }

    public void FIdUseExp.genWriteBackResidual_der_CAD(CodeStream str, String indent, String name, Enumerator enumerator, Set<Integer> forIndices, Enumerator indexCounter) {
        int index = indexCounter.next();
        if ((forIndices.size() == 0 || forIndices.contains(index)) && shouldBeDifferentiated()) {
            str.print(indent);
            str.print("(*dF)[");
            str.print(enumerator.next());
            str.print("] = ");
            str.print(name);
            str.print(" - (");
            str.print(derName_CAD());
            str.print(");\n");
        }
    }

	/*-------------------------------------------------------------------------
	 * CAD code for Statements resides bellow
	 *-----------------------------------------------------------------------*/
	//Methods to handle If clauses starts here
    @Override
	public void FIfWhenStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		for (FIfWhenClause clause : getFIfWhenClauses())
			clause.getTest().genTempVars_CAD(p, str, indent);
		str.print(indent);
		getFIfWhenClauses().prettyPrintWithSep(p, str, indent, indent + "} else ");
		prettyPrintElse_C(p, str, indent);
		str.print(indent);
		str.print("}\n");
	}
	
	//Methods to handle while loops starts here
    @Override
	public void FWhileStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		getTest().genTempVars_CAD(p, str, indent);
		str.print(indent);
		str.print("while (");
		p.print(getTest(), str, indent);
		str.print(") {\n");
		p.print(getWhileStmts(), str, p.indent(indent));
		getTest().genTempVars_CAD(p, str, p.indent(indent));
		str.print(indent);
		str.print("}\n");
	}
	
	//Methods to handle for-loops in functions starts here
    @Override
	public void FForStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		getIndex().genTempVars_CAD(p, str, indent);
		getIndex().printForIndexInit_C(p, str, indent);
		str.print(indent);
		str.print("for (");
		p.print(getIndex(), str, indent);
		str.print(") {\n");
		getIndex().printForIndexNext_C(p, str, p.indent(indent));
		p.print(getForStmts(), str, p.indent(indent));
		str.print(indent);
		str.print("}\n");
	}

    /**
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param indent  used to get a consistently formated c-code
     * @param str  the c-code is written to this stream 
     */
    @Override
    public void FReturnStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
        returnDefinition().printReturnWrite_CAD(str, indent);
        // TODO: Check if there are any dynamic declarations first
        str.print(indent + "JMI_DYNAMIC_FREE()\n");
        str.print(indent + "return;\n");
    }

    @Override
	public void FFunctionCallStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored())
			genTempVars_CAD(p, str, indent);
	}
	
    @Override
	public void FFunctionCallEquation.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored())
			genTempVars_CAD(p, str, indent);
	}

    /**
     *  Prints AD code for this assignement statement
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param indent  used to get a consistently formated c-code
     * @param str  the c-code is written to this stream 
     */
    @Override
    public void FAssignStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
        genTempVars_CAD(p, str, indent);
        str.print(indent);
        p.print(getLeft(), str, indent);
        str.print(" = ");
        p.print(getRight(), str, indent);
        str.print(";\n");

        if (shouldBeDifferentiated()) {
            str.print(indent);
            str.print(((FIdUseExp)getLeft()).getFIdUse().toString_der_CAD(p));
            str.print(" = ");
            getRight().genDer_CAD(p, str, indent);
            str.print(";\n");
        }
    }
	
	/*-------------------------------------------------------------------------
	 * END CAD code for statements
	 *-----------------------------------------------------------------------*/

    /**
     * Used to declare function headers. 
     * 
     * @param indent  used to get a consistently formated c-code
     * @param str  the c-code is written to this stream 
     */
    public void FFunctionDecl.genHeader_CAD(CodeStream str, String indent) {
        if (!shouldPrintFuncDecl_CAD())
            return;
        prettyPrintHead_CAD(printer_CAD, str, indent, "void", "der_AD", true);
        str.print(";\n");
    }

    /**
     *  Functions in Modelica may have derivative annotations associated with them. 
     * When printing the body of a function a check is made to see if it has a derivative
     * annotation, if so this function is called that assigns the variables of the function
     * by calling its non-AD counterpart and its derivatives by calling its derivative annotation. 
     * Only variables of type real can be filled by the derivative function, if they are not of 
     * type real they are omitted in the printed call.
     * 
     * @param str  the c-code is written to this stream 
     */
    public void FFunctionDecl.genFuncAnnotation_CAD(CodePrinter p, CodeStream str, String indent){
        for (FFunctionVariable ffv : myOutputs())
            ffv.genVarDecls_CAD(p, str, indent);
        str.print(indent);
        str.print("/*Using specified derivative annotation instead of AD*/\n");
        
        genNonADFunctionCall_CAD(p, str, indent);
        
        // Print the call to the specified derivative function
        AnnotationNode derNode = derivativeAnnotationUnrestricted();
        str.print(indent);
        str.print(derivativeFunction(derNode).funcNameUnderscore("def") + "(");
        String sep = "";
        for (FFunctionVariable ffv : myInputs()){
            str.print(sep);
            sep = ", ";
            if (ffv.shouldBeDifferentiated(derNode)) {
                str.print(ffv.varName_CAD());
            } else {
                str.print(ffv.name_C());
            }
        }
        for (FFunctionVariable ffv : myInputs()){
            if (ffv.shouldBeDifferentiated(derNode)){
                str.print(sep);
                sep = ", ";
                str.print(ffv.derName_CAD());
            }
        }
        for (FFunctionVariable ffv : myOutputs()){
            if (ffv.shouldBeDifferentiated(derNode)) {
                str.print(sep);
                sep = ", ";
                if (!ffv.isComposite()) {
                    str.print("&");
                }
                str.print(ffv.derName_CAD());
            }
        }
        str.print(");\n");
    }

    /**
     * Function for generating a dummy function that only calls the normal function and also
     * set output derivatives to zero. 
     */
    public void FFunctionDecl.genZeroDerivativeFunction_CAD(CodePrinter p, CodeStream str, String indent) {
        for (FFunctionVariable ffv : myOutputs())
            ffv.genVarDecls_CAD(p, str, indent);
        str.print(indent);
        str.print("/*Zero derivative function*/\n");
        
        genNonADFunctionCall_CAD(p, str, indent);
        
        AnnotationNode derNode = derivativeAnnotationUnrestricted();
        for (FFunctionVariable ffv : myOutputs())
            if(ffv.shouldBeDifferentiated(derNode))
                str.format("%s%s = 0;\n", indent, ffv.derName_CAD());
    }

    /**
     * Generates a function call to the non AD function.
     */
    public void FFunctionDecl.genNonADFunctionCall_CAD(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        str.print(funcNameUnderscore("def") + "(");
        String sep = "";
        AnnotationNode derNode = derivativeAnnotationUnrestricted();
        for (FFunctionVariable ffv : myInputs()){
            str.print(sep);
            sep = ", ";
            if (ffv.shouldBeDifferentiated(derNode)) {
                str.print(ffv.varName_CAD());
            } else {
                str.print(ffv.name_C());
            }
        }
        for (FFunctionVariable ffv : myOutputs()){
            str.print(sep);
            sep = ", ";
            if (!ffv.isComposite()) {
                str.print("&");
            }
            if (ffv.shouldBeDifferentiated(derNode)) {
                str.print(ffv.varName_CAD());
            } else {
                str.print(ffv.name_C());
            }
        }
        str.print(");\n");
    }

	syn boolean FFunctionDecl.shouldPrintFuncDecl_CAD() = requiresDerivative() && functionIsUsedAsDerivative();

    /**
     *  Prints a function, the header and body. A check is made whether the function
     * has a derivative annotation, if so the body of the function is printed in a 
     * special way. 
     * Since the function may have NULL inputs a check is made at the end of the function,
     * if some of the inputs that are to be filled by the function are NULL they are 
     * not updated. 
     * 
     * @param p            use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str          the c-code is written to this stream 
     * @param outerIndent  used to get a consistently formated c-code
     */
    @Override
    public void FFunctionDecl.prettyPrint_CAD(CodePrinter p, CodeStream str, String outerIndent) {
        if (!shouldPrintFuncDecl_CAD())
            return;
        String indent = p.indent(outerIndent);
        // Print definition
        prettyPrintHead_CAD(p, str, outerIndent, "void", "der_AD", true);
        str.print(" {\n");
        str.print(indent + "JMI_DYNAMIC_INIT()\n");
        if (derivativeFunctionUnrestricted() != null){
            genFuncAnnotation_CAD(p, str, indent);
            genReturnStmt_CAD(p, str, indent);
        } else if (derivativeEqualsZero()){
            genZeroDerivativeFunction_CAD(p, str, indent);
            genReturnStmt_CAD(p, str, indent);
        } else {
            genVarDecls_CAD(p, str, indent);
            for (FFunctionVariable ffv : myNonInputs()) {
                if (!ffv.isArray()) {
                    p.print(ffv, str, indent);
                }
            }
            p.print(getFAlgorithm(), str, indent);
        }
        str.print(outerIndent + "}\n\n");
    }

	public void FFunctionDecl.genReturnStmt_CAD(CodePrinter p, CodeStream str, String indent) {
		returnDefinition().printReturnWrite_CAD(str, indent);
		str.print(indent + "JMI_DYNAMIC_FREE()\n");
		str.print(indent + "return;\n");
	}
	
    @Override
	public void FFunctionVariable.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
        FInitArrayStmt.genInit_C(p, str, indent, varName_CAD(), this, type());
        FInitArrayStmt.genInit_C(p, str, indent, derName_CAD(), this, type());
    }
    
    @Override
    public void FInitArrayStmt.prettyPrint_CAD(CodePrinter p, CodeStream str, String indent) {
        FFunctionVariable fv = getFIdUseExp().myFuncFV();
        FInitArrayStmt.genInit_C(p, str, indent, fv.varName_CAD(), fv, type());
        FInitArrayStmt.genInit_C(p, str, indent, fv.derName_CAD(), fv, type());
    }
    
    /**
     *  Loops through its FFunctionVariables, calls a function on each that prints
     * code for checking if the corresponding function variables input was set as NULL. 
     * Is used to handle NULL arguments in functions.
     * 
     * @param str  the c-code is written to this stream 
     * @param indent  used to get a consistently formated c-code
     */
    public void FunctionReturnDefinition.printReturnWrite_CAD(CodeStream str, String indent) {
        AnnotationNode derNode = decl.derivativeAnnotationUnrestricted();
        for (FFunctionVariable v : outputs)
            if (v.shouldBeDifferentiated(derNode))
                v.printReturnWrite_CAD(str, indent);
            else
                v.printReturnWrite_C(str, indent);
    }

    /**
     *  Prints code that checks whether the variables corresponding return varible was set as
     * NULL, if not the return variable is set to this variables value. Is used to handle NULL
     * inputs in functions. 
     * 
     * @param str  the c-code is written to this stream 
     * @param indent  used to get a consistently formated c-code
     */
    public void FFunctionVariable.printReturnWrite_CAD(CodeStream str, String indent) {
        if (!isRecord()) {
            str.print(indent);
            str.print("if (");
            str.print(varReturnName_CAD());
            str.print(" != NULL) *");
            str.print(varReturnName_CAD());
            str.print(" = ");
            str.print(varName_CAD());
            str.print(";\n");
            str.print(indent);
            str.print("if (");
            str.print(derReturnName_CAD());
            str.print(" != NULL) *");
            str.print(derReturnName_CAD());
            str.print(" = ");
            str.print(derName_CAD());
            str.print(";\n");
        }
    }

    @Override
    public void FFunctionArray.printReturnWrite_CAD(CodeStream str, String indent) {}

    //end returns from functions

    //Function declarations and headers
    /**
     *  Generates the header for this function declaration in this way:
     * type functionname_suffix(inputs, (returnArgs? outputs:""))
     * 
     * @param p  use CADPrettyPrinter for p.print to call prettyPrint_CAD
     * @param str  the c-code is written to this stream 
     * @param indent  used to get a consistently formated c-code
     * @param type  the functions return type
     * @param suffix  typically der_AD for AD functions
     * @param returnArgs  specifies whether return arguments should be printed or not
     */
    private void FFunctionDecl.prettyPrintHead_CAD(CodePrinter p, CodeStream str, String indent, 
            String type, String suffix, boolean returnArgs) {
        str.print(indent);
        str.print(type);
        str.print(" ");
        str.print(funcNameUnderscore(suffix));
        str.print("(");
        String sep = "";
        AnnotationNode derNode = derivativeAnnotationUnrestricted();
        for (FFunctionVariable v : myInputs()) {
            str.print(sep);
            if (v.shouldBeDifferentiated(derNode)) {
                v.printArgument_var_CAD(str);
            } else {
                v.printArgument_C(str);
            }
            sep = ", ";
        }
        for (FFunctionVariable v : myInputs()) {
            if (v.shouldBeDifferentiated(derNode)){
                str.print(sep);
                v.printArgument_der_CAD(str);
            }
        }
        if (returnArgs) {
            for (FFunctionVariable v : myOutputs()) {
                str.print(sep);
                if (v.shouldBeDifferentiated(derNode)) {
                    v.printReturnArgument_var_CAD(str);
                } else {
                    v.printReturnArgument_C(str);
                }
                sep = ", ";
            }
        }
        if (returnArgs) {
            for (FFunctionVariable v : myOutputs()) {
                if (v.shouldBeDifferentiated(derNode)) {
                    str.print(sep);
                    v.printReturnArgument_der_CAD(str);
                    sep = ", ";
                }
            }
        }
        str.print(")");
    }

    /**
     * Prints the argument's C type and name for this variable, used when generating function headers. 
     * 
     * @param str  the c-code is written to this stream
     */
    public void FFunctionVariable.printArgument_var_CAD(CodeStream str) {
        str.print(type_C());
        str.print(" "  + varName_CAD());
    }

    /**
     * Prints the derivative argument's C type and name for this variable, used when generating function headers.
     * It is assumed that this function is called for real arguments only, since discrete lack derivatives. Thus
     * no explicit check is made for the non-real scenario.
     * 
     * @param str  the c-code is written to this stream
     */
    public void FFunctionVariable.printArgument_der_CAD(CodeStream str) {
        str.print(type_C());
        str.print(" ");
        str.print(derName_CAD());
    }

    /**
     * Prints variables return argument, used when generating function headers.
     * 
     * @param str  the c-code is written to this stream
     */
    public void FFunctionVariable.printReturnArgument_var_CAD(CodeStream str) {
        str.print(typeReturn_C());
        str.print(" ");
        str.print(varReturnName_CAD());
    }

    /**
     * Prints derivative variables return argument, used when generating function headers.
     * When calling a function with derivative outputs for non real variables this return
     * argument should be set to NULL, in that case no derivative will be set for this variable
     * (see printReturnWrite_CAD) 
     * 
     * @param str  the c-code is written to this stream
     */
    public void FFunctionVariable.printReturnArgument_der_CAD(CodeStream str) {
        str.print(typeReturn_C());
        str.print(" ");
        str.print(derReturnName_CAD());
    }

	syn lazy String FAbstractVariable.varName_CAD() = name_C();
	syn lazy String FAbstractVariable.derName_CAD() = "0";
	
	eq FFunctionVariable.varName_CAD() = nameUnderscore() + "_var_" + C_SUFFIX_VARIABLE;
	eq FFunctionArray.varName_CAD()    = nameUnderscore() + "_var_" + C_SUFFIX_ARRAY;
	eq FFunctionVariable.derName_CAD() = nameUnderscore() + "_der_" + C_SUFFIX_VARIABLE;
	eq FFunctionArray.derName_CAD()    = nameUnderscore() + "_der_" + C_SUFFIX_ARRAY;
	
	syn String FFunctionVariable.varReturnName_CAD() = 
		isRecord() ? varName_CAD() : (getFQName().nameUnderscore() + "_var_" + C_SUFFIX_RETURN);
	syn String FFunctionArray.varReturnName_CAD()    = varName_CAD();
	
	syn String FFunctionVariable.derReturnName_CAD() = 
		isRecord() ? derName_CAD() : (getFQName().nameUnderscore() + "_der_" + C_SUFFIX_RETURN);
	syn String FFunctionArray.derReturnName_CAD()    = derName_CAD();
	
	//end functions
	
}