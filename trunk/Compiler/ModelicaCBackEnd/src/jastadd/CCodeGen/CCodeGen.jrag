/*
Copyright (C) 2009 Modelon AB
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.Stack;

import org.jmodelica.util.Enumerator;
import org.jmodelica.util.streams.CStringCodeStream;

aspect CCodeGen {

    /**
     * Static printer instance.
     */
    static CPrettyPrinter ASTNode.printer_C = new CPrettyPrinter();

    public class CPrettyPrinter extends CodePrinter {

        public CPrettyPrinter() {
            this(null, false, Homotopy.HOMOTOPY, true);
        }
        
        public CPrettyPrinter(AbstractEquationBlock block) {
            this(block, false, Homotopy.HOMOTOPY, false);
        }

        protected CPrettyPrinter(AbstractEquationBlock block, boolean inInitialSystem, Homotopy homotopyType,
                boolean writeSwitches) {
            super(block, inInitialSystem, homotopyType, writeSwitches);
        }

        @Override
        protected CodePrinter createPrinter(AbstractEquationBlock block, boolean inInitialSystem, Homotopy homotopyType,
                boolean writeSwitches) {
            return new CPrettyPrinter(block, inInitialSystem, homotopyType, writeSwitches);
        }

        @Override
        public void print(ASTNode node, CodeStream str, String indent) { 
            node.prettyPrint_C(this, str, indent); 
        }

        @Override
        public void printVarDecls(ASTNode node, CodeStream str, String indent) {
            node.genVarDecls_C(this, str, indent);
        }
        
        @Override
        public void printDecl(ASTNode node, CodeStream str, String indent, Set<ASTNode> visited, Collection<FVariable> forVariables, boolean solved) {
            node.printDecl_C(this, str, indent, visited, forVariables, solved);
        }
        
        @Override
        public void printPreSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempVars_C(this, str, indent);
        }
        
        @Override
        public void printPostSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempFree_C(this, str, indent);
        }

        @Override
        public TypePrinter_C createDeclPrinter(CodeStream str) {
            return new DeclPrinter_C(this, str);
        }
        
        @Override
        public TypePrinter_C createInitPrinter(CodeStream str) {
            return new InitPrinter_C(this, str);
        }
        
        @Override
        public TypePrinter_C createInitSetPrinter(CodeStream str) {
            return new InitSetPrinter_C(this, str);
        }

        @Override
        public void genBlockResidualCall(AbstractEquationBlock block, CodeStream str, String indent) {
            block.genBlockResidualCall_C(this, str, indent);
        }

        @Override
        public void genSolved(FAbstractEquation node, CodeStream str, String indent,
                Set<FAbstractEquation> visited, Collection<FVariable> forVariables, Collection<Integer> forIndices) {
            node.genBlock_C(this, str, indent, visited, forVariables, forIndices);
        }

        @Override
        public void genResidual(FAbstractEquation node, CodeStream str, String indent, Enumerator enumerator,
                Set<FAbstractEquation> visited, Set<Integer> forIndices) {
            node.genResidual_C(this, str, indent, enumerator, visited, forIndices);
        }
    }

	public String ASTNode.prettyPrint_C(String indent) {
		ByteArrayOutputStream os = new ByteArrayOutputStream();
		CodeStream str = new CodeStream(os);
		prettyPrint_C(str,indent);
		return os.toString();
	}

	public void ASTNode.prettyPrint_C(CodeStream str, String indent) {
 		prettyPrint_C(printer_C, str, indent);
	}

    public void ASTNode.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this)
            node.genVarDecls_C(p, str, indent);
    }
    
    public void ASTNode.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this)
            p.printPreSteps(node, str, indent);
    }
    
	public void ASTNode.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
 		prettyPrint(p, str, indent);
	}
	
    public void ASTNode.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this)
            p.printPostSteps(node, str, indent);
    }

    syn boolean FFunctionCall.impureCodeGen(CodePrinter p) = !type().isComposite() && !type().isString() &&
            inWhen() && !isFunctionCallClause() && p.inBlock() && !dependsOnBlock(p.getBlock());
    syn String FFunctionCall.tempNameComputed_C() = tempName_C() + "_computed";

    public void FFunctionCall.genStaticVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        str.print("static ");
        type().printScalarDecl_C(str, indent, false, tempName_C());
        str.format("%sstatic int %s = 0;\n", indent, tempNameComputed_C());
    }

    public void FFunctionCall.genStaticTempVars_C(CodePrinter p, CodeStream str, String indent) {
        str.format("%s%s = 0;\n", indent, tempNameComputed_C());
    }

    @Override
    public void FFunctionCall.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        getArgs().genTempArg(p.DeclStep, str, indent);
        if (!functionCallIsExp() && myFCallable().isPartialFunction() && !isPartialFunctionCall()) {
            str.formatln("%s%s %s;", indent, myFCallable().actualFFunctionDecl().funcNameUnderscore(C_SUFFIX_FPOUT), tempName_C());
        }
        if (isStringExp()) {
            type().printScalarDecl_C(str, indent, false, tempName_C());
        }
    }
    
    @Override
    public void FFunctionCall.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        getArgs().genTempArg(p.PreStep, str, indent);
        if (isStringExp()) {
            str.print(indent);
            str.print(tempName_C());
            str.print(" = ");
            myFCallable().prettyPrintCall_C(p, str, indent, this);
            str.println(";");
        }
    }

    @Override
    public void FFunctionCall.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        if (isStringExp()) {
            str.print(tempName_C());
        } else if (impureCodeGen(p)) {
            str.format("JMI_CACHED(%s, ", tempName_C());
            myFCallable().prettyPrintCall_C(p, str, indent, this);
            str.print(")");
        } else {
            myFCallable().prettyPrintCall_C(p, str, indent, this);
        }
    }

    @Override
    public void FFunctionCall.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        getArgs().genTempArg(p.PostStep, str, indent);
        if (isStringExp()) {
            type().printFree_C(str, indent, false, tempName_C());
        }
    }

    syn boolean FFunctionCall.isStringExp() = functionCallIsExp() && type().isString();
    
    
    public interface FCallable {
        /**
         * \brief Generate a call to this callable.
         */
        public void prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call);
    }
    
    @Override
    public void FFunctionDecl.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call) {
        boolean exp = call.functionCallIsExp();
        if (!exp)
            str.print(indent);
        str.print(funcNameUnderscore(exp ? C_SUFFIX_EXP : C_SUFFIX_DEF));
        str.print("(");
        String sep = "";
        for (FExp arg : call.getArgs()) {
            str.print(sep);
            arg.genTempArg(p.ExecStep, str, indent);
            sep = ", ";
        }
        if (!exp) {
            call.prettyPrintCallOutputs_C(p, str, indent, myOutputs().size(), sep);
        }
        str.print(")");
        if (!exp)
            str.print(";\n");
    }
    
    public void FAbstractFunctionCall.prettyPrintCallOutputs_C(CodePrinter p, CodeStream str, String indent, int outputs, String sep) {
        int lefts = myLefts().size();
        for (int i = 0; i < outputs; i++) {
            str.print(sep);
            if (i < lefts) {
                myLefts().get(i).genArgument_C(str);
            } else if (i == 0 && lefts == 0 && isFunctionCallArg()) {
                str.print(tempName_C());
            } else {
                str.print("NULL");
            }
            sep = ", ";
        }
    }
    
    @Override
    public void FFunctionVariable.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call) {
        boolean exp = call.functionCallIsExp();
        String out = "NULL";
        if (!exp) {
            out = call.tempName_C();
            str.formatln("%s%s.n = %s;", indent, out, call.myLefts().size());
            out = "&" +out;
            str.print(indent);
        }
        str.format("%s->fpcl(%s, %s", name_C(), name_C(), out);
        String sep = ", ";
        for (FExp arg : call.getArgs()) {
            str.format("%s(%s)(", sep, arg.type().type_C());
            arg.genTempArg(p.ExecStep, str, indent);
            str.print(")");
        }
        str.print(")");
        if (!exp)
            str.print(";\n");
        if (!exp) {
            int tot = myOutputs().size();
            int lefts = call.myLefts().size();
            for (int i = 0; i < tot; i++) {
                if (i < lefts) {
                    String n = call.myLefts().get(i).prettyPrint_C(indent);
                    str.formatln("%s%s = %s.%s;", indent, n, call.tempName_C(), n);
                }
            }
        }
    }
    
    @Override
    public void FPartialFunctionCall.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        boolean exp = functionCallIsExp();
        FCallable fc = myFCallable();
        String previous = "NULL";
        String result   = "NULL";
        if (fc.isPartialFunction()) {
            previous = ((FFunctionVariable) fc).name_C();
        } else {
            result = "&" + tempName_C();
        }
        if (fc.isPartialFunction()) {
            str.print(previous);
            str.print("->fpcr");
        } else {
            str.print(fc.funcNameUnderscore(C_SUFFIX_FPCR));
        }
        str.print("(");
        str.print(previous);
        str.print(", ");
        str.print(result);
        
        /* Print "0" for the inputs we don't set, and "1, value" for those we do set */
        Iterator<FIdUse> it = getArgNames().iterator();
        Iterator<FFunctionVariable> it2 = fc.myInputs().iterator();
        for (FExp arg : getArgs()) {
            String name = it.next().name();
            while (!it2.next().name().equals(name)) {
                str.print(", 0");
            }
            str.print(", 1");
            
            str.print(", ");
            str.format("(%s)(", arg.type().type_C());
            arg.genTempArg(p.ExecStep, str, indent);
            str.print(")");
        }
        while (it2.hasNext()) {
            str.print(", 0");
            it2.next();
        }
        
        str.print(")");
    }
	
	public String FunctionReturnDefinition.getDeclaredType_C() {
		if (outputs.size() > 0) 
			return outputs.get(0).type_C();
		else
			return "void";
	}
	
	public void FunctionReturnDefinition.printReturnForExp_C(CodeStream str, String indent) {
		str.print(indent);
		str.print("return");
		if (outputs.size() > 0) { 
			str.print(" ");
			str.print(outputs.get(0).name_C());
		}
		str.print(";\n");
	}
	
	public void FunctionReturnDefinition.printDeclarationForExp_C(CodePrinter p, CodeStream str, String indent) {
		if (outputs.size() > 0) 
			outputs.get(0).genVarDecls_C(p, str, indent);
	}
	
	public void FunctionReturnDefinition.printReturnWrite_C(CodeStream str, String indent) {
		for (FFunctionVariable v : outputs) 
			v.printReturnWrite_C(str, indent);
	}
	
	
	private void FFunctionDecl.prettyPrintHead_C(CodePrinter p, CodeStream str, String indent, 
			String type, String suffix, boolean returnArgs) {
		str.print(indent);
		str.print(type);
		str.print(" ");
		str.print(funcNameUnderscore(suffix));
		str.print("(");
		String sep = "";
		for (FFunctionVariable v : myInputs()) {
			str.print(sep);
			v.printArgument_C(str);
			sep = ", ";
		}
		if (returnArgs) {
			for (FFunctionVariable v : myOutputs()) {
				str.print(sep);
				v.printReturnArgument_C(str);
				sep = ", ";
			}
		}
		str.print(")");
	}
	
	private void FFunctionDecl.prettyPrintWrappedCall_C(CodeStream str, String indent) {
		if (!shouldPrintFuncDecl_C())
			return;
		str.print(indent);
		str.print(funcNameUnderscore(C_SUFFIX_DEF));
		str.print("(");
		String sep = "";
		for (FFunctionVariable v : myInputs()) {
			str.print(sep);
			str.print(v.name_C());
			sep = ", ";
		}
		if (myOutputs().size() > 0) {
			str.print(sep);
			str.print("&");
			str.print(myOutputs().get(0).name_C());
			for (int i = myOutputs().size() - 1; i > 0; i--)
				str.print(", NULL");
		}
		str.print(");\n");
	}
	
	public void FFunctionDecl.genHeader_C(CodeStream str, String indent) {
		if (!shouldPrintFuncDecl_C())
			return;
		prettyPrintHead_C(printer_C, str, indent, "void", C_SUFFIX_DEF, true);
		str.print(";\n");
    	if (generateExpFunction()) {
    		String type = returnDefinition().getDeclaredType_C();
			prettyPrintHead_C(printer_C, str, indent, type, C_SUFFIX_EXP, false);
			str.print(";\n");
    	}
	}
	
    /**
     * \brief Generates forward declarations for FPCL and FPCR functions used
     * by partial function calls.
     */
    public void FFunctionDecl.genHeadersPartial_C(CodeStream str, String indent) {
        prettyPrintHeadFPCL_C(str, indent);
        str.println(";");
        prettyPrintHeadFPCR_C(str, indent);
        str.println(";");
    }
    
    /**
     * \brief Generates FP and OUT structs used by partial function calls.
     */
    public void FFunctionDecl.genStructsPartial_C(CodeStream str, String indent) {
        CodePrinter p = ASTNode.printer_C;
        String fp  = funcNameUnderscore(C_SUFFIX_FP);
        String out = funcNameUnderscore(C_SUFFIX_FPOUT);
        String next = p.indent(indent);
        
        beginStruct_C(str, indent, out);
        str.formatln("%sint n;", next);
        for (FFunctionVariable ffv : myOutputs()) {
            str.formatln("%s%s %s;", next, ffv.type().type_C(), ffv.name_C());
        }
        endStruct_C(str, indent);
        
        beginStruct_C(str, indent, fp);
        str.formatln("%s%s (*fpcl)(%s*, %s*, ...);", next, returnDefinition().getDeclaredType_C(), fp, out);
        str.formatln("%s%s* (*fpcr)(%s*, %s*, ...);", next, fp, fp, fp);
        for (FFunctionVariable ffv : myInputs()) {
            String name = ffv.name_C();
            str.formatln("%s%s %s;", next, ffv.type().type_C(), name);
            str.formatln("%sint %s_s;", next, name);
        }
        endStruct_C(str, indent);
    }
    
    /**
     * \brief Generate first line of struct declaration name_ with typedef to name
     */
    public static void FFunctionDecl.beginStruct_C(CodeStream str, String indent, String name) {
        str.formatln("%stypedef struct %s_ %s;", indent, name, name);
        str.formatln("%sstruct %s_ {", indent, name);
    }
    
    /**
     * \brief Generate last line of struct declaration
     */
    public static void FFunctionDecl.endStruct_C(CodeStream str, String indent) {
        str.formatln("%s};", indent);
    }
    
    /**
     * \brief Generate declaration for varargs
     */
    public void FFunctionDecl.genVarArgsDecl(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_list argp;");
    }
    
    /**
     * \brief Generate initialization for varargs
     */
    public void FFunctionDecl.genVarArgsOpen(CodeStream str, String indent, String last) {
        str.print(indent);
        str.print("va_start(argp, ");
        str.print(last);
        str.println(");");
    }
    
    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String indent, String dest, String type) {
        str.print(indent);
        str.print(dest);
        str.print(" = ");
        genVarArgsRead(str, type);
        str.println(";");
    }
    
    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String type) {
        str.print("va_arg(argp, ");
        str.print(type);
        str.print(")");
    }
    
    /**
     * \brief Generate closing for varargs
     */
    public void FFunctionDecl.genVarArgsClose(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_end(argp);");
    }
    
    /**
     * \brief Generate header for FPCL function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCL_C(CodeStream str, String indent) {
        str.format("%s%s %s(%s* fp_in, %s* out, ...)", indent, returnDefinition().getDeclaredType_C(), funcNameUnderscore(C_SUFFIX_FPCL), funcNameUnderscore(C_SUFFIX_FP), funcNameUnderscore(C_SUFFIX_FPOUT));
    }
    
    /**
     * \brief Generate header for FPCR function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCR_C(CodeStream str, String indent) {
        String fp = funcNameUnderscore(C_SUFFIX_FP);
        str.format("%s%s* %s(%s* fp_in, %s* fp_out, ...)", indent, fp, funcNameUnderscore(C_SUFFIX_FPCR), fp, fp);
    }
	
	/**
	 * Helper method that checks wether the functiondecl should be printed.
	 */
	syn boolean FFunctionDecl.shouldPrintFuncDecl_C() = functionIsUsed();
	
    @Override
	public void FFunctionDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!shouldPrintFuncDecl_C())
			return;
		String next = p.indent(indent);
		// Print definition
		prettyPrintHead_C(p, str, indent, "void", C_SUFFIX_DEF, true);
		str.print(" {\n");
        ASTNode.genDynMemInit(str, next);
		genVarDecls_C(p, str, p.indent(indent));
        for (FFunctionVariable ffv : myNonInputs()) {
            if (!ffv.isArray()) {
                p.print(ffv, str, next);
            }
        }
    	p.print(getFAlgorithm(), str, next);
    	str.print(indent);
    	str.print("}\n\n");
    	
    	// Print wrapper for expressions
    	if (generateExpFunction()) {
	    	String type = returnDefinition().getDeclaredType_C();
			prettyPrintHead_C(p, str, indent, type, C_SUFFIX_EXP, false);
			str.print(" {\n");
			returnDefinition().printDeclarationForExp_C(p, str, next);
			prettyPrintWrappedCall_C(str, next);
			returnDefinition().printReturnForExp_C(str, next);
	    	str.print(indent);
	    	str.print("}\n\n");
    	}
	}
	
    /**
     * \brief Generates FPCL and FPCR functions used by partial function calls.
     */
    public void FFunctionDecl.prettyPrintPartial_C(CodeStream str, String indent) {
        int i;
        CodePrinter p = ASTNode.printer_C;
        String next = p.indent(indent);
        String next2 = p.indent(next);
        String next3 = p.indent(next2);
        String fp = funcNameUnderscore(C_SUFFIX_FP);
        ArrayList<FFunctionVariable> inputs  = myInputs();
        ArrayList<FFunctionVariable> outputs = myOutputs();
        int n = inputs.size() + outputs.size();
        String[] names = new String[n];
        for (i = 0; i < n; i++) {
            names[i] = "tmp_" + (i+1); 
        }
        
        // FPCL
        prettyPrintHeadFPCL_C(str, indent);
        str.print(" {\n");
        
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%s%s %s;", next, ffv.type_C(), names[i++]);
        }
        for (FFunctionVariable ffv : outputs) {
            str.formatln("%s%s %s;", next, ffv.type_C(), names[i++]);
        }
        
        genVarArgsDecl(str, next);
        genVarArgsOpen(str, next, "out");
        i = 0;
        for (FFunctionVariable ffv : inputs) {
              str.formatln("%sif (fp_in->%s_s) {", next, ffv.name_C());
              str.formatln("%s%s = fp_in->%s;", next2, names[i], ffv.name_C());
              str.formatln("%s} else {", next);
              genVarArgsRead(str, next2, names[i], ffv.type_C());
              str.formatln("%s}", next);
              i++;
        }
        genVarArgsClose(str, next);
        
        str.format("%s%s(", next, funcNameUnderscore("def"));
        String prefix = "";
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.print(prefix);
            str.print(names[i++]);
            prefix = ", ";
        }
        for (FFunctionVariable ffv : outputs) {
            str.print(prefix);
            str.print("&");
            str.print(names[i++]);
        }
        str.println(");");
        
        str.formatln("%sif (out != NULL) {",next);
        i = 0;
        for (FFunctionVariable ffv : outputs) {
              str.formatln("%sif (out->n > %d) {", next2, i);
              str.formatln("%sout->%s = %s;", next3, ffv.name_C(), names[i + inputs.size()]);
              str.formatln("%s}", next2);
              i++;
        }
        str.formatln("%s}",next);
        if (outputs.size() > 0)
            str.formatln("%sreturn %s;", next, names[inputs.size()]);
        str.format("%s}\n\n", indent);
        
        
        // FPCR
        prettyPrintHeadFPCR_C(str, indent);
        str.print(" {\n");
        genVarArgsDecl(str, next);
        str.formatln("%sif (fp_out == NULL) {", next);
        str.formatln("%sfp_out = malloc(sizeof(%s));", next2, fp);
        str.formatln("%s}", next);
        
        str.formatln("%sfp_out->fpcl = &%s;", next, funcNameUnderscore(C_SUFFIX_FPCL));
        str.formatln("%sfp_out->fpcr = &%s;", next, funcNameUnderscore(C_SUFFIX_FPCR));
        
        str.formatln("%sif (fp_in == NULL) {", next);
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%sfp_out->%s_s = 0;", next2, ffv.name_C());
        }
        str.formatln("%s} else {", next);
        for (FFunctionVariable ffv : inputs) {
            String name = ffv.name_C();
            str.formatln("%sfp_out->%s_s = fp_in->%s_s;", next2, name, name);
            str.formatln("%sfp_out->%s = fp_in->%s;", next2, name, name);
        }
        str.formatln("%s}", next);
        
        genVarArgsOpen(str, next, "fp_out");
        for (FFunctionVariable ffv : inputs) {
            String name = ffv.name_C();
            str.format("%sif (!fp_out->%s_s && ", next, name);
            genVarArgsRead(str, "int");
            str.println(") {");
            str.formatln("%sfp_out->%s_s = 1;", next2, name);
            genVarArgsRead(str, next2, "fp_out->" + name, ffv.type_C());
            str.formatln("%s}", next);
        }
        genVarArgsClose(str, next);
        
        str.formatln("%sreturn fp_out;", next);
        str.format("%s}\n\n", indent);
    }
	
	/**
	 * Check if we need to generate a wrapper for expressions for this function.
	 */
	syn boolean FFunctionDecl.generateExpFunction() = hasOutputs() && !isComposite();
	
	
	
	
	
	
	
	
    syn String FRecordDecl.name_C()      = getFQName().lastActualTypePartName() + "_" + recordIndex();
	
    @Override
    public void FRecordDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        p.print(type(), str, indent);
    }
    
    @Override
    public void FRecordType.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        // Scalar type
        printStruct_C(p, str, indent, false);
        
        //Array type
		str.print(indent);
		str.print("JMI_ARRAY_TYPE(");
        str.print(nameScalar_C());
		str.print(", ");
		str.print(nameArray_C());
		str.print(")\n\n");
        
        // External type
        if (externalValid()) {
            printStruct_C(p, str, indent, true);
        }
        str.print("\n");
    }

    public void FRecordType.printStruct_C(CodePrinter p, CodeStream str, String indent, boolean ext) {
        String name = ext ? nameScalarExt_C() : nameScalar_C();
        FFunctionDecl.beginStruct_C(str, indent, name);
        String next = p.indent(indent);
        for (FRecordComponentType frct : getComponents()) {
            str.print(next);
            str.print(ext ? frct.getFType().nameScalarExt_C() : frct.getFType().type_C());
            str.print(" ");
            str.print(frct.getName());
            str.print(";\n");
        }
        if (getNumComponent() == 0) {
            // always generate default field so that C struct is not empty
            str.print(next + "char dummy;\n");
        }
        FFunctionDecl.endStruct_C(str, indent);
    }
    
	// Suffixes that are used with variables in JMI: size, var, arr, rec
	public static final String ASTNode.C_SUFFIX_DEF      = "def";
	public static final String ASTNode.C_SUFFIX_EXP      = "exp";
	public static final String ASTNode.C_SUFFIX_REC      = "r";
    public static final String ASTNode.C_SUFFIX_EXT      = "_ext";
	public static final String ASTNode.C_SUFFIX_ENUM     = "e";
	public static final String ASTNode.C_SUFFIX_INDEX    = "i";
	public static final String ASTNode.C_SUFFIX_VARIABLE = "v";
	public static final String ASTNode.C_SUFFIX_ARRAY    = "a";
	public static final String ASTNode.C_SUFFIX_RETURN   = "o";
	public static final String ASTNode.C_SUFFIX_NULL     = "n";

	public static final String ASTNode.C_ARRAY_RECORD    = "rec";
	public static final String ASTNode.C_ARRAY_REFERENCE = "ref";
	public static final String ASTNode.C_ARRAY_VALUE     = "val";
    
    // Suffixes used with functional arguments
    public static final String ASTNode.C_SUFFIX_FP       = "fp";
    public static final String ASTNode.C_SUFFIX_FPCL     = "fpcl";
    public static final String ASTNode.C_SUFFIX_FPCR     = "fpcr";
    public static final String ASTNode.C_SUFFIX_FPOUT    = "fpout";
    
    public class FTypePrefixVariability {
        public enum VariabilityCausality_C {
            CI("ci"),
            CD("cd"),
            PI("pi"),
            PS("ps"),
            PF("pf"),
            PE("pe"),
            PD("pd");
            
            private String s;
            
            private VariabilityCausality_C(String s) {
                this.s = s;
            }
            
            public String toString() {
                return s;
            }
        }
    }
    
    syn FTypePrefixVariability.VariabilityCausality_C FVariable.variabilityCausality_C() = variability().variabilityCausality_C(this);
    
    syn VariabilityCausality_C FTypePrefixVariability.variabilityCausality_C(FVariable fv) {
        throw new UnsupportedOperationException();
    }
    eq FConstant.variabilityCausality_C(FVariable fv)        = fv.isIndependentConstant()  ? VariabilityCausality_C.CI : VariabilityCausality_C.CD;
    eq FParameter.variabilityCausality_C(FVariable fv)       = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PD;
    eq FStructParameter.variabilityCausality_C(FVariable fv) = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PS;
    eq FFinalParameter.variabilityCausality_C(FVariable fv)  = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PF;
    eq FEvalParameter.variabilityCausality_C(FVariable fv)   = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PE;
    
	syn String FAbstractVariable.funcArrayType(boolean assign) = 
		isRecord() ? C_ARRAY_RECORD : (assign ? C_ARRAY_REFERENCE : C_ARRAY_VALUE);
    
    syn String FType.arrayAccess(int nd, String name, String ind) {
        return String.format("jmi_array_%s_%d(%s, %s)", isRecord() ? C_ARRAY_RECORD : C_ARRAY_REFERENCE, 
                nd, name, ind);
    }

	syn lazy String FAbstractVariable.name_C() = null;
	eq FVariable.name_C()           = isForIndex() ? 
										name_C(null, variableIndex() + C_SUFFIX_INDEX) : 
										name_C(""); 
    eq FStringVariable.name_C()     = name_C("_s_" + variabilityCausality_C());
	eq FPreRealVariable.name_C()    = preName_C();
	eq FPreBooleanVariable.name_C() = preName_C();
	eq FPreIntegerVariable.name_C() = preName_C();
	eq FPreStringVariable.name_C()  = preName_C();
	eq FPreEnumVariable.name_C()    = preName_C();

	eq FFunctionVariable.name_C()   = name_C(null, C_SUFFIX_VARIABLE);
	eq FFunctionArray.name_C()      = name_C(null, C_SUFFIX_ARRAY);
	
	syn String FAbstractVariable.preName_C() = null; 
	eq FVariable.preName_C() = name_C("pre");
	
	protected String FVariable.name_C(String prefix) {
		return name_C(prefix, Integer.toString(variableIndex()));
	}
	
	protected String FAbstractVariable.name_C(String prefix, String suffix) {
		StringBuilder buf = new StringBuilder();
		if (prefix != null) {
			buf.append(prefix);
			buf.append('_');
		}
		buf.append(nameUnderscore());
		buf.append('_');
		buf.append(suffix);
		return buf.toString();
	}
	
	syn String FFunctionVariable.nameReturn_C() = 
		isRecord() ? name_C() : name_C(null, C_SUFFIX_RETURN);
    syn String FFunctionArray.nameReturn_C() =
        isString() ? name_C(null, C_SUFFIX_RETURN) : name_C();
	
	syn String FAbstractVariable.type_C() = type().type_C();
	syn String FFunctionCallLeft.type_C() = type().type_C();
	
	
    syn String FFunctionVariable.typeReturn_C() = isRecord() ? type_C() : (type_C() + "*");
    eq FFunctionArray.typeReturn_C()            = type_C();
    
    
    syn String FType.type_C() = isArray() ? arrayType_C() : scalarType_C();
    
    syn String FType.scalarType_C()         = nameScalar_C();
    eq FRecordType.scalarType_C()           = nameScalar_C() + "*";
    
    syn String FType.arrayType_C()          = nameArray_C() + "*";

    
    syn String FType.typeExternal_C() = isArray() ? arrayExternalType_C() : scalarExternalType_C();
    
    syn String FType.scalarExternalType_C() = nameScalarExt_C();
    eq FRecordType.scalarExternalType_C()   = nameScalarExt_C() + "*";
    
    syn String FType.arrayExternalType_C()  = nameArrayExt_C() + "*";
    
    syn String FType.nameScalar_C(boolean external) = external ? nameScalarExt_C() : nameScalar_C();
    syn String FType.nameArray_C(boolean external)  = external ? nameArrayExt_C() : nameArray_C();
    
    syn String FType.nameScalar_C()       = "jmi_real_t";
    eq FRecordType.nameScalar_C()         = (getFClass() != null ? myFRecordDecl().name_C() : 
        ASTNode.underScore(getName())) + "_" + C_SUFFIX_REC;
    eq FStringType.nameScalar_C()         = "jmi_string_t";
    eq FExternalObjectType.nameScalar_C() = "jmi_extobj_t";
    eq FFunctionType.nameScalar_C() = myFFunctionDecl().funcNameUnderscore(C_SUFFIX_FP) + "*";
    
    syn String FType.nameArray_C()        = "jmi_array_t";
    eq FRecordType.nameArray_C()          = nameScalar_C() + C_SUFFIX_ARRAY;
    eq FStringType.nameArray_C()          = "jmi_string_array_t";
    eq FExternalObjectType.nameArray_C()  = "jmi_extobj_array_t";
    
    syn String FType.nameScalarExt_C()    = nameScalar_C();
    eq FRecordType.nameScalarExt_C()      = nameScalar_C() +  C_SUFFIX_EXT;
    eq FIntegerType.nameScalarExt_C()     = "jmi_int_t";
    eq FBooleanType.nameScalarExt_C()     = "jmi_int_t";
    eq FEnumType.nameScalarExt_C()        = "jmi_int_t";
    
    syn String FType.nameArrayExt_C()     = nameArray_C();
    eq FIntegerType.nameArrayExt_C()      = "jmi_int_array_t";
    eq FBooleanType.nameArrayExt_C()      = "jmi_int_array_t";
    eq FEnumType.nameArrayExt_C()         = "jmi_int_array_t";
    
    
    /* Corresponding external c representation */
    syn String FExp.argType_C(boolean ref) = type().argType_C(ref);
    eq FSizeExp.argType_C(boolean ref)     = ref ? type().argType_C(ref) : "size_t";
    
    syn String FType.argType_C(boolean ref)        = argTypeBase_C() + (ref ? "*" : "");
    eq FStringType.argType_C(boolean ref)          = "const " + super.argType_C(isArray());
    
    syn String FType.argTypeBase_C()        = type_C();
    eq FPrimitiveType.argTypeBase_C()       = "double";
    eq FIntegerType.argTypeBase_C()         = "int";
    eq FBooleanType.argTypeBase_C()         = "int";
    eq FEnumType.argTypeBase_C()            = "int";
    eq FExternalObjectType.argTypeBase_C()  = "void*";
    eq FStringType.argTypeBase_C()          = "char*";
    
    /* Macro type tokens */
    syn String FType.macroType() = macroTypeScalar() + (isArray() ? "_ARR" : "");
    
    syn String FType.macroTypeScalar() = "GEN";
    eq FStringType.macroTypeScalar()   = "STR";
    
    syn String FType.macroTypeDecl(boolean external) = external ? macroTypeDeclScalar() + "_EXT" : macroTypeDeclScalar();
    
    syn String FType.macroTypeDeclScalar()       = "GEN";
    eq FRealType.macroTypeDeclScalar()           = "REA";
    eq FIntegerType.macroTypeDeclScalar()        = "INT";
    eq FBooleanType.macroTypeDeclScalar()        = "BOO";
    eq FEnumType.macroTypeDeclScalar()           = "ENU";
    eq FStringType.macroTypeDeclScalar()         = "STR";
    eq FExternalObjectType.macroTypeDeclScalar() = "EXO";
    
    public static void ASTNode.genFunctionStart(CodeStream str, String indent) {
        str.print(indent);
        str.print("int ef = 0;\n");
        ASTNode.genDynMemInit(str, indent);
    }
    
    public static void ASTNode.genFunctionEnd(CodeStream str, String indent) {
        ASTNode.genDynMemFree(str, indent);
        str.print(indent);
        str.print("return ef;\n");
    }
    
    public static void ASTNode.genDynMemInit(CodeStream str, String indent) {
        str.print(indent);
        str.print("JMI_DYNAMIC_INIT()\n");
    }
    
    public static void ASTNode.genDynMemFree(CodeStream str, String indent) {
        str.print(indent);
        str.print("JMI_DYNAMIC_FREE()\n");
    }
    
    
	public void FFunctionVariable.printReturnArgument_C(CodeStream str) {
		str.print(typeReturn_C());
		str.print(" ");
		str.print(nameReturn_C());
	}
	
	public void FFunctionVariable.printReturnWrite_C(CodeStream str, String indent) {
		if (!isRecord()) {
			getType().printReturn_C(str, indent, nameReturn_C(), name_C());
		}
	}
    
    @Override
    public void FFunctionArray.printReturnWrite_C(CodeStream str, String indent) {
        if (isString()) {
            getType().printReturn_C(str, indent, nameReturn_C(), name_C());
        }
    }
    
	public void FFunctionVariable.printArgument_C(CodeStream str) {
		str.print(type_C());
		str.print(" ");
		str.print(name_C());
	}
	
	private FExp FFunctionVariable.dummyFExp = null;
	
	public void FFunctionVariable.setDummyExp() {
		if (dummyFExp == null) 
			dummyFExp = new FNoExp();
		setBindingExp(dummyFExp);
	}
	
	public void FFunctionVariable.resetDummyExp() {
		if (dummyFExp != null)
			setBindingExpOpt(new Opt());
	}

    public void FFunctionVariable.print(TypePrinter_C tp, String name, String indent) {
        setDummyExp();
        tp.reset(name, getBindingExp(), size(), false, indent);
        type().print(tp);
        resetDummyExp();
    }

    @Override
    public void FFunctionVariable.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        FInitArrayStmt.genInit_C(p, str, indent, name_C(), this, type());
    }

    public void FType.printDecl_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        printDecl_C(p, str, indent, name, src, false);
    }

    public void FType.printDecl_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, boolean external) {
        print(p.createDeclPrinter(str), indent, name, src, external);
    }

    public void FType.printInit_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        printInit_C(p, str, indent, name, src, false);
    }

    public void FType.printInit_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, boolean external) {
        print(p.createInitSetPrinter(str), indent, name, src, external);
    }

    public void FType.print(TypePrinter_C tp, String indent, String name, FExp src, boolean external) {
        tp.reset(name, src, size(), external, indent);
        print(tp);
    }

    public void FType.print(TypePrinter_C p)               { p.print(this); }
    public void FRecordType.print(TypePrinter_C p)         { p.print(this); }
    public void FExternalObjectType.print(TypePrinter_C p) { p.print(this); }
    
    public abstract class TypePrinter_C {
        protected CodePrinter p;
        protected CodeStream str;
        protected FExp src;
        protected boolean external = false;
        protected boolean subDecls = false; // Used in CAD
        
        private Stack<Level> levels   = new Stack<Level>();
        
        public TypePrinter_C(CodePrinter p, CodeStream str) {
            this.p = p;
            this.str = str;
        }
        
        public TypePrinter_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, Size s, boolean external) {
            this(p, str);
            reset(name, src, s, external, indent);
        }
        
        public void reset(String name, FExp src, Size s, boolean external, String indent) {
            this.src = src;
            levels = new Stack<Level>();
            levels.push(new Level(name, indent, !s.variability().knownParameterOrLess() || external));
            this.external = external;
        }
        
        public void resetUnknown(String name, FType type, String indent) {
            this.src = null;
            levels = new Stack<Level>();
            levels.push(new Level(name, indent, type.isArray() || type.isExternalObject()));
            this.external = false;
        }
        
        public void setSubDecls(boolean subDecls) { this.subDecls = subDecls; }
        
        protected String name()     { return levels.peek().name; }
        protected String indent()   { return levels.peek().indent; }
        protected boolean dynamic() { return levels.peek().dynamic; }
        
        protected class Level {
            String name;
            String indent;
            boolean dynamic;
            public Level(String name, String indent, boolean dynamic) {
                this.name    = name;
                this.indent  = indent;
                this.dynamic = dynamic;
            }
        }
        
        protected void pushLevel(String name, boolean indent, Size s) {
            levels.push(new Level(name, indent ? p.indent(indent()) : indent(), !s.variability().knownParameterOrLess() || dynamic()));
        }
        
        protected void pushLevelExt(String name, boolean indent, Size s) {
            levels.push(new Level(name, indent ? p.indent(indent()) : indent(), s.ndims() > 0));
        }
        
        protected void popLevel() {
            levels.pop();
        }
        
        
        protected String dynStr(FType type) {
            return (dynamic() ? "DYNA" : "STAT");
        }
        
        public void print(FType type) {
            if (type.isArray()) {
                printArray(type);
            } else {
                printScalar(type);
            }
        }
        
        public void print(FRecordType type) {
            printComposite(type);
        }
        
        public void print(FExternalObjectType type) {
            printComposite(type);
        }
        
        public void printComposite(FType type) {
            print(type);
            if (type.isArray()) {
                if (dynamic()) {
                    printDynArray(type);
                } else {
                    for (Index i : type.indices()) {
                        pushLevel(type.arrayAccess(type.ndims(), name(), i.toUnclosedString()), false, Size.SCALAR);
                        printComps(type);
                        popLevel();
                    }
                }
            } else {
                printComps(type);
            }
        }
        
        protected void printComps(FType type) {
            if (type.isRecord()) {
                printComps((FRecordType) type);
            }
        }
        
        protected void printComps(FRecordType type) {
            for (FRecordComponentType comp : type.getComponents()) {
                if (shouldPrintComp(comp)) {
                    String compName = name() + "->" + comp.getName();
                    boolean useTempName = !dynamic() && comp.getFType().isComposite();
                    String tempName = useTempName ? acquireTemp(compName) : compName;
                    pushLevel(tempName, false, comp.getFType().size());
                    comp.getFType().print(this);
                    popLevel();
                    if (useTempName)
                        tempWriteBack(compName, tempName);
                }
            }
        }
        
        protected boolean shouldPrintComp(FRecordComponentType comp) {
            return comp.getFType().isComposite();
        }
        
        protected void printExt(FExternalObjectType type) {
            
        }
        
        protected void printComps(FExternalObjectType type) {
            int i = 0;
            String name = acquireTemp(name());
            for (FExp arg : type.myConstructorStmt().myConstructorArgs()) {
                pushLevelExt(name + "_arg" + i, false, arg.size());
                FType t = arg.type();
                boolean b = t.parent == null;
                if (b) {
                    // This needs to be done since some exps does
                    // not parent their calculated type
                    t.setParent(type);
                }
                t.print(this);
                if (b) {
                    t.setParent(null);
                }
                popLevel();
                i++;
            }
        }
        
        protected void printScalar(FType type) {}
        abstract protected void printArray(FType type);
        abstract protected void printDynArray(FType type);
        abstract protected String acquireTemp(String name);
        protected void tempWriteBack(String compName, String tempName) {}
        
        protected void printSizesAsArgs(FType type) {
            printNumElements(type);
            str.print(", ");
            str.print(type.ndims());
            printDimensions(type);
        }
        protected void printNumElements(FType type) {
            if (external && dynamic()) {
                type.size().printNumElements_C(p, str, indent(), src.myCodeGenContext().alias(src.prettyPrint_C("")));
            } else {
                type.size().printNumElements_C(p, str, indent(), src);
            }
        }
        protected void printDimensions(FType type) {
            str.print(", ");
            if (external && dynamic())
                type.size().printDimensions_C(p, str, indent(), src.myCodeGenContext().alias(src.prettyPrint_C("")));
            else
                type.size().printDimensions_C(p, str, indent(), src);
        }
    }
    
    public class DeclPrinter_C extends TypePrinter_C {
        protected boolean print = true;
        public DeclPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }

        @Override
        protected String acquireTemp(String key) {
            String tmp = src.nextTempName_C();
            src.recordChildTempNames().put(key, tmp);
            return tmp;
        }

        @Override
        protected void printScalar(FType type) {
            if (print) {
                type.printScalarDecl_C(str, indent(), external, name());
            }
        }

        @Override
        protected void printArray(FType type) {
            if (print) {
                str.format("%sJMI_ARR(%s, %s, %s, %s, ", indent(), dynStr(type),
                        type.nameScalar_C(external), type.nameArray_C(external), name());
                printSizesAsArgs(type);
                str.println(")");
            }
        }

        @Override
        protected void printNumElements(FType type) {
            if (dynamic())
                str.print("-1");
            else
                super.printNumElements(type);
        }

        @Override
        protected void printDimensions(FType type) {
            
        }

        @Override
        protected void printDynArray(FType type) {
            String ind    = acquireTemp(name());
            String maxind = ind + "_max";
            print = true;
            pushLevel(ind, false, Size.SCALAR);
            type.fRealScalarType().print(this);
            popLevel();
            pushLevel(maxind, false, Size.SCALAR);
            type.fRealScalarType().print(this);
            popLevel();
            print = type.isExternalObject();
            pushLevel(type.arrayAccess(1, name(), ind), false, new MutableSize(1));
            printComps(type);
            popLevel();
            print = true;
        }
    }
    
    public class InitPrinter_C extends TypePrinter_C {
        public InitPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }

        @Override
        protected String acquireTemp(String key) {
            return src.recordChildTempNames().get(key);
        }

        @Override
        protected void printArray(FType type) {
            str.format("%sJMI_ARRAY_INIT_%d(%s, %s, %s, %s, ", indent(), type.ndims(), dynStr(type),
                    type.nameScalar_C(external), type.nameArray_C(external), name());
            printSizesAsArgs(type);
            str.println(")");
        }

        @Override
        protected void printDynArray(FType type) {
            String ind    = acquireTemp(name());
            String maxind = ind + "_max";
            if (initMaxInd()) {
                str.print(indent() + maxind + " = ");
                printNumElements(type);
                str.println(" + 1;");
            }
            str.formatln("%sfor (%s = 1; %s < %s; %s++) {", indent(), ind, ind, maxind, ind);
            pushLevel(type.arrayAccess(1, name(), ind), true, new MutableSize(1));
            printComps(type);
            popLevel();
            str.println(indent() + "}");
        }

        protected boolean initMaxInd() { return true; }

        @Override
        protected void tempWriteBack(String compName, String tempName) {
            str.formatln("%s%s = %s;", indent(), compName, tempName);
        }
    }
    
    public class InitSetPrinter_C extends InitPrinter_C {
        public InitSetPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }

        @Override
        protected void printScalar(FType type) {
            type.printInitStartValue_C(p, str, indent(), name());
        }

        @Override
        protected boolean shouldPrintComp(FRecordComponentType comp) {
            return super.shouldPrintComp(comp) || comp.getFType().isString();
        }
    }

    public void FType.printInitStartValue_C(CodePrinter p, CodeStream str, String indent, String name) {}

    @Override
    public void FStringType.printInitStartValue_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.print(indent);
        str.print("JMI_INI(");
        str.print(macroTypeScalar());
        str.print(", ");
        str.print(name);
        str.print(")\n");
    }
	
	private Map<String,String> FExp.recordChildTempNameMap = null;
	
	public Map<String,String> FExp.recordChildTempNames() {
		if (recordChildTempNameMap == null)
			recordChildTempNameMap = new HashMap<String,String>();
		return recordChildTempNameMap;
	}

    public void Size.printNumElements_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        str.print(numElements());
    }

    @Override
    public void MutableSize.printNumElements_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        if (!variability().knownParameterOrLess()) {
            for (int i = 0; i < size.length; i++) {
                FExp exp = exps[i];
                if (i > 0) {
                    str.print(" * ");
                }
                if (exp == null) {
                    str.print(size[i]);
                } else {
                    boolean addParenthesis = exp.addParenthesis(FExp.PRECEDENCE_MULTIPLICATIVE);
                    if (addParenthesis) {
                        str.print("(");
                    }
                    p.print(exp, str, indent);
                    if (addParenthesis) {
                        str.print(")");
                    }
                }
            }
        } else {
            super.printNumElements_C(p, str, indent, src);
        }
    }

    public void Size.printDimensions_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        str.print(toUnclosedString());
    }

	@Override
	public void MutableSize.printDimensions_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        if (!variability().knownParameterOrLess()) {
			for (int i = 0; i < size.length; i++) {
				if (i > 0)
					str.print(", ");
                if (exps[i] == null) {
					str.print(size[i]);
				} else {
                    FExp exp = exps[i];
					exp.prettyPrint_C(p, str, indent); // TODO: This is a hack to get CAD gen to work!
				}
			}
		} else {
			super.printDimensions_C(p, str, indent, src);
		}
	}
	
    public void Size.printNumElements_C(CodePrinter p, CodeStream str, String indent, String name) {
        printDimsWithSep_C(p, str, indent, name, " * ");
    }
    public void Size.printDimensions_C(CodePrinter p, CodeStream str, String indent, String name) {
        printDimsWithSep_C(p, str, indent, name, ", ");
    }
    private void Size.printDimsWithSep_C(CodePrinter p, CodeStream str, String indent, String name, String sep) {
        printSize_C(p, str, indent, name, 0);
        for (int i = 1; i < ndims(); i++) {
            str.print(sep);
            printSize_C(p, str, indent, name, i);
        }
    }
    public void Size.printSize_C(CodePrinter p, CodeStream str, String indent, String name, int dim) {
        str.print("jmi_array_size(");
        str.print(name);
        str.print(", ");
        str.print(dim);
        str.print(")");
    }
    public void Size.printSize_C(CodePrinter p, CodeStream str, String indent, FExp e, int dim) {
        str.print("jmi_array_size(");
        p.print(e, str, indent);
        str.print(", ");
        str.print(dim);
        str.print(")");
    }
    
    public void Size.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (size[i] == Size.UNKNOWN) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printVarDecls(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genVarDecls_C(p, str, indent, src);
        }
    }

	
    public void Size.genTempVars_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genTempVars_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (size[i] == Size.UNKNOWN) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printPreSteps(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genTempVars_C(p, str, indent, src);
        }
    }
    
    public void Size.genTempFree_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genTempFree_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (size[i] == Size.UNKNOWN) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printPostSteps(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genTempFree_C(p, str, indent, src);
        }
    }
	
    
    
    
    
    
    
    @Override
    public void FAbstractEquation.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                node.genVarDecls_C(p, str, indent);
    }
    
    public void ASTNode.printDecl_C(CodePrinter p, CodeStream str, String indent, Set<ASTNode> visited, Collection<FVariable> forVariables, boolean solved) {
        throw new UnsupportedOperationException("FAbstractEquation.printDecl_C(CodePrinter p, CodeStream str, String indent, Collection<FVariable> forVariables, boolean solved) not implemented for class '" + getClass().getSimpleName() +"'");
    }
    
    @Override
    public void FAlgorithm.printDecl_C(CodePrinter p, CodeStream str, String indent, Set<ASTNode> visited, Collection<FVariable> forVariables, boolean solved) {
        boolean first = visited == null || visited.add(this);
        if (first) {
            p.printVarDecls(this, str, indent);
            if (!solved || (forVariables != null && forVariables.size() != uniqueFIdUseExpsInLHS().size())) {
                fRealScalarType().printDecl_C(printer_C, str, indent, this.tempName_C(), null);
                for (FIdUseExp use : uniqueFIdUseExpsInLHS()) {
                    if (!solved || !forVariables.contains(use.myFV()) || !use.myFV().isReal()) {
                        if (!use.inFunctionCallLeftTop()) {
                            use.type().printDecl_C(printer_C, str, indent, use.tempName_C(), use);
                        }
                    }
                }
            }
        }
    }
	
    @Override
	public void FFunctionVariable.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		if (!isInput()) {
			String suffix = (isOutput() && isComposite() && !isString()) ? C_SUFFIX_NULL : "";
			print(p.createDeclPrinter(str), name_C() + suffix, indent);
		}
	}
    
    @Override
	public void FExternalStmt.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		FExternalLanguage lang = getFExternalLanguage();
		lang.genVarDecls_C(p, str, indent, this);
		lang.genFuncDecl(p, str, indent, this);
	}
    
    public void FType.printDeclBase_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, boolean external) {
        if (isArray()) {
            if (size().isUnknown() || external) {
                printDecl_C(p, str, indent, name, src, external);
            } else {
                str.format("%sJMI_ARR(STAT, %s, %s, %s, ", indent,
                        nameScalar_C(external), nameArray_C(external), name);
                size().printNumElements_C(p, str, indent, src);
                str.print(", ");
                str.print(ndims());
                str.println(")");
            }
        } else {
            printScalarDecl_C(str, indent, external, name);
        }
    }
    
    @Override
	public void FAlgorithm.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!inFunction()) {
			// Print initialization stmts for variables which might not be set before use
			Set<FVariable> defSet = defSet();
			for (FVariable fv : referencedFVariablesInLHS()) {
				if (!defSet.contains(fv)) {
					FStatement.printAssignStmt_C(str, indent, fv.name_C(), fv.algorithmInit_C());
				}
			}
		}
		// Print the algorithm
		p.print(getFStatements(), str, indent);
	}
	
	public String FVariable.algorithmInit_C() {
		if (isDiscrete()) {
			return myPreVariable().name_C();
		} else if (isParameter() && hasBindingExp()) {
			return getBindingExp().prettyPrint_C("");
		} else {
			FExp e = startAttributeExp();
			return (e == null) ? "0.0" : e.prettyPrint_C("");
		}
	}
    
    @Override
    public void FInitArrayStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        FFunctionVariable fv = getFIdUseExp().myFuncFV();
        FInitArrayStmt.genInit_C(p, str, indent, fv.name_C(), fv, type());
    }
    
    public static void FInitArrayStmt.genInit_C(CodePrinter p, CodeStream str, String indent, String name,
            FFunctionVariable fv, FType type) {
        fv.setDummyExp();
        TypePrinter_C tp = p.createInitSetPrinter(str);
        if (fv.isComposite() && fv.isOutput() && !fv.isString()) {
            String next = p.indent(indent);
            String iniName = name + C_SUFFIX_NULL;
            str.print(indent + "if (" + name + " == NULL) {\n");
            tp.reset(iniName, fv.getBindingExp(), type.size(), false, next);
            type.print(tp);
            str.print(next + name + " = " + iniName + ";\n");
            str.print(indent + "}\n");
        } else {
            tp.reset(name, fv.getBindingExp(), type.size(), false, indent);
            type.print(tp);
        }
        fv.resetDummyExp();
    }
    
    @Override
	public void FFunctionCallStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored()) {
			p.printPreSteps(this, str, indent);
			p.print(getCall(), str, indent);
			for (FFunctionCallLeft l : getLefts()) {
				l.genWriteBackAssignment_C(str, indent, null);
			}
            p.printPostSteps(this, str, indent);
		}
	}
	
    @Override
	public void FFunctionCallEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored()) {
			p.printPreSteps(this, str, indent);
			p.print(getCall(), str, indent);
            p.printPostSteps(this, str, indent);
		}
	}
	
	   
    @Override
    public void FIfEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        if (isWhen() && p.inInitialSystem() && !getTest().isInitialGuard()) {
            return;
        }
        genIfStart_C(p, str, indent);
        for (FAbstractEquation equation : getFAbstractEquations())
            p.print(equation, str, p.indent(indent));
        if (hasElse()) {
            p.print(getElse(), str,indent);
        }
        genIfEnd_C(p, str, indent);
    }
    
    @Override
    public void FElseEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        genIfStart_C(p, str, indent);
        for (FAbstractEquation equation : getFAbstractEquations())
            p.print(equation, str, p.indent(indent));
    }

    @Override
	public void FAssignStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(this, str, indent);
        getLeft().type().printAssign_C(p, str, indent, getLeft(), getRight());
        p.printPostSteps(this, str, indent);
	}
	
    @Override
	public void FReturnStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		returnDefinition().printReturnWrite_C(str, indent);
        ASTNode.genDynMemFree(str, indent);
		str.print(indent + "return;\n");
	}
	
    @Override
	public void FBreakStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print(indent + "break;\n");
	}
	
    @Override
	public void FIfWhenStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		for (FIfWhenClause clause : getFIfWhenClauses())
			p.printPreSteps(clause.getTest(), str, indent);
		str.print(indent);
		getFIfWhenClauses().prettyPrintWithSep(p, str, indent, indent + "} else ");
		prettyPrintElse_C(p, str, indent);
		str.print(indent);
		str.print("}\n");
        for (FIfWhenClause clause : getFIfWhenClauses())
            p.printPostSteps(clause.getTest(), str, indent);
	}
	
	protected void FIfWhenStmt.prettyPrintElse_C(CodePrinter p, CodeStream str, String indent) {}
	
	protected void FIfStmt.prettyPrintElse_C(CodePrinter p, CodeStream str, String indent) {
		if (getNumElseStmt() > 0) {
			str.print(indent);
			str.print("} else {\n");
			p.print(getElseStmts(), str, p.indent(indent));
		}
	}
	
    @Override
	public void FIfWhenClause.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.print("if (");
		p.print(getTest(), str, indent);
		str.print(") {\n");
		p.print(getFStatements(), str, p.indent(indent));
	}
	
    @Override
	public void FWhileStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		p.printPreSteps(getTest(), str, indent);
		str.print(indent);
		str.print("while (");
		p.print(getTest(), str, "");
		str.print(") {\n");
		p.print(getWhileStmts(), str, p.indent(indent));
		str.print(indent);
		str.print("}\n");
        p.printPostSteps(getTest(), str, indent);
	}


    @Override
    public void FForStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(getIndex(), str, indent);
        getIndex().printForIndexInit_C(p, str, indent);
        str.print(indent);
        str.print("for (");
        p.print(getIndex(), str, indent);
        str.print(") {\n");
        getIndex().printForIndexNext_C(p, str, p.indent(indent));
        p.print(getForStmts(), str, p.indent(indent));
        str.print(indent);
        str.print("}\n");
        p.printPostSteps(getIndex(), str, indent);
    }

    @Override
    public void FForIndex.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        super.genVarDecls_C(p, str, indent);
        String name = getFVariable().name_C();
        str.format("%sjmi_real_t %s;\n", indent, name);
        getFExp().genForIndexExtraVarDecls_C(p, str, indent, name);
    }

    public void FExp.genForIndexExtraVarDecls_C(CodePrinter p, CodeStream str, String indent, String name) {
    }

    @Override
    public void FRangeExp.genForIndexExtraVarDecls_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%sjmi_real_t %se;\n", indent, name);
    }

    @Override
    public void FIdUseExp.genForIndexExtraVarDecls_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%sint %si;\n", indent, name);
    }

    public void FForIndex.printForIndexInit_C(CodePrinter p, CodeStream str, String indent) {
        getFExp().printForIndexInit_C(p, str, indent, getFVariable().name_C());
    }

    public void FExp.printForIndexInit_C(CodePrinter p, CodeStream str, String indent, String name) {
    }

    @Override
    public void FRangeExp.printForIndexInit_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%s%se = ", indent, name);
        p.print(getFExp(hasStep() ? 2 : 1), str, indent);
        str.print(" + ");
        printForIndexStep_C(p, str, indent);
        str.print(" / 2.0;\n");
    }

    protected void FRangeExp.printForIndexStep_C(CodePrinter p, CodeStream str, String indent) {
        if (hasStep()) {
            getFExp(1).printStepValue_C(p, str, indent);
        } else {
            str.print("1");
        }
    }

    @Override
    public void FForIndex.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        getFExp().printForIndex_C(p, str, indent, getFVariable().name_C());
    }

    public void FExp.printForIndex_C(CodePrinter p, CodeStream str, String indent, String name) {
        throw new UnsupportedOperationException("C code generation for loop index not implemented for class " + 
                getClass().getSimpleName());
    }

    @Override
    public void FIdUseExp.printForIndex_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%1$si = 0; %1$si < jmi_array_size(%2$s, 0); %1$si++", 
                name, getFIdUse().toString_C(p));
    }

    @Override
    public void FRangeExp.printForIndex_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%s = ", name);
        getFExp(0).printInitialForIndexValue_C(p, str, indent);

        if (hasStep() && !getFExp(1).variability().knownParameterOrLess()) {
            str.format("; %s * ", name);
            p.print(getFExp(1), str, indent);
            str.format(" < %se * ", name);
            p.print(getFExp(1), str, indent);
            str.format("; %s += ", name);
        } else {
            String cmp = (hasStep() && getFExp(1).ceval().isNegative()) ? ">" : "<";
            str.format("; %s %s %se; %s += ", name, cmp, name, name);
        }
        printForIndexStep_C(p, str, indent);
    }

    public void FExp.printForIndexNext_C(CodePrinter p, CodeStream str, String indent, String name) {}

    public void FForIndex.printForIndexNext_C(CodePrinter p, CodeStream str, String indent) {
        getFExp().printForIndexNext_C(p, str, indent, getFVariable().name_C());
    }

    @Override
    public void FIdUseExp.printForIndexNext_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.format("%1$s%2$s = jmi_array_val_1(%3$s, %2$si);\n", 
                indent, name, getFIdUse().toString_C(p));
    }

    public void FExp.printInitialForIndexValue_C(CodePrinter p, CodeStream str, String indent) {
        p.print(this, str, indent);
    }

    @Override
    public void FIntegerLitExp.printInitialForIndexValue_C(CodePrinter p, CodeStream str, String indent) {
        str.print(getValue());
    }

    public void FExp.printStepValue_C(CodePrinter p, CodeStream str, String indent) {
        p.print(this, str, indent);
    }

    @Override
    public void FIntegerLitExp.printStepValue_C(CodePrinter p, CodeStream str, String indent) {
        prettyPrint_C(p, str, indent);
    }

    @Override
	public void FEnumDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		str.format("%sstatic char* %s[] = { \"\"", indent, name_C());
		for (FEnumLiteral el : ((FEnumLiteralList) getFEnumSpecification()).getFEnumLiterals())
			str.format(", \"%s\"", el.name());
		str.print(" };\n");
	}

	syn String FType.enumNames_C() = null;
	eq FEnumType.enumNames_C()     = myFEnumDecl().name_C();

	syn String FEnumDecl.name_C() = getName().getFQName().lastActualPartName() + "_" + enumIndex() + "_" + C_SUFFIX_ENUM;

	
	
	
	
	



    
    
    

    @Override
	public void FExternalStmt.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {		
		// Generate temp arrays for all array inputs and outputs
		// and transpose array for if array is input (Fortran 77 only)
		getFExternalLanguage().prepExternalArg(p, str, indent, this, false);
		
		str.print(indent);
		// return variable?
		if(hasReturnVar()) {
            String name = getReturnVar().type().isRecord() ?
                    "*"+getReturnVar().tempName_C() :
                    getReturnVar().getFIdUse().name_C();
            str.print(getCodeGenContext().alias(name));
            str.print(" = ");
		}
		
		// print function call
		getFExternalLanguage().genFuncCall(p, str, indent, this);
		
		// If there are any output arrays, transpose these before returning (Fortran 77 only)
		getFExternalLanguage().prepExternalArg(p, str, indent, this, true);
	}

	public class MatrixOp {
		
		private String function;
		
        public MatrixOp(FType type, FExternalLanguage lang, boolean writeback) {
            boolean isFortran = lang instanceof FFortran77ExternalLanguage;
            this.function = String.format("jmi_%smatrix_%s_%s%s", 
                    isFortran ? "" : "copy_",
                    writeback ? "from" : "to",
                    isFortran ? "fortran_" : "",
                    type.isReal() ? "real" : "int");
        }
		
		public void genMatrixOp(CodePrinter p, CodeStream str, String indent, String arr, String src, String dest) {
			str.print(indent + function + "(");
			str.print(arr + ", ");
			str.print(src + "->var");
			str.print(", " + dest + "->var");
			str.print(");\n");				
		}
	}

    public void FExternalLanguage.prepExternalArg(CodePrinter p, CodeStream str, String indent, FExternalStmt stmt, boolean writeback){
        for (FExp arg : stmt.getArgs()) {
            if (extShouldArgConvert(arg)) {
                arg.prepExternalArg(p, str, indent, this, writeback);
            }
        }
        if (writeback && stmt.hasReturnVar() && stmt.getReturnVar().type().isRecord()) {
            stmt.getReturnVar().prepExternalArg(p, str, indent, this, writeback);
        }
    }

    public void FExp.prepExternalArg(CodePrinter p, CodeStream str, String indent, FExternalLanguage lang, boolean writeback) {
        String tempName = tempName_C();
        String src = myCodeGenContext().alias(prettyPrint_C(indent));
        useTempVar = true;
        if (isArray()) {
            MatrixOp op = new MatrixOp(type(), lang, writeback);
            if (writeback)
                op.genMatrixOp(p, str, indent, src, tempName, src);
            else
                op.genMatrixOp(p, str, indent, src, src, tempName);
        } else {
            type().printAssignExt_C(p, str, indent, tempName, src, writeback, true);
        }
    }

    public void FType.printAssignExt_C(CodePrinter p, CodeStream str, String indent, String dst, String src, 
            boolean wb, boolean first) {
        if (wb) {
            str.formatln("%s%s = %s;", indent, src, dst);
        } else {
            str.formatln("%s%s = (%s) %s;", indent, dst, argType_C(false), src);
        }
    }

    @Override
    public void FStringType.printAssignExt_C(CodePrinter p, CodeStream str, String indent, String dst, String src, 
            boolean wb, boolean first) {
        str.formatln("%sJMI_ASG(%s, %s, %s)", indent, macroType(), dst, src);
    }

    @Override
    public void FRecordType.printAssignExt_C(CodePrinter p, CodeStream str, String indent, String dst, String src, 
            boolean wb, boolean first) {
        dst = dst + (first ? "->" : ".");
        src = src + "->";
        for (FRecordComponentType frct : getComponents()) {
            frct.getFType().printAssignExt_C(p, str, indent, dst + frct.getName(), src + frct.getName(), wb, false);
        }
    }
    
    @Override
    public void FAbstractEquation.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPreSteps(node, str, indent);
    }
    
    @Override
    public void FAbstractEquation.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPostSteps(node, str, indent);
    }

    @Override
    public void FIfEquation.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(getTest(), str, indent);
    }
    
    @Override
    public void FIfEquation.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        p.printPostSteps(getTest(), str, indent);
    }

    syn lazy String FExp.tempName_C()       = nextTempName_C();
    syn lazy String FAlgorithm.tempName_C() = nextTempName_C();
    
    syn String FExp.nextTempName_C()       = myCodeGenContext().nextTempName_C();
    syn String FAlgorithm.nextTempName_C() = myCodeGenContext().nextTempName_C();
    
    public class CodeGenContext {
        private int nextTempNbr_C = 1;
        
        public String nextTempName_C() {
            return "tmp_" + nextTempNbr_C++;
        }
        public void setAlias(String key, String val) {
            throw new UnsupportedOperationException();
        }
        public String alias(String key) {
            return key;
        }
        public CodeGenContext createProxy() {
            return new CodeGenContextProxy(this);
        }
        private class CodeGenContextProxy extends CodeGenContext {
            private CodeGenContext redirect;
            private Map<String,String> aliases = new HashMap<String,String>();
            public CodeGenContextProxy(CodeGenContext redirect) {
                this.redirect = redirect;
            }
            public String nextTempName_C() {
                return redirect.nextTempName_C();
            }
            public void setAlias(String key, String val) {
                aliases.put(key,val);
            }
            public String alias(String key) {
                return aliases.get(key);
            }
        }
    }
    private CodeGenContext FClass.codeGenContext = new CodeGenContext();
    private CodeGenContext FFunctionDecl.codeGenContext = new CodeGenContext();
    private CodeGenContext FExternalStmt.codeGenContext = null;
    public void FExternalStmt.setCodeGenContext(CodeGenContext cgc) { codeGenContext = cgc; }
    public CodeGenContext FExternalStmt.getCodeGenContext() { return codeGenContext == null ? myCodeGenContext() : codeGenContext; }
    
    inh CodeGenContext FExp.myCodeGenContext();
    inh CodeGenContext FAlgorithm.myCodeGenContext();
    inh CodeGenContext FExternalStmt.myCodeGenContext();
    eq Root.getChild().myCodeGenContext() = null;
    eq FClass.getChild().myCodeGenContext() = codeGenContext;
    eq FFunctionDecl.getChild().myCodeGenContext() = codeGenContext;
    eq FExternalStmt.getChild().myCodeGenContext() = getCodeGenContext();
    
    public void AbstractEquationBlock.genEvalModeValueReferences_C(CodePrinter p, CodeStream str, String indent, 
            String mode, Collection<FVariable> fvs) {
        if (fvs.size() > 0) {
            String nextIndent = p.indent(indent);
            int i = 0;
            genOpenEvalMode_C(str, indent, mode);
            for (FVariable fv : fvs) {
                if (!fv.isPreVariable()) {
                    str.format("%sx[%d] = %d;\n", nextIndent, i, fv.valueReference());
                }
                i++;
            }
            genCloseEvalMode_C(str, indent);
        }
    }
    
    public Map<FVariable,String> AbstractEquationBlock.createSolverArrayMap(Collection<FVariable> fvs) {
        Map<FVariable,String> solverArrayMap = new LinkedHashMap<FVariable,String>();
        int i = 0;
        for (FVariable fv : fvs) {
            solverArrayMap.put(fv, "x[" + (i++) + "]");
        }
        return solverArrayMap;
    }
    
    public void AbstractEquationBlock.genEvalModeAttribute_C(CodePrinter p, CodeStream str, String indent, 
            String mode, String attr, Map<FVariable,String> solverArrayMap) {
        genEvalModeAttribute_C(p, str, indent, mode, attr, solverArrayMap, false);
    }
    
    public void AbstractEquationBlock.genEvalModeAttribute_C(CodePrinter p, CodeStream str, String indent, 
            String mode, String attr, Map<FVariable,String> solverArrayMap, boolean set) {
        if (p.C_blockResidualAttributePrinter.attributeSet(attr, solverArrayMap)) {
            String nextIndent = p.indent(indent);
            genOpenEvalMode_C(str, indent, mode);
            p.C_blockResidualAttributePrinter.print(p, str, nextIndent, attr, solverArrayMap, set);
            genCloseEvalMode_C(str, indent);
        }
    }
    
    public void AbstractEquationBlock.genEvalModeSwitchIndex_C(CodePrinter p, CodeStream str, String indent, 
            String mode, Collection<FRelExp> ... relExpss) {
        boolean print = false;
        for (Collection<FRelExp> relExps : relExpss) {
            if (relExps.size() > 0) {
                print = true;
            }
        }
        if (print) {
            String nextIndent = p.indent(indent);
            genOpenEvalMode_C(str, indent, mode);
            Enumerator e = new Enumerator();
            for (Collection<FRelExp> relExps : relExpss) {
                for (FRelExp relExp : relExps) {
                    relExp.genBlockResidualFunction_printSwitchIndex_C(p, str, nextIndent, e);
                }
            }
            genCloseEvalMode_C(str, indent);
        }
    }
    
    public void AbstractEquationBlock.genOpenEvalMode_C(CodeStream str, String indent, String mode) {
        str.print("if (evaluation_mode == ");
        str.print(mode);
        str.print(") {\n");
    }
    
    public void AbstractEquationBlock.genCloseEvalMode_C(CodeStream str, String indent) {
        str.print(indent + "} else ");
    }

    public void AbstractEquationBlock.genBlockResidualFunction_C(CodePrinter p, CodeStream str, String outerIndent, int generateSparseThreshold) {

        if (!hasResidualFunction()) {
            return;
        }

        for (AbstractEquationBlock subBlock : genBlockResidualFunction_subBlocks_C()) {
            subBlock.genBlockResidualFunction_C(p, str, outerIndent, generateSparseThreshold);
        }

        Map<FVariable,String> solverArrayMap = createSolverArrayMap(localUnsolvedVariables());
        
        genBlockResidualSetUpFunctionDecl_C(p, str, outerIndent);
        
        String indent = p.indent(outerIndent);
        String nextIndent = p.indent(indent);
        str.format("%sstatic int %s(jmi_t* jmi, jmi_real_t* x, jmi_real_t* residual, int evaluation_mode) {\n", 
                outerIndent, genBlockResidualFunctionName_C(p));
        String label = getLabel();
        if (label == null) {
            label = getClass().getSimpleName();
        }
        str.format("%s/***** %s: %s *****/\n", indent, p.inInitialSystem() ? "Init block" : "Block", label);
        str.print(indent + "jmi_real_t** res = &residual;\n");
        ASTNode.genFunctionStart(str, indent);
        genVarDecls(p, str, indent, null);
        
        str.print(indent);

        genEvalModeAttribute_C(p, str, indent, "JMI_BLOCK_NOMINAL",   FAttribute.NOMINAL, solverArrayMap); 
        genEvalModeAttribute_C(p, str, indent, "JMI_BLOCK_START",     FAttribute.START,   solverArrayMap);
        genEvalModeAttribute_C(p, str, indent, "JMI_BLOCK_START_SET", FAttribute.START,   solverArrayMap, true);
        genEvalModeAttribute_C(p, str, indent, "JMI_BLOCK_MIN",       FAttribute.MIN,     solverArrayMap);
        genEvalModeAttribute_C(p, str, indent, "JMI_BLOCK_MAX",       FAttribute.MAX,     solverArrayMap);

        genEvalModeValueReferences_C(p, str, indent, "JMI_BLOCK_VALUE_REFERENCE",
                localUnsolvedVariables());
        genEvalModeValueReferences_C(p, str, indent, "JMI_BLOCK_SOLVED_REAL_VALUE_REFERENCE",
                localSolvedRealVariables());
        genEvalModeValueReferences_C(p, str, indent, "JMI_BLOCK_DISCRETE_REAL_VALUE_REFERENCE",
                discreteRealVariables_C());
        genEvalModeAttribute_C(p, str, indent,       "JMI_BLOCK_DISCRETE_REAL_NOMINAL", 
                FAttribute.NOMINAL, createSolverArrayMap(discreteRealVariables_C()));
        genEvalModeValueReferences_C(p, str, indent, "JMI_BLOCK_SOLVED_NON_REAL_VALUE_REFERENCE", 
                nonRealVariables_C());
        genEvalModeValueReferences_C(p, str, indent, "JMI_BLOCK_DIRECTLY_IMPACTING_NON_REAL_VALUE_REFERENCE", 
                directlyImpactingNonReals_C());
        genEvalModeValueReferences_C(p, str, indent, "JMI_BLOCK_NON_REAL_TEMP_VALUE_REFERENCE", 
                nonRealTempVariables_C());

        genEvalModeSwitchIndex_C(p, str, indent, "JMI_BLOCK_ACTIVE_SWITCH_INDEX",
                activeSwitches_C(), activeInitialSwitches_C());
        genEvalModeSwitchIndex_C(p, str, indent, "JMI_BLOCK_DIRECTLY_ACTIVE_SWITCH_INDEX",
                directlyActiveSwitches_C);

        // Equation nominal values
        if (hasEquationNominal_C(false)) {
            genOpenEvalMode_C(str, indent, "JMI_BLOCK_EQUATION_NOMINAL");
            Map<FAbstractEquation,FExp> nominalMap = new HashMap<FAbstractEquation,FExp>();
            genEquationNominalVarDecl_C(p, str, p.indent(indent), false, nominalMap);
            genEquationNominal_C(p, str, p.indent(indent), false, nominalMap);
            genCloseEvalMode_C(str, indent);
        }

        if (hasEquationNominal_C(true)) {
            genOpenEvalMode_C(str, indent, "JMI_BLOCK_EQUATION_NOMINAL_AUTO");
            Map<FAbstractEquation,FExp> nominalMap = new HashMap<FAbstractEquation,FExp>();
            genEquationNominalVarDecl_C(p, str, p.indent(indent), true, nominalMap);
            genEquationNominal_C(p, str, p.indent(indent), true, nominalMap);
            genCloseEvalMode_C(str, indent);
        }

        // Loop over all active variables and write their value to x
        if (localUnsolvedVariables().size() > 0) {
            genOpenEvalMode_C(str, indent, "JMI_BLOCK_INITIALIZE");
            for (FVariable fv : localUnsolvedVariables()) 
                fv.genBlockResidualInit_C(p, str, nextIndent, solverArrayMap);
            genCloseEvalMode_C(str, indent);
        }

        // Generate code for Jacobian
        if (isLinear() && generateSparseThreshold >= localSolvedRealVariables().size()) {
            genOpenEvalMode_C(str, indent, "JMI_BLOCK_EVALUATE_JACOBIAN");
            // TODO: Merge the two functions?
            genBlockResidualFunction_jacobianDecls_C(p, str, p.indent(indent));
            genBlockResidualFunction_jacobian_C(p, str, p.indent(indent));
            genCloseEvalMode_C(str, indent);
        } else if (isLinear()) {
        	genOpenEvalMode_C(str, indent, "JMI_BLOCK_EVALUATE_JACOBIAN");
        	str.print(nextIndent + "ef = -1;\n");
        	genCloseEvalMode_C(str, indent);
        }
        
        p = p.evalPrinter();
        
        str.print("if (evaluation_mode & JMI_BLOCK_EVALUATE || evaluation_mode & JMI_BLOCK_WRITE_BACK) {\n");
        // Loop over all active variables and write the values in x to the z vector
        str.print(nextIndent + "if ((evaluation_mode & JMI_BLOCK_EVALUATE_NON_REALS) == 0) {\n"); // TODO: remove guard when correct x is given to JMI_BLOCK_EVALUATE_NON_REALS
        for (FVariable fv : localUnsolvedVariables()) 
            fv.genBlockResidualEvalInit_C(p, str, p.indent(nextIndent), solverArrayMap);
        str.print(nextIndent + "}\n");
        Set<FAbstractEquation> visitedList = new HashSet<FAbstractEquation>();
        genSolvedPart(p, str, nextIndent, visitedList);
        str.print(nextIndent + "if (evaluation_mode & JMI_BLOCK_EVALUATE) {\n");
        // Write the residual expressions
        genResidualPart(p, str, p.indent(nextIndent), new Enumerator(), visitedList);
        str.print(nextIndent + "}\n");
        str.print(indent + "}\n");
        ASTNode.genFunctionEnd(str, indent);
        str.print(outerIndent + "}\n\n");
    }

    @Override
    public void AbstractSubBLTBlock.genBlockResidualFunction_C(CodePrinter p, CodeStream str, String outerIndent, int generateSparseThreshold) {

        for (T blt : subBLTs) {
            for (AbstractEquationBlock block : blt) {
                block.genBlockResidualFunction_C(p, str, outerIndent, generateSparseThreshold);
            }
        }
    }

    @Override
    public void HomotopyBlock.genBlockResidualFunction_C(CodePrinter p, CodeStream str,
            String outerIndent, int generateSparseThreshold) {

        homotopySubBlock.genBlockResidualFunction_C(p, str, outerIndent, generateSparseThreshold);
        CodePrinter simplifiedPrinter = p.homotopySimplifiedPrinter();

        for (AbstractEquationBlock block : subBLTs()[SIMPLIFIED_BLT_POS]) {
            block.genBlockResidualFunction_C(simplifiedPrinter, str, outerIndent, generateSparseThreshold);
        }
    }
    /*
     * Various dispatch methods used in genBlockResidualFunction_C():
     */

    /**
     * Only needed for numerically solved equation blocks. Ensures that the
     * residual function is generated for such blocks.
     */
    protected Collection<AbstractEquationBlock> AbstractEquationBlock.genBlockResidualFunction_subBlocks_C() {
        return Collections.emptyList();
    }

    @Override
    protected Collection<AbstractEquationBlock> EquationBlock.genBlockResidualFunction_subBlocks_C() {
        return solvedBlocks();
    }
    
    /**
     * Prints the position for the switch in the z-vector
     */
    public void FRelExp.genBlockResidualFunction_printSwitchIndex_C(CodePrinter p, CodeStream str, String nextIndent, Enumerator enumerator) {
        if (originalFExp().generatesEventInDAE()) {
            str.format("%sx[%d] = jmi->offs_sw + %d;\n", nextIndent, enumerator.next(), mySwitchIndex());
        } else {
            str.format("%sx[%d] = jmi->offs_sw_init + %d;\n", nextIndent, enumerator.next(), relExpInInitialEquationsIndex());
        }
    }

    public C_blockResidualAttributePrinter CodePrinter.C_blockResidualAttributePrinter = new C_blockResidualAttributePrinter();
    
    public abstract class CodePrinter {
        public static class C_blockResidualAttributePrinter {
            public void print(CodePrinter p, CodeStream str, String indent, String attr, 
                    Map<FVariable, String> iterVarMap, boolean set) {
                if (!set) {
                    for (Map.Entry<FVariable, String> iterEntry : iterVarMap.entrySet()) {
                        FExp exp = attributeExp(iterEntry.getKey(), attr);
                        if (exp != null) {
                            p.printVarDecls(exp, str, indent);
                        }
                    }
                }
                for (Map.Entry<FVariable, String> iterEntry : iterVarMap.entrySet()) {
                    FVariable iv = iterEntry.getKey();
                    if (attributeSet(iv, attr)) {
                        if (set) {
                            str.format("%s%s = 1;\n", indent, iterEntry.getValue());
                        } else {
                            FExp exp = attributeExp(iv, attr);
                            if (exp != null) {
                                p.printPreSteps(exp, str, indent);
                                str.print(indent);
                                str.print(iterEntry.getValue());
                                str.print(" = ");
                                p.print(exp, str, indent);
                                str.print(";\n");
                                p.printPostSteps(exp, str, indent);
                            }
                        }
                    }
                }
            }
            
            private Collection<String> attributes = Arrays.asList(FAttribute.START, FAttribute.MIN, FAttribute.MAX, FAttribute.NOMINAL);

            public void printVariability(CodePrinter p, CodeStream str, String indent, Collection<FVariable> iterVars) {
                FTypePrefixVariability variability = ASTNode.fConstant();
                for (FVariable var : iterVars) {
                    for (String attr : attributes) {
                        FExp exp = attributeExp(var, attr);
                        if (exp != null) {
                            variability = variability.combine(exp.variability());
                        }
                    }
                    
                }
                str.print(variability.genJMIVariabilityConstant_C() + ", ");
            }
            
            public boolean attributeSet(String attr, Map<FVariable, String> iterVarMap) {
                for (FVariable fv : iterVarMap.keySet()) {
                    if (attributeSet(fv, attr)) {
                        return true;
                    }
                }
                return false;
            }
            
            public boolean attributeSet(FVariable var, String attr) {
                return var.attributeSet(attr);
            }
            
            public FExp attributeExp(FVariable var, String attr) {
                return var.attributeExp(attr);
            }

        }
    }
    
    public abstract boolean AbstractEquationBlock.hasEquationNominal_C(boolean auto);

    @Override
    public boolean EquationBlock.hasEquationNominal_C(boolean auto) {
        for (SimpleEquationBlock block : unsolvedBlocks()) {
            if (block.hasEquationNominal_C(auto)) {
                return true;
            }
        }
        return false;
    }

    @Override
    public boolean SimpleEquationBlock.hasEquationNominal_C(boolean auto) { 
        return realVariables().size() > 0 && equation().equationNominal_C(auto) != null;
    }

    @Override
    public boolean AbstractSubBLTBlock.hasEquationNominal_C(boolean auto) { return true; } // To trigger error message

    public abstract void AbstractEquationBlock.genEquationNominalVarDecl_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap);

    @Override
    public void EquationBlock.genEquationNominalVarDecl_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap) {
        for (SimpleEquationBlock block : unsolvedBlocks())
            block.genEquationNominalVarDecl_C(p, str, indent, auto, nominalMap);
    }

    @Override
    public void AbstractSubBLTBlock.genEquationNominalVarDecl_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap) {
        throw new UnsupportedOperationException("AbstractSubBLTBlock.genEquationNominalVarDecl_C() is not implemented!");
    }

    @Override
    public void SimpleEquationBlock.genEquationNominalVarDecl_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap) {
        FExp nom = equation().equationNominal_C(auto);
        nominalMap.put(equation(), nom);
        if (nom == null) {
            return;
        }
        p.printVarDecls(nom, str, indent);
    }

    public abstract void AbstractEquationBlock.genEquationNominal_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap);

    @Override
    public void EquationBlock.genEquationNominal_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap) {
        Enumerator e = new Enumerator();
        for (SimpleEquationBlock block : unsolvedBlocks()) {
            block.genEquationNominal_C(p, str, indent, auto, nominalMap, e);
        }
    }

    @Override
    public void AbstractSubBLTBlock.genEquationNominal_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap) {
        throw new UnsupportedOperationException("AbstractSubBLTBlock.genEquationNominal_C() is not implemented!");
    }

    @Override
    public void SimpleEquationBlock.genEquationNominal_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap) {
        genEquationNominal_C(p, str, indent, auto, nominalMap, new Enumerator());
    }

    public void SimpleEquationBlock.genEquationNominal_C(CodePrinter p, CodeStream str, String indent,
            boolean auto, Map<FAbstractEquation,FExp> nominalMap, Enumerator e) {
        FExp nom = nominalMap.get(equation());
        if (nom == null) {
            return;
        }
        for (int i = 0; i < realVariables().size(); i++) {
            int num = e.next();
            if (i == 0) {
                p.printPreSteps(nom, str, indent);
                str.format("%s(*res)[%d] = ", indent, num);
                p.print(nom, str, indent);
                p.printPostSteps(nom, str, indent);
                str.print(";\n");
            } else {
                str.format("%s(*res)[%d] = (*res)[%d];\n", indent, num, num - 1);
            }
        }
    }

    public FExp FAbstractEquation.equationNominal_C(boolean auto) {
        return auto ? nominal() : null;
    }

	public void FVariable.genBlockResidualValuref_C(CodePrinter p, CodeStream str, String indent, 
	        Map<FVariable,String> solverArrayMap) {
		if (valueReference() != -1) 
			str.format("%s%s = %d;\n", indent, solverArrayMap.get(this), valueReference());
	}
	
	public void FVariable.genBlockResidualBoundsCall_C(CodePrinter p, CodeStream str, String indent,
	        String func, String msg, Map<FVariable,String> solverArrayMap) {
		boolean min = minAttributeSet();
		boolean max = maxAttributeSet();
		if (min || max) {
			String type = (min && max) ? "bounds" : (max ? "ubound" : "lbound");
			str.format("%s%s_%s(%s, ", indent, func, type, solverArrayMap.get(this));
			if (min)
				str.format("%s, ", attributeExp(FAttribute.MIN).ceval());
			if (max)
				str.format("%s, ", attributeExp(FAttribute.MAX).ceval());
			str.format("\"%s for variable %s\");\n", msg, name());
		}
	}
	
	public void FVariable.genBlockResidualInit_C(CodePrinter p, CodeStream str, String indent,
	        Map<FVariable,String> solverArrayMap) {
		str.format("%s%s = %s;\n", indent, solverArrayMap.get(this), name_C());
		genBlockResidualBoundsCall_C(p, str, indent, "init_with", "Resetting initial value", solverArrayMap);
	}
	
	public void FVariable.genBlockResidualEvalInit_C(CodePrinter p, CodeStream str, String indent,
	        Map<FVariable,String> solverArrayMap) {
		genBlockResidualBoundsCall_C(p, str, indent, "check", "Out of bounds", solverArrayMap);
		genBlockResidualWriteback_C(p, str, indent, solverArrayMap);
	}
	
	public void FVariable.genBlockResidualWriteback_C(CodePrinter p, CodeStream str, String indent,
	        Map<FVariable,String> solverArrayMap) {
		str.format("%s%s = %s;\n", indent, name_C(), solverArrayMap.get(this));
	}
	
	
    public void AbstractEquationBlock.genBlockResidualFunction_jacobianDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (jacobian != null)
            for (FExp[] col : jacobian)
                for (FExp exp : col)
                    if (exp != null)
                        exp.genVarDecls_C(ASTNode.printer_C, str, indent);
    }

    public void AbstractEquationBlock.genBlockResidualFunction_jacobian_C(CodePrinter p, CodeStream str, String indent) {
        if (jacobian == null)
            return;
        FExp[][] jacobian = jacobian();
        int rows = jacobian.length;
        int cols = jacobian.length;
        str.format("%smemset(residual, 0, %d * sizeof(jmi_real_t));\n", indent, rows * cols);
        // Output Jacobian
        for (int col = 0; col < cols; col++) {
            for (int row = 0; row < rows; row++) {
                if (jacobian[row][col] != null) {
                    p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sresidual[%d] = ", indent, rows * col + row);
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
    }

    @Override
    public void TornEquationBlock.genBlockResidualFunction_jacobian_C(CodePrinter p, CodeStream str, String indent) {
        if (!isLinear())
            return;
        int n1 = localSolvedRealVariables().size();
        int n2 = unsolvedVariables().size();
        if (n1 == 0) {
            /* This block should not be a torn block. #4691. */
            super.genBlockResidualFunction_jacobian_C(p, str, indent);
            return;
        }
        indent = p.indent(indent);
        String innerIndent = p.indent(indent);
        FExp[][] jacobian = jacobian();
        str.format("%sjmi_real_t* Q1 = calloc(%d, sizeof(jmi_real_t));\n", indent, n1 * n2);
        str.format("%sjmi_real_t* Q2 = calloc(%d, sizeof(jmi_real_t));\n", indent, n2 * n1);
        str.format("%sjmi_real_t* Q3 = residual;\n", indent);
        str.format("%sint i;\n", indent);
        str.format("%schar trans = 'N';\n", indent);
        str.format("%sdouble alpha = -1;\n", indent);
        str.format("%sdouble beta = 1;\n", indent);
        str.format("%sint n1 = %d;\n", indent, n1);
        str.format("%sint n2 = %d;\n", indent, n2);
        
        // Write top-right quadrant, A12, to Q1.
        for (int col = n1; col < n1 + n2; col++) {
            for (int row = 0; row < n1; row++) {
                if (jacobian[row][col] != null) {
                    p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sQ1[%d] = ", indent, n1 * (col - n1) + row);
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
        // Compute L^-1 * A12 by doing Q1 = L^-1 * Q1
        str.format("%sfor (i = 0; i < %d; i += %d) {\n", indent, n1 * n2, n1);
        for (int row = 0; row < n1; row++) {
            for (int col = 0; col <= row; col++) {
                if (jacobian[row][col] != null) {
                    p.printPreSteps(jacobian[row][col], str, innerIndent);
                }
            }
            str.format("%sQ1[i + %d] = (Q1[i + %d]", innerIndent, row, row);
            for (int col = 0; col < row; col++) {
                if (jacobian[row][col] != null) {
                    str.format(" - (");
                    p.print(jacobian[row][col], str, indent);
                    str.format(") * Q1[i + %d]", col);
                }
            }
            str.format(") / (");
            p.print(jacobian[row][row], str, indent);
            str.format(");\n");
            for (int col = 0; col <= row; col++) {
                if (jacobian[row][col] != null) {
                    p.printPostSteps(jacobian[row][col], str, innerIndent);
                }
            }
        }
        str.format("%s}\n", indent);
        // Write bottom-left quadrant, A21, to Q2.
        for (int col = 0; col < n1; col++) {
            for (int row = n1; row < n1 + n2; row++) {
                if (jacobian[row][col] != null) {
                    p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sQ2[%d] = ", indent, n2 * col + (row - n1));
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
        
        // Write bottom-right quadrant, A22, to Q3.
        str.format("%smemset(Q3, 0, %d * sizeof(jmi_real_t));\n", indent, n2 * n2);
        for (int col = n1; col < n1 + n2; col++) {
            for (int row = n1; row < n1 + n2; row++) {
                if (jacobian[row][col] != null) {
                	p.printPreSteps(jacobian[row][col], str, indent);
                    str.format("%sQ3[%d] = ", indent, n2 * (col - n1) + (row - n1));
                    p.print(jacobian[row][col], str, indent);
                    str.format(";\n");
                    p.printPostSteps(jacobian[row][col], str, indent);
                }
            }
        }
        
        // Compute block jacobian into Q3
        str.format("%sdgemm_(&trans, &trans, &n2, &n2, &n1, &alpha, Q2, &n2, Q1, &n1, &beta, Q3, &n2);\n", indent);
        
        str.format("%sfree(Q1);\n", indent);
        str.format("%sfree(Q2);\n", indent);
    }

    public void AbstractEquationBlock.genBlockAddCall_C(CodePrinter p, CodeStream str, String indent, boolean dirDer,
            boolean inInit, boolean generateSparse, String nleSolver, int parentBlockNumber) {

        if (!hasResidualFunction()) {
            return;
        }

        int suffix = getSequenceNumber();

        for (AbstractEquationBlock subBlock : genBlockResidualFunction_subBlocks_C()) {
            subBlock.genBlockAddCall_C(p, str, indent, dirDer, inInit, generateSparse, nleSolver, suffix);
        }
        str.print(indent);
        str.print("jmi_dae_" + (inInit ? "init_" : "") + "add_equation_block(");
        str.print("*jmi, dae_" + (inInit ? "init_" : "") + "block_" + suffix + ", ");
        if (dirDer) {
            str.print("dae_" + (inInit ? "init_" : "") + "block_dir_der_" + suffix + ", ");
        } else {
            str.print("NULL, ");
        }

        addSparseJacobianFunctionPointers(str, generateSparse);

        str.print(localUnsolvedVariables().size() + ", "); // Rename to realIterationVariables() and nonRealIterationVariables()?
        str.print(localSolvedRealVariables().size() + ", ");
        str.print(discreteRealVariables_C().size() + ", ");
        str.print(nonRealVariables_C().size() + ", ");
        str.print(directlyImpactingNonReals_C().size() + ", ");
        str.print(nonRealTempVariables_C().size() + ", ");
        str.print((activeSwitches_C().size() + activeInitialSwitches_C().size()) + ", ");
        str.print(directlyActiveSwitches_C().size() + ", ");
        str.print(variability().genJMIVariabilityConstant_C() + ", ");
        p.C_blockResidualAttributePrinter.printVariability(p, str, indent, this.localUnsolvedVariables());
        str.print(genJMISolverConstant_C(nleSolver) + ", ");
        str.print(getSequenceNumber() + ", \"");
        str.print(getLabel() + "\", ");
        str.print(parentBlockNumber + ");\n");
    }

    protected void AbstractEquationBlock.addSparseJacobianFunctionPointers(CodeStream str, boolean generateSparse) {
        str.print("NULL, NULL, ");
    }
    protected void TornEquationBlock.addSparseJacobianFunctionPointers(CodeStream str, boolean generateSparse) {
        if (generateSparse) {
            int suffix = getSequenceNumber();
            str.print(JACOBIAN_FUNCTION_C + "_" + suffix + ", ");
            str.print(JACOBIAN_STRUCT_FUNCTION_C + "_" + suffix + ", ");
        } else {
            super.addSparseJacobianFunctionPointers(str, generateSparse);
        }
    }

    @Override
    public void AbstractSubBLTBlock.genBlockAddCall_C(CodePrinter p, CodeStream str, String indent, boolean dirDer,
            boolean inInit, boolean generateSparse, String nleSolver, int parentBlockNumber) {

        for (T blt : subBLTs)
            for (AbstractEquationBlock block : blt)
                block.genBlockAddCall_C(p, str, indent, dirDer, inInit, generateSparse, nleSolver, parentBlockNumber);
    }

	syn String FTypePrefixVariability.genJMIVariabilityConstant_C();
	eq FParameter.genJMIVariabilityConstant_C() = "JMI_PARAMETER_VARIABILITY";
	eq FDiscrete.genJMIVariabilityConstant_C() = "JMI_DISCRETE_VARIABILITY";
	eq FConstant.genJMIVariabilityConstant_C() = "JMI_CONSTANT_VARIABILITY";
	eq FContinuous.genJMIVariabilityConstant_C() = "JMI_CONTINUOUS_VARIABILITY";
	/* Composite variabilities are removed during scalarization */
	eq FCompositeVariability.genJMIVariabilityConstant_C() = null;
	
    public String AbstractEquationBlock.genJMISolverConstant_C(String nleSolver) {
        if (isLinear() || localUnsolvedEquations().isEmpty())
            return "JMI_LINEAR_SOLVER";
        else if (nleSolver.equals("kinsol"))
            return "JMI_KINSOL_SOLVER";
        else if (nleSolver.equals("minpack"))
            return "JMI_MINPACK_SOLVER";
        else
            throw new UnsupportedOperationException("The string value: " + nleSolver + " is not valid for the compiler option nonlinear_solver");
    }

    private Collection<FRelExp> AbstractEquationBlock.activeSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.inactiveSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.activeInitialSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.inactiveInitialSwitches_C = null;
    private Collection<FRelExp> AbstractEquationBlock.directlyActiveSwitches_C = null;
    private Collection<FVariable> AbstractEquationBlock.directlyImpactingNonReals_C = null;
    
    /**
     * Returns all active switches in the block. A switch is considered active
     * in a block if is located in the block and depends on active variables
     * in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.activeSwitches_C() {
        cacheSwitches_C();
        return activeSwitches_C;
    }
    
    
    /**
     * Returns all active initial switches in the block. A switch is considered
     * active in a block if is located in the block and depends on active
     * aariables in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.activeInitialSwitches_C() {
        cacheSwitches_C();
        return activeInitialSwitches_C;
    }
    
    /**
     * Returns all inactive switches in the block. A switch is considered active
     * in a block if is located in the block and depends on active variables
     * in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.inactiveSwitches_C() {
        cacheSwitches_C();
        return inactiveSwitches_C;
    }
    
    
    /**
     * Returns all inactive initial switches in the block. A switch is considered
     * active in a block if is located in the block and depends on active
     * variables in the block.
     */
    public Collection<FRelExp> AbstractEquationBlock.inactiveInitialSwitches_C() {
        cacheSwitches_C();
        return inactiveInitialSwitches_C;
    }
    
    /**
     * Returns all directly active switches in the block. A switch is
     * considered active in a block if is located in the block and depends on
     * active variables in the block. A switch is considered direct if it
     * diretly affects an continuous equation.
     */
    public Collection<FRelExp> AbstractEquationBlock.directlyActiveSwitches_C() {
        cacheSwitches_C();
        return directlyActiveSwitches_C;
    }
    
    /**
     * Returns all discrete real non temporary variables in the block.
     */
    public Collection<FVariable> AbstractEquationBlock.discreteRealVariables_C() {
        Collection<FVariable> l = new ArrayList<FVariable>();
        for (FVariable fv : localDiscreteRealVariables()) {
            if (!fv.isTemporary()) {
                l.add(fv);
            }
        }
        return l;
    }
    
    /**
     * Returns all non real non temporary variables in the block.
     */
    public Collection<FVariable> AbstractEquationBlock.nonRealVariables_C() {
        Collection<FVariable> l = new ArrayList<FVariable>();
        for (FVariable fv : localNonRealVariables()) {
            if (!fv.isTemporary()) {
                l.add(fv);
            }
        }
        return l;
    }
    
    public Collection<FVariable> AbstractEquationBlock.nonRealTempVariables_C() {
        Collection<FVariable> l = new ArrayList<FVariable>();
        for (FVariable fv : localNonRealVariables()) {
            if (fv.isTemporary()) {
                l.add(fv);
            }
        }
        return l;
    }
    
    /**
     * Returns all directly affecting non reals in the block. A non real is
     * considered directly affecting in a block if is solved in the block and 
     * is used in a continuous equation.
     */
    public Collection<FVariable> AbstractEquationBlock.directlyImpactingNonReals_C() {
        cacheSwitches_C();
        return directlyImpactingNonReals_C;
    }
    
    private void AbstractEquationBlock.cacheSwitches_C() {
        if (activeSwitches_C != null && activeInitialSwitches_C != null && inactiveSwitches_C != null &&
                inactiveInitialSwitches_C != null && directlyActiveSwitches_C != null && directlyImpactingNonReals_C != null)
            return;
        activeSwitches_C = new LinkedHashSet<FRelExp>();
        activeInitialSwitches_C = new LinkedHashSet<FRelExp>();
        inactiveSwitches_C = new LinkedHashSet<FRelExp>();
        inactiveInitialSwitches_C = new LinkedHashSet<FRelExp>();
        directlyActiveSwitches_C = new LinkedHashSet<FRelExp>();
        directlyImpactingNonReals_C = new LinkedHashSet<FVariable>();
        
        Set<FAbstractEquation> realEqns = new HashSet<FAbstractEquation>(localRealEquations());
        Set<FVariable> nonRealVars = new HashSet<FVariable>(nonRealVariables_C());
        Set<FVariable> allVariables = new HashSet<FVariable>(allLocalVariables());
        for (FAbstractEquation equation : allLocalEquations()) {
            boolean realEqn = realEqns.contains(equation);
            for (FRelExp relExp : equation.relExpInInitialEquation()) {
                FRelExp orig = relExp.originalFExp();
                if (orig.dependsOn(allVariables)) {
                    activeInitialSwitches_C.add(orig);
                    if (realEqn)
                        directlyActiveSwitches_C.add(orig);
                } else {
                    inactiveInitialSwitches_C.add(orig);
                }
            }
            for (FRelExp relExp : equation.relExpInEquation()) {
                FRelExp orig = relExp.originalFExp();
                if (orig.dependsOn(allVariables)) {
                    activeSwitches_C.add(orig);
                    if (realEqn)
                        directlyActiveSwitches_C.add(orig);
                } else {
                    inactiveSwitches_C.add(orig);
                }
            }
            if (realEqn) {
                for (FVariable var : equation.referencedFVariables()) {
                    if (nonRealVars.contains(var))
                        directlyImpactingNonReals_C.add(var);
                }
            }
        }
    }


    /**
     * Generate block code for equations
     * 
     * @param visited      Keeps track of visited equations
     * @param forVariables Variables that should get a writeback
     * @param forIndices   Indices of equations that should get a writeback
     */
    public void FAbstractEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {}

    public void FAbstractEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {}

    @Override
    public void FEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        FVariable fv = forVariables.iterator().next();
        FExp sol = solution(fv);
        p.printPreSteps(sol, str, indent);
        str.format("%s%s = ", indent, fv.name_C());
        p.print(sol, str, indent);
        str.print(";\n");
        p.printPostSteps(sol, str, indent);
    }

    @Override
    public void FFunctionCallEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        if (!getCall().isIgnored()) {
            genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
            for (FFunctionCallLeft l : getLefts()) {
                l.genWriteBackAssignment_C(str, indent, forVariables);
            }
        }
    }

    @Override
    public void FFunctionCallEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        if (!getCall().isIgnored()) {
            if (firstVisit) {
                p.printPreSteps(this, str, indent);
                p.print(getCall(), str, indent);
                p.printPostSteps(this, str, indent);
            }
        }
    }

    @Override
    public void FAlgorithm.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null || !visited.contains(this);
        boolean sideEffect = forVariables == null || forVariables.size() == uniqueFIdUseExpsInLHS().size();
        genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
        if (!sideEffect && (!firstVisit || !forVariables.iterator().next().isReal())) {
            for (FIdUseExp use : uniqueFIdUseExpsInLHS())
                use.genWriteBackAssignment_C(str, indent, use.tempName_C(), forVariables);
        }
    }

    @Override
    public void FAlgorithm.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        boolean sideEffect = forVariables == null || forVariables.size() == uniqueFIdUseExpsInLHS().size();
        if (firstVisit) {
            if (sideEffect) {
                p.print(this, str, indent);
            } else {
                prettyPrintNoSideEffect_C(str, indent, forVariables);
            }
        }
    }

    @Override
    public void FIfWhenElseEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        genIfStart_C(p, str, indent);
        if (forVariables == null) {
            for (FAbstractEquation equation : getFAbstractEquations()) {
                equation.genAssignment_C(p, str, p.indent(indent));
            }
            return;
        }
        Iterator<FVariable> fvIt = forVariables.iterator();
        Iterator<Integer> fiIt = forIndices.iterator();
        Map<Integer, FVariable> fiToFvMap = new HashMap<Integer, FVariable>();
        while (fvIt.hasNext() && fiIt.hasNext()) {
            fiToFvMap.put(fiIt.next(), fvIt.next());
        }
        int i = 0;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Collection<Integer> fis   = new ArrayList<Integer>();
            Collection<FVariable> fvs = new ArrayList<FVariable>();
            int n = equation.numScalarEquations();
            for (int k = 0; k < n; k++) {
                FVariable var = fiToFvMap.get(k + i);
                if (var != null) {
                    fis.add(k);
                    fvs.add(var);
                }
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genBlock_C(p, str, p.indent(indent), visited, fvs, fis);
            }
            i += n;
        }
    }

    @Override
    public void FIfEquation.genBlock_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        super.genBlock_C(p, str, indent, visited, forVariables, forIndices);
        if (hasElse())
            getElse().genBlock_C(p, str, indent, visited, forVariables, forIndices);
        genIfEnd_C(p, str, indent);
    }

    @Override
    public void FIfWhenElseEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        genIfStart_C(p, str, indent);
        Iterator<FVariable> fvIt = forVariables.iterator();
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Collection<Integer> fis   = new ArrayList<Integer>();
            Collection<FVariable> fvs = new ArrayList<FVariable>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                    fis.add(n - i);
                    fvs.add(fvIt.next());
                    n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genBlockEval_C(p, str, p.indent(indent), visited, fvs, fis);
            }
            i += equation.numScalarEquations();
        }
    }

    @Override
    public void FIfEquation.genBlockEval_C(CodePrinter p, CodeStream str, String indent, Set<FAbstractEquation> visited,
            Collection<FVariable> forVariables, Collection<Integer> forIndices) {
        super.genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
        if (hasElse())
            getElse().genBlockEval_C(p, str, indent, visited, forVariables, forIndices);
        genIfEnd_C(p, str, indent);
    }
    
    
    
    /**
     * Generate residual code for equations
     * 
     * @param enumerator Enumerates residuals
     * @param visited    Keeps track of visited equations
     * @param forIndices Indices of equations that should get a residual
     */
    public void FAbstractEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {}

    @Override
    public void FEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        p.printPreSteps(this, str, indent);
        str.print(indent + "(*res)[" + enumerator.next() + "] = ");
        p.print(getRight(), str, "");
        str.print(" - (");
        p.print(getLeft(), str, "");
        str.print(");\n");
        p.printPostSteps(this, str, indent);
    }

    @Override
    public void FFunctionCallEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        boolean firstVisit = visited == null || visited.add(this);
        if (!getCall().isIgnored()) {
            if (firstVisit) {
                p.printPreSteps(this, str, indent);
                p.print(getCall(), str, indent);
                p.printPostSteps(this, str, indent);
            }
            Enumerator indexCounter = new Enumerator();
            for (FFunctionCallLeft l : getLefts())
                l.genWriteBackResidual_C(str, indent, enumerator, forIndices, indexCounter);
        }
    }

    @Override
    public void FIfWhenElseEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        genIfStart_C(printer_C, str, indent);
        Iterator<Integer> fiIt = forIndices.iterator();
        int i = 0;
        int n = fiIt.hasNext() ? fiIt.next() : -1;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            Set<Integer> fis = new HashSet<Integer>();
            while (n >= i && n < i + equation.numScalarEquations()) {
                fis.add(n - i);
                n = fiIt.hasNext() ? fiIt.next() : -1;
            }
            if (forIndices.size() == 0 || fis.size() > 0) {
                equation.genResidual_C(p, str, p.indent(indent), enumerator, visited, fis);
            }
            i += equation.numScalarEquations();
        }
    }

    @Override
    public void FIfWhenEquation.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        Enumerator enumCopy = enumerator.copy();
        super.genResidual_C(p, str, indent, enumerator, visited, forIndices);
        if (hasElse())
            getElse().genResidual_C(p, str, indent, enumCopy, visited, forIndices);
        genIfEnd_C(p, str, indent);
    }

    @Override
    public void FAlgorithm.genResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator, Set<FAbstractEquation> visited, Set<Integer> forIndices) {
        if (visited == null || visited.add(this)) {
            p.printPreSteps(this, str, indent);
            prettyPrintNoSideEffect_C(str, indent, null);
            p.printPostSteps(this, str, indent);
        }
        Enumerator indexCounter = new Enumerator();
        for (FIdUseExp use : uniqueFIdUseExpsInLHS()) {
            use.genWriteBackResidual_C(str, indent, use.tempName_C(), enumerator, forIndices, indexCounter);
        }
    }

    /**
     * Helper for genBlock_C and genResidual_C
     * Prints the algorithm, statements which restore LHS variables,
     * and statements which put the new values in temporaries.
     */
    public void FAlgorithm.prettyPrintNoSideEffect_C(CodeStream str, String indent, Collection<FVariable> forVariables) {
        String switchTemp = this.tempName_C();
        Collection<FIdUseExp> lhs = uniqueFIdUseExpsInLHS();
        for (FIdUseExp use : lhs) {
            if (forVariables == null || !forVariables.contains(use.myFV()) || !use.myFV().isReal()) {
                FStatement.printAssignStmt_C(str, indent, use.tempName_C(), use.myFV().name_C());
            }
        }
        prettyPrint_C(str, indent);
        for (FIdUseExp use : lhs) {
            if (forVariables == null || !forVariables.contains(use.myFV()) || !use.myFV().isReal()) {
                FStatement.printAssignStmt_C(str, indent, switchTemp, use.myFV().name_C());
                FStatement.printAssignStmt_C(str, indent, use.myFV().name_C(), use.tempName_C());
                FStatement.printAssignStmt_C(str, indent, use.tempName_C(), switchTemp);
            }
        }
    }

    public static void FStatement.printAssignStmt_C(CodeStream str, String indent, String dst, String src) {
        str.print(indent + dst + " = " + src + ";\n");
    }

    public void FType.printAssign_C(CodePrinter p, CodeStream str, String indent, FExp dst, FExp src) {
        str.print(indent);
        p.print(dst, str, indent);
        str.print(" = ");
        p.print(src, str, indent);
        str.print(";\n");
    }

    @Override
    public void FStringType.printAssign_C(CodePrinter p, CodeStream str, String indent, FExp dst, FExp src) {
        str.print(indent);
        str.print("JMI_ASG(");
        str.print(macroType());
        str.print(", ");
        p.print(dst, str, indent);
        str.print(", ");
        p.print(src, str, indent);
        str.print(")\n");
    }

    public void FType.printReturn_C(CodeStream str, String indent, String dst, String src) {
        str.print(indent);
        str.print("JMI_RET(");
        str.print(macroType());
        str.print(", ");
        str.print(dst);
        str.print(", ");
        str.print(src);
        str.print(")\n");
    }

    public void FType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.print(indent);
        str.print("JMI_DEF(");
        str.print(macroTypeDecl(external));
        str.print(", ");
        str.print(name);
        str.print(")\n");
    }

    @Override
    public void FRecordType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.formatln("%sJMI_RECORD_STATIC(%s, %s)", indent, nameScalar_C(external), name);
    }

    public void FType.printFree_C(CodeStream str, String indent, boolean external, String name) {
    }

    @Override
    public void FStringType.printFree_C(CodeStream str, String indent, boolean external, String name) {
        if (isArray()) {
            str.formatln("%sjmi_free_str_arr(%s);", indent, name);
        } else {
            str.formatln("%sJMI_FREE(%s)", indent, name);
        }
    }

    /**
     * Helper for printing if equations
     */
    public void FIfWhenElseEquation.genIfStart_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        str.print("} else {\n");
    }

    @Override
    public void FIfWhenEquation.genIfStart_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        if (isElse())
            str.print("} else ");
        str.print("if (");
        p.print(getTest(), str, p.indent(indent));
        str.print(") {\n");
    }

    /**
     * Helper for printing if equations
     */
    public void FIfWhenElseEquation.genIfEnd_C(CodePrinter p, CodeStream str, String indent) {}

    @Override
    public void FIfWhenEquation.genIfEnd_C(CodePrinter p, CodeStream str, String indent) {
        if (!isElse()) {
            str.print(indent);
            str.print("}\n");
        }
    }
    
    /**
     * Generates code for dependent parameter assignments
     */
    public void FAbstractEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {
        genBlock_C(p, str, indent, null, null, null);
    }

    @Override
    public void FEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(this, str, indent);
        FIdUseExp left = (FIdUseExp)getLeft().stripNegations();
        FVariable fv = (FVariable)left.myFV();
        if (fv.isExternalObject()) {
            fv.genDestructorCall_C(p, str, indent);
        }
        fv.genAssignment_C(p, str, indent, fv.name_C(), getRight(), getLeft().isNegated());
        p.printPostSteps(this, str, indent);
    }

    public void FVariable.genDestructorCall_C(CodePrinter p, CodeStream str, String indent) {
        throw new UnsupportedOperationException("Method not implemented for class " + getClass().getSimpleName() + "!");
    }

    public void FExternalObjectVariable.genDestructorCall_C(CodePrinter p, CodeStream str, String indent) {
        if (hasConstructorCall(Index.NULL)) {
            str.formatln("%sif (%s != NULL) {", indent, name_C());
            p.print(getDestructorCall(), str, p.indent(indent));
            str.formatln("%s%s = NULL;", p.indent(indent), name_C());
            str.formatln("%s}", indent);
        } else {
            /* Alias external objects does not call constructors so no destructor call is needed. */
        }
    }

    syn FFunctionCallStmt FExternalObjectVariable.getDestructorCall() {
        String strName = type().name() + ".destructor";
        FIdUse name = new FIdUse(strName);
        List<FExp> args = new List<FExp>();
        args.add(createUseExp());
        FFunctionCall call = new FFunctionCall(name, args, FFunctionType.create(strName, new ArrayList<FVariable>(), myFClass()));
        return new FFunctionCallStmt(new List<FFunctionCallLeft>(), call);
    }

    syn String FFunctionCallLeft.name_C() {
        if (replaceWithTemp()) {
            return getFExp().tempName_C();
        } else {
            return ((FIdUseExp) getFExp()).getFIdUse().name_C();
        }
    }
    
    public void FExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        throw new UnsupportedOperationException("Method not implemented for class " + getClass().getSimpleName() + "!");
    }

    @Override
    public void FRelExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        printIndicator(p.DeclStep, str, indent, true);
    }

    @Override
    public void FDelayExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (!p.inInitialSystem()) {
            p.printVarDecls(getDelay(), str, indent);
        }
    }

    @Override
    public void FSpatialDistExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (!p.inInitialSystem()) {
            p.printVarDecls(getX(), str, indent);
            p.printVarDecls(getPositiveVelocity(), str, indent);
        }
    }

    public void FExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        throw new UnsupportedOperationException("Method not implemented for class " + getClass().getSimpleName() + "!");
    }

    @Override
    public void FRelExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        printIndicator(p.PreStep, str, indent, true);
		str.print(indent + "(*res)[" + enumerator.next() + "] = ");
        printIndicator(p.ExecStep, str, indent, true);
		str.print(";\n");
        printIndicator(p.PostStep, str, indent, true);
	}

    @Override
    public void FDelayExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        if (p.inInitialSystem()) {
            str.formatln("%s(*res)[%d] = JMI_DELAY_INITIAL_EVENT_RES;", indent, enumerator.next());
            str.formatln("%s(*res)[%d] = JMI_DELAY_INITIAL_EVENT_RES;", indent, enumerator.next());
        } else {
            p.printPreSteps(getDelay(), str, indent);
            int index = myDelayIndex();
            str.format("%sjmi_delay_first_event_indicator(jmi, %d, ", indent, index);
            p.print(getDelay(), str, indent);
            str.print(", &(*res)[" + enumerator.next() + "]);\n");
            str.format("%sjmi_delay_second_event_indicator(jmi, %d, ", indent, index);
            p.print(getDelay(), str, indent);
            str.print(", &(*res)[" + enumerator.next() + "]);\n");
            p.printPostSteps(getDelay(), str, indent);
        }
    }

    @Override
    public void FSpatialDistExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        if (p.inInitialSystem()) {
            str.formatln("%s(*res)[%d] = JMI_DELAY_INITIAL_EVENT_RES;", indent, enumerator.next());
        } else {
            p.printPreSteps(getX(), str, indent);
            p.printPreSteps(getPositiveVelocity(), str, indent);
            int index = mySpatialDistIndex();
            str.format("%sef = jmi_spatialdist_event_indicator(jmi, %d, ", indent, index);
            p.print(getX(), str, indent);
            str.print(", ");
            p.print(getPositiveVelocity(), str, indent);
            str.print(", &(*res)[" + enumerator.next() + "]);\n");
            p.printPostSteps(getX(), str, indent);
            p.printPostSteps(getPositiveVelocity(), str, indent);
        }
    }
    
    syn nta FExp FRelExp.getIndicatorNominal() = FExp.nominalMax(getLeft(), getRight());
    
    syn lazy boolean FRelExp.scale() = myOptions().getBooleanOption("event_indicator_scaling");
    
    inh boolean FExp.hasBrancher();
    inh lazy boolean FRelExp.hasBrancher();
    eq Root.getChild().hasBrancher()              = false;
    eq FAbstractEquation.getChild().hasBrancher() = false;
    eq FAndExp.getLeft().hasBrancher()            = isIndicatorGuard(getLeft()) || hasBrancher();
    eq FAndExp.getRight().hasBrancher()           = true;
    eq FOrExp.getLeft().hasBrancher()             = isIndicatorGuard(getLeft()) || hasBrancher();
    eq FOrExp.getRight().hasBrancher()            = true;
    eq FIfExp.getThenExp().hasBrancher()          = true;
    eq FIfExp.getElseExp().hasBrancher()          = true;
    
    private void FRelExp.printIndicator(CodePrinter.StepPrinter sp, CodeStream str, String indent, boolean guard) {
        boolean hb = hasBrancher();
        if (guard && hb) {
            sp.print(str, FEqExp.macro_C);
            sp.print(str, "(");
            printIndicatorGuard(sp, str, indent, this);
            sp.print(str, ", JMI_TRUE, ");
        }
        
        if (scale()) {
            sp.print(str, "(");
        }
        
        if (hasIndicator()) {
            sp.print(getIndicator(), str, indent);
        } else {
            sp.print(getLeft(), str, indent);
            sp.print(str, " - (");
            sp.print(getRight(), str, indent);
            sp.print(str, ")");
        }
        
        if (scale()) {
            sp.print(str, ") / ");
            sp.print(getIndicatorNominal(), str, indent);
        }
        
        if (guard && hb) {
            sp.print(str, ", 1.0)");
        }
    }
    
    inh FExp FExp.parentFExp();
    eq Root.getChild().parentFExp()              = null;
    eq FAbstractEquation.getChild().parentFExp() = null;
    eq FExp.getChild().parentFExp()              = this;
    
    public void FExp.printIndicatorGuard(CodePrinter.StepPrinter sp, CodeStream str, String indent) {
        FExp par = parentFExp();
        if (par != null) {
            par.printIndicatorGuard(sp, str, indent, this);
        }
    }
    
    public void FExp.printIndicatorGuard(CodePrinter.StepPrinter sp, CodeStream str, String indent, FExp e) {
        if (isIndicatorGuard(e)) {
            printIndicatorGuard(sp, str, indent, myIndicatorGuardExp(e), negateIndicatorGuard(e));
        } else {
            printIndicatorGuard(sp, str, indent);
        }
    }
    
    syn boolean FExp.isIndicatorGuard(FExp e) = false;
    eq FLogBinExp.isIndicatorGuard(FExp e)    = e == getRight() || allowFlipGuard();
    eq FIfExp.isIndicatorGuard(FExp e)        = e == getThenExp() || e == getElseExp();
    
    syn FExp FExp.myIndicatorGuardExp(FExp e) = null;
    eq FLogBinExp.myIndicatorGuardExp(FExp e) = e == getRight() ? getLeft() : getRight();
    eq FIfExp.myIndicatorGuardExp(FExp e)     = getIfExp();
    
    syn boolean FExp.negateIndicatorGuard(FExp e) = false;
    eq FOrExp.negateIndicatorGuard(FExp e)        = true;
    eq FIfExp.negateIndicatorGuard(FExp e)        = e == getElseExp();
    
    syn lazy boolean FLogBinExp.allowFlipGuard() = !getRight().hasEventIndicator();
    
    syn boolean ASTNode.hasEventIndicator() {
        for (ASTNode n : this) {
            if (n.hasEventIndicator()) {
                return true;
            }
        }
        return false;
    }
    eq FRelExp.hasEventIndicator() = originalFExp() == this && generatesEvent() || super.hasEventIndicator();
    
    public void FExp.printIndicatorGuard(CodePrinter.StepPrinter sp, CodeStream str, String indent, FExp e, boolean not) {
        boolean hb = hasBrancher();
        if (hb) {
            sp.print(str, FAndExp.macro_C);
            sp.print(str, "(");
            printIndicatorGuard(sp, str, indent);
            sp.print(str, ", ");
        }
        
        if (not) {
            sp.print(str, FNotExp.macro_C);
            sp.print(str, "(");
        }
        
        sp.print(e, str, indent);
        
        if (not) {
            sp.print(str, ")");
        }
        
        if (hb) {
            sp.print(str, ")");
        }
    }

    public void FExp.genTimeEventVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        genVarDecls_C(p, str, indent);
    }

    @Override
    public void FRelExp.genTimeEventVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        printIndicator(p.DeclStep, str, indent, true);
    }

    public void FExp.genTimeEvent_C(CodePrinter p, CodeStream str, String indent, String res) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void FRelExp.genTimeEvent_C(CodePrinter p, CodeStream str, String indent, String res) {
        printIndicator(p.PreStep, str, indent, true);
        boolean phased = isPhased();
        str.format("%sif (SURELY_LT_ZERO(", indent);
        printIndicator(p.ExecStep, str, indent, true);
        str.print(")");
        if (phased) {
            str.print(" || (!jmi->eventPhase && ALMOST_ZERO(");
            printIndicator(p.ExecStep, str, indent, true);
            str.print("))");
        }
        str.println(") {");
        
        str.format("%sjmi_min_time_event(%s, 1, %s, ", p.indent(indent), res, phased ? "1" : "0");
        p.print(solutionForTime(), str, indent);
        str.formatln(");\n%s}", indent);
        printIndicator(p.PostStep, str, indent, true);
    }

    @Override
    public void FSampleExp.genTimeEvent_C(CodePrinter p, CodeStream str, String indent, String res) {
        /*
            There are three cases to consider for each sampler:
             1) The current time is (surely) before the offset of 
                the sampler. In this case, the next time event occurs
                at time offset.
             2) The current time is a sample instant of the sampler
                in which case next time event is the next sample
                instant.
             3) If neither of the above holds true, then the current
                time is in between two sample instants of the sampler.
                In this case, the next time event is the next sample
                instant.
        */
        super.genTempVars_C(p, str, indent);
        // Case 1: time is before offset 
        str.print("  if (SURELY_LT_ZERO(_t - (");
        getOffset().prettyPrint_C(str,"");
        str.print("))) {\n");
        str.format("%sjmi_min_time_event(%s, 1, 0, ", indent, res);
        getOffset().prettyPrint_C(str,"");
        str.println(");");
        //str.print("printf(\"Hepp: %f %f\\n\",_t,nextTimeEventTmp);\n");
        str.print("  } ");   
        // Case 2: we are at a sample                                   
        str.print(" else if (ALMOST_ZERO(jmi_dremainder(jmi, _t - (");
        getOffset().prettyPrint_C(str,"");
        str.print("), ");
        getInterval().prettyPrint_C(str,"");
        str.print("))) {\n");
        // nSamp should be almost an integer - round to get it exact
        str.print("    nSamp = jmi_dround((_t - (");
        getOffset().prettyPrint_C(str,"");
        str.print(")) / (");
        getInterval().prettyPrint_C(str,"");
        str.print("));\n");
        str.format("%sjmi_min_time_event(%s, 1, 0, ", indent, res);
        str.print("(nSamp + 1.0) * (");
        getInterval().prettyPrint_C(str,"");
        str.print(") + (");
        getOffset().prettyPrint_C(str,"");
        str.println("));");
/*----*//*
        str.print("printf(\"Hopp: %12.12f %12.12f %12.12f %12.12f\\n\",_t,nextTimeEventTmp,nSamp,");
        str.print("(_t-");
        getOffset().prettyPrint_C(str,"");
        str.print(")/(");
        getInterval().prettyPrint_C(str,"");
        str.print("));\n");

*//*---*/
        str.print("  } ");

        // Case 3: Neither of the above: in between samples
        str.print(" else if (SURELY_GT_ZERO(jmi_dremainder(jmi, _t - (");
        getOffset().prettyPrint_C(str,"");
        str.print("), ");
        getInterval().prettyPrint_C(str,"");
        str.print("))) {\n");
        // User the floor function to get the number of previous
        // samples
        str.print("    nSamp = floor((_t - (");
        getOffset().prettyPrint_C(str,"");
        str.print(")) / (");
        getInterval().prettyPrint_C(str,"");
        str.print("));\n");
        str.format("%sjmi_min_time_event(%s, 1, 0, ", indent, res);
        str.print("(nSamp + 1.0) * (");
        getInterval().prettyPrint_C(str,"");
        str.print(") + (");
        getOffset().prettyPrint_C(str,"");
        str.println("));");
/*----*//*
        str.print("printf(\"Hopp2: %12.12f %12.12f %12.12f %12.12f\\n\",_t,nextTimeEventTmp,nSamp,");
        str.print("(_t-");
        getOffset().prettyPrint_C(str,"");
        str.print(")/(");
        getInterval().prettyPrint_C(str,"");
        str.print("));\n");

*//*---*/
        str.print("  }\n");
        super.genTempFree_C(p, str, indent);
    }

	public void FRealVariable.genStartAttributeResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
		p.printPreSteps(this, str, indent);
		if (!(this instanceof FDerivativeVariable)) {
			str.print(indent + "(*res)[" + enumerator.next() + "] = ");
			if (startAttributeSet()) {
				if (myOptions().getBooleanOption("enable_variable_scaling")) {
					str.print("(");
					p.print(startAttributeExp(), str, "");
					str.print(")");
					str.print("/sf(");
					str.print(valueReference());
					str.print(")");
				} else {
					p.print(startAttributeExp(), str, "");
				}
			} else {
				str.print("0.0");
			}
			str.print(" - ");
			str.print(name_C());
			str.print(";\n");
		}
		p.printPostSteps(this, str, indent);
	}
	
    public void FExp.genRelExpKind(CodeStream str) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void FDelayExp.genRelExpKind(CodeStream str) {
        str.print(FRelExp.GEQ_C);
        str.print(", ");
        str.print(FRelExp.GEQ_C);
    }

    @Override
    public void FSpatialDistExp.genRelExpKind(CodeStream str) {
        str.print(FRelExp.GEQ_C);
    }

    @Override
    public void FRelExp.genRelExpKind(CodeStream str) {
    	str.print(kindString());
    }

    public void FRelExp.genRelExpKindPhased(CodeStream str) {
        str.print(kindStringPhased());
    }

    public static String FRelExp.LT_C  = "JMI_REL_LT";
    public static String FRelExp.LEQ_C = "JMI_REL_LEQ";
    public static String FRelExp.GT_C  = "JMI_REL_GT";
    public static String FRelExp.GEQ_C = "JMI_REL_GEQ";

    syn String FRelExp.kindString() = "-1";
    eq FLtExp.kindString()  = FRelExp.LT_C;
    eq FLeqExp.kindString() = FRelExp.LEQ_C;
    eq FGtExp.kindString()  = FRelExp.GT_C;
    eq FGeqExp.kindString() = FRelExp.GEQ_C;

    syn String FRelExp.kindStringPhased() = kindString();
    eq FLtExp.kindStringPhased()  = FRelExp.LEQ_C;
    eq FLeqExp.kindStringPhased() = FRelExp.LT_C;
    eq FGtExp.kindStringPhased()  = FRelExp.GEQ_C;
    eq FGeqExp.kindStringPhased() = FRelExp.GT_C;

    /**
     * Convert to a string represenation to use in C source files.
     * 
     * @return Representation of value for C files.   
     */
	public String CValue.cCodeValue() {
		return toString();
	}

    @Override
    public String CValueBoolean.cCodeValue() {
        return ASTNode.boolValue_C(value);
    }

    @Override
	public String CValueEnum.cCodeValue() {
		return Integer.toString(intValue());
	}

    public void FVariable.genStartValue_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(this, str, indent);
        FExp exp = useBindingExpAsStart() ? getBindingExp() : startAttributeExp();
        boolean noExp = exp == null;
        if (noExp)
            setBindingExp(exp = type().zeroLiteral());
        genAssignment_C(p, str, indent, name_C(), exp, false);
        if (noExp)
            setBindingExpOpt(new Opt());
        p.printPostSteps(this, str, indent);
    }

    public void FVariable.genAssignment_C(CodePrinter p, CodeStream str, String indent, String name, FExp right,
            boolean neg) {
        str.print(indent);
        if (isString()) {
             str.print("JMI_ASG(STR_Z, ");
             str.print(name);
             str.print(", ");
        } else {
            str.print(name);
            str.print(" = ");
        }
        if (neg) {
            str.print("-");
        }
        str.print("(");
        p.print(right, str, "");
        str.print(")");
        if (isReal() && myOptions().getBooleanOption("enable_variable_scaling")) {
            str.print("/sf(");
            str.print(valueReference());
            str.print(")");
        }
        if (isString()) {
            str.print(")");
        }
        str.print(";\n");
    }

	public void BLT.genOdeDerivativeBlocks(CodePrinter p, CodeStream str, String indent) {
		for (AbstractEquationBlock block : this) {
			block.genSolvedInBLT(p, str, indent); 
		}
	}

	public java.util.List<AbstractEquationBlock> BLT.getAllBlocks() {
		return this;
	}

	public void BLT.genVarDecls(CodePrinter p, CodeStream str, String indent) {
		for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genVarDecls(p, str, indent);
		}
	}

    @Override
	public void StructuredBLT.genOdeDerivativeBlocks(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%s/********* Initialize reinits *******/", indent);
        for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genReinitTempInits_C(p, str, indent);
        }
		str.formatln("%s/************* ODE section *********/", indent);
		// Loop over all derivatives
		for (AbstractEquationBlock eb : getOdeBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
		str.formatln("%s/************ Real outputs *********/", indent);
		for (AbstractEquationBlock eb : getRealOutputBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
		str.formatln("%s/****Integer and boolean outputs ***/", indent);
		for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
		str.formatln("%s/**** Other variables ***/", indent);
		for (AbstractEquationBlock eb : getOtherBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
        str.formatln("%s/********* Write back reinits *******/", indent);
        for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genReinitWritebacks_C(p, indent, str);
        }
	}

    @Override
    public void DynamicStateBLT.genOdeDerivativeBlocks(CodePrinter p, CodeStream str, String indent) {
        DynamicStateSet lastSet = null;
        int i = 0;
        for (FVariable state : states()) {
            DynamicStateSet set = state.dynamicStateSet();
            if (lastSet != set) {
                i = 0;
                lastSet = set;
            } else {
                i++;
            }
            str.formatln("%s%s = %s;", indent, state.name_C(), set.getStateVars()[i].name_C());
        }
        super.genOdeDerivativeBlocks(p, str, indent);
        lastSet = null;
        i = 0;
        for (FVariable algebraic : algebraics()) {
            DynamicStateSet set = algebraic.dynamicStateSet();
            if (lastSet != set) {
                i = 0;
                lastSet = set;
            } else {
                i++;
            }
            str.formatln("%s%s = %s;", indent, set.getAlgebraicVars()[i].name_C(), algebraic.name_C());
        }
    }
	

    syn int DynamicStateSet.id_C() = id() - 1;

    public void DynamicStateSet.genDSCoefficientsFuncName_C(CodePrinter p, CodeStream str, String indent) {
        str.print("ds_coefficients");
        str.format("_%d", id_C());
    }

    public void DynamicStateManager.genDynamicStateAddCall_C(CodePrinter p, CodeStream str, String indent) {
        for (DynamicStateSet set : getSets())
            set.genDynamicStateAddCall_C(p, str, indent);
    }

    public void DynamicStateSet.genDynamicStateAddCall_C(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%s{", indent);
        String innerIndent = p.indent(indent);
        str.formatln("%sint* ds_var_value_refs = calloc(%d, sizeof(int));", innerIndent, numVars());
        str.formatln("%sint* ds_state_value_refs = calloc(%d, sizeof(int));", innerIndent, numStates());
        str.formatln("%sint* ds_algebraic_value_refs = calloc(%d, sizeof(int));", innerIndent, numAlgebraics());
        int i = 0;
        for (FVariable var : fVars()) {
            str.formatln("%sds_var_value_refs[%d] = %d; /* %s */", innerIndent, i, var.valueReference(), var.name());
            i++;
        }
        i = 0;
        for (FVariable var : getStateVars()) {
            str.formatln("%sds_state_value_refs[%d] = %d; /* %s */", innerIndent, i, var.valueReference(), var.name());
            i++;
        }
        i = 0;
        for (FVariable var : getAlgebraicVars()) {
            str.formatln("%sds_algebraic_value_refs[%d] = %d; /* %s */", innerIndent, i, var.valueReference(), var.name());
            i++;
        }
        str.format("%sjmi_dynamic_state_add_set(*jmi, %d, %d, %d, ds_var_value_refs, ds_state_value_refs, ds_algebraic_value_refs, ", innerIndent, id_C(), numVars(), numStates());
        genDSCoefficientsFuncName_C(p, str, indent);
        str.println(");");
        str.formatln("%sfree(ds_var_value_refs);", innerIndent);
        str.formatln("%sfree(ds_state_value_refs);", innerIndent);
        str.formatln("%sfree(ds_algebraic_value_refs);", innerIndent);
        str.formatln("%s}", indent);
    }

    public void DynamicStateManager.genDynamicStateCoefficients_C(CodePrinter p, CodeStream str, String indent) {
        for (DynamicStateSet set : getSets())
            set.genDynamicStateCoefficients_C(p, str, indent);
    }

    public void DynamicStateSet.genDynamicStateCoefficients_C(CodePrinter p, CodeStream str, String outerIndent) {
        str.format("%sstatic void ", outerIndent);
        String indent = p.indent(outerIndent);
        genDSCoefficientsFuncName_C(p, str, indent);
        str.println("(jmi_t* jmi, jmi_real_t* res) {");
        for (DynamicStateCoefficient coff : getCoefficients())
            p.printVarDecls(coff, str, indent);
        str.format("%smemset(res, 0, %d * sizeof(jmi_real_t));\n", indent, numAlgebraics() * numVars());
        for (DynamicStateCoefficient coff : getCoefficients()) {
            p.printPreSteps(coff, str, indent);
            str.format("%sres[%d] = ", indent, coff.getEquation() + numAlgebraics() * coff.getVariable());
            p.print(coff, str, indent);
            str.println(";");
            p.printPostSteps(coff, str, indent);
        }
        
        str.formatln("%s}", outerIndent);
        str.println();
    }
}
