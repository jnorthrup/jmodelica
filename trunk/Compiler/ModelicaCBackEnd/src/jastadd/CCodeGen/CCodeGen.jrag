/*
Copyright (C) 2009-2017 Modelon AB
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.ByteArrayOutputStream;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Set;
import java.util.Stack;

import org.jmodelica.util.Enumerator;
import org.jmodelica.util.streams.CStringCodeStream;

aspect CCodeGen {

    /**
     * Static printer instance.
     */
    static CPrettyPrinter ASTNode.printer_C = new CPrettyPrinter();

    public class CPrettyPrinter extends CodePrinter {

        public CPrettyPrinter() {
            this(null, false, Homotopy.HOMOTOPY, true);
        }
        
        public CPrettyPrinter(AbstractEquationBlock block) {
            this(block, false, Homotopy.HOMOTOPY, false);
        }

        protected CPrettyPrinter(AbstractEquationBlock block, boolean inInitialSystem, Homotopy homotopyType,
                boolean writeSwitches) {
            super(block, inInitialSystem, homotopyType, writeSwitches);
        }

        @Override
        protected CodePrinter createPrinter(AbstractEquationBlock block, boolean inInitialSystem, Homotopy homotopyType,
                boolean writeSwitches) {
            return new CPrettyPrinter(block, inInitialSystem, homotopyType, writeSwitches);
        }

        @Override
        public void print(ASTNode node, CodeStream str, String indent) { 
            node.prettyPrint_C(this, str, indent); 
        }

        @Override
        public void printVarDecls(ASTNode node, CodeStream str, String indent) {
            node.genVarDecls_C(this, str, indent);
        }
        
        @Override
        public void printDecl(ASTNode node, CodeStream str, String indent, Set<ASTNode> visited, Collection<FVariable> forVariables, boolean solved) {
            node.printDecl_C(this, str, indent, visited, forVariables, solved);
        }
        
        @Override
        public void printPreSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempVars_C(this, str, indent);
        }
        
        @Override
        public void printPostSteps(ASTNode node, CodeStream str, String indent) {
            node.genTempFree_C(this, str, indent);
        }

        @Override
        public TypePrinter_C createDeclPrinter(CodeStream str) {
            return new DeclPrinter_C(this, str);
        }
        
        @Override
        public TypePrinter_C createInitPrinter(CodeStream str) {
            return new InitPrinter_C(this, str);
        }
        
        @Override
        public TypePrinter_C createInitSetPrinter(CodeStream str) {
            return new InitSetPrinter_C(this, str);
        }

        @Override
        public void genBlockResidualCall(AbstractEquationBlock block, CodeStream str, String indent) {
            block.genBlockResidualCall_C(this, str, indent);
        }

        @Override
        public void genSolved(FAbstractEquation node, CodeStream str, String indent,
                Set<FAbstractEquation> visited, Collection<FVariable> forVariables, Collection<Integer> forIndices) {
            node.genBlock_C(this, str, indent, visited, forVariables, forIndices);
        }

        @Override
        public void genResidual(FAbstractEquation node, CodeStream str, String indent, Enumerator enumerator,
                Set<FAbstractEquation> visited, Set<Integer> forIndices) {
            node.genResidual_C(this, str, indent, enumerator, visited, forIndices);
        }
    }

    public String ASTNode.prettyPrint_C() {
        // This method should not exist
        ByteArrayOutputStream os = new ByteArrayOutputStream();
        CodeStream str = new CodeStream(os);
        prettyPrint_C(ASTNode.printer_C, str, "");
        return os.toString();
    }


    public void ASTNode.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this) {
            p.printVarDecls(node, str, indent);
        }
    }

    public void ASTNode.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this) {
            p.printPreSteps(node, str, indent);
        }
    }

    public void ASTNode.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        prettyPrint(p, str, indent);
    }

    public void ASTNode.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        for (ASTNode node : this) {
            p.printPostSteps(node, str, indent);
        }
    }

    /*
     * Record declaration
     */
    
    syn String FRecordDecl.name_C()      = getFQName().lastActualTypePartName() + "_" + recordIndex();
	
    @Override
    public void FRecordDecl.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        p.print(type(), str, indent);
    }
    
    @Override
    public void FRecordType.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        // Scalar type
        printStruct_C(p, str, indent, false);
        
        //Array type
		str.print(indent);
		str.print("JMI_ARRAY_TYPE(");
        str.print(nameScalar_C());
		str.print(", ");
		str.print(nameArray_C());
		str.print(")\n\n");
        
        // External type
        if (externalValid()) {
            printStruct_C(p, str, indent, true);
        }
        str.print("\n");
    }

    public void FRecordType.printStruct_C(CodePrinter p, CodeStream str, String indent, boolean ext) {
        String name = ext ? nameScalarExt_C() : nameScalar_C();
        FFunctionDecl.beginStruct_C(str, indent, name);
        String next = p.indent(indent);
        for (FRecordComponentType frct : getComponents()) {
            str.print(next);
            str.print(ext ? frct.getFType().nameScalarExt_C() : frct.getFType().type_C());
            str.print(" ");
            str.print(frct.getName());
            str.print(";\n");
        }
        if (getNumComponent() == 0) {
            // always generate default field so that C struct is not empty
            str.print(next + "char dummy;\n");
        }
        FFunctionDecl.endStruct_C(str, indent);
    }
    
	// Suffixes that are used with variables in JMI: size, var, arr, rec
	public static final String ASTNode.C_SUFFIX_DEF      = "def";
	public static final String ASTNode.C_SUFFIX_EXP      = "exp";
	public static final String ASTNode.C_SUFFIX_REC      = "r";
    public static final String ASTNode.C_SUFFIX_EXT      = "_ext";
	public static final String ASTNode.C_SUFFIX_ENUM     = "e";
	public static final String ASTNode.C_SUFFIX_INDEX    = "i";
	public static final String ASTNode.C_SUFFIX_VARIABLE = "v";
	public static final String ASTNode.C_SUFFIX_ARRAY    = "a";
	public static final String ASTNode.C_SUFFIX_RETURN   = "o";
	public static final String ASTNode.C_SUFFIX_NULL     = "n";

	public static final String ASTNode.C_ARRAY_RECORD    = "rec";
	public static final String ASTNode.C_ARRAY_REFERENCE = "ref";
	public static final String ASTNode.C_ARRAY_VALUE     = "val";
    
    // Suffixes used with functional arguments
    public static final String ASTNode.C_SUFFIX_FP       = "fp";
    public static final String ASTNode.C_SUFFIX_FPCL     = "fpcl";
    public static final String ASTNode.C_SUFFIX_FPCR     = "fpcr";
    public static final String ASTNode.C_SUFFIX_FPOUT    = "fpout";
    
    public class FTypePrefixVariability {
        public enum VariabilityCausality_C {
            CI("ci"),
            CD("cd"),
            PI("pi"),
            PS("ps"),
            PF("pf"),
            PE("pe"),
            PD("pd");
            
            private String s;
            
            private VariabilityCausality_C(String s) {
                this.s = s;
            }
            
            public String toString() {
                return s;
            }
        }
    }
    
    syn FTypePrefixVariability.VariabilityCausality_C FVariable.variabilityCausality_C() = variability().variabilityCausality_C(this);
    
    syn VariabilityCausality_C FTypePrefixVariability.variabilityCausality_C(FVariable fv) {
        throw new UnsupportedOperationException();
    }
    eq FConstant.variabilityCausality_C(FVariable fv)          = fv.isIndependentConstant()  ? VariabilityCausality_C.CI : VariabilityCausality_C.CD;
    eq FParameter.variabilityCausality_C(FVariable fv)         = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PD;
    eq FStructParameter.variabilityCausality_C(FVariable fv)   = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PS;
    eq FFinalParameter.variabilityCausality_C(FVariable fv)    = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PF;
    eq FEvalTrueParameter.variabilityCausality_C(FVariable fv) = fv.isIndependentParameter() ? VariabilityCausality_C.PI : VariabilityCausality_C.PE;
    
	syn String FAbstractVariable.funcArrayType(boolean assign) = 
		isRecord() ? C_ARRAY_RECORD : (assign ? C_ARRAY_REFERENCE : C_ARRAY_VALUE);
    
    syn String FType.arrayAccess(int nd, String name, String ind) {
        return String.format("jmi_array_%s_%d(%s, %s)", isRecord() ? C_ARRAY_RECORD : C_ARRAY_REFERENCE, 
                nd, name, ind);
    }

	syn lazy String FAbstractVariable.name_C() = null;
	eq FVariable.name_C()           = isForIndex() ? 
										name_C(null, variableIndex() + C_SUFFIX_INDEX) : 
										name_C(""); 
    eq FStringVariable.name_C()     = name_C("_s_" + variabilityCausality_C());
	eq FPreRealVariable.name_C()    = preName_C();
	eq FPreBooleanVariable.name_C() = preName_C();
	eq FPreIntegerVariable.name_C() = preName_C();
	eq FPreStringVariable.name_C()  = preName_C();
	eq FPreEnumVariable.name_C()    = preName_C();

	eq FFunctionVariable.name_C()   = name_C(null, C_SUFFIX_VARIABLE);
	eq FFunctionArray.name_C()      = name_C(null, C_SUFFIX_ARRAY);
	
	syn String FAbstractVariable.preName_C() = null; 
	eq FVariable.preName_C() = name_C("pre");
	
	protected String FVariable.name_C(String prefix) {
		return name_C(prefix, Integer.toString(variableIndex()));
	}
	
	protected String FAbstractVariable.name_C(String prefix, String suffix) {
		StringBuilder buf = new StringBuilder();
		if (prefix != null) {
			buf.append(prefix);
			buf.append('_');
		}
		buf.append(nameUnderscore());
		buf.append('_');
		buf.append(suffix);
		return buf.toString();
	}
	
	syn String FFunctionVariable.nameReturn_C() = 
		isRecord() ? name_C() : name_C(null, C_SUFFIX_RETURN);
    syn String FFunctionArray.nameReturn_C() =
        isString() ? name_C(null, C_SUFFIX_RETURN) : name_C();
	
	syn String FAbstractVariable.type_C() = type().type_C();
	syn String FFunctionCallLeft.type_C() = type().type_C();
	
	
    syn String FFunctionVariable.typeReturn_C() = isRecord() ? type_C() : (type_C() + "*");
    eq FFunctionArray.typeReturn_C()            = type_C();
    
    
    syn String FType.type_C() = isArray() ? arrayType_C() : scalarType_C();
    
    syn String FType.scalarType_C()         = nameScalar_C();
    eq FRecordType.scalarType_C()           = nameScalar_C() + "*";
    
    syn String FType.arrayType_C()          = nameArray_C() + "*";

    
    syn String FType.typeExternal_C() = isArray() ? arrayExternalType_C() : scalarExternalType_C();
    
    syn String FType.scalarExternalType_C() = nameScalarExt_C();
    eq FRecordType.scalarExternalType_C()   = nameScalarExt_C() + "*";
    
    syn String FType.arrayExternalType_C()  = nameArrayExt_C() + "*";
    
    syn String FType.nameScalar_C(boolean external) = external ? nameScalarExt_C() : nameScalar_C();
    syn String FType.nameArray_C(boolean external)  = external ? nameArrayExt_C() : nameArray_C();
    
    syn String FType.nameScalar_C()       = "jmi_real_t";
    eq FRecordType.nameScalar_C()         = (getFClass() != null ? myFRecordDecl().name_C() : 
        ASTNode.underScore(getName())) + "_" + C_SUFFIX_REC;
    eq FStringType.nameScalar_C()         = "jmi_string_t";
    eq FExternalObjectType.nameScalar_C() = "jmi_extobj_t";
    eq FFunctionType.nameScalar_C() = myFFunctionDecl().funcNameUnderscore(C_SUFFIX_FP) + "*";
    
    syn String FType.nameArray_C()        = "jmi_array_t";
    eq FRecordType.nameArray_C()          = nameScalar_C() + C_SUFFIX_ARRAY;
    eq FStringType.nameArray_C()          = "jmi_string_array_t";
    eq FExternalObjectType.nameArray_C()  = "jmi_extobj_array_t";
    
    syn String FType.nameScalarExt_C()    = nameScalar_C();
    eq FRecordType.nameScalarExt_C()      = nameScalar_C() +  C_SUFFIX_EXT;
    eq FIntegerType.nameScalarExt_C()     = "jmi_int_t";
    eq FBooleanType.nameScalarExt_C()     = "jmi_int_t";
    eq FEnumType.nameScalarExt_C()        = "jmi_int_t";
    
    syn String FType.nameArrayExt_C()     = nameArray_C();
    eq FIntegerType.nameArrayExt_C()      = "jmi_int_array_t";
    eq FBooleanType.nameArrayExt_C()      = "jmi_int_array_t";
    eq FEnumType.nameArrayExt_C()         = "jmi_int_array_t";
    
    
    /* Corresponding external c representation */
    syn String FExp.argType_C(boolean ref) = type().argType_C(ref);
    eq FSizeExp.argType_C(boolean ref)     = ref ? type().argType_C(ref) : "size_t";
    
    syn String FType.argType_C(boolean ref)        = argTypeBase_C() + (ref ? "*" : "");
    eq FStringType.argType_C(boolean ref)          = "const " + super.argType_C(isArray());
    
    syn String FType.argTypeBase_C()        = type_C();
    eq FPrimitiveType.argTypeBase_C()       = "double";
    eq FIntegerType.argTypeBase_C()         = "int";
    eq FBooleanType.argTypeBase_C()         = "int";
    eq FEnumType.argTypeBase_C()            = "int";
    eq FExternalObjectType.argTypeBase_C()  = "void*";
    eq FStringType.argTypeBase_C()          = "char*";
    
    /* Macro type tokens */
    syn String FType.macroType() = macroTypeScalar() + (isArray() ? "_ARR" : "");
    
    syn String FType.macroTypeScalar() = "GEN";
    eq FStringType.macroTypeScalar()   = "STR";
    
    syn String FType.macroTypeDecl(boolean external) = external ? macroTypeDeclScalar() + "_EXT" : macroTypeDeclScalar();
    
    syn String FType.macroTypeDeclScalar()       = "GEN";
    eq FRealType.macroTypeDeclScalar()           = "REA";
    eq FIntegerType.macroTypeDeclScalar()        = "INT";
    eq FBooleanType.macroTypeDeclScalar()        = "BOO";
    eq FEnumType.macroTypeDeclScalar()           = "ENU";
    eq FStringType.macroTypeDeclScalar()         = "STR";
    eq FExternalObjectType.macroTypeDeclScalar() = "EXO";
    
    public static void ASTNode.genFunctionStart(CodeStream str, String indent) {
        str.print(indent);
        str.print("int ef = 0;\n");
        ASTNode.genDynMemInit(str, indent);
    }
    
    public static void ASTNode.genFunctionEnd(CodeStream str, String indent) {
        ASTNode.genDynMemFree(str, indent);
        str.print(indent);
        str.print("return ef;\n");
    }
    
    public static void ASTNode.genDynMemInit(CodeStream str, String indent) {
        str.print(indent);
        str.print("JMI_DYNAMIC_INIT()\n");
    }
    
    public static void ASTNode.genDynMemFree(CodeStream str, String indent) {
        str.print(indent);
        str.print("JMI_DYNAMIC_FREE()\n");
    }


	public void FFunctionVariable.printArgument_C(CodeStream str) {
		str.print(type_C());
		str.print(" ");
		str.print(name_C());
	}
	
	private FExp FFunctionVariable.dummyFExp = null;
	
	public void FFunctionVariable.setDummyExp() {
		if (dummyFExp == null) 
			dummyFExp = new FNoExp();
		setBindingExp(dummyFExp);
	}
	
	public void FFunctionVariable.resetDummyExp() {
		if (dummyFExp != null)
			setBindingExpOpt(new Opt());
	}

    public void FFunctionVariable.print(TypePrinter_C tp, String name, String indent) {
        setDummyExp();
        tp.reset(name, getBindingExp(), size(), false, indent);
        type().print(tp);
        resetDummyExp();
    }

    @Override
    public void FFunctionVariable.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        p.printInit(this, str, indent, type());
    }

    public void FType.printDecl_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        printDecl_C(p, str, indent, name, src, false);
    }

    public void FType.printDecl_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, boolean external) {
        print(p.createDeclPrinter(str), indent, name, src, external);
    }

    public void FType.printInit_C(CodePrinter p, CodeStream str, String indent, String name, FExp src) {
        printInit_C(p, str, indent, name, src, false);
    }

    public void FType.printInit_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, boolean external) {
        print(p.createInitSetPrinter(str), indent, name, src, external);
    }

    public void FType.print(TypePrinter_C tp, String indent, CodePrinter.ExecuteCodePrinter ep, FExp src, boolean external) {
        print(tp, indent, ep.name(src), src, external);
    }

    public void FType.print(TypePrinter_C tp, String indent, String name, FExp src, boolean external) {
        tp.reset(name, src, size(), external, indent);
        print(tp);
    }

    public void FType.print(TypePrinter_C p)               { p.print(this); }
    public void FRecordType.print(TypePrinter_C p)         { p.print(this); }
    public void FExternalObjectType.print(TypePrinter_C p) { p.print(this); }
    
    public abstract class TypePrinter_C {
        protected CodePrinter p;
        protected CodeStream str;
        protected FExp src;
        protected boolean external = false;
        protected boolean subDecls = false; // Used in CAD
        
        private Stack<Level> levels   = new Stack<Level>();
        
        public TypePrinter_C(CodePrinter p, CodeStream str) {
            this.p = p;
            this.str = str;
        }
        
        public TypePrinter_C(CodePrinter p, CodeStream str, String indent, String name, FExp src, Size s, boolean external) {
            this(p, str);
            reset(name, src, s, external, indent);
        }
        
        public void reset(String name, FExp src, Size s, boolean external, String indent) {
            this.src = src;
            levels = new Stack<Level>();
            levels.push(new Level(name, indent, !s.variability().knownParameterOrLess() || external, src));
            this.external = external;
        }
        
        public void resetUnknown(String name, FType type, String indent) {
            this.src = null;
            levels = new Stack<Level>();
            levels.push(new Level(name, indent, type.isArray() || type.isExternalObject(), null));
            this.external = false;
        }
        
        public void setSubDecls(boolean subDecls) { this.subDecls = subDecls; }
        
        protected String name()     { return levels.peek().name; }
        protected String indent()   { return levels.peek().indent; }
        protected boolean dynamic() { return levels.peek().dynamic; }
        
        protected class Level {
            String name;
            String indent;
            boolean dynamic;
            FExp src;
            public Level(String name, String indent, boolean dynamic, FExp src) {
                this.name    = name;
                this.indent  = indent;
                this.dynamic = dynamic;
                this.src = src;
            }
        }
        
        protected void pushLevel(String name, boolean indent, Size s, FExp src) {
            levels.push(new Level(name, indent ? p.indent(indent()) : indent(), !s.variability().knownParameterOrLess() || dynamic(), src));
        }
        
        protected void pushLevelExt(String name, boolean indent, Size s) {
            levels.push(new Level(name, indent ? p.indent(indent()) : indent(), s.ndims() > 0, null));
        }
        
        protected void popLevel() {
            levels.pop();
        }
        
        
        protected String dynStr(FType type) {
            return (dynamic() ? "DYNA" : "STAT");
        }
        
        public void print(FType type) {
            if (type.isArray()) {
                printArray(type);
            } else {
                printScalar(type);
            }
        }
        
        public void print(FRecordType type) {
            printComposite(type);
        }
        
        public void print(FExternalObjectType type) {
            printComposite(type);
        }
        
        FExp levelSrc(Index i) {
            FExp exp = levels.peek().src;
            if (exp != null && exp instanceof FArray && exp.type().isRecord()) {
                return exp.fArrayCell(i, 0);
            }
            return null;
        }
        
        FExp levelSrc(String name) {
            FExp exp = levels.peek().src;
            if (exp != null && exp instanceof FRecordConstructor) {
                return exp.component(name);
            }
            return null;
        }
        
        public void printComposite(FType type) {
            print(type);
            if (type.isArray()) {
                if (dynamic()) {
                    printDynArray(type);
                } else {
                    for (Index i : type.indices()) {
                        pushLevel(type.arrayAccess(type.ndims(), name(), i.toUnclosedString()), false, Size.SCALAR, levelSrc(i));
                        printComps(type);
                        popLevel();
                    }
                }
            } else {
                printComps(type);
            }
        }
        
        protected void printComps(FType type) {
            if (type.isRecord()) {
                printComps((FRecordType) type);
            }
        }
        
        protected void printComps(FRecordType type) {
            for (FRecordComponentType comp : type.getComponents()) {
                if (shouldPrintComp(comp)) {
                    String compName = name() + "->" + comp.getName();
                    boolean useTempName = !dynamic() && comp.getFType().isComposite();
                    String tempName = useTempName ? acquireTemp(compName) : compName;
                    FExp compExp = levelSrc(comp.getName());
                    pushLevel(tempName, false, comp.getFType().size(), compExp);
                    if (compExp == null || compExp.type().isNoType()) {
                        comp.getFType().print(this);
                    } else {
                        compExp.type().print(this);
                    }
                    popLevel();
                    if (useTempName)
                        tempWriteBack(compName, tempName);
                }
            }
        }
        
        protected boolean shouldPrintComp(FRecordComponentType comp) {
            return comp.getFType().isComposite();
        }
        
        protected void printExt(FExternalObjectType type) {
            
        }
        
        protected void printComps(FExternalObjectType type) {
            int i = 0;
            String name = acquireTemp(name());
            for (FExp arg : type.myConstructorStmt().myConstructorArgs()) {
                pushLevelExt(name + "_arg" + i, false, arg.size());
                FType t = arg.type();
                boolean b = t.parent == null;
                if (b) {
                    // This needs to be done since some exps does
                    // not parent their calculated type
                    t.setParent(type);
                }
                t.print(this);
                if (b) {
                    t.setParent(null);
                }
                popLevel();
                i++;
            }
        }
        
        protected void printScalar(FType type) {}
        abstract protected void printArray(FType type);
        abstract protected void printDynArray(FType type);
        abstract protected String acquireTemp(String name);
        protected void tempWriteBack(String compName, String tempName) {}
        
        protected void printSizesAsArgs(FType type) {
            printNumElements(type);
            str.print(", ");
            str.print(type.ndims());
            printDimensions(type);
        }
        protected void printNumElements(FType type) {
            if (external && dynamic())
                type.size().printNumElements_C(p, str, indent(), src.myCodeGenContext().alias(src.prettyPrint_C()));
            else
                type.size().printNumElements_C(p, str, indent(), src);
        }
        protected void printDimensions(FType type) {
            str.print(", ");
            if (external && dynamic())
                type.size().printDimensions_C(p, str, indent(), src.myCodeGenContext().alias(src.prettyPrint_C()));
            else
                type.size().printDimensions_C(p, str, indent(), src);
        }
    }
    
    public class DeclPrinter_C extends TypePrinter_C {
        protected boolean print = true;
        public DeclPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }

        @Override
        protected String acquireTemp(String key) {
            String tmp = src.nextTempName_C();
            src.recordChildTempNames().put(key, tmp);
            return tmp;
        }

        @Override
        protected void printScalar(FType type) {
            if (print) {
                type.printScalarDecl_C(str, indent(), external, name());
            }
        }

        @Override
        protected void printArray(FType type) {
            if (print) {
                str.print(indent(), "JMI_ARR(",
                        dynStr(type), ", ", 
                        type.nameScalar_C(external), ", ",
                        type.nameArray_C(external), ", ",
                        name(), ", ");
                printSizesAsArgs(type);
                str.println(")");
            }
        }

        @Override
        protected void printNumElements(FType type) {
            if (dynamic())
                str.print("-1");
            else
                super.printNumElements(type);
        }

        @Override
        protected void printDimensions(FType type) {
            
        }

        @Override
        protected void printDynArray(FType type) {
            String ind    = acquireTemp(name());
            String maxind = ind + "_max";
            print = true;
            pushLevel(ind, false, Size.SCALAR, null);
            type.fRealScalarType().print(this);
            popLevel();
            pushLevel(maxind, false, Size.SCALAR, null);
            type.fRealScalarType().print(this);
            popLevel();
            print = type.isExternalObject();
            pushLevel(type.arrayAccess(1, name(), ind), false, new MutableSize(1), null);
            printComps(type);
            popLevel();
            print = true;
        }
    }
    
    public class InitPrinter_C extends TypePrinter_C {
        public InitPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }

        @Override
        protected String acquireTemp(String key) {
            return src.recordChildTempNames().get(key);
        }

        @Override
        protected void printArray(FType type) {
            str.print(indent(), "JMI_ARRAY_INIT_", type.ndims(), "(", 
                    dynStr(type), ", ",
                    type.nameScalar_C(external), ", ",
                    type.nameArray_C(external), ", ",
                    name(), ", ");
            printSizesAsArgs(type);
            str.println(")");
        }

        @Override
        protected void printDynArray(FType type) {
            String ind    = acquireTemp(name());
            String maxind = ind + "_max";
            if (initMaxInd()) {
                str.print(indent() + maxind + " = ");
                printNumElements(type);
                str.println(" + 1;");
            }
            str.formatln("%sfor (%s = 1; %s < %s; %s++) {", indent(), ind, ind, maxind, ind);
            pushLevel(type.arrayAccess(1, name(), ind), true, new MutableSize(1), null);
            printComps(type);
            popLevel();
            str.println(indent() + "}");
        }

        protected boolean initMaxInd() { return true; }

        @Override
        protected void tempWriteBack(String compName, String tempName) {
            str.formatln("%s%s = %s;", indent(), compName, tempName);
        }
    }
    
    public class InitSetPrinter_C extends InitPrinter_C {
        public InitSetPrinter_C(CodePrinter p, CodeStream str) {
            super(p, str);
        }

        @Override
        protected void printScalar(FType type) {
            type.printInitStartValue_C(p, str, indent(), name());
        }

        @Override
        protected boolean shouldPrintComp(FRecordComponentType comp) {
            return super.shouldPrintComp(comp) || comp.getFType().isString();
        }
    }

    public void FType.printInitStartValue_C(CodePrinter p, CodeStream str, String indent, String name) {
        
    }

    @Override
    public void FStringType.printInitStartValue_C(CodePrinter p, CodeStream str, String indent, String name) {
        str.print(indent);
        str.print("JMI_INI(");
        str.print(macroTypeScalar());
        str.print(", ");
        str.print(name);
        str.print(")\n");
    }
	
	private Map<String,String> FExp.recordChildTempNameMap = null;
	
	public Map<String,String> FExp.recordChildTempNames() {
		if (recordChildTempNameMap == null)
			recordChildTempNameMap = new HashMap<String,String>();
		return recordChildTempNameMap;
	}

	public void Size.printNumElements_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
		str.print(numElements());
	}

    @Override
    public void MutableSize.printNumElements_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        if (!variability().knownParameterOrLess()) {
            for (int i = 0; i < size.length; i++) {
                FExp exp = exps[i];
                if (i > 0) {
                    str.print(" * ");
                }
                if (exp == null) {
                    str.print(size[i]);
                } else {
                    boolean addParenthesis = exp.addParenthesis(FExp.PRECEDENCE_MULTIPLICATIVE);
                    if (addParenthesis) {
                        str.print("(");
                    }
                    p.print(exp, str, indent);
                    if (addParenthesis) {
                        str.print(")");
                    }
                }
            }
        } else {
            super.printNumElements_C(p, str, indent, src);
        }
	}
	
    public void Size.printDimensions_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        str.print(toUnclosedString());
    }

	@Override
	public void MutableSize.printDimensions_C(CodePrinter p, CodeStream str, String indent, ASTNode src) {
        if (!variability().knownParameterOrLess()) {
			for (int i = 0; i < size.length; i++) {
				if (i > 0)
					str.print(", ");
                if (exps[i] == null) {
					str.print(size[i]);
				} else {
                    FExp exp = exps[i];
					exp.prettyPrint_C(p, str, indent); // TODO: This is a hack to get CAD gen to work!
				}
			}
		} else {
			super.printDimensions_C(p, str, indent, src);
		}
	}
	
    public void Size.printNumElements_C(CodePrinter p, CodeStream str, String indent, String name) {
        printDimsWithSep_C(p, str, indent, name, " * ");
    }
    public void Size.printDimensions_C(CodePrinter p, CodeStream str, String indent, String name) {
        printDimsWithSep_C(p, str, indent, name, ", ");
    }
    private void Size.printDimsWithSep_C(CodePrinter p, CodeStream str, String indent, String name, String sep) {
        printSize_C(p, str, indent, name, 0);
        for (int i = 1; i < ndims(); i++) {
            str.print(sep);
            printSize_C(p, str, indent, name, i);
        }
    }
    public void Size.printSize_C(CodePrinter p, CodeStream str, String indent, String name, int dim) {
        str.print("jmi_array_size(");
        str.print(name);
        str.print(", ");
        str.print(dim);
        str.print(")");
    }
    public void Size.printSize_C(CodePrinter p, CodeStream str, String indent, FExp e, int dim) {
        str.print("jmi_array_size(");
        p.print(e, str, indent);
        str.print(", ");
        str.print(dim);
        str.print(")");
    }
    
    public void Size.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genVarDecls_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (size[i] == Size.UNKNOWN) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printVarDecls(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genVarDecls_C(p, str, indent, src);
        }
    }

	
    public void Size.genTempVars_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genTempVars_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (size[i] == Size.UNKNOWN) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printPreSteps(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genTempVars_C(p, str, indent, src);
        }
    }
    
    public void Size.genTempFree_C(CodePrinter p, CodeStream str, String indent, FExp src) {}

    @Override
    public void MutableSize.genTempFree_C(CodePrinter p, CodeStream str, String indent, FExp src) {
        if (isUnknown()) {
            for (int i = 0; i < size.length; i++) {
                if (size[i] == Size.UNKNOWN) {
                    FExp exp = src.dynamicFExp(exps[i]);
                    p.printPostSteps(exp, str, indent); // TODO: This is a hack to get CAD gen to work!
                }
            }
        } else {
            super.genTempFree_C(p, str, indent, src);
        }
    }
	
    
    
    
    
    
    
    @Override
    public void FAbstractEquation.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                node.genVarDecls_C(p, str, indent);
    }

    @Override
	public void FFunctionVariable.genVarDecls_C(CodePrinter p, CodeStream str, String indent) {
		if (!isInput()) {
			String suffix = (isOutput() && isComposite() && !isString()) ? C_SUFFIX_NULL : "";
			print(p.createDeclPrinter(str), name_C() + suffix, indent);
		}
	}

    @Override
	public void FFunctionCallEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
		if (!getCall().isIgnored()) {
			p.printPreSteps(this, str, indent);
		}
	}

    @Override
    public void FIfEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        if (isWhen() && p.inInitialSystem() && !getTest().isInitialGuard()) {
            return;
        }
        p.printPreSteps(this, str, indent);
        genIfStart_C(p, str, indent);
        for (FAbstractEquation equation : getFAbstractEquations())
            p.print(equation, str, p.indent(indent));
        if (hasElse()) {
            p.print(getElse(), str,indent);
        }
        genIfEnd_C(p, str, indent);
    }
    
    @Override
    public void FElseEquation.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        genIfStart_C(p, str, indent);
        for (FAbstractEquation equation : getFAbstractEquations())
            p.print(equation, str, p.indent(indent));
    }

    @Override
    public void FAbstractEquation.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPreSteps(node, str, indent);
    }

    @Override
    public void FAbstractEquation.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        ASTNode attributeList = getFAttributeList();
        for (ASTNode node : this)
            if (node != attributeList)
                p.printPostSteps(node, str, indent);
    }

    @Override
    public void FIfEquation.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(getTest(), str, indent);
    }
    
    @Override
    public void FIfEquation.genTempFree_C(CodePrinter p, CodeStream str, String indent) {
        p.printPostSteps(getTest(), str, indent);
    }

    public static void FStatement.printAssignStmt_C(CodeStream str, String indent, String dst, String src) {
        str.print(indent + dst + " = " + src + ";\n");
    }

    public void FType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.print(indent);
        str.print("JMI_DEF(");
        str.print(macroTypeDecl(external));
        str.print(", ");
        str.print(name);
        str.print(")\n");
    }

    @Override
    public void FRecordType.printScalarDecl_C(CodeStream str, String indent, boolean external, String name) {
        str.formatln("%sJMI_RECORD_STATIC(%s, %s)", indent, nameScalar_C(external), name);
    }

    public void FType.printFree_C(CodeStream str, String indent, boolean external, String name) {
    }

    @Override
    public void FStringType.printFree_C(CodeStream str, String indent, boolean external, String name) {
        if (isArray()) {
            str.formatln("%sjmi_free_str_arr(%s);", indent, name);
        } else {
            str.formatln("%sJMI_FREE(%s)", indent, name);
        }
    }

    /**
     * Helper for printing if equations
     */
    public void FIfWhenElseEquation.genIfStart_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        str.print("} else {\n");
    }

    @Override
    public void FIfWhenEquation.genIfStart_C(CodePrinter p, CodeStream str, String indent) {
        str.print(indent);
        if (isElse())
            str.print("} else ");
        str.print("if (");
        p.print(getTest(), str, p.indent(indent));
        str.print(") {\n");
    }

    /**
     * Helper for printing if equations
     */
    public void FIfWhenElseEquation.genIfEnd_C(CodePrinter p, CodeStream str, String indent) {}

    @Override
    public void FIfWhenEquation.genIfEnd_C(CodePrinter p, CodeStream str, String indent) {
        if (!isElse()) {
            str.print(indent);
            str.print("}\n");
        }
    }
    
    /**
     * Generates code for dependent parameter assignments
     */
    public void FAbstractEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {
        genBlock_C(p, str, indent, null, null, null);
    }

    @Override
    public void FEquation.genAssignment_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(this, str, indent);
        FIdUseExp left = (FIdUseExp)getLeft().stripNegations();
        FVariable fv = (FVariable)left.myFV();
        if (fv.isExternalObject()) {
            fv.genDestructorCall_C(p, str, indent);
        }
        fv.genAssignment_C(p, str, indent, fv.name_C(), getRight(), getLeft().isNegated());
        p.printPostSteps(this, str, indent);
    }

    public void FVariable.genDestructorCall_C(CodePrinter p, CodeStream str, String indent) {
        throw new UnsupportedOperationException("Method not implemented for class " + getClass().getSimpleName() + "!");
    }

    public void FExternalObjectVariable.genDestructorCall_C(CodePrinter p, CodeStream str, String indent) {
        if (hasConstructorCall(Index.NULL)) {
            str.formatln("%sif (%s != NULL) {", indent, name_C());
            p.print(getDestructorCall(), str, p.indent(indent));
            str.formatln("%s%s = NULL;", p.indent(indent), name_C());
            str.formatln("%s}", indent);
        } else {
            /* Alias external objects does not call constructors so no destructor call is needed. */
        }
    }

    syn FFunctionCallStmt FExternalObjectVariable.getDestructorCall() {
        String strName = type().name() + ".destructor";
        FIdUse name = new FIdUse(strName);
        List<FExp> args = new List<FExp>();
        args.add(createUseExp());
        FFunctionCall call = new FFunctionCall(name, args, FFunctionType.create(strName, new ArrayList<FVariable>(), myFClass()));
        return new FFunctionCallStmt(new List<FFunctionCallLeft>(), call);
    }

    syn String FFunctionCallLeft.name_C() {
        if (replaceWithTemp()) {
            return getFExp().tempName_C();
        } else {
            return ((FIdUseExp) getFExp()).getFIdUse().name_C();
        }
    }
    
    public void FExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        throw new UnsupportedOperationException("Method not implemented for class " + getClass().getSimpleName() + "!");
    }

    @Override
    public void FRelExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        printIndicator(p.DeclStep, str, indent, true);
    }

    @Override
    public void FDelayExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (!p.inInitialSystem()) {
            p.printVarDecls(getDelay(), str, indent);
        }
    }

    @Override
    public void FSpatialDistExp.genEventResidualVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (!p.inInitialSystem()) {
            p.printVarDecls(getX(), str, indent);
            p.printVarDecls(getPositiveVelocity(), str, indent);
        }
    }

    public void FExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        throw new UnsupportedOperationException("Method not implemented for class " + getClass().getSimpleName() + "!");
    }

    @Override
    public void FRelExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        printIndicator(p.PreStep, str, indent, true);
		str.print(indent + "(*res)[" + enumerator.next() + "] = ");
        printIndicator(p.ExecStep, str, indent, true);
		str.print(";\n");
        printIndicator(p.PostStep, str, indent, true);
	}

    @Override
    public void FDelayExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        if (p.inInitialSystem()) {
            str.formatln("%s(*res)[%d] = JMI_DELAY_INITIAL_EVENT_RES;", indent, enumerator.next());
            str.formatln("%s(*res)[%d] = JMI_DELAY_INITIAL_EVENT_RES;", indent, enumerator.next());
        } else {
            p.printPreSteps(getDelay(), str, indent);
            int index = myDelayIndex();
            str.format("%sjmi_delay_first_event_indicator(jmi, %d, ", indent, index);
            p.print(getDelay(), str, indent);
            str.print(", &(*res)[" + enumerator.next() + "]);\n");
            str.format("%sjmi_delay_second_event_indicator(jmi, %d, ", indent, index);
            p.print(getDelay(), str, indent);
            str.print(", &(*res)[" + enumerator.next() + "]);\n");
            p.printPostSteps(getDelay(), str, indent);
        }
    }

    @Override
    public void FSpatialDistExp.genEventResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
        if (p.inInitialSystem()) {
            str.formatln("%s(*res)[%d] = JMI_DELAY_INITIAL_EVENT_RES;", indent, enumerator.next());
        } else {
            p.printPreSteps(getX(), str, indent);
            p.printPreSteps(getPositiveVelocity(), str, indent);
            int index = mySpatialDistIndex();
            str.format("%sef = jmi_spatialdist_event_indicator(jmi, %d, ", indent, index);
            p.print(getX(), str, indent);
            str.print(", ");
            p.print(getPositiveVelocity(), str, indent);
            str.print(", &(*res)[" + enumerator.next() + "]);\n");
            p.printPostSteps(getX(), str, indent);
            p.printPostSteps(getPositiveVelocity(), str, indent);
        }
    }
    
    syn nta FExp FRelExp.getIndicatorNominal() = FExp.nominalMax(getLeft(), getRight());
    
    syn lazy boolean FRelExp.scale() = myOptions().getBooleanOption("event_indicator_scaling");
    
    inh boolean FExp.hasBrancher();
    inh lazy boolean FRelExp.hasBrancher();
    eq Root.getChild().hasBrancher()              = false;
    eq FAbstractEquation.getChild().hasBrancher() = false;
    eq FAndExp.getLeft().hasBrancher()            = isIndicatorGuard(getLeft()) || hasBrancher();
    eq FAndExp.getRight().hasBrancher()           = true;
    eq FOrExp.getLeft().hasBrancher()             = isIndicatorGuard(getLeft()) || hasBrancher();
    eq FOrExp.getRight().hasBrancher()            = true;
    eq FIfExp.getThenExp().hasBrancher()          = true;
    eq FIfExp.getElseExp().hasBrancher()          = true;
    
    private void FRelExp.printIndicator(CodePrinter.StepPrinter sp, CodeStream str, String indent, boolean guard) {
        boolean hb = hasBrancher();
        if (guard && hb) {
            sp.print(str, FEqExp.macro_C);
            sp.print(str, "(");
            printIndicatorGuard(sp, str, indent, this);
            sp.print(str, ", JMI_TRUE, ");
        }
        
        if (scale()) {
            sp.print(str, "(");
        }
        
        if (hasIndicator()) {
            sp.print(getIndicator(), str, indent);
        } else {
            sp.print(getLeft(), str, indent);
            sp.print(str, " - (");
            sp.print(getRight(), str, indent);
            sp.print(str, ")");
        }
        
        if (scale()) {
            sp.print(str, ") / ");
            sp.print(getIndicatorNominal(), str, indent);
        }
        
        if (guard && hb) {
            sp.print(str, ", " + FLitExp.macro_C + "(1))");
        }
    }
    
    inh FExp FExp.parentFExp();
    eq Root.getChild().parentFExp()              = null;
    eq FAbstractEquation.getChild().parentFExp() = null;
    eq FExp.getChild().parentFExp()              = this;
    
    public void FExp.printIndicatorGuard(CodePrinter.StepPrinter sp, CodeStream str, String indent) {
        FExp par = parentFExp();
        if (par != null) {
            par.printIndicatorGuard(sp, str, indent, this);
        }
    }
    
    public void FExp.printIndicatorGuard(CodePrinter.StepPrinter sp, CodeStream str, String indent, FExp e) {
        if (isIndicatorGuard(e)) {
            printIndicatorGuard(sp, str, indent, myIndicatorGuardExp(e), negateIndicatorGuard(e));
        } else {
            printIndicatorGuard(sp, str, indent);
        }
    }
    
    syn boolean FExp.isIndicatorGuard(FExp e) = false;
    eq FLogBinExp.isIndicatorGuard(FExp e)    = e == getRight() || allowFlipGuard();
    eq FIfExp.isIndicatorGuard(FExp e)        = e == getThenExp() || e == getElseExp();
    
    syn FExp FExp.myIndicatorGuardExp(FExp e) = null;
    eq FLogBinExp.myIndicatorGuardExp(FExp e) = e == getRight() ? getLeft() : getRight();
    eq FIfExp.myIndicatorGuardExp(FExp e)     = getIfExp();
    
    syn boolean FExp.negateIndicatorGuard(FExp e) = false;
    eq FOrExp.negateIndicatorGuard(FExp e)        = true;
    eq FIfExp.negateIndicatorGuard(FExp e)        = e == getElseExp();
    
    syn lazy boolean FLogBinExp.allowFlipGuard() = !getRight().hasEventIndicator();
    
    syn boolean ASTNode.hasEventIndicator() {
        for (ASTNode n : this) {
            if (n.hasEventIndicator()) {
                return true;
            }
        }
        return false;
    }
    eq FRelExp.hasEventIndicator() = originalFExp() == this && generatesEvent() || super.hasEventIndicator();
    
    public void FExp.printIndicatorGuard(CodePrinter.StepPrinter sp, CodeStream str, String indent, FExp e, boolean not) {
        boolean hb = hasBrancher();
        if (hb) {
            sp.print(str, FAndExp.macro_C);
            sp.print(str, "(");
            printIndicatorGuard(sp, str, indent);
            sp.print(str, ", ");
        }
        
        if (not) {
            sp.print(str, FNotExp.macro_C);
            sp.print(str, "(");
        }
        
        sp.print(e, str, indent);
        
        if (not) {
            sp.print(str, ")");
        }
        
        if (hb) {
            sp.print(str, ")");
        }
    }

    public void FExp.genTimeEventVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        genVarDecls_C(p, str, indent);
    }

    @Override
    public void FRelExp.genTimeEventVarDecls_C(CodePrinter p, CodeStream str, String indent) {
        printIndicator(p.DeclStep, str, indent, true);
    }

    public void FExp.genTimeEvent_C(CodePrinter p, CodeStream str, String indent, String res) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void FRelExp.genTimeEvent_C(CodePrinter p, CodeStream str, String indent, String res) {
        printIndicator(p.PreStep, str, indent, true);
        boolean phased = isPhased();
        str.format("%sif (SURELY_LT_ZERO(", indent);
        printIndicator(p.ExecStep, str, indent, true);
        str.print(")");
        if (phased) {
            str.print(" || (!jmi->eventPhase && ALMOST_ZERO(");
            printIndicator(p.ExecStep, str, indent, true);
            str.print("))");
        }
        str.println(") {");
        
        str.format("%sjmi_min_time_event(%s, 1, %s, ", p.indent(indent), res, phased ? "1" : "0");
        p.print(solutionForTime(), str, indent);
        str.formatln(");\n%s}", indent);
        printIndicator(p.PostStep, str, indent, true);
    }

    @Override
    public void FSampleExp.genTimeEvent_C(CodePrinter p, CodeStream str, String indent, String res) {
        /*
            There are three cases to consider for each sampler:
             1) The current time is (surely) before the offset of 
                the sampler. In this case, the next time event occurs
                at time offset.
             2) The current time is a sample instant of the sampler
                in which case next time event is the next sample
                instant.
             3) If neither of the above holds true, then the current
                time is in between two sample instants of the sampler.
                In this case, the next time event is the next sample
                instant.
        */
        super.genTempVars_C(p, str, indent);
        // Case 1: time is before offset 
        str.print("  if (SURELY_LT_ZERO(_t - (");
        p.print(getOffset(), str, indent);
        str.print("))) {\n");
        str.format("%sjmi_min_time_event(%s, 1, 0, ", indent, res);
        p.print(getOffset(), str, indent);
        str.println(");");
        //str.print("printf(\"Hepp: %f %f\\n\",_t,nextTimeEventTmp);\n");
        str.print("  } ");   
        // Case 2: we are at a sample                                   
        str.print(" else if (ALMOST_ZERO(jmi_dremainder(jmi, _t - (");
        p.print(getOffset(), str, indent);
        str.print("), ");
        p.print(getInterval(), str, indent);
        str.print("))) {\n");
        // nSamp should be almost an integer - round to get it exact
        str.print("    nSamp = jmi_dround((_t - (");
        p.print(getOffset(), str, indent);
        str.print(")) / (");
        p.print(getInterval(), str, indent);
        str.print("));\n");
        str.format("%sjmi_min_time_event(%s, 1, 0, ", indent, res);
        str.print("(nSamp + 1.0) * (");
        p.print(getInterval(), str, indent);
        str.print(") + (");
        p.print(getOffset(), str, indent);
        str.println("));");
/*----*//*
        str.print("printf(\"Hopp: %12.12f %12.12f %12.12f %12.12f\\n\",_t,nextTimeEventTmp,nSamp,");
        str.print("(_t-");
        p.print(getOffset(), str, indent);
        str.print(")/(");
        p.print(getInterval(), str, indent);
        str.print("));\n");

*//*---*/
        str.print("  } ");

        // Case 3: Neither of the above: in between samples
        str.print(" else if (SURELY_GT_ZERO(jmi_dremainder(jmi, _t - (");
        p.print(getOffset(), str, indent);
        str.print("), ");
        p.print(getInterval(), str, indent);
        str.print("))) {\n");
        // User the floor function to get the number of previous
        // samples
        str.print("    nSamp = floor((_t - (");
        p.print(getOffset(), str, indent);
        str.print(")) / (");
        p.print(getInterval(), str, indent);
        str.print("));\n");
        str.format("%sjmi_min_time_event(%s, 1, 0, ", indent, res);
        str.print("(nSamp + 1.0) * (");
        p.print(getInterval(), str, indent);
        str.print(") + (");
        p.print(getOffset(), str, indent);
        str.println("));");
/*----*//*
        str.print("printf(\"Hopp2: %12.12f %12.12f %12.12f %12.12f\\n\",_t,nextTimeEventTmp,nSamp,");
        str.print("(_t-");
        p.print(getOffset(), str, indent);
        str.print(")/(");
        p.print(getInterval(), str, indent);
        str.print("));\n");

*//*---*/
        str.print("  }\n");
        super.genTempFree_C(p, str, indent);
    }

	public void FRealVariable.genStartAttributeResidual_C(CodePrinter p, CodeStream str, String indent, Enumerator enumerator) {
		p.printPreSteps(this, str, indent);
		if (!(this instanceof FDerivativeVariable)) {
			str.print(indent + "(*res)[" + enumerator.next() + "] = ");
			if (startAttributeSet()) {
				if (myOptions().getBooleanOption("enable_variable_scaling")) {
					str.print("(");
					p.print(startAttributeExp(), str, "");
					str.print(")");
					str.print("/sf(");
					str.print(valueReference());
					str.print(")");
				} else {
					p.print(startAttributeExp(), str, "");
				}
			} else {
				str.print("0.0");
			}
			str.print(" - ");
			str.print(name_C());
			str.print(";\n");
		}
		p.printPostSteps(this, str, indent);
	}
	
    public void FExp.genRelExpKind(CodeStream str) {
        throw new UnsupportedOperationException();
    }

    @Override
    public void FDelayExp.genRelExpKind(CodeStream str) {
        str.print(FRelExp.GEQ_C);
        str.print(", ");
        str.print(FRelExp.GEQ_C);
    }

    @Override
    public void FSpatialDistExp.genRelExpKind(CodeStream str) {
        str.print(FRelExp.GEQ_C);
    }

    @Override
    public void FRelExp.genRelExpKind(CodeStream str) {
    	str.print(kindString());
    }

    public void FRelExp.genRelExpKindPhased(CodeStream str) {
        str.print(kindStringPhased());
    }

    public static String FRelExp.LT_C  = "JMI_REL_LT";
    public static String FRelExp.LEQ_C = "JMI_REL_LEQ";
    public static String FRelExp.GT_C  = "JMI_REL_GT";
    public static String FRelExp.GEQ_C = "JMI_REL_GEQ";

    syn String FRelExp.kindString() = "-1";
    eq FLtExp.kindString()  = FRelExp.LT_C;
    eq FLeqExp.kindString() = FRelExp.LEQ_C;
    eq FGtExp.kindString()  = FRelExp.GT_C;
    eq FGeqExp.kindString() = FRelExp.GEQ_C;

    syn String FRelExp.kindStringPhased() = kindString();
    eq FLtExp.kindStringPhased()  = FRelExp.LEQ_C;
    eq FLeqExp.kindStringPhased() = FRelExp.LT_C;
    eq FGtExp.kindStringPhased()  = FRelExp.GEQ_C;
    eq FGeqExp.kindStringPhased() = FRelExp.GT_C;

    /**
     * Convert to a string represenation to use in C source files.
     * 
     * @return Representation of value for C files.   
     */
	public String CValue.cCodeValue() {
		return toString();
	}

    @Override
    public String CValueBoolean.cCodeValue() {
        return ASTNode.boolValue_C(value);
    }

    @Override
	public String CValueEnum.cCodeValue() {
		return Integer.toString(intValue());
	}

    public void FVariable.genStartValue_C(CodePrinter p, CodeStream str, String indent) {
        p.printPreSteps(this, str, indent);
        FExp exp = useBindingExpAsStart() ? getBindingExp() : startAttributeExp();
        boolean noExp = exp == null;
        if (noExp)
            setBindingExp(exp = type().zeroLiteral());
        genAssignment_C(p, str, indent, name_C(), exp, false);
        if (noExp)
            setBindingExpOpt(new Opt());
        p.printPostSteps(this, str, indent);
    }

    public void FVariable.genAssignment_C(CodePrinter p, CodeStream str, String indent, String name, FExp right,
            boolean neg) {
        str.print(indent);
        if (isString()) {
             str.print("JMI_ASG(STR_Z, ");
             str.print(name);
             str.print(", ");
        } else {
            str.print(name);
            str.print(" = ");
        }
        if (neg) {
            str.print("-");
        }
        str.print("(");
        p.print(right, str, "");
        str.print(")");
        if (isReal() && myOptions().getBooleanOption("enable_variable_scaling")) {
            str.print("/sf(");
            str.print(valueReference());
            str.print(")");
        }
        if (isString()) {
            str.print(")");
        }
        str.print(";\n");
    }

	public void BLT.genOdeDerivativeBlocks(CodePrinter p, CodeStream str, String indent) {
		for (AbstractEquationBlock block : this) {
			block.genSolvedInBLT(p, str, indent); 
		}
	}

	public java.util.List<AbstractEquationBlock> BLT.getAllBlocks() {
		return this;
	}

	public void BLT.genVarDecls(CodePrinter p, CodeStream str, String indent) {
		for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genVarDecls(p, str, indent);
		}
	}

    @Override
	public void StructuredBLT.genOdeDerivativeBlocks(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%s/********* Initialize reinits *******/", indent);
        for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genReinitTempInits_C(p, str, indent);
        }
		str.formatln("%s/************* ODE section *********/", indent);
		// Loop over all derivatives
		for (AbstractEquationBlock eb : getOdeBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
		str.formatln("%s/************ Real outputs *********/", indent);
		for (AbstractEquationBlock eb : getRealOutputBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
		str.formatln("%s/****Integer and boolean outputs ***/", indent);
		for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
		str.formatln("%s/**** Other variables ***/", indent);
		for (AbstractEquationBlock eb : getOtherBlocks()) {
			eb.genSolvedInBLT(p, str, indent);
		}
        str.formatln("%s/********* Write back reinits *******/", indent);
        for (AbstractEquationBlock eb : getAllBlocks()) {
            eb.genReinitWritebacks_C(p, indent, str);
        }
	}

    @Override
    public void DynamicStateBLT.genOdeDerivativeBlocks(CodePrinter p, CodeStream str, String indent) {
        DynamicStateSet lastSet = null;
        int i = 0;
        for (FVariable state : states()) {
            DynamicStateSet set = state.dynamicStateSet();
            if (lastSet != set) {
                i = 0;
                lastSet = set;
            } else {
                i++;
            }
            str.formatln("%s%s = %s;", indent, state.name_C(), set.getStateVars()[i].name_C());
        }
        super.genOdeDerivativeBlocks(p, str, indent);
        lastSet = null;
        i = 0;
        for (FVariable algebraic : algebraics()) {
            DynamicStateSet set = algebraic.dynamicStateSet();
            if (lastSet != set) {
                i = 0;
                lastSet = set;
            } else {
                i++;
            }
            str.formatln("%s%s = %s;", indent, set.getAlgebraicVars()[i].name_C(), algebraic.name_C());
        }
    }
	

    syn int DynamicStateSet.id_C() = id() - 1;

    public void DynamicStateSet.genDSCoefficientsFuncName_C(CodePrinter p, CodeStream str, String indent) {
        str.print("ds_coefficients");
        str.format("_%d", id_C());
    }

    public void DynamicStateManager.genDynamicStateAddCall_C(CodePrinter p, CodeStream str, String indent) {
        for (DynamicStateSet set : getSets())
            set.genDynamicStateAddCall_C(p, str, indent);
    }

    public void DynamicStateSet.genDynamicStateAddCall_C(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%s{", indent);
        String innerIndent = p.indent(indent);
        str.formatln("%sint* ds_var_value_refs = calloc(%d, sizeof(int));", innerIndent, numVars());
        str.formatln("%sint* ds_state_value_refs = calloc(%d, sizeof(int));", innerIndent, numStates());
        str.formatln("%sint* ds_algebraic_value_refs = calloc(%d, sizeof(int));", innerIndent, numAlgebraics());
        int i = 0;
        for (FVariable var : fVars()) {
            str.formatln("%sds_var_value_refs[%d] = %d; /* %s */", innerIndent, i, var.valueReference(), var.name());
            i++;
        }
        i = 0;
        for (FVariable var : getStateVars()) {
            str.formatln("%sds_state_value_refs[%d] = %d; /* %s */", innerIndent, i, var.valueReference(), var.name());
            i++;
        }
        i = 0;
        for (FVariable var : getAlgebraicVars()) {
            str.formatln("%sds_algebraic_value_refs[%d] = %d; /* %s */", innerIndent, i, var.valueReference(), var.name());
            i++;
        }
        str.format("%sjmi_dynamic_state_add_set(*jmi, %d, %d, %d, ds_var_value_refs, ds_state_value_refs, ds_algebraic_value_refs, ", innerIndent, id_C(), numVars(), numStates());
        genDSCoefficientsFuncName_C(p, str, indent);
        str.println(");");
        str.formatln("%sfree(ds_var_value_refs);", innerIndent);
        str.formatln("%sfree(ds_state_value_refs);", innerIndent);
        str.formatln("%sfree(ds_algebraic_value_refs);", innerIndent);
        str.formatln("%s}", indent);
    }

    public void DynamicStateManager.genDynamicStateCoefficients_C(CodePrinter p, CodeStream str, String indent) {
        for (DynamicStateSet set : getSets())
            set.genDynamicStateCoefficients_C(p, str, indent);
    }

    public void DynamicStateSet.genDynamicStateCoefficients_C(CodePrinter p, CodeStream str, String outerIndent) {
        str.format("%sstatic void ", outerIndent);
        String indent = p.indent(outerIndent);
        genDSCoefficientsFuncName_C(p, str, indent);
        str.println("(jmi_t* jmi, jmi_real_t* res) {");
        for (DynamicStateCoefficient coff : getCoefficients())
            p.printVarDecls(coff, str, indent);
        str.format("%smemset(res, 0, %d * sizeof(jmi_real_t));\n", indent, numAlgebraics() * numVars());
        for (DynamicStateCoefficient coff : getCoefficients()) {
            p.printPreSteps(coff, str, indent);
            str.format("%sres[%d] = ", indent, coff.getEquation() + numAlgebraics() * coff.getVariable());
            p.print(coff, str, indent);
            str.println(";");
            p.printPostSteps(coff, str, indent);
        }
        
        str.formatln("%s}", outerIndent);
        str.println();
    }
}
