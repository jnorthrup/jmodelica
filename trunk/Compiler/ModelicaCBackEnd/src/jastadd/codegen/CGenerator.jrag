
/*
Copyright (C) 2009 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/** \file CGenerator.java
*  \brief CGenerator class.
*/

import java.io.*;

public class CGenerator extends GenericGenerator {
	
	protected static final String INDENT = "    ";
	
	/**
	 * C: external function includes
	 */
	public class DAETag_C_externalFuncIncludes extends DAETag {
		
		public DAETag_C_externalFuncIncludes(AbstractGenerator myGenerator, FClass fclass) {
			super("external_func_includes", myGenerator, fclass);
		}
		
		public void generate(CodeStream genPrinter) {
			for (String incl : fclass.externalIncludes()) 
				genPrinter.println(incl);
		}
	}

	/**
	 * C: scaling_method
	 */
	public class DAETag_C_scalingMethod extends DAETag {
		
		public DAETag_C_scalingMethod(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_scaling_method", myGenerator, fclass);
		}
	
		public void generate(CodeStream genPrinter) {
			if (fclass.root().options.getBooleanOption("enable_variable_scaling")) {
				genPrinter.print("JMI_SCALING_VARIABLES");
			} else {
				genPrinter.print("JMI_SCALING_NONE");
			}
		}
	
	}
	
	/**
	 * Base class for tags generating an array and the size of the array.
	 */
	public abstract class DAEArrayTag<T extends ASTNode> extends DAETag {
	    
	    private String varName;
	    private String nullValue;
	    private String type;
        
        public DAEArrayTag(String name, AbstractGenerator myGenerator, FClass fclass, 
                String varName, String type, String nullValue) {
            super(name, myGenerator, fclass);
            this.varName = varName;
            this.type = type;
            this.nullValue = nullValue;
        }
        
        public void generate(CodeStream genPrinter) {
            Collection<T> elems = elements();
            int n = elems.size();
            genPrinter.format("static const int N_%s = %d;\n", varName, n);
            genPrinter.format("static const %s DAE_%s[] = { ", type, varName);
            if (n == 0) {
                genPrinter.print(nullValue);
            } else {
                boolean first = true;
                for (T e : elems) {
                    if (first)
                        first = false;
                    else
                        genPrinter.print(", ");
                    generateFor(e, genPrinter);
                }
            }
            genPrinter.print(" };");
        }
        
        protected abstract Collection<T> elements();
        
        protected abstract void generateFor(T e, CodeStream genPrinter);
	    
	}

	/**
	 * C: relational operator kind, <, >, <=, <=
	 */
	public class DAETag_C_initial_relations extends DAEArrayTag<FRelExp> {
		
		public DAETag_C_initial_relations(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_initial_relations", myGenerator, fclass, "initial_relations", "int", "-1");
		}
        
        protected Collection<FRelExp> elements() {
            return fclass.relExpInInitialEquations();
        }
        
        protected void generateFor(FRelExp e, CodeStream genPrinter) {
            e.genRelExpKind(genPrinter);
        }
	
	}

	/**
	 * C: relational operator kind, <, >, <=, <=
	 */
	public class DAETag_C_relations extends DAEArrayTag<FRelExp> {
		
		public DAETag_C_relations(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_relations", myGenerator, fclass, "relations", "int", "-1");
		}
        
        protected Collection<FRelExp> elements() {
            return fclass.relExpInEquations();
        }
        
        protected void generateFor(FRelExp e, CodeStream genPrinter) {
            e.genRelExpKind(genPrinter);
        }
	
	}

    /**
     * C: nominal values
     */
    public class DAETag_C_nominals extends DAEArrayTag<FRealVariable> {
        
        public DAETag_C_nominals(AbstractGenerator myGenerator, FClass fclass) {
            super("C_DAE_nominals", myGenerator, fclass, "nominals", "jmi_real_t", "0.0");
        }
        
        protected Collection<FRealVariable> elements() {
            return fclass.differentiatedRealVariables();
        }
        
        protected void generateFor(FRealVariable e, CodeStream genPrinter) {
            genPrinter.print(StrictMath.abs(e.nominalAttribute()));
        }
    
    }

	
	/**
	 * C: equation residuals
	 */
	public class DAETag_C_equationResiduals extends DAETag {
		
		public DAETag_C_equationResiduals(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_equation_residuals", myGenerator, fclass);
			addOptions("generate_dae");
		}
	
		public void generate(CodeStream genPrinter) {
			for (FAbstractEquation e : fclass.equations()) 
				e.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			Enumerator enumerator = new Enumerator();
			for (FAbstractEquation e : fclass.equations())
				e.genResidual_C(ASTNode.printer_C, genPrinter, INDENT, enumerator, null, null);
		}
	
	}

	/**
	 * C: event indicator residuals in equations
	 */
	public class DAETag_C_eventIndicatorResiduals extends DAETag {
		
		public DAETag_C_eventIndicatorResiduals(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_event_indicator_residuals", myGenerator, fclass);
		}
	
		public void generate(CodeStream genPrinter) {
			if (!fclass.onlyInitBLT()) {
				for (FRelExp e : fclass.relExpInEquations()) 
					e.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
				Enumerator enumerator = new Enumerator();
				for (FRelExp e : fclass.relExpInEquations())
					e.genResidual_C(ASTNode.printer_C, genPrinter, INDENT, enumerator);
			} else {
				genPrinter.print("  model_init_R0(jmi, res);\n");
			}
		}
	
	}

	/**
	 * C: initial equation residuals
	 */
	public class DAETag_C_initialEquationResiduals extends DAETag {
		
		public DAETag_C_initialEquationResiduals(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_initial_equation_residuals", myGenerator, fclass);
            addOptions("generate_dae");
		}
	
		public void generate(CodeStream genPrinter) {
		    CodePrinter printer = ASTNode.printer_C.initialSystemPrinter();
			for (FAbstractEquation e : fclass.equations()) 
				e.genVarDecls_C(printer, genPrinter, INDENT);
			for (FAbstractEquation e : fclass.initialEquations()) 
				e.genVarDecls_C(printer, genPrinter, INDENT);
			Enumerator enumerator = new Enumerator();
			for (FAbstractEquation e : fclass.equations())
				e.genResidual_C(printer, genPrinter, INDENT, enumerator, null, null);
			for (FAbstractEquation e : fclass.initialEquations())
				e.genResidual_C(printer, genPrinter, INDENT, enumerator, null, null);
		}	
	}

	/**
	 * C: event indicator residuals in initial equations
	 */
	public class DAETag_C_initialEventIndicatorResiduals extends DAETag {
		
		public DAETag_C_initialEventIndicatorResiduals(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_initial_event_indicator_residuals", myGenerator, fclass);
		}
	
		public void generate(CodeStream genPrinter) {
            CodePrinter printer = ASTNode.printer_C.initialSystemPrinter();
			for (FRelExp e : fclass.relExpInEquations()) 
				e.genVarDecls_C(printer, genPrinter, INDENT);
			for (FRelExp e : fclass.relExpInInitialEquations()) 
				e.genVarDecls_C(printer, genPrinter, INDENT);
			Enumerator enumerator = new Enumerator();
			for (FRelExp e : fclass.relExpInEquations())
				e.genResidual_C(printer, genPrinter, INDENT, enumerator);
			for (FRelExp e : fclass.relExpInInitialEquations())
				e.genResidual_C(printer, genPrinter, INDENT, enumerator);
		}
	}
	
	/**
	 * C: initial guess equation residuals
	 */
	public class DAETag_C_initialGuessEquationResiduals extends DAETag {
		
		public DAETag_C_initialGuessEquationResiduals(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_initial_guess_equation_residuals", myGenerator, fclass);
		}
	
		public void generate(CodeStream genPrinter) {
			for (FRealVariable fv : fclass.realVariables())
				if (!fv.fixedAttribute())
					fv.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			Enumerator enumerator = new Enumerator();
			for (FRealVariable fv : fclass.realVariables())
				if (!fv.fixedAttribute())
					fv.genStartAttributeResidual_C(ASTNode.printer_C, genPrinter, INDENT, enumerator);
		}
	
	}

	/**
	 * C: dependent parameter residuals
	 */
	public class DAETag_C_initialDependentParameterResiduals extends DAETag {
		
		public DAETag_C_initialDependentParameterResiduals(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_initial_dependent_parameter_residuals", myGenerator, fclass);
            addOptions("generate_dae");
		}
	
		public void generate(CodeStream genPrinter) {
			Enumerator enumerator = new Enumerator();
			for (FAbstractEquation e : fclass.getFParameterEquations())
				e.genResidual_C(ASTNode.printer_C, genPrinter, INDENT, enumerator, null, null);
		}
	
	}

	/**
	 * C: dependent parameter assignments
	 */
	public class DAETag_C_initialDependentParameterAssignments extends DAETag {
		
		public DAETag_C_initialDependentParameterAssignments(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_initial_dependent_parameter_assignments", myGenerator, fclass);
		}
	
		public void generate(CodeStream genPrinter) {
			for (FAbstractEquation e : fclass.getFParameterEquations()) 
				e.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			for (FAbstractEquation e : fclass.getFParameterEquations()) 
				e.genAssignment_C(ASTNode.printer_C, genPrinter, INDENT);
            if (!fclass.externalObjectVariables().isEmpty()) {
                genPrinter.print(INDENT + "jmi->dep_extobjs_initialized = 1;\n");
            }
		}
	
	}

	/**
	 * C: macros for C variable aliases
	 */
	public class DAETag_C_variableAliases extends DAETag {
		
		public DAETag_C_variableAliases(AbstractGenerator myGenerator, FClass fclass) {
			super("C_variable_aliases", myGenerator, fclass);
		}
		
		private void generateVar(CodeStream genPrinter, FVariable fv, String offset, int index) {
			genPrinter.print("#define ");
			genPrinter.print(fv.name_C());
			genPrinter.print(" ((*(jmi->z))[jmi->offs_");
			genPrinter.print(offset);
			genPrinter.print("+");
			genPrinter.print(index);
			genPrinter.print("])\n");
		}
		
		private void generateVarList(CodeStream genPrinter, Iterable<? extends FVariable> list, String offset) {
			generateVarList(genPrinter, list, offset, 0);
		}

		private void generateVarList(CodeStream genPrinter, Iterable<? extends FVariable> list, String offset, int index) {
			for (FVariable fv : list)
				generateVar(genPrinter, fv, offset, index++);
		}

		private void generatePreVar(CodeStream genPrinter, FVariable fv, String offset, int index) {
			genPrinter.print("#define ");
			genPrinter.print("pre" + fv.name_C());
			genPrinter.print(" ((*(jmi->z))[jmi->offs_pre_");
			genPrinter.print(offset);
			genPrinter.print("+");
			genPrinter.print(index);
			genPrinter.print("])\n");
		}
		
		private void generatePreVarList(CodeStream genPrinter, Iterable<? extends FVariable> list, String offset) {
			int index = 0;
			for (FVariable fv : list)
				generatePreVar(genPrinter, fv, offset, index++);
		}
		
        private void generateExtObject(CodeStream genPrinter, FVariable fv, int index) {
            genPrinter.print("#define ");
            genPrinter.print(fv.name_C());
            genPrinter.print(" ((jmi->ext_objs)[");
            genPrinter.print(index);
            genPrinter.print("])\n");
        }
        
        private void generateExtObjectList(CodeStream genPrinter, Iterable<? extends FExternalObjectVariable> list) {
            int index = 0;
            for (FExternalObjectVariable fv : list)
                generateExtObject(genPrinter, fv, index++);
        }
	
		public void generate(CodeStream genPrinter) {
			generateVarList(genPrinter, fclass.independentRealConstants(),     "real_ci");
			generateVarList(genPrinter, fclass.dependentRealConstants(),       "real_cd");
			generateVarList(genPrinter, fclass.independentRealParameters(),    "real_pi");
			generateVarList(genPrinter, fclass.dependentRealParameters(),      "real_pd");
			// Handle enums as Integers
			generateVarList(genPrinter, fclass.independentIntegerConstants(),     "integer_ci");
			generateVarList(genPrinter, fclass.independentEnumConstants(),        "integer_ci", fclass.numIndependentIntegerConstants());
			generateVarList(genPrinter, fclass.dependentIntegerConstants(),       "integer_cd");
			generateVarList(genPrinter, fclass.dependentEnumConstants(),          "integer_cd", fclass.numDependentIntegerConstants());
			generateVarList(genPrinter, fclass.independentIntegerParameters(),    "integer_pi");
			generateVarList(genPrinter, fclass.independentEnumParameters(),       "integer_pi", fclass.numIndependentIntegerParameters());
			generateVarList(genPrinter, fclass.dependentIntegerParameters(),      "integer_pd");
			generateVarList(genPrinter, fclass.dependentEnumParameters(),         "integer_pd", fclass.numDependentIntegerParameters());
			generateVarList(genPrinter, fclass.independentBooleanConstants(),     "boolean_ci");
			generateVarList(genPrinter, fclass.dependentBooleanConstants(),       "boolean_cd");
			generateVarList(genPrinter, fclass.independentBooleanParameters(),    "boolean_pi");
			generateVarList(genPrinter, fclass.dependentBooleanParameters(),      "boolean_pd");
			generateVarList(genPrinter, fclass.derivativeVariables(),             "real_dx");
			generateVarList(genPrinter, fclass.differentiatedRealVariables(),     "real_x");
			generateVarList(genPrinter, fclass.realInputs(),                      "real_u");
			generateVarList(genPrinter, fclass.algebraicContinousRealVariables(), "real_w");
			genPrinter.print("#define _time ((*(jmi->z))[jmi->offs_t])\n"); 
			generateVarList(genPrinter, fclass.discreteRealVariables(),           "real_d");
			generateVarList(genPrinter, fclass.discreteIntegerVariables(),        "integer_d");
			generateVarList(genPrinter, fclass.discreteEnumVariables(),           "integer_d");
			generateVarList(genPrinter, fclass.integerInputs(),                   "integer_u");
			generateVarList(genPrinter, fclass.enumInputs(),                      "integer_u");
			generateVarList(genPrinter, fclass.discreteBooleanVariables(),        "boolean_d");
			generateVarList(genPrinter, fclass.booleanInputs(),                   "boolean_u");
			if (fclass.root().options.getBooleanOption("generate_ode")) {
				generatePreVarList(genPrinter, fclass.derivativeVariables(),             "real_dx");
				generatePreVarList(genPrinter, fclass.differentiatedRealVariables(),     "real_x");
				generatePreVarList(genPrinter, fclass.realInputs(),                      "real_u");
				generatePreVarList(genPrinter, fclass.algebraicContinousRealVariables(), "real_w");
				generatePreVarList(genPrinter, fclass.discreteRealVariables(),           "real_d");
				generatePreVarList(genPrinter, fclass.discreteIntegerVariables(),        "integer_d");
				generatePreVarList(genPrinter, fclass.discreteEnumVariables(),           "integer_d");
				generatePreVarList(genPrinter, fclass.integerInputs(),                   "integer_u");
				generatePreVarList(genPrinter, fclass.enumInputs(),                      "integer_u");
				generatePreVarList(genPrinter, fclass.discreteBooleanVariables(),        "boolean_d");
				generatePreVarList(genPrinter, fclass.booleanInputs(),                   "boolean_u");
			}
			generateExtObjectList(genPrinter, fclass.externalObjectVariables());

		}
	}

	/**
	 * Generates code for BLT block residuals
	 */
	/**
	 * C: C functions for the DAE BLT block residuals
	 */
	public class DAETag_C_dae_blocks_residual_functions extends DAETag {
		
		public DAETag_C_dae_blocks_residual_functions(AbstractGenerator myGenerator, FClass fclass) {
			super("C_dae_blocks_residual_functions", myGenerator, fclass);
            addOptions("generate_ode");
		}
		
        @Override
        public boolean isActive() {
            return !fclass.onlyInitBLT() && super.isActive();
        }

		public void generate(CodeStream genPrinter) {
			for (AbstractEquationBlock block : fclass.getDAEStructuredBLT().getAllBlocks())
				block.genBlockResidualFunction_C(ASTNode.blockPrinter_C, genPrinter, "", false);
		}
	}

	/**
	 * Generates code for adding BLT blocks 
	 */
	/**
	 * C: Add the DAE block functions to the JMI struct
	 */
	public class DAETag_C_dae_add_blocks_residual_functions extends DAETag {
		
		public DAETag_C_dae_add_blocks_residual_functions(AbstractGenerator myGenerator, FClass fclass) {
			super("C_dae_add_blocks_residual_functions", myGenerator, fclass);
            addOptions("generate_ode");
		}

        @Override
        public boolean isActive() {
            return !fclass.onlyInitBLT() && super.isActive();
        }

		public void generate(CodeStream genPrinter) {
			if (!CADGenerator.shouldGenerateBlockJacobians(fclass)) {
				for (AbstractEquationBlock block : fclass.getDAEStructuredBLT().getAllBlocks())
					block.genBlockAddCall_C(false, false, ASTNode.printer_C.indent(""), genPrinter, fclass.root().options.getStringOption("nonlinear_solver"));
			}
		}
	}

	/**
	 * Number of DAE blocks
	 */
	/**
	 * C: Number of DAE blocks
	 */
	public class DAETag_C_dae_n_blocks extends DAETag {
		
		public DAETag_C_dae_n_blocks(AbstractGenerator myGenerator, FClass fclass) {
			super("n_dae_blocks", myGenerator, fclass);
		}

        public void generate(CodeStream genPrinter) {
            if (fclass.onlyInitBLT())
                genPrinter.print("0");
            else
                genPrinter.print(fclass.getDAEBLT().getNumLabledBlocks());
        }
	}

	/**
	 * Generates code for BLT block residuals (DAE initialization system)
	 */
	/**
	 * C: C functions for the DAE BLT block residuals
	 */
	public class DAETag_C_dae_init_blocks_residual_functions extends DAETag {
		
		public DAETag_C_dae_init_blocks_residual_functions(AbstractGenerator myGenerator, FClass fclass) {
			super("C_dae_init_blocks_residual_functions", myGenerator, fclass);
            addOptions("generate_ode");
		}

		public void generate(CodeStream genPrinter) {
            CodePrinter printer = ASTNode.blockPrinter_C.initialSystemPrinter();
			for (AbstractEquationBlock block : fclass.getDAEInitBLT())
				block.genBlockResidualFunction_C(printer, genPrinter, "", true); 
		}
	}

	/**
	 * Generates code for adding BLT blocks 
	 */
	/**
	 * C: Add the DAE initialization block functions to the JMI struct
	 */
	public class DAETag_C_dae_init_add_blocks_residual_functions extends DAETag {
		
		public DAETag_C_dae_init_add_blocks_residual_functions(AbstractGenerator myGenerator, FClass fclass) {
			super("C_dae_init_add_blocks_residual_functions", myGenerator, fclass);
            addOptions("generate_ode");
		}

		public void generate(CodeStream genPrinter) {
			if (!CADGenerator.shouldGenerateBlockJacobians(fclass)) {
				for (AbstractEquationBlock block : fclass.getDAEInitBLT())
					block.genBlockAddCall_C(false, true, ASTNode.printer_C.indent(""), genPrinter, fclass.root().options.getStringOption("nonlinear_solver"));
			}
		}
	}

	/**
	 * Number of DAE initialization blocks
	 */
	/**
	 * C: Number of DAE initialization blocks
	 */
	public class DAETag_C_dae_init_n_blocks extends DAETag {
		
		public DAETag_C_dae_init_n_blocks(AbstractGenerator myGenerator, FClass fclass) {
			super("n_dae_init_blocks", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			genPrinter.print(fclass.getDAEInitBLT().getNumLabledBlocks());
		}
	}

	/**
	 * Generates code for computing the guard expressions
	 */
	/**
	 * C: Compute guard expressions ODE
	 */
	public class DAETag_C_ode_guards extends DAETag {
		
		public DAETag_C_ode_guards(AbstractGenerator myGenerator, FClass fclass) {
			super("C_ode_guards", myGenerator, fclass);
			addOptions("generate_ode");
		}

		public void generate(CodeStream genPrinter) {
			if (!fclass.onlyInitBLT()) {
				for (FExp e : fclass.guardExpInEquations()) 
					e.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
				int i=0;
				for (FExp e : fclass.guardExpInEquations()) {
				    genPrinter.print("  _guards(" + i + ") = ");
					e.prettyPrint_C(genPrinter,"");		
					genPrinter.print(";\n");		
					i++;
				}
			} else {
				genPrinter.print("  model_ode_guards_init(jmi);\n");
			}
		}
	}

	/**
	 * Generates code for computing the guard expressions in the initial equations
	 */
	/**
	 * C: Compute guard expressions ODE initialization system
	 */
	public class DAETag_C_ode_guards_init extends DAETag {
		
		public DAETag_C_ode_guards_init(AbstractGenerator myGenerator, FClass fclass) {
			super("C_ode_guards_init", myGenerator, fclass);
            addOptions("generate_ode");
		}

		public void generate(CodeStream genPrinter) {
            CodePrinter printer = ASTNode.printer_C.initialSystemPrinter();
			for (FExp e : fclass.guardExpInInitialEquations()) 
				e.genVarDecls_C(printer, genPrinter, INDENT);
			int i=0;
			for (FExp e : fclass.guardExpInInitialEquations()) {
			    genPrinter.print("  _guards_init(" + i + ") = ");
				e.prettyPrint_C(printer, genPrinter,"");
				genPrinter.print(";\n");
				i++;
			}
		}
	}

	/**
	 * Generates code for computation of the nect time event.
	 */
	/**
	 * C: Compute the next time event.
	 */
	public class DAETag_C_ode_time_events extends DAETag {
		
		public DAETag_C_ode_time_events(AbstractGenerator myGenerator, FClass fclass) {
			super("C_ode_time_events", myGenerator, fclass);
            addOptions("generate_ode");
		}

        @Override
        public boolean isActive() {
            return !fclass.onlyInitBLT() && super.isActive();
        }

		public void generate(CodeStream genPrinter) {
			for (FSampleExp e : fclass.samplers()) 
				e.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			genPrinter.print("  jmi_real_t nextTimeEvent;\n");
			genPrinter.print("  jmi_real_t nextTimeEventTmp;\n");				
			genPrinter.print("  jmi_real_t nSamp;\n");	
			genPrinter.print("  nextTimeEvent = JMI_INF;\n");
			
			
			/*
				There are three cases to consider for each sampler:
				 1) The current time is (surely) before the offset of 
				    the sampler. In this case, the next time event occurs
				    at time offset.
				 2) The current time is a sample instant of the sampler
				    in which case next time event is the next sample
				    instant.
				 3) If neither of the above holds true, then the current
				    time is in between two sample instants of the sampler.
				    In this case, the next time event is the next sample
				    instant.
			
			*/
			
//			genPrinter.print("  printf(\"sample function called at time %f\\n\",_t);\n");	
			for (FSampleExp s : fclass.samplers()) {
				genPrinter.print("  nextTimeEventTmp = JMI_INF;\n");
				// Case 1: time is before offset 
				genPrinter.print("  if (SURELY_LT_ZERO(_t - (");
				s.getOffset().prettyPrint_C(genPrinter,"");
				genPrinter.print("))) {\n");
				genPrinter.print("    nextTimeEventTmp = ");
				s.getOffset().prettyPrint_C(genPrinter,"");
				genPrinter.print(";\n");
				//genPrinter.print("printf(\"Hepp: %f %f\\n\",_t,nextTimeEventTmp);\n");
			    genPrinter.print("  } ");	
			    // Case 2: we are at a sample			    					
				genPrinter.print(" else if (ALMOST_ZERO(jmi_dremainder(_t - (");
				s.getOffset().prettyPrint_C(genPrinter,"");
				genPrinter.print("), ");
				s.getInterval().prettyPrint_C(genPrinter,"");
				genPrinter.print("))) {\n");
				// nSamp should be almost an integer - round to get it exact
				genPrinter.print("    nSamp = jmi_dround((_t - (");
			    s.getOffset().prettyPrint_C(genPrinter,"");
			    genPrinter.print(")) / (");
			    s.getInterval().prettyPrint_C(genPrinter,"");
				genPrinter.print("));\n");
				genPrinter.print("    nextTimeEventTmp = (nSamp + 1.0) * (");
				s.getInterval().prettyPrint_C(genPrinter,"");
				genPrinter.print(") + (");
			    s.getOffset().prettyPrint_C(genPrinter,"");
			    genPrinter.print(");\n");
/*----*//*
					genPrinter.print("printf(\"Hopp: %12.12f %12.12f %12.12f %12.12f\\n\",_t,nextTimeEventTmp,nSamp,");
					genPrinter.print("(_t-");
				    s.getOffset().prettyPrint_C(genPrinter,"");
				    genPrinter.print(")/(");
				    s.getInterval().prettyPrint_C(genPrinter,"");
					genPrinter.print("));\n");

*//*---*/
			    genPrinter.print("  } ");

				// Case 3: Neither of the above: in between samples
				genPrinter.print(" else if (SURELY_GT_ZERO(jmi_dremainder(_t - (");
				s.getOffset().prettyPrint_C(genPrinter,"");
				genPrinter.print("), ");
				s.getInterval().prettyPrint_C(genPrinter,"");
				genPrinter.print("))) {\n");
				// User the floor function to get the number of previous
				// samples
				genPrinter.print("    nSamp = floor((_t - (");
			    s.getOffset().prettyPrint_C(genPrinter,"");
			    genPrinter.print(")) / (");
			    s.getInterval().prettyPrint_C(genPrinter,"");
				genPrinter.print("));\n");
				genPrinter.print("    nextTimeEventTmp = (nSamp + 1.0) * (");
				s.getInterval().prettyPrint_C(genPrinter,"");
				genPrinter.print(") + (");
			    s.getOffset().prettyPrint_C(genPrinter,"");
			    genPrinter.print(");\n");
/*----*//*
					genPrinter.print("printf(\"Hopp2: %12.12f %12.12f %12.12f %12.12f\\n\",_t,nextTimeEventTmp,nSamp,");
					genPrinter.print("(_t-");
				    s.getOffset().prettyPrint_C(genPrinter,"");
				    genPrinter.print(")/(");
				    s.getInterval().prettyPrint_C(genPrinter,"");
					genPrinter.print("));\n");

*//*---*/
			    genPrinter.print("  }\n ");


			    genPrinter.print("  if (nextTimeEventTmp<nextTimeEvent) {\n");
			    genPrinter.print("    nextTimeEvent = nextTimeEventTmp;\n");
			    genPrinter.print("  }\n");				    						
			}
//			genPrinter.print("printf(\"Happ: %12.12f\\n\",nextTimeEvent);\n");

			genPrinter.print("  *nextTime = nextTimeEvent;\n");
		}
	}

	/**
	 * Generates code for solving the BLT blocks
	 */
	/**
	 * C: Compute derivatives of the ODE
	 */
	public class DAETag_C_ode_derivatives extends DAETag {
		
		public DAETag_C_ode_derivatives(AbstractGenerator myGenerator, FClass fclass) {
			super("C_ode_derivatives", myGenerator, fclass);
            addOptions("generate_ode");
		}

		public void generate(CodeStream genPrinter) {
			if (fclass.onlyInitBLT()) {
				genPrinter.print(INDENT + "ef = model_ode_initialize(jmi);\n");
			} else {
				fclass.getDAEStructuredBLT().genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
				genPrinter.print(INDENT + "model_ode_guards(jmi);\n");
				fclass.getDAEStructuredBLT().genOdeDerivativeBlocks(genPrinter);
			}
		}
	}

	/**
	 * Generates code for solving the BLT blocks in the initialization system
	 */
	/**
	 * C: Solve the initialization system
	 */
	public class DAETag_C_ode_initialization extends DAETag {
		
		public DAETag_C_ode_initialization(AbstractGenerator myGenerator, FClass fclass) {
			super("C_ode_initialization", myGenerator, fclass);
            addOptions("generate_ode");
		}

		public void generate(CodeStream genPrinter) {
            CodePrinter printer = ASTNode.printer_C.initialSystemPrinter();
			fclass.getDAEInitBLT().genVarDecls_C(printer, genPrinter, INDENT);
			genPrinter.print(INDENT + "model_ode_guards(jmi);\n");
			for (AbstractEquationBlock block : fclass.getDAEInitBLT())
				block.genBlock_C(printer, genPrinter, printer.indent(""), true);
		}
	}

	/**
	 * Generates code for solving the BLT blocks for computing the outputs
	 */
	/**
	 * C: Compute the ODE outputs
	 */
	public class DAETag_C_ode_outputs extends DAETag {
		
		public DAETag_C_ode_outputs(AbstractGenerator myGenerator, FClass fclass) {
			super("C_ode_outputs", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
		}
	}
	
	/**
	 * Generates headers for Modelica functions.
	 */
	/**
	 * C: C function headers representing Modelica functions
	 */
	public class DAETag_C_function_headers extends DAETag {
		
		public DAETag_C_function_headers(AbstractGenerator myGenerator, FClass fclass) {
			super("C_function_headers", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			for (FFunctionDecl func : fclass.getFFunctionDecls())
				func.genHeader_C(genPrinter, "");
		}
	}
	
	/**
	 * Generates definitions for Modelica functions.
	 */
	/**
	 * C: C functions representing Modelica functions
	 */
	public class DAETag_C_functions extends DAETag {
		
		public DAETag_C_functions(AbstractGenerator myGenerator, FClass fclass) {
			super("C_functions", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			for (FFunctionDecl func : fclass.getFFunctionDecls())
				func.prettyPrint_C(genPrinter, "");
		}
	}
	
	/**
	 * Generates structs for Modelica records.
	 */
	/**
	 * C: C structs representing Modelica records
	 */
	public class DAETag_C_records extends DAETag {
		
		public DAETag_C_records(AbstractGenerator myGenerator, FClass fclass) {
			super("C_records", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			for (FRecordDecl rec : fclass.getFRecordDecls())
				rec.prettyPrint_C(genPrinter, "");
		}
	}
	
	/**
	 * Generates string representations of enumeration literals.
	 */
	/**
	 * C: string representations of enumeration literals
	 */
	public class DAETag_C_enums_strings extends DAETag {
		
		public DAETag_C_enums_strings(AbstractGenerator myGenerator, FClass fclass) {
			super("C_enum_strings", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			for (FEnumDecl e : fclass.getFEnumDecls())
				e.prettyPrint_C(genPrinter, "");
		}
	}
	
	/**
	 * Generates wrappers for Modelica functions for exporting in a shared library.
	 */
	/**
	 * C: C functions wrapping internal representation of Modelica functions
	 */
	public class DAETag_C_export_functions extends DAETag {
		
		public DAETag_C_export_functions(AbstractGenerator myGenerator, FClass fclass) {
			super("C_export_functions", myGenerator, fclass);
            addOptions("export_functions");
		}

		public void generate(CodeStream out) {
			for (FFunctionDecl func : fclass.getFFunctionDecls())
				if (func.hasExportWrapper_C())
					func.exportWrapper_C(out, "");
		}
	}
	
	/**
	 * Generates export wrappers for groups of Modelica functions with the same signature.
	 * 
	 * Allows less functions to be imported from resulting shared library. 
	 * Requires $C_export_functions$, and must be after it.
	 */
	/**
	 * C: C functions wrapping groups of export function with same signature
	 */
	public class DAETag_C_export_wrappers extends DAETag {
		
		public DAETag_C_export_wrappers(AbstractGenerator myGenerator, FClass fclass) {
			super("C_export_wrappers", myGenerator, fclass);
            addOptions("export_functions_vba");
		}

		public void generate(CodeStream out) {
			// TODO: refactor out parts not specific to VBA to make it 
			//       easier to support other platforms with special needs
			int i = 0;
			String ind = ASTNode.printer_C.indent("");
			for (ArrayList<FFunctionDecl> grp : fclass.exportWrapperGroups()) {
				FFunctionDecl first = grp.get(0);
				String type = first.exportWrapperType_C();
				String name = "select_vba_" + (++i);
				
				out.format("char* %s_names[] = { ", name);
				String fmt = "\"%s\"";
				for (FFunctionDecl f : grp) {
					out.format(fmt, f.getFQName().nameUnderscore());
					fmt = ", \"%s\"";
				}
				out.print(" };\n");
				
				out.format("int %s_lengths[] = { ", name);
				fmt = "%d";
				for (FFunctionDecl f : grp) {
					out.format(fmt, f.getFQName().nameUnderscore().length());
					fmt = ", %d";
				}
				out.print(" };\n");
				
				out.format("%s (*%s_funcs[])(", type, name);
				first.exportWrapperArgumentTypeDecl_C(out);
				out.print(") = { ");
				fmt = "*%s";
				for (FFunctionDecl f : grp) {
					out.format(fmt, f.funcNameExportWrapper());
					fmt = ", *%s";
				}
				out.print(" };\n");
				
				String sep = first.myInputs().isEmpty() ? "" : ", "; 
				out.format("DllExport %s __stdcall %s(char* name%s", type, name, sep);
				first.exportWrapperArgumentDecl_C(out);
				out.print(") {\n");
				out.format("%sint i, j;\n", ind);
				out.format("%sfor (i = 0, j = 0; name[i] != 0; i++) \n", ind);
				out.format("%s%swhile (j < %d && i <= %s_lengths[j] && name[i] > %s_names[j][i]) j++;\n", ind, ind, grp.size(), name, name);
				out.format("%sif (j >= %d || strcmp(%s_names[j], name)) return 0;\n", ind, grp.size(), name);
				out.format("%sreturn %s_funcs[j](", ind, name);
				first.exportWrapperArgumentCall_C(out);
				out.print(");\n");
				out.print("}\n\n");
			}
		}
	}

	/**
	 * C: DAE output value references
	 */
	public class DAETag_C_outputVrefs extends DAETag {
		
		public DAETag_C_outputVrefs(AbstractGenerator myGenerator, FClass fclass) {
			super("C_DAE_output_vrefs", myGenerator, fclass);
		}
	
		public void generate(CodeStream genPrinter) {

			if (fclass.numOutputs()>0) {
				genPrinter.print("static const int Output_vrefs[" + 
					fclass.numOutputs() + "] = {");		

				int ind = 0;
				for (FVariable fv : fclass.outputs()) {
					genPrinter.print(fv.valueReference());
					if (ind < fclass.numOutputs()-1) {
						genPrinter.print(",");
					}	
					ind++;
				}		
				genPrinter.print("};\n");
			} else {
				genPrinter.print("static const int Output_vrefs[1] = {-1};");
			} 
		}	
	}

	/**
	 * Generates MODEL_IDENTIFIER.
	 */
	/**
	 * C: Model identifier
	 */
	public class DAETag_C_model_id extends DAETag {
		
		public DAETag_C_model_id(AbstractGenerator myGenerator, FClass fclass) {
			super("C_model_id", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			genPrinter.print(fclass.nameUnderscore());
		}
	}
	
    /**
     * Generates JM_VERSION.
     */
    /**
     * C: JModelica version
     */
    public class DAETag_C_jmodelica_version extends DAETag {
        
        public DAETag_C_jmodelica_version(AbstractGenerator myGenerator, FClass fclass) {
            super("C_jmodelica_version", myGenerator, fclass);
        }
        
        public void generate(CodeStream genPrinter) {
            genPrinter.print(Version.parseVersion());
        }
    }

	/**
	 * Generates GUID.
	 */
	/**
	 * C: GUID
	 */
	public class DAETag_C_guid extends DAETag {
		
		public DAETag_C_guid(AbstractGenerator myGenerator, FClass fclass) {
			super("C_guid", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			genPrinter.print("\""+fclass.guid()+"\"");
		}
	}

	/**
	 * Generates start values.
	 */
	/**
	 * C: start values
	 */
	public class DAETag_C_set_start_values extends DAETag {
		
		public DAETag_C_set_start_values(AbstractGenerator myGenerator, FClass fclass) {
			super("C_set_start_values", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			for (FVariable fv : fclass.independentConstants()) 
				fv.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			for (FVariable fv : fclass.dependentConstants()) 
				fv.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			for (FVariable fv : fclass.independentParameters()) 
				fv.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			for (FVariable fv : fclass.variables()) 
				fv.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			for (FVariable fv : fclass.discretePreVariables()) 
				fv.genVarDecls_C(ASTNode.printer_C, genPrinter, INDENT);
			
			for (FVariable fv : fclass.independentConstants()) 
				fv.genStartValue_C(INDENT, genPrinter);
			for (FVariable fv : fclass.dependentConstants()) 
				fv.genStartValue_C(INDENT, genPrinter);
			for (FVariable fv : fclass.independentParameters()) 
				fv.genStartValue_C(INDENT, genPrinter);
			genPrinter.print(INDENT + "model_init_eval_parameters(jmi);\n");
			for (FVariable fv : fclass.variables()) 
				fv.genStartValue_C(INDENT, genPrinter);
			for (FVariable fv : fclass.discretePreVariables()) 
				fv.genStartValue_C(INDENT, genPrinter);
			if (!fclass.externalObjectVariables().isEmpty()) 
			    genPrinter.print(INDENT + "jmi->indep_extobjs_initialized = 1;\n");
		}
	}
	
	/**
	 * Generates mapping between runtime option names and value references for the 
	 * associated parameters.
	 */
	/**
	 * C: runtime option name map
	 */
	public class DAETag_C_runtime_option_map extends DAETag {
		
		public DAETag_C_runtime_option_map(AbstractGenerator myGenerator, FClass fclass) {
			super("C_runtime_option_map", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			genPrinter.print("const char *fmi_runtime_options_map_names[] = {\n");
			for (FVariable fv : fclass.runtimeOptionParameters())
				genPrinter.println("    \"" + fv.name() + "\",");
			genPrinter.print("    NULL\n};\n\n");

			genPrinter.print("const int fmi_runtime_options_map_vrefs[] = {\n    ");
			int i = 0;
			for (FVariable fv : fclass.runtimeOptionParameters()) 
				genPrinter.print(fv.valueReference() + ((++i % 10) == 0 ? ",\n    " : ", "));
			genPrinter.print("0\n};\n\n");

			genPrinter.print("const int fmi_runtime_options_map_length = " + fclass.numRuntimeOptionParameters() + ";");
		}
	}
	
	/**
	 * Generates calls to the destructors of all external objects.
	 */
	public class DAETag_C_destruct_external_object extends DAETag {
		
		public DAETag_C_destruct_external_object(AbstractGenerator myGenerator, FClass fclass) {
			super("C_destruct_external_object", myGenerator, fclass);
		}

		public void generate(CodeStream genPrinter) {
			for (FExternalObjectVariable eo : fclass.externalObjectVariables()) {
			    if (eo.hasDestructorCall()) {
    				genPrinter.format("    if (%s != NULL) {\n", eo.name_C());
    				eo.getDestructorCall().prettyPrint_C(genPrinter, "        ");
    				genPrinter.format("        %s = NULL;\n    }\n", eo.name_C());
			    }
			}
		}
	}
	
	/**
	 * \brief Returns the string denoting the beginning of the copyright blurb.
	 */
	protected String startOfBlurb() { return "/*"; }
	
	/**
	 * Constructor.
	 * 
	 * @param expPrinter Printer object used to generate code for expressions.
	 * @param escapeCharacter Escape characters used to decode tags.
	 * @param fclass An FClass object used as a basis for the code generation.
	 */
	public CGenerator(Printer expPrinter, char escapeCharacter,
			FClass fclass) {
		super(expPrinter, escapeCharacter, fclass);
	}
	
	
	
    public class ECETag_external_includes extends ExternalCEvalTag {
        public ECETag_external_includes(AbstractGenerator myGenerator, FClass fClass) {
            super("ECE_external_includes", myGenerator, fClass);
        }
        
        public void generate(CodeStream genPrinter, FExternalStmt ext) {
            String inc = ext.include();
            if (inc != null)
                genPrinter.println(inc);
        }
    }
    
    public class ECETag_record_definitions extends ExternalCEvalTag {
        public ECETag_record_definitions(AbstractGenerator myGenerator, FClass fClass) {
            super("ECE_record_definitions", myGenerator, fClass);
        }
        
        public void generate(CodeStream genPrinter, FExternalStmt ext) {
            for (FRecordDecl rec : ext.usedRecords()) {
                rec.prettyPrint_C(genPrinter, "");
            }
        }
    }
    
    public class ECETag_main extends ExternalCEvalTag {
        public ECETag_main(AbstractGenerator myGenerator, FClass fClass) {
            super("ECE_main", myGenerator, fClass);
        }
        
        public void generate(CodeStream genPrinter, FExternalStmt ext) {
            ext.genSerializeMain_C(genPrinter, "");
        }
    }
}

public class ExternCEvalGenerator extends CGenerator {
    public ExternCEvalGenerator(Printer expPrinter, char escapeCharacter, FClass fclass, FExternalStmt ext) {
        super(expPrinter, escapeCharacter, fclass);
        for (AbstractTag t : tagMap.values())
            if (t instanceof ExternalCEvalTag)
                ((ExternalCEvalTag)t).setExt(ext);
    }
}
