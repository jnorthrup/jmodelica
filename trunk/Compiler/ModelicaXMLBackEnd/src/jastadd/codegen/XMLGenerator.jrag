
/*
Copyright (C) 2009 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/** \file XMLGenerator.java
*  \brief XMLGenerator class.
*/


import java.io.PrintStream;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Set;
import java.util.Stack;


/**
 * A generator class for XML code generation which takes a model described by
 * <FClass> and provides an XML document for the meta-data in the model. Uses a
 * template for the static general structure of tags and an internal class
 * <TagGenerator> for the parts of the XML that are dynamic, that is, may vary
 * depending on the contents of the underlying model.
 * 
 * @see AbstractGenerator
 * 
 */
public class XMLGenerator extends GenericGenerator {
	
	private HashMap<String,String> illegalCharsSub;
	
	/**
	 * Internal class used to generate the model root attributes.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_rootAttributes extends DAETag {
		private static final String df = "yyyy-MM-dd'T'HH:mm:ss";
		
		public DAETag_XML_rootAttributes(AbstractGenerator myGenerator, FClass fclass) {
			super("XML_rootAttributes", "Model attributes.", myGenerator, fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			genPrinter.print("fmiVersion=\"1.0\" ");
			genPrinter.print("modelName=\""+fclass.name()+"\" ");
			genPrinter.print("modelIdentifier=\""+fclass.nameUnderscore()+"\" ");
			genPrinter.print("guid=\"unsupported\" ");
			//genPrinter.print("description=\"String\" ");
			//genPrinter.print("author=\"String\" ");
			//genPrinter.print("version=\"0.0\" ");
			//genPrinter.print("generationTool=\"normalizedString\" ");
			// Todays date for now
			SimpleDateFormat dateformat = new SimpleDateFormat(df);
			genPrinter.print("generationDateAndTime=\""+dateformat.format(new Date())+"\" ");
			genPrinter.print("variableNamingConvention=\"flat\" ");
			genPrinter.print("numberOfContinuousStates=\""+fclass.numDifferentiatedRealVariables()+"\" ");
			genPrinter.print("numberOfEventIndicators=\""+fclass.numEventIndicators()+"\"");
		}
	}
	
	/**
	 * Internal class used to generate roots attributes of the XML document.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_namespaces extends DAETag {
		
		public DAETag_XML_namespaces (AbstractGenerator myGenerator, FClass fclass) {
			super("XML_namespaces","Namespaces definition",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		*/
		
		public void generate(PrintStream genPrinter) {
			
			//XML standard namespace
			String xsiNS = "xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"";
			//extensions' namespaces definitions
			String expNS= "xmlns:exp=\"https://svn.jmodelica.org/trunk/XML/daeExpressions.xsd\"";
			String equNS= "xmlns:equ=\"https://svn.jmodelica.org/trunk/XML/daeEquations.xsd\"";
			String funNS= "xmlns:fun=\"https://svn.jmodelica.org/trunk/XML/daeFunctions.xsd\"";
			String optNS= "xmlns:opt=\"https://svn.jmodelica.org/trunk/XML/daeOptimization.xsd\"";
			
			genPrinter.print(expNS + " " + equNS + " " + funNS + " " + optNS + " " + xsiNS);			
		
		}
	}
		
	/**
	 * Internal class used to generate the unit definitions tag.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_unitDefinitions extends DAETag {
		
		public DAETag_XML_unitDefinitions(
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_unitDefinitions","Unit definitions (optional).",
			  myGenerator,fclass);
		}
				
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			// extract all units and beloning unit definitions
			HashMap<String,HashSet<String>> map = new HashMap<String,HashSet<String>>();
			for(FVariable variable:fclass.allVariables()) {
				if(variable instanceof FRealVariable && ((FRealVariable)variable).unitAttributeSet() && ((FRealVariable)variable).displayUnitAttributeSet()) {
					String attribute = ((FRealVariable)variable).unitAttribute();
					if(map.containsKey(attribute)) {
						HashSet<String> temp=map.get(attribute);
						temp.add(((FRealVariable)variable).displayUnitAttribute());
					} else {
						HashSet<String> set = new HashSet<String>();
						set.add(((FRealVariable)variable).displayUnitAttribute());
						map.put(attribute, set);
					}
				}
			}
			
			//generate code if any units defined
			Set<String> units = map.keySet();
			if(!units.isEmpty()) {
				genPrinter.print("<UnitDefinitions>");
				Iterator<String> it = units.iterator();
				while(it.hasNext()) {
					String unit = it.next();
					genPrinter.print("\n\t\t <BaseUnit unit=\""+unit+"\">");
					HashSet<String> defs = map.get(unit);
					Iterator<String> defsit = defs.iterator();
					while(defsit.hasNext()) {
						genPrinter.print("\n\t\t\t <DisplayUnitDefinition ");
						genPrinter.print("displayUnit=\""+ defsit.next()+"\" ");
						genPrinter.print("gain=\"1\" ");
						genPrinter.print("offset=\"0\"/>");
					}
					genPrinter.print("\n\t\t </BaseUnit>");
				}				
				genPrinter.print("\n\t </UnitDefinitions>");
			}
		}
	}

	/**
	 * Internal class used to generate the type definitions tag.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_typeDefinitions extends DAETag {
		
		public DAETag_XML_typeDefinitions(
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_typeDefinitions","Type definitions (optional).",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
//				genPrinter.print("<TypeDefinitions>");
//				genPrinter.print("\n\t\t TODO (optional element)");
//				genPrinter.print("\n\t </TypeDefinitions>");
		}
	}
	
	/**
	 * Internal class used to generate the default experiment tag.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_defaultExperiment extends DAETag {
		
		public DAETag_XML_defaultExperiment(
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_defaultExperiment","Default experiment (optional).",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
//				genPrinter.print("<DefaultExperiment>");
//				genPrinter.print("\n\t\t TODO (optional element)");
//				genPrinter.print("\n\t </DefaultExperiment>");
		}
	}

	/**
	 * Internal class used to generate the vendor annotations tag.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_vendorAnnotations extends DAETag {
		
		public DAETag_XML_vendorAnnotations(
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_vendorAnnotations","Vendor annotations (optional).",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
//				genPrinter.print("<VendorAnnotations>");
//				genPrinter.print("\n\t\t TODO (optional element)");
//				genPrinter.print("\n\t </VendorAnnotations>");
		}
	}	

	/**
	 * Internal class used to generate the model variables tags.
	 * 
	 * The model variables tags may vary in number and content. Therefore 
	 * the template file can not be used for this part of the XML. Instead, 
	 * all model variable tags are generated dynamically using this tag class.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_modelVariables extends DAETag {
		
		public DAETag_XML_modelVariables(
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_variables","Model variables. (Optional)",
			  myGenerator,fclass);
		}
	
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {			
			for(FVariable variable:fclass.allVariables()) {		
				genPrinter.print("\n\t\t <ScalarVariable ");
				genPrinter.print("name=\""+variable.name()+"\" ");
				genPrinter.print("valueReference=\""+variable.valueReference()+"\" ");
				if(variable.hasFStringComment()) {
					genPrinter.print("description=\"");
					//genPrinter.print("![CDATA[" + variable.getFStringComment().getComment()+"]]"+"\" ");
					genPrinter.print(replaceIllegalChars(variable.getFStringComment().getComment())+"\" ");
				}
				genPrinter.print("variability=\"");
				if(variable.isConstant()) {
					genPrinter.print("constant\" ");
				} else if(variable.isParameter()) {
					genPrinter.print("parameter\" ");
				} else if(variable.isDiscrete()) {
					genPrinter.print("discrete\" ");
				} else {
					//default
					genPrinter.print("continuous\" ");
				}
				genPrinter.print("causality=\"");
				if(variable.isInput()) {
					genPrinter.print("input\" ");
				} else if(variable.isOutput()) {
					genPrinter.print("output\" ");
				} else {
					//default
					genPrinter.print("internal\" ");
				}
                genPrinter.print("alias=\"");
                if(variable.isAlias()) {
                	if(variable.isNegated()) {
                        genPrinter.print("negatedAlias\" ");
                	} else {
                    	genPrinter.print("alias\" ");
                	}
                } else {
                	genPrinter.print("noAlias\"");
                }
                genPrinter.print(">");

				if(variable.isReal()) {
					genPrinter.print("\n\t\t\t <Real ");
					addRealAttributes(genPrinter, (FRealVariable)variable);
					genPrinter.print("/>");					
				} else if(variable.isInteger()) {
					genPrinter.print("\n\t\t\t <Integer ");
					addIntegerAttributes(genPrinter, (FIntegerVariable)variable);
					genPrinter.print("/>");
				} else if(variable.isBoolean()) {
					genPrinter.print("\n\t\t\t <Boolean ");
					addBooleanAttributes(genPrinter, (FBooleanVariable)variable);
					genPrinter.print("/>");
				} else if(variable.isString()) {
					genPrinter.print("\n\t\t\t <String ");
					addStringAttributes(genPrinter, (FStringVariable)variable);
					genPrinter.print("/>");
				} else if(false) {
//					TODO: Enumeration variable
				}
				 else {
					//TODO: errorhandling
					System.err.println("Invalid or missing variable type definition");
				}
				
				//direct dependency - not supported
               				
				//is linear?
				Boolean generateFMI = fclass.root().options.getBooleanOption("generate_fmi_xml");
				if(!generateFMI) {
					addLinearInfo(genPrinter, variable);
				
					//variable category
					genPrinter.print("\n\t\t\t <VariableCategory>");
					if(variable.isDerivativeVariable()) {
						genPrinter.print("derivative");
					} else if(variable.isDifferentiatedVariable()) {
						genPrinter.print("state");
					} else if(variable.isDependentConstant()) {
						genPrinter.print("dependentConstant");
					} else if(variable.isIndependentConstant()) {
						genPrinter.print("independentConstant");
					} else if(variable.isDependentParameter()) {
						genPrinter.print("dependentParamenter");
					} else if(variable.isIndependentParameter()) {
						genPrinter.print("independentParameter");
					} else {
						//default is algebraic
						genPrinter.print("algebraic");
					}
					genPrinter.print("</VariableCategory>");
				}
				
				genPrinter.print("\n\t\t </ScalarVariable>");
			}
		}
	}
	
	protected String replaceIllegalChars(String s) {
		Iterator<String> itr = illegalCharsSub.keySet().iterator();
		while(itr.hasNext()) {
			String illegalChar = itr.next();
			if(s.contains(illegalChar)){
				s = s.replace(illegalChar, illegalCharsSub.get(illegalChar));
			}
		}
		return s;
	}
	
	/*
	 * Helper method generating linear variable tag such that it can be overridden in 
	 * OptimicaXMLVariableGenerator.
	 */
	protected void addLinearInfo(PrintStream genPrinter, FVariable variable){
		//isLinear
		genPrinter.print("\n\t\t\t <isLinear>"+variable.isLinear()+"</isLinear>");
	}

	/*
	 * Helper method generating all real attributes.
	 */
	protected void addRealAttributes(PrintStream genPrinter, FRealVariable realvariable) {
		//declaredType
		//genPrinter.print("declaredType=\"String\" ");		
		//quantity
		if(realvariable.quantityAttributeSet()) {
			genPrinter.print("quantity=\""+realvariable.quantityAttribute()+"\" ");
		}
		//unit
		if(realvariable.unitAttributeSet()) {
			genPrinter.print("unit=\""+realvariable.unitAttribute()+"\" ");
		}
		//default display unit
		if(realvariable.displayUnitAttributeSet()) {
			genPrinter.print("displayUnit=\""+realvariable.displayUnitAttribute()+"\" ");
		}		
		//relativeQuantity
		genPrinter.print("relativeQuantity=\"false\" ");
		
		//min
		if(realvariable.minAttributeSet()) {
			genPrinter.print("min=\""+realvariable.minAttribute()+"\" ");
		}
		//max
		if(realvariable.maxAttributeSet()) {
			genPrinter.print("max=\""+realvariable.maxAttribute()+"\" ");
		}
		//nominal
		if (realvariable instanceof FDerivativeVariable) {
			if(((FDerivativeVariable)realvariable).myDifferentiatedVariable().
					nominalAttributeSet()) {
				genPrinter.print("nominal=\""+((FDerivativeVariable)realvariable).
						myDifferentiatedVariable().nominalAttribute()+"\" ");
			}
		} else {
			if(realvariable.nominalAttributeSet()) {
				genPrinter.print("nominal=\""+realvariable.nominalAttribute()+"\" ");
			}
		}
		//start
		if ((realvariable.isDependentParameter() && !realvariable.startAttributeSet()) || realvariable.isIndependentConstant()) {
			genPrinter.print("start=\""+realvariable.getBindingExp().ceval().realValue()+"\" ");
		} else {
			genPrinter.print("start=\""+realvariable.startAttribute()+"\" ");
		}
		// fixed - unsupported
		
	}
	
	/*
	 * Helper method generating all integer attributes.
	 */
	protected void addIntegerAttributes(PrintStream genPrinter, FIntegerVariable integervariable) {
		//declaredType
		//genPrinter.print("declaredType=\"String\" ");		
		//quantity
		if(integervariable.quantityAttributeSet()) {
			genPrinter.print("quantity=\""+integervariable.quantityAttribute()+"\" ");
		}					
		//min
		if(integervariable.minAttributeSet()) {
			genPrinter.print("min=\""+integervariable.minAttribute()+"\" ");
		}
		//max
		if(integervariable.maxAttributeSet()) {
			genPrinter.print("max=\""+integervariable.maxAttribute()+"\" ");
		}
		//start
		if ((integervariable.isDependentParameter() && !integervariable.startAttributeSet()) || integervariable.isIndependentConstant()) {
			genPrinter.print("start=\"" +integervariable.getBindingExp().ceval().intValue() +"\" ");
		} else {
			genPrinter.print("start=\"" +integervariable.startAttribute()+"\" ");
		}
		// fixed - unsupported
	}
	
	/*
	 * Helper method generating all boolean attributes.
	 */
	protected void addBooleanAttributes(PrintStream genPrinter, FBooleanVariable booleanvariable) {
		//declaredType
		//genPrinter.print("declaredType=\"String\" ");
		//start attribute
		if ((booleanvariable.isDependentParameter() && !booleanvariable.startAttributeSet()) || booleanvariable.isIndependentConstant()) {
			genPrinter.print("start=\"" +booleanvariable.getBindingExp().ceval().booleanValue() + "\" ");
		} else {
			genPrinter.print("start=\"" +booleanvariable.startAttribute()+"\" ");
		}
		// fixed - unsupported
	}
	
	/*
	 * Helper class generating all string attributes.
	 */
	protected void addStringAttributes(PrintStream genPrinter, FStringVariable stringvariable) {
		//declaredType
		//genPrinter.print("declaredType=\"String\" ");
		//start attribute
		if ((stringvariable.isDependentParameter() && !stringvariable.startAttributeSet()) || stringvariable.isIndependentConstant()) {
			genPrinter.print("start=\"" +stringvariable.getBindingExp().ceval().stringValue() + "\" ");
		} else if(stringvariable.startAttributeSet()) {
			genPrinter.print("start=\""+stringvariable.startAttribute()+"\" ");
		}
		// fixed - unsupported
	}
		
	/**
	 * Internal class used to generate the tags for parameters binding equations.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_bindingEquations extends DAETag {
		
		public DAETag_XML_bindingEquations (
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_bindingEquations","List of binding equations for parameters",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			Boolean generateEqu = fclass.root().options.getBooleanOption("generate_xml_equations");
			if(generateEqu) {
				genPrinter.println("<equ:BindingEquations>");			
			
				for(FVariable variable:fclass.independentParameters()){
					if(variable.hasBindingExp()){
						FExp expression = variable.getBindingExp();
						genPrinter.println("\t\t<equ:BindingEquation>");
						genPrinter.print("\t\t\t<equ:Parameter>");
						genPrinter.print(variable.name());
						genPrinter.println("</equ:Parameter>");
						genPrinter.println("\t\t\t<equ:BindingExp>");
						expression.prettyPrint_XML(genPrinter,"\t\t\t\t",expression);
						genPrinter.println("\t\t\t</equ:BindingExp>");
						genPrinter.println("\t\t</equ:BindingEquation>");
					}
				}
		
				for(FVariable variable:fclass.dependentParameters()){
					if(variable.hasBindingExp()){
						FExp expression = variable.getBindingExp();
						genPrinter.println("\t\t<equ:BindingEquation>");
						genPrinter.print("\t\t\t<equ:Parameter>");
						genPrinter.print(variable.name());
						genPrinter.println("</equ:Parameter>");
						genPrinter.println("\t\t\t<equ:BindingExp>");
						expression.prettyPrint_XML(genPrinter,"\t\t\t\t",expression);
						genPrinter.println("\t\t\t</equ:BindingExp>");
						genPrinter.println("\t\t</equ:BindingEquation>");
					}
				}
			
				genPrinter.println("\t</equ:BindingEquations>");
			}
		}
	}
	
	
	
	/**
	 * Internal class used to generate the tags for dynamic equations.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_equations extends DAETag {
		
		public DAETag_XML_equations (
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_Equations","List of equations",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			Boolean generateEqu = fclass.root().options.getBooleanOption("generate_xml_equations");
			if(generateEqu){
				genPrinter.println("<equ:DynamicEquations>");			
				for(FAbstractEquation e : fclass.equations())
					e.prettyPrint_XML(genPrinter,"\t\t",e);								
				genPrinter.println("\t</equ:DynamicEquations>");
			}
		}
	}
	

	/**
	 * Internal class used to generate the tags for initial equations.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_initialEquations extends DAETag {
		
		public DAETag_XML_initialEquations (
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_initialEquations","List of initial equations",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			Boolean generateEqu = fclass.root().options.getBooleanOption("generate_xml_equations");
			if(generateEqu) {
				genPrinter.println("<equ:InitialEquations>");			
				for(FAbstractEquation e : fclass.initialEquations())
					e.prettyPrint_XML(genPrinter,"\t\t",e);								
				genPrinter.println("\t</equ:InitialEquations>");
			}
		}
	}
	
	/**
	 * Internal class used to generate the tags for optimization problems
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_Optimization extends DAETag {
		
		public DAETag_XML_Optimization (
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_Optimization","Optimization problem's representation",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			//do nothing
		}
	}
	
	
	/**
	 * Internal class used to generate the tags for user-defined functions declaration.
	 * 
	 * @see DAETag
	 */
	class DAETag_XML_functions extends DAETag {
		
		public DAETag_XML_functions (
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_Functions","Functions Declaration",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			Boolean generateEqu = fclass.root().options.getBooleanOption("generate_xml_equations");
			if(generateEqu) {
				genPrinter.println("<fun:FunctionsList>");			
				for(FFunctionDecl f : fclass.getFFunctionDeclList())
					f.prettyPrint_XML(genPrinter,"\t\t",f);								
				genPrinter.println("\t</fun:FunctionsList>");
			}
		}
	}
	
	/**
	 * Constructor.
	 * 
	 * @param expPrinter Printer object used to generate code for expressions.
	 * @param escapeCharacter Escape characters used to decode tags.
	 * @param fclass An FClass object used as a basis for the code generation.
	 */
	public XMLGenerator(Printer expPrinter, char escapeCharacter,
			FClass fclass) {
		super(expPrinter,escapeCharacter, fclass);
		
		illegalCharsSub=new HashMap<String,String>();
		illegalCharsSub.put("<","&lt;");
		illegalCharsSub.put("&","&amp");
	}
}

/**
 * A helper class to XMLGenerator classes providing start and end tags with the
 * correct amount of tabs. This class will be used in the XML code generation
 * for the parts which are dynamical and therefore can not use a template.
 * 
 */
class TagGenerator {
	private String tabs="";
	private Stack<String> stack;
	private String previous;
	
	/**
	 * Constructor.
	 * 
	 * @param tabstart Number of tabs indent at start.
	 */
	public TagGenerator(int tabstart) {
		stack = new Stack<String>();
		for(int i =0; i<tabstart; i++) {
			tabs=tabs+"\t";
		}
	}
	
	/**
	 * Generates a tag with a certain tagname.
	 * 
	 * The first time the tagname is encountered a start tag is created. The
	 * second time the same tagname is used a matching end tag is created. For
	 * each unique tagname a new start tag is created with one more tab indent.
	 * If start and end tags are encountered immediately after each other they
	 * will be on the same line.
	 * 
	 * @param tagname
	 *            The name of the tag to create.
	 * @return Start or end tag with name set to <tagname>.
	 */
	public String generateTag(String tagname) {
		return generateTag(tagname, false);
	}
	
	public String generateTag(String tagname, boolean isAttributeTag) {
		if(stack.isEmpty() || !stack.peek().equals(tagname.trim())) {
			stack.push(tagname.trim());
			return generateStartTag(tagname, isAttributeTag);
		}else {
			return generateEndTag(stack.pop(), isAttributeTag);
		} 

	}
	
	/**
	 * Generates a start tag with the specified tagname.
	 * 
	 * @param tagname
	 *            The name of the tag for which a start tag should be created.
	 * @return The start tag with name set to <tagname>.
	 */
	private String generateStartTag(String tagname, boolean isAttributeTag) {
		String tag;
		if(isAttributeTag) {
			tag = "\n"+tabs+"<"+tagname+" "; 
		}else {
			tag = "\n"+tabs+"<"+tagname+">";			
		}
		tabs=tabs+"\t";
		previous = tagname;
		return tag;
		
	}
	
	/**
	 * Generates an end tag with the specified tagname.
	 * 
	 * @param tagname
	 *            The name of the tag for which an end tag should be created.
	 * @return The end tag with name set to <tagname>.
	 */
	private String generateEndTag(String tagname, boolean isAttributeTag) {
		String tag;
		tabs=tabs.substring(1);
		if(!previous.equals(tagname)) {
			tag=("\n"+tabs);
		} else {
			tag=("");
		}
		if(isAttributeTag) {
			tag = tag +"/>";
		} else {
			tag=tag+("</"+tagname+">");
		}
		return tag;
	}
}

