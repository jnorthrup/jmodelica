/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.io.BufferedWriter;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.util.Collection;

import org.jmodelica.util.OptionRegistry;

//import beaver.Parser.Exception;

/**
 * 
 * Main compiler class which bundles the tasks needed to compile an Optimica
 * model. This class is an extension of ModelicaCompiler.
 * <p>
 * There are two usages with this class:
 * 	-# Compile in one step either from the command line or by calling the static 
 * method <compileModel> in your own class.
 *	-# Split compilation into several steps by calling the static methods in your
 *  own class.
 *  <p>
 * Use (1) for a simple and compact way of compiling an Optimica model. As a
 * minimum, provide the modelfile name and class name as command line arguments.
 * Optional arguments are XML templates and c template files which are needed
 * for code generation. If any of these are ommitted no code generation will be
 * performed.
 * <p>
 * Example without code generation: <br>
 * <code>org.jmodelica.applications.OptimicaCompiler myModels/models.mo models.model1</code>
 * <p>
 * Example with code generation: <br> 
 * <code>org.jmodelica.applications.OptimicaCompiler myModels/models.mo 
 * models.model1 XMLtemplate1.xml XMLtemplate2.xml XMLtemplate3.xml cppTemplate.cpp</code>
 * <p>
 * Logging can be set with the optional argument -log=i, w or e where:
 *	- -i : log info, warning and error messages 
 *	- -w : log warning and error messages
 *	- -e : log error messages only (default if the log option is not used)
 * <p>
 * Example with log level set to INFO: <br>
 * <code>org.jmodelica.applications.OptimicaCompiler -i myModels/models.mo
 * models.model1</code> <br>
 * The logs will be printed to standard out.
 * <p>
 * 
 * For method (2), the compilation steps are divided into 4 tasks which can be
 * used via the methods:
 *	-# parseModel (source code -> attributed source representation) - ModelicaCompiler
 *	-# instantiateModel (source representation -> instance model) - ModelicaCompiler
 *	-# flattenModel (instance model -> flattened model)
 *	-# generateCode (flattened model -> c code and XML code)
 * 
 * <p>
 * They must be called in this order. Use provided methods in ModelicaCompiler
 * to get/set logging level.
 * 
 */
public class OptimicaCompiler extends ModelicaCompiler{
	
	private String optimicaCTemplatefile=null;
	
	public OptimicaCompiler(OptionRegistry options, String xmlTpl, 
			String xmlValuesTpl, String cTemplatefile, 
			String optimicaCTemplatefile) {
		super(options, xmlTpl, xmlValuesTpl, cTemplatefile);
		this.optimicaCTemplatefile = optimicaCTemplatefile;
	}	
		
	/**
	 * Compiles an Optimica model. A model file name and class must be provided.
	 * Prints an error and returns without completion if, for example, a file 
	 * can not be found or if the parsing fails. Supports multiple model files.
	 * 
	 * @param name
	 *            Array of names of the model files.
	 * @param cl
	 *            The name of the class in the model file to compile.
	 *            
	 * @throws beaver.Parser.Exception If there was an Beaver parsing exception.
	 * @throws CompilerException
	 *             If errors have been found during the parsing, instantiation
	 *             or flattening.
	 * @throws FileNotFoundException
	 *             If the model file can not be found.
	 * @throws IOException
	 *             If there was an error reading the model file. (Beaver
	 *             exception.)
	 * @throws IOException
	 *             If there was an error creating the .mof file.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to parse, instantiate or flatten is not
	 *             found.
	 * 
	 */
	public void compileModel(String name[], String cl) 
	  throws ModelicaClassNotFoundException, CompilerException, FileNotFoundException, IOException, beaver.Parser.Exception {
		log.info("======= Compiling model =======");
		
		// build source tree
		SourceRoot sr = parseModel(name);

		// compute instance tree
		InstClassDecl icd = instantiateModel(sr, cl);
			
		// flattening
		FClass fc = flattenModel(icd);

		// Generate code?
		if (getXMLTpl() != null && getXMLValuesTpl() != null && getCTemplate() != null) 
			generateCode(fc);
		
		log.info("====== Model compiled successfully =======");
	}

	
	/**
	 * \brief Create a new FOptClass object.
	 * @param icd A reference to a instance class - in compiler extensions
	 * it may be useful to be able to extract the kind of class is being
	 * instantiated: model, block etc.

	 */
	protected FClass createFClass(InstClassDecl icd) {
		if (icd.isOptimizationClass()) {
			return new FOptClass();
		} else {
			return new FClass();
		}
	}

	/**
	 * Computes the flattened model representation from a model instance node.
	 * 
	 * @param icd
	 *            A reference to the model instance.
	 * 
	 * @return FOptClass or FClass object representing the flattened model.
	 * 
	 * @throws CompilerException
	 *             If errors have been found during the flattening.
	 * @throws IOException
	 *             If there was an error creating the .mof file.
	 * @throws ModelicaClassNotFoundException
	 *             If the Modelica class to flatten is not found.
	 */
	public FClass flattenModel(InstClassDecl icd) 
			throws CompilerException, ModelicaClassNotFoundException, IOException {
		return super.flattenModel(icd);
	}
	
	/**
	 * \brief Create a new OptimicaXMLGenerator object.
	 */
	protected XMLGenerator createXMLGenerator(FClass fc) {
		if (fc instanceof FOptClass) {
			return new OptimicaXMLGenerator(new PrettyPrinter(), '$', (FOptClass) fc);
		} else {
			return new XMLGenerator(new PrettyPrinter(), '$', fc);
		}
	}
	
	/**
	 * \brief Create a new OptimicaCGenerator object.
	 */
	protected CGenerator createCGenerator(FClass fc) {
		if (fc instanceof FOptClass) {
			return new OptimicaCGenerator(new PrettyPrinter(), '$', (FOptClass) fc);
		} else {
			return new CGenerator(new PrettyPrinter(), '$', fc);
		}
	}

	/**
	 * \brief get the C template. 
	 * 
	 * @param fc A reference to an FClass object. This is convenient in
	 * extensions of ModelicaCompiler that need to distinguish between
	 * different kinds of flattened classes.
	 */
	protected String getCTemplatefile(FClass fc) {
		if (fc instanceof FOptClass) {
			return this.optimicaCTemplatefile;
		} else {
			return this.cTemplatefile;
		}
	}

	protected OptimicaCompiler(String[] args, Hashtable<String, String> programarguments) {
		super("OptimicaCompiler", args, programarguments);
		int arg = programarguments.size();
		if (args.length >= arg+6) {
			optimicaCTemplatefile = args[arg+5];
		} else {
			// set default template
			String filesep = System.getProperty("file.separator");
			String templatepath = System.getenv("JMODELICA_HOME")+filesep+"CodeGenTemplates"+filesep;
			optimicaCTemplatefile = templatepath+"jmi_optimica_template.c";
		}
	}
	
	public static void main(String args[]) {
		// Get any program options set
		Hashtable<String, String> programarguments = extractProgramArguments(args, 0);
		// Create compiler
		OptimicaCompiler oc = new OptimicaCompiler(args, programarguments);
		// Compile model
		oc.compileModelFromCommandLine(args, programarguments);
	}	
}
