/*
    Copyright (C) 2009-2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


%right RPAREN;
%right NOT;
%left AND;
%left OR;
%left LT, LEQ, GT, GEQ, EQ, NEQ;
%left MULT, DIV;
%left PLUS, MINUS;

%header {: // Generated from C:\stuff\workspace\JModelica\Compiler\ModelicaCompilerCasADi/build/modelica/parsers/ModelicaParser.parser
package org.jmodelica.modelica.parser;
 import org.jmodelica.modelica.compiler.*;
 import org.jmodelica.util.AdjustableSymbol;
 import org.jmodelica.util.AbstractAdjustableSymbol;
 import org.jmodelica.util.formatting.FormattingRecorder;
 import org.jmodelica.util.formatting.FormattingType;
 import org.jmodelica.api.problemHandling.Problem;
 import org.jmodelica.api.problemHandling.ProblemSeverity;
 import org.jmodelica.api.problemHandling.ProblemKind;
 import beaver.Parser.Events;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;:};
%embed {: // Generated from C:\stuff\workspace\JModelica\Compiler\ModelicaCompilerCasADi/build/modelica/parsers/ModelicaParser.parser
/**
     * Error reporting class that creates an error message and delegates reporting the 
     * message to a subclass.
     */
    public abstract static class Report extends Events {

        /**
         * Report an error with error message <code>msg</code>.
         */
        protected abstract void report(Problem P);

        /**
         * Creates an error message for when <code>token</code> is found unexpectedly. 
         * Passes the error message to {@link #report(Problem)}.
         * @param token     the unexpected symbol.
         */
        public void syntaxError(Symbol token) {
            
            StringBuilder s = new StringBuilder();
            //s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
            if (token.getId() == Terminals.EOF) {
                s.append("  Unexpected end of file");
            } else if (token.value != null) {
                s.append("   Unexpected token: \"" + token.value + "\"");
            } else if (token.getId()<Terminals.NAMES.length)
                s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
            else 
                s.append("  Syntactic error");
            Problem p = new Problem(fileName, s.toString(), ProblemSeverity.ERROR, ProblemKind.SYNTACTIC,
                    Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()),
                    Symbol.getLine(token.getEnd()), Symbol.getColumn(token.getEnd()));
            
            report(p);
        }

        /**
         * Creates an error message for when the scanner throws an exception.
         * Passes the error message to {@link #report(Problem)}.
         * @param e     the exception.
         */
        public void scannerError(Scanner.Exception e) {
            /*
            StringBuilder s = new StringBuilder(e.getMessage());
            s.append(" at line ");
            s.append(e.line);
            s.append(", column ");
            s.append(e.column);
            */
            Problem p = new Problem(fileName, e.getMessage(), ProblemSeverity.ERROR, ProblemKind.LEXICAL,
                    e.line, e.column, e.line, e.column);
            
            report(p);
        }

        private String fileName = "";

        public void setFileName(String fn) {
            fileName = fn;
        }

    }
    
    /**
     * Error reporting class that throws a {@link ParserException} on an error.
     * Uses error message created by {@link Report}.
     */
    public class AbortingReport extends Report {

        /**
         * Throws a <code>ParserException</code> with <code>msg</code> as the message.
         */
        @Override
        protected void report(Problem p) {
          throw new ParserException(p);
        }

    }

    /**
     * Error reporting class that collects error messages for later retrieval.
     * Uses error message created by {@link Report}.
     */
    public static class CollectingReport extends Report {

        private ArrayList<Problem> errors = new ArrayList<Problem>();

        /**
         * Adds error message <code>msg</code> to list.
         */ 
        @Override
        protected void report(Problem p) {
            errors.add(p);          
        }

        /**
         * Get the list of errors. Returns a reference to the internal list, not a copy.
         * @return a {@link java.util.Collection} with the reported error messages.
         */
        public Collection<Problem> getErrors() {
            return errors;
        }

        /**
         * Reset the list of errors.
         */
        public void resetErrors() {
            errors = new ArrayList<Problem>();
        }

        /**
         * Checks if any errors has been reported.
         * @return <code>true</code> if the list contains any errors.
         */
        public boolean hasErrors() {
            return !errors.isEmpty();
        }

    }

    { report = new AbortingReport(); }  // As default, throw exception on errors.

    /**
     * Set the error reporting class to use.
     * @param report    a subclass of {@link Events} to use for reporting errors.
     */
    public void setReport(Events report) {
        this.report = report;
    }

    public Events getReport() {
        return report;
    }

    private int[] lineBreakMap;

    public void setLineBreakMap(int[] map) {
        lineBreakMap = map;
    }

    private FormattingRecorder<ASTNode<?>> formattingRecorder;

    public void setFormattingRecorder(FormattingRecorder<ASTNode<?>> formattingRecorder) {
        this.formattingRecorder = formattingRecorder;
    }

    public void setFileName(String fn) {
        if (report instanceof Report)
            ((Report) report).setFileName(fn);
    }
    
    Symbol annotationTok = null;
    
    private void adjustStart(Symbol... syms) {
        AdjustableSymbol[] aSyms = new AdjustableSymbol[syms.length];
        for (int i = 0; i < syms.length; i++) {
            /* All symbols involved implements AdjustableSymbol, but since we can't change 
             * Beaver, the Java compiler can't verify that. If any Symbol used doesn't then
             * we want to know that - thus the raw cast. */
            aSyms[i] = (AdjustableSymbol) syms[i];
        }
        if (aSyms.length > 0) {
            aSyms[0].adjustStartOfEmptySymbols(aSyms, 1, 0);
        }
    }
    
    private static class Bool extends AbstractAdjustableSymbol {
        public final boolean value;
        
        public Bool(boolean val) {
            value = val;
        }
    }
    
    private static Bool newTrue() {
        return new Bool(true);
    }
    
    private static Bool newFalse() {
        return new Bool(false);
    }
    
    private static class RedeclareReplaceableHeader extends AbstractAdjustableSymbol {
        public final boolean has_redeclare;
        public final boolean has_each;
        public final boolean has_final;
        
        public RedeclareReplaceableHeader(boolean has_redeclare,
                                          boolean has_each,
                                          boolean has_final) {
            this.has_redeclare = has_redeclare;
            this.has_each = has_each;
            this.has_final = has_final;
        }
    }
    
    private static class TypePrefixes extends AbstractAdjustableSymbol {
        public final Opt<SrcTypePrefixFlow> flow;
        public final Opt<SrcTypePrefixVariability> variability;
        public final Opt<SrcTypePrefixInputOutput> input_output;
        
        public TypePrefixes(Opt<SrcTypePrefixFlow> flow, 
                            Opt<SrcTypePrefixVariability> variability, 
                            Opt<SrcTypePrefixInputOutput> input_output) {
            super(flow, variability, input_output);
            this.flow = flow;
            this.variability = variability;
            this.input_output = input_output;
        }
    }
    
    private static class ConstrClauseAndComment extends AbstractAdjustableSymbol {
        public final Opt<SrcConstrainingClause> constr;
        public final SrcComment comment;
        
        public ConstrClauseAndComment(SrcConstrainingClause constr, 
                                      SrcComment comment) {
            super(constr, comment);
            this.constr = new Opt(constr);
            this.comment = comment;
        }
        
        public ConstrClauseAndComment() {
            this.constr = new Opt();
            this.comment = new SrcComment();
        }
    }:};
%terminals error;
%terminals WITHIN;
%terminals SEMICOLON;
%terminals EQUALS;
%terminals EXTENDS;
%terminals ENUMERATION;
%terminals LPAREN;
%terminals RPAREN;
%terminals COLON;
%terminals COMMA;
%terminals FLOW;
%terminals STREAM;
%terminals DISCRETE;
%terminals PARAMETER;
%terminals CONSTANT;
%terminals INPUT;
%terminals OUTPUT;
%terminals CLASS;
%terminals MODEL;
%terminals BLOCK;
%terminals CONNECTOR;
%terminals EXPANDABLE;
%terminals TYPE;
%terminals PACKAGE;
%terminals FUNCTION;
%terminals RECORD;
%terminals OPERATOR;
%terminals PARTIAL;
%terminals ENCAPSULATED;
%terminals INNER;
%terminals OUTER;
%terminals REDECLARE;
%terminals EACH;
%terminals FINAL;
%terminals REPLACEABLE;
%terminals PUBLIC;
%terminals PROTECTED;
%terminals EQUATION;
%terminals INITIAL_EQUATION;
%terminals ALGORITHM;
%terminals INITIAL_ALGORITHM;
%terminals EXTERNAL;
%terminals STRING;
%terminals CONSTRAINEDBY;
%terminals IMPORT;
%terminals DOTMULT;
%terminals LBRACK;
%terminals RBRACK;
%terminals IF;
%terminals ANNOTATION;
%terminals CONNECT;
%terminals FOR;
%terminals LOOP;
%terminals END_FOR;
%terminals IN;
%terminals WHEN;
%terminals THEN;
%terminals END_WHEN;
%terminals ELSEWHEN;
%terminals END_IF;
%terminals ELSEIF;
%terminals ELSE;
%terminals ASSIGN;
%terminals BREAK;
%terminals RETURN;
%terminals WHILE;
%terminals END_WHILE;
%terminals OR;
%terminals AND;
%terminals NOT;
%terminals LT;
%terminals LEQ;
%terminals GT;
%terminals GEQ;
%terminals EQ;
%terminals NEQ;
%terminals PLUS;
%terminals MINUS;
%terminals DOTPLUS;
%terminals DOTMINUS;
%terminals MULT;
%terminals DIV;
%terminals DOTDIV;
%terminals POW;
%terminals DOTPOW;
%terminals UNSIGNED_NUMBER;
%terminals UNSIGNED_INTEGER;
%terminals TRUE;
%terminals FALSE;
%terminals LBRACE;
%terminals RBRACE;
%terminals TIME;
%terminals END;
%terminals ID;
%terminals DER;
%terminals DOT;
%terminals END_ID;
%typeof import_clause = "SrcImportClause";
%typeof function_call = "SrcFunctionCall";
%typeof string_comment = "SrcStringComment";
%typeof string_comment_opt = "Opt";
%typeof constraining_clause_and_comment = "ConstrClauseAndComment";
%typeof component_list = "List";
%typeof component_decl = "SrcComponentDecl";
%typeof component_decl_no_conditional = "SrcComponentDecl";
%typeof program = "Program";
%typeof if_exp = "SrcIfExp";
%typeof if_equation = "SrcIfEquation";
%typeof enum_literal = "SrcEnumLiteralDecl";
%typeof relation = "SrcExp";
%typeof function_arguments = "SrcFunctionArguments";
%typeof function_arguments_opt = "Opt";
%typeof else_if_clause = "SrcIfClause";
%typeof value_modification = "SrcValueModification";
%typeof value_modification_opt = "Opt";
%typeof multiplicative_exp = "SrcExp";
%typeof access_loc = "SrcAccess";
%typeof function_call_left = "SrcFunctionCallLeft";
%typeof has_partial = "Bool";
%typeof constraining_clause = "SrcConstrainingClause";
%typeof constraining_clause_opt = "Opt";
%typeof exp = "SrcExp";
%typeof access_dot = "SrcDot";
%typeof element = "SrcElement";
%typeof element_opt_list = "List";
%typeof element_list = "List";
%typeof while_stmt = "SrcWhileStmt";
%typeof default_element_list = "SrcDefaultElementList";
%typeof for_clause_e = "SrcForClauseE";
%typeof named_argument = "SrcNamedArgument";
%typeof element_plus = "List";
%typeof type_prefix_variability = "SrcTypePrefixVariability";
%typeof type_prefix_variability_opt = "Opt";
%typeof id_decl = "SrcIdDecl";
%typeof has_encapsulated = "Bool";
%typeof for_in_exp = "SrcExp";
%typeof for_in_exp_opt = "Opt";
%typeof restriction = "SrcRestriction";
%typeof artm_exp = "SrcExp";
%typeof primary = "SrcExp";
%typeof extends_clause = "SrcExtendsClause";
%typeof partial_function_call = "SrcPartialFunctionCall";
%typeof access = "SrcAccess";
%typeof access_opt = "Opt";
%typeof type_prefix_input_output = "SrcTypePrefixInputOutput";
%typeof type_prefix_input_output_opt = "Opt";
%typeof complete_modification = "SrcCompleteModification";
%typeof if_stmt = "SrcIfStmt";
%typeof matrix = "SrcMatrix";
%typeof else_if_equation = "SrcIfWhenElseEquation";
%typeof else_if_equation_opt = "Opt";
%typeof for_index = "SrcForIndex";
%typeof clause_star = "List";
%typeof else_stmts = "SrcElseClause";
%typeof end_decl = "SrcEndDecl";
%typeof when_equation = "SrcWhenEquation";
%typeof class_modification = "SrcClassModification";
%typeof class_modification_opt = "Opt";
%typeof clause = "SrcClause";
%typeof annotation = "SrcAnnotation";
%typeof annotation_opt = "Opt";
%typeof within = "SrcWithin";
%typeof within_opt = "Opt";
%typeof annotation_tok = "Symbol";
%typeof named_argument_id = "SrcAccess";
%typeof pow_exp = "SrcExp";
%typeof has_outer = "Bool";
%typeof function_call_stmt_left_list = "List";
%typeof when_clause = "SrcWhenClause";
%typeof function_arguments_named = "SrcFunctionArguments";
%typeof function_arguments_named_opt = "Opt";
%typeof source_root = "SourceRoot";
%typeof anonymous_short_class = "SrcBaseClassDecl";
%typeof argument_list = "List";
%typeof abstract_equation = "SrcAbstractEquation";
%typeof abstract_equation_opt_list = "List";
%typeof abstract_equation_list = "List";
%typeof argument = "SrcArgument";
%typeof for_index_decl = "SrcForIndexDecl";
%typeof arg_list_p = "List";
%typeof external_function_call = "SrcExternalFunctionCall";
%typeof external_function_call_opt = "Opt";
%typeof simple_expression = "SrcExp";
%typeof class_annotation = "SrcAnnotation";
%typeof class_annotation_opt = "Opt";
%typeof external_language = "SrcExternalLanguage";
%typeof external_language_opt = "Opt";
%typeof function_call_left_list = "List";
%typeof if_clause = "SrcIfClause";
%typeof enum_specification = "SrcEnumComponentClause";
%typeof access_scalar_loc = "SrcAccess";
%typeof else_when_equation = "SrcWhenEquation";
%typeof else_when_equation_opt = "Opt";
%typeof stored_definition = "SrcStoredDefinition";
%typeof subscript = "SrcSubscript";
%typeof named_arguments = "List";
%typeof access_single_array = "SrcArrayAccess";
%typeof external_clause = "SrcExternalClause";
%typeof external_clause_opt = "Opt";
%typeof modification = "SrcModification";
%typeof modification_opt = "Opt";
%typeof unary_exp = "SrcExp";
%typeof conditional_attribute = "SrcConditionalAttribute";
%typeof conditional_attribute_opt = "Opt";
%typeof access_single_scalar = "SrcNamedAccess";
%typeof has_redeclare = "Bool";
%typeof access_scalar_dot = "SrcDot";
%typeof type_prefix_flow = "SrcTypePrefixFlow";
%typeof type_prefix_flow_opt = "Opt";
%typeof base_class_decl = "SrcBaseClassDecl";
%typeof log_exp = "SrcExp";
%typeof subscript_list = "List";
%typeof string_comment_exp = "SrcExp";
%typeof string = "SrcStringLitExp";
%typeof component_clause_in_argument = "SrcComponentClause";
%typeof when_clause_list = "List";
%typeof else_when_clause = "SrcWhenClause";
%typeof extends_clause_short_class = "SrcExtendsClauseShortClass";
%typeof der_expression = "SrcDerExp";
%typeof type_prefixes = "TypePrefixes";
%typeof access_scalar = "SrcAccess";
%typeof has_inner = "Bool";
%typeof access_single = "SrcNamedAccess";
%typeof has_each = "Bool";
%typeof statement = "SrcStatement";
%typeof statement_opt_list = "List";
%typeof statement_list = "List";
%typeof function_call_stmt = "SrcFunctionCallStmt";
%typeof if_clause_list = "List";
%typeof additive_exp = "SrcExp";
%typeof enum_literal_list = "List";
%typeof has_final = "Bool";
%typeof for_indices = "List";
%typeof when_stmt = "SrcWhenStmt";
%typeof redeclare_replaceable_header = "RedeclareReplaceableHeader";
%typeof matrix_row = "SrcMatrixRow";
%typeof array_subscripts = "SrcArraySubscripts";
%typeof array_subscripts_opt = "Opt";
%typeof arg_list = "List";
%typeof else_if_exp = "SrcExp";
%typeof access_expression = "SrcAccessExp";
%typeof for_stmt = "SrcForStmt";
%typeof comment = "SrcComment";
%typeof function_argument_exp = "SrcExp";
%typeof base_class_decl_list = "List";
%typeof enum_contents = "List";
%goal source_root;
%goal anonymous_short_class;
%goal exp;
%goal element;
%goal abstract_equation;
%goal argument;
%goal access_scalar;
source_root =
    {: SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr;:}

  | program.program {: SourceRoot sr = new SourceRoot(program); 
       return sr;:}
  ;
program =
    stored_definition.stored_definition {: return new Program(new List().add(stored_definition));:}
  ;
stored_definition =
    within_opt.within base_class_decl_list.base_class_decl_list {: SrcStoredDefinition def = new SrcStoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
        formattingRecorder.postParsing(def);
        return def;:}

  | error.error {: return new SrcBadDefinition();:}
  ;
within =
    WITHIN.WITHIN access_opt.access SEMICOLON.SEMICOLON {: return new SrcWithin(access);:}
  ;
base_class_decl_list =
    base_class_decl.base_class_decl SEMICOLON.SEMICOLON {: return new List().add(base_class_decl);:}

  | base_class_decl_list.base_class_decl_list base_class_decl.base_class_decl SEMICOLON.SEMICOLON {: base_class_decl_list.add(base_class_decl);
        return base_class_decl_list;:}
  ;
anonymous_short_class =
    extends_clause_short_class.extends_clause_short_class {: return new SrcShortClassDecl(
            new SrcIdDecl("'Anonymous Class'"),
            false, false, 
            new SrcClass(), 
            false, false, false, false, false, 
            new Opt(), new Opt(), 
            extends_clause_short_class);:}
  ;
base_class_decl =
    has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction id_decl.start string_comment_opt.string_comment clause_star.clause_star external_clause_opt.external_clause class_annotation_opt.class_annotation end_decl.end_decl {: adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcFullClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl);:}

  | has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction id_decl.class_name EQUALS.EQUALS extends_clause_short_class.extends_clause_short_class {: adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcShortClassDecl(
            class_name, 
            has_encapsulated.value, 
            has_partial.value, 
            restriction, 
            false, false, false, false, false, 
            new Opt(), new Opt(),
            extends_clause_short_class);:}

  | has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction EXTENDS.EXTENDS id_decl.start class_modification_opt.class_modification string_comment_opt.string_comment clause_star.clause_star external_clause_opt.external_clause class_annotation_opt.class_annotation end_decl.end_decl {: adjustStart(has_encapsulated, has_partial, restriction);
        SrcInlineExtendsClause ext = new SrcInlineExtendsClause(
            new SrcNamedAccess(start.getID()),
            class_modification,
            new Opt());
        return new SrcExtendClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl, 
            ext);:}

  | has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction id_decl.enum_name EQUALS.EQUALS ENUMERATION.ENUMERATION LPAREN.LPAREN enum_specification.enum_specification RPAREN.RPAREN comment.comment {: adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcEnumClassDecl(
            enum_name,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            comment.getSrcStringCommentOpt(),
            new List(new SrcDefaultElementList(new List(enum_specification))),
            new Opt(),
            comment.getSrcAnnotationOpt(),
            new SrcEndDecl(enum_name.getID()));:}

  | error.error {: return new SrcBadClassDecl();:}
  ;
extends_clause_short_class =
    type_prefixes.type_prefixes access_scalar.access_scalar array_subscripts_opt.array_subscripts class_modification_opt.class_modification comment.comment {: adjustStart(type_prefixes, access_scalar);
        return new SrcExtendsClauseShortClass(
            access_scalar,
            class_modification, 
            new Opt<SrcAnnotation>(),
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            array_subscripts, 
            comment);:}
  ;
enum_specification =
    enum_contents.enum_contents {: return new SrcEnumComponentClause(
                false, false, false, false, false,
                new Opt(),
                new Opt(new SrcConstant()),
                new Opt(),
                new SrcNamedAccess("EnumType"),
                new Opt(),
                enum_contents,
                new Opt(),
                new SrcComment());:}
  ;
enum_contents =
    COLON.COLON {: return new List();:}

  | enum_literal_list.enum_literal_list {: return enum_literal_list;:}
  ;
enum_literal_list =
    enum_literal.enum_literal {: return new List(enum_literal);:}

  | enum_literal_list.enum_literal_list COMMA.COMMA enum_literal.enum_literal {: enum_literal_list.add(enum_literal); 
        return enum_literal_list;:}
  ;
enum_literal =
    id_decl.id_decl comment.comment {: return new SrcEnumLiteralDecl(
                id_decl,
                new Opt(),
                new Opt(),
                new Opt(),
                comment);:}
  ;
type_prefix_flow =
    FLOW.FLOW {: return new SrcFlow();:}

  | STREAM.STREAM {: return new SrcStream();:}
  ;
type_prefix_variability =
    DISCRETE.DISCRETE {: return new SrcDiscrete();:}

  | PARAMETER.PARAMETER {: return new SrcParameter();:}

  | CONSTANT.CONSTANT {: return new SrcConstant();:}
  ;
type_prefix_input_output =
    INPUT.INPUT {: return new SrcInput();:}

  | OUTPUT.OUTPUT {: return new SrcOutput();:}
  ;
type_prefixes =
    type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output {: adjustStart(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
        return new TypePrefixes(type_prefix_flow, type_prefix_variability, type_prefix_input_output);:}
  ;
restriction =
    CLASS.CLASS {: return new SrcClass();:}

  | MODEL.MODEL {: return new SrcModel();:}

  | BLOCK.BLOCK {: return new SrcBlock();:}

  | CONNECTOR.CONNECTOR {: return new SrcConnector();:}

  | EXPANDABLE.EXPANDABLE CONNECTOR.CONNECTOR {: return new SrcExpandableConnector();:}

  | TYPE.TYPE {: return new SrcType();:}

  | PACKAGE.PACKAGE {: return new SrcPackage();:}

  | FUNCTION.FUNCTION {: return new SrcFunction();:}

  | RECORD.RECORD {: return new SrcRecord();:}

  | OPERATOR.OPERATOR RECORD.RECORD {: return new SrcOperatorRecord();:}

  | OPERATOR.OPERATOR FUNCTION.FUNCTION {: return new SrcOperatorFunction();:}

  | OPERATOR.OPERATOR {: return new SrcOperator();:}
  ;
has_partial =
    PARTIAL.PARTIAL {: return newTrue();:}

  | {: return newFalse();:}
  ;
has_encapsulated =
    ENCAPSULATED.ENCAPSULATED {: return newTrue();:}

  | {: return newFalse();:}
  ;
has_inner =
    INNER.INNER {: return newTrue();:}

  | {: return newFalse();:}
  ;
has_outer =
    OUTER.OUTER {: return newTrue();:}

  | {: return newFalse();:}
  ;
has_redeclare =
    REDECLARE.REDECLARE {: return newTrue();:}

  | {: return newFalse();:}
  ;
has_each =
    EACH.EACH {: return newTrue();:}

  | {: return newFalse();:}
  ;
has_final =
    FINAL.FINAL {: return newTrue();:}

  | {: return newFalse();:}
  ;
redeclare_replaceable_header =
    REDECLARE.REDECLARE has_each.has_each has_final.has_final REPLACEABLE.REPLACEABLE {: return new RedeclareReplaceableHeader(true, has_each.value, has_final.value);:}

  | has_each.has_each has_final.has_final REPLACEABLE.REPLACEABLE {: adjustStart(has_each, has_final, REPLACEABLE);
        return new RedeclareReplaceableHeader(false, has_each.value, has_final.value);:}
  ;
clause_star =
    default_element_list.default_element_list {: return new List(default_element_list);:}

  | {: return new List();:}

  | clause_star.clause_star clause.clause {: return clause_star.add(clause);:}
  ;
default_element_list =
    element_plus.element_plus {: return new SrcDefaultElementList(element_plus);:}
  ;
element_plus =
    element.element {: return new List(element);:}

  | element_plus.element_plus element.element {: return element_plus.add(element);:}
  ;
clause =
    PUBLIC.PUBLIC element_opt_list.element {: return new SrcPublicElementList(element);:}

  | PROTECTED.PROTECTED element_opt_list.element {: return new SrcProtectedElementList(element);:}

  | EQUATION.EQUATION abstract_equation_opt_list.abstract_equation {: return new SrcEquationClause(abstract_equation);:}

  | INITIAL_EQUATION.INITIAL_EQUATION abstract_equation_opt_list.abstract_equation {: return new SrcInitialEquationClause(abstract_equation);:}

  | ALGORITHM.ALGORITHM statement_opt_list.statement {: return new SrcAlgorithm(statement);:}

  | INITIAL_ALGORITHM.INITIAL_ALGORITHM statement_opt_list.statement {: return new SrcInitialAlgorithm(statement);:}
  ;
external_clause =
    EXTERNAL.EXTERNAL external_language_opt.external_language external_function_call_opt.external_function_call annotation_opt.annotation SEMICOLON.SEMICOLON {: return new SrcExternalClause(external_language, external_function_call, annotation);:}
  ;
external_language =
    STRING.s {: return new SrcExternalLanguage(((String)s.value));:}
  ;
class_annotation =
    annotation.annotation SEMICOLON.SEMICOLON {: return annotation;:}
  ;
external_function_call =
    access.access EQUALS.EQUALS id_decl.id_decl LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN {: return new SrcExternalFunctionCall(new Opt(access), id_decl, arg_list);:}

  | id_decl.id_decl LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN {: return new SrcExternalFunctionCall(new Opt(), id_decl, arg_list);:}
  ;
element =
    has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer base_class_decl.base_class_decl SEMICOLON.SEMICOLON {: adjustStart(has_redeclare, has_final, has_inner, has_outer, base_class_decl);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        return base_class_decl;:}

  | has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer REPLACEABLE.REPLACEABLE base_class_decl.base_class_decl constraining_clause_and_comment.constraining_clause_and_comment SEMICOLON.SEMICOLON {: adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        base_class_decl.setReplaceable(true);
        base_class_decl.setSrcConstrainingClauseOpt(constraining_clause_and_comment.constr);
        base_class_decl.setConstrainingClauseComment(constraining_clause_and_comment.comment);
        return base_class_decl;:}

  | extends_clause.extends_clause SEMICOLON.SEMICOLON {: return extends_clause;:}

  | import_clause.import_clause SEMICOLON.SEMICOLON {: return import_clause;:}

  | has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer type_prefixes.type_prefixes access_scalar.access_scalar array_subscripts_opt.array_subscripts component_list.component_list SEMICOLON.SEMICOLON {: adjustStart(has_redeclare, has_final, has_inner, has_outer, type_prefixes, access_scalar);
        return new SrcComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            false,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            new Opt(),
            new SrcComment());:}

  | has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer REPLACEABLE.REPLACEABLE type_prefixes.type_prefixes access_scalar.access_scalar array_subscripts_opt.array_subscripts component_list.component_list constraining_clause_and_comment.constraining_clause_and_comment SEMICOLON.SEMICOLON {: adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        return new SrcComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            true,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            constraining_clause_and_comment.constr,
            constraining_clause_and_comment.comment);:}

  | error.error SEMICOLON.SEMICOLON {: return new SrcBadElement();:}
  ;
constraining_clause_and_comment =
    constraining_clause.constraining_clause comment.comment {: return new ConstrClauseAndComment(constraining_clause, comment);:}

  | {: return new ConstrClauseAndComment();:}
  ;
constraining_clause =
    CONSTRAINEDBY.CONSTRAINEDBY access.access class_modification_opt.class_modification {: return new SrcConstrainingClause(access, class_modification);:}
  ;
extends_clause =
    EXTENDS.EXTENDS access.access class_modification_opt.class_modification annotation_opt.annotation {: return new SrcExtendsClause(access, class_modification, annotation);:}
  ;
import_clause =
    IMPORT.IMPORT access_scalar.access_scalar comment.comment {: return new SrcImportClauseQualified(access_scalar, comment);:}

  | IMPORT.IMPORT access_scalar.access_scalar DOTMULT.DOTMULT comment.comment {: return new SrcImportClauseUnqualified(access_scalar, comment);:}

  | IMPORT.IMPORT id_decl.alias EQUALS.EQUALS access_scalar.access_scalar comment.comment {: return new SrcImportClauseRename(access_scalar, comment, alias);:}
  ;
array_subscripts =
    LBRACK.LBRACK subscript_list.subscript_list RBRACK.RBRACK {: return new SrcArraySubscripts(subscript_list);:}
  ;
subscript_list =
    subscript.subscript {: return new List().add(subscript);:}

  | subscript_list.subscript_list COMMA.COMMA subscript.subscript {: subscript_list.add(subscript);
        return subscript_list;:}
  ;
subscript =
    COLON.COLON {: return new SrcColonSubscript();:}

  | exp.exp {: return new SrcExpSubscript(exp);:}
  ;
component_list =
    component_decl.component_decl {: return new List(component_decl);:}

  | component_list.component_list COMMA.COMMA component_decl.component_decl {: component_list.add(component_decl);
        return component_list;:}
  ;
component_decl =
    id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification conditional_attribute_opt.conditional_attribute comment.comment {: return new SrcComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 conditional_attribute, 
                                 comment);:}
  ;
component_decl_no_conditional =
    id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment {: return new SrcComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 new Opt(), 
                                 comment);:}
  ;
conditional_attribute =
    IF.IF exp.exp {: return new SrcConditionalAttribute(exp);:}
  ;
modification =
    complete_modification.complete_modification {: return complete_modification;:}

  | value_modification.value_modification {: return value_modification;:}
  ;
complete_modification =
    class_modification.class_modification value_modification_opt.value_modification {: return new SrcCompleteModification(class_modification, value_modification);:}
  ;
value_modification =
    EQUALS.EQUALS exp.exp {: return new SrcValueModification(exp);:}

  | COLON.COLON EQUALS.EQUALS exp.exp {: return new SrcValueModification(exp);:}
  ;
class_modification =
    LPAREN.LPAREN RPAREN.RPAREN {: return new SrcClassModification();:}

  | LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN {: return new SrcClassModification(argument_list);:}
  ;
argument_list =
    argument.argument {: return new List().add(argument);:}

  | argument_list.argument_list COMMA.COMMA argument.argument {: argument_list.add(argument);
        return argument_list;:}
  ;
argument =
    has_each.has_each has_final.has_final access.access modification_opt.modification comment.comment {: adjustStart(has_each, has_final, access);
        return new SrcComponentModification(
            has_each.value, 
            has_final.value, 
            access, 
            modification, 
            comment);:}

  | redeclare_replaceable_header.redeclare_replaceable_header base_class_decl.base_class_decl constraining_clause_opt.constraining_clause {: adjustStart(redeclare_replaceable_header, base_class_decl);
        SrcNamedAccess name = new SrcNamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setSrcConstrainingClauseOpt(constraining_clause);
        base_class_decl.setReplaceable(true);
        base_class_decl.setRedeclare(redeclare_replaceable_header.has_redeclare);
        return new SrcClassRedeclare(
            redeclare_replaceable_header.has_each, 
            redeclare_replaceable_header.has_final, 
            name, 
            base_class_decl);:}

  | REDECLARE.REDECLARE has_each.has_each has_final.has_final base_class_decl.base_class_decl {: SrcNamedAccess name = new SrcNamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setRedeclare(true);
        return new SrcClassRedeclare(
            has_each.value,
            has_final.value,
            name,
            base_class_decl);:}

  | redeclare_replaceable_header.header component_clause_in_argument.cc constraining_clause_opt.constr {: adjustStart(header, cc);
        cc.setSrcConstrainingClauseOpt(constr);
        cc.setLocationNoTree(header, (constr.hasChild() ? constr : cc));
        cc.setRedeclare(header.has_redeclare);
        return new SrcComponentRedeclare(
            header.has_each, 
            header.has_final, 
            cc.createAccessForRedeclareNode(),
            cc);:}

  | REDECLARE.REDECLARE has_each.has_each has_final.has_final component_clause_in_argument.cc {: cc.setReplaceable(false);
        cc.setLocationNoTree(REDECLARE, cc);
        return new SrcComponentRedeclare(
            has_each.value, 
            has_final.value, 
            cc.createAccessForRedeclareNode(),
            cc);:}

  | error.error {: return new SrcBadArgument();:}
  ;
component_clause_in_argument =
    type_prefixes.type_prefixes access_scalar.access_scalar component_decl_no_conditional.component_decl_no_conditional {: adjustStart(type_prefixes, access_scalar);
        return new SrcComponentClause(
            true,   // Changed in argument rule for case without "redeclare"
            false, 
            false, 
            false, 
            true,   // Changed in argument rule for case without "replaceable"
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            access_scalar, 
            new Opt(), 
            new List(component_decl_no_conditional), 
            new Opt(), 
            new SrcComment());:}
  ;
annotation =
    annotation_tok.annotation_tok class_modification.class_modification {: annotationTok = null;
        return new SrcParseAnnotation(class_modification);:}
  ;
annotation_tok =
    ANNOTATION.ANNOTATION {: if (annotationTok != null) {
            getReport().syntaxError(ANNOTATION);
        }
        annotationTok = ANNOTATION;
        return new Symbol(ANNOTATION);:}
  ;
abstract_equation =
    exp.left EQUALS.EQUALS exp.right comment.comment SEMICOLON.SEMICOLON {: return new SrcEquation(comment, left, right);:}

  | if_equation.if_equation SEMICOLON.SEMICOLON {: return if_equation;:}

  | for_clause_e.for_clause_e SEMICOLON.SEMICOLON {: return for_clause_e;:}

  | when_equation.when_equation SEMICOLON.SEMICOLON {: return when_equation;:}

  | CONNECT.CONNECT LPAREN.LPAREN access.a COMMA.COMMA access.b RPAREN.RPAREN comment.comment SEMICOLON.SEMICOLON {: return new SrcConnectClause(comment, a, b);:}

  | LPAREN.LPAREN function_call_left_list.function_call_left_list RPAREN.RPAREN EQUALS.EQUALS function_call.function_call comment.comment SEMICOLON.SEMICOLON {: return new SrcFunctionCallEquation(comment, function_call_left_list, function_call);:}

  | function_call.function_call comment.comment SEMICOLON.SEMICOLON {: return new SrcFunctionCallEquation(comment, new List(), function_call);:}
  ;
function_call_left_list =
    function_call_left.a COMMA.COMMA function_call_left.b {: return new List().add(a).add(b);:}

  | function_call_left_list.function_call_left_list COMMA.COMMA function_call_left.function_call_left {: return function_call_left_list.add(function_call_left);:}
  ;
function_call_left =
    {: return new SrcFunctionCallLeft();:}

  | access.access {: return new SrcFunctionCallLeft(new Opt(access));:}
  ;
for_clause_e =
    FOR.FOR for_indices.for_indices LOOP.LOOP abstract_equation_opt_list.abstract_equation END_FOR.END_FOR comment.comment {: return new SrcForClauseE(comment, for_indices,abstract_equation);:}
  ;
for_indices =
    for_index.for_index {: return new List().add(for_index);:}

  | for_indices.for_indices COMMA.COMMA for_index.for_index {: for_indices.add(for_index);
        return for_indices;:}
  ;
for_index =
    for_index_decl.for_index_decl for_in_exp_opt.for_in_exp {: SrcForIndex f = new SrcForIndex(
            false,
            false,
            false,
            false,
            false,
            new Opt(),
            new Opt(new SrcIndexParameter()),
            new Opt(),
            new SrcNamedAccess("Integer"),
            new Opt(),
            new List(for_index_decl),
            new Opt(),
            new SrcComment(),
            for_in_exp); 
        return f;:}
  ;
for_index_decl =
    id_decl.id_decl {: return new SrcForIndexDecl(
            id_decl,
            new Opt(),
            new Opt(),
            new Opt(),
            new SrcComment());:}
  ;
for_in_exp =
    IN.IN exp.e {: return e;:}
  ;
when_equation =
    WHEN.WHEN exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_when_equation_opt.else_when_equation END_WHEN.END_WHEN comment.comment {: return new SrcWhenEquation(comment,
                                abstract_equation,
                                test, 
                                else_when_equation);:}
  ;
else_when_equation =
    ELSEWHEN.ELSEWHEN exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_when_equation_opt.else_when_equation {: return new SrcWhenEquation(new SrcComment(),
                                abstract_equation, 
                                test, 
                                else_when_equation);:}
  ;
if_equation =
    IF.IF exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_if_equation_opt.else_if_equation END_IF.END_IF comment.comment {: return new SrcIfEquation(comment, 
                              abstract_equation, 
                              test, 
                              else_if_equation);:}
  ;
else_if_equation =
    ELSEIF.ELSEIF exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_if_equation_opt.else_if_equation {: return new SrcIfEquation(new SrcComment(),
                              abstract_equation, 
                              test, 
                              else_if_equation);:}

  | ELSE.ELSE abstract_equation_opt_list.abstract_equation {: return new SrcElseEquation(new SrcComment(), 
                                abstract_equation);:}
  ;
statement =
    access.left ASSIGN.ASSIGN exp.right comment.comment SEMICOLON.SEMICOLON {: return new SrcAssignStmt(comment, left, right);:}

  | function_call_stmt.function_call_stmt SEMICOLON.SEMICOLON {: return function_call_stmt;:}

  | BREAK.BREAK comment.comment SEMICOLON.SEMICOLON {: return new SrcBreakStmt(comment);:}

  | RETURN.RETURN comment.comment SEMICOLON.SEMICOLON {: return new SrcReturnStmt(comment);:}

  | if_stmt.if_stmt SEMICOLON.SEMICOLON {: return if_stmt;:}

  | when_stmt.when_stmt SEMICOLON.SEMICOLON {: return when_stmt;:}

  | for_stmt.for_stmt SEMICOLON.SEMICOLON {: return for_stmt;:}

  | while_stmt.while_stmt SEMICOLON.SEMICOLON {: return while_stmt;:}

  | error.error {: return new SrcBadStatement();:}
  ;
function_call_stmt =
    LPAREN.LPAREN function_call_stmt_left_list.function_call_stmt_left_list RPAREN.RPAREN ASSIGN.ASSIGN function_call.function_call comment.comment {: return new SrcFunctionCallStmt(comment, function_call_stmt_left_list, function_call);:}

  | function_call.function_call comment.comment {: return new SrcFunctionCallStmt(comment, new List(), function_call);:}
  ;
function_call_stmt_left_list =
    function_call_left.function_call_left {: return new List().add(function_call_left);:}

  | function_call_stmt_left_list.function_call_stmt_left_list COMMA.COMMA function_call_left.function_call_left {: return function_call_stmt_left_list.add(function_call_left);:}
  ;
if_stmt =
    IF.IF if_clause_list.if_clause_list else_stmts.else_stmts END_IF.END_IF comment.comment {: return new SrcIfStmt(comment, if_clause_list, new Opt(else_stmts));:}

  | IF.IF if_clause_list.if_clause_list END_IF.END_IF comment.comment {: return new SrcIfStmt(comment, if_clause_list, new Opt());:}
  ;
if_clause_list =
    if_clause.if_clause {: return new List().add(if_clause);:}

  | if_clause_list.if_clause_list else_if_clause.else_if_clause {: return if_clause_list.add(else_if_clause);:}
  ;
if_clause =
    exp.exp THEN.THEN statement_opt_list.statement {: return new SrcIfClause(exp, statement);:}
  ;
else_if_clause =
    ELSEIF.ELSEIF if_clause.if_clause {: return if_clause;:}
  ;
else_stmts =
    ELSE.ELSE statement_opt_list.statement {: return new SrcElseClause(statement);:}
  ;
when_stmt =
    WHEN.WHEN when_clause_list.when_clause_list END_WHEN.END_WHEN comment.comment {: return new SrcWhenStmt(comment, when_clause_list);:}
  ;
when_clause_list =
    when_clause.when_clause {: return new List().add(when_clause);:}

  | when_clause_list.when_clause_list else_when_clause.else_when_clause {: return when_clause_list.add(else_when_clause);:}
  ;
when_clause =
    exp.exp THEN.THEN statement_opt_list.statement {: return new SrcWhenClause(exp, statement);:}
  ;
else_when_clause =
    ELSEWHEN.ELSEWHEN exp.exp THEN.THEN statement_opt_list.statement {: return new SrcWhenClause(exp, statement);:}
  ;
for_stmt =
    FOR.FOR for_indices.for_indices LOOP.LOOP statement_opt_list.statement END_FOR.END_FOR comment.comment {: return new SrcForStmt(comment, for_indices, statement);:}
  ;
while_stmt =
    WHILE.WHILE exp.exp LOOP.LOOP statement_opt_list.statement END_WHILE.END_WHILE comment.comment {: return new SrcWhileStmt(comment, exp, statement);:}
  ;
exp =
    simple_expression.simple_expression {: return simple_expression;:}

  | if_exp.if_exp {: return if_exp;:}
  ;
if_exp =
    IF.IF exp.ifexp THEN.THEN exp.thenexp else_if_exp.else_if_exp {: return new SrcIfExp(ifexp, thenexp, else_if_exp);:}
  ;
else_if_exp =
    ELSEIF.ELSEIF exp.ifexp THEN.THEN exp.thenexp else_if_exp.else_if_exp {: return new SrcIfExp(ifexp, thenexp, else_if_exp);:}

  | ELSE.ELSE exp.exp {: return exp;:}
  ;
simple_expression =
    log_exp.log_exp {: return log_exp;:}

  | log_exp.l1 COLON.COLON log_exp.l2 {: SrcRangeExp r = new SrcRangeExp();
           r.addSrcExp(l1);
           r.addSrcExp(l2);
           return r;:}

  | log_exp.l1 COLON.COLON log_exp.l2 COLON.COLON_ log_exp.l3 {: SrcRangeExp r = new SrcRangeExp();
           r.addSrcExp(l1);
           r.addSrcExp(l2);
           r.addSrcExp(l3);
           return r;:}
  ;
log_exp =
    log_exp.a OR.OR log_exp.b {: return new SrcOrExp(a,b);:}

  | log_exp.a AND.AND log_exp.b {: return new SrcAndExp(a,b);:}

  | NOT.NOT relation.a {: return new SrcNotExp(a);:}

  | relation.relation {: return relation;:}
  ;
relation =
    artm_exp.a LT.LT artm_exp.b {: return new SrcLtExp(a,b);:}

  | artm_exp.a LEQ.LEQ artm_exp.b {: return new SrcLeqExp(a,b);:}

  | artm_exp.a GT.GT artm_exp.b {: return new SrcGtExp(a,b);:}

  | artm_exp.a GEQ.GEQ artm_exp.b {: return new SrcGeqExp(a,b);:}

  | artm_exp.a EQ.EQ artm_exp.b {: return new SrcEqExp(a,b);:}

  | artm_exp.a NEQ.NEQ artm_exp.b {: return new SrcNeqExp(a,b);:}

  | artm_exp.a {: return a;:}
  ;
artm_exp =
    additive_exp.additive_exp {: return additive_exp;:}
  ;
additive_exp =
    multiplicative_exp.e {: return e;:}

  | additive_exp.e1 PLUS.PLUS multiplicative_exp.e2 {: return new SrcAddExp(e1, e2);:}

  | additive_exp.e1 MINUS.MINUS multiplicative_exp.e2 {: return new SrcSubExp(e1, e2);:}

  | additive_exp.e1 DOTPLUS.DOTPLUS multiplicative_exp.e2 {: return new SrcDotAddExp(e1, e2);:}

  | additive_exp.e1 DOTMINUS.DOTMINUS multiplicative_exp.e2 {: return new SrcDotSubExp(e1, e2);:}
  ;
multiplicative_exp =
    unary_exp.e {: return e;:}

  | multiplicative_exp.e1 MULT.MULT unary_exp.e2 {: return new SrcMulExp(e1, e2);:}

  | multiplicative_exp.e1 DIV.DIV unary_exp.e2 {: return new SrcDivExp(e1, e2);:}

  | multiplicative_exp.e1 DOTMULT.DOTMULT unary_exp.e2 {: return new SrcDotMulExp(e1, e2);:}

  | multiplicative_exp.e1 DOTDIV.DOTDIV unary_exp.e2 {: return new SrcDotDivExp(e1, e2);:}
  ;
unary_exp =
    pow_exp.pow_exp {: return pow_exp;:}

  | MINUS.MINUS unary_exp.unary_exp {: return new SrcNegExp(unary_exp);:}

  | PLUS.PLUS unary_exp.unary_exp {: formattingRecorder.addItem(FormattingType.NON_BREAKING_WHITESPACE, "+", PLUS);
                              return unary_exp;:}
  ;
pow_exp =
    primary.primary {: return primary;:}

  | primary.a POW.POW primary.e {: return new SrcPowExp(a,e);:}

  | primary.a DOTPOW.DOTPOW primary.e {: return new SrcDotPowExp(a,e);:}
  ;
primary =
    UNSIGNED_NUMBER.n {: return new SrcRealLitExp(((String)n.value));:}

  | UNSIGNED_INTEGER.n {: return new SrcIntegerLitExp(((String)n.value));:}

  | TRUE.TRUE {: return new SrcBooleanLitExpTrue();:}

  | FALSE.FALSE {: return new SrcBooleanLitExpFalse();:}

  | STRING.s {: return new SrcStringLitExp(((String)s.value));:}

  | access_expression.access_expression {: return access_expression;:}

  | der_expression.der_expression {: return der_expression;:}

  | LPAREN.LPAREN exp.a RPAREN.RPAREN {: return new SrcParExp(a);:}

  | function_call.function_call {: return function_call;:}

  | LBRACK.LBRACK matrix.matrix RBRACK.RBRACK {: return matrix;:}

  | LBRACE.LBRACE function_arguments.function_arguments RBRACE.RBRACE {: return new SrcArrayConstructor(function_arguments);:}

  | TIME.TIME {: return new SrcTimeExp();:}

  | END.END {: return new SrcEndExp();:}
  ;
function_call =
    access.access LPAREN.LPAREN function_arguments_opt.function_arguments RPAREN.RPAREN {: return new SrcFunctionCall(access, function_arguments);:}
  ;
partial_function_call =
    FUNCTION.FUNCTION access.access LPAREN.LPAREN function_arguments_named_opt.function_arguments_named RPAREN.RPAREN {: return new SrcPartialFunctionCall(access, function_arguments_named);:}

  | FUNCTION.FUNCTION access.access {: return new SrcPartialFunctionCall(access, new Opt());:}
  ;
function_arguments =
    exp.exp FOR.FOR for_indices.for_indices {: List arg_list_f = new List().add(new SrcIterExp(exp, for_indices));
                                         return new SrcFunctionArguments(arg_list_f, new List());:}

  | arg_list_p.arg_list_p {: return new SrcFunctionArguments(arg_list_p, new List());:}

  | arg_list_p.arg_list_p COMMA.COMMA named_arguments.named_arguments {: return new SrcFunctionArguments(arg_list_p, named_arguments);:}

  | function_arguments_named.function_arguments_named   ;
function_arguments_named =
    named_arguments.named_arguments {: return new SrcFunctionArguments(new List(), named_arguments);:}
  ;
named_arguments =
    named_argument.named_argument {: return new List().add(named_argument);:}

  | named_arguments.named_arguments COMMA.COMMA named_argument.named_argument {: return named_arguments.add(named_argument);:}
  ;
function_argument_exp =
    exp.exp {: return exp;:}

  | partial_function_call.partial_function_call {: return partial_function_call;:}
  ;
named_argument =
    named_argument_id.named_argument_id EQUALS.EQUALS function_argument_exp.function_argument_exp {: return new SrcNamedArgument(named_argument_id,function_argument_exp);:}
  ;
named_argument_id =
    ID.id {: return new SrcNamedAccess(((String)id.value));:}
  ;
matrix =
    matrix_row.matrix_row {: return new SrcMatrix(new List().add(matrix_row));:}

  | matrix.matrix SEMICOLON.SEMICOLON matrix_row.matrix_row {: matrix.addRow(matrix_row); 
                                    return matrix;:}
  ;
matrix_row =
    exp.exp {: return new SrcMatrixRow(new List().add(exp));:}

  | matrix_row.matrix_row COMMA.COMMA exp.exp {: matrix_row.addSrcExp(exp); 
                             return matrix_row;:}
  ;
arg_list =
    {: return new List();:}

  | exp.exp {: return new List().add(exp);:}

  | arg_list.arg_list COMMA.COMMA exp.exp {: arg_list.add(exp); 
                           return arg_list;:}
  ;
arg_list_p =
    function_argument_exp.function_argument_exp {: return new List().add(function_argument_exp);:}

  | arg_list_p.arg_list_p COMMA.COMMA function_argument_exp.function_argument_exp {: return arg_list_p.add(function_argument_exp);:}
  ;
comment =
    string_comment_opt.string_comment annotation_opt.annotation {: return new SrcComment(string_comment,annotation);:}
  ;
string_comment =
    string_comment_exp.string_comment_exp {: return new SrcStringComment(string_comment_exp);:}
  ;
string_comment_exp =
    string.string 
  | string_comment_exp.string_comment_exp PLUS.PLUS string.string {: return new SrcAddExp(string_comment_exp, string);:}
  ;
string =
    STRING.s {: return new SrcStringLitExp(((String)s.value));:}
  ;
id_decl =
    ID.id {: return new SrcIdDecl(((String)id.value));:}
  ;
access_expression =
    access.access {: return new SrcAccessExp(access);:}
  ;
der_expression =
    DER.DER LPAREN.LPAREN exp.exp RPAREN.RPAREN {: return new SrcDerExp(exp);:}
  ;
access =
    access_loc.access_loc {: return access_loc;:}

  | DOT.DOT access_loc.access_loc {: return new SrcGlobalAccess(access_loc);:}
  ;
access_loc =
    access_single.access_single 
  | access_dot.access_dot   ;
access_dot =
    access_single.a DOT.DOT access_single.b {: return new SrcDot(new List(a, b));:}

  | access_dot.access_dot DOT.DOT access_single.access_single {: access_dot.addSrcAccess(access_single);
        return access_dot;:}
  ;
access_single =
    access_single_array.access_single_array 
  | access_single_scalar.access_single_scalar   ;
access_single_array =
    ID.id array_subscripts.array_subscripts {: return new SrcArrayAccess(((String)id.value), array_subscripts);:}
  ;
access_single_scalar =
    ID.id {: return new SrcNamedAccess(((String)id.value));:}
  ;
access_scalar =
    access_scalar_loc.access_scalar_loc {: return access_scalar_loc;:}

  | DOT.DOT access_scalar_loc.access_scalar_loc {: return new SrcGlobalAccess(access_scalar_loc);:}
  ;
access_scalar_loc =
    access_scalar_dot.access_scalar_dot 
  | access_single_scalar.access_single_scalar   ;
access_scalar_dot =
    access_single_scalar.a DOT.DOT access_single_scalar.b {: return new SrcDot(new List(a, b));:}

  | access_scalar_dot.access_scalar_dot DOT.DOT access_single_scalar.access_single_scalar {: access_scalar_dot.addSrcAccess(access_single_scalar);
        return access_scalar_dot;:}
  ;
end_decl =
    END_ID.END_ID {: String value = (String) END_ID.value;
        String id = value.substring(3, value.length()).trim();
        return new SrcEndDecl(id);:}
  ;


string_comment_opt =
    {: return new Opt(); :}
  | string_comment.n {: return new Opt(n); :}
  ;










function_arguments_opt =
    {: return new Opt(); :}
  | function_arguments.n {: return new Opt(n); :}
  ;


value_modification_opt =
    {: return new Opt(); :}
  | value_modification.n {: return new Opt(n); :}
  ;





constraining_clause_opt =
    {: return new Opt(); :}
  | constraining_clause.n {: return new Opt(n); :}
  ;



element_opt_list =
    {: return new List(); :}
  | element_list.n {: return n; :}
  ;
element_list =
    element.n {: return new List().add(n); :}
  | element_list.l element.n {: return l.add(n); :}
  ;






type_prefix_variability_opt =
    {: return new Opt(); :}
  | type_prefix_variability.n {: return new Opt(n); :}
  ;



for_in_exp_opt =
    {: return new Opt(); :}
  | for_in_exp.n {: return new Opt(n); :}
  ;






access_opt =
    {: return new Opt(); :}
  | access.n {: return new Opt(n); :}
  ;

type_prefix_input_output_opt =
    {: return new Opt(); :}
  | type_prefix_input_output.n {: return new Opt(n); :}
  ;




else_if_equation_opt =
    {: return new Opt(); :}
  | else_if_equation.n {: return new Opt(n); :}
  ;






class_modification_opt =
    {: return new Opt(); :}
  | class_modification.n {: return new Opt(n); :}
  ;


annotation_opt =
    {: return new Opt(); :}
  | annotation.n {: return new Opt(n); :}
  ;

within_opt =
    {: return new Opt(); :}
  | within.n {: return new Opt(n); :}
  ;







function_arguments_named_opt =
    {: return new Opt(); :}
  | function_arguments_named.n {: return new Opt(n); :}
  ;




abstract_equation_opt_list =
    {: return new List(); :}
  | abstract_equation_list.n {: return n; :}
  ;
abstract_equation_list =
    abstract_equation.n {: return new List().add(n); :}
  | abstract_equation_list.l abstract_equation.n {: return l.add(n); :}
  ;




external_function_call_opt =
    {: return new Opt(); :}
  | external_function_call.n {: return new Opt(n); :}
  ;


class_annotation_opt =
    {: return new Opt(); :}
  | class_annotation.n {: return new Opt(n); :}
  ;

external_language_opt =
    {: return new Opt(); :}
  | external_language.n {: return new Opt(n); :}
  ;





else_when_equation_opt =
    {: return new Opt(); :}
  | else_when_equation.n {: return new Opt(n); :}
  ;





external_clause_opt =
    {: return new Opt(); :}
  | external_clause.n {: return new Opt(n); :}
  ;

modification_opt =
    {: return new Opt(); :}
  | modification.n {: return new Opt(n); :}
  ;


conditional_attribute_opt =
    {: return new Opt(); :}
  | conditional_attribute.n {: return new Opt(n); :}
  ;




type_prefix_flow_opt =
    {: return new Opt(); :}
  | type_prefix_flow.n {: return new Opt(n); :}
  ;
















statement_opt_list =
    {: return new List(); :}
  | statement_list.n {: return n; :}
  ;
statement_list =
    statement.n {: return new List().add(n); :}
  | statement_list.l statement.n {: return l.add(n); :}
  ;










array_subscripts_opt =
    {: return new Opt(); :}
  | array_subscripts.n {: return new Opt(n); :}
  ;









