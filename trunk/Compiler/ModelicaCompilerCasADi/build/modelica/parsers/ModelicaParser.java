// Generated from C:\stuff\workspace\JModelica\Compiler\ModelicaCompilerCasADi/build/modelica/parsers/ModelicaParser.parser
package org.jmodelica.modelica.parser;
 import org.jmodelica.modelica.compiler.*;
 import org.jmodelica.util.AdjustableSymbol;
 import org.jmodelica.util.AbstractAdjustableSymbol;
 import org.jmodelica.util.formatting.FormattingRecorder;
 import org.jmodelica.util.formatting.FormattingType;
 import org.jmodelica.api.problemHandling.Problem;
 import org.jmodelica.api.problemHandling.ProblemSeverity;
 import org.jmodelica.api.problemHandling.ProblemKind;
 import beaver.Parser.Events;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ModelicaParser.beaver".
 */
public class ModelicaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short STRING = 2;
		static public final short DOT = 3;
		static public final short ANNOTATION = 4;
		static public final short SEMICOLON = 5;
		static public final short COMMA = 6;
		static public final short RPAREN = 7;
		static public final short IF = 8;
		static public final short LPAREN = 9;
		static public final short PLUS = 10;
		static public final short MINUS = 11;
		static public final short CONSTRAINEDBY = 12;
		static public final short FOR = 13;
		static public final short ELSEIF = 14;
		static public final short ELSE = 15;
		static public final short LBRACK = 16;
		static public final short RBRACE = 17;
		static public final short EQUALS = 18;
		static public final short DER = 19;
		static public final short LBRACE = 20;
		static public final short UNSIGNED_NUMBER = 21;
		static public final short UNSIGNED_INTEGER = 22;
		static public final short TRUE = 23;
		static public final short FALSE = 24;
		static public final short TIME = 25;
		static public final short END = 26;
		static public final short LOOP = 27;
		static public final short RBRACK = 28;
		static public final short COLON = 29;
		static public final short END_ID = 30;
		static public final short THEN = 31;
		static public final short EXTERNAL = 32;
		static public final short PUBLIC = 33;
		static public final short PROTECTED = 34;
		static public final short EQUATION = 35;
		static public final short INITIAL_EQUATION = 36;
		static public final short ALGORITHM = 37;
		static public final short INITIAL_ALGORITHM = 38;
		static public final short FUNCTION = 39;
		static public final short OR = 40;
		static public final short AND = 41;
		static public final short NOT = 42;
		static public final short CONNECTOR = 43;
		static public final short RECORD = 44;
		static public final short EXPANDABLE = 45;
		static public final short OPERATOR = 46;
		static public final short INPUT = 47;
		static public final short OUTPUT = 48;
		static public final short CLASS = 49;
		static public final short MODEL = 50;
		static public final short BLOCK = 51;
		static public final short TYPE = 52;
		static public final short PACKAGE = 53;
		static public final short DOTMULT = 54;
		static public final short PARTIAL = 55;
		static public final short ENCAPSULATED = 56;
		static public final short DISCRETE = 57;
		static public final short PARAMETER = 58;
		static public final short CONSTANT = 59;
		static public final short FLOW = 60;
		static public final short STREAM = 61;
		static public final short LT = 62;
		static public final short LEQ = 63;
		static public final short GT = 64;
		static public final short GEQ = 65;
		static public final short EQ = 66;
		static public final short NEQ = 67;
		static public final short REPLACEABLE = 68;
		static public final short DOTPLUS = 69;
		static public final short DOTMINUS = 70;
		static public final short MULT = 71;
		static public final short DIV = 72;
		static public final short DOTDIV = 73;
		static public final short EXTENDS = 74;
		static public final short END_IF = 75;
		static public final short WHEN = 76;
		static public final short FINAL = 77;
		static public final short END_WHEN = 78;
		static public final short OUTER = 79;
		static public final short INNER = 80;
		static public final short REDECLARE = 81;
		static public final short ELSEWHEN = 82;
		static public final short POW = 83;
		static public final short DOTPOW = 84;
		static public final short IMPORT = 85;
		static public final short END_FOR = 86;
		static public final short WHILE = 87;
		static public final short BREAK = 88;
		static public final short RETURN = 89;
		static public final short CONNECT = 90;
		static public final short END_WHILE = 91;
		static public final short ASSIGN = 92;
		static public final short EACH = 93;
		static public final short IN = 94;
		static public final short ENUMERATION = 95;
		static public final short WITHIN = 96;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"STRING",
			"DOT",
			"ANNOTATION",
			"SEMICOLON",
			"COMMA",
			"RPAREN",
			"IF",
			"LPAREN",
			"PLUS",
			"MINUS",
			"CONSTRAINEDBY",
			"FOR",
			"ELSEIF",
			"ELSE",
			"LBRACK",
			"RBRACE",
			"EQUALS",
			"DER",
			"LBRACE",
			"UNSIGNED_NUMBER",
			"UNSIGNED_INTEGER",
			"TRUE",
			"FALSE",
			"TIME",
			"END",
			"LOOP",
			"RBRACK",
			"COLON",
			"END_ID",
			"THEN",
			"EXTERNAL",
			"PUBLIC",
			"PROTECTED",
			"EQUATION",
			"INITIAL_EQUATION",
			"ALGORITHM",
			"INITIAL_ALGORITHM",
			"FUNCTION",
			"OR",
			"AND",
			"NOT",
			"CONNECTOR",
			"RECORD",
			"EXPANDABLE",
			"OPERATOR",
			"INPUT",
			"OUTPUT",
			"CLASS",
			"MODEL",
			"BLOCK",
			"TYPE",
			"PACKAGE",
			"DOTMULT",
			"PARTIAL",
			"ENCAPSULATED",
			"DISCRETE",
			"PARAMETER",
			"CONSTANT",
			"FLOW",
			"STREAM",
			"LT",
			"LEQ",
			"GT",
			"GEQ",
			"EQ",
			"NEQ",
			"REPLACEABLE",
			"DOTPLUS",
			"DOTMINUS",
			"MULT",
			"DIV",
			"DOTDIV",
			"EXTENDS",
			"END_IF",
			"WHEN",
			"FINAL",
			"END_WHEN",
			"OUTER",
			"INNER",
			"REDECLARE",
			"ELSEWHEN",
			"POW",
			"DOTPOW",
			"IMPORT",
			"END_FOR",
			"WHILE",
			"BREAK",
			"RETURN",
			"CONNECT",
			"END_WHILE",
			"ASSIGN",
			"EACH",
			"IN",
			"ENUMERATION",
			"WITHIN",
		};
	}
	static public class AltGoals {
		static public final short anonymous_short_class = 97;
		static public final short exp = 98;
		static public final short element = 99;
		static public final short abstract_equation = 100;
		static public final short argument = 101;
		static public final short access_scalar = 102;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjVGU0LSNL$vdxzktkstrBLQJkWgB0Aceic9Z464MJW1Z5Q195anWLU#mz4Uoz81R4g8a" +
		"LKR4tK04HiM7l7KGDM29sr3l$tpapS#$SydOVIFBvVN$UsRapSyxCER#PELFkVM$V8rgpGT" +
		"TcITLHNrqRBWuNgww64xwgTVWgrOUl6jArrCdoKtNf1Neos3HFAsJFfZYXsaZtrNt3b#aqI" +
		"9#WjyENcI3fIoLeVzdMcw1xqpZ45z5ukf2kfdFLU7MhxWtPkMcY0tHBE4kV6yvYKfDKKPyR" +
		"$9HvwZmrGVr3NQ6kKjUGbjB$pjI#Y2wW2xDQHTOzKzQYeHx8zQD6waEzgG7fi#buN4DJJdM" +
		"ainIu#fmCFKPdaiI6mkVZD6GTz6EgcJfH4vUbtTErgQoxqkWShIpRBPLVYRgYzEcw0NIEN0" +
		"sTGvTIit1CkG6wC#WShsr7qfzeIzgAHkW6#hjNqr1dVHOepHLIAoVpwA5Nk8TqFQX1heOQQ" +
		"0tBCILdgfvw9hX937S9XdhwpAifX7BNOipgyuW#IUNx1Ks2eGvKBzSwcxxKSgHS#A2UYO3O" +
		"4Tr8Zz71Y5z3cKkzceR#JWlea0nNYDx9b3sG3g8fkWIgawkXEdMdvPXo5wXf#WAE7L47cNi" +
		"Nm2DAc7#b9D44jJvcIIcFg6Cg7$VjgReKBWuwKj#W8LpCQRxIAhRS0ZfMDuFxIf9qCxr3Ez" +
		"1EuIkfKHhAeqHxqSze5zg8DgQTQMsKwPkftqLtePOqryekIUOnexlGMDqd$1ZqYbmDlQBxI" +
		"DcFRRtprJ7wV8uTCKBCelFLbk77DC#hASHI5QIvLlPwAX#tycdat5plXVHHz5RuiQenvTH1" +
		"wl1m2L9BAXDDb6kybkrAnz7nHgQtuq3RwEqSqNQ6R#aouRcwvq6o4jO0yCBNLJUzdMz7NnQ" +
		"drVbwhhf5pTChwRc6fCHSHsgLe0NvoziczHbVFUH$KAFeRIiToG4h$4X7M6CDNqXDbhYxxa" +
		"xRXtEnhrnEpz3#Kkvtu8xqxOGFUUd5y1xu9BsWLgMFr4ggHJ0ygNle7l3uUXgdlaP#n$0XT" +
		"Rkw3hmbuJJrS3WTj9W#uve#qVCqKNLASwtiwnJ7xNKBQL$CYJCnunOoSLgVYUj2KqwLrHhq" +
		"BU8IJQ6wSBgQ7huQhEPgEr9Fg8dgqZJNK518vlNX#d3iULTXDb#5t5MM3aVwQbXwbQQOSlG" +
		"KIYfm5PslLJwfJX9VxOtQkwXdfDjom9XjwoXOrVA5rB$v6ddxvz2sdYeBRufgbDeHGKjiyz" +
		"EW9uqBdmoV35OEUWNTWjxC3Re4NOELWkv1Zw0SQk3MbOcEaVYZn2mvnyZqDXpe1BsD8ph0y" +
		"0sf#SBh6zJPSTHqXgfZ7iReKQxjsVdAItVGJwXtr9#mkZvXIBG#uKYz7NuBphTjq7DyrIlx" +
		"g8DQ8zE$vg1lHR144mpVvUHg#reLmczvBH7PhU4qhXqJNHodzNYQgCUhtVLuHyp5$1fFVUa" +
		"AQVytu7nJcUWgkRuGzAMvFBzKHwmb3LRw0GUSopvm1DJ2Jvt5s6lP9x#9l7WkJYxF#NRK92" +
		"zzVtmM2zzGvuPl27TSrFuXuTVWV5sPq0TyzTUY6#aH8zFdSQ0NzNcEL9tX9r5JNqNIGxwUN" +
		"LLNtmvGnsaFjNvTtQTV5#uud7c$eCMoDX6i45sZAP$e9RdYdAjkZjhwGoiTnu5UHcm9NYly" +
		"3Eh#iakJn$y1HjopeoPvQR#ltrHpmZU5Euv7F5YJKOTm$h2D5xqfLuVt9pI1XcD#6zaR25l" +
		"JPhIfwgvw16k5ZzEkmlydxKs$e5$IhsWO7Kv7m1ldIr#7oTRuTlJDNlf6VQCQp5UgnIbUK8" +
		"BxIg8reNfCTzFTQ94QfpPHWzIQ#ZLz8iADuDwOf7015SC5QQuXTKAASmFePRw6ZwBceqpgP" +
		"3qBabdqBo1wpvOx3FGAwmQzG#yZrA3MOLBV8zLH7uOxW1loY3v8SIQ16kNw4dADJE4xuJk2" +
		"g17NMLPdBzLRzK7z3$MiS4RuI3WZ6A0dgLEafazl1OFrMnck4FqxnRbENnU#n5USJYU5Bmd" +
		"D26UWvAVWCo8fnppcGkzRUZvMhldOgQuBvt7D1BqPhAtVp70DNPFANmywYQ#mVHrIJFD1rz" +
		"4tI5r7tMov#OOBlM$gUVIudeVUlPvMbleUgOxg9NLlccjb7LASoQ2F#Cgwa6AQ1xfUTK7gU" +
		"hM$BJVFS6CF3dw1EWTAVO$KFS7QcBkJyoZed#9Sgw#5d#EATa#EvjWleQLLdm5EDrlk37q6" +
		"BG9N$9mULtzKE#fhWtMuPeAEqSVWv9Nc2gcradbtjbA3rTgmxspl0DcLyFDhrQQc77NHku2" +
		"kXVqhQ27RHvtwzFb9hHvieGRddwtqFrDdhKNgCBL4Pkm$a7EMTuQMZUb6N0#qzGgmMv0ub#" +
		"XLkSOhoaWz2YGozIKaDz51QalrHNGcvj9$IUrTE9FgMlMhX9xVWEVPmNeQf$rTu0trj7v3k" +
		"EFqA7K6B0Hgk0x02V89wmYkKOltD6kfbOs0nAobdTIleVSDsbLAPzPIjQtqJf1gYMzdEoyt" +
		"6wUssVe#jRqggKdqfVgjbDWfqP90lQXtrZkhNRnT#01z7nsbxqlGRFq7q8k8SqZjbk7ifMU" +
		"72$LHeDcHtcFLkcfVh1kpqN8kimxiulIkDb1$GTiUbh5Vg0yC5$eablyAohMSHHI#Z$2ly9" +
		"FmDKw3Fc5Iwz9J8ld4M6O9Udi3TPEw7X8#lVzB7u1w7g6SdDuhM7uXPVTTLGxV3T$LYrG9D" +
		"LTJX#X5JB0y9Lo44ekivKN8$KLj4FNAIQZvDwxf4thfIEorx#QHEYx5UG$xm7lXU$e5TGfg" +
		"EhqNekI9#ZGWEjYKqwSXzx1NuXBKEOXh#gH#gax3EV2zFDBFf$ApQNiPvrtrhk5xaTxB8Bb" +
		"ONmnT5zbo5#i$wpzx9QQ42zN5wN76slrtx9VvlVrSniDcuZfDFwyUz3piDhMkdW2QhIwt7Z" +
		"P1JbrnRz#jfwb$efvFit57UQNnoHnwDfM$H$yEuHuW#frdUIeiJmJDLbTRonF39y8dFCiFw" +
		"7lKjLBJ8rY#0PRloQNTK$cfUWU4gK2q0sewlNCXUKQVZkjkjjpfe3zv9PxLKzLTKjCZUDWV" +
		"ONbgBksKoi$MlvULP33YgU5ZwlFmCIRedQLFXNn7M#vKVIhkFATYntX6VINh$7tOtr8hYVf" +
		"0lGzD#Il9GyayTeoosJ5aLlrOFMxkyDIwiXBErjlRtYwgfn0sq4L7MC6ACGKTX6Tx951s$H" +
		"KPTeoYNN#$0AwRz4rOVxbqQltLg#XLr3FejoADeqL1ALXVMhYARqUVaaYVehG#mP5wGRWs5" +
		"zH4aWwW4rBqso3Gl#4unU#eEwfNzGd#ypSrEkVvsrfg2sgbDNK$tK#z5xuTlgqFrOUg8zKm" +
		"jPNQ6bpe0ky4y3R37V09Qe7QdEOn3#DrAFZ7Ey9eVQB#5UMVTgcWareObx8qHK$1MUfupE8" +
		"4dzuAYlfTnEsZFfDHqw7X0ng1INtiK8F7U4I$say$1NqNgyqPKJW$d1yGfCT5j40l2EUxd0" +
		"fT2hn$UQKClGrwJn#7bYVuyEHtGCTLtTTFwGlLZ$I5J3GbwkiBMLVG27rbTIYzYRYaDbSRW" +
		"dk8FYJeZ7XiH6U33d6vO9M8VmYmZKrIC936wbw81wKalVItG3wsMjJHdAZNH#WZ8jJVYAwl" +
		"4OvGH#0SCLOl0UeIxFNJNw7aM3qceY$qvy7FN2xuUSJl2HgJeazrps1BFIPyAyadUI5UMjH" +
		"hwB8kEzIiWNNXMbP$5NqJuDVZX7SqQ8m#rf6r6EKYIHFes2H1seHx6hzKGaVLg2UW#3ZgPj" +
		"1ug5dNuwnF7HziXDYWFjQYFbR$BQ9PuCroEQIZL9psUSpDIDO3PpsE7Ka#bGFMrO6L30PNW" +
		"cEgrRFagGVhEjdgcINfat4t#hTm3lLdFlNKjq1o2rCmc5Q3gbLzE#gRE8qwfDwYTzNFrC$L" +
		"MUeSzGPjGNVgTM1FWYC$xNBKb#yT#Aw6vBcEaONJE80ppH2dBFyY89b04t6#cgulufmyGrv" +
		"7KW$plGFYJhuTTNIS3gT3qtIVXBysi4XmvAVrsfX1mbCbx5y$4hJaId0i#RuuXRex9#5pU$" +
		"JZzXJwk27L5RB77Q7kuxuT$QI7mFO7lK0KR19iPkqDHYp1aPzsEPY#CMXs6e8#HWOqWnqlQ" +
		"eFmnTN4kxb$#2LzojgUT7sQjACUYTCvVShyjL13WgFW9t7QIOmr2l2tSV1ZLvhZO7F1CJsy" +
		"1xaFNMdz8PDzBhyOV6cFNilt8CwdxLXwF$AozvciR4sarqHwJKT#skMYyI1x#eXavlGHoNS" +
		"LVlP9ch7hww4yEvO#Y6fym6HbhKYt8jtgo4#xN0Pf9BD8tMjNuQUHsXVNy5zPEowTVWb$46" +
		"89ZloqotcL3D98ba7A$4f8VJsKPyUbCqYPFn2n14T#skKoI2DP1YdpAo7rzL2U7PVE86N#0" +
		"CGI7FbfbyiWZMGPfColXDJNGtbsN3g3bFbh89RWo4#xN0Pf9CiWPNubfBuUohFZqXcap5yT" +
		"iGH7VjhbCaWZMGOfyoiXzVLGdXsNpY1bVd$44XpvQPVB88ra6QJChuJKrqDvTbmwWvJvE2k" +
		"OuCXFkrm6QIJB86L#9QI#7igpuz8PfCnV5R44HtxQvJ988ra6AVCh8VNrK9uTbyuWPNuDOW" +
		"cE$BJBPP16iWnIvbT2wkkXF3ikxTiAdp4ojRVwdR6bZWgV0NTNAPDhY#jmcPYinWshFfD7h" +
		"t09BBhxdzhm6JN6w5UdqqHenlsFoVDBRHC#PSZMZN8#twNJPTEIYB$Kc0LBT1$X481tDiSu" +
		"fs#kPrdzdI5zsf2r5#LylakdowObUXECrYOSE#AybrlTy13FyZp1I6U9X881HYjVJMcnrpy" +
		"O73wj5FNdVC2hsQtcxW71t4LiahPAFwK$qEtwHyX9SEIdNIxZuv4iu#FCh#JZlXxAisDfG#" +
		"GaEFBJBfV15Caoc9XV2PElX$BiMDe0EGcE$BJBPJ15iWmcvbV2vEkXF3kMraTEWYC$xN8PJ" +
		"94CcFpNhiAlX6dzHDaSEvP#W9m4HtxQvJAO8ba64$DJcCAPyFAPnau2KyQEfPyX9y6HdtOv" +
		"eoESoPf5MoHZNZXJzLNzOadkf$asmRfpQmfJrewPTpz4Je8ZF#rob7h5iZn9BgQVqy$IfRD" +
		"sB6sCd0H7VjhbCfOZMPua5zFcmBHndfOSgniX9y6HdtQvZEL8bYV9nVH7ODeeJqkErI78IN" +
		"3afrqkOpcIvKboCTq6J4FojEHONHSv2OxyjCjbB4UoF4akfZk0QTqyBJbMVugS14T#skKob" +
		"YDPdWGpz0icrMJYy0lcG7YhNCdcykoOUVSJv2GuyjCkvomwdR4iWqduuQT9OevW#jJg#JJM" +
		"ah1ZCF4p60cE$BJBHPYipbYMmIJypATfvRG6J4kidYMnbeGTWsbJv2GuGk4Vqzrnpl8yNQw" +
		"qgPd2nFpsFW6z5kqdxmfich0wbUwDrBIluIJxr9XFny#Ynjbql7ywfhFe1foEJwRiwVXwQS" +
		"cp77nY3SIdOtxn4#8nT1sk9zDVgq1pit$snEdOuJfQyXukjGqORPtQixZCQyDgUzNObh7ef" +
		"3lHjlP4SelWgcXRS6LVja$qR6X3a5xzi$Hg#dLzk$ZM9VCiVhQKtoV$NKwM9$EURtavjQxZ" +
		"c7SvxJtA1cu6U3E1#FFbUcNDxoP8S6JaSSvSJUt89lC6cvf65a7u0QsVd7r#JlySTIGuCYL" +
		"SpgJIdMYbCpba9TvdM$Qeu06$5W$u8TrFC#W1Uf0UWgw7K9lZ788abVSi8gV#d03ncD4Z#d" +
		"8epVUVnehKFjEopxaUGYorv6MUaDzFydHCFlloUnddXyFx3LVg9Z$tQKRaVZs0oyJaFqzJa" +
		"xoqz#aUQ7xDQ5NZiixiqAZfh9$HS2plWN3UF26$5xRk3U$L3q3F0vooUEwLTANPmBl8lQwK" +
		"ewZF7t1n7gdfoRnOcsxV0td0sJRwJSwKSbRq$Xn0Zy328voorlQNT2N4$1x1$gwKemZn8ox" +
		"EepG$uL#FEDj6lyqzeWPwjlQJi9#L9b98Lq8yZKkuKewMyGd2KFS48SAzdz7jSZuYqBuIzh" +
		"NSH0hfIeZlunAkbAEbGwm$Ct6meOTO$DYWqFiQF#Oq#t5aPny9##WvuCtXb6XxJ7ZxHFzxP" +
		"tXHZlyJZqlQKfQYFfhZuZo27oVojgUD7y$XTxoCBgTFxwFCkk7ix2rXR$qeU8zoIhpz1U7j" +
		"7RvWoF3Y75#vf2dbA4Byg8lpACrF#B7aZ2wdps3pREqbOIyhjIdz2QT0dnYol2WdyLwcV4p" +
		"n$YwzvZyHvDD2xluUJcL27qoDYNNnbUJCmsc7JMXF2NjQBb8M#vvnEdw5pyhPmfPmfHpXRB" +
		"4CcDCs70fSUNtRC8a8D5h2QBkh8MNbeuLGHz$hKuoPIzfIbjnvoEs8oxPx6grolPjuzqmY6" +
		"gttaB27VX2y1pbbvNi8eOw#soTF#nvHAKkHv44Nvr6Qdq3yeBCjrxiCfWIYFSBxEE0gdxNW" +
		"b1t$#uJBTUxooVEG#rmfHv7TMIxEepGVMcPpO0A2sTH9jCqs#XWJ3OmH6QkY$c6#18EhlhD" +
		"elzm$k9nxHYMlTkkeL#nwVIAHVuhMl1u$R5RPU9tbfr7fDJVzZ0hSetIHFZQVwNEwy9e4VN" +
		"bKJEQj3gdhSdG9$F$rI7#H4Y$$Cttg3kzJXUuLttzm2V#UZ5#Lvdh55O9uVSglLRc$VuJ#J" +
		"ZpnbNSidhM#u#BPiDg9ngbjGhcpCFiZ#mzEdJAkffRnd#XEp6dSfehnVbxkSn$Jqz4RqwiT" +
		"LpbrJXT$RNMV6N7x8#knup0zZzBygkzTg$JtkFtEyzKCoNtEf3gR6AddmiyDtvR#tE#xnAp" +
		"XjhJj#NiaUoYfozQzhChURSlFbgztLdZf4H8sr2CScPt8vKmguMTaUUkOsf5aZ4Ho7nhrxB" +
		"DHhMfNe$RBVRHKvPAjlHDXXeJsFMoGp9OlfSwTFgcN8ttYRMgHdf57BFT9BGvVjFtoeY4$p" +
		"Jcvje$irrNrm7giFHXAXM3TOBrWWs18aF#iFgbxP9NpxpTLbljjbUL#NsMvKLMMsxFASeTL" +
		"MUxAAiizMgLtrbPPxXTLbjkdod87LrbkR9NbJgsot0LLbfjTPRadgoptONNbWXyadrOkrNf" +
		"ireBXBZWIzePnBkBvAr8aoqhSIcfMLZtC1KTcPOrpZfVGOgI$ue3ShnnPIPoJQwgkaVw20t" +
		"A$S6GbSKwkgRf6#aiEoFtIaPN4ERccwaQoY3NPZ0lpmtz7Jv7TQwbsF3e5UhR4k6p9iIDhE" +
		"Sh5F0#NaMx10Raj75b9d9DhggwH3kM0t517LXBdv9ggQwIRSq1kSqTM4kVacgfhf9jnG6up" +
		"HrOIv#IQgXl9FAPvvvmb$lFygaP2R#M28s5l6ESYde$2yYB9v6YEybcZMWIJ$PaTrJh58AZ" +
		"kfFKVhaLqUOMQxdsWgcho$m1KNREIlRQGLbvBfyjzJdjhxGPjMbs#M5VKMb5hHQqLjLRKog" +
		"z5$sTg#Q$q#xBjxKb3rAIuSkfzsJSjTrmREcPI$YVEZ7HMczBPRKhdqCRwOshZfUNzxF2p9" +
		"367UnBNSKRkdYUoDdc$xMD3ekFZY1OR7c8XOo7EyHNwlsA2rg$Yb5ZvAlnIoCLVWlUbVBhn" +
		"I$DyZNFnyyGuTiyJmm$1an2HqVoXAnTEeu7sFmM$b2i$Ivj6vedwH7s7$F#Wz$Go$iz2VRl" +
		"xxqAhX$Hjhew#8q7tHoLkLz$gsnDqMpX7t#QJ7GV#LC3zFlcZbFslIVFCDtx$08KwPGOtvx" +
		"#3R4iL1LIW6YfIBTLHFPKmpW6LXJC6cZfJ5oaRqALHgLuerOUQKQelzQDLQJNgJwlJ6ZG0C" +
		"#vgceYxtxLeCArDwz2wE5clXxFr1fWvPs66$52UOF#O#9DZH4D46q7RK7Y#qpuCDg#4tvRf" +
		"rxGDLYC5Ne6sfz6q9tnvRzg7zgNzK6QN7FHyTUXhWRyUwEUZR9bEefDnRZwLJgFJQQoWfmn" +
		"wOo4V$T0KUX$DK3gQZg6$qj$eMA3$1zQK4NHhX7wIeCzY7K1tW5UExDK1QsplCh5NeYi4Qp" +
		"63TOheoSVQEuMLxVMc3mJ3K0$3C5mRl9wUBFnqJ#zFVw43WA5t1aDlqPAFuQKK1jT3MGpl9" +
		"30e#Zndj1s6gvTgpEwj6aEo7mZI01ZYiHeBwNkGtvtR3xNq87rH0SFJAGozwHgw5lQp6DvA" +
		"OVXN2iDbaYx38vhX5saC2XvHg7Bc9NsNqAe0zcka7#g0uGQBuK79PtstCrhLWJe2IzueyNV" +
		"U7ao7qA5q67RKPjHCOsKjHrV0MflntTvsbKZtLsT8$FxgbUelHdWPv5s0uOeC1fQ#M073FL" +
		"NFzH8z2GpVM0oiau0XlQ8sK2DmD8dShAY#HbulUg4jVL2t1NNhlBejMBa7HNLhKtM7I3ckE" +
		"vnUHbd#$Fwcz7ESSZO7RmlQqfviHg6zbzChuBdsRaU$yThx9TexAdSly95$dK6#7yhwoCzA" +
		"p1WV#HjIboMtO3J60FcLa73T5aYIo6iyv0xH1BeO#yebz7T1VhLeKbXZ2z0wIdGosiuq3Ln" +
		"ZCM#jc8dU7rtbMk4i4xGEbJqgNYlgFByxswwPvw76#HY7hM1vRCRoR#btzFiAbllahDQyFX" +
		"I0OAWtvuP9QWHand8P$TUUjusMVYycHgrSSSnUIupPMAaRUpkFsTbILw6roJ4xAp5c0ooYV" +
		"6#x4fP7jOcwJYpN9L2h1EekYJtVH$sgr0s0tfGOWZBZf2wtEudwKW$rPK2z1BFaYWgefrI9" +
		"EZb3PYLGrtXrLGArolGrSxbkCsH9rECyr7pM2u0wrikenq1l07JChGvrFByKVBZGBkhaAk2" +
		"yTKXKadUe1nAentYe$REOeZDHbr6VwxM$FTJZSjQYBWdKptXrn#MYTYVQ8Gd#cAL67VTTUw" +
		"YV5TGilTnhguzwxFSGTNFADytAQ51F1MfJcjUq1uX$nO1HTwMLQ6NgHgjGT#f1FL6Zc8Dwl" +
		"mJgveHVAxI2CLsCsAtxAj6QKMWDunsFrbo0kzwB82#X3kFDdexkgtWwkZzpNw90R3i#SJo5" +
		"z32a7y7w#vXTVyrkiBreKpWp5UZV5MptgcZxkHpR5Dasuy4rXe7Ai3tKsZOrjgVdPJ$O6ZM" +
		"sXUsHERPthcYxMBNjejWUbh9jsiqzLSYzGp4Zk7niNvLh#oRKKB1zMuvjzjnyswEhjZrQR4" +
		"zFsVOzk9cUoDWUZdQFgs3xqXpROoBR$icIL#wutSRFjxT#VfDTOxFjPlxOAllSdN36G9Asx" +
		"VlvkzANsyD#qTflniahRNaQVG9DrLaUZpurcjAMkyYTrXFHcNvuwaoVN9dkokm2RjViGxEn" +
		"Cl6TLXTwD5hTU6MwERK2rSfzTtfbwhpKw#bmh2Fyluv5M1jL4V5JRQobnMWj7Oqqzs2bjRJ" +
		"KxbfQcpYFdItjhyEfRGpEg4L1t2MpbZA#Oc8NphlFDAULwkxT5FInPUw9v3YtG3O2CZFEmw" +
		"MVjfVHRfAsvQqdmzjusZ0iOvdiwNquB7CzTteloxmgU$DgD2npNBQdz#5BTNfN6SjdMyldm" +
		"VBvQAcph3AMXyEotzixvAnZnOfhQ4l6yjPYUHZsWMHlRosMYvxbhLEMjywnt5BHShRDjrGO" +
		"PtF7KepkMCpp1DzothvHkSrPovNQdBRCNlLzjZogwhsoicML6UUqvQnljzNcuHKiZn7ByTE" +
		"2ORGeOtcqx1Z3eXr3vUvLbNQCj6#Fnwmocioisi6UbTtTUB7YKw2y7ID$$PqThR#F0XTho5" +
		"z$MUzEg3a4DSVZ3i$WIkuOvAs$NFu5x#bAYwo$3jdRqNCXBfUsjJLzAgjX#cJ7PLkejOhdR" +
		"qVGaNIKtUNuok4uEfvEe1E1cLUyph3IcSx07V18s3e7Ty0xe4VurBgZXzgSB1ng5Q6#1vmq" +
		"QkuxFfSLKgYV52tLezu5jdUnOrcAK9jrslZY6OX7uhHr3ZnX1z5Ubq7TEK9TYb3tokbhKpl" +
		"hgQEN4lKmxpvEfL2F1UgpWPf7z3oWFj#Ydje6wZKzr2g3#Yfx5hmXXRepz8rU2jJndF0zX0" +
		"GrMGyv6wW9gCy3wlDbhlceIKu$3dMnJR$cfsevkxoMrtT53Gr0ZQkWHZmI6Cy1nXsGharwY" +
		"BLeKIFL1cf8EsDbQ4RytL0hb2xGLHPD0ZNEzbiZTGREzcsWjXeog0L71hLmCwY9m0c0Ebeh" +
		"aVVMIcbj5rWyYmgY0MLmbRKISGlkp8VAdRdp45uhHm0rwzeM7b93aw5hHxhHhfLiPsUw7NN" +
		"lJAoLztbhPHObhvM25A5jf6xMkPBUSvMuBb8b#ro5jIgCj9rnrWk6K5dw4$SEY4SdaDxyNP" +
		"5Y1W4fUES1xVbSIdesxbCp9bj5zO5KIfGpfr1#XXxjboYnKGAfyf0wF1CGJwGnk5RTfxYEX" +
		"MLNRgrAVOgqzAcaZ6$wCsi8uc6kJv7#ZdrAy$AGYkQF43wcnOa#$KeaMz6tk991YglHPVgK" +
		"#7cfM33lI3jhPHyfUFxpALV6UPKWZVIqwQUcX7XVTFeGf6RbT1egtFrPwP1OJxfF$rj8jNt" +
		"b8usaGtJYLGcfphoMna#ZEYkGha2w0kaAf2kG$gz36f$9$JjalKodMykl#apkeSHfDxh$AR" +
		"ax2SrdyauutNQXSv3UmPRTiRtxYFyEPgcNkVjXp3fnzuDStVB5tDvT1EuUp3doB1hgOJNdo" +
		"17K8hbjOypsT3OIOJBk5dR0tSDawUSRsP$CtGD2vYv29yuytpyVNu7fluKfOUL$3IPpr$IV" +
		"mSJFLcqgnXGzMxKInbHftVaFzLCQKqQo0jCAJFyVOC8rzTbBS4gotvLjgKxB3vDhwGfComD" +
		"JrSzyCvWYBLK$DOvEn$o9OV$KDeckmwvolSwSskWEiP0zjK43UAqYdOC03RXUJtENzkmfxy" +
		"IO4NbVyZwk7QCH#G#TW8rjgUE$s$Smuwfict5bNwvFefsOU$L3xjLCoJkgm3T7IWwGwzpyT" +
		"pcrJhxBcR3XdvQ7oNK4WhpBQV5j7ptFjlrjPe3vZvqSJsSVpdYwUyASv#dnccXdNzNpYk$V" +
		"ygmbMcZk0UHp1Yd9CiuhVZUR#sRPUfikJt16G1jw6wcgjFbFOqMRFHdRze$0c8WsuKLFoAM" +
		"tsMjV5xxhBTFRYHwmDPknrYLdSXMVKqAzCxMvfputnviD6dV$LIyhwaZZJxZ$Ca$85UsKVD" +
		"$9rdMVCgymLfNdk9iRbVeNwqfcj28qCZVYkrp9ZRIZzJ#6kFtPN1rYA$rEYB$h4uI8aq9iu" +
		"$znnBpYf14lknzZfZVvdnSLNdfSbwCVewprOzefpolo#lY$XtXP$BXzhrWsnF7#xdIr$wJA" +
		"d14Jkv4ynSDkn4$4MWLnbzm#xfFdnphrCgstwIpY7PS5Szf6tCUoIxHMcdaLLhSigWXpdbU" +
		"Oyz3oyWf1FEAx8lQq$yVz#FkBsFFZeKa$DeYJVepKJf8tVhnprMUefVhSYcr1rUkrkRFmUi" +
		"VqvpADdVs4QVJSqPwl7whkF#ki3dEwikThMe3mUAI$ZQS0z6QbTomabNh7GdYLxZyghX0or" +
		"$DNjRRxkpM1sdYrUJ8$KhpR$4yX$tVCZlPJ6cP$x2B#R4OaMjFHRoDJ$R1ZrJwob6Tmp#hG" +
		"s6hapqlb9SlRtzC#Yx1GSkd$bFtCxd69fn3fkb6#xVF2mwas9JooRN$Fz4SRVhPylLDNU6N" +
		"V7R9hRgKdvsOdoddYOlOl$svL##$2BU#LRjdEppNHwbQj7ShPg#FLo8psZ2f7UqRQioITBh" +
		"$SUa2q$v7#HBlIdsatsfts#9yQXHNbLfJxNr5kcTPZVoNLYITwiXv$f$STl9KrN$#ELJt3I" +
		"tqUL9usUl$T$dsiw$U96nUfMnUFYvKktOutGCu7hTc#hBphVH$wu$im3cuaf6xjqex4iiyG" +
		"YLjy199Y55KYo9$PTl#kU6RwRzRIMfwrvwy$hMtthb#JQgklMSbUMqZRky#fOgrjm#honRg" +
		"YrefQAsgjgBMYLdujhV#lrF9VwVTbgzYJndYrC#$B2lVSTdJyvwIastWPQOLFtV1tLvepGI" +
		"VjdYVowPUV4#K#WQ01$0IYabIRvnD3qk$V66jQopStC8vERUB8URzIk$VRifzJ668qH#NYR" +
		"nOR8ZxFJrpu$m7vdCfs#Ncf$$JIFD$gGpNH$n16JmBbQL0dQeR6vFCTUMTCD3RJ7rAoPkZ9" +
		"#qHC6#ysv4dZbchjuqhKofo53IwYu9TZv9zv#qt7PIMYbVcNx3OXy#lHDn5rE11nLyHpY0h" +
		"d8hqPKUqZH7NrI3#4U4k8#Hj$$u30tpfwE#JZCNWz4VYNEBObwZi8DqdlmrO07P05$2sJNo" +
		"1U5sL#X70qmhq8foCy3lxkA7yuKSsRHCMEH6kiZNXly66lq9#e1tGD6W3Cg3y8U5RV0$7EH" +
		"AizX$W8elv5OEY1U3MYdWZrzoFzSwBkqDbuB9hPZwZZVOZtGG3UJcZVIXZVJdkY$RyYQWeH" +
		"$n7XFBHxEuHh4Rv5dP48ro1yWx9ernfx0TC3I5#Dz0b8tupuCiJ0N82EDUv1l2fYu0h#WlR" +
		"0AzVuD#BRW0VzjV9hg8jsTqDREdrDDA0H$V84KUTjaCQuqak8WLiLK0RZiFefq3SMygiG$m" +
		"01SlvcwnhqTG7ZrlWnsdqHKVbFg3SAyJIKNKBKvTUGeMtzZqFPeSXVYVWNmDG0dLSW7e7yR" +
		"w1Z1yJ3m4FVrEw8ViEuDF9OlWqx6oEW7slGPuqV8aOxow#YhzP2#aAKXOqQsAj7NnKmRZNe" +
		"bveV8ro005p198pXLj3Dc86fK8lqvz0DFrD$Xtnpb5i0t3pkZFahb4TV5rS15lXDy1HieSz" +
		"wS7teQJePEEJNHf6kWHnhIV0Asji5VJKLyMYYLU07Ar#76DWw0zig4w2tC#BvYE4ptGSZHj" +
		"d#a#73dH0$33z07$L$5$5ZmCVrko663nNHFmF68NwGg1SmzOLlbFQ3$yz5V2VQyoXayCq2#" +
		"o$ygNGKmgT88ry3V0fs2i1HZxxeq8fqRvI7l0v#Kpe0RSHOrCAVQmSYe9rzKA#0kLM2xpV3" +
		"5qheznBwjkUci8$olJ4sBS1MYtwgHN$qXUyLC2vr7P0$3JON8RqHR62U5Z3sTT1VU1enojP" +
		"YBjTXRZQiYNbs4lIZ3TWtg0Pph05nUMkqzGR46BC#p8E$jS8lwZ0dMd#B$eElrG5FTzZg$Z" +
		"lOdeWyzBHokr6l5ZvLnDWMuVj5u2r2Nel#hZqOuIEKHR$NNuf#k17vjv1lGS3yhKKRQZ3ET" +
		"T1VW4$KmKTQi3xqVXPfnWpVhKF$rM6CwZ2$wh1czSGubp1dr3EmSmVqeav3MRx3a#hX2yLZ" +
		"4ACFw#4V3PZRnHUGXb$MOpwLu6yDmDYCDQ4xvcW$uExAwzdba6CC1i1cxNf8Gzw8TQ8UywO" +
		"CFwcVWHZjhyTwL9wD6FtQWFRNluCOVb#FDjQ$YF0PV1DhpHhebxhdaSUOy1GlyRXYJZS1Mw" +
		"aECVgbRXxIw9SIoZTXtIXXVMd1UjCJc4eOfoRW7W2$BM7DxWC$2k3BzLY7Ekm67iQo11yPW" +
		"3ufmKVxODngC5TBFyFOm2TAXw1Dc5Cbj24OZdQYRqfeVmUCTGb#FX1hPGdbMp2dQyz76kFT" +
		"0VvQGb#NC4O3Dq2CDhKmBjWjePy3#48FO6tbDHBzq$eFO8My5zeQO3qO28mTiDOreEzxxOl" +
		"u9uWnTpfY$ZMW$RsRaJuLQVHZRypvXYCHFuduUE37Vj40N##3SMw0hJwOryt0qCHp3Uj50z" +
		"RTnajG7txLW7dI0MFI02mD6AkETo76k0w4tzPX31lWZnqnZWte#uxemmQiu$MOroNWQO2VD" +
		"P#9iYSY3TmTiPurmXyQiFuEX0yqOZnQC8ODADC8#pLOKtiffE5Z7T6sHkWVY7vgn7pfZJsh" +
		"4MjrfoR4mDI0FR8H#5enNerenq0UVwofZUZd0doz$ajWW3DqvBqHQrGZojLmkp4kPVX6pQr" +
		"8e#yRiVQMuSzbZ54Fs6ly8GBwRI36fX7#tmYzPLvNiPwNiU#KiPTqnTfOUnRw1VtHYlvhu7" +
		"v0VpLWxMp5tj0HUsHvV#30E9UnVtJiXG1v#J04x2zbr2l3HXbzsBWJOXmHokY3yXJKEGFzY" +
		"ZvinDhJYl4iOWqeOovtvBq7#qSjzl1Q#5G9Ur8PwtS9$TY0T0FMZGRi9GsO8nqm5cNOBCE7" +
		"Qe2jZ3saZB7fWFMp5ULRuBCTuGSTCDRDE7FqUGD#Z3sW7toYuJtONXryxeVhKGyO1d7$e4u" +
		"FO6w2Bwo6DZTXF9lWDqtejpB6hGd#reGvqiI$mWt$xCqyhEkj6CychBcjgDS4d#YDELBN5s" +
		"ciEttGjgOVc$DHXoDDNBoJOvCkyAdg20JWea66Hsl7ShMxYUlMT3oJhvrYvVojzaDCkedF3" +
		"ot9Scgcdq$AQ5ISxhT5LgxkDd6F3MsPgqsy#c8J3$f9NBPb$pZTSvg9LxuyvgsyqCJTDl3i" +
		"Nra9cuThd9UURcEivS79DlsUZR$XivD9hzefgQFRt#9qzt$6wRusNhM$9r#Gh5itnyIggyL" +
		"yOonRzOTPlDqtpk7jPEAWNynhFYLPHest#alf#ibomS5nclecPJNs7DvyYTV6bR8wLjqgcQ" +
		"SbAJsFj8sXc#sJLRhO#k#OkDVADjxVnW#PUFLv9XwqYutti$4nDZxTm$P73yS#c1V7UsrVY" +
		"$SiBt#xBNSn0lQr8lyM8FQFEgmPXFckS0uexjvMMqpzubmJrnrdyrXNYulCUIgOwfN3daUt" +
		"nFd21IQkn$vPm1aam5eIp75oO5zYyK7M5Nim$wfBpLPn$LKFoM8fd1gdwxecPNK3upJ$PtR" +
		"Gs5xRilfBM3EBMAFgzbgwUaNihmMSCTH69b$6UQBcCIlRB2xNWBDCyU8KxirCt6ZNlrudUd" +
		"rm2fydgyDGzxM9wrji$hHOrkETE1tS0jb3oRg5zvBvcitZTFsc7fvBB5QiCRLFM$dPdlmcs" +
		"$vrOCFwRzd3qMJdGdc1hJlLrfjbvPkYVnumwTAMdjuNJTmLFbVthfKVXFnk5g$uEdpg8w$E" +
		"#rp6RvUjvysPqfIqlAt0zzLnkeRF5zDDkjZRq$c#YPknHv9jP#bR4pSCYiiLEyNf5fn36h0" +
		"VDcmSyrPpvVOnSOTpRDxsUyCUjjnA9gwtQt33uKdCzKUOkE#tCQ$dw3WzQ7tRDlX#0MUGmZ" +
		"j#VIDhj7EvNsSFty1acNwhU#MVIieQ9iRffXCy$cksV4vV5sm$#lvJteZN5IImdpLCntp3F" +
		"LCZxa$ARUuBxGNKv$l#LfEkmrcgwpMnZvQn7fHn5YhkLhd#QZ#nxIYRkDVhjgqzJDnXa5yU" +
		"VdesU3jNrbUtVZBFBxK5VKiA8SWDk7j0KFGnmcBa5oF#YWeq7#dvyctQYYRYdcqYrI8q8ZG" +
		"Wy3Tv5#a5n9$QyBQ40ir2FVx#UWwVU#5B6ov6cMSH9qDGWMVupqZWNn9J24JF8SPT8JsF6A" +
		"Ti6eyO9rYw2Z5EpdG3yJU1yrEo6lbswhkGnzq7Ga2F8ZrRGa0FLWXFesrVeyoJI2z1kvT0p" +
		"mM8Bw1wXC264aAZfE#LG7GrR5s8iXSXlaZY8er3UW5qBK3y468EqoGKw5R8NqEvRr3$Jl0u" +
		"t8xqP0a5Eelubo4Az2xuxoA#3ULlaxZ6YnKzWFGLA7iPyJST5X42BzGZyFVR5UXr6ou7rij" +
		"HzWIqwMR4DuDt3ShoB#9yWVX4b7yAUev7$0JY9y0x2V594XTi2591qSdGTpBIRo3z1igSWZ" +
		"gd0EERoBy9$kFWyU$fl8LmAlWBmL#8z6VWBqB#DDG$7U48y3aSXVgtI0ZeIEIFHBaZaJySi" +
		"Gc1lDDy6DBvGT4X28TAA2J2mU0TB74S3WJlGEZaS13I1u77ON#aAuU25yTb#LTPhWVMww5h" +
		"BlXpmNCn$#BK93A$INKTOWx$GFgVY3#KKA274J#Cc7#HVWRICv2UWtWEucEXysz8$rL2WOv" +
		"6F1RXBmW7m2x$JiU#ABCFOWvxemo7FP7ci1Taeub$AOL38B#Qme6$Cvd3LAIFWTrZ46CtH5" +
		"24kqC4HVoxRpCHuquIGT4Z4W9#8egW27U128hu2U0dY5z6$39YhBe8Idvtv4fIyaiUKn3FG" +
		"pmFCJ#X$W0nxcBb#qJFaH0GxlmH59z04HJXpX51yHDF14Lt4$zoaYBiXF8TXoyYVX4nxfeH" +
		"#Bl12K7HkHBuTni8GT6O$mTHCHuv");
 // Generated from C:\stuff\workspace\JModelica\Compiler\ModelicaCompilerCasADi/build/modelica/parsers/ModelicaParser.parser
/**
     * Error reporting class that creates an error message and delegates reporting the 
     * message to a subclass.
     */
    public abstract static class Report extends Events {

        /**
         * Report an error with error message <code>msg</code>.
         */
        protected abstract void report(Problem P);

        /**
         * Creates an error message for when <code>token</code> is found unexpectedly. 
         * Passes the error message to {@link #report(Problem)}.
         * @param token     the unexpected symbol.
         */
        public void syntaxError(Symbol token) {
            
            StringBuilder s = new StringBuilder();
            //s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
            if (token.getId() == Terminals.EOF) {
                s.append("  Unexpected end of file");
            } else if (token.value != null) {
                s.append("   Unexpected token: \"" + token.value + "\"");
            } else if (token.getId()<Terminals.NAMES.length)
                s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
            else 
                s.append("  Syntactic error");
            Problem p = new Problem(fileName, s.toString(), ProblemSeverity.ERROR, ProblemKind.SYNTACTIC,
                    Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()),
                    Symbol.getLine(token.getEnd()), Symbol.getColumn(token.getEnd()));
            
            report(p);
        }

        /**
         * Creates an error message for when the scanner throws an exception.
         * Passes the error message to {@link #report(Problem)}.
         * @param e     the exception.
         */
        public void scannerError(Scanner.Exception e) {
            /*
            StringBuilder s = new StringBuilder(e.getMessage());
            s.append(" at line ");
            s.append(e.line);
            s.append(", column ");
            s.append(e.column);
            */
            Problem p = new Problem(fileName, e.getMessage(), ProblemSeverity.ERROR, ProblemKind.LEXICAL,
                    e.line, e.column, e.line, e.column);
            
            report(p);
        }

        private String fileName = "";

        public void setFileName(String fn) {
            fileName = fn;
        }

    }
    
    /**
     * Error reporting class that throws a {@link ParserException} on an error.
     * Uses error message created by {@link Report}.
     */
    public class AbortingReport extends Report {

        /**
         * Throws a <code>ParserException</code> with <code>msg</code> as the message.
         */
        @Override
        protected void report(Problem p) {
          throw new ParserException(p);
        }

    }

    /**
     * Error reporting class that collects error messages for later retrieval.
     * Uses error message created by {@link Report}.
     */
    public static class CollectingReport extends Report {

        private ArrayList<Problem> errors = new ArrayList<Problem>();

        /**
         * Adds error message <code>msg</code> to list.
         */ 
        @Override
        protected void report(Problem p) {
            errors.add(p);          
        }

        /**
         * Get the list of errors. Returns a reference to the internal list, not a copy.
         * @return a {@link java.util.Collection} with the reported error messages.
         */
        public Collection<Problem> getErrors() {
            return errors;
        }

        /**
         * Reset the list of errors.
         */
        public void resetErrors() {
            errors = new ArrayList<Problem>();
        }

        /**
         * Checks if any errors has been reported.
         * @return <code>true</code> if the list contains any errors.
         */
        public boolean hasErrors() {
            return !errors.isEmpty();
        }

    }

    { report = new AbortingReport(); }  // As default, throw exception on errors.

    /**
     * Set the error reporting class to use.
     * @param report    a subclass of {@link Events} to use for reporting errors.
     */
    public void setReport(Events report) {
        this.report = report;
    }

    public Events getReport() {
        return report;
    }

    private int[] lineBreakMap;

    public void setLineBreakMap(int[] map) {
        lineBreakMap = map;
    }

    private FormattingRecorder<ASTNode<?>> formattingRecorder;

    public void setFormattingRecorder(FormattingRecorder<ASTNode<?>> formattingRecorder) {
        this.formattingRecorder = formattingRecorder;
    }

    public void setFileName(String fn) {
        if (report instanceof Report)
            ((Report) report).setFileName(fn);
    }
    
    Symbol annotationTok = null;
    
    private void adjustStart(Symbol... syms) {
        AdjustableSymbol[] aSyms = new AdjustableSymbol[syms.length];
        for (int i = 0; i < syms.length; i++) {
            /* All symbols involved implements AdjustableSymbol, but since we can't change 
             * Beaver, the Java compiler can't verify that. If any Symbol used doesn't then
             * we want to know that - thus the raw cast. */
            aSyms[i] = (AdjustableSymbol) syms[i];
        }
        if (aSyms.length > 0) {
            aSyms[0].adjustStartOfEmptySymbols(aSyms, 1, 0);
        }
    }
    
    private static class Bool extends AbstractAdjustableSymbol {
        public final boolean value;
        
        public Bool(boolean val) {
            value = val;
        }
    }
    
    private static Bool newTrue() {
        return new Bool(true);
    }
    
    private static Bool newFalse() {
        return new Bool(false);
    }
    
    private static class RedeclareReplaceableHeader extends AbstractAdjustableSymbol {
        public final boolean has_redeclare;
        public final boolean has_each;
        public final boolean has_final;
        
        public RedeclareReplaceableHeader(boolean has_redeclare,
                                          boolean has_each,
                                          boolean has_final) {
            this.has_redeclare = has_redeclare;
            this.has_each = has_each;
            this.has_final = has_final;
        }
    }
    
    private static class TypePrefixes extends AbstractAdjustableSymbol {
        public final Opt<SrcTypePrefixFlow> flow;
        public final Opt<SrcTypePrefixVariability> variability;
        public final Opt<SrcTypePrefixInputOutput> input_output;
        
        public TypePrefixes(Opt<SrcTypePrefixFlow> flow, 
                            Opt<SrcTypePrefixVariability> variability, 
                            Opt<SrcTypePrefixInputOutput> input_output) {
            super(flow, variability, input_output);
            this.flow = flow;
            this.variability = variability;
            this.input_output = input_output;
        }
    }
    
    private static class ConstrClauseAndComment extends AbstractAdjustableSymbol {
        public final Opt<SrcConstrainingClause> constr;
        public final SrcComment comment;
        
        public ConstrClauseAndComment(SrcConstrainingClause constr, 
                                      SrcComment comment) {
            super(constr, comment);
            this.constr = new Opt(constr);
            this.comment = comment;
        }
        
        public ConstrClauseAndComment() {
            this.constr = new Opt();
            this.comment = new SrcComment();
        }
    }

	public ModelicaParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 7: // source_root = 
			{
					 SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr;
			}
			case 8: // source_root = program.program
			{
					final Symbol _symbol_program = _symbols[offset + 1];
					final Program program = (Program) _symbol_program.value;
					 SourceRoot sr = new SourceRoot(program); 
       return sr;
			}
			case 9: // program = stored_definition.stored_definition
			{
					final Symbol _symbol_stored_definition = _symbols[offset + 1];
					final SrcStoredDefinition stored_definition = (SrcStoredDefinition) _symbol_stored_definition.value;
					 return new Program(new List().add(stored_definition));
			}
			case 10: // stored_definition = within_opt.within base_class_decl_list.base_class_decl_list
			{
					final Symbol _symbol_within = _symbols[offset + 1];
					final Opt within = (Opt) _symbol_within.value;
					final Symbol _symbol_base_class_decl_list = _symbols[offset + 2];
					final List base_class_decl_list = (List) _symbol_base_class_decl_list.value;
					 SrcStoredDefinition def = new SrcStoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
        formattingRecorder.postParsing(def);
        return def;
			}
			case 11: // stored_definition = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new SrcBadDefinition();
			}
			case 12: // within = WITHIN.WITHIN access_opt.access SEMICOLON.SEMICOLON
			{
					final Symbol WITHIN = _symbols[offset + 1];
					final Symbol _symbol_access = _symbols[offset + 2];
					final Opt access = (Opt) _symbol_access.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SrcWithin(access);
			}
			case 13: // base_class_decl_list = base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_base_class_decl = _symbols[offset + 1];
					final SrcBaseClassDecl base_class_decl = (SrcBaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new List().add(base_class_decl);
			}
			case 14: // base_class_decl_list = base_class_decl_list.base_class_decl_list base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_base_class_decl_list = _symbols[offset + 1];
					final List base_class_decl_list = (List) _symbol_base_class_decl_list.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 2];
					final SrcBaseClassDecl base_class_decl = (SrcBaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 base_class_decl_list.add(base_class_decl);
        return base_class_decl_list;
			}
			case 15: // anonymous_short_class = extends_clause_short_class.extends_clause_short_class
			{
					final Symbol _symbol_extends_clause_short_class = _symbols[offset + 1];
					final SrcExtendsClauseShortClass extends_clause_short_class = (SrcExtendsClauseShortClass) _symbol_extends_clause_short_class.value;
					 return new SrcShortClassDecl(
            new SrcIdDecl("'Anonymous Class'"),
            false, false, 
            new SrcClass(), 
            false, false, false, false, false, 
            new Opt(), new Opt(), 
            extends_clause_short_class);
			}
			case 16: // base_class_decl = has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction id_decl.start string_comment_opt.string_comment clause_star.clause_star external_clause_opt.external_clause class_annotation_opt.class_annotation end_decl.end_decl
			{
					final Symbol _symbol_has_encapsulated = _symbols[offset + 1];
					final Bool has_encapsulated = (Bool) _symbol_has_encapsulated.value;
					final Symbol _symbol_has_partial = _symbols[offset + 2];
					final Bool has_partial = (Bool) _symbol_has_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final SrcRestriction restriction = (SrcRestriction) _symbol_restriction.value;
					final Symbol _symbol_start = _symbols[offset + 4];
					final SrcIdDecl start = (SrcIdDecl) _symbol_start.value;
					final Symbol _symbol_string_comment = _symbols[offset + 5];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_clause_star = _symbols[offset + 6];
					final List clause_star = (List) _symbol_clause_star.value;
					final Symbol _symbol_external_clause = _symbols[offset + 7];
					final Opt external_clause = (Opt) _symbol_external_clause.value;
					final Symbol _symbol_class_annotation = _symbols[offset + 8];
					final Opt class_annotation = (Opt) _symbol_class_annotation.value;
					final Symbol _symbol_end_decl = _symbols[offset + 9];
					final SrcEndDecl end_decl = (SrcEndDecl) _symbol_end_decl.value;
					 adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcFullClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl);
			}
			case 17: // base_class_decl = has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction id_decl.class_name EQUALS.EQUALS extends_clause_short_class.extends_clause_short_class
			{
					final Symbol _symbol_has_encapsulated = _symbols[offset + 1];
					final Bool has_encapsulated = (Bool) _symbol_has_encapsulated.value;
					final Symbol _symbol_has_partial = _symbols[offset + 2];
					final Bool has_partial = (Bool) _symbol_has_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final SrcRestriction restriction = (SrcRestriction) _symbol_restriction.value;
					final Symbol _symbol_class_name = _symbols[offset + 4];
					final SrcIdDecl class_name = (SrcIdDecl) _symbol_class_name.value;
					final Symbol EQUALS = _symbols[offset + 5];
					final Symbol _symbol_extends_clause_short_class = _symbols[offset + 6];
					final SrcExtendsClauseShortClass extends_clause_short_class = (SrcExtendsClauseShortClass) _symbol_extends_clause_short_class.value;
					 adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcShortClassDecl(
            class_name, 
            has_encapsulated.value, 
            has_partial.value, 
            restriction, 
            false, false, false, false, false, 
            new Opt(), new Opt(),
            extends_clause_short_class);
			}
			case 18: // base_class_decl = has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction EXTENDS.EXTENDS id_decl.start class_modification_opt.class_modification string_comment_opt.string_comment clause_star.clause_star external_clause_opt.external_clause class_annotation_opt.class_annotation end_decl.end_decl
			{
					final Symbol _symbol_has_encapsulated = _symbols[offset + 1];
					final Bool has_encapsulated = (Bool) _symbol_has_encapsulated.value;
					final Symbol _symbol_has_partial = _symbols[offset + 2];
					final Bool has_partial = (Bool) _symbol_has_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final SrcRestriction restriction = (SrcRestriction) _symbol_restriction.value;
					final Symbol EXTENDS = _symbols[offset + 4];
					final Symbol _symbol_start = _symbols[offset + 5];
					final SrcIdDecl start = (SrcIdDecl) _symbol_start.value;
					final Symbol _symbol_class_modification = _symbols[offset + 6];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_string_comment = _symbols[offset + 7];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_clause_star = _symbols[offset + 8];
					final List clause_star = (List) _symbol_clause_star.value;
					final Symbol _symbol_external_clause = _symbols[offset + 9];
					final Opt external_clause = (Opt) _symbol_external_clause.value;
					final Symbol _symbol_class_annotation = _symbols[offset + 10];
					final Opt class_annotation = (Opt) _symbol_class_annotation.value;
					final Symbol _symbol_end_decl = _symbols[offset + 11];
					final SrcEndDecl end_decl = (SrcEndDecl) _symbol_end_decl.value;
					 adjustStart(has_encapsulated, has_partial, restriction);
        SrcInlineExtendsClause ext = new SrcInlineExtendsClause(
            new SrcNamedAccess(start.getID()),
            class_modification,
            new Opt());
        return new SrcExtendClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl, 
            ext);
			}
			case 19: // base_class_decl = has_encapsulated.has_encapsulated has_partial.has_partial restriction.restriction id_decl.enum_name EQUALS.EQUALS ENUMERATION.ENUMERATION LPAREN.LPAREN enum_specification.enum_specification RPAREN.RPAREN comment.comment
			{
					final Symbol _symbol_has_encapsulated = _symbols[offset + 1];
					final Bool has_encapsulated = (Bool) _symbol_has_encapsulated.value;
					final Symbol _symbol_has_partial = _symbols[offset + 2];
					final Bool has_partial = (Bool) _symbol_has_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final SrcRestriction restriction = (SrcRestriction) _symbol_restriction.value;
					final Symbol _symbol_enum_name = _symbols[offset + 4];
					final SrcIdDecl enum_name = (SrcIdDecl) _symbol_enum_name.value;
					final Symbol EQUALS = _symbols[offset + 5];
					final Symbol ENUMERATION = _symbols[offset + 6];
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_enum_specification = _symbols[offset + 8];
					final SrcEnumComponentClause enum_specification = (SrcEnumComponentClause) _symbol_enum_specification.value;
					final Symbol RPAREN = _symbols[offset + 9];
					final Symbol _symbol_comment = _symbols[offset + 10];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 adjustStart(has_encapsulated, has_partial, restriction);
        return new SrcEnumClassDecl(
            enum_name,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            comment.getSrcStringCommentOpt(),
            new List(new SrcDefaultElementList(new List(enum_specification))),
            new Opt(),
            comment.getSrcAnnotationOpt(),
            new SrcEndDecl(enum_name.getID()));
			}
			case 20: // base_class_decl = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new SrcBadClassDecl();
			}
			case 21: // extends_clause_short_class = type_prefixes.type_prefixes access_scalar.access_scalar array_subscripts_opt.array_subscripts class_modification_opt.class_modification comment.comment
			{
					final Symbol _symbol_type_prefixes = _symbols[offset + 1];
					final TypePrefixes type_prefixes = (TypePrefixes) _symbol_type_prefixes.value;
					final Symbol _symbol_access_scalar = _symbols[offset + 2];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 3];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_class_modification = _symbols[offset + 4];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 adjustStart(type_prefixes, access_scalar);
        return new SrcExtendsClauseShortClass(
            access_scalar,
            class_modification, 
            new Opt<SrcAnnotation>(),
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            array_subscripts, 
            comment);
			}
			case 22: // enum_specification = enum_contents.enum_contents
			{
					final Symbol _symbol_enum_contents = _symbols[offset + 1];
					final List enum_contents = (List) _symbol_enum_contents.value;
					 return new SrcEnumComponentClause(
                false, false, false, false, false,
                new Opt(),
                new Opt(new SrcConstant()),
                new Opt(),
                new SrcNamedAccess("EnumType"),
                new Opt(),
                enum_contents,
                new Opt(),
                new SrcComment());
			}
			case 23: // enum_contents = COLON.COLON
			{
					final Symbol COLON = _symbols[offset + 1];
					 return new List();
			}
			case 24: // enum_contents = enum_literal_list.enum_literal_list
			{
					final Symbol _symbol_enum_literal_list = _symbols[offset + 1];
					final List enum_literal_list = (List) _symbol_enum_literal_list.value;
					 return enum_literal_list;
			}
			case 25: // enum_literal_list = enum_literal.enum_literal
			{
					final Symbol _symbol_enum_literal = _symbols[offset + 1];
					final SrcEnumLiteralDecl enum_literal = (SrcEnumLiteralDecl) _symbol_enum_literal.value;
					 return new List(enum_literal);
			}
			case 26: // enum_literal_list = enum_literal_list.enum_literal_list COMMA.COMMA enum_literal.enum_literal
			{
					final Symbol _symbol_enum_literal_list = _symbols[offset + 1];
					final List enum_literal_list = (List) _symbol_enum_literal_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_literal = _symbols[offset + 3];
					final SrcEnumLiteralDecl enum_literal = (SrcEnumLiteralDecl) _symbol_enum_literal.value;
					 enum_literal_list.add(enum_literal); 
        return enum_literal_list;
			}
			case 27: // enum_literal = id_decl.id_decl comment.comment
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final SrcIdDecl id_decl = (SrcIdDecl) _symbol_id_decl.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcEnumLiteralDecl(
                id_decl,
                new Opt(),
                new Opt(),
                new Opt(),
                comment);
			}
			case 28: // type_prefix_flow = FLOW.FLOW
			{
					final Symbol FLOW = _symbols[offset + 1];
					 return new SrcFlow();
			}
			case 29: // type_prefix_flow = STREAM.STREAM
			{
					final Symbol STREAM = _symbols[offset + 1];
					 return new SrcStream();
			}
			case 30: // type_prefix_variability = DISCRETE.DISCRETE
			{
					final Symbol DISCRETE = _symbols[offset + 1];
					 return new SrcDiscrete();
			}
			case 31: // type_prefix_variability = PARAMETER.PARAMETER
			{
					final Symbol PARAMETER = _symbols[offset + 1];
					 return new SrcParameter();
			}
			case 32: // type_prefix_variability = CONSTANT.CONSTANT
			{
					final Symbol CONSTANT = _symbols[offset + 1];
					 return new SrcConstant();
			}
			case 33: // type_prefix_input_output = INPUT.INPUT
			{
					final Symbol INPUT = _symbols[offset + 1];
					 return new SrcInput();
			}
			case 34: // type_prefix_input_output = OUTPUT.OUTPUT
			{
					final Symbol OUTPUT = _symbols[offset + 1];
					 return new SrcOutput();
			}
			case 35: // type_prefixes = type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output
			{
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 1];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 2];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 3];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					 adjustStart(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
        return new TypePrefixes(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
			}
			case 36: // restriction = CLASS.CLASS
			{
					final Symbol CLASS = _symbols[offset + 1];
					 return new SrcClass();
			}
			case 37: // restriction = MODEL.MODEL
			{
					final Symbol MODEL = _symbols[offset + 1];
					 return new SrcModel();
			}
			case 38: // restriction = BLOCK.BLOCK
			{
					final Symbol BLOCK = _symbols[offset + 1];
					 return new SrcBlock();
			}
			case 39: // restriction = CONNECTOR.CONNECTOR
			{
					final Symbol CONNECTOR = _symbols[offset + 1];
					 return new SrcConnector();
			}
			case 40: // restriction = EXPANDABLE.EXPANDABLE CONNECTOR.CONNECTOR
			{
					final Symbol EXPANDABLE = _symbols[offset + 1];
					final Symbol CONNECTOR = _symbols[offset + 2];
					 return new SrcExpandableConnector();
			}
			case 41: // restriction = TYPE.TYPE
			{
					final Symbol TYPE = _symbols[offset + 1];
					 return new SrcType();
			}
			case 42: // restriction = PACKAGE.PACKAGE
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					 return new SrcPackage();
			}
			case 43: // restriction = FUNCTION.FUNCTION
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					 return new SrcFunction();
			}
			case 44: // restriction = RECORD.RECORD
			{
					final Symbol RECORD = _symbols[offset + 1];
					 return new SrcRecord();
			}
			case 45: // restriction = OPERATOR.OPERATOR RECORD.RECORD
			{
					final Symbol OPERATOR = _symbols[offset + 1];
					final Symbol RECORD = _symbols[offset + 2];
					 return new SrcOperatorRecord();
			}
			case 46: // restriction = OPERATOR.OPERATOR FUNCTION.FUNCTION
			{
					final Symbol OPERATOR = _symbols[offset + 1];
					final Symbol FUNCTION = _symbols[offset + 2];
					 return new SrcOperatorFunction();
			}
			case 47: // restriction = OPERATOR.OPERATOR
			{
					final Symbol OPERATOR = _symbols[offset + 1];
					 return new SrcOperator();
			}
			case 48: // has_partial = PARTIAL.PARTIAL
			{
					final Symbol PARTIAL = _symbols[offset + 1];
					 return newTrue();
			}
			case 49: // has_partial = 
			{
					 return newFalse();
			}
			case 50: // has_encapsulated = ENCAPSULATED.ENCAPSULATED
			{
					final Symbol ENCAPSULATED = _symbols[offset + 1];
					 return newTrue();
			}
			case 51: // has_encapsulated = 
			{
					 return newFalse();
			}
			case 52: // has_inner = INNER.INNER
			{
					final Symbol INNER = _symbols[offset + 1];
					 return newTrue();
			}
			case 53: // has_inner = 
			{
					 return newFalse();
			}
			case 54: // has_outer = OUTER.OUTER
			{
					final Symbol OUTER = _symbols[offset + 1];
					 return newTrue();
			}
			case 55: // has_outer = 
			{
					 return newFalse();
			}
			case 56: // has_redeclare = REDECLARE.REDECLARE
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					 return newTrue();
			}
			case 57: // has_redeclare = 
			{
					 return newFalse();
			}
			case 58: // has_each = EACH.EACH
			{
					final Symbol EACH = _symbols[offset + 1];
					 return newTrue();
			}
			case 59: // has_each = 
			{
					 return newFalse();
			}
			case 60: // has_final = FINAL.FINAL
			{
					final Symbol FINAL = _symbols[offset + 1];
					 return newTrue();
			}
			case 61: // has_final = 
			{
					 return newFalse();
			}
			case 62: // redeclare_replaceable_header = REDECLARE.REDECLARE has_each.has_each has_final.has_final REPLACEABLE.REPLACEABLE
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_has_each = _symbols[offset + 2];
					final Bool has_each = (Bool) _symbol_has_each.value;
					final Symbol _symbol_has_final = _symbols[offset + 3];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol REPLACEABLE = _symbols[offset + 4];
					 return new RedeclareReplaceableHeader(true, has_each.value, has_final.value);
			}
			case 63: // redeclare_replaceable_header = has_each.has_each has_final.has_final REPLACEABLE.REPLACEABLE
			{
					final Symbol _symbol_has_each = _symbols[offset + 1];
					final Bool has_each = (Bool) _symbol_has_each.value;
					final Symbol _symbol_has_final = _symbols[offset + 2];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol REPLACEABLE = _symbols[offset + 3];
					 adjustStart(has_each, has_final, REPLACEABLE);
        return new RedeclareReplaceableHeader(false, has_each.value, has_final.value);
			}
			case 64: // clause_star = default_element_list.default_element_list
			{
					final Symbol _symbol_default_element_list = _symbols[offset + 1];
					final SrcDefaultElementList default_element_list = (SrcDefaultElementList) _symbol_default_element_list.value;
					 return new List(default_element_list);
			}
			case 65: // clause_star = 
			{
					 return new List();
			}
			case 66: // clause_star = clause_star.clause_star clause.clause
			{
					final Symbol _symbol_clause_star = _symbols[offset + 1];
					final List clause_star = (List) _symbol_clause_star.value;
					final Symbol _symbol_clause = _symbols[offset + 2];
					final SrcClause clause = (SrcClause) _symbol_clause.value;
					 return clause_star.add(clause);
			}
			case 67: // default_element_list = element_plus.element_plus
			{
					final Symbol _symbol_element_plus = _symbols[offset + 1];
					final List element_plus = (List) _symbol_element_plus.value;
					 return new SrcDefaultElementList(element_plus);
			}
			case 68: // element_plus = element.element
			{
					final Symbol _symbol_element = _symbols[offset + 1];
					final SrcElement element = (SrcElement) _symbol_element.value;
					 return new List(element);
			}
			case 69: // element_plus = element_plus.element_plus element.element
			{
					final Symbol _symbol_element_plus = _symbols[offset + 1];
					final List element_plus = (List) _symbol_element_plus.value;
					final Symbol _symbol_element = _symbols[offset + 2];
					final SrcElement element = (SrcElement) _symbol_element.value;
					 return element_plus.add(element);
			}
			case 70: // clause = PUBLIC.PUBLIC element_opt_list.element
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					final Symbol _symbol_element = _symbols[offset + 2];
					final List element = (List) _symbol_element.value;
					 return new SrcPublicElementList(element);
			}
			case 71: // clause = PROTECTED.PROTECTED element_opt_list.element
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					final Symbol _symbol_element = _symbols[offset + 2];
					final List element = (List) _symbol_element.value;
					 return new SrcProtectedElementList(element);
			}
			case 72: // clause = EQUATION.EQUATION abstract_equation_opt_list.abstract_equation
			{
					final Symbol EQUATION = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new SrcEquationClause(abstract_equation);
			}
			case 73: // clause = INITIAL_EQUATION.INITIAL_EQUATION abstract_equation_opt_list.abstract_equation
			{
					final Symbol INITIAL_EQUATION = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new SrcInitialEquationClause(abstract_equation);
			}
			case 74: // clause = ALGORITHM.ALGORITHM statement_opt_list.statement
			{
					final Symbol ALGORITHM = _symbols[offset + 1];
					final Symbol _symbol_statement = _symbols[offset + 2];
					final List statement = (List) _symbol_statement.value;
					 return new SrcAlgorithm(statement);
			}
			case 75: // clause = INITIAL_ALGORITHM.INITIAL_ALGORITHM statement_opt_list.statement
			{
					final Symbol INITIAL_ALGORITHM = _symbols[offset + 1];
					final Symbol _symbol_statement = _symbols[offset + 2];
					final List statement = (List) _symbol_statement.value;
					 return new SrcInitialAlgorithm(statement);
			}
			case 76: // external_clause = EXTERNAL.EXTERNAL external_language_opt.external_language external_function_call_opt.external_function_call annotation_opt.annotation SEMICOLON.SEMICOLON
			{
					final Symbol EXTERNAL = _symbols[offset + 1];
					final Symbol _symbol_external_language = _symbols[offset + 2];
					final Opt external_language = (Opt) _symbol_external_language.value;
					final Symbol _symbol_external_function_call = _symbols[offset + 3];
					final Opt external_function_call = (Opt) _symbol_external_function_call.value;
					final Symbol _symbol_annotation = _symbols[offset + 4];
					final Opt annotation = (Opt) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new SrcExternalClause(external_language, external_function_call, annotation);
			}
			case 77: // external_language = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new SrcExternalLanguage(((String)s.value));
			}
			case 78: // class_annotation = annotation.annotation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final SrcAnnotation annotation = (SrcAnnotation) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return annotation;
			}
			case 79: // external_function_call = access.access EQUALS.EQUALS id_decl.id_decl LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol _symbol_access = _symbols[offset + 1];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_id_decl = _symbols[offset + 3];
					final SrcIdDecl id_decl = (SrcIdDecl) _symbol_id_decl.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_arg_list = _symbols[offset + 5];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 return new SrcExternalFunctionCall(new Opt(access), id_decl, arg_list);
			}
			case 80: // external_function_call = id_decl.id_decl LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final SrcIdDecl id_decl = (SrcIdDecl) _symbol_id_decl.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_arg_list = _symbols[offset + 3];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new SrcExternalFunctionCall(new Opt(), id_decl, arg_list);
			}
			case 81: // element = has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_has_redeclare = _symbols[offset + 1];
					final Bool has_redeclare = (Bool) _symbol_has_redeclare.value;
					final Symbol _symbol_has_final = _symbols[offset + 2];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_has_inner = _symbols[offset + 3];
					final Bool has_inner = (Bool) _symbol_has_inner.value;
					final Symbol _symbol_has_outer = _symbols[offset + 4];
					final Bool has_outer = (Bool) _symbol_has_outer.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 5];
					final SrcBaseClassDecl base_class_decl = (SrcBaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 adjustStart(has_redeclare, has_final, has_inner, has_outer, base_class_decl);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        return base_class_decl;
			}
			case 82: // element = has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer REPLACEABLE.REPLACEABLE base_class_decl.base_class_decl constraining_clause_and_comment.constraining_clause_and_comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_has_redeclare = _symbols[offset + 1];
					final Bool has_redeclare = (Bool) _symbol_has_redeclare.value;
					final Symbol _symbol_has_final = _symbols[offset + 2];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_has_inner = _symbols[offset + 3];
					final Bool has_inner = (Bool) _symbol_has_inner.value;
					final Symbol _symbol_has_outer = _symbols[offset + 4];
					final Bool has_outer = (Bool) _symbol_has_outer.value;
					final Symbol REPLACEABLE = _symbols[offset + 5];
					final Symbol _symbol_base_class_decl = _symbols[offset + 6];
					final SrcBaseClassDecl base_class_decl = (SrcBaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause_and_comment = _symbols[offset + 7];
					final ConstrClauseAndComment constraining_clause_and_comment = (ConstrClauseAndComment) _symbol_constraining_clause_and_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 8];
					 adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        base_class_decl.setReplaceable(true);
        base_class_decl.setSrcConstrainingClauseOpt(constraining_clause_and_comment.constr);
        base_class_decl.setConstrainingClauseComment(constraining_clause_and_comment.comment);
        return base_class_decl;
			}
			case 83: // element = extends_clause.extends_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_extends_clause = _symbols[offset + 1];
					final SrcExtendsClause extends_clause = (SrcExtendsClause) _symbol_extends_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return extends_clause;
			}
			case 84: // element = import_clause.import_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_import_clause = _symbols[offset + 1];
					final SrcImportClause import_clause = (SrcImportClause) _symbol_import_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return import_clause;
			}
			case 85: // element = has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer type_prefixes.type_prefixes access_scalar.access_scalar array_subscripts_opt.array_subscripts component_list.component_list SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_has_redeclare = _symbols[offset + 1];
					final Bool has_redeclare = (Bool) _symbol_has_redeclare.value;
					final Symbol _symbol_has_final = _symbols[offset + 2];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_has_inner = _symbols[offset + 3];
					final Bool has_inner = (Bool) _symbol_has_inner.value;
					final Symbol _symbol_has_outer = _symbols[offset + 4];
					final Bool has_outer = (Bool) _symbol_has_outer.value;
					final Symbol _symbol_type_prefixes = _symbols[offset + 5];
					final TypePrefixes type_prefixes = (TypePrefixes) _symbol_type_prefixes.value;
					final Symbol _symbol_access_scalar = _symbols[offset + 6];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 7];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_component_list = _symbols[offset + 8];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol SEMICOLON = _symbols[offset + 9];
					 adjustStart(has_redeclare, has_final, has_inner, has_outer, type_prefixes, access_scalar);
        return new SrcComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            false,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            new Opt(),
            new SrcComment());
			}
			case 86: // element = has_redeclare.has_redeclare has_final.has_final has_inner.has_inner has_outer.has_outer REPLACEABLE.REPLACEABLE type_prefixes.type_prefixes access_scalar.access_scalar array_subscripts_opt.array_subscripts component_list.component_list constraining_clause_and_comment.constraining_clause_and_comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_has_redeclare = _symbols[offset + 1];
					final Bool has_redeclare = (Bool) _symbol_has_redeclare.value;
					final Symbol _symbol_has_final = _symbols[offset + 2];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_has_inner = _symbols[offset + 3];
					final Bool has_inner = (Bool) _symbol_has_inner.value;
					final Symbol _symbol_has_outer = _symbols[offset + 4];
					final Bool has_outer = (Bool) _symbol_has_outer.value;
					final Symbol REPLACEABLE = _symbols[offset + 5];
					final Symbol _symbol_type_prefixes = _symbols[offset + 6];
					final TypePrefixes type_prefixes = (TypePrefixes) _symbol_type_prefixes.value;
					final Symbol _symbol_access_scalar = _symbols[offset + 7];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 8];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_component_list = _symbols[offset + 9];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol _symbol_constraining_clause_and_comment = _symbols[offset + 10];
					final ConstrClauseAndComment constraining_clause_and_comment = (ConstrClauseAndComment) _symbol_constraining_clause_and_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 11];
					 adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        return new SrcComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            true,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            constraining_clause_and_comment.constr,
            constraining_clause_and_comment.comment);
			}
			case 87: // element = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new SrcBadElement();
			}
			case 88: // constraining_clause_and_comment = constraining_clause.constraining_clause comment.comment
			{
					final Symbol _symbol_constraining_clause = _symbols[offset + 1];
					final SrcConstrainingClause constraining_clause = (SrcConstrainingClause) _symbol_constraining_clause.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new ConstrClauseAndComment(constraining_clause, comment);
			}
			case 89: // constraining_clause_and_comment = 
			{
					 return new ConstrClauseAndComment();
			}
			case 90: // constraining_clause = CONSTRAINEDBY.CONSTRAINEDBY access.access class_modification_opt.class_modification
			{
					final Symbol CONSTRAINEDBY = _symbols[offset + 1];
					final Symbol _symbol_access = _symbols[offset + 2];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 3];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					 return new SrcConstrainingClause(access, class_modification);
			}
			case 91: // extends_clause = EXTENDS.EXTENDS access.access class_modification_opt.class_modification annotation_opt.annotation
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_access = _symbols[offset + 2];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 3];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_annotation = _symbols[offset + 4];
					final Opt annotation = (Opt) _symbol_annotation.value;
					 return new SrcExtendsClause(access, class_modification, annotation);
			}
			case 92: // import_clause = IMPORT.IMPORT access_scalar.access_scalar comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_access_scalar = _symbols[offset + 2];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol _symbol_comment = _symbols[offset + 3];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcImportClauseQualified(access_scalar, comment);
			}
			case 93: // import_clause = IMPORT.IMPORT access_scalar.access_scalar DOTMULT.DOTMULT comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_access_scalar = _symbols[offset + 2];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol DOTMULT = _symbols[offset + 3];
					final Symbol _symbol_comment = _symbols[offset + 4];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcImportClauseUnqualified(access_scalar, comment);
			}
			case 94: // import_clause = IMPORT.IMPORT id_decl.alias EQUALS.EQUALS access_scalar.access_scalar comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_alias = _symbols[offset + 2];
					final SrcIdDecl alias = (SrcIdDecl) _symbol_alias.value;
					final Symbol EQUALS = _symbols[offset + 3];
					final Symbol _symbol_access_scalar = _symbols[offset + 4];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcImportClauseRename(access_scalar, comment, alias);
			}
			case 95: // array_subscripts = LBRACK.LBRACK subscript_list.subscript_list RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_subscript_list = _symbols[offset + 2];
					final List subscript_list = (List) _symbol_subscript_list.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new SrcArraySubscripts(subscript_list);
			}
			case 96: // subscript_list = subscript.subscript
			{
					final Symbol _symbol_subscript = _symbols[offset + 1];
					final SrcSubscript subscript = (SrcSubscript) _symbol_subscript.value;
					 return new List().add(subscript);
			}
			case 97: // subscript_list = subscript_list.subscript_list COMMA.COMMA subscript.subscript
			{
					final Symbol _symbol_subscript_list = _symbols[offset + 1];
					final List subscript_list = (List) _symbol_subscript_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_subscript = _symbols[offset + 3];
					final SrcSubscript subscript = (SrcSubscript) _symbol_subscript.value;
					 subscript_list.add(subscript);
        return subscript_list;
			}
			case 98: // subscript = COLON.COLON
			{
					final Symbol COLON = _symbols[offset + 1];
					 return new SrcColonSubscript();
			}
			case 99: // subscript = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return new SrcExpSubscript(exp);
			}
			case 100: // component_list = component_decl.component_decl
			{
					final Symbol _symbol_component_decl = _symbols[offset + 1];
					final SrcComponentDecl component_decl = (SrcComponentDecl) _symbol_component_decl.value;
					 return new List(component_decl);
			}
			case 101: // component_list = component_list.component_list COMMA.COMMA component_decl.component_decl
			{
					final Symbol _symbol_component_list = _symbols[offset + 1];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_component_decl = _symbols[offset + 3];
					final SrcComponentDecl component_decl = (SrcComponentDecl) _symbol_component_decl.value;
					 component_list.add(component_decl);
        return component_list;
			}
			case 102: // component_decl = id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification conditional_attribute_opt.conditional_attribute comment.comment
			{
					final Symbol _symbol_comp_name = _symbols[offset + 1];
					final SrcIdDecl comp_name = (SrcIdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 3];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_conditional_attribute = _symbols[offset + 4];
					final Opt conditional_attribute = (Opt) _symbol_conditional_attribute.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 conditional_attribute, 
                                 comment);
			}
			case 103: // component_decl_no_conditional = id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment
			{
					final Symbol _symbol_comp_name = _symbols[offset + 1];
					final SrcIdDecl comp_name = (SrcIdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 3];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 4];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 new Opt(), 
                                 comment);
			}
			case 104: // conditional_attribute = IF.IF exp.exp
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return new SrcConditionalAttribute(exp);
			}
			case 105: // modification = complete_modification.complete_modification
			{
					final Symbol _symbol_complete_modification = _symbols[offset + 1];
					final SrcCompleteModification complete_modification = (SrcCompleteModification) _symbol_complete_modification.value;
					 return complete_modification;
			}
			case 106: // modification = value_modification.value_modification
			{
					final Symbol _symbol_value_modification = _symbols[offset + 1];
					final SrcValueModification value_modification = (SrcValueModification) _symbol_value_modification.value;
					 return value_modification;
			}
			case 107: // complete_modification = class_modification.class_modification value_modification_opt.value_modification
			{
					final Symbol _symbol_class_modification = _symbols[offset + 1];
					final SrcClassModification class_modification = (SrcClassModification) _symbol_class_modification.value;
					final Symbol _symbol_value_modification = _symbols[offset + 2];
					final Opt value_modification = (Opt) _symbol_value_modification.value;
					 return new SrcCompleteModification(class_modification, value_modification);
			}
			case 108: // value_modification = EQUALS.EQUALS exp.exp
			{
					final Symbol EQUALS = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return new SrcValueModification(exp);
			}
			case 109: // value_modification = COLON.COLON EQUALS.EQUALS exp.exp
			{
					final Symbol COLON = _symbols[offset + 1];
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return new SrcValueModification(exp);
			}
			case 110: // class_modification = LPAREN.LPAREN RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol RPAREN = _symbols[offset + 2];
					 return new SrcClassModification();
			}
			case 111: // class_modification = LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_argument_list = _symbols[offset + 2];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new SrcClassModification(argument_list);
			}
			case 112: // argument_list = argument.argument
			{
					final Symbol _symbol_argument = _symbols[offset + 1];
					final SrcArgument argument = (SrcArgument) _symbol_argument.value;
					 return new List().add(argument);
			}
			case 113: // argument_list = argument_list.argument_list COMMA.COMMA argument.argument
			{
					final Symbol _symbol_argument_list = _symbols[offset + 1];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_argument = _symbols[offset + 3];
					final SrcArgument argument = (SrcArgument) _symbol_argument.value;
					 argument_list.add(argument);
        return argument_list;
			}
			case 114: // argument = has_each.has_each has_final.has_final access.access modification_opt.modification comment.comment
			{
					final Symbol _symbol_has_each = _symbols[offset + 1];
					final Bool has_each = (Bool) _symbol_has_each.value;
					final Symbol _symbol_has_final = _symbols[offset + 2];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_access = _symbols[offset + 3];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					final Symbol _symbol_modification = _symbols[offset + 4];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 adjustStart(has_each, has_final, access);
        return new SrcComponentModification(
            has_each.value, 
            has_final.value, 
            access, 
            modification, 
            comment);
			}
			case 115: // argument = redeclare_replaceable_header.redeclare_replaceable_header base_class_decl.base_class_decl constraining_clause_opt.constraining_clause
			{
					final Symbol _symbol_redeclare_replaceable_header = _symbols[offset + 1];
					final RedeclareReplaceableHeader redeclare_replaceable_header = (RedeclareReplaceableHeader) _symbol_redeclare_replaceable_header.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 2];
					final SrcBaseClassDecl base_class_decl = (SrcBaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 3];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 adjustStart(redeclare_replaceable_header, base_class_decl);
        SrcNamedAccess name = new SrcNamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setSrcConstrainingClauseOpt(constraining_clause);
        base_class_decl.setReplaceable(true);
        base_class_decl.setRedeclare(redeclare_replaceable_header.has_redeclare);
        return new SrcClassRedeclare(
            redeclare_replaceable_header.has_each, 
            redeclare_replaceable_header.has_final, 
            name, 
            base_class_decl);
			}
			case 116: // argument = REDECLARE.REDECLARE has_each.has_each has_final.has_final base_class_decl.base_class_decl
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_has_each = _symbols[offset + 2];
					final Bool has_each = (Bool) _symbol_has_each.value;
					final Symbol _symbol_has_final = _symbols[offset + 3];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 4];
					final SrcBaseClassDecl base_class_decl = (SrcBaseClassDecl) _symbol_base_class_decl.value;
					 SrcNamedAccess name = new SrcNamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setRedeclare(true);
        return new SrcClassRedeclare(
            has_each.value,
            has_final.value,
            name,
            base_class_decl);
			}
			case 117: // argument = redeclare_replaceable_header.header component_clause_in_argument.cc constraining_clause_opt.constr
			{
					final Symbol _symbol_header = _symbols[offset + 1];
					final RedeclareReplaceableHeader header = (RedeclareReplaceableHeader) _symbol_header.value;
					final Symbol _symbol_cc = _symbols[offset + 2];
					final SrcComponentClause cc = (SrcComponentClause) _symbol_cc.value;
					final Symbol _symbol_constr = _symbols[offset + 3];
					final Opt constr = (Opt) _symbol_constr.value;
					 adjustStart(header, cc);
        cc.setSrcConstrainingClauseOpt(constr);
        cc.setLocationNoTree(header, (constr.hasChild() ? constr : cc));
        cc.setRedeclare(header.has_redeclare);
        return new SrcComponentRedeclare(
            header.has_each, 
            header.has_final, 
            cc.createAccessForRedeclareNode(),
            cc);
			}
			case 118: // argument = REDECLARE.REDECLARE has_each.has_each has_final.has_final component_clause_in_argument.cc
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_has_each = _symbols[offset + 2];
					final Bool has_each = (Bool) _symbol_has_each.value;
					final Symbol _symbol_has_final = _symbols[offset + 3];
					final Bool has_final = (Bool) _symbol_has_final.value;
					final Symbol _symbol_cc = _symbols[offset + 4];
					final SrcComponentClause cc = (SrcComponentClause) _symbol_cc.value;
					 cc.setReplaceable(false);
        cc.setLocationNoTree(REDECLARE, cc);
        return new SrcComponentRedeclare(
            has_each.value, 
            has_final.value, 
            cc.createAccessForRedeclareNode(),
            cc);
			}
			case 119: // argument = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new SrcBadArgument();
			}
			case 120: // component_clause_in_argument = type_prefixes.type_prefixes access_scalar.access_scalar component_decl_no_conditional.component_decl_no_conditional
			{
					final Symbol _symbol_type_prefixes = _symbols[offset + 1];
					final TypePrefixes type_prefixes = (TypePrefixes) _symbol_type_prefixes.value;
					final Symbol _symbol_access_scalar = _symbols[offset + 2];
					final SrcAccess access_scalar = (SrcAccess) _symbol_access_scalar.value;
					final Symbol _symbol_component_decl_no_conditional = _symbols[offset + 3];
					final SrcComponentDecl component_decl_no_conditional = (SrcComponentDecl) _symbol_component_decl_no_conditional.value;
					 adjustStart(type_prefixes, access_scalar);
        return new SrcComponentClause(
            true,   // Changed in argument rule for case without "redeclare"
            false, 
            false, 
            false, 
            true,   // Changed in argument rule for case without "replaceable"
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            access_scalar, 
            new Opt(), 
            new List(component_decl_no_conditional), 
            new Opt(), 
            new SrcComment());
			}
			case 121: // annotation = annotation_tok.annotation_tok class_modification.class_modification
			{
					final Symbol _symbol_annotation_tok = _symbols[offset + 1];
					final Symbol annotation_tok = (Symbol) _symbol_annotation_tok.value;
					final Symbol _symbol_class_modification = _symbols[offset + 2];
					final SrcClassModification class_modification = (SrcClassModification) _symbol_class_modification.value;
					 annotationTok = null;
        return new SrcParseAnnotation(class_modification);
			}
			case 122: // annotation_tok = ANNOTATION.ANNOTATION
			{
					final Symbol ANNOTATION = _symbols[offset + 1];
					 if (annotationTok != null) {
            getReport().syntaxError(ANNOTATION);
        }
        annotationTok = ANNOTATION;
        return new Symbol(ANNOTATION);
			}
			case 123: // abstract_equation = exp.left EQUALS.EQUALS exp.right comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_left = _symbols[offset + 1];
					final SrcExp left = (SrcExp) _symbol_left.value;
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_right = _symbols[offset + 3];
					final SrcExp right = (SrcExp) _symbol_right.value;
					final Symbol _symbol_comment = _symbols[offset + 4];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new SrcEquation(comment, left, right);
			}
			case 124: // abstract_equation = if_equation.if_equation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_if_equation = _symbols[offset + 1];
					final SrcIfEquation if_equation = (SrcIfEquation) _symbol_if_equation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return if_equation;
			}
			case 125: // abstract_equation = for_clause_e.for_clause_e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_for_clause_e = _symbols[offset + 1];
					final SrcForClauseE for_clause_e = (SrcForClauseE) _symbol_for_clause_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return for_clause_e;
			}
			case 126: // abstract_equation = when_equation.when_equation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_when_equation = _symbols[offset + 1];
					final SrcWhenEquation when_equation = (SrcWhenEquation) _symbol_when_equation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return when_equation;
			}
			case 127: // abstract_equation = CONNECT.CONNECT LPAREN.LPAREN access.a COMMA.COMMA access.b RPAREN.RPAREN comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol CONNECT = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final SrcAccess a = (SrcAccess) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final SrcAccess b = (SrcAccess) _symbol_b.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new SrcConnectClause(comment, a, b);
			}
			case 128: // abstract_equation = LPAREN.LPAREN function_call_left_list.function_call_left_list RPAREN.RPAREN EQUALS.EQUALS function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_function_call_left_list = _symbols[offset + 2];
					final List function_call_left_list = (List) _symbol_function_call_left_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol EQUALS = _symbols[offset + 4];
					final Symbol _symbol_function_call = _symbols[offset + 5];
					final SrcFunctionCall function_call = (SrcFunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 6];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new SrcFunctionCallEquation(comment, function_call_left_list, function_call);
			}
			case 129: // abstract_equation = function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final SrcFunctionCall function_call = (SrcFunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SrcFunctionCallEquation(comment, new List(), function_call);
			}
			case 130: // function_call_left_list = function_call_left.a COMMA.COMMA function_call_left.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcFunctionCallLeft a = (SrcFunctionCallLeft) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcFunctionCallLeft b = (SrcFunctionCallLeft) _symbol_b.value;
					 return new List().add(a).add(b);
			}
			case 131: // function_call_left_list = function_call_left_list.function_call_left_list COMMA.COMMA function_call_left.function_call_left
			{
					final Symbol _symbol_function_call_left_list = _symbols[offset + 1];
					final List function_call_left_list = (List) _symbol_function_call_left_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_function_call_left = _symbols[offset + 3];
					final SrcFunctionCallLeft function_call_left = (SrcFunctionCallLeft) _symbol_function_call_left.value;
					 return function_call_left_list.add(function_call_left);
			}
			case 132: // function_call_left = 
			{
					 return new SrcFunctionCallLeft();
			}
			case 133: // function_call_left = access.access
			{
					final Symbol _symbol_access = _symbols[offset + 1];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					 return new SrcFunctionCallLeft(new Opt(access));
			}
			case 134: // for_clause_e = FOR.FOR for_indices.for_indices LOOP.LOOP abstract_equation_opt_list.abstract_equation END_FOR.END_FOR comment.comment
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol END_FOR = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcForClauseE(comment, for_indices,abstract_equation);
			}
			case 135: // for_indices = for_index.for_index
			{
					final Symbol _symbol_for_index = _symbols[offset + 1];
					final SrcForIndex for_index = (SrcForIndex) _symbol_for_index.value;
					 return new List().add(for_index);
			}
			case 136: // for_indices = for_indices.for_indices COMMA.COMMA for_index.for_index
			{
					final Symbol _symbol_for_indices = _symbols[offset + 1];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_for_index = _symbols[offset + 3];
					final SrcForIndex for_index = (SrcForIndex) _symbol_for_index.value;
					 for_indices.add(for_index);
        return for_indices;
			}
			case 137: // for_index = for_index_decl.for_index_decl for_in_exp_opt.for_in_exp
			{
					final Symbol _symbol_for_index_decl = _symbols[offset + 1];
					final SrcForIndexDecl for_index_decl = (SrcForIndexDecl) _symbol_for_index_decl.value;
					final Symbol _symbol_for_in_exp = _symbols[offset + 2];
					final Opt for_in_exp = (Opt) _symbol_for_in_exp.value;
					 SrcForIndex f = new SrcForIndex(
            false,
            false,
            false,
            false,
            false,
            new Opt(),
            new Opt(new SrcIndexParameter()),
            new Opt(),
            new SrcNamedAccess("Integer"),
            new Opt(),
            new List(for_index_decl),
            new Opt(),
            new SrcComment(),
            for_in_exp); 
        return f;
			}
			case 138: // for_index_decl = id_decl.id_decl
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final SrcIdDecl id_decl = (SrcIdDecl) _symbol_id_decl.value;
					 return new SrcForIndexDecl(
            id_decl,
            new Opt(),
            new Opt(),
            new Opt(),
            new SrcComment());
			}
			case 139: // for_in_exp = IN.IN exp.e
			{
					final Symbol IN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final SrcExp e = (SrcExp) _symbol_e.value;
					 return e;
			}
			case 140: // when_equation = WHEN.WHEN exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_when_equation_opt.else_when_equation END_WHEN.END_WHEN comment.comment
			{
					final Symbol WHEN = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final SrcExp test = (SrcExp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_when_equation = _symbols[offset + 5];
					final Opt else_when_equation = (Opt) _symbol_else_when_equation.value;
					final Symbol END_WHEN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcWhenEquation(comment,
                                abstract_equation,
                                test, 
                                else_when_equation);
			}
			case 141: // else_when_equation = ELSEWHEN.ELSEWHEN exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_when_equation_opt.else_when_equation
			{
					final Symbol ELSEWHEN = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final SrcExp test = (SrcExp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_when_equation = _symbols[offset + 5];
					final Opt else_when_equation = (Opt) _symbol_else_when_equation.value;
					 return new SrcWhenEquation(new SrcComment(),
                                abstract_equation, 
                                test, 
                                else_when_equation);
			}
			case 142: // if_equation = IF.IF exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_if_equation_opt.else_if_equation END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final SrcExp test = (SrcExp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_if_equation = _symbols[offset + 5];
					final Opt else_if_equation = (Opt) _symbol_else_if_equation.value;
					final Symbol END_IF = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcIfEquation(comment, 
                              abstract_equation, 
                              test, 
                              else_if_equation);
			}
			case 143: // else_if_equation = ELSEIF.ELSEIF exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_if_equation_opt.else_if_equation
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final SrcExp test = (SrcExp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_if_equation = _symbols[offset + 5];
					final Opt else_if_equation = (Opt) _symbol_else_if_equation.value;
					 return new SrcIfEquation(new SrcComment(),
                              abstract_equation, 
                              test, 
                              else_if_equation);
			}
			case 144: // else_if_equation = ELSE.ELSE abstract_equation_opt_list.abstract_equation
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new SrcElseEquation(new SrcComment(), 
                                abstract_equation);
			}
			case 145: // statement = access.left ASSIGN.ASSIGN exp.right comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_left = _symbols[offset + 1];
					final SrcAccess left = (SrcAccess) _symbol_left.value;
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_right = _symbols[offset + 3];
					final SrcExp right = (SrcExp) _symbol_right.value;
					final Symbol _symbol_comment = _symbols[offset + 4];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new SrcAssignStmt(comment, left, right);
			}
			case 146: // statement = function_call_stmt.function_call_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call_stmt = _symbols[offset + 1];
					final SrcFunctionCallStmt function_call_stmt = (SrcFunctionCallStmt) _symbol_function_call_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return function_call_stmt;
			}
			case 147: // statement = BREAK.BREAK comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol _symbol_comment = _symbols[offset + 2];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SrcBreakStmt(comment);
			}
			case 148: // statement = RETURN.RETURN comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_comment = _symbols[offset + 2];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new SrcReturnStmt(comment);
			}
			case 149: // statement = if_stmt.if_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_if_stmt = _symbols[offset + 1];
					final SrcIfStmt if_stmt = (SrcIfStmt) _symbol_if_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return if_stmt;
			}
			case 150: // statement = when_stmt.when_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_when_stmt = _symbols[offset + 1];
					final SrcWhenStmt when_stmt = (SrcWhenStmt) _symbol_when_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return when_stmt;
			}
			case 151: // statement = for_stmt.for_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_for_stmt = _symbols[offset + 1];
					final SrcForStmt for_stmt = (SrcForStmt) _symbol_for_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return for_stmt;
			}
			case 152: // statement = while_stmt.while_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_while_stmt = _symbols[offset + 1];
					final SrcWhileStmt while_stmt = (SrcWhileStmt) _symbol_while_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return while_stmt;
			}
			case 153: // statement = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new SrcBadStatement();
			}
			case 154: // function_call_stmt = LPAREN.LPAREN function_call_stmt_left_list.function_call_stmt_left_list RPAREN.RPAREN ASSIGN.ASSIGN function_call.function_call comment.comment
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_function_call_stmt_left_list = _symbols[offset + 2];
					final List function_call_stmt_left_list = (List) _symbol_function_call_stmt_left_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol ASSIGN = _symbols[offset + 4];
					final Symbol _symbol_function_call = _symbols[offset + 5];
					final SrcFunctionCall function_call = (SrcFunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 6];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcFunctionCallStmt(comment, function_call_stmt_left_list, function_call);
			}
			case 155: // function_call_stmt = function_call.function_call comment.comment
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final SrcFunctionCall function_call = (SrcFunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcFunctionCallStmt(comment, new List(), function_call);
			}
			case 156: // function_call_stmt_left_list = function_call_left.function_call_left
			{
					final Symbol _symbol_function_call_left = _symbols[offset + 1];
					final SrcFunctionCallLeft function_call_left = (SrcFunctionCallLeft) _symbol_function_call_left.value;
					 return new List().add(function_call_left);
			}
			case 157: // function_call_stmt_left_list = function_call_stmt_left_list.function_call_stmt_left_list COMMA.COMMA function_call_left.function_call_left
			{
					final Symbol _symbol_function_call_stmt_left_list = _symbols[offset + 1];
					final List function_call_stmt_left_list = (List) _symbol_function_call_stmt_left_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_function_call_left = _symbols[offset + 3];
					final SrcFunctionCallLeft function_call_left = (SrcFunctionCallLeft) _symbol_function_call_left.value;
					 return function_call_stmt_left_list.add(function_call_left);
			}
			case 158: // if_stmt = IF.IF if_clause_list.if_clause_list else_stmts.else_stmts END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_if_clause_list = _symbols[offset + 2];
					final List if_clause_list = (List) _symbol_if_clause_list.value;
					final Symbol _symbol_else_stmts = _symbols[offset + 3];
					final SrcElseClause else_stmts = (SrcElseClause) _symbol_else_stmts.value;
					final Symbol END_IF = _symbols[offset + 4];
					final Symbol _symbol_comment = _symbols[offset + 5];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcIfStmt(comment, if_clause_list, new Opt(else_stmts));
			}
			case 159: // if_stmt = IF.IF if_clause_list.if_clause_list END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_if_clause_list = _symbols[offset + 2];
					final List if_clause_list = (List) _symbol_if_clause_list.value;
					final Symbol END_IF = _symbols[offset + 3];
					final Symbol _symbol_comment = _symbols[offset + 4];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcIfStmt(comment, if_clause_list, new Opt());
			}
			case 160: // if_clause_list = if_clause.if_clause
			{
					final Symbol _symbol_if_clause = _symbols[offset + 1];
					final SrcIfClause if_clause = (SrcIfClause) _symbol_if_clause.value;
					 return new List().add(if_clause);
			}
			case 161: // if_clause_list = if_clause_list.if_clause_list else_if_clause.else_if_clause
			{
					final Symbol _symbol_if_clause_list = _symbols[offset + 1];
					final List if_clause_list = (List) _symbol_if_clause_list.value;
					final Symbol _symbol_else_if_clause = _symbols[offset + 2];
					final SrcIfClause else_if_clause = (SrcIfClause) _symbol_else_if_clause.value;
					 return if_clause_list.add(else_if_clause);
			}
			case 162: // if_clause = exp.exp THEN.THEN statement_opt_list.statement
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					final Symbol THEN = _symbols[offset + 2];
					final Symbol _symbol_statement = _symbols[offset + 3];
					final List statement = (List) _symbol_statement.value;
					 return new SrcIfClause(exp, statement);
			}
			case 163: // else_if_clause = ELSEIF.ELSEIF if_clause.if_clause
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_if_clause = _symbols[offset + 2];
					final SrcIfClause if_clause = (SrcIfClause) _symbol_if_clause.value;
					 return if_clause;
			}
			case 164: // else_stmts = ELSE.ELSE statement_opt_list.statement
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_statement = _symbols[offset + 2];
					final List statement = (List) _symbol_statement.value;
					 return new SrcElseClause(statement);
			}
			case 165: // when_stmt = WHEN.WHEN when_clause_list.when_clause_list END_WHEN.END_WHEN comment.comment
			{
					final Symbol WHEN = _symbols[offset + 1];
					final Symbol _symbol_when_clause_list = _symbols[offset + 2];
					final List when_clause_list = (List) _symbol_when_clause_list.value;
					final Symbol END_WHEN = _symbols[offset + 3];
					final Symbol _symbol_comment = _symbols[offset + 4];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcWhenStmt(comment, when_clause_list);
			}
			case 166: // when_clause_list = when_clause.when_clause
			{
					final Symbol _symbol_when_clause = _symbols[offset + 1];
					final SrcWhenClause when_clause = (SrcWhenClause) _symbol_when_clause.value;
					 return new List().add(when_clause);
			}
			case 167: // when_clause_list = when_clause_list.when_clause_list else_when_clause.else_when_clause
			{
					final Symbol _symbol_when_clause_list = _symbols[offset + 1];
					final List when_clause_list = (List) _symbol_when_clause_list.value;
					final Symbol _symbol_else_when_clause = _symbols[offset + 2];
					final SrcWhenClause else_when_clause = (SrcWhenClause) _symbol_else_when_clause.value;
					 return when_clause_list.add(else_when_clause);
			}
			case 168: // when_clause = exp.exp THEN.THEN statement_opt_list.statement
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					final Symbol THEN = _symbols[offset + 2];
					final Symbol _symbol_statement = _symbols[offset + 3];
					final List statement = (List) _symbol_statement.value;
					 return new SrcWhenClause(exp, statement);
			}
			case 169: // else_when_clause = ELSEWHEN.ELSEWHEN exp.exp THEN.THEN statement_opt_list.statement
			{
					final Symbol ELSEWHEN = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_statement = _symbols[offset + 4];
					final List statement = (List) _symbol_statement.value;
					 return new SrcWhenClause(exp, statement);
			}
			case 170: // for_stmt = FOR.FOR for_indices.for_indices LOOP.LOOP statement_opt_list.statement END_FOR.END_FOR comment.comment
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_statement = _symbols[offset + 4];
					final List statement = (List) _symbol_statement.value;
					final Symbol END_FOR = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcForStmt(comment, for_indices, statement);
			}
			case 171: // while_stmt = WHILE.WHILE exp.exp LOOP.LOOP statement_opt_list.statement END_WHILE.END_WHILE comment.comment
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_statement = _symbols[offset + 4];
					final List statement = (List) _symbol_statement.value;
					final Symbol END_WHILE = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final SrcComment comment = (SrcComment) _symbol_comment.value;
					 return new SrcWhileStmt(comment, exp, statement);
			}
			case 172: // exp = simple_expression.simple_expression
			{
					final Symbol _symbol_simple_expression = _symbols[offset + 1];
					final SrcExp simple_expression = (SrcExp) _symbol_simple_expression.value;
					 return simple_expression;
			}
			case 173: // exp = if_exp.if_exp
			{
					final Symbol _symbol_if_exp = _symbols[offset + 1];
					final SrcIfExp if_exp = (SrcIfExp) _symbol_if_exp.value;
					 return if_exp;
			}
			case 174: // if_exp = IF.IF exp.ifexp THEN.THEN exp.thenexp else_if_exp.else_if_exp
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final SrcExp ifexp = (SrcExp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_thenexp = _symbols[offset + 4];
					final SrcExp thenexp = (SrcExp) _symbol_thenexp.value;
					final Symbol _symbol_else_if_exp = _symbols[offset + 5];
					final SrcExp else_if_exp = (SrcExp) _symbol_else_if_exp.value;
					 return new SrcIfExp(ifexp, thenexp, else_if_exp);
			}
			case 175: // else_if_exp = ELSEIF.ELSEIF exp.ifexp THEN.THEN exp.thenexp else_if_exp.else_if_exp
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final SrcExp ifexp = (SrcExp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_thenexp = _symbols[offset + 4];
					final SrcExp thenexp = (SrcExp) _symbol_thenexp.value;
					final Symbol _symbol_else_if_exp = _symbols[offset + 5];
					final SrcExp else_if_exp = (SrcExp) _symbol_else_if_exp.value;
					 return new SrcIfExp(ifexp, thenexp, else_if_exp);
			}
			case 176: // else_if_exp = ELSE.ELSE exp.exp
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return exp;
			}
			case 177: // simple_expression = log_exp.log_exp
			{
					final Symbol _symbol_log_exp = _symbols[offset + 1];
					final SrcExp log_exp = (SrcExp) _symbol_log_exp.value;
					 return log_exp;
			}
			case 178: // simple_expression = log_exp.l1 COLON.COLON log_exp.l2
			{
					final Symbol _symbol_l1 = _symbols[offset + 1];
					final SrcExp l1 = (SrcExp) _symbol_l1.value;
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_l2 = _symbols[offset + 3];
					final SrcExp l2 = (SrcExp) _symbol_l2.value;
					 SrcRangeExp r = new SrcRangeExp();
           r.addSrcExp(l1);
           r.addSrcExp(l2);
           return r;
			}
			case 179: // simple_expression = log_exp.l1 COLON.COLON log_exp.l2 COLON.COLON_ log_exp.l3
			{
					final Symbol _symbol_l1 = _symbols[offset + 1];
					final SrcExp l1 = (SrcExp) _symbol_l1.value;
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_l2 = _symbols[offset + 3];
					final SrcExp l2 = (SrcExp) _symbol_l2.value;
					final Symbol COLON_ = _symbols[offset + 4];
					final Symbol _symbol_l3 = _symbols[offset + 5];
					final SrcExp l3 = (SrcExp) _symbol_l3.value;
					 SrcRangeExp r = new SrcRangeExp();
           r.addSrcExp(l1);
           r.addSrcExp(l2);
           r.addSrcExp(l3);
           return r;
			}
			case 180: // log_exp = log_exp.a OR.OR log_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcOrExp(a,b);
			}
			case 181: // log_exp = log_exp.a AND.AND log_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcAndExp(a,b);
			}
			case 182: // log_exp = NOT.NOT relation.a
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final SrcExp a = (SrcExp) _symbol_a.value;
					 return new SrcNotExp(a);
			}
			case 183: // log_exp = relation.relation
			{
					final Symbol _symbol_relation = _symbols[offset + 1];
					final SrcExp relation = (SrcExp) _symbol_relation.value;
					 return relation;
			}
			case 184: // relation = artm_exp.a LT.LT artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcLtExp(a,b);
			}
			case 185: // relation = artm_exp.a LEQ.LEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol LEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcLeqExp(a,b);
			}
			case 186: // relation = artm_exp.a GT.GT artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcGtExp(a,b);
			}
			case 187: // relation = artm_exp.a GEQ.GEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol GEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcGeqExp(a,b);
			}
			case 188: // relation = artm_exp.a EQ.EQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcEqExp(a,b);
			}
			case 189: // relation = artm_exp.a NEQ.NEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol NEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcExp b = (SrcExp) _symbol_b.value;
					 return new SrcNeqExp(a,b);
			}
			case 190: // relation = artm_exp.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					 return a;
			}
			case 191: // artm_exp = additive_exp.additive_exp
			{
					final Symbol _symbol_additive_exp = _symbols[offset + 1];
					final SrcExp additive_exp = (SrcExp) _symbol_additive_exp.value;
					 return additive_exp;
			}
			case 192: // additive_exp = multiplicative_exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final SrcExp e = (SrcExp) _symbol_e.value;
					 return e;
			}
			case 193: // additive_exp = additive_exp.e1 PLUS.PLUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcAddExp(e1, e2);
			}
			case 194: // additive_exp = additive_exp.e1 MINUS.MINUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcSubExp(e1, e2);
			}
			case 195: // additive_exp = additive_exp.e1 DOTPLUS.DOTPLUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol DOTPLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcDotAddExp(e1, e2);
			}
			case 196: // additive_exp = additive_exp.e1 DOTMINUS.DOTMINUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol DOTMINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcDotSubExp(e1, e2);
			}
			case 197: // multiplicative_exp = unary_exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final SrcExp e = (SrcExp) _symbol_e.value;
					 return e;
			}
			case 198: // multiplicative_exp = multiplicative_exp.e1 MULT.MULT unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcMulExp(e1, e2);
			}
			case 199: // multiplicative_exp = multiplicative_exp.e1 DIV.DIV unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcDivExp(e1, e2);
			}
			case 200: // multiplicative_exp = multiplicative_exp.e1 DOTMULT.DOTMULT unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol DOTMULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcDotMulExp(e1, e2);
			}
			case 201: // multiplicative_exp = multiplicative_exp.e1 DOTDIV.DOTDIV unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final SrcExp e1 = (SrcExp) _symbol_e1.value;
					final Symbol DOTDIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final SrcExp e2 = (SrcExp) _symbol_e2.value;
					 return new SrcDotDivExp(e1, e2);
			}
			case 202: // unary_exp = pow_exp.pow_exp
			{
					final Symbol _symbol_pow_exp = _symbols[offset + 1];
					final SrcExp pow_exp = (SrcExp) _symbol_pow_exp.value;
					 return pow_exp;
			}
			case 203: // unary_exp = MINUS.MINUS unary_exp.unary_exp
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_unary_exp = _symbols[offset + 2];
					final SrcExp unary_exp = (SrcExp) _symbol_unary_exp.value;
					 return new SrcNegExp(unary_exp);
			}
			case 204: // unary_exp = PLUS.PLUS unary_exp.unary_exp
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_unary_exp = _symbols[offset + 2];
					final SrcExp unary_exp = (SrcExp) _symbol_unary_exp.value;
					 formattingRecorder.addItem(FormattingType.NON_BREAKING_WHITESPACE, "+", PLUS);
                              return unary_exp;
			}
			case 205: // pow_exp = primary.primary
			{
					final Symbol _symbol_primary = _symbols[offset + 1];
					final SrcExp primary = (SrcExp) _symbol_primary.value;
					 return primary;
			}
			case 206: // pow_exp = primary.a POW.POW primary.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol POW = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final SrcExp e = (SrcExp) _symbol_e.value;
					 return new SrcPowExp(a,e);
			}
			case 207: // pow_exp = primary.a DOTPOW.DOTPOW primary.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol DOTPOW = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final SrcExp e = (SrcExp) _symbol_e.value;
					 return new SrcDotPowExp(a,e);
			}
			case 208: // primary = UNSIGNED_NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new SrcRealLitExp(((String)n.value));
			}
			case 209: // primary = UNSIGNED_INTEGER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new SrcIntegerLitExp(((String)n.value));
			}
			case 210: // primary = TRUE.TRUE
			{
					final Symbol TRUE = _symbols[offset + 1];
					 return new SrcBooleanLitExpTrue();
			}
			case 211: // primary = FALSE.FALSE
			{
					final Symbol FALSE = _symbols[offset + 1];
					 return new SrcBooleanLitExpFalse();
			}
			case 212: // primary = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new SrcStringLitExp(((String)s.value));
			}
			case 213: // primary = access_expression.access_expression
			{
					final Symbol _symbol_access_expression = _symbols[offset + 1];
					final SrcAccessExp access_expression = (SrcAccessExp) _symbol_access_expression.value;
					 return access_expression;
			}
			case 214: // primary = der_expression.der_expression
			{
					final Symbol _symbol_der_expression = _symbols[offset + 1];
					final SrcDerExp der_expression = (SrcDerExp) _symbol_der_expression.value;
					 return der_expression;
			}
			case 215: // primary = LPAREN.LPAREN exp.a RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final SrcExp a = (SrcExp) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new SrcParExp(a);
			}
			case 216: // primary = function_call.function_call
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final SrcFunctionCall function_call = (SrcFunctionCall) _symbol_function_call.value;
					 return function_call;
			}
			case 217: // primary = LBRACK.LBRACK matrix.matrix RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_matrix = _symbols[offset + 2];
					final SrcMatrix matrix = (SrcMatrix) _symbol_matrix.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return matrix;
			}
			case 218: // primary = LBRACE.LBRACE function_arguments.function_arguments RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_function_arguments = _symbols[offset + 2];
					final SrcFunctionArguments function_arguments = (SrcFunctionArguments) _symbol_function_arguments.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new SrcArrayConstructor(function_arguments);
			}
			case 219: // primary = TIME.TIME
			{
					final Symbol TIME = _symbols[offset + 1];
					 return new SrcTimeExp();
			}
			case 220: // primary = END.END
			{
					final Symbol END = _symbols[offset + 1];
					 return new SrcEndExp();
			}
			case 221: // function_call = access.access LPAREN.LPAREN function_arguments_opt.function_arguments RPAREN.RPAREN
			{
					final Symbol _symbol_access = _symbols[offset + 1];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_function_arguments = _symbols[offset + 3];
					final Opt function_arguments = (Opt) _symbol_function_arguments.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new SrcFunctionCall(access, function_arguments);
			}
			case 222: // partial_function_call = FUNCTION.FUNCTION access.access LPAREN.LPAREN function_arguments_named_opt.function_arguments_named RPAREN.RPAREN
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					final Symbol _symbol_access = _symbols[offset + 2];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_function_arguments_named = _symbols[offset + 4];
					final Opt function_arguments_named = (Opt) _symbol_function_arguments_named.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new SrcPartialFunctionCall(access, function_arguments_named);
			}
			case 223: // partial_function_call = FUNCTION.FUNCTION access.access
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					final Symbol _symbol_access = _symbols[offset + 2];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					 return new SrcPartialFunctionCall(access, new Opt());
			}
			case 224: // function_arguments = exp.exp FOR.FOR for_indices.for_indices
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					final Symbol FOR = _symbols[offset + 2];
					final Symbol _symbol_for_indices = _symbols[offset + 3];
					final List for_indices = (List) _symbol_for_indices.value;
					 List arg_list_f = new List().add(new SrcIterExp(exp, for_indices));
                                         return new SrcFunctionArguments(arg_list_f, new List());
			}
			case 225: // function_arguments = arg_list_p.arg_list_p
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					 return new SrcFunctionArguments(arg_list_p, new List());
			}
			case 226: // function_arguments = arg_list_p.arg_list_p COMMA.COMMA named_arguments.named_arguments
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_named_arguments = _symbols[offset + 3];
					final List named_arguments = (List) _symbol_named_arguments.value;
					 return new SrcFunctionArguments(arg_list_p, named_arguments);
			}
			case 228: // function_arguments_named = named_arguments.named_arguments
			{
					final Symbol _symbol_named_arguments = _symbols[offset + 1];
					final List named_arguments = (List) _symbol_named_arguments.value;
					 return new SrcFunctionArguments(new List(), named_arguments);
			}
			case 229: // named_arguments = named_argument.named_argument
			{
					final Symbol _symbol_named_argument = _symbols[offset + 1];
					final SrcNamedArgument named_argument = (SrcNamedArgument) _symbol_named_argument.value;
					 return new List().add(named_argument);
			}
			case 230: // named_arguments = named_arguments.named_arguments COMMA.COMMA named_argument.named_argument
			{
					final Symbol _symbol_named_arguments = _symbols[offset + 1];
					final List named_arguments = (List) _symbol_named_arguments.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_named_argument = _symbols[offset + 3];
					final SrcNamedArgument named_argument = (SrcNamedArgument) _symbol_named_argument.value;
					 return named_arguments.add(named_argument);
			}
			case 231: // function_argument_exp = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return exp;
			}
			case 232: // function_argument_exp = partial_function_call.partial_function_call
			{
					final Symbol _symbol_partial_function_call = _symbols[offset + 1];
					final SrcPartialFunctionCall partial_function_call = (SrcPartialFunctionCall) _symbol_partial_function_call.value;
					 return partial_function_call;
			}
			case 233: // named_argument = named_argument_id.named_argument_id EQUALS.EQUALS function_argument_exp.function_argument_exp
			{
					final Symbol _symbol_named_argument_id = _symbols[offset + 1];
					final SrcAccess named_argument_id = (SrcAccess) _symbol_named_argument_id.value;
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_function_argument_exp = _symbols[offset + 3];
					final SrcExp function_argument_exp = (SrcExp) _symbol_function_argument_exp.value;
					 return new SrcNamedArgument(named_argument_id,function_argument_exp);
			}
			case 234: // named_argument_id = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new SrcNamedAccess(((String)id.value));
			}
			case 235: // matrix = matrix_row.matrix_row
			{
					final Symbol _symbol_matrix_row = _symbols[offset + 1];
					final SrcMatrixRow matrix_row = (SrcMatrixRow) _symbol_matrix_row.value;
					 return new SrcMatrix(new List().add(matrix_row));
			}
			case 236: // matrix = matrix.matrix SEMICOLON.SEMICOLON matrix_row.matrix_row
			{
					final Symbol _symbol_matrix = _symbols[offset + 1];
					final SrcMatrix matrix = (SrcMatrix) _symbol_matrix.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					final Symbol _symbol_matrix_row = _symbols[offset + 3];
					final SrcMatrixRow matrix_row = (SrcMatrixRow) _symbol_matrix_row.value;
					 matrix.addRow(matrix_row); 
                                    return matrix;
			}
			case 237: // matrix_row = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return new SrcMatrixRow(new List().add(exp));
			}
			case 238: // matrix_row = matrix_row.matrix_row COMMA.COMMA exp.exp
			{
					final Symbol _symbol_matrix_row = _symbols[offset + 1];
					final SrcMatrixRow matrix_row = (SrcMatrixRow) _symbol_matrix_row.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 matrix_row.addSrcExp(exp); 
                             return matrix_row;
			}
			case 239: // arg_list = 
			{
					 return new List();
			}
			case 240: // arg_list = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 return new List().add(exp);
			}
			case 241: // arg_list = arg_list.arg_list COMMA.COMMA exp.exp
			{
					final Symbol _symbol_arg_list = _symbols[offset + 1];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					 arg_list.add(exp); 
                           return arg_list;
			}
			case 242: // arg_list_p = function_argument_exp.function_argument_exp
			{
					final Symbol _symbol_function_argument_exp = _symbols[offset + 1];
					final SrcExp function_argument_exp = (SrcExp) _symbol_function_argument_exp.value;
					 return new List().add(function_argument_exp);
			}
			case 243: // arg_list_p = arg_list_p.arg_list_p COMMA.COMMA function_argument_exp.function_argument_exp
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_function_argument_exp = _symbols[offset + 3];
					final SrcExp function_argument_exp = (SrcExp) _symbol_function_argument_exp.value;
					 return arg_list_p.add(function_argument_exp);
			}
			case 244: // comment = string_comment_opt.string_comment annotation_opt.annotation
			{
					final Symbol _symbol_string_comment = _symbols[offset + 1];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_annotation = _symbols[offset + 2];
					final Opt annotation = (Opt) _symbol_annotation.value;
					 return new SrcComment(string_comment,annotation);
			}
			case 245: // string_comment = string_comment_exp.string_comment_exp
			{
					final Symbol _symbol_string_comment_exp = _symbols[offset + 1];
					final SrcExp string_comment_exp = (SrcExp) _symbol_string_comment_exp.value;
					 return new SrcStringComment(string_comment_exp);
			}
			case 247: // string_comment_exp = string_comment_exp.string_comment_exp PLUS.PLUS string.string
			{
					final Symbol _symbol_string_comment_exp = _symbols[offset + 1];
					final SrcExp string_comment_exp = (SrcExp) _symbol_string_comment_exp.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_string = _symbols[offset + 3];
					final SrcStringLitExp string = (SrcStringLitExp) _symbol_string.value;
					 return new SrcAddExp(string_comment_exp, string);
			}
			case 248: // string = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new SrcStringLitExp(((String)s.value));
			}
			case 249: // id_decl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new SrcIdDecl(((String)id.value));
			}
			case 250: // access_expression = access.access
			{
					final Symbol _symbol_access = _symbols[offset + 1];
					final SrcAccess access = (SrcAccess) _symbol_access.value;
					 return new SrcAccessExp(access);
			}
			case 251: // der_expression = DER.DER LPAREN.LPAREN exp.exp RPAREN.RPAREN
			{
					final Symbol DER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final SrcExp exp = (SrcExp) _symbol_exp.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new SrcDerExp(exp);
			}
			case 252: // access = access_loc.access_loc
			{
					final Symbol _symbol_access_loc = _symbols[offset + 1];
					final SrcAccess access_loc = (SrcAccess) _symbol_access_loc.value;
					 return access_loc;
			}
			case 253: // access = DOT.DOT access_loc.access_loc
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol _symbol_access_loc = _symbols[offset + 2];
					final SrcAccess access_loc = (SrcAccess) _symbol_access_loc.value;
					 return new SrcGlobalAccess(access_loc);
			}
			case 256: // access_dot = access_single.a DOT.DOT access_single.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcNamedAccess a = (SrcNamedAccess) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcNamedAccess b = (SrcNamedAccess) _symbol_b.value;
					 return new SrcDot(new List(a, b));
			}
			case 257: // access_dot = access_dot.access_dot DOT.DOT access_single.access_single
			{
					final Symbol _symbol_access_dot = _symbols[offset + 1];
					final SrcDot access_dot = (SrcDot) _symbol_access_dot.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_access_single = _symbols[offset + 3];
					final SrcNamedAccess access_single = (SrcNamedAccess) _symbol_access_single.value;
					 access_dot.addSrcAccess(access_single);
        return access_dot;
			}
			case 260: // access_single_array = ID.id array_subscripts.array_subscripts
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final SrcArraySubscripts array_subscripts = (SrcArraySubscripts) _symbol_array_subscripts.value;
					 return new SrcArrayAccess(((String)id.value), array_subscripts);
			}
			case 261: // access_single_scalar = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new SrcNamedAccess(((String)id.value));
			}
			case 262: // access_scalar = access_scalar_loc.access_scalar_loc
			{
					final Symbol _symbol_access_scalar_loc = _symbols[offset + 1];
					final SrcAccess access_scalar_loc = (SrcAccess) _symbol_access_scalar_loc.value;
					 return access_scalar_loc;
			}
			case 263: // access_scalar = DOT.DOT access_scalar_loc.access_scalar_loc
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol _symbol_access_scalar_loc = _symbols[offset + 2];
					final SrcAccess access_scalar_loc = (SrcAccess) _symbol_access_scalar_loc.value;
					 return new SrcGlobalAccess(access_scalar_loc);
			}
			case 266: // access_scalar_dot = access_single_scalar.a DOT.DOT access_single_scalar.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final SrcNamedAccess a = (SrcNamedAccess) _symbol_a.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final SrcNamedAccess b = (SrcNamedAccess) _symbol_b.value;
					 return new SrcDot(new List(a, b));
			}
			case 267: // access_scalar_dot = access_scalar_dot.access_scalar_dot DOT.DOT access_single_scalar.access_single_scalar
			{
					final Symbol _symbol_access_scalar_dot = _symbols[offset + 1];
					final SrcDot access_scalar_dot = (SrcDot) _symbol_access_scalar_dot.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_access_single_scalar = _symbols[offset + 3];
					final SrcNamedAccess access_single_scalar = (SrcNamedAccess) _symbol_access_single_scalar.value;
					 access_scalar_dot.addSrcAccess(access_single_scalar);
        return access_scalar_dot;
			}
			case 268: // end_decl = END_ID.END_ID
			{
					final Symbol END_ID = _symbols[offset + 1];
					 String value = (String) END_ID.value;
        String id = value.substring(3, value.length()).trim();
        return new SrcEndDecl(id);
			}
			case 269: // string_comment_opt = 
			{
					 return new Opt();
			}
			case 270: // string_comment_opt = string_comment.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcStringComment n = (SrcStringComment) _symbol_n.value;
					 return new Opt(n);
			}
			case 271: // function_arguments_opt = 
			{
					 return new Opt();
			}
			case 272: // function_arguments_opt = function_arguments.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcFunctionArguments n = (SrcFunctionArguments) _symbol_n.value;
					 return new Opt(n);
			}
			case 273: // value_modification_opt = 
			{
					 return new Opt();
			}
			case 274: // value_modification_opt = value_modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcValueModification n = (SrcValueModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 275: // constraining_clause_opt = 
			{
					 return new Opt();
			}
			case 276: // constraining_clause_opt = constraining_clause.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcConstrainingClause n = (SrcConstrainingClause) _symbol_n.value;
					 return new Opt(n);
			}
			case 277: // element_opt_list = 
			{
					 return new List();
			}
			case 278: // element_opt_list = element_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 279: // element_list = element.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcElement n = (SrcElement) _symbol_n.value;
					 return new List().add(n);
			}
			case 280: // element_list = element_list.l element.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final SrcElement n = (SrcElement) _symbol_n.value;
					 return l.add(n);
			}
			case 281: // type_prefix_variability_opt = 
			{
					 return new Opt();
			}
			case 282: // type_prefix_variability_opt = type_prefix_variability.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcTypePrefixVariability n = (SrcTypePrefixVariability) _symbol_n.value;
					 return new Opt(n);
			}
			case 283: // for_in_exp_opt = 
			{
					 return new Opt();
			}
			case 284: // for_in_exp_opt = for_in_exp.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcExp n = (SrcExp) _symbol_n.value;
					 return new Opt(n);
			}
			case 285: // access_opt = 
			{
					 return new Opt();
			}
			case 286: // access_opt = access.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcAccess n = (SrcAccess) _symbol_n.value;
					 return new Opt(n);
			}
			case 287: // type_prefix_input_output_opt = 
			{
					 return new Opt();
			}
			case 288: // type_prefix_input_output_opt = type_prefix_input_output.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcTypePrefixInputOutput n = (SrcTypePrefixInputOutput) _symbol_n.value;
					 return new Opt(n);
			}
			case 289: // else_if_equation_opt = 
			{
					 return new Opt();
			}
			case 290: // else_if_equation_opt = else_if_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcIfWhenElseEquation n = (SrcIfWhenElseEquation) _symbol_n.value;
					 return new Opt(n);
			}
			case 291: // class_modification_opt = 
			{
					 return new Opt();
			}
			case 292: // class_modification_opt = class_modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcClassModification n = (SrcClassModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 293: // annotation_opt = 
			{
					 return new Opt();
			}
			case 294: // annotation_opt = annotation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcAnnotation n = (SrcAnnotation) _symbol_n.value;
					 return new Opt(n);
			}
			case 295: // within_opt = 
			{
					 return new Opt();
			}
			case 296: // within_opt = within.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcWithin n = (SrcWithin) _symbol_n.value;
					 return new Opt(n);
			}
			case 297: // function_arguments_named_opt = 
			{
					 return new Opt();
			}
			case 298: // function_arguments_named_opt = function_arguments_named.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcFunctionArguments n = (SrcFunctionArguments) _symbol_n.value;
					 return new Opt(n);
			}
			case 299: // abstract_equation_opt_list = 
			{
					 return new List();
			}
			case 300: // abstract_equation_opt_list = abstract_equation_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 301: // abstract_equation_list = abstract_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcAbstractEquation n = (SrcAbstractEquation) _symbol_n.value;
					 return new List().add(n);
			}
			case 302: // abstract_equation_list = abstract_equation_list.l abstract_equation.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final SrcAbstractEquation n = (SrcAbstractEquation) _symbol_n.value;
					 return l.add(n);
			}
			case 303: // external_function_call_opt = 
			{
					 return new Opt();
			}
			case 304: // external_function_call_opt = external_function_call.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcExternalFunctionCall n = (SrcExternalFunctionCall) _symbol_n.value;
					 return new Opt(n);
			}
			case 305: // class_annotation_opt = 
			{
					 return new Opt();
			}
			case 306: // class_annotation_opt = class_annotation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcAnnotation n = (SrcAnnotation) _symbol_n.value;
					 return new Opt(n);
			}
			case 307: // external_language_opt = 
			{
					 return new Opt();
			}
			case 308: // external_language_opt = external_language.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcExternalLanguage n = (SrcExternalLanguage) _symbol_n.value;
					 return new Opt(n);
			}
			case 309: // else_when_equation_opt = 
			{
					 return new Opt();
			}
			case 310: // else_when_equation_opt = else_when_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcWhenEquation n = (SrcWhenEquation) _symbol_n.value;
					 return new Opt(n);
			}
			case 311: // external_clause_opt = 
			{
					 return new Opt();
			}
			case 312: // external_clause_opt = external_clause.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcExternalClause n = (SrcExternalClause) _symbol_n.value;
					 return new Opt(n);
			}
			case 313: // modification_opt = 
			{
					 return new Opt();
			}
			case 314: // modification_opt = modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcModification n = (SrcModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 315: // conditional_attribute_opt = 
			{
					 return new Opt();
			}
			case 316: // conditional_attribute_opt = conditional_attribute.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcConditionalAttribute n = (SrcConditionalAttribute) _symbol_n.value;
					 return new Opt(n);
			}
			case 317: // type_prefix_flow_opt = 
			{
					 return new Opt();
			}
			case 318: // type_prefix_flow_opt = type_prefix_flow.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcTypePrefixFlow n = (SrcTypePrefixFlow) _symbol_n.value;
					 return new Opt(n);
			}
			case 319: // statement_opt_list = 
			{
					 return new List();
			}
			case 320: // statement_opt_list = statement_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 321: // statement_list = statement.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcStatement n = (SrcStatement) _symbol_n.value;
					 return new List().add(n);
			}
			case 322: // statement_list = statement_list.l statement.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final SrcStatement n = (SrcStatement) _symbol_n.value;
					 return l.add(n);
			}
			case 323: // array_subscripts_opt = 
			{
					 return new Opt();
			}
			case 324: // array_subscripts_opt = array_subscripts.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final SrcArraySubscripts n = (SrcArraySubscripts) _symbol_n.value;
					 return new Opt(n);
			}
			case 0: // $goal = source_root
			case 227: // function_arguments = function_arguments_named.function_arguments_named
			case 246: // string_comment_exp = string.string
			case 254: // access_loc = access_single.access_single
			case 255: // access_loc = access_dot.access_dot
			case 258: // access_single = access_single_array.access_single_array
			case 259: // access_single = access_single_scalar.access_single_scalar
			case 264: // access_scalar_loc = access_scalar_dot.access_scalar_dot
			case 265: // access_scalar_loc = access_single_scalar.access_single_scalar
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $anonymous_short_class anonymous_short_class
			case 2: // $goal = $exp exp
			case 3: // $goal = $element element
			case 4: // $goal = $abstract_equation abstract_equation
			case 5: // $goal = $argument argument
			case 6: // $goal = $access_scalar access_scalar
			{
				return _symbols[offset + 2];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
