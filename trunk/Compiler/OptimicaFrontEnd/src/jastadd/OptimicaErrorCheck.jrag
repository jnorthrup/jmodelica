/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect OptimicaErrorCheck {

  	public void InstOptClassDecl.collectErrors() {
    	super.collectErrors();
    	getFConstraintList().collectErrors();
    	getInstClassModificationOpt().collectErrors();
    	
    	//TODO: this code is duplicated from InstPrimitive.typeCheck()
    	// which is pretty brute force. There is a note on refactorization
    	// of this code in ModelicaFrontEnd which possibly could simplify things.
    	if (hasInstClassModification()) {
    		for (InstModification im : getInstClassModification().getInstArgumentList()) {
    			// Only check attributes, value modifications are checked above
    			if (im instanceof InstComponentModification) {
    				InstComponentModification icm = (InstComponentModification) im;
    				if (icm.getInstModification().hasInstValueMod()) {
    					FExp val_mod = icm.getInstModification().instValueMod();
    					if (!icm.type().isUnknown() && !val_mod.type().isUnknown()) {
    						//FPrimitiveType attr_type = attributeType(icm);
    						FPrimitiveType attr_type = icm.type();
    						if (!icm.type().typeCompatible(val_mod.type().scalarType())) {
    							icm.error("The type of the binding expression of the attribute " + icm.name() +
    							" does not match the declared type of the variable");							
    						} else if (!icm.getEach() && !attr_type.dimensionCompatible(val_mod.type())) { 
    							icm.error("Array size mismatch for the attribute " + icm.name() +
    									", size of declaration is " + Arrays.toString(attr_type.size()) + 
    									" and size of " + icm.name() + " expression is " + 
    									Arrays.toString(val_mod.size()));
    						} else if (icm.getEach()) { 
    							if (ndims() == 0) {
    								icm.error("The 'each' keyword cannot be applied to attributes of scalar components");
    							} else if (val_mod.ndims() > 0) {
    								icm.error("The attribute " + icm.name() + 
    								" is declared 'each' and the binding expression is not scalar");
    							}
    						}
    					}
    				}
    			}
    		}
    	}

    	
  	}

	public void FOptClass.checkFClassDimensions() {
		// Check dimensions of DAE
		int n_eq_F = numScalarEquations() + numPathEqConstraints();
		int n_vars_F = numAlgebraicRealVariables() + numDifferentiatedRealVariables();
		if (n_eq_F!=n_vars_F) {
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		}
		
		// Check dimensions of DAE initialization system
		// Notice that this check is stricter than in the Modelica case,
		// since here we really need initialization system to be balanced.
		// The F1 equations can in the simulation case be used to derive
		// initial conditions for the states, but for the simultaneous
		// optimization algorithm, this is not the case.
		int n_eq_F0 = numInitialEquations() + numScalarEquations() + numPathEqConstraints();
		int n_vars_F0 = numAlgebraicRealVariables() + 2*numDifferentiatedRealVariables();
		if (n_eq_F0<n_vars_F0) {
			warning("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		}
		if (n_eq_F0>n_vars_F0) {
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		}

	
	}
  	
	  public void FConstraint.typeCheck() {
		  //System.out.println("FEquation.typeCheck(): " + getLeft().type() + " " + getRight().type());
		  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
			  if (!getLeft().type().equivalentTo(getRight().type())) {
				  error("The right and left expression types of constraint are" +
			  			" not compatible");		  
			  }
		  }
	  }
}