/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect OptimicaFlattening {

	// Check if the InstOptClassDecl matches the name of class to be flattened. 
	public InstNode InstOptClassDecl.findFlattenInst(String className, FClass fc) {
		FOptClass foc = (FOptClass)fc;
   		if (className.equals(qualifiedName())) {
  	 		foc.setFQName(new FQName(qualifiedName())); 
  	 		//InstRoot r = getInstRoot();
  	 				
			//r.dumpTree("");
			//r.printIVarAccesses("");
			foc.addFEquationBlock(new FEquationBlock(new List()));			
			for (AbstractEquation ae : equations()) {
		       ae.flatten(getFQName(),foc);
		    }
			for (Constraint c : constraints()) {
		       c.flatten(getFQName(),foc);
		    }

//			for (InstComponentDecl n : getInstComponentDecls())
//				n.flatten(foc);
			getInstComponentDeclList().flatten(foc);
			getInstExtendsList().flatten(foc);
           
			foc.genConnectionEquations();
			OptClassDecl ocd = (OptClassDecl)getClassDecl();
			if (ocd.hasClassModification()) {
				List attr = new List();
				ocd.getClassModification().collectAttributes(attr,new FQName(new List()));
				foc.setFAttributeList(attr);
			}
			return this;	
   		} else {
  			return super.findFlattenInst(className,fc);
   		}  	
	}	
	
	refine Flattening public void InstNode.flatten(FClass fc) {
		for (AbstractEquation ae : equations()) {
		   ae.flatten(getFQName(),fc);
		}
        for (Constraint c : constraints()) {
           c.flatten(getFQName(),fc);
        }
		getInstComponentDeclList().flatten(fc);
		getInstExtendsList().flatten(fc);
	}	

	syn lazy ArrayList<Constraint> ClassDecl.constraints() = new ArrayList<Constraint>();
	eq OptClassDecl.constraints() {
	    ArrayList<Constraint> l = new ArrayList<Constraint>();
		for (Constraint c : getConstraints())
			l.add(c);
		return l;
	}
	eq ShortClassDecl.constraints() = getExtendsClauseShortClass().getSuper().myClassDecl().constraints();
	
	syn ArrayList<Constraint> InstNode.constraints() = new ArrayList<Constraint>();
	eq InstClassRoot.constraints() = getClassDecl().constraints();
	eq InstOptClassDecl.constraints() = getClassDecl().constraints();
	eq InstComponentDecl.constraints() = getComponentDecl().myClass().constraints();
	eq InstExtends.constraints() = getExtendsClause().getSuper().myClassDecl().constraints();
	
    public void Constraint.flatten(FQName prefix, FClass fc) {}

	public void ConstraintEq.flatten(FQName prefix, FClass fc) {
		FOptClass foc = (FOptClass)fc;
		foc.addFConstraint(new FConstraintEq(getLeft().flatten(prefix),getRight().flatten(prefix)));
	}

	public void ConstraintLeq.flatten(FQName prefix, FClass fc) {
		FOptClass foc = (FOptClass)fc;
		foc.addFConstraint(new FConstraintLeq(getLeft().flatten(prefix),getRight().flatten(prefix)));
	}

	public void ConstraintGeq.flatten(FQName prefix, FClass fc) {
		FOptClass foc = (FOptClass)fc;
		foc.addFConstraint(new FConstraintGeq(getLeft().flatten(prefix),getRight().flatten(prefix)));
	}

	public FExp InstantValue.flatten(FQName prefix) {
		return new FInstantValue(new FIdUseQualified("",new FQName().append(getName(),prefix)),
		   getArg().flatten(prefix));
	}
}