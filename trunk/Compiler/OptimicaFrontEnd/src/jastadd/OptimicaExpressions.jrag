/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect OptimicaExpressions {

	rewrite InstFunctionCall {
		when (//((getName() instanceof InstDot)? 
				//	((InstDot)getName()).getLeft()!=null: true) && 
				getName().getLastInstAccess() instanceof InstComponentAccess &&
				getNumArg()==1)
		 to InstTimedVariable {
//			System.out.println("rewrite InstFunctionCall: " + getName().name());
		 	InstTimedVariable iv = new InstTimedVariable(getName(), getArg(0).getFExp());
		 	iv.setLocation(this);
		 	return iv;
		 }
	}
	
	rewrite FIdUseExp {
		when (name().equals("startTime")) to FStartTimeExp {
			return new FStartTimeExp();
		}
	}

	rewrite FIdUseExp {
		when (name().equals("finalTime")) to FFinalTimeExp {
			return new FFinalTimeExp();
		}
	}
	
	refine InstNameClassification eq InstFunctionCall.getName().kind() = Kind.AMBIGUOUS_ACCESS;
	
	eq FStartTimeExp.ceval() {
		if (myFOptClass().startTimeAttributeSet()) {
			return myFOptClass().startTimeAttributeCValue();
		} else if (myFOptClass().startTimeInitialGuessAttributeSet()) {
			return myFOptClass().startTimeInitialGuessAttributeCValue();
		} else {
			return myFOptClass().startTimeAttributeCValue();
		}
	}

	eq FFinalTimeExp.ceval() {
		if (myFOptClass().finalTimeAttributeSet()) {
			return myFOptClass().finalTimeAttributeCValue();
		} else if (myFOptClass().finalTimeInitialGuessAttributeSet()) {
			return myFOptClass().finalTimeInitialGuessAttributeCValue();
		} else {
			return myFOptClass().finalTimeAttributeCValue();
		}
	}
	
	public FExp FTimedVariable.scalarize(HashMap<String,Integer> indexMap) { 
		return new FTimedVariable((FIdUse)getName().fullCopy(),getArg().scalarize(indexMap)); 
	}
	
	boolean FTimedVariable.rewritten = false;
	
	/**
	 * \brief FTimedVariables referring to alias variables need to be changed to 
	 * FTimedVariables referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FTimedVariables needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FTimedVariable {
		when (!rewritten && myFClass() != null && 
				myFClass().aliasVariablesEliminated &&
				!getName().myFV().isUnknown() && getName().myFV().isAlias()) to FExp {
			FQName new_name = (FQName)((FVariable)getName().myFV()).alias().getFQName().fullCopy();
			//FQName old_name = getName().getFQName();
			//System.out.println(" ************************************* FIdUseExp.rewrite " + old_name.name() + " -> " + new_name.name());

			FExp new_exp = null;
			FTimedVariable tv = new FTimedVariable(new FIdUse(new_name),getArg());
			tv.rewritten = true;
			if (getName().myFV().isNegated()) {
				new_exp = new FNegExp(tv);
			} else {
				new_exp = tv;
			}
			return new_exp;
		}
	}
	
	public void FTimedVariable.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
}

aspect OptimicaInheritedFactoryMethods {

	public FTimedVariable    FTimedVariable.createEmptyNode()    { return new FTimedVariable(); }
	public InstTimedVariable InstTimedVariable.createEmptyNode() { return new InstTimedVariable(); }
	
	public FStartTimeExp FStartTimeExp.createEmptyNode() { return new FStartTimeExp(); }
	public FFinalTimeExp FFinalTimeExp.createEmptyNode() { return new FFinalTimeExp(); }
	
}

aspect OptimicaArrays {
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FConstraint.ndims() {
		if (getLeft().ndims() == getRight().ndims()) {
			return getLeft().ndims();
		}
		return -1;
	}	
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn int[] FConstraint.size() {
		int[] leftSize = getLeft().size();
		int[] rightSize = getRight().size();
		if (leftSize.length!=rightSize.length) {
			return new int[0];
		}
		for (int i=0;i<leftSize.length;i++) {
			if (leftSize[i]!=rightSize[i]) {
				return new int[0];
			}
		}
		return leftSize;
	}

	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FConstraint.indices() = getLeft().indices();

}

