aspect OptimicaTransformCanonical {
	
	public void FOptClass.scalarize() {
		
		/* Notice that it is not ok to call super.scalarize() here, since
		 * then the scalarized variable lists will be set prior to
		 * scalarizing the constraints and costfunctions, which will make
		 * lookup in the constraint scalarization fail.
		 */
				
		List<FVariable> vars = new List<FVariable>();
		List<FVariable> alias_vars = new List<FVariable>();
		// Scalarize all non-alias variables
		for (FVariable fv : getFVariables()) {
			fv.scalarize(vars);
		}
		// Scalarize alias variables
		for (FVariable fv : getAliasVariables()) {
			fv.scalarize(alias_vars);
		}
		
		// Scalarize equations
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFEquationBlock(0).getFAbstractEquations()) {
			ae.scalarize(eqns,new HashMap<String,Integer>());
		}
		getFEquationBlock(0).setFAbstractEquationList(eqns);
		List<FAbstractEquation> ieqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFInitialEquations()) {
			ae.scalarize(ieqns,new HashMap<String,Integer>());
		}
		setFInitialEquationList(ieqns);		
		
		// Scalarize constraints
		List<FConstraint> constr = new List<FConstraint>();
		for (FConstraint c : getFConstraints()) {
			c.scalarize(constr,new HashMap<String,Integer>());
		}
		setFConstraintList(constr);

		// Scalarize class attributes
		// Iterate over all attributes and scalarize.
		for (FAttribute a : getFAttributes()) 
			a.scalarize(new Index());
		
		// Replace variables
		setFVariableList(vars);
		setAliasVariableList(alias_vars);
		
		// Replace subscript expressions with literals
		eqns.makeSubscriptsLiteral();
		ieqns.makeSubscriptsLiteral();
		constr.makeSubscriptsLiteral();

		flush();		
	}
	
	/**
	 * \brief Scalarize constraint and put all scalarized equations in list eqns.
	 */
	public void FConstraint.scalarize(List<FConstraint> constr, 
			HashMap<String,Integer> indexMap) {
		//System.out.println("FEquation.scalarize() " + ndims());
		if (ndims()==0) {
			/**
			 * If the constraint is of dimension 0, i.e, already scalar,
			 * the equations is "scalarized" into a simple equation where
			 * e.g. built in functions are replaced by elementary operations.
			 */
			FConstraint c = createEmptyNode();
			c.setLeft(getLeft().scalarize(indexMap));
			c.setRight(getRight().scalarize(indexMap));
			constr.addChild(c);
		} else if (ndims() > 0) {
			/**
			 * If the expression is an array expression, then the FExp.getArray()
			 * element is used to generate scalar equations.
			 */
			// Iterate over array elements and create scalarized equation for each
			for (Index i : indices()) { 
				FConstraint c = createEmptyNode();
				c.setLeft((FExp) getLeft().getArray().get(i).scalarize(indexMap));
				c.setRight((FExp) getRight().getArray().get(i).scalarize(indexMap));
				constr.addChild(c);
			}
		}
	}

	
	/**
	 * \brief Scalarize equation and put all scalarized equations in list eqns.
	 */
/*	public void FFunctionCallEquation.scalarize(List<FAbstractEquation> eqns, 
			HashMap<String,Integer> indexMap) {
		List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft id : getLefts())
			lefts.add(id.scalarize(indexMap));
		eqns.addChild(new FFunctionCallEquation(lefts, (FAbstractFunctionCall) getCall().scalarize(indexMap)));
	}
	*/
	/*
	public void FForClauseE.scalarize(List<FAbstractEquation> eqns,
			HashMap<String,Integer> indexMap) {
		Indices indices = Indices.create(getFForIndexs());
		
		HashMap<String,Integer> myIndexMap = new HashMap<String,Integer>();
		myIndexMap.putAll(indexMap);
		for (Index i : indices) {
			int j = 0;
			int[] ii = indices.translate(i).index();
			for (FForIndex fi : getFForIndexs()) {
				myIndexMap.put(fi.getFVariable().name(), Integer.valueOf(ii[j]));
				j++;
			}
			
			for (FAbstractEquation ae : getFAbstractEquations()) {
				ae.scalarize(eqns, myIndexMap);
			}
		}		
	}
	
	*/
	
	public FExp FTimedVariable.scalarize(HashMap<String,Integer> indexMap) { 
		return new FTimedVariable(getName().scalarize(indexMap),getArg().scalarize(indexMap)); 
	}
	
	public FExp FStartTimeExp.scalarize(HashMap<String,Integer> indexMap) { return new FStartTimeExp(); } 
	public FExp FFinalTimeExp.scalarize(HashMap<String,Integer> indexMap) { return new FFinalTimeExp(); } 
	
}
