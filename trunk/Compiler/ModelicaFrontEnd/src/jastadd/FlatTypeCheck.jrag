/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Arrays;
import java.util.Collections;

aspect FlatTypeCheck {
	
  public void ASTNode.typeCheck() {
	  
  }
 
 
    public void InstPrimitive.typeCheck() {
    	FExp bexp = myBindingInstExp();
    	if (bexp != null && !bexp.type().isUnknown()) {
    		if (myBindingExpHasEach() && !inArrayComponent()) {
    			error("The 'each' keyword cannot be applied to members of non-array components");
     		} else {
    			if (!bindingType().typeCompatible(bexp.type())) {
    				if (!bindingType().scalarType().typeCompatible(bexp.type().scalarType())) {
    					error("The binding expression of the variable " + name() +
    							" does not match the declared type of the variable");
    				} else {
    					error("Array size mismatch in declaration of " + 
    							(myBindingExpHasEach() ? "each " : "") + name() +
    							", size of declaration is " + Arrays.toString(bindingType().size()) + 
    							" and size of binding expression is " + 
    							Arrays.toString(bexp.size()));
     				}
    			}
    		}
	    }
	  
    	// TODO: Can't this be moved to InstComponentModification.typeCheck()?
    	// This code is duplicated in FOptClass in OptimicaFrontEnd 
    	// (OptimicaErrorCheck.jrag). If the suggested factorization is
    	// done then that code could probably be simplified too.
 	    // Check the type correctness of attributes
	    for (InstModification im : totalMergedEnvironment()) {
		    // Only check attributes, value modifications are checked above
		    if (im instanceof InstComponentModification) {
			    InstComponentModification icm = (InstComponentModification) im;
				if (icm.getInstModification().hasInstValueMod()) {
					FExp val_mod = icm.getInstModification().instValueMod();
					if (!icm.type().isUnknown() && !val_mod.type().isUnknown()) {
						FPrimitiveType attr_type = attributeType(icm);
						if (!icm.type().typeCompatible(val_mod.type().scalarType())) {
							icm.error("The type of the binding expression of the attribute " + icm.name() +
							  " does not match the declared type of the variable");							
						} else if (!icm.getEach() && !attr_type.dimensionCompatible(val_mod.type())) { 
							icm.error("Array size mismatch for the attribute " + icm.name() +
									", size of declaration is " + Arrays.toString(attr_type.size()) + 
									" and size of " + icm.name() + " expression is " + 
									Arrays.toString(val_mod.size()));
						} else if (icm.getEach()) { 
							if (ndims() == 0) {
								icm.error("The 'each' keyword cannot be applied to attributes of scalar components");
							} else if (val_mod.ndims() > 0) {
								icm.error("The attribute " + icm.name() + 
										" is declared 'each' and the binding expression is not scalar");
							}
						}
					}
				}
			}
		}
    }
    
  public void FEquation.typeCheck() {
	  //System.out.println("FEquation.typeCheck(): " + getLeft().type() + " " + getRight().type());
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (!getLeft().type().equivalentTo(getRight().type())) {
			  error("The right and left expression types of equation are" +
		  			" not compatible");		  
		  }
	  }
  }
  
  // Generic typeCheck() that calls typeError() if type is unknown and no FExp child has unknown type
  public void FExp.typeCheck() {
	  if (type().isUnknown()) {
		  for (ASTNode n : this) {
			  if (isUnknownFExp(n))
				  return;
			  if (n instanceof List) 
				  for (ASTNode n2 : (List<ASTNode>) n) 
					  if (isUnknownFExp(n2))
						  return;
			  if (n instanceof Opt && n.getNumChild() > 0 && isUnknownFExp(n.getChild(0)))
				  return;
		  }
		  typeError();
	  }
  }
  
  protected static boolean FExp.isUnknownFExp(ASTNode n) {
	  return n instanceof FExp && ((FExp) n).type().isUnknown();
  }
  
  // TODO: Add specialized typeError() methods that gived better error message
  
  public void FExp.typeError() {
	  error("Type error in expression");	  
  }

  
  // FIdUseExp and FInstAccessExp ska inte kollas, det görs i InstAccess
  public void FIdUseExp.typeCheck() {}
  public void FInstAccessExp.typeCheck() {}
  
  /**
   * \brief Check if the FExp of this FIterExp must be scalar.
   */
  inh boolean FIterExp.iterExpMustBeScalar();
  eq FExp.getChild().iterExpMustBeScalar()       = false;
  eq Root.getChild().iterExpMustBeScalar()       = false;
  eq InstNode.getChild().iterExpMustBeScalar()   = false;
  eq FMinMaxExp.getChild().iterExpMustBeScalar() = true;
  // TODO: Add product() when it is implemented
  
  // FIterExp has simplified type() that cannot be unknown if getFExp().type() isn't unknown
  public void FIterExp.typeCheck() {
	  if (iterExpMustBeScalar() && !getFExp().type().isUnknown() && getFExp().ndims() != 0)
		  error("The expression of a reduction-expression must be scalar, except for sum(): " +
				  getFExp() + " has ndims() = " + getFExp().ndims());
  }
  
  public void InstForIndex.typeCheck() {
	  if (hasFExp() && !getFExp().type().isUnknown() && getFExp().ndims() != 1)
		  error("The expression of for index " + name() + " must be a vector expression: " + 
				  getFExp() + " has ndims() = " + getFExp().ndims());
  }
  
  public void FExpSubscript.typeCheck() {
	  if (ndims() > 1) { 
		  error("Array index must be scalar or vector expression: " + getFExp());
	  } else if (!type().isInteger()) { // TODO: Expand to support Boolean and enums
		  error("Array index must be Integer expression: " + getFExp());
	  } else if (!inFunction() && !getFExp().variability().lessOrEqual(fParameter())) {
		  error("Array index in equation must be constant, parameter or loop index: " + getFExp());
	  } else {
		  int max = mySize()[0];
		  for (FExp e : getExpanded().iterable()) {
			  int i = e.ceval().intValue();
			  if (i < 1 || i > max) {
				  error("Array index out of bounds: " + i + ", index expression: "+ getFExp());
				  return;
			  }
		  }
	  }
  }
  
  
  public void InstComponentAccess.typeCheck() {
	//  System.out.println("InstComponentAccess.typeCheck: " + printSlice());
  }
  
  
  public void InstAssignStmt.typeCheck() {
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (getLeft().isForIndex())
			  error("Can not assign a value to a for loop index");
		  else if (!getLeft().type().typeCompatible(getRight().type())) 
			  error("Types of right and left side of assignment are not compatible");		  
	  }
  }
  
  public void FWhileStmt.typeCheck() {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of while statement is not Boolean");
  }
  
  public void FIfClause.typeCheck() {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if statement is not Boolean");
  }
  
  public void FWhenClause.typeCheck() {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when statement isn't Boolean scalar or vector expression");
		  // TODO: This will cause NullPointerException until FInstAccessExp.variability() is defined
//		  if (!getTest().variability().lessOrEqual(fDiscrete()))
//			  error("Test expression of when statement isn't discrete-time");
	  }
  }
  
  
  public void FInfArgsFunctionCall.typeCheck() {
      super.typeCheck();
      if (getNumOriginalArg() < minNumArgs()) {
    	  error("Too few arguments to " + builtInName() + "(), must have at least " + minNumArgs());
      } else {
	      for (FExp exp : getFExps()) {
	          if (!exp.type().isUnknown() && !typeOfArgIsOK(exp)) {
	              exp.error("Argument of " + builtInName() + "() is not " + 
	            		  getOKArgTypeString() + ": " + exp.prettyPrint(""));
	          } else if (!variabilityOfArgIsOK(exp)) {
	        	  exp.error("Argument of " + builtInName() + "() does not have " + 
	        			  getOKArgVariabilityString() + " variability: " + exp.prettyPrint(""));
	          }
	      }
      }
  }
  
  syn int FInfArgsFunctionCall.minNumArgs() = 1;
  eq FFillExp.minNumArgs() = 2;
  
  syn boolean FInfArgsFunctionCall.typeOfArgIsOK(FExp exp) = fIntegerScalarType().typeCompatible(exp.type());
  syn String FInfArgsFunctionCall.getOKArgTypeString() = "compatible with Integer";
  
  syn boolean FInfArgsFunctionCall.variabilityOfArgIsOK(FExp exp) = exp.variability().lessOrEqual(fParameter());
  syn String FInfArgsFunctionCall.getOKArgVariabilityString() = "constant or parameter";
  
  public void FBuiltInFunctionCall.typeCheck() {
	  if (checkTypeAsExpression())
		  super.typeCheck();
	  if (myLefts().size() > 1)
		  error("Too many components assigned from function call: " + builtInName() + 
				  "() has 1 output(s)");
  }
  
  syn boolean FBuiltInFunctionCall.checkTypeAsExpression() = false;
  eq FSizeExp.checkTypeAsExpression() = true;
  eq FMinMaxExp.checkTypeAsExpression() = true;
  
  public void InstFunctionCall.typeCheck() {
	  if (myOutputs().size() < myLefts().size())
		  error("Too many components assigned from function call: " + getName().name() + 
				  "() has " + myOutputs().size() + " output(s)");
  }
  
  public void FFunctionCallLeft.typeCheck() {
	  if (hasFIdUse() && !type().isUnknown() && !myOutput().isUnknown()) { // Avoid duplicate error
		  if (getFIdUse().isForIndex())
			  error("Can not assign a value to a for loop index");
		  else if (!type().typeCompatible(myOutput().type())) 
			  error("Types of component " + getFIdUse().name() + " and output " + 
					  myOutput().name() + " are not compatible");
	  }
  }
  
  public void InstFunctionArgument.typeCheck() {
	  if (!getFExp().type().isUnknown() && !getBoundInput().type().isUnknown()) {
		  boolean typeOk;
		  if (argumentDefinedTypeValid()) 
			  typeOk = getBoundInput().type().typeCompatible(getFExp().type());
		  else
			  typeOk = argumentTypeValid(getFExp().type());
		  if (!typeOk) {
			  error("Types of " + argumentDesc() + " and input " + getBoundInput().name() + 
					  " are not compatible");
		  }
	  }
  }
  
  public void InstMissingArgument.typeCheck() {
	  error("Missing argument for required input " + getBoundInput().name());
  }
  
  public void InstMultipleBoundArgument.typeCheck() {
	  error("Multiple arguments matches input " + getBoundInput().name());
  }
  
  public void InstDefaultArgument.typeCheck() {}
  
  protected String InstFunctionArgument.argumentDesc() { return null; }
  
  protected String InstPositionalArgument.argumentDesc() {
	  return "positional argument " + (getPos() + 1);
  }
  
  protected String InstNamedArgument.argumentDesc() {
	  return "named argument " + getName().prettyPrint("");
  }
  
  /**
   * \brief Check if the type defined for this argument in the built-in function list 
   *        is valid.
   */
  inh boolean InstFunctionArgument.argumentDefinedTypeValid();
  eq FAbstractFunctionCall.getChild().argumentDefinedTypeValid() = true;
  eq FTranspose.getChild().argumentDefinedTypeValid()            = false;
  eq FMinMaxExp.getChild().argumentDefinedTypeValid()            = false;
  eq FSumExp.getChild().argumentDefinedTypeValid()               = false;
  eq FSizeExp.getOriginalArg(int i).argumentDefinedTypeValid()   = i != 0;
 
  /**
   * \brief Check if the type supplied is valid for this argument.
   * 
   * Only used if argumentDefinedTypeValid() returns <code>false</code>.
   */
  inh boolean InstFunctionArgument.argumentTypeValid(FPrimitiveType type);
  eq FAbstractFunctionCall.getChild().argumentTypeValid(FPrimitiveType type) = false;
  eq FTranspose.getChild().argumentTypeValid(FPrimitiveType type)            = type.ndims() >= 2;
  eq FSizeExp.getChild().argumentTypeValid(FPrimitiveType type)              = true;
  eq FSumExp.getChild().argumentTypeValid(FPrimitiveType type)               = type.ndims() > 0;
  eq FMinMaxExp.getOriginalArg(int i).argumentTypeValid(FPrimitiveType type) = 
	  hasY() ^ getOriginalArg(i).getFExp().isArray();
  
}