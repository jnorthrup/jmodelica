/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Arrays;
import java.util.Collections;

aspect FlatTypeCheck {
	
  public void ASTNode.typeCheck() {
	  
  }
 
 
    public void InstAssignable.typeCheck() {
    	FExp bexp = myBindingInstExp();
    	if (bexp != null && !bexp.type().isUnknown()) {
    		if (myBindingExpHasEach() && !inArrayComponent()) {
    			error("The 'each' keyword cannot be applied to members of non-array components");
     		} else {
    			if (!bindingType().typeCompatible(bexp.type())) {
    				if (!myBindingExpHasEach() && type().typeCompatible(bexp.type())) {
						warning("Assuming 'each' for the binding expression to the variable " + name());
    				} else if (!bindingType().scalarType().typeCompatible(bexp.type().scalarType())) {
    					error("The binding expression of the variable " + name() +
    							" does not match the declared type of the variable");
    				} else {
    					error("Array size mismatch in declaration of " + 
    							(myBindingExpHasEach() ? "each " : "") + name() +
    							", size of declaration is " + bindingType().size() + 
    							" and size of binding expression is " + bexp.size());
     				}
    			}
    		}
	    }
	  
    	typeCheckAttributes();
    }
    
    public void InstAssignable.typeCheckAttributes() {}
    
    public void InstPrimitive.typeCheckAttributes() {
	    for (InstModification im : totalMergedEnvironment()) 
	    	im.typeCheckAttribute(this);
     }
   
    public void InstModification.typeCheckAttribute(InstNode owner) {}

    public void InstComponentModification.typeCheckAttribute(InstNode owner) {
    	if (hasInstModification() && getInstModification().hasInstValueMod()) {
			FExp val_mod = getInstModification().instValueMod();
			if (!type().isUnknown() && !val_mod.type().isUnknown()) {
				FType attr_type = owner.attributeType(this);
				if (!type().typeCompatible(val_mod.type().scalarType())) {
					error("The type of the binding expression of the attribute " + name() +
					  " does not match the declared type of the variable");
				} else if (!getEach() && !attr_type.dimensionCompatible(val_mod.type())) { 
					if (val_mod.ndims() == 0) {
						warning("Assuming 'each' for the attribute " + name());
					} else {
						error("Array size mismatch for the attribute " + name() +
								", size of declaration is " + attr_type.size() + 
								" and size of " + name() + " expression is " + val_mod.size());
					}
				} else if (getEach()) { 
					if (owner.ndims() == 0) {
						error("The 'each' keyword cannot be applied to attributes of scalar components");
					} else if (val_mod.ndims() > 0) {
						error("The attribute " + name() + 
								" is declared 'each' and the binding expression is not scalar");
					}
				}
			}
    	}
    }
    
  public void FEquation.typeCheck() {
	  //log.debug("FEquation.typeCheck(): " + getLeft().type() + " " + getRight().type());
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (!getLeft().type().equivalentTo(getRight().type())) {
			  error("The right and left expression types of equation are" +
		  			" not compatible");		  
		  }
	  }
  }
  
  // Generic typeCheck() that calls typeError() if type is unknown and no FExp child has unknown type
  public void FExp.typeCheck() {
	  if (type().isUnknown()) {
		  for (FExp exp : childFExps())
			  if (exp.type().isUnknown())
				  return;
		  typeError();
	  }
  }
  
  protected static boolean FExp.isUnknownFExp(ASTNode n) {
	  return n instanceof FExp && ((FExp) n).type().isUnknown();
  }
  
  // TODO: Add specialized typeError() methods that gived better error message
  
  public void FExp.typeError() {
	  error("Type error in expression");	  
  }

  
  public void FIdUseExp.typeCheck() {
	  if (!getFIdUse().isUnknown() && type().isUnknown())
		  typeError();
  }
  public void FInstAccessExp.typeCheck() {
	  if (!getInstAccess().isUnknown() && type().isUnknown())
		  typeError();
  }

  /**
   * \brief Check if the FExp of this FIterExp must be scalar.
   */
  inh boolean FIterExp.iterExpMustBeScalar();
  eq FExp.getChild().iterExpMustBeScalar()       = false;
  eq Root.getChild().iterExpMustBeScalar()       = false;
  eq InstNode.getChild().iterExpMustBeScalar()   = false;
  eq FMinMaxExp.getChild().iterExpMustBeScalar() = true;
  // TODO: Add product() when it is implemented
  
  public void FIterExp.typeCheck() {
	  super.typeCheck();
	  if (iterExpMustBeScalar() && !getFExp().type().isUnknown() && getFExp().ndims() != 0)
		  error("The expression of a reduction-expression must be scalar, except for sum(): " +
				  getFExp() + " has " + getFExp().ndims() + " dimension(s)");
  }
  
  public void InstForIndex.typeCheck() {
	  if (hasFExp() && !getFExp().type().isUnknown() && getFExp().ndims() != 1)
		  error("The expression of for index " + name() + " must be a vector expression: " + 
				  getFExp() + " has " + getFExp().ndims() + " dimension(s)");
  }
  
  public void FExpSubscript.typeCheck() {
	  if (ndims() > 1) { 
		  error("Array index must be scalar or vector expression: " + getFExp());
	  } else if (!type().isInteger()) { // TODO: Expand to support Boolean and enums
		  error("Array index must be Integer expression: " + getFExp());
	  } else if (!inFunction()) { 
		  if (!getFExp().variability().lessOrEqual(fParameter())) {
			  error("Array index in equation must be constant, parameter or loop index: " + getFExp());
		  } else { // TODO: Perform bounds check in functions if index has parameter variability or lower?
			  int max = mySize().get(0);
			  for (FExp e : getExpanded().iterable()) {
				  int i = e.ceval().intValue();
				  if (i < 1 || i > max) {
					  error("Array index out of bounds: " + i + ", index expression: "+ getFExp());
					  return;
				  }
			  }
		  }
	  }
  }
  
  
  public void InstComponentAccess.typeCheck() {
	//  log.debug("InstComponentAccess.typeCheck: " + printSlice());
  }
  
  
  public void InstAssignStmt.typeCheck() {
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (getLeft().isForIndex())
			  error("Can not assign a value to a for loop index");
		  else if (!getLeft().type().typeCompatible(getRight().type(), true)) 
			  error("Types of right and left side of assignment are not compatible");		  
	  }
  }
  
  public void FWhileStmt.typeCheck() {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of while statement is not Boolean");
  }
  
  public void FIfClause.typeCheck() {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if statement is not Boolean");
  }
  
  public void FWhenClause.typeCheck() {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when statement isn't Boolean scalar or vector expression");
		  // TODO: This will cause NullPointerException until FInstAccessExp.variability() is defined
//		  if (!getTest().variability().lessOrEqual(fDiscrete()))
//			  error("Test expression of when statement isn't discrete-time");
	  }
  }
  
  
  public void FInfArgsFunctionCall.typeCheck() {
      super.typeCheck();
      if (getNumOriginalArg() < minNumArgs()) 
    	  error("Too few arguments to " + builtInName() + "(), must have at least " + minNumArgs());
      else 
    	  typeCheckFExps();
  }
  
  public void FInfArgsFunctionCall.typeCheckFExps() {
      for (FExp exp : getFExps()) {
          if (!exp.type().isUnknown() && !typeOfArgIsOK(exp)) {
              exp.error("Argument of " + builtInName() + "() is not " + 
            		  getOKArgTypeString() + ": " + exp);
          } else if (!variabilityOfArgIsOK(exp)) {
        	  exp.error("Argument of " + builtInName() + "() does not have " + 
        			  getOKArgVariabilityString() + " variability: " + exp);
          }
      }
  }
  
  public void FCatExp.typeCheckFExps() {
	  if (!getDim().type().isUnknown() && !fIntegerScalarType().typeCompatible(getDim().type()))
		  error("Dimension argument of cat() is not compatible with Integer: " + getDim());
	  else if (!getDim().type().isUnknown() && !getDim().variability().lessOrEqual(fParameter()))
		  error("Dimension argument of cat() does not have constant or parameter variability: " + getDim());
  }
  
  public void FAbstractCat.typeCheckFExps() {}
  
  public void FAbstractCat.typeError() {
	  error("Types do not match in array concatenation");	  
  }
  
  syn int FInfArgsFunctionCall.minNumArgs() = 1;
  eq FFillExp.minNumArgs()     = 2;
  eq FCatExp.minNumArgs()      = 2;
  eq FAbstractCat.minNumArgs() = 0;
  
  syn boolean FInfArgsFunctionCall.typeOfArgIsOK(FExp exp)        = fIntegerScalarType().typeCompatible(exp.type());
  syn boolean FInfArgsFunctionCall.variabilityOfArgIsOK(FExp exp) = exp.variability().lessOrEqual(fParameter());
  syn String FInfArgsFunctionCall.getOKArgTypeString()            = "compatible with Integer";
  syn String FInfArgsFunctionCall.getOKArgVariabilityString()     = "constant or parameter";
   
  public void FBuiltInFunctionCall.typeCheck() {
	  if (checkTypeAsExpression())
		  super.typeCheck();
	  if (myLefts().size() > 1)
		  error("Too many components assigned from function call: " + builtInName() + 
				  "() has 1 output(s)");
  }
  
  syn boolean FBuiltInFunctionCall.checkTypeAsExpression() = false;
  eq FSizeExp.checkTypeAsExpression()     = true;
  eq FMinMaxExp.checkTypeAsExpression()   = true;
  eq FIdentity.checkTypeAsExpression()    = true;
  eq FLinspace.checkTypeAsExpression()    = true;
  eq FAbstractCat.checkTypeAsExpression() = dimensionIsOk();
  
  syn boolean FAbstractCat.dimensionIsOk(); 
  eq FCatExp.dimensionIsOk()    = getDim().variability().lessOrEqual(fParameter()) && 
  								  getDim().type().isInteger() && getDim().type().isScalar();
  eq FMatrix.dimensionIsOk()    = true;
  eq FMatrixRow.dimensionIsOk() = true;
 
  public void InstFunctionCall.typeCheck() {
	  if (!isFunctionCallClause() && !getName().myInstClassDecl().isRecord() && !hasOutputs())
		  error("Function " + getName().name() + " has no outputs, but is used in expression");
	  else if (!isFunctionCallClause() && size().isUnknown())
		  error("Could not evaluate array size of output " + expOutput().name());
	  if (myOutputs().size() < myLefts().size())
		  error("Too many components assigned from function call: " + getName().name() + 
				  "() has " + myOutputs().size() + " output(s)");
  }
  
  public void FFunctionCallLeft.typeCheck() {
	  if (hasFExp() && !myOutput().isUnknown() && !type().isUnknown()) { // Avoid duplicate error
		  if (getFExp() instanceof FIdUseExp) {  // Should never be false - add check? 
			  FIdUse use = ((FIdUseExp) getFExp()).getFIdUse();
			  if (use.isForIndex())
				  error("Can not assign a value to a for loop index");
			  else if (size().isUnknown())
				  error(functionCallDecription() + ":could not evaluate array size of output " + 
						  myOutput().name());
			  else if (!use.type().typeCompatible(type())) 
				  error(functionCallDecription() + ": types of component " + use.name() + 
						  " and output " + myOutput().name() + " are not compatible");
		  }
	  }
  }
  
  inh String InstFunctionArgument.functionCallDecription();
  inh String FFunctionCallLeft.functionCallDecription();
  eq FAbstractFunctionCall.getChild().functionCallDecription() = functionCallDecription();
  eq FFunctionCallEquation.getChild().functionCallDecription() = getCall().functionCallDecription();
  eq FFunctionCallStmt.getChild().functionCallDecription()     = getCall().functionCallDecription();
  
  public void InstFunctionArgument.typeCheck() {
	  if (!getFExp().type().isUnknown() && (getBoundInput() == null || !getBoundInput().type().isUnknown())) {
		  boolean typeOk;
		  if (argumentDefinedTypeValid()) 
			  typeOk = getBoundInput().type().typeCompatible(getFExp().type(), true);
		  else
			  typeOk = argumentTypeValid(getFExp().type());
		  if (!typeOk) {
			  error(functionCallDecription() + ": types of " + argumentDesc() + 
					  " and input " + getBoundInput().name() + " are not compatible");
		  }
	  }
  }
  
  public void InstMissingArgument.typeCheck() {
	  error(functionCallDecription() + ": missing argument for required input " + getBoundInput().name());
  }
  
  public void InstMultipleBoundArgument.typeCheck() {
	  error(functionCallDecription() + ": multiple arguments matches input " + getBoundInput().name());
  }
  
  public void InstDefaultArgument.typeCheck() {}
  
  protected String InstFunctionArgument.argumentDesc() { return null; }
  
  protected String InstPositionalArgument.argumentDesc() {
	  return "positional argument " + (getPos() + 1);
  }
  
  protected String InstNamedArgument.argumentDesc() {
	  return "named argument " + getName().prettyPrint("");
  }
  
  public void InstAccess.typeCheck() {
	  if (getTopInstAccess() == this && !type().isUnknown()) {
		  // TODO: if this is a slice, check that all branches are of equal size
	  }
  }
  
  /**
   * \brief Check if the type defined for this argument in the built-in function list 
   *        is valid.
   */
  inh boolean InstFunctionArgument.argumentDefinedTypeValid();
  eq FAbstractFunctionCall.getChild().argumentDefinedTypeValid() = true;
  eq FTranspose.getChild().argumentDefinedTypeValid()            = false;
  eq FMinMaxExp.getChild().argumentDefinedTypeValid()            = false;
  eq FSumExp.getChild().argumentDefinedTypeValid()               = false;
  eq FNdimsExp.getOriginalArg(int i).argumentDefinedTypeValid()  = false;
  eq FSizeExp.getOriginalArg(int i).argumentDefinedTypeValid()   = i != 0;
  eq FInfArgsFunctionCall.getChild().argumentDefinedTypeValid()  = false;

  /**
   * \brief Check if the type supplied is valid for this argument.
   * 
   * Only used if argumentDefinedTypeValid() returns <code>false</code>.
   */
  inh boolean InstFunctionArgument.argumentTypeValid(FType type);
  eq FAbstractFunctionCall.getChild().argumentTypeValid(FType type) = type.isPrimitive();
  eq FTranspose.getChild().argumentTypeValid(FType type)            = type.ndims() >= 2 && type.isPrimitive();
  eq FSumExp.getChild().argumentTypeValid(FType type)               = type.ndims() > 0 && type.hasAdd();
  eq FMinMaxExp.getOriginalArg(int i).argumentTypeValid(FType type) = 
	  hasY() != getOriginalArg(i).getFExp().isArray() && type.isPrimitive();
  
}