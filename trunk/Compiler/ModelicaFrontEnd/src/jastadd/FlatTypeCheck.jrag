/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect FlatTypeCheck {
	
  public void ASTNode.typeCheck() {
	  
  }
 
 
    public void InstPrimitive.typeCheck() {
    	FExp bexp = myBindingInstExp();
    	if (bexp != null && !bexp.type().isUnknown()) {
    		boolean badType = false;
    		String badSizeName = null;
    		if (myBindingExpHasEach()) {
    			if (!type().scalarType().typeCompatible(bexp.type().scalarType())) {
    				badType = true;
    			} else if (ndims() == 0) {
    				error("The 'each' keyword cannot be applied to scalar members of non-array components");
    			} else if (bexp.ndims() >= ndims()) {
					error("Array size mismatch in declaration: each " + name() +
						  ", declaration has " + ndims() + " dimension(s) and binding expression has " +
						  bexp.ndims() + ", expression must have fewer than declaration");
    			} else if (!type().dimensionCompatibleFromRight(bexp.type())) {
    				badSizeName = "each " + name();
    			}
    		} else {
    			if (!type().typeCompatible(bexp.type())) {
    				if (!type().dimensionCompatible(bexp.type())) {
        				badSizeName = name();
    				} else {
    					badType = true;
    				}
    			}
    		}
    		
		    if (badType) {
			    error("The binding expression of the variable " + name() +
			    	  " does not match the declared type of the variable");
		    } else if (badSizeName != null) {
				error("Array size mismatch in declaration: " + badSizeName +
					  ", size of declaration is " + Arrays.toString(size()) + 
					  " and size of binding expression is " + 
					  Arrays.toString(bexp.size()));
		    }
	    }
	  
    	// TODO: Can't this be moved to InstComponentModification.typeCheck()?
	    // Check the type correctness of attributes
	    for (InstModification im : totalMergedEnvironment()) {
		    // Only check attributes, value modifications are checked above
		    if (im instanceof InstComponentModification) {
			    InstComponentModification icm = (InstComponentModification) im;
				if (icm.getInstModification().hasInstValueMod()) {
					FExp val_mod = icm.getInstModification().instValueMod();
					if (!icm.getName().myInstComponentDecl().isUnknown() && !val_mod.type().isUnknown()) {
						if (!icm.type().typeCompatible(val_mod.type().scalarType())) {
							icm.error("The type of the binding expression of the attribute " + icm.name() +
							  " does not match the declared type of the variable");							
						} else if (!icm.getEach() && val_mod.ndims()!=0 && !type().dimensionCompatible(val_mod.type())) { 
							icm.error("Array size mismatch for attribute: " + icm.name() +
									", size of declaration is " + Arrays.toString(size()) + 
									" and size of " + icm.name() + " expression is " + 
									Arrays.toString(val_mod.size()));
						} else if (icm.getEach()) { 
							if (ndims() == 0) {
								icm.error("The 'each' keyword cannot be applied to attributes of scalar components");
							} else if (val_mod.ndims() >= ndims()) {
								icm.error("Array size mismatch for attribute: each " + icm.name() +
										  ", declaration has " + ndims() + " dimension(s) and expression has " +
										  val_mod.ndims() + ", expression must have fewer than declaration");
							} else if (!type().dimensionCompatibleFromRight(val_mod.type())) {
								icm.error("Array size mismatch for attribute: each " + icm.name() +
										", size of declaration is " + Arrays.toString(size()) + 
										" and size of " + icm.name() + " expression is " + 
										Arrays.toString(val_mod.size()));
							}
						}
					}
				}
			}
		}
    }
    
  public void FEquation.typeCheck() {
	  //System.out.println("FEquation.typeCheck(): " + getLeft().type() + " " + getRight().type());
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (!getLeft().type().equivalentTo(getRight().type())) {
			  error("The right and left expression types of equation are" +
		  			" not compatible");		  
		  }
	  }
  }
  
  public void FArtmBinExp.typeCheck() {
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (type().isUnknown()) {
			  error("Type error in expression");	  
		  }
	  }
  }

  
  public void InstComponentAccess.typeCheck() {
	//  System.out.println("InstComponentAccess.typeCheck: " + printSlice());
  }
  
  
  public void InstAssignStmt.typeCheck() {
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (getLeft().isForIndex())
			  error("Can not assign a value to a for loop index");
		  else if (!getLeft().type().typeCompatible(getRight().type())) 
			  error("Types of right and left side of assignment are not compatible");		  
	  }
  }
  
  public void FWhileStmt.typeCheck() {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of while statement is not Boolean");
  }
  
  public void FIfClause.typeCheck() {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if statement is not Boolean");
  }
  
  public void FWhenClause.typeCheck() {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when statement isn't Boolean scalar or vector expression");
		  // TODO: This will cause NullPointerException until FInstAccessExp.variability() is defined
//		  if (!getTest().variability().lessOrEqual(fDiscrete()))
//			  error("Test expression of when statement isn't discrete-time");
	  }
  }
  
  
  public void FInfArgsFunctionCall.typeCheck() {
      super.typeCheck();
      for (InstFunctionArgument arg : originalArgs) {
    	  FExp exp = arg.getFExp();
          if (!exp.type().isUnknown() && !typeOfArgIsOK(exp)) {
              exp.error("Argument of " + getBuiltInName() + "() is not " + getOKArgTypeString());
          }
      }
  }
  
  syn boolean FInfArgsFunctionCall.typeOfArgIsOK(FExp exp) = fIntegerScalarType().typeCompatible(exp.type());
  syn String FInfArgsFunctionCall.getOKArgTypeString() = "compatible with Integer";
  
  public void FBuiltInFunctionCall.typeCheck() {
	  if (myLefts().size() > 1)
		  error("Too many components assigned from function call: " + getBuiltInName() + 
				  "() has 1 output(s)");
  }
  
  public void InstFunctionCall.typeCheck() {
	  if (myOutputs().size() < myLefts().size())
		  error("Too many components assigned from function call: " + getName().name() + 
				  "() has " + myOutputs().size() + " output(s)");
  }
  
  public void FFunctionCallLeft.typeCheck() {
	  if (hasFIdUse() && !type().isUnknown() && !myOutput().isUnknown()) { // Avoid duplicate error
		  if (getFIdUse().isForIndex())
			  error("Can not assign a value to a for loop index");
		  else if (!type().typeCompatible(myOutput().type())) 
			  error("Types of component " + getFIdUse().name() + " and output " + 
					  myOutput().name() + " are not compatible");
	  }
  }
  
  public void InstFunctionArgument.typeCheck() {
	  if (!getFExp().type().isUnknown() && !getBoundInput().type().isUnknown()) {
		  if (!getBoundInput().type().typeCompatible(getFExp().type())) {
			  error("Types of " + argumentDesc() + " and input " + getBoundInput().name() + 
					  " are not compatible");
		  }
	  }
  }
  
  public void InstMissingArgument.typeCheck() {
	  error("Missing argument for required input " + getBoundInput().name());
  }
  
  public void InstMultipleBoundArgument.typeCheck() {
	  error("Multiple arguments matches input " + getBoundInput().name());
  }
  
  public void InstDefaultArgument.typeCheck() {}
  
  protected String InstFunctionArgument.argumentDesc() { return null; }
  
  protected String InstPositionalArgument.argumentDesc() {
	  return "positional argument " + (getPos() + 1);
  }
  
  protected String InstNamedArgument.argumentDesc() {
	  return "named argument " + getName().prettyPrint("");
  }
  
}