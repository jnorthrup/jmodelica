/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect FlatTypeCheck {
	
  public void ASTNode.typeCheck() {
	  
  }
 
 
  public void InstPrimitive.typeCheck() {
	  if (myBindingInstExp() != null) {
		  // Check type compatibility
		  /*
		  System.out.println("Type check " + name() + " type: " + 
				  type().toString() + " (" + type().toString() + ") "+ " binding exp type: " + 
				  myBindingInstExp().type().toString() + "( "+ myBindingInstExp().type().toString() + ") " + " binding exp:");
		  */
		  
/*		  if (myBindingInstExp().type().isUnknown()) {
			  error("The binding expression of the variable " + name() + " has unknown type.");
		  }
	*/	  
		  if (!myBindingInstExp().type().isUnknown() && // Avoid duplicate error messages
				  !type().typeCompatible(myBindingInstExp().type())) {
			  if (!type().dimensionCompatible(myBindingInstExp().type())) {
				  error("Type array size mismatch in declaration " + name() +
							": size of declaration is " + Indices.printIndices(size()) + 
							" and size of binding expression is " + Indices.printIndices(myBindingInstExp().size()));
/*				  
				  error("Type dimension mismatch in declaration " + name() +
						  ": dimension of declaration is " + ndims() + 
						  ", dimension of binding expression is "+ myBindingInstExp().ndims());
*/
			  } else {
			  
/*
			  System.out.println("Error in " + name() + " type: " + 
					  type().toString() + " (" + type().toString() + ") "+ " binding exp type: " + 
					  myBindingInstExp().type().toString() + "( "+ myBindingInstExp().type().toString() + ") " + " binding exp:");
			  myBindingInstExp().dumpTree("");
			  */
			  error("The binding expression of the variable " + name() +
					  " does not match the declared type of the variable");
			  }
		  }
		  
	  }
	  
	// Check the type correctness of attributes
	  for (InstModification im : totalMergedEnvironment()) {
		  // Only check attributes, value modifications are checked above
		  if (im instanceof InstComponentModification) {
			  InstComponentModification icm = (InstComponentModification)im;
				if (icm.getInstModification().hasInstValueMod()) {
					FExp val_mod = icm.getInstModification().instValueMod();
					if (!icm.getName().myInstComponentDecl().isUnknown() && !val_mod.type().isUnknown()) {
						if (!icm.type().typeCompatible(val_mod.type().scalarType())) {
							icm.error("The type of the binding expression of the attribute " + icm.name() +
							  " does not match the declared type of the variable");							
						} else if (!icm.getEach() && val_mod.ndims()!=0 && !type().dimensionCompatible(val_mod.type())) { 
							icm.error("Array size mismatch for attribute " + icm.name() +
									": size of declaration is " + Indices.printIndices(size()) + 
									" and size of " + icm.name() + " expression is " + Indices.printIndices(val_mod.size()));
						} else if (icm.getEach()){ // If the each keyword is specified, then the dimension should be 0.
							if (val_mod.ndims()>0) {
								icm.error("The 'each' keyword is specified for the attribute " + icm.name() + 
								        " but the expression provided is not scalar.");
							}
						}
					}
				}
			}
		}
	  
	  
  }
 
  public void FEquation.typeCheck() {
	  //System.out.println("FEquation.typeCheck(): " + getLeft().type() + " " + getRight().type());
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (!getLeft().type().equivalentTo(getRight().type())) {
			  error("The right and left expression types of equation are" +
		  			" not compatible");		  
		  }
	  }
  }
  
  public void FArtmBinExp.typeCheck() {
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (type().isUnknown()) {
			  error("Type error in expression");	  
		  }
	  }
  }

  
  public void InstComponentAccess.typeCheck() {
	//  System.out.println("InstComponentAccess.typeCheck: " + printSlice());
  }
  
  public void FInfArgsFunctionCall.typeCheck() {
		for (InstFunctionArgument arg : originalArgs) {
			FExp exp = arg.getFExp();
			if (!exp.type().isUnknown() && !typeOfArgIsOK(exp)) {
				exp.error("Argument of " + getBuiltInName() + "() is not " + getOKArgTypeString());
			}
		}
  }
  
  syn boolean FInfArgsFunctionCall.typeOfArgIsOK(FExp exp) = fIntegerScalarType().typeCompatible(exp.type());
  syn String FInfArgsFunctionCall.getOKArgTypeString() = "compatible with Integer";
  
  public void InstFunctionArgument.typeCheck() {
	  if (!getFExp().type().isUnknown() && !getBoundInput().type().isUnknown()) {
		  if (!getBoundInput().type().typeCompatible(getFExp().type())) {
			  error("Types of " + argumentDesc() + " and input " + getBoundInput().name() + 
					  " are not compatible");
		  }
	  }
  }
  
  public void InstMissingArgument.typeCheck() {
	  error("Missing argument for required input " + getBoundInput().name());
  }
  
  public void InstMultipleBoundArgument.typeCheck() {
	  error("Multiple arguments matches input " + getBoundInput().name());
  }
  
  public void InstDefaultArgument.typeCheck() {}
  
  protected String InstFunctionArgument.argumentDesc() { return null; }
  
  protected String InstPositionalArgument.argumentDesc() {
	  return "positional argument " + (getPos() + 1);
  }
  
  protected String InstNamedArgument.argumentDesc() {
	  return "named argument " + getName().prettyPrint("");
  }
  
}