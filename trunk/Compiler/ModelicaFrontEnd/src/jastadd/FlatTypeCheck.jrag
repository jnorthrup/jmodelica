/*
    Copyright (C) 2009-2013 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Arrays;
import java.util.Collections;
import org.jmodelica.util.Criteria;
import org.jmodelica.util.ErrorCheckType;

aspect FlatTypeCheck {

    public void ASTNode.typeCheck(ErrorCheckType checkType) {}

    public abstract class ErrorChecker {
        public static class TypeChecker extends ErrorChecker {
            public TypeChecker() {
                super("TypeCheck");
            }

            @Override
            public void check(ASTNode node, ErrorCheckType checkType) {
                node.typeCheck(checkType);
            }
        }
    }

    private static ErrorChecker ASTNode.TYPE_CHECKER = addErrorChecker(new ErrorChecker.TypeChecker());

    public void InstNode.typeCheck(ErrorCheckType checkType) {
        typeCheckSystemResiduals(checkType);
    }
    
    public void InstComposite.typeCheck(ErrorCheckType checkType) {
        super.typeCheck(checkType);
        // Note that modifiers (including redeclarations) in a constraining clause
        // are applied to the declaration itself and is therefore also type checked.
        if (hasInstConstraining()) {
              InstNode superType = getInstConstraining().getInstNode();
              InstComponentDecl declaredType = this; 
              if (!declaredType.subType(superType))
                   declaredType.getComponentDecl().error("In the declaration '" + declaredType.getComponentDecl() + 
                           "', the declared class is not a subtype of the constraining class");
        }
    }

    public void InstReplacingRecord.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingComposite.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingPrimitive.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingExpandableConnectorDecl.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstComponentDecl.typeCheckReplacingComponent(InstComponentDecl declaredType, ErrorCheckType checkType) {
        super.typeCheck(checkType);
        
        // Type check the original component
        InstComponentDecl superType = declaredType.constrainingInstComponentDecl();
        if (declaredType.hasInstConstraining() && !declaredType.subType(superType))
            superType.getComponentDecl().error("In the declaration '%s', the declared class is not a subtype of the constraining class", 
                    declaredType.getComponentDecl());

        // The environment should be traversed backwards in order to perform correct
        // subtype tests in redeclaration chains.       
        for (int i = myEnvironment().size() - 1; i >= 0; i--) {
            InstModification im = myEnvironment().get(i);
            InstComponentRedeclare redeclare = im.matchInstComponentRedeclare(name());
            if (redeclare != null) { 
                InstComponentDecl declaredSubType = redeclare.getInstComponentDecl();
                InstComponentDecl constrainingSubType = declaredSubType.constrainingInstComponentDecl();
                    
                // Check consistency of the redeclaring component
                if (declaredSubType.hasInstConstraining() && !declaredSubType.subType(constrainingSubType))
                    declaredSubType.getComponentDecl().error("In the declaration '%s', the declared class is not a subtype of the constraining class", 
                            declaredSubType.getComponentDecl());

                // It is ok to check against the constrainingSubType, since the declaredSubType is a subtype
                // of the constrainingSubType. Then if constrainingSubType is a subtype of superType, then it
                // follows that declaredSubType is a subtype of superType by transitivity.
                if (!constrainingSubType.subType(superType))
                    constrainingSubType.getComponentDecl().error("In the declaration '%s', the replacing class is not a subtype of the constraining class from the declaration '%s'", 
                            constrainingSubType.getComponentDecl(), superType.getComponentDecl());
            
                // If the redeclaring declaration has a constraining clause, the constraining
                // type of the redeclaring declaration of should be used in following subtype-test 
                // instead of the constraining type of the orignal declaration.
                if (declaredSubType.hasInstConstraining()) 
                    superType = constrainingSubType;
            }
            typeCheckSystemResiduals(checkType);
        }
    }

    public void InstAssignable.typeCheck(ErrorCheckType checkType) {
        FExp bexp = myBindingInstExp();
        boolean func = inFunction();
        Size componentSize = size();
        if (!componentSize.isComplete() && !func && !inRecordDecl() && !checkType.allowIncompleteSizes()) 
            error("Can not infer array size of the variable " + name());
        if (bexp != null && !inRecordWithBindingExp() && !bexp.type().isUnknown() && !isInRedeclareMod()) {
            if (myBindingExpHasEach() && !inArrayComponent()) {
                bexp.error("The 'each' keyword cannot be applied to members of non-array components");
            } else {
                FType expectedBT = bindingType();
                FType actualBT = bexp.type();
                if (!expectedBT.typeCompatible(actualBT, func) && !expectedBT.isUnknown()) {
                    if (!myBindingExpHasEach() && type().typeCompatible(actualBT, func)) {
                        bexp.warning("Assuming 'each' for the binding expression to the variable " + name());
                    } else if (!expectedBT.scalarType().typeCompatible(actualBT.scalarType())) {
                        bexp.error("The binding expression of the variable " + name() +
                                " does not match the declared type of the variable");
                    } else {
                        bexp.error("Array size mismatch in declaration of " + 
                                (myBindingExpHasEach() ? "each " : "") + name() +
                                ", size of declaration is " + expectedBT.size() + 
                                " and size of binding expression is " + actualBT.size());
                    }
                }
            }
        }
        
        if (hasConditionalAttribute()) {
            FExp cond = getConditionalAttribute();
            if (!cond.type().isUnknown()) {
                if (!cond.type().isScalar()) 
                    error("The guard expression of a conditional component should be a scalar expression");
                if (!cond.type().isBoolean()) 
                    error("The guard expression of a conditional component should be a boolean expression");
                if (!cond.variability().lessOrEqual(fParameter())) 
                    error("The guard expression of a conditional component should have parameter or constant variability");
            }
        }
        
        if (root().options.getBooleanOption("hand_guided_tearing")) {
            AnnotationNode iterationNode = annotation().vendorNode().forPath("IterationVariable");
            AnnotationNode enabledNode = iterationNode.forPath("enabled");
            if (enabledNode.exists()) {
                FExp enabledExp = containingInstNode().dynamicFExp(enabledNode.exp().instantiate());
                typeCheckHGTEnabled(checkType, enabledExp, type(), enabledNode.isEachSet());
            }
        }
        
        typeCheckAttributes();
        super.typeCheck(checkType);
    }

    inh boolean InstComponentDecl.inRecordWithBindingExp();
    eq InstRecord.getChild().inRecordWithBindingExp()             = myBindingInstExp() != null;
    eq InstArrayComponentDecl.getChild().inRecordWithBindingExp() = inRecordWithBindingExp();
    eq InstNode.getChild().inRecordWithBindingExp()               = false;
    eq Root.getChild().inRecordWithBindingExp()                   = false;
    
    public void InstAssignable.typeCheckAttributes() {}
    
    public void InstPrimitive.typeCheckAttributes() {
	    for (InstModification im : totalMergedEnvironment()) 
	    	im.typeCheckAttribute(this);
     }
   
    public void InstModification.typeCheckAttribute(InstNode owner) {}

    public void InstComponentModification.typeCheckAttribute(InstNode owner) {
        if (hasInstModification() && getInstModification().hasInstValueMod()) {
            FExp valMod = getInstModification().instValueMod();
            if (!type().isUnknown() && !valMod.type().isUnknown()) {
                Size attrSize = owner.attributeSize(this);
                boolean checkSize = !owner.isInRedeclareMod();
                if (!type().typeCompatible(valMod.type().scalarType())) {
                    error("The type of the binding expression of the attribute " + name() +
                            " does not match the declared type of the variable");
                } else if (checkSize) {
                    if (!hasEach() && !attrSize.equivalent(valMod.size(), false)) { 
                        if (valMod.ndims() == 0) {
                            warning("Assuming 'each' for the attribute " + name());
                        } else {
                            error("Array size mismatch for the attribute " + name() +
                                    ", size of declaration is " + attrSize + 
                                    " and size of " + name() + " expression is " + valMod.size());
                        }
                    } else if (hasEach()) { 
                        if (owner.ndims() == 0 && !owner.inArrayComponent()) {
                            error("The 'each' keyword cannot be applied to attributes of scalar components");
                        } else if (valMod.ndims() > 0) {
                            error("The attribute " + name() + 
                                    " is declared 'each' and the binding expression is not scalar");
                        }
                    }
                }
            }
        }
    }

    inh boolean InstNode.isInRedeclareMod();
    eq InstElementRedeclare.getChild().isInRedeclareMod() = true;
    eq InstClassDecl.getChild().isInRedeclareMod()        = false;
    eq InstRoot.getChild().isInRedeclareMod()             = false;
    eq Root.getChild().isInRedeclareMod()                 = false;


  public void FEquation.typeCheck(ErrorCheckType checkType) {
      typeCheckHGTResidual(checkType);
      typeCheckNominal(checkType);
      typeCheckLocalIteration(checkType);
      FType left = getLeft().type();
      FType right = getRight().type();
      if (!left.isUnknown() && !right.isUnknown()) {
          if (!left.equivalentTo(right)) {
              if (left.scalarType().equivalentTo(right.scalarType())) {
                  if (!lockBranch(checkType))
                      error("The array sizes of right and left hand side of equation are not compatible");
              } else {
                  error("The right and left expression types of equation are not compatible");
              }
          }
      }
  }
  
  public void FConnectClause.typeCheck(ErrorCheckType checkType) {
      InstAccess left  = getConnector1().getInstAccess();
      InstAccess right = getConnector2().getInstAccess();
      boolean check = true;
      boolean expandableSame = true;
      for (InstAccess access = left; access != null; access = (access == left) ? right : null) {
          if (!access.isExpandableConnectorPart() && !access.isUnknown() && !access.myInstComponentDecl().myInstClass().isUnknown()) {
              if (!access.myInstComponentDecl().isConnector())
                  access.error("Connecting to an instance of a non-connector type is not allowed");
          } else {
              check = false;
          }
          if (access.myInstComponentDecl().isExpandableConnector())
              expandableSame = !expandableSame;
      }
      if (!expandableSame && !left.isUnknown() && !right.isUnknown())
          error("Connecting an expandable connector to a non-expandable connector is not allowed");
      if (check) { 
          InstComponentDecl leftComp  = left.lookupEvaluatingIndices();
          InstComponentDecl rightComp = right.lookupEvaluatingIndices();
          if (!leftComp.connectableTo(rightComp))
              error("Types of connected components do not match");
          else if (!left.size().equivalent(right.size(), false))
              error("Sizes do not match in connection");
      }
  }
  
  // Generic typeCheck(checkType) that calls typeError() if type is unknown and no FExp child has unknown type
  public void FExp.typeCheck(ErrorCheckType checkType) {
	  if (type().isUnknown()) {
		  for (FExp exp : childFExps())
			  if (exp.type().isUnknown())
				  return;
		  typeError();
	  }
  }
  
  protected static boolean FExp.isUnknownFExp(ASTNode n) {
	  return n instanceof FExp && ((FExp) n).type().isUnknown();
  }
  
  // TODO: Add specialized typeError() methods that gives better error messages
  
  public void FExp.typeError() {
	  error("Type error in expression: " + this);	  
  }

  public void FInstAccessExp.typeError() {
	  getInstAccess().typeError();
  }
  
  public void InstAccess.typeError() {
	  typeError(this);
  }
  
  protected void InstAccess.typeError(InstAccess top) {}
  
  protected void InstDot.typeError(InstAccess top) {
	  getLastInstAccess().typeError(top);
  }
  
  protected void InstGlobalAccess.typeError(InstAccess top) {
	  getInstAccess().typeError(top);
  }
  
  protected void InstComponentAccess.typeError(InstAccess top) {
	  InstComponentDecl icd = myInstComponentDecl();
	  if (!icd.isUnknown() && !icd.myInstClass().isUnknown() && !inCardinality()) {
		  if (icd.isOrExtendsPrimitive() || icd.isRecord())
			  top.error("Could not calculate type of " + top.name());
		  else
			  top.error("Accesses to composite components other than records are not allowed: " + top.name());
	  }
  }
  
  protected void InstComponentArrayAccess.typeError(InstAccess top) {
	  InstComponentDecl icd = myInstComponentDecl();
      if (!icd.isUnknown() && !icd.myInstClass().isUnknown() && !inCardinality()) {
          if (icd.isOrExtendsPrimitive() || icd.isRecord())
			  top.error("Could not calculate type of " + top.name());
		  else
			  top.error("Accesses to composite components other than records are not allowed: " + top.name());
	  }
  }
  
  inh boolean InstAccess.inCardinality();
  eq FCardinality.getChild().inCardinality() = true;
  eq InstNode.getChild().inCardinality()     = false;
  eq Root.getChild().inCardinality()         = false;
  
  protected void InstClassAccess.typeError(InstAccess top) {
	  if (!isComponentSizeClass() || !isInstComponentSize())
		  top.error("Illegal access to class in expression: " + top.name());
  }
  
  public void FIfExp.typeError() {
		FType thenType = getThenExp().type();
		FType elseType = getElseExp().type();
		FType scalar = thenType.scalarType();
		scalar = scalar.typePromotion(elseType.scalarType());
		
		if (!getIfExp().isOKTestExp() || thenType.ndims() != elseType.ndims()) {
			getIfExp().error("Test expression of if expression must be scalar boolean");
		} else if (scalar.isUnknown()) { 
			error("Branches of if expression has incompatible types");
		} else {
			if (isParameterIf())
				error("Failed to evaluate test expression in if expression with branches that have different array sizes");
			else
				error("If expression with branches that have different array sizes must have parameter test expression");
		}
  }
  
  public void FIdUseExp.typeCheck(ErrorCheckType checkType) {
	  if (!getFIdUse().isUnknown() && type().isUnknown() && !accessToModelOK())
		  typeError();
  }
  
	public void FIdUse.typeCheck(ErrorCheckType checkType) {
		if (inAlgorithm() && useIsAssignment() && variability().constantVariability()) {
			error("Assignments to constants is not allowed in algorithms");
		}
		if (inAlgorithm() && useIsAssignment() && !(myFAlgorithm().getType() instanceof FInitialEquation) && 
				variability().parameterVariability() && !isForIndex()) {
			error("Assignments to parameters in algorithms is only allowed in initial algorithms");
		}
	}
  
  public void FInstAccessExp.typeCheck(ErrorCheckType checkType) {
	  if (!getInstAccess().isUnknown() && type().isUnknown() && !accessToModelOK())
		  typeError();
  }

  inh boolean FIdUseExp.accessToModelOK();
  inh boolean FInstAccessExp.accessToModelOK();
  inh boolean InstFunctionArgument.accessToModelOK();
  eq BaseNode.getChild().accessToModelOK()             = false;
  eq InstFunctionArgument.getChild().accessToModelOK() = accessToModelOK();
  eq FSizeExp.getFExp().accessToModelOK()              = true;
  eq FSizeExp.getOriginalArg(int i).accessToModelOK()  = i == 0;
  
  
  /**
   * \brief Check if the FExp of this FIterExp must be scalar.
   */
  inh boolean FIterExp.iterExpMustBeScalar();
  eq FExp.getChild().iterExpMustBeScalar()       = false;
  eq Root.getChild().iterExpMustBeScalar()       = false;
  eq InstNode.getChild().iterExpMustBeScalar()   = false;
  eq FMinMaxExp.getChild().iterExpMustBeScalar() = true;
  // TODO: Add product() when it is implemented
  
  public void FIterExp.typeCheck(ErrorCheckType checkType) {
	  super.typeCheck(checkType);
	  if (iterExpMustBeScalar() && !getFExp().type().isUnknown() && getFExp().ndims() != 0)
		  error("The expression of a reduction-expression must be scalar, except for sum(): " +
				  getFExp() + " has " + getFExp().ndims() + " dimension(s)");
  }
  
  public void FStreamBuiltIn.typeCheck(ErrorCheckType checkType) {
	  if (!getFExp().isAccessToStream()) 
		  error("Argument of " + builtInName() + "() must be a stream variable");
  }
  
  syn boolean FExp.isAccess()  = false;
  eq FIdUseExp.isAccess()      = true;
  eq FInstAccessExp.isAccess() = true;
  syn FIdUse FExp.asFIdUse() {
	  throw new UnsupportedOperationException("asFIdUse() is not supported for class type " + getClass().getSimpleName());
  }
  eq FIdUseExp.asFIdUse() = getFIdUse();
  
  syn FIdUseExp FExp.asFIdUseExp() {
      throw new UnsupportedOperationException("asFIdUseExp() is not supported for class type " + getClass().getSimpleName());
  }
  eq FIdUseExp.asFIdUseExp() = this;
  
	syn boolean FExp.isInstAccess()  = false;
	eq FInstAccessExp.isInstAccess() = true;
	syn InstAccess FExp.asInstAccess() {
		throw new UnsupportedOperationException();
	}
	eq FInstAccessExp.asInstAccess() = getInstAccess();
	
  syn boolean FExp.isAccessToStream()  = false;
  eq FIdUseExp.isAccessToStream()      = getFIdUse().isAccessToStream();
  eq FInstAccessExp.isAccessToStream() = getInstAccess().isAccessToStream();
  
  syn boolean FIdUse.isAccessToStream()  = false;
  eq FIdUseInstAccess.isAccessToStream() = getInstAccess().isAccessToStream();
  
  syn boolean InstAccess.isAccessToStream() = myInstComponentDecl().getComponentDecl().isStream();
  
  
  
  public void InstForIndex.typeCheck(ErrorCheckType checkType) {
	  if (hasFExp() && !getFExp().type().isUnknown() && getFExp().ndims() != 1)
		  error("The expression of for index " + name() + " must be a vector expression: " + 
				  getFExp() + " has " + getFExp().ndims() + " dimension(s)");
  }
  
  public void FExpSubscript.typeCheckAsSize(ErrorCheckType checkType) {
	  if (ndims() > 0) { 
		  error("Array size must be scalar expression: " + getFExp());
      } else if (!type().isUnknown() && !getFExp().canBeComponentSize()) {
          error("Array size must be Integer expression, Boolean type or enumeration type: " + getFExp());
	  } else if (!inFunction()) { 
		  if (!getFExp().variability().lessOrEqual(fParameter())) {
			  error("Array size must be constant or parameter: " + getFExp());
		  } else if (!checkType.allowIncompleteSizes()) {
			  try {
				  getFExp().ceval().intValue();
			  } catch (ConstantEvaluationException e) {
				  error("Could not evaluate array size expression: " + getFExp());
			  }
		  }
	  }
  }
  
  public void FExpSubscript.typeCheckAsIndex(ErrorCheckType checkType) {
	  if (ndims() > 1) { 
		  error("Array index must be scalar or vector expression: " + getFExp());
      } else if (!type().isUnknown() && !type().canBeIndex()) {
          error("Array index must be Integer, Boolean, or enumeration expression: " + getFExp());
      } else if (!type().isUnknown() && !myIndexType().isUnknown() && !type().scalarType().typeCompatible(myIndexType())) {
          error("Expected array index of type '%s' found '%s'", myIndexType().name(), type().scalarType().name());
	  } else if (!inFunction()) { 
		  if (!getFExp().variability().parameterOrLess()) {
			  warning("Variable array index in equation can result in slow simulation time");
		  } else if (!reportedOutOfBound && !inUnknownAccess()) {
	          // Check array bounds
	          // TODO: Perform bounds check in functions if index has parameter variability or lower?
	          try {
	              int max = mySize().get(0);
	              for (FExp e : getFExp().getArray().iterable()) {
	                  int i = e.ceval().intValue();
	                  if (i < 1 || i > max) {
	                      if (!lockBranch(checkType))
	                          error("Array index out of bounds: " + i + ", index expression: " + getFExp());
	                      reportedOutOfBound = true;
	                      return;
	                  }
	              }
	          } catch (ConstantEvaluationException e) {
	          }
		  }
	  }
  }
  
  syn FType FExpSubscript.myIndexType() = myIndexType(myDim());
  inh FType FExpSubscript.myIndexType(int i);
  eq Root.getChild().myIndexType(int i)                                = fUnknownType();
  eq InstArrayAccess.getFArraySubscripts().myIndexType(int i)          = fUnknownType();
  eq InstComponentArrayAccess.getFArraySubscripts().myIndexType(int i) = myInstComponentDecl().myIndexType(i);
  
  syn FType InstComponentDecl.myIndexType(int dim) {
    FArraySubscripts fas = getFArraySubscripts();
    if (fas != null && fas.getNumFSubscript() > dim)
        return fas.getFSubscript(dim).type().scalarType();
    else
        return fUnknownType();
  }
  
  private boolean FExpSubscript.reportedOutOfBound = false;
  
  
  public void FExpSubscript.typeCheck(ErrorCheckType checkType) {
	  if (isInstComponentSize()) 
		  typeCheckAsSize(checkType);
	  else 
		  typeCheckAsIndex(checkType);
  }
  
  inh boolean FSubscript.inUnknownAccess();
  eq FIdUse.getChild().inUnknownAccess()                  = myFV().isUnknown();
  eq InstScalarAccess.getChild().inUnknownAccess()        = myInstComponentDecl().isUnknown();
  eq InstArrayAccess.getChild().inUnknownAccess()         = myInstComponentDecl().isUnknown();
  eq InstEquationAccess.getChild().inUnknownAccess()      = myEquation() == null;
  eq InstEquationArrayAccess.getChild().inUnknownAccess() = myEquation() == null;
  eq FlatRoot.getChild().inUnknownAccess()                = false;
  eq InstRoot.getChild().inUnknownAccess()                = false;
  
  syn boolean FExp.canBeComponentSize()  = type().isInteger();
  eq FInstAccessExp.canBeComponentSize() = type().isInteger() || getInstAccess().isComponentSizeClass();
  eq FIdUseExp.canBeComponentSize()      = type().isInteger() || getFIdUse().isComponentSizeClass();
  
  syn boolean InstAccess.isComponentSizeClass() = myInstClassDecl().isComponentSizeClass();
  syn boolean FIdUse.isComponentSizeClass()     = false;
  eq FIdUseInstAccess.isComponentSizeClass()    = getInstAccess().isComponentSizeClass();
  
  syn boolean InstClassDecl.isComponentSizeClass() = isBoolean();
  eq InstEnumClassDecl.isComponentSizeClass()      = true;
  
  inh boolean InstClassAccess.isInstComponentSize();
  inh boolean FInstAccessExp.isInstComponentSize();
  inh boolean FExpSubscript.isInstComponentSize();
  inh boolean FArraySubscripts.isInstComponentSize();
  eq InstComponentDecl.getLocalFArraySubscripts().isInstComponentSize() = true;
  eq InstComponentDecl.getFArraySubscripts().isInstComponentSize()      = true;
  eq InstShortClassDecl.getFArraySubscripts().isInstComponentSize()     = true;
  eq InstAccess.getChild().isInstComponentSize()                        = false;
  eq FQNamePart.getChild().isInstComponentSize()                        = false;
  eq FIdUse.getChild().isInstComponentSize()                            = false;
  eq FExp.getChild().isInstComponentSize()                              = false;
  eq FInstAccessExp.getChild().isInstComponentSize()                    = isInstComponentSize();
  eq FAbstractVariable.getChild().isInstComponentSize()                 = false;
  eq FAbstractEquation.getChild().isInstComponentSize()                 = false;
  eq InstNode.getChild().isInstComponentSize()                          = false;
  eq FlatRoot.getChild().isInstComponentSize()                          = false;
	
  syn boolean FArraySubscripts.isFullSize() {
      for (FSubscript fs : getFSubscripts())
          if (!fs.isColon())
              return false;
      return true;
  }
  
  
  public void InstComponentAccess.typeCheck(ErrorCheckType checkType) {
	//  log.debug("InstComponentAccess.typeCheck: " + printSlice());
  }
  
  
  public void InstAssignStmt.typeCheck(ErrorCheckType checkType) {
	  if (!getLeft().type().isUnknown() && !getRight().type().isUnknown()) {
		  if (getLeft().isForIndex())
			  error("Can not assign a value to a for loop index");
		  else if (!getLeft().type().typeCompatible(getRight().type(), true)) 
			  error("Types of right and left side of assignment are not compatible");		  
	  }
  }
  
  public void FWhileStmt.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of while statement is not Boolean");
  }
  
  public void FIfClause.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if statement is not Boolean");
  }
  
  public void FWhenClause.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when statement isn't Boolean scalar or vector expression");
	  }
  }
  
  public void FIfEquation.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if equation is not Boolean");
  }
  
  public void FWhenEquation.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when equation isn't Boolean scalar or vector expression");
	  }
  }
  
  
  public void FInfArgsFunctionCall.typeCheck(ErrorCheckType checkType) {
      super.typeCheck(checkType);
      if (getNumOriginalArg() < minNumArgs()) 
    	  error("Too few arguments to " + builtInName() + "(), must have at least " + minNumArgs());
      else 
    	  typeCheckFExps();
  }
  
  public void FInfArgsFunctionCall.typeCheckFExps() {
      for (FExp exp : getFExps()) {
          if (!exp.type().isUnknown() && !typeOfArgIsOK(exp)) {
              exp.error("Argument of " + builtInName() + "() is not " + 
            		  getOKArgTypeString() + ": " + exp);
          } else if (!variabilityOfArgIsOK(exp)) {
        	  exp.error("Argument of " + builtInName() + "() does not have " + 
        			  getOKArgVariabilityString() + " variability: " + exp);
          }
      }
  }
  
  public void FCatExp.typeCheckFExps() {
	  if (!getDim().type().isUnknown() && !fIntegerScalarType().typeCompatible(getDim().type()))
		  error("Dimension argument of cat() is not compatible with Integer: " + getDim());
	  else if (!getDim().type().isUnknown() && !getDim().variability().lessOrEqual(fParameter()))
		  error("Dimension argument of cat() does not have constant variability: " + getDim());
  }
  
  public void FAbstractCat.typeCheckFExps() {}
  
  public void FAbstractCat.typeError() {
	  error("Types do not match in array concatenation");	  
  }
  
  syn int FInfArgsFunctionCall.minNumArgs() = 1;
  eq FFillExp.minNumArgs()     = 2;
  eq FCatExp.minNumArgs()      = 2;
  eq FAbstractCat.minNumArgs() = 0;
  
  syn boolean FInfArgsFunctionCall.typeOfArgIsOK(FExp exp)        = 
		  fIntegerScalarType().typeCompatible(exp.type());
  syn boolean FInfArgsFunctionCall.variabilityOfArgIsOK(FExp exp) = 
		  exp.variability().lessOrEqual(fParameter()) || inFunction();
  syn String FInfArgsFunctionCall.getOKArgTypeString()            = 
		  "compatible with Integer";
  syn String FInfArgsFunctionCall.getOKArgVariabilityString()     = 
		  "constant or parameter";
   
  public void FBuiltInFunctionCall.typeCheck(ErrorCheckType checkType) {
	  if (checkTypeAsExpression())
		  super.typeCheck(checkType);
	  int n = builtInHasOutput() ? 1 : 0;
	  if (myLefts().size() > n)
		  error("Too many components assigned from function call: " + builtInName() + 
				  "() has " + n + " output(s)");
	  else if (!isFunctionCallClause() && n == 0)
		  error("Function " + builtInName() + "() has no outputs, but is used in expression");
  }
  
  public void FSemiLinearExp.typeCheck(ErrorCheckType checkType) {
      if (isArray()) {
          Size s = size();
          for (FExp arg : myArgs()) {
              if (!arg.type().isScalar() && !arg.size().equivalent(s, false)) {
                  error("Mismatching sizes in semiLinear. All non-scalar arguments need matching sizes");
                  break;
              }
          }
      }
      super.typeCheck(checkType);
  }
  
  public void FEnumIntegerExp.typeCheck(ErrorCheckType checkType) {
	  super.typeCheck(checkType);
	  // We can't define the function Integer in PredefinedTypes.jrag - conflict with the type Integer
	  int n = getNumOriginalArg();
	  if (n != 1)
		  error("Calling function Integer(): too " + (n > 1 ? "many" : "few") + " arguments");
  }
  
  public void InstPreExp.typeCheck(ErrorCheckType checkType) {
  	if (!getFExp().isAccess()) {
  		error("Calling function pre(): argument must be variable access");
  		return;
  	}
  }
 
  public void FAssert.typeCheck(ErrorCheckType checkType) {
	  if (hasLevel()) {
		  if (getLevel().isParameterExp())
			  getLevel().markAsStructuralParameter(checkType);
		  else if (!getLevel().isConstantExp())
			  error("Level of assert() must be constant or parameter");
	  }
  }
  
  public void FReinit.typeCheck(ErrorCheckType checkType) {
      if (!getVar().isAccess() || !getVar().type().isReal())
          error("First argument to reinit() must be an access to a Real variable");
      else if (!getVar().type().typeCompatible(getFExp().type()))
          error("Arguments to reinit() must be of compatible types");
  }
  
  public void FEdgeExp.typeCheck(ErrorCheckType checkType) {
    if (!getFExp().isAccess() || !getFExp().type().isBoolean()) {
      error("Calling function edge(): argument must be a boolean variable access");	
    }
  }
  
  public void FChangeExp.typeCheck(ErrorCheckType checkType) {
    if (!getFExp().isAccess()) {
      error("Calling function change(): argument must be a variable access");
      return;  		
    }
  }

	public void FStringExp.typeCheck(ErrorCheckType checkType) {
		FType valueType = getValue().type();
		if (hasSignificantDigits() && !valueType.isReal())
			error("Calling function String(): named argument significantDigits can only be used when first argument is real");
		if (hasFormat() && (hasMinimumLength() || hasLeftJustified() || hasSignificantDigits()))
			error("Calling function String(): named argument format can not be used together with minimumLength, leftJustified or significantDigits");
	}
  
  public void FHomotopyExp.typeCheck(ErrorCheckType checkType) {
    if (!getActual().type().equivalentTo(getSimplified().type())) {
      error("Calling function homotopy(): arguments must be same type");
    }
  }
  
  syn boolean FBuiltInFunctionCall.builtInHasOutput() = true;
  eq FIgnoredBuiltIn.builtInHasOutput() = false;
  eq FConnectionsOp.builtInHasOutput()  = false;
  eq FConnBoolOp.builtInHasOutput()     = true;
  
  syn boolean FBuiltInFunctionCall.checkTypeAsExpression() = false;
  eq FSizeExp.checkTypeAsExpression()     = true;
  eq FMinMaxExp.checkTypeAsExpression()   = true;
  eq FIdentity.checkTypeAsExpression()    = true;
  eq FLinspace.checkTypeAsExpression()    = true;
  eq FAbstractCat.checkTypeAsExpression() = dimensionIsOk();
  
  syn boolean FAbstractCat.dimensionIsOk(); 
  eq FCatExp.dimensionIsOk()    = getDim().isConstantExp() && 
  								  getDim().type().isInteger() && getDim().type().isScalar();
  eq FMatrix.dimensionIsOk()    = true;
  eq FMatrixRow.dimensionIsOk() = true;
 
  public void InstFunctionCall.typeCheck(ErrorCheckType checkType) {
	  if (!isFunctionCallClause() && !getName().myInstClassDecl().isRecord() && !hasOutputs())
		  error("Function " + getName().name() + "() has no outputs, but is used in expression");
	  else if (!isFunctionCallClause() && !inFunction() && size().isUnknown())
		  error("Could not evaluate array size of output " + expOutput().name());
	  if (myOutputs().size() < myLefts().size())
		  error("Too many components assigned from function call: " + getName().name() + 
				  "() has " + myOutputs().size() + " output(s)");
  }
  
  public void FFunctionCallLeft.typeCheck(ErrorCheckType checkType) {
	  if (hasFExp() && !myOutput().isUnknown() && !type().isUnknown()) { // Avoid duplicate error
		  if (getFExp() instanceof FIdUseExp) {  // Should never be false - add check? 
			  FIdUse use = getFExp().asFIdUse();
			  if (use.isForIndex()) {
				  error("Can not assign a value to a for loop index");
			  } else if (size().isUnknown() && !inFunction()) {
				  error(functionCallDecription() + ": could not evaluate array size of output " + 
						  myOutput().name());
			  } else if (!use.type().typeCompatible(type(), true)) {
			      if (use.type().scalarType().typeCompatible(type().scalarType())) {
			          if (!lockBranch(checkType))
	                      error(functionCallDecription() + ": array sizes of component " + use.name() + 
	                              " and output " + myOutput().name() + " are not compatible");
			      } else {
    				  error(functionCallDecription() + ": types of component " + use.name() + 
    						  " and output " + myOutput().name() + " are not compatible");
			      }
			  }
		  }
	  }
  }
  
  inh String InstFunctionArgument.functionCallDecription();
  inh String FFunctionCallLeft.functionCallDecription();
  eq FAbstractFunctionCall.getChild().functionCallDecription() = functionCallDecription();
  eq FFunctionCallEquation.getChild().functionCallDecription() = getCall().functionCallDecription();
  eq FFunctionCallStmt.getChild().functionCallDecription()     = getCall().functionCallDecription();
  
  public void InstFunctionArgument.typeCheck(ErrorCheckType checkType) {
	  boolean typeOk = true;
	  FType type = getFExp().type();
	  if (!type.isUnknown()) {
		  if (argumentDefinedTypeValid()) {
			  FType boundType = getBoundInput().type();
			  if (!boundType.isUnknown()) {
				  if (isVectorized()) 
					  boundType = boundType.sizedType(boundType.size().expand(vectorizedSize()));
				  else if (isDestructorArgument())
					  boundType = boundType.sizedType(type.size());
				  typeOk = boundType.typeCompatible(type, true);
			  }
		  } else {
			  typeOk = argumentTypeValid(type);
		  }
	  }
	  if (!typeOk) {
		  if (getBoundInput() == null) {
			  error(nonBoundArgumentTypeError());
		  } else {
		      String msg = argumentTypeError();
		      if (msg != null)
		          error(msg);
		      else
    			  error(functionCallDecription() + ": types of " + argumentDesc() + 
    					  " and input " + getBoundInput().name() + " are not compatible");
		  }
	  }
  }
  
  public void InstMissingArgument.typeCheck(ErrorCheckType checkType) {
	  if (!isDestructorArgument())
		  error(functionCallDecription() + ": missing argument for required input " + getBoundInput().name());
  }
  
  public void InstMultipleBoundArgument.typeCheck(ErrorCheckType checkType) {
	  error(functionCallDecription() + ": multiple arguments matches input " + getBoundInput().name());
  }
  
  inh boolean InstFunctionArgument.isDestructorArgument();
  eq InstFunctionCall.getArg().isDestructorArgument() = isDestructorCall();
  eq BaseNode.getChild().isDestructorArgument()       = false;
  
  inh boolean InstClassDecl.inExternalObject();
  eq InstNode.getChild().inExternalObject() = isExternalObject();
  
  public void InstDefaultArgument.typeCheck(ErrorCheckType checkType) {}
  
  inh String InstFunctionArgument.nonBoundArgumentTypeError();
  eq FExp.getChild().nonBoundArgumentTypeError()                          = null;
  eq FArrayDimAsArgsExp.getOriginalArg(int i).nonBoundArgumentTypeError() = 
	  functionCallDecription() + ": type of positional argument " + i + " is not compatible with Integer";
  
  inh String InstFunctionArgument.argumentTypeError();
  eq FExp.getChild().argumentTypeError()         = null;
  eq FCardinality.getChild().argumentTypeError() = "The argument of cardinality() must be a scalar reference to a connector";
  
  protected String InstFunctionArgument.argumentDesc() { return null; }
  
  protected String InstPositionalArgument.argumentDesc() {
	  return "positional argument " + (getPos() + 1);
  }
  
  protected String InstNamedArgument.argumentDesc() {
	  return "named argument " + getName().prettyPrint("");
  }
  
  public void InstAccess.typeCheck(ErrorCheckType checkType) {
//	  if (getTopInstAccess() == this && !type().isUnknown()) {
		  // TODO: if this is a slice, check that all branches are of equal size
//	  }
  }
  
  public void InstDot.typeCheck(ErrorCheckType checkType) {
	  // Check for accesses to non-constant component in class
	  int n = getNumInstAccess();
	  for (int i = 0; i < n - 1; i++)
		  getInstAccess(i).checkAccessCompInClassLeft(getInstAccess(i + 1), checkType);
	  super.typeCheck(checkType);
  }
  
  public void InstAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {}
  
  public void InstClassAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {
	  right.checkAccessCompInClassRight(myInstClassDecl(), checkType);
  }
  
  public void InstComponentAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {
	  if (myInstComponentDecl().isPrimitive()) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access attribute of primitive with dot notation: " + top.name());
	  }
  }
  
  public void InstComponentArrayAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {
	  if (myInstComponentDecl().isPrimitive()) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access attribute of primitive with dot notation: " + top.name());
	  }
  }
  
  public void InstAccess.checkAccessCompInClassRight(InstClassDecl icd, ErrorCheckType checkType) {}
  
  public void InstComponentAccess.checkAccessCompInClassRight(InstClassDecl icd, ErrorCheckType checkType) {
	  String type = null;
	  if (icd.extendsEnum()) {
		  if (!myInstComponentDecl().isEnumLiteral())
			  type = "attribute of primitive with dot notation";
	  } else if (icd.isPackage()) {
		  icd.checkRestriction(checkType);
	  } else if (!icd.isOkPackage()) {
		  type = "component in non-package class";
	  }
	  if (type != null) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access " + type + ": " + top.name());
	  }
  }
  
  public void InstComponentArrayAccess.checkAccessCompInClassRight(InstClassDecl icd, ErrorCheckType checkType) {
	  String type = null;
	  if (icd.extendsEnum()) {
		  if (!myInstComponentDecl().isEnumLiteral())
			  type = "attribute of primitive with dot notation";
	  } else if (icd.isPackage()) {
		  icd.checkRestriction(checkType);
	  } else if (!icd.isOkPackage()) {
		  type = "component in non-package class";
	  }
	  if (type != null) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access " + type + ": " + top.name());
	  }
  }
  
  /**
   * \brief Check if the type defined for this argument in the built-in function list 
   *        is valid.
   */
  inh boolean InstFunctionArgument.argumentDefinedTypeValid();
  eq FAbstractFunctionCall.getChild().argumentDefinedTypeValid()           = true;
  eq FTranspose.getOriginalArg().argumentDefinedTypeValid()                = false;
  eq FSymmetric.getOriginalArg().argumentDefinedTypeValid()                = false;
  eq FMinMaxExp.getOriginalArg().argumentDefinedTypeValid()                = false;
  eq FReductionExp.getOriginalArg().argumentDefinedTypeValid()             = false;
  eq FHomotopyExp.getOriginalArg().argumentDefinedTypeValid()              = false;
  eq FSemiLinearExp.getOriginalArg().argumentDefinedTypeValid()            = false;
  eq FNdimsExp.getOriginalArg().argumentDefinedTypeValid()                 = false;
  eq FInfArgsFunctionCall.getOriginalArg().argumentDefinedTypeValid()      = false;
  eq FEnumIntegerExp.getOriginalArg().argumentDefinedTypeValid()           = false;
  eq FVectUnaryBuiltIn.getOriginalArg().argumentDefinedTypeValid()         = false;
  eq FDimensionConvert.getOriginalArg().argumentDefinedTypeValid()         = false;
  eq FEventGenExp.getOriginalArg().argumentDefinedTypeValid()              = false;
  eq FCardinality.getOriginalArg().argumentDefinedTypeValid()              = false;
  eq FMathematicalFunctionCall.getOriginalArg().argumentDefinedTypeValid() = false;
  eq FConnectionsOp.getOriginalArg().argumentDefinedTypeValid()            = false;
  eq FStringExp.getOriginalArg(int i).argumentDefinedTypeValid()           = i > 0;
  eq FConnPotentialRoot.getOriginalArg(int i).argumentDefinedTypeValid()   = i == 1;
  eq FSizeExp.getOriginalArg(int i).argumentDefinedTypeValid()             = i != 0;
  eq FSmoothExp.getOriginalArg(int i).argumentDefinedTypeValid()           = i == 0;
  eq InstPreExp.getOriginalArg().argumentDefinedTypeValid()                = false;
  eq FEdgeExp.getOriginalArg().argumentDefinedTypeValid()                  = false;
  eq FChangeExp.getOriginalArg().argumentDefinedTypeValid()                = false;
  eq FReinit.getOriginalArg().argumentDefinedTypeValid()                   = false;

  /**
   * \brief Check if the type supplied is valid for this argument.
   * 
   * Only used if argumentDefinedTypeValid() returns <code>false</code>.
   */
  inh boolean InstFunctionArgument.argumentTypeValid(FType type);
  eq FAbstractFunctionCall.getChild().argumentTypeValid(FType type) = type.isPrimitive();
  eq FTranspose.getChild().argumentTypeValid(FType type)            = type.ndims() >= 2 && type.isPrimitive();
  eq FSymmetric.getChild().argumentTypeValid(FType type)            = type.ndims() == 2 && type.size().get(0) == type.size().get(1);
  eq FReductionExp.getChild().argumentTypeValid(FType type)         = type.ndims() > 0 && type.hasAdd();
  eq FHomotopyExp.getChild().argumentTypeValid(FType type)          = true;
  eq FSemiLinearExp.getChild().argumentTypeValid(FType type)        = type.isNumeric();
  eq FNoEventExp.getChild().argumentTypeValid(FType type)           = true;
  eq FSizeExp.getChild().argumentTypeValid(FType type)              = true;
  eq FAbsExp.getChild().argumentTypeValid(FType type)               = type.isNumeric();
  eq FSignExp.getChild().argumentTypeValid(FType type)              = type.isNumeric();
  eq FEnumIntegerExp.getChild().argumentTypeValid(FType type)       = type.isEnum();
  eq FEventGenExp.getChild().argumentTypeValid(FType type)          = type.isNumeric();
  eq FMathematicalFunctionCall.getChild().argumentTypeValid(FType type) = type.isNumeric();
  eq FArrayDimAsArgsExp.getFExp().argumentTypeValid(FType type)     = type.isInteger();
  eq FFillExp.getOriginalArg(int i).argumentTypeValid(FType type)   = true;
  eq FMinMaxExp.getOriginalArg(int i).argumentTypeValid(FType type) = 
	  hasY() != getOriginalArg(i).getFExp().isArray() && type.isPrimitive();
  eq FSmoothExp.getChild().argumentTypeValid(FType type)            = type.onlyContainsReal();
  eq FDimensionConvert.getChild().argumentTypeValid(FType type)     = argumentSizeValid(type.size());
  eq FCardinality.getChild().argumentTypeValid(FType type)          = type.isScalar() && getFExp().isComponentReference(ALLOWED_COMPONENTS);
  eq FConnectionsOp.getOriginalArg(int i).argumentTypeValid(FType type) = 
          getOriginalArg(i).getFExp().isComponentReference(ALLOWED_COMPONENTS);
  eq FStringExp.getChild().argumentTypeValid(FType type)            = type.isScalar() && (type.isReal() || type.isInteger() || type.isBoolean() || type.isEnum());
  eq FReinit.getChild().argumentTypeValid(FType type)               = true;  // Type checked in Reinit.typeCheck()
  
  protected static final Criteria<InstComponentDecl> FCardinality.ALLOWED_COMPONENTS = new Criteria<InstComponentDecl>() {
      public boolean test(InstComponentDecl elem) { return elem.isConnector() || elem.isPrimitive(); }
  };

  protected static final Criteria<InstComponentDecl> FConnectionsOp.ALLOWED_COMPONENTS = new Criteria<InstComponentDecl>() {
      public boolean test(InstComponentDecl elem) { return elem.isOverconstrainedType(); }
  };

  /**
   * Check if this expression is a reference to a component matching specified criteria.
   * 
   * Only valid in instance tree.
   */
  syn boolean FExp.isComponentReference(Criteria<InstComponentDecl> criteria)  = false;
  eq FInstAccessExp.isComponentReference(Criteria<InstComponentDecl> criteria) = 
      criteria.test(getInstAccess().myInstComponentDecl());

  /**
   * Check if the given Size is valid for the argument of the operator.
   */
  syn boolean FDimensionConvert.argumentSizeValid(Size s) {
	  boolean[] useDim = new boolean[s.ndims()];
	  for (int d : dimensionsToKeep())
		  if (d < useDim.length)
			  useDim[d] = true;
	  for (int i = 0; i < s.ndims(); i++)
		  if (!useDim[i] && s.get(i) != 1)
			  return false;
	  return true;
  }
	
}

aspect FlatVariabilityCheck {
    
    private FExp FPreExp.instanceTreeSource = null;
    private FExp FReinit.instanceTreeSource = null;
    
    public void FExp.setInstanceTreeSource(FExp source) {}
    
    public void FPreExp.setInstanceTreeSource(FExp source) {
        instanceTreeSource = source;
    }
    
    public void FReinit.setInstanceTreeSource(FExp source) {
        instanceTreeSource = source;
    }
    
    /**
     * Surrounds the FExp <code>exp</code> with pre if it is an non literal exp, else return exp.
     * 
     * Also sets the <code>instanceTreeSource</code> field of the FPreExp (if any) 
     * to <code>source</code>.
     */
    public static FExp FPreExp.create(FExp exp, FExp source) {
        exp = create(exp);
        exp.setInstanceTreeSource(source);
        return exp;
    }
    
    /**
     * Check operations that are allowed on discrete expressions or variables, 
     * but not on continuous ones or vice-versa.
     * 
     * Also breaks connections back to instance tree that was added during flattening 
     * to be able to report these errors in the correct place.
     */
    public void ASTNode.checkDiscreteOperations() {
        for (ASTNode n : this)
            n.checkDiscreteOperations();
    }
    
    public void FPreExp.checkDiscreteOperations() {
        if (instanceTreeSource != null && getFIdUse().myFV().isContinuous() && !inWhen() && !inInitialEquationSection()) 
            instanceTreeSource.discreteArgError();
        instanceTreeSource = null;
    }
    
    public void FReinit.checkDiscreteOperations() {
        if (instanceTreeSource != null && !myFV().isContinuous()) 
            instanceTreeSource.discreteArgError();
        instanceTreeSource = null;
    }
    
    /**
     * Generate error for operator that got wrong variability of argument
     */
    public void FExp.discreteArgError() {
        throw new UnsupportedOperationException();
    }
    
    public void InstPreExp.discreteArgError() {
        error("Calling built-in operator pre() with a continuous variable access as argument can only be done in when clauses and initial equations");
    }
    
    public void FChangeExp.discreteArgError() {
        error("Calling built-in operator change() with a continuous variable access as argument can only be done in when clauses and initial equations");
    }
    
    public void FReinit.discreteArgError() {
        error("Built-in operator reinit() must have a continuous variable access as its first argument");
    }
    
}