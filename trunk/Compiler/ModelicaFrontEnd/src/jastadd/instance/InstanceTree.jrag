/*
    Copyright (C) 2009-2013 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.Collections;

aspect Environment {

    /**
     * TODO: Is it a good idea to inherit? Should env be a component?
     */
    public class Environment extends ArrayList<InstModification> {
    
        public Environment() {
        	super();
        }

        /**
         * Merge an outer modification into the environment: add it at the beginning.
         */    
    	public void mergeOuterModification(InstModification outerMod) {
    		ArrayList<InstModification> outerMods = outerMod.expand();
    		addAll(0,outerMods);
    	}

        /**
         * Merge an inner modification into the environment: add it last.
         */    
    	public void mergeInnerModification(InstModification innerMod) {
    		ArrayList<InstModification> innerMods = innerMod.expand();
    		addAll(innerMods);    	
    	}

        /**
         * Merge an outer environment: add it first.
         */ 
    	public void mergeOuterEnvironment(Environment outerEnv) {
    		addAll(0,outerEnv);
    	}

        /**
         * Merge an inner environment: add it last.
         */
    	public void mergeInnerEnvironment(Environment innerEnv) {
    	   addAll(innerEnv);
    	}

        public Environment clone() {
        	Environment env = new Environment();
        	env.addAll(this);
        	return env;
        }
    	
    	/**
    	 * TODO: implement!
    	 */
        public Environment peel(String name) {
        	return new Environment();
        }
        
        public String toString() {
           StringBuilder str = new StringBuilder();
           str.append("{");
           for (InstModification im : this) {
//           	  str.append("  " + im.getModification().prettyPrint("") + ",\n");
           	  str.append("  " + im.getModification().prettyPrint("") + ",");
           	  str.append(im.myInstNode().toString());
           	  str.append("\n");
           }
           str.append("}\n");
           return str.toString();
        }
        
        public String toString(String indent) {
           StringBuilder str = new StringBuilder();
           str.append(indent+"{");
           for (int i=0;i<size();i++) {
              InstModification im = get(i);
              if (i==0)
              	str.append(im.getModification().prettyPrint(""));
           	  else
           	  	str.append(indent + " " +  im.getModification().prettyPrint(""));
           	  str.append(": ");
           	//  if (im.myInstNode().toString()!=null)
	           	  str.append(im.myInstNode().name());

              if (i !=size()-1)
              	str.append(",\n");
           }
           str.append("}\n");
           return str.toString();
        }
    
    }

}

aspect InstModifications{

	public ArrayList<InstModification> InstModification.expand() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		l.add(this);
		return l;
	}

	public ArrayList<InstModification> InstCompleteModification.expand() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		for (InstModification im : getInstClassModification().getInstArguments())
			l.add(im);
		if (hasInstValueModification())
			l.add(getInstValueModification());
		return l;	
		
	}

	public ArrayList<InstModification> InstClassModification.expand() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		for (InstModification im : getInstArguments())
			l.add(im);
		return l;	
	}

	public abstract InstModification Modification.newInstModification();
	public InstCompleteModification CompleteModification.newInstModification() {
		InstCompleteModification icm = new InstCompleteModification(this,getClassModification().newInstModification(),new Opt());
        if (hasValueModification())
        	icm.setInstValueModification(getValueModification().newInstModification());
        return icm;
	}	
	public InstValueModification ValueModification.newInstModification() {
		return new InstValueModification(this);
	}
	public InstClassModification ClassModification.newInstModification () {
		List l = new List();
		for (Argument a : getArguments()) {
			l.add(a.newInstModification());
		}
		return new InstClassModification(this,l);
	}
	public InstComponentModification ComponentModification.newInstModification() {
		InstComponentModification icm = new InstComponentModification(this,hasEach(),hasFinal(),getName().newInstAccess(),new Opt());
		if (hasModification())
			icm.setInstModification(getModification().newInstModification());
		icm.setLocation(this);
		return icm;
	}
	public InstComponentRedeclare ComponentRedeclare.newInstModification() {
	    // TODO: Can this component be redeclared?
		InstComponentRedeclare icr = new InstComponentRedeclare(this,hasEach(),hasFinal(),getName().newInstAccess());
		icr.setLocation(this);
		return icr;
	}
	
	public InstComponentRedeclare PN_ComponentRedeclare.newInstModification() {
		return null; // This should never be called since all PN_ComponentRedeclare:s are rewritten	    
	}	
	
	public InstClassRedeclare ClassRedeclare.newInstModification() {
		InstClassRedeclare icr = new InstClassRedeclare(this,hasEach(),hasFinal(),getName().newInstAccess());
		icr.setLocation(this);
		return icr;
	}
	
	
	syn CompleteModification InstCompleteModification.getCompleteModification() = (CompleteModification)getModification();
	syn ClassModification InstClassModification.getClassModification() = (ClassModification)getModification();
	syn ValueModification InstValueModification.getValueModification() = (ValueModification)getModification();
	syn ComponentModification InstComponentModification.getComponentModification() = (ComponentModification)getModification();
	syn ClassRedeclare InstClassRedeclare.getClassRedeclare() = (ClassRedeclare)getModification();
	syn ComponentRedeclare InstComponentRedeclare.getComponentRedeclare() = (ComponentRedeclare)getModification();

	
	/**
	 * At what level from the top model is this modification set?
	 */
	inh int InstModification.modificationLevel();
	inh int InstNode.modificationLevel();
	eq InstNode.getChild().modificationLevel()           = modificationLevel() + 1;
	eq InstRoot.getChild().modificationLevel()           = 0;
    eq Root.getChild().modificationLevel()               = 0;
	eq InstShortClassDecl.getChild().modificationLevel() = modificationLevel();

}

aspect Environments {

 	syn lazy ArrayList<InstModification> InstNode.localInstModifications() 
 	   = new ArrayList<InstModification>();

 	
 	eq InstComponentDecl.localInstModifications() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		// Add modifications of the declaration itself
		if (hasInstModification())
			l.add(getInstModification());
			
	    // If there is a constraining clause, these modifications should be merged as well 
		if (hasInstConstraining() &&
		       getInstConstraining().hasInstClassModification())
		  	l.add(getInstConstraining().getInstClassModification());	
        l.addAll(myInstClass().classInstModifications());
		return l;
		
	}
 	
	eq InstReplacingRecord.localInstModifications()    = calcLocalInstModForRedeclaringComponent(getOriginalInstComponent());
	eq InstReplacingComposite.localInstModifications() = calcLocalInstModForRedeclaringComponent(getOriginalInstComponent());
	
	syn ArrayList<InstModification> InstComponentDecl.calcLocalInstModForRedeclaringComponent(
			InstComponentDecl originalInst) {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		// If there is a constraining clase, return its modifications
		if (originalInst.hasInstConstraining()) {
		  if (originalInst.getInstConstraining().hasInstClassModification()) {
			l.add(originalInst.getInstConstraining().getInstClassModification());
          }
        } else {
            // If no constraining clause, use the original declaration 
            // and return its modifiers
     		if (originalInst.hasInstModification())
				l.add(originalInst.getInstModification());     
        }
        l.addAll(myInstClass().classInstModifications());
		return l;
	}
	 
	eq InstShortClassDecl.localInstModifications() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
   		if (hasInstClassModification())
				l.add(getInstClassModification());     
		if (hasInstConstraining()) {
		  if (getInstConstraining().hasInstClassModification()) {
			l.add(getInstConstraining().getInstClassModification());
          }
        } 
        l.addAll(getInstExtends(0).myInstClass().classInstModifications());
   		return l;
	}
	
	syn ArrayList<InstModification> InstClassDecl.localInstModificationsForReplacingClass() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		InstClassDecl org = originalInstClass();
		// If there is a constraining clase, return its modifications
		if (org.hasInstConstraining()) {
			if (org.getInstConstraining().hasInstClassModification()) 
				l.add(org.getInstConstraining().getInstClassModification());
        } else {
            // If no constraining clause, use the original declaration 
            // and return its modifiers
     		if (org.hasInstClassModification())
				l.add(org.getInstClassModification());     
        }	
		return l;
	}
 	
	eq InstReplacingShortClassDecl.localInstModifications() {
		ArrayList<InstModification> l = localInstModificationsForReplacingClass();
        l.addAll(getInstExtends(0).myInstClass().classInstModifications());
		return l;
	}
 	
	eq InstReplacingSimpleShortClassDecl.localInstModifications() = localInstModificationsForReplacingClass();
	eq InstReplacingFullClassDecl.localInstModifications()        = localInstModificationsForReplacingClass();
	
	/**
	 * Return OriginalInstClass for nodes that have it, null otherwise.
	 */
	syn InstClassDecl InstClassDecl.originalInstClass()      = null;
	eq InstReplacingShortClassDecl.originalInstClass()       = getOriginalInstClass();
	eq InstReplacingSimpleShortClassDecl.originalInstClass() = getOriginalInstClass();
	eq InstReplacingFullClassDecl.originalInstClass()        = getOriginalInstClass();
	 	
	// TODO: This should probably be implemented as an AST node child. 	
	syn lazy boolean InstClassDecl.hasInstClassModification() = false;
	eq InstShortClassDecl.hasInstClassModification() = getInstExtends(0).hasInstClassModification(); 	
	syn lazy InstClassModification InstClassDecl.getInstClassModification() = null;
	eq InstShortClassDecl.getInstClassModification() = getInstExtends(0).getInstClassModification(); 	

	eq InstExtends.localInstModifications() {
		ArrayList<InstModification> l = new ArrayList<InstModification>();
		if (hasInstClassModification())
			l.add(getInstClassModification());
        l.addAll(myInstClass().classInstModifications());
		return l;
	}

 	syn lazy ArrayList<InstModification> InstClassDecl.classInstModifications() = getMergedEnvironment().clone();

 
 
    /* getMergedEnvironment gives the environment applicable
       to the children of the InstNode. It consists of the outer modifications
       in the environment (with the name of the InstNode itself, if any,
       removed) merged with potential local modifications.
    
       TODO: Should this attribute be lazy? Probably yes
      
    */   
    
    // TODO: merge also class redeclaration modifications    
	syn lazy Environment InstNode.getMergedEnvironment() {
		// Retrieve modifications upwards
		Environment env = filteredEnvironment().clone();
		for (InstModification im : getElementInstModifications())
			env.mergeInnerModification(im);
        for (InstModification im : localInstModifications())
            env.mergeInnerModification(im);
		return env;
	}
	
	syn Environment InstNode.filteredEnvironment() = nameScope() ? myEnvironment(name()) : myEnvironment();
	
	eq InstArrayComponentDecl.getMergedEnvironment() {
		Environment env = super.getMergedEnvironment();
		for (int i = 0; i < env.size(); i++) {
			if (env.get(i) instanceof InstValueModification) {
				InstValueModification ivm = (InstValueModification) env.get(i);
				FExp exp = ivm.getFExp();
				if (exp.isArray()) {
					exp = exp.splitArrayExp(getIndex());
					InstArrayModification aim = new InstArrayModification(ivm.getModification(), exp);
					env.set(i, ivm.dynamicInstMod(aim));
				}
			}
		}
		return env;
	}


	/**
	 * myEnvironment represents the environment of the InstNode itself. It is defined
	 * as an inherited attribute and is computed from the outer environment located at
	 * ancestor InstNodes.
	 */	
	inh Environment InstNode.myEnvironment();
	inh Environment InstNode.myEnvironment(String name);
    eq Root.getChild().myEnvironment()            = null;
    eq Root.getChild().myEnvironment(String name) = null;
	
	/**
	 * When no arguments are supplied to myEnvironment, the MergedEnvironment of the ancestor
	 * InstNode is simply duplicated. This is typically the case for extends clauses.
	 */
	eq InstNode.getChild().myEnvironment() = getMergedEnvironment().clone();

/*
	eq InstReplacingShortClassDecl.getChild().myEnvironment() {
		Environment env = getMergedEnvironment().clone();
		if (getOriginalInstClass().hasInstConstraining()) {
			if (getOriginalInstClass().getInstConstraining().hasInstClassModification())
				env.mergeInnerModification(getOriginalInstClass().getInstConstraining().getInstClassModification());
		} else {
		    InstClassDecl origDecl = getOriginalInstClass();
			if (origDecl.getInstExtends(0).hasInstClassModification())
				env.mergeInnerModification(origDecl.getInstExtends(0).getInstClassModification());
		}
		return env;
	}
*/

	/** 
	 * When a string argument representing a component name is given as argument to myEnvironment,
	 * the resulting environment consists only of modifications with a matching prefix. In effect, this 
	 * results in a "peeling" operation, where the first name in a qualified name is removed, and the rest
	 * of the modification is added to myEnvironment. The algorithm is somewhat complicated by component
	 * redeclares that needs to be taken into account. 
	 */
	eq InstNode.getChild().myEnvironment(String name) = myEnvironment_def(name); // This is just to get caching at the right place.
	
	syn lazy Environment InstNode.myEnvironment_def(String name) {
		Environment env = new Environment();
		boolean componentRedeclareFound = false;
		InstComponentRedeclare icr = retrieveReplacingComponent(name);
		boolean classRedeclareFound = false;
		InstRedeclareClassNode iclrn = retrieveReplacingClass(name);
		for (InstModification im : getMergedEnvironment()) {
			// If a first component redeclare modification is found, add modifiers
			if (!componentRedeclareFound && im == icr) {
            	if (icr.getInstComponentDecl().hasInstModification()) 
    				env.mergeInnerModification(icr.getInstComponentDecl().getInstModification());
				componentRedeclareFound = true;
			}
			// If a first class redeclare modification is found, add modifiers
			// TODO: Do we need to handle the case when iclrn is an InstClassDecl?
			if (!classRedeclareFound && im == iclrn) {
				InstClassRedeclare iclr = (InstClassRedeclare) im;
            	if (iclr.getInstClassDecl().hasInstClassModification()) 
    				env.mergeInnerModification(iclr.getInstClassDecl().getInstClassModification());
				classRedeclareFound = true;
			}
			
			if (im.matchInstModification(name) != null) {
				env.mergeInnerModification(im.matchInstModification(name));
			}
		}
		return env;
		
	}

	eq Program.getInstProgramRoot().myEnvironment() = new Environment();
	eq Program.getInstProgramRoot().myEnvironment(String name) = new Environment();
	
	syn lazy List<InstRecordModification> InstValueModification.getInstRecordModificationList() {
		List<InstRecordModification> res = new List<InstRecordModification>();
		getFExp().populateInstRecordModificationList(res, this);
		return res;
	}
	
	syn InstModification InstModification.matchInstModification(String name) = null;
	eq InstCompleteModification.matchInstModification(String name) {
		for (InstModification im : getInstClassModification().getInstArguments()) {
		    InstModification match = im.matchInstModification(name);
			if (match != null)
				return match;
		}
		return null;
	}
	
	eq InstComponentModification.matchInstModification(String name) {
		if (getName().matches(name))
			return hasInstModification() ? getInstModification() : null;
		return null;
	}
	
	eq InstValueModification.matchInstModification(String name) {
		for (InstRecordModification im : getInstRecordModifications())
			if (im.getName().equals(name))
				return im;
		return null;
	}
	
	// Only add modifiers in constraining clauses
	eq InstComponentRedeclare.matchInstModification(String name) {
		if (getName().matches(name) && getInstComponentDecl().hasInstConstraining() &&
		    getInstComponentDecl().getInstConstraining().hasInstClassModification())
			return getInstComponentDecl().getInstConstraining().getInstClassModification();
		return null;
	}	
	
	// Only add modifiers in constraining clauses
	eq InstClassRedeclare.matchInstModification(String name) {
		if (getName().matches(name) && getInstClassDecl().hasInstConstraining() &&
		    getInstClassDecl().getInstConstraining().hasInstClassModification())
			return getInstClassDecl().getInstConstraining().getInstClassModification();
		return null;
	}
	
	public void FExp.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org) {}
	
	public void InstRecordConstructor.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org) {
		InstClassDecl icd = getRecord().myInstClassDecl();
		ArrayList<InstComponentDecl> inputs = icd.myModifiableComponents();
		Modification mod = org.getModification();
		for (int i = 0; i < inputs.size(); i++) {
			String name = inputs.get(i).name();
			list.add(getArg(i).createInstRecordModification(mod, name));
		}
	}
    
    public InstRecordModification InstFunctionArgument.createInstRecordModification(Modification mod, String name) {
        return new InstRecordModification(mod, name, getFExp());
    }
    
    public InstRecordModification InstDefaultArgument.createInstRecordModification(Modification mod, String name) {
        InstModification source = null;
        if (getFExp().findComponentWithThisBindingExp() == null) {
            source = getFExp().surroundingInstModification();
            mod = source.getModification();
        }
        return new InstDefaultRecordModification(mod, name, getFExp(), source);
    }
	
	public void FIdUseExp.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org) {
		getFIdUse().populateInstRecordModificationList(list, org, this);
	}
	
	public void FInstAccessExp.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org) {
		getInstAccess().populateInstRecordModificationList(list, org, this);
	}
	
	public void FIdUse.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org, FExp exp) {}
	
	public void FIdUseInstAccess.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org, FExp exp) {
		getInstAccess().populateInstRecordModificationList(list, org, exp);
	}
	
	public void InstAccess.populateInstRecordModificationList(
			List<InstRecordModification> list, InstValueModification org, FExp exp) {
		InstComponentDecl var = myInstComponentDecl();
		if (var.isRecord()) {
			Modification mod = org.getModification();
			for (FRecordComponentType comp : ((FRecordType) var.type()).getComponents()) {
				String name = comp.getName();
				FExp val = exp.dynamicFExp(new FInstAccessExp(copyAndAppend(name)));
				list.add(new InstRecordModification(mod, name, val));
			}
		}
	}
	
	/**
	 * Find the InstModification containing this expression, if any.
	 */
	inh InstModification FExp.surroundingInstModification();
    eq InstModification.getChild().surroundingInstModification() = this;
    eq InstNode.getChild().surroundingInstModification()         = null;
    eq Root.getChild().surroundingInstModification()             = null;
	
	
	syn InstComponentRedeclare InstModification.matchInstComponentRedeclare(String name) = null;
	eq InstComponentRedeclare.matchInstComponentRedeclare(String name) {
		if (getName().name().equals(name))
			return this;
		else
			return null;
	}
	
    syn InstClassRedeclare InstModification.matchInstClassRedeclare(String name) = null;
	eq InstClassRedeclare.matchInstClassRedeclare(String name) {
		if (getName().name().equals(name))
			return this;
		else
			return null;
	}
	
	syn InstComponentRedeclare InstNode.retrieveReplacingComponent(String name) {
		for (InstModification im : getMergedEnvironment()) {
			InstComponentRedeclare icr = im.matchInstComponentRedeclare(name);
			if (icr != null) 
				return icr;
		}
		return null;
	}

	// TODO: make sure components are created using the right class now
	syn InstRedeclareClassNode InstNode.retrieveReplacingClass(String name) {
		for (InstModification im : getMergedEnvironment()) {
			InstClassRedeclare icr = im.matchInstClassRedeclare(name);
			if (icr != null) 
				return icr;
		}
		return null;
	}
	
	eq InstExtends.retrieveReplacingClass(String name) {
		InstRedeclareClassNode res = super.retrieveReplacingClass(name);
		return (res == null) ? lookupReplacingClass(name) : res;
	}
	
	inh InstRedeclareClassNode InstExtends.lookupReplacingClass(String name);
	eq InstNode.getInstExtends().lookupReplacingClass(String name) {
		for (InstClassDecl icd : getRedeclaredInstClassDecls())
			if (icd.name().equals(name))
				return icd;
		return retrieveReplacingClass(name);
	}
	eq InstExtends.getChild().lookupReplacingClass(String name) {
		InstRedeclareClassNode res = lookupReplacingClass(name);
		if (res != null)
			return res;
		for (InstClassDecl icd : getRedeclaredInstClassDecls())
			if (icd.name().equals(name))
				return icd;
		return super.retrieveReplacingClass(name);
	}
    eq InstRoot.getChild().lookupReplacingClass(String name) = null;
    eq Root.getChild().lookupReplacingClass(String name)     = null;

	inh InstNode InstModification.myInstNode();
	inh InstNode InstNode.myInstNode();
	inh InstNode FAbstractEquation.myInstNode();
	eq InstNode.getChild().myInstNode() = this;
	eq Root.getChild().myInstNode() {
		throw new UnsupportedOperationException();
	}
	
	//The lexical scope of modifiers for short classes are "outside" of the short declaration
    eq InstExtendsShortClass.getChild().myInstNode() = myInstNode();
	
	/**
	 * InstPrimitive:s may have children of type InstExtends, if the InstPrimitive is instantiated
	 * either from a short class declaration that references a primitive type or from a 'type' class
	 * declaration that inherits a primitive type. In both cases, the result is one or a chain of InstExtends/
	 * InstExtendsShortClass children. The final node in such a chain holds the total merged environment of 
	 * the InstPrimitive. InstRecords can of course have InstExtends.
	 */
	syn lazy Environment InstNode.totalMergedEnvironment() {
		if (getNumInstExtends()==0)
			return getMergedEnvironment();
		else
			return getInstExtends(0).totalMergedEnvironment();
	}
	eq InstSimpleShortClassDecl.totalMergedEnvironment() = actualInstClass().getMergedEnvironment();

}

aspect InstanceTreeConstruction {

    syn lazy List Program.getAnonymousClassList() = new List();

    private Map<String,ClassDecl> Program.anonymousClassMap = null;

    syn ClassDecl Program.anonymousClass(String code, Restriction restriction, String targetName) {
        if (anonymousClassMap == null)
            anonymousClassMap = new HashMap<String,ClassDecl>();
        ClassDecl res = anonymousClassMap.get(code);
        if (res == null) {
            try {
                addAnonymousClass(ParserHandler.parseAnonymousClassString(code, restriction, targetName));
                res = getAnonymousClass(getNumAnonymousClass() - 1);
                anonymousClassMap.put(code, res);
            } catch (IOException e) {
                // Can't normally happen when reading from a string, but just in case
                throw new RuntimeException("Reading from string failed", e);
            } catch (beaver.Parser.Exception e) {
                // Parser crashed - just handle this higher up
                throw new RuntimeException("Parser crashed", e);
            } catch (ParserException e) {
                CompilerException ce = new CompilerException();
                ce.addProblem(e.getProblem());
                throw ce;
            }
        }
        return res;
    }

    syn lazy List InstProgramRoot.getInstAnonymousClassList() = new List();

    syn lazy InstClassDecl InstProgramRoot.instantiateModel(String className) {
        int p = className.indexOf('(');
        if (p >= 0) {
            String targetName = className.substring(0, p);
            InstLookupResult<InstClassDecl> icd = lookupInstClassQualified(targetName);
            if (icd.successful()) {
                Restriction restriction = ((BaseClassDecl) icd.target().getClassDecl()).getRestriction();
                ClassDecl cl = sourceRoot().getProgram().anonymousClass(className, restriction, targetName);
                if (cl != null) {
                    addInstAnonymousClass(createInstClassDecl(cl));
                    return getInstAnonymousClass(getNumInstAnonymousClass() - 1);
                }
            }
            return unknownInstClassDecl();
        } else {
            InstLookupResult<InstClassDecl> icd = lookupInstClassQualified(className);
            return icd.successful() ? icd.target() : unknownInstClassDecl();
        }
    }

	syn nta Opt InstNode.getDynamicFExpOpt() = new DynamicOpt();
	syn nta Opt FExp.getDynamicFExpOpt()     = new DynamicOpt();
	syn lazy Opt FAbstractEquation.getDynamicFAbstractEquationOpt() = new DynamicOpt();	
	syn lazy List InstValueModification.getDynamicInstModList() = new List();
	syn nta Opt FVariable.getDynamicFVariableOpt() = new DynamicOpt();
	
	/**
	 * Dynamically places an FExp in the tree under this InstNode.
	 * 
	 * @return  the final version of the dynamically placed node.
	 */
	public FExp InstNode.dynamicFExp(FExp exp) {
		getDynamicFExpOpt().setChild(exp, 0);
		return (FExp) getDynamicFExpOpt().getChild(0);
	}
	
	
	/**
	 * Dynamically places an FExp in the tree under this FExp.
	 * 
	 * If <code>exp</code> is already in tree of if <code>exp == this</code>, 
	 * then <code>exp</code> is returned.
	 * 
	 * @return  the final version of the dynamically placed node.
	 */
	public FExp FExp.dynamicFExp(FExp exp) {
		if (exp == this)
			return exp;
		if (exp.parent != null) {
			int i = exp.parent.getIndexOfChild(exp);
			if (i >= 0)
				return (FExp) exp.parent.getChild(i);
		}
		getDynamicFExpOpt().setChild(exp, 0);
		return (FExp) getDynamicFExpOpt().getChild(0);
	}
    
    public FVariable FVariable.dynamicFVariable(FVariable fv) {
        if (fv == this)
            return fv;
        if (fv.parent != null) {
            int i = fv.parent.getIndexOfChild(fv);
            if (i >= 0)
                return (FVariable) fv.parent.getChild(i);
        }
        getDynamicFVariableOpt().setChild(fv, 0);
        return (FVariable) getDynamicFVariableOpt().getChild(0);
    }
    
	/**
	 * Dynamically places an FAbstractEquation in the tree under this FAbstractEquation.
	 * 
	 * @return  the final version of the dynamically placed node.
	 */
	public FAbstractEquation FAbstractEquation.dynamicFAbstractEquation(FAbstractEquation eqn) {
		if (eqn == this)
			return eqn;
		getDynamicFAbstractEquationOpt().setChild(eqn, 0);
		return (FAbstractEquation) getDynamicFAbstractEquationOpt().getChild(0);
	}
		
	/**
	 * Dynamically places an InstModification in the tree under this InstValueModification.
	 * 
	 * @return  the final version of the dynamically placed node.
	 */
	public InstModification InstValueModification.dynamicInstMod(InstModification im) {
		// TODO: only used for modifications on array components, should probably use an NTA specifically for that instead
		getDynamicInstModList().add(im);
		return getDynamicInstMod(getNumDynamicInstMod() - 1);
	}


    public interface InstLookupRedirectNode {
        InstLookupResult<InstClassDecl> lookupInstClassRedirect(String name);
    }

	InstNode implements InstLookupRedirectNode;
	InstModification implements InstLookupRedirectNode;
	
	syn lazy List InstNode.getInstComponentDeclList() {
		List<InstComponentDecl> l = new List<InstComponentDecl>();
		for (ComponentDecl cd : components()) 
	        l.add(createInstComponentDecl(cd));
		return l;
		
	}

	eq InstComponentDecl.getInstComponentDeclList() {
		//System.out.println( " : " + getClass().getName() + " : "+ myFSubscripts().size());
		if (isArrayDecl()) { // Take care of array declarations separately
			// Loop over indices and create new InstArrayComponentDecls
			List l = new List();
			// Only the first FSubscript is used to create the first layer
			// of InstArrayComponentDecls. The remaining are used when
			// InstArrayComponentDecls are created further down in the tree.
			// For a zero length, create a dummy node with index 0 
			int n = size().get(0);
			for (int i = (n == 0) ? 0 : 1; i <= n; i++)
				l.add(createInstArrayComponentDecl(i));
			return l;
		} else { // If not array, then proceed as usual
			return super.getInstComponentDeclList();
		}
	}

	eq InstArrayComponentDecl.getInstComponentDeclList() {
		// Get the FSubscript corresponding to this InstArrayComponentDecl
		int n = childDimensionLength();
		List l = new List();
		if (n > 0) {
			// Loop over indices and create new InstArrayComponentDecls
            // For a zero length, create a dummy node with index 0 
			for (int i = (n == 0) ? 0 : 1; i <= n; i++)
				l.add(createInstArrayComponentDecl(i));
		} else {
			for (ComponentDecl cd : components()) 
				l.add(createInstComponentDecl(cd));
		}
			return l;
	}
	
	public InstComponentDecl InstComponentDecl.createInstArrayComponentDecl(int i) {
	    return new InstArrayComponentDecl(new InstClassAccess("ArrayDecl"), new Opt(), 
                getComponentDecl(), new Opt(), new Opt(), new Opt(), i);
	}

    syn lazy List InstNode.getInstClassDeclList() {
        List l = new List();
        
        for (ClassDecl cd : classes()) {
            if (!cd.hasRedeclare()) {
                InstClassDecl icd = createInstClassDecl(cd);
                if (icd != null)
                    l.add(icd);
            }
        }
        
        return l;
    }

	syn lazy List InstNode.getRedeclaredInstClassDeclList() {
		List l = new List();
		
		for (ClassDecl cd : classes()) {
			if (cd.hasRedeclare()) {
			    InstNode icd = cd.newInstClassDecl();
			    if (icd != null)
			    	l.add(icd);
			}
		}				
		
		return l;
	}
    
    syn boolean ClassDecl.hasRedeclare() = false;

	syn lazy List InstNode.getInstExtendsList() {
		List l = new List();
		for (ExtendsClause e : superClasses()) 
			l.add(createInstExtends(e));
		
		return l;
	}
	
	eq InstComponentDecl.getInstExtendsList() {
		List l = new List();
		if (!isArrayDecl()) {
			for (ExtendsClause e : superClasses()) 
				l.add(createInstExtends(e));
		}
		
		return l;
	}

	eq InstArrayComponentDecl.getInstExtendsList() {
		List l = new List();
		if (childDimensionLength() == Size.UNKNOWN) {
			// Loop over indices and create new 
			for (ExtendsClause e : superClasses()) {
				l.add(createInstExtends(e));
			}			
		} 
		return l;
	}
	
	eq InstPrimitive.getInstComponentDeclList() = new List();
	eq InstPrimitive.getInstClassDeclList() = new List();

	syn lazy List<InstModification> InstNode.getElementInstModificationList() {
        List<InstModification> l = new List<InstModification>();
        for (Modification m : elementModifications()) 
            l.add(m.newInstModification());
        return l;
	}


    public InstComponentDecl InstNode.createInstComponentDecl(ComponentDecl cd) {
    	// Check if the component is redeclared. 
    	// -> Yes: Create an InstReplacingComponent component
    	// -> No: Create an InstComponent 
    	InstComponentRedeclare irc = retrieveReplacingComponent(cd.name());
    	if (irc!=null) {
    		ComponentDecl replacingComp = irc.getComponentRedeclare().getComponentDecl();
    		return new InstCreateReplacingComponentDecl(replacingComp, irc, cd, irc);
    		// TODO: handle expandable connectors in this case
    	} else { 
    		return new InstCreateComponentDecl(cd, null);    	
    	}
     }
     
     rewrite InstCreateReplacingComponentDecl {
     	to InstComponentDecl getClassName().myInstClassDecl().newInstReplacingComponent(
     			getComponentDecl(), getOriginalDecl(), getInstComponentRedeclare());
     }
     
     rewrite InstCreateComponentDecl {
     	to InstComponentDecl getClassName().myInstClassDecl().newInstComponentDecl(getComponentDecl());
     }
     
     rewrite InstCreateForIndexPrimitive {
     	to InstPrimitive (InstPrimitive) getClassName().myInstClassDecl().newInstComponentDecl(getComponentDecl());
     }

     public InstClassDecl InstNode.createInstClassDecl(ClassDecl bcd) {
         // Check if the class is redeclared. 
         // -> Yes: Create an InstReplacingClass component
         // -> No: Create an InstClassDecl
         InstRedeclareClassNode icr = retrieveReplacingClass(bcd.name());
         if (icr != null) {
             ClassDecl replacingClass = icr.redeclaringClassDecl();
             return bcd.newInstReplacingClass(replacingClass, icr);
         } else {
             return bcd.newInstClassDecl();
         }
     }

     public interface InstRedeclareClassNode {
         public InstLookupResult<InstClassDecl> lookupInstClass(String name);
         public InstLookupResult<InstClassDecl> lookupInstClassQualified(String name);
         public ClassDecl redeclaringClassDecl();
     }
    InstClassDecl implements InstRedeclareClassNode;
    InstClassRedeclare implements InstRedeclareClassNode;
    
    syn ClassDecl InstClassDecl.redeclaringClassDecl()      = getClassDecl();
    syn ClassDecl InstClassRedeclare.redeclaringClassDecl() = getClassRedeclare().getBaseClassDecl();

	public InstNode InstNode.createInstExtends(ExtendsClause ec) {
   		// This cannot be redeclared. Just create and return.
   		return ec.newInstExtends();
	}

	public InstNode InstReplacingShortClassDecl.createInstExtends(ExtendsClause ec) {
		return createInstExtendsCheckReplacing(ec);
	}

	public InstNode InstReplacingSimpleShortClassDecl.createInstExtends(ExtendsClause ec) {
		return createInstExtendsCheckReplacing(ec);
	}
	
	public InstNode InstExtendsShortClass.createInstExtends(ExtendsClause ec) {
		return createInstExtendsCheckReplacing(ec);
	}
	
	public InstNode InstReplacingExtendsShortClass.createInstExtends(ExtendsClause ec) {
		return createInstExtendsCheckReplacing(ec);
	}

	public InstNode InstNode.createInstExtendsCheckReplacing(ExtendsClause ec) {
		if (!isInInstModification() && ec.needsReplacingExtends()) {
			Environment e = myEnvironment();
			InstModification im = findMatching(e, name());
			if (im != null)
				return im.createInstReplacingExtends(ec);
		}
		return ec.newInstExtends();
	}
	
	public InstExtends InstModification.createInstReplacingExtends(ExtendsClause ec) {
		return ec.newInstExtends();
	}
	
	public InstExtends InstClassRedeclare.createInstReplacingExtends(ExtendsClause ec) {
		for (InstExtends ie : getInstClassDecl().actualInstClass().getInstExtendss())
			return ie.createInstReplacingExtends(ec);
		return ec.newInstExtends();
	}
	
	public InstExtends InstShortClassDecl.createInstReplacingExtends(ExtendsClause ec) {
		for (InstExtends ie : getInstExtendss())
			return ie.createInstReplacingExtends(ec);
		return ec.newInstExtends();
	}
	
	public InstExtends InstSimpleShortClassDecl.createInstReplacingExtends(ExtendsClause ec) {
		return actualInstClass().createInstReplacingExtends(ec);
	}
	
	public InstExtends InstNode.createInstReplacingExtends(ExtendsClause ec) {
		return ec.newInstExtends();
	}
	
	public InstExtends InstExtendsShortClass.createInstReplacingExtends(ExtendsClause ec) {
		return ec.newInstReplacingExtends(this);
	}
	
	eq InstNamedModification.matches(String str) = name().equals(str);
	
	inh boolean InstNode.isInInstModification();
	eq InstModification.getChild().isInInstModification() = true;
	eq InstRoot.getChild().isInInstModification()         = false;
	eq Root.getChild().isInInstModification()             = false;

	syn boolean ExtendsClause.needsReplacingExtends()  = false;
	eq ExtendsClauseShortClass.needsReplacingExtends() = true;
	
		// Dispatch w.r.t. class type
	public abstract InstComponentDecl InstClassDecl.newInstComponentDecl(ComponentDecl cd);
	public InstComponentDecl InstBaseClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return newInstComponentDecl(cd,cd.getClassName());		
	}
	
	
	public InstComponentDecl InstPrimitiveClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return newInstComponentDecl(cd,cd.getClassName());
	}
	public InstComponentDecl InstBuiltInClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return newInstComponentDecl(cd,cd.getClassName());
	}
		
	public abstract InstComponentDecl InstClassDecl.newInstComponentDecl(ComponentDecl cd, Access className);

	public InstComponentDecl InstBaseClassDecl.newInstComponentDecl(ComponentDecl cd, Access className) {
		InstComponentDecl icd = emptyInstComponentDecl(cd, className.newInstAccess());
		if (cd.hasVarArraySubscripts()) 
			icd.setLocalFArraySubscripts(cd.getVarArraySubscripts().instantiate());
		if (cd.hasConditionalAttribute())
			icd.setConditionalAttribute(cd.getConditionalAttribute().getExp().instantiate());
		if (cd.hasModification())
			icd.setInstModification(cd.getModification().newInstModification());
		icd.setInstConstrainingOpt(cd.newInstConstrainingComponentOpt());
		icd.setLocation(cd);
		return icd;
	}

	public InstComponentDecl InstSimpleShortClassDecl.newInstComponentDecl(ComponentDecl cd, Access className) {
		return actualInstClass().newInstComponentDecl(cd, className);
	}
	
	public InstComponentDecl InstBaseClassDecl.emptyInstComponentDecl(ComponentDecl cd, InstAccess name) {
		if (isRecord()) 
			return new InstRecord(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
		else if (extendsEnum()) 
			return new InstEnum(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
		else if (isExternalObject())
			return new InstExternalObject(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
		else if (extendsPrimitive()) 
			return new InstPrimitive(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
		else if (isExpandableConnector())
		    return new InstExpandableConnectorDecl(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
        else if (isPartialFunction())
            return new InstPartialFunction(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
		else
			return new InstComposite(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
	}
	
	public InstComponentDecl InstPrimitiveClassDecl.emptyInstComponentDecl(ComponentDecl cd, InstAccess name) {
		return new InstPrimitive(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
	}
	
	public InstComponentDecl InstEnumClassDecl.emptyInstComponentDecl(ComponentDecl cd, InstAccess name) {
		return new InstEnum(name, new Opt(), cd, new Opt(), new Opt(), new Opt());
	}
	
	public InstComponentDecl InstBuiltInClassDecl.newInstComponentDecl(ComponentDecl cd, Access className) {
		if (cd.isEnumLiteral()) 
			return new InstEnumLiteral(className.newInstAccess(), new Opt(), cd, new Opt(), new Opt(), new Opt());	
		else 
			return new InstBuiltIn(className.newInstAccess(), new Opt(), cd, new Opt(), new Opt(), new Opt());
	}
	
	public InstComponentDecl InstClassDecl.newInstConstrainingComponentDecl(ComponentDecl cd, Access className) {
		// TODO: Does this really use the correct modifiers, etc?
		InstComponentDecl icd = newInstComponentDecl(cd, className);
		icd.setInstConstrainingOpt(new Opt());
		return icd;
	}

	public abstract InstComponentDecl InstClassDecl.newInstReplacingComponent(
			ComponentDecl replacingDecl, ComponentDecl originalDecl, InstComponentRedeclare icr);

    public InstComponentDecl InstBaseClassDecl.newInstReplacingComponent(
            ComponentDecl replacingDecl, ComponentDecl originalDecl, InstComponentRedeclare icr) {
        Opt fas_opt = new Opt();
        if (replacingDecl.hasVarArraySubscripts()) 
            fas_opt.setChild(replacingDecl.getVarArraySubscripts().instantiate(), 0);
        Opt cond_attr_opt = new Opt();
        if (originalDecl.hasConditionalAttribute()) 
            cond_attr_opt.setChild(originalDecl.getConditionalAttribute().getExp().instantiate(), 0);
        
        if (isOrExtendsPrimitive()) {
            InstReplacingPrimitive icd = new InstReplacingPrimitive(replacingDecl.newInstClassAccess(), 
                    fas_opt, replacingDecl, new Opt(), new Opt(), cond_attr_opt, originalDecl, icr);
            icd.setInstConstrainingOpt(originalDecl.newInstConstrainingComponentOpt());
            icd.setLocation(originalDecl);
            return icd;
        } else if (isRecord()) {
            InstReplacingRecord icd = new InstReplacingRecord(replacingDecl.newInstClassAccess(), 
                    fas_opt, replacingDecl, new Opt(), new Opt(), cond_attr_opt, originalDecl, icr);
            icd.setInstConstrainingOpt(originalDecl.newInstConstrainingComponentOpt());
            icd.setLocation(originalDecl);
            return icd;
        } else {
            InstReplacingComposite icd;
            if (isExpandableConnector())
                icd = new InstReplacingExpandableConnectorDecl(replacingDecl.newInstClassAccess(), 
                        fas_opt, replacingDecl, new Opt(), new Opt(), cond_attr_opt, originalDecl, icr);
            else
                icd = new InstReplacingComposite(replacingDecl.newInstClassAccess(), 
                        fas_opt, replacingDecl, new Opt(), new Opt(), cond_attr_opt, originalDecl, icr);
            icd.setInstConstrainingOpt(originalDecl.newInstConstrainingComponentOpt());
            icd.setLocation(originalDecl);
            return icd;
        }
    }

	// This cannot be done.
	public InstComponentDecl InstBuiltInClassDecl.newInstReplacingComponent(
			ComponentDecl replacingDecl, ComponentDecl originalDecl, InstComponentRedeclare icr) {
		throw new UnsupportedOperationException();
	}

    public InstClassDecl ClassDecl.newInstClassDecl() {
        return new UnknownInstClassDecl();
    }
    
    public Opt<InstExternal> FullClassDecl.newInstExternalOpt() {
    	return hasExternalClause() ? new Opt(getExternalClause().instantiate()) : new Opt();
    }

    public InstFullClassDecl FullClassDecl.newInstClassDecl() {
    	InstFullClassDecl fcd = new InstFullClassDecl(this, new Opt(), newInstRestriction(), newInstExternalOpt());
	    fcd.setInstConstrainingOpt(newInstConstrainingClassOpt());
    	fcd.setLocation(this);
    	return fcd;
    }

    public InstExtendClassDecl ExtendClassDecl.newInstClassDecl() {
    	// TODO: Shouldn't extending class decl be able to have an external clause?
    	InstExtendClassDecl ecd = new InstExtendClassDecl(this, new Opt(), newInstRestriction(), new Opt());
	    ecd.setInstConstrainingOpt(newInstConstrainingClassOpt());
    	ecd.setLocation(this);
    	return ecd;
    }

    public InstShortClassDecl ShortClassDecl.newInstClassDecl() {
		Opt fas_opt = new Opt();
		if (getExtendsClauseShortClass().hasArraySubscripts()) {
			fas_opt.setChild(getExtendsClauseShortClass().getArraySubscripts().instantiate(),0);
		}
    	InstShortClassDecl scd =  new InstShortClassDecl(this, new Opt(), 
    			newInstRestriction(),fas_opt);
	    scd.setInstConstrainingOpt(newInstConstrainingClassOpt());    	
    	scd.setLocation(this);
    	return scd;
    }

    public InstPrimitiveClassDecl PrimitiveClassDecl.newInstClassDecl() {
    	return new InstPrimitiveClassDecl(this, new Opt(), newInstRestriction(), newInstExternalOpt());
    }

    public InstBuiltInClassDecl BuiltInClassDecl.newInstClassDecl() {
    	return new InstBuiltInClassDecl(this);
    }

    public InstEnumClassDecl EnumClassDecl.newInstClassDecl() {
    	InstEnumClassDecl ecd = new InstEnumClassDecl(this, new Opt(), newInstRestriction(), newInstExternalOpt());
    	ecd.setLocation(this);
    	return ecd;
    }
    
    public BadInstClassDecl BadClassDecl.newInstClassDecl() {
        BadInstClassDecl ecd = new BadInstClassDecl(this, new Opt<InstConstraining>(), new InstMClass(), new Opt<InstExternal>());
        return ecd;
    }
  
    public InstClassDecl ClassDecl.newInstReplacingClass(ClassDecl replacingClass, InstRedeclareClassNode icr) {
    	return replacingClass.createInstReplacingClass(this, icr);
    }    
    
    public InstClassDecl PrimitiveClassDecl.newInstReplacingClass(ClassDecl replacingClass, InstRedeclareClassNode icr) {
    	InstRestriction ir = newInstRestriction();
    	Opt<InstExternal> exto = newInstExternalOpt();  // TODO: shouldn't ir & exto come from replacing class
        return new InstReplacingPrimitiveClassDecl(replacingClass, new Opt(), ir, exto, this, icr);
    }
    
    public InstClassDecl ClassDecl.createInstReplacingClass(ClassDecl replacedClass, InstRedeclareClassNode icr) {
    	return null;
    }
    
    public InstClassDecl FullClassDecl.createInstReplacingClass(ClassDecl replacedClass, InstRedeclareClassNode icr) {
    	InstRestriction ir = newInstRestriction();
    	Opt<InstExternal> exto = newInstExternalOpt();
    	InstReplacingFullClassDecl fcd = new InstReplacingFullClassDecl(this, new Opt(), ir, exto, replacedClass, icr);
	    fcd.setInstConstrainingOpt(newInstConstrainingClassOpt()); 
	    //TODO: Should be constr clause of original or redeclared? 
	    // - Should be from redeclared if it has one.
    	fcd.setLocation(this);
    	return fcd;
    }
    
    public InstClassDecl ShortClassDecl.createInstReplacingClass(ClassDecl replacedClass, InstRedeclareClassNode icr) {
		Opt fas_opt = new Opt();
		if (getExtendsClauseShortClass().hasArraySubscripts()) 
			fas_opt.setChild(getExtendsClauseShortClass().getArraySubscripts().instantiate(), 0);
    	InstRestriction ir = newInstRestriction();
      	InstReplacingShortClassDecl scd =  new InstReplacingShortClassDecl(this, new Opt(), ir, fas_opt, replacedClass, icr);
	    scd.setInstConstrainingOpt(newInstConstrainingClassOpt());    	
    	scd.setLocation(this);
    	return scd;
     }
    
    // Create InstRestriction
    public InstRestriction BaseClassDecl.newInstRestriction() {
    	return getRestriction().newInstRestriction();
    }
    
    public abstract InstRestriction Restriction.newInstRestriction();
    public InstModel               Model.newInstRestriction()               { return new InstModel(); }
    public InstBlock               Block.newInstRestriction()               { return new InstBlock(); }
    public InstMClass              MClass.newInstRestriction()              { return new InstMClass(); }
    public InstConnector           Connector.newInstRestriction()           { return new InstConnector(); }
    public InstExpandableConnector ExpandableConnector.newInstRestriction() { return new InstExpandableConnector(); }
    public InstMType               MType.newInstRestriction()               { return new InstMType(); }
    public InstMPackage            MPackage.newInstRestriction()            { return new InstMPackage(); }
    public InstFunction            Function.newInstRestriction()            { return new InstFunction(); }
    public InstMRecord             Record.newInstRestriction()              { return new InstMRecord(); }
    public InstOperator            Operator.newInstRestriction()            { return new InstOperator(); }
    public InstOperatorFunction    OperatorFunction.newInstRestriction()    { return new InstOperatorFunction(); }
    public InstOperatorRecord      OperatorRecord.newInstRestriction()      { return new InstOperatorRecord(); }

    /**
     * A connector class inheriting a record class is both connector and record, 
     * this method finds any inherited restriction that should be kept.
     */
    syn InstRestriction InstRestriction.inheritedRestriction()       = null;
    eq InstMRecord.inheritedRestriction()                            = this;
    eq InstOperatorRecord.inheritedRestriction()                     = this;
    inh lazy InstRestriction InstConnector.inheritedRestriction();
    eq InstBaseClassDecl.getInstRestriction().inheritedRestriction() = inheritedRestriction(false);
    
    /**
     * A connector class inheriting a record class is both connector and record, 
     * this method finds any inherited restriction that should be kept.
     */
    syn InstRestriction InstClassDecl.inheritedRestriction(boolean checkMine) = null;
    eq InstSimpleShortClassDecl.inheritedRestriction(boolean checkMine)       = 
        actualInstClass().inheritedRestriction(true);
    eq InstBaseClassDecl.inheritedRestriction(boolean checkMine) {
        if (checkMine)
            return getInstRestriction().inheritedRestriction();
        for (InstExtends ie : getInstExtendss()) {
            InstRestriction ir = ie.myInstClass().inheritedRestriction(true);
            if (ir != null)
                return ir;
        }
        return null;
    }

    // Build an InstExtends
	public InstExtends ExtendsClause.newInstExtends() {
		InstNormalExtends ie = newEmptyInstExtends();
		ie.setClassName(getSuper().newInstAccess());
		ie.setExtendsClause(this);
		if (hasClassModification())
			ie.setInstClassModification(getClassModification().newInstModification());
		ie.setLocation(this);
		return ie;
	}
	
	public InstExtends ExtendsClause.newInstReplacingExtends(InstExtendsShortClass iesc) {
		InstReplacingExtendsShortClass ie = new InstReplacingExtendsShortClass();
		ie.setClassName(getSuper().newInstAccess());
		ie.setExtendsClause(this);
		ie.setInstExtendsShortClass(iesc);
		ie.setLocation(this);
		return ie;
	}
	
	public InstNormalExtends ExtendsClause.newEmptyInstExtends() {
		return new InstNormalExtends();
	}
	
	public InstNormalExtends ExtendsClauseShortClass.newEmptyInstExtends() {
		return new InstExtendsShortClass();
	}
	
	public InstNormalExtends InlineExtendsClause.newEmptyInstExtends() {
		return new InstInlineExtends();
	}

	public InstAccess ComponentDecl.newInstClassAccess() {
		return getClassName().newInstAccess();
	}
	
	public abstract InstAccess Access.newInstAccess();
	
	public InstAccess ArrayAccess.newInstAccess() {
		InstAccess ia;
		if (hasArraySubscripts() && getArraySubscripts().getNumSubscript()>0) {
			ia = new InstParseArrayAccess(getID(), getArraySubscripts().instantiate());
		} else {
			ia = new InstParseAccess(getID());
		}
		ia.setLocation(this);
		return ia;
	}

	public InstAccess NamedAccess.newInstAccess() {
		InstAccess ia =  new InstParseAccess(getID());
		ia.setLocation(this);
		return ia;
	}

	public InstAccess Dot.newInstAccess() {
		List<InstAccess> l = new List<InstAccess>();
		for (Access a : getAccesss())
			l.add(a.newInstAccess());
		InstDot ia = new InstDot(l);
		ia.setLocation(this);
		return ia;
	}

	public InstAccess PN_Dot.newInstAccess() {
		throw new UnsupportedOperationException();
	}

	public InstAccess GlobalAccess.newInstAccess() {
		InstAccess ia = new InstGlobalAccess(getAccess().newInstAccess());
		ia.setLocation(this);
		return ia;
	}

	syn boolean InstExtends.hasInstClassModification()           = false;
	eq InstReplacingExtendsShortClass.hasInstClassModification() = getInstExtendsShortClass().hasInstClassModification();
	
	syn InstClassModification InstExtends.getInstClassModification() = null;
	eq InstReplacingExtendsShortClass.getInstClassModification()     = getInstExtendsShortClass().getInstClassModification();

	syn lazy InstProgramRoot Program.getInstProgramRoot() {
		return new InstProgramRoot(this, new Opt());
	}

	syn lazy InstClassDecl InstClassRedeclare.getInstClassDecl() {
		return getClassRedeclare().getBaseClassDecl().newInstClassDecl();
	}

	syn lazy InstComponentDecl InstComponentRedeclare.getInstComponentDecl() =
		new InstCreateComponentDecl(getComponentRedeclare().getComponentDecl(), null);

	syn lazy InstComponentDecl InstReplacingRecord.getOriginalInstComponent() =
    	new InstCreateComponentDecl(getOriginalDecl(), null);

    syn lazy InstComponentDecl InstReplacingComposite.getOriginalInstComponent() =
        new InstCreateComponentDecl(getOriginalDecl(), null);

    syn lazy InstComponentDecl InstReplacingPrimitive.getOriginalInstComponent() =
        new InstCreateComponentDecl(getOriginalDecl(), null);


	syn lazy InstClassDecl InstReplacingShortClassDecl.getOriginalInstClass() =
		getOriginalClassDecl().newInstClassDecl();

	syn lazy InstClassDecl InstReplacingSimpleShortClassDecl.getOriginalInstClass() =
		getOriginalClassDecl().newInstClassDecl();

	syn lazy InstClassDecl InstReplacingFullClassDecl.getOriginalInstClass() =
		getOriginalClassDecl().newInstClassDecl();

	/**
	 * Returns the FExp associated with this argument, if any.
	 */
	public FExp InstFunctionArgument.getFExp() { return null; }

	/**
	 * Returns the FExp associated with this argument, if any, without triggering rewrites.
	 */
	public FExp InstFunctionArgument.getFExpNoTransform() { return null; }

	public FExp InstDefaultArgument.getFExpNoTransform() { return getFExp(); }
	
	syn lazy FFunctionCallStmt InstExternalObject.getDestructorCall() {
		InstAccess name = getClassName().copyAndAppend("destructor");
		List<InstFunctionArgument> args = new List<InstFunctionArgument>();
		args.add(new InstPositionalArgument(0, createUseExp()));
		InstFunctionCall ifc = new InstFunctionCall(name, args);
		ifc.generated = true;
		FFunctionCallStmt stmt = new FFunctionCallStmt(new List(), ifc);
		return stmt;
	}

	
	private boolean InstShortClassDecl.simpleRewriteDone = false;
	
	rewrite InstShortClassDecl {
		when (!simpleRewriteDone) to InstAbstractShortClassDecl {
			simpleRewriteDone = true;
			if (shouldBeExpanded())
				return this;
			InstSimpleShortClassDecl res = createInstSimpleShortClassDecl();
			res.setLocation(this);
			return res;
		}	
	}
	
	public InstSimpleShortClassDecl InstShortClassDecl.createInstSimpleShortClassDecl() {
		return new InstSimpleShortClassDecl(getClassDecl(), getInstConstrainingOpt(), getInstRestriction());
	}
	
	public InstReplacingSimpleShortClassDecl InstReplacingShortClassDecl.createInstSimpleShortClassDecl() {
		return new InstReplacingSimpleShortClassDecl(getClassDecl(), getInstConstrainingOpt(), 
				getInstRestriction(), getOriginalClassDecl(), getInstClassRedeclare());
	}
	
	syn boolean InstShortClassDecl.shouldBeExpanded() = 
		hasFArraySubscripts() || 
		hasInstClassModification() || 
		getClassDecl().hasTypePrefix() || 
		(hasInstConstraining() && getInstConstraining().hasInstClassModification()) || 
		!filteredEnvironment().isEmpty();
	
	syn boolean ClassDecl.hasTypePrefix() = false;
	eq ShortClassDecl.hasTypePrefix()     = getExtendsClauseShortClass().hasTypePrefix();
	
	syn boolean ExtendsClauseShortClass.hasTypePrefix() = 
		hasTypePrefixFlow() || hasTypePrefixVariability() || hasTypePrefixInputOutput();
	
	syn lazy InstAccess InstSimpleShortClassDecl.getTarget() = 
		getBaseClassDecl().superClasses().iterator().next().getSuper().newInstAccess();
	
	public List<InstComponentDecl> InstSimpleShortClassDecl.getInstComponentDeclList() {
		throw new UnsupportedOperationException();
	}
	
	public List<InstClassDecl> InstSimpleShortClassDecl.getInstClassDeclList() {
		throw new UnsupportedOperationException();
	}
	
	public List<InstExtends> InstSimpleShortClassDecl.getInstExtendsList() {
		throw new UnsupportedOperationException();
	}
	
	public List<InstImport> InstSimpleShortClassDecl.getInstImportList() {
		throw new UnsupportedOperationException();
	}
	
	public List<InstClassDecl> InstSimpleShortClassDecl.getRedeclaredInstClassDeclList() {
		throw new UnsupportedOperationException();
	}

}

aspect ExpandableConnectorMembers {
    
    private List<InstComponentDecl> InstExpandableConnectorDecl.expandedMembers          = null;
    private List<InstComponentDecl> InstReplacingExpandableConnectorDecl.expandedMembers = null;
    private List<InstComponentDecl> InstArrayExpandableConnector.expandedMembers         = null;
    
    eq InstExpandableConnectorDecl.getInstComponentDeclList()          = 
        (expandedMembers != null) ? expandedMembers : super.getInstComponentDeclList();
    eq InstReplacingExpandableConnectorDecl.getInstComponentDeclList() = 
        (expandedMembers != null) ? expandedMembers : super.getInstComponentDeclList();
    eq InstArrayExpandableConnector.getInstComponentDeclList()         = 
        (expandedMembers != null) ? expandedMembers : super.getInstComponentDeclList();
    
    eq InstExpandableConnectorDecl.getInstExtendsList()          = 
        (expandedMembers != null) ? new List<InstExtends>() : super.getInstExtendsList();
    eq InstReplacingExpandableConnectorDecl.getInstExtendsList() = 
        (expandedMembers != null) ? new List<InstExtends>() : super.getInstExtendsList();
    eq InstArrayExpandableConnector.getInstExtendsList()         = 
        (expandedMembers != null) ? new List<InstExtends>() : super.getInstExtendsList();
    
    public InstComponentDecl InstExpandableConnectorDecl.createInstArrayComponentDecl(int i) {
        return new InstArrayExpandableConnector(new InstClassAccess("ArrayDecl"), new Opt(), 
                getComponentDecl(), new Opt(), new Opt(), new Opt(), i);
    }
    public InstComponentDecl InstReplacingExpandableConnectorDecl.createInstArrayComponentDecl(int i) {
        return new InstArrayExpandableConnector(new InstClassAccess("ArrayDecl"), new Opt(), 
                getComponentDecl(), new Opt(), new Opt(), new Opt(), i);
    }
    public InstComponentDecl InstArrayExpandableConnector.createInstArrayComponentDecl(int i) {
        return new InstArrayExpandableConnector(new InstClassAccess("ArrayDecl"), new Opt(), 
                getComponentDecl(), new Opt(), new Opt(), new Opt(), i);
    }
    
    public InstExpandableConnectorMember.InstExpandableConnectorMember(InstComponentDecl org, Opt<FArraySubscripts> subscripts, String name) {
        this(null, subscripts, org.getComponentDecl(), new Opt(), new Opt(), new Opt(), org, name);
    }
    
    syn boolean InstComponentDecl.isExpandableConnectorMember()    = false;
    eq InstExpandableConnectorMember.isExpandableConnectorMember() = true;
    
    eq InstExpandableConnectorMember.getInstComponentDeclList()       = getCopyOf().getInstComponentDeclList().fullCopy();
    eq InstExpandableConnectorMember.getInstClassDeclList()           = getCopyOf().getInstClassDeclList().fullCopy();
    eq InstExpandableConnectorMember.getInstExtendsList()             = getCopyOf().getInstExtendsList().fullCopy();
    eq InstExpandableConnectorMember.getInstImportList()              = getCopyOf().getInstImportList().fullCopy();
    eq InstExpandableConnectorMember.getRedeclaredInstClassDeclList() = getCopyOf().getRedeclaredInstClassDeclList().fullCopy();
    eq InstExpandableConnectorMember.getFAbstractEquationList()       = getCopyOf().getFAbstractEquationList().fullCopy();
    
    eq InstExpandableConnectorMember.name() = getName();
    
    eq InstExpandableConnectorMember.myInstClass()        = getCopyOf().myInstClass();
    eq InstExpandableConnectorMember.defaultVariability() = getCopyOf().defaultVariability();
    
    eq InstExpandableConnectorMember.isAssignable() = getCopyOf().isAssignable();
    
    eq InstExpandableConnectorMember.myFSubscripts() {
        // Only use local subscripts - they include entire size
        java.util.List<FSubscript> l = new ArrayList<FSubscript>();
        if (hasLocalFArraySubscripts())
            getLocalFArraySubscripts().getFSubscripts().addAllTo(l);
        return l;
    }
    
    public void InstExpandableConnectorMember.flattenUsedFuncsAndEnums(FClass fc) {
        getCopyOf().flattenUsedFuncsAndEnums(fc);
    }
    
}

aspect InstaceConstrainingClauses {

	public Opt ComponentDecl.newInstConstrainingComponentOpt() {
		if (hasConstrainingClause()) {
	    	Opt opt = getConstrainingClause().hasClassModification()? new Opt(getConstrainingClause().getClassModification().newInstModification()) : new Opt();
			return new Opt(new InstConstrainingComponent(getConstrainingClause().getAccess().newInstAccess(),opt,this));
		} else {
			return new Opt();
		}
	}

	public Opt BaseClassDecl.newInstConstrainingClassOpt() {
		if (hasConstrainingClause()) {
	    	Opt opt = getConstrainingClause().hasClassModification()? new Opt(getConstrainingClause().getClassModification().newInstModification()) : new Opt();
			return new Opt(new InstConstrainingClass(getConstrainingClause().getAccess().newInstAccess(),opt,this));
		} else {
			return new Opt();
		}
	}
	
    syn lazy ConstrainingClause InstConstraining.getConstrainingClause();
    eq InstConstrainingComponent.getConstrainingClause() = getComponentDecl().getConstrainingClause();
    eq InstConstrainingClass.getConstrainingClause() = getBaseClassDecl().getConstrainingClause();

    syn lazy InstBaseNode InstConstraining.getInstNode();
    eq InstConstrainingComponent.getInstNode() =
        getClassName().myInstClassDecl().newInstConstrainingComponentDecl(getComponentDecl(), getConstrainingClause().getAccess());
    eq InstConstrainingClass.getInstNode() {
        ClassDecl classToExpand = getClassName().myInstClassDecl().getClassDecl();
        return classToExpand.newInstClassDecl();
    }

	syn lazy FExp InstValueModification.getFExp() = 
		getValueModification().getExp().instantiate();
	eq InstRecordModification.getFExp() = getValue().unboundCopy();
	eq InstArrayModification.getFExp()  = getCell().unboundCopy();
	
	public List InstNode.buildFAbstractEquationList() { 
	    List l = new List();
	    for (AbstractEquation e : equations()) {
	    	l.add(e.instantiate());
	    }
	    for (Algorithm a : algorithms()) {
	    	l.add(a.instantiate());
	    }
	    for (FAlgorithm a : fAlgorithms()) {
	        l.add(a.fullCopy());
	    }
	    return l;
	}
	
	public List InstArrayComponentDecl.buildFAbstractEquationList() {
		return instComponentDecl().buildFAbstractEquationList();
	}
	
	syn lazy List InstNode.getFAbstractEquationList() = 
		buildFAbstractEquationList();
	eq InstComponentDecl.getFAbstractEquationList() = 
		isArrayParent() ? new List() : buildFAbstractEquationList();

	// TODO: Change behaviour of isArrayDecl to this instead?
	syn boolean InstComponentDecl.isArrayParent() = 
		getNumInstComponentDecl() > 0 && getInstComponentDecl(0).isArrayChild();

	syn boolean InstComponentDecl.isArrayChild() = false;
	eq InstArrayComponentDecl.isArrayChild()     = true;
}

aspect InstImportClauses {


    syn List InstNode.getInstImportList() {
    	List l = new List();
    	for (ImportClause ic : imports()) {
    		InstImport iic = ic.newInstImport();
    		iic.setLocation(ic);
    		l.add(iic);
    	}
    	return l;
    }


	public abstract InstImport ImportClause.newInstImport(); 
	public InstImport ImportClauseQualified.newInstImport() {
		return new InstImportQualified(getPackageName().newInstAccess(),this);
	}
	public InstImport ImportClauseUnqualified.newInstImport() {
		return new InstImportUnqualified(getPackageName().newInstAccess(),this);
	}
	public InstImport ImportClauseRename.newInstImport() {
		return new InstImportRename(getPackageName().newInstAccess(),this);
	}
	

} 

aspect InstanceAST_API {
	syn boolean InstNode.nameScope() = false;
	eq InstComponentDecl.nameScope() = true;
	eq InstArrayComponentDecl.nameScope() = false;
    eq InstBaseClassDecl.nameScope() = true;
    
    syn String InstNode.name() = "";
    eq InstComponentDecl.name() = getComponentDecl().name();
    eq InstBaseClassDecl.name() = getBaseClassDecl().name();
    eq InstBuiltInClassDecl.name() = getBuiltInClassDecl().name();
    eq InstExtends.name() = getClassName().name();
	syn BaseClassDecl InstBaseClassDecl.getBaseClassDecl() = (BaseClassDecl)getClassDecl();
	syn BuiltInClassDecl InstBuiltInClassDecl.getBuiltInClassDecl() = (BuiltInClassDecl)getClassDecl();

    syn String InstNode.qualifiedName();
    syn lazy String InstClassDecl.qualifiedName();
    eq InstComponentDecl.qualifiedName()    = getFQName().name();
    eq InstExtends.qualifiedName()          = myInstClass().qualifiedName();
    eq InstBaseClassDecl.qualifiedName()    = getInstRestriction().qualifiedClassName();
    eq InstBuiltInClassDecl.qualifiedName() = name();
    eq InstProgramRoot.qualifiedName()      = "";

    syn String InstRestriction.qualifiedClassName() = myInstClassDecl().buildQualifiedName();
    eq InstOperator.qualifiedClassName()            = myInstClassDecl().buildQualifiedOperatorName();
    eq InstOperatorFunction.qualifiedClassName()    = myInstClassDecl().buildQualifiedOperatorName();

    syn String InstNode.buildQualifiedName() = combineName(instClassNamePrefix(false), name());

    syn String InstClassDecl.buildQualifiedOperatorName() = combineName(instClassNamePrefix(true), name());

    inh String InstNode.instClassNamePrefix(boolean sup);
    eq InstExtends.getChild().instClassNamePrefix(boolean sup)       = sup ? qualifiedName() : instClassNamePrefix(sup);
    eq InstBaseClassDecl.getChild().instClassNamePrefix(boolean sup) = qualifiedName();
    eq InstComponentDecl.getChild().instClassNamePrefix(boolean sup) = buildQualifiedName();
    eq Root.getChild().instClassNamePrefix(boolean sup)              = "";
    eq InstRoot.getChild().instClassNamePrefix(boolean sup)          = "";

    /**
     * Get the qualified class name of the oldest ancestor in the inheritance structure.
     * 
     * For classes inheriting multiple classes, only the first one is considered.
     * This is useful mostly for classes that only allows inheriting from one other class.
     */
    syn String InstNode.baseClassName()                  = 
        (getNumInstExtends() > 0) ? getInstExtends(0).baseClassName() : qualifiedName();
    eq InstComponentDecl.baseClassName()                 = myInstClass().baseClassName();
    eq InstSimpleShortClassDecl.baseClassName()          = actualInstClass().baseClassName();
    eq InstReplacingSimpleShortClassDecl.baseClassName() = actualInstClass().baseClassName();


	syn Iterable<AbstractEquation> InstNode.equations() = Collections.<AbstractEquation>emptyList();
	eq InstComponentDecl.equations()                    = myInstClass().equations();
	eq InstExtends.equations()                          = myInstClass().equations();
	eq InstFullClassDecl.equations()                    = getBaseClassDecl().equations();	
	
	syn Iterable<Algorithm> InstNode.algorithms() = Collections.<Algorithm>emptyList();
	eq InstComponentDecl.algorithms()             = myInstClass().algorithms();
	eq InstExtends.algorithms()                   = myInstClass().algorithms();
	eq InstFullClassDecl.algorithms()             = getBaseClassDecl().algorithms();	
	
    syn Iterable<FAlgorithm> InstNode.fAlgorithms() = Collections.<FAlgorithm>emptyList();
    eq InstComponentDecl.fAlgorithms()              = myInstClass().fAlgorithms();
    eq InstExtends.fAlgorithms()                    = myInstClass().fAlgorithms();
    eq InstFullClassDecl.fAlgorithms() {
        InstExternal ie = getInstExternal();
        if (ie != null) {
            ArrayList<FAlgorithm> l = new ArrayList<FAlgorithm>();
            l.add(ie.getFAlgorithm());
            return l;
        } else {
            return super.fAlgorithms();
        }
    }
    
	syn Iterable<ComponentDecl> InstNode.components() = Collections.<ComponentDecl>emptyList();
	eq InstComponentDecl.components()                 = myInstClass().components();
	eq InstArrayComponentDecl.components()            = instComponentDecl().components();
	eq InstExtends.components()                       = 
	    extendsPrimitive() ? Collections.<ComponentDecl>emptyList() : myInstClass().components();
	eq InstBaseClassDecl.components()                 = getBaseClassDecl().components();
	
	syn Iterable<ExtendsClause> InstNode.superClasses() = Collections.<ExtendsClause>emptyList();
	eq InstComponentDecl.superClasses()                 = myInstClass().superClasses();
	eq InstArrayComponentDecl.superClasses()            = instComponentDecl().superClasses();
	eq InstExtends.superClasses()                       = myInstClass().superClasses();
    eq InstBaseClassDecl.superClasses()                 = getBaseClassDecl().superClasses();

	syn Iterable<ClassDecl> InstNode.classes() = Collections.<ClassDecl>emptyList();
	eq InstProgramRoot.classes()               = getProgram().classes();
	eq InstComponentDecl.classes()             = myInstClass().classes();
	eq InstArrayComponentDecl.classes()        = instComponentDecl().classes();
	eq InstBaseClassDecl.classes()             = getBaseClassDecl().classes();
	eq InstExtends.classes()                   = myInstClass().classes();

	syn Iterable<ImportClause> InstNode.imports() = Collections.<ImportClause>emptyList();
	eq InstComponentDecl.imports()                = myInstClass().imports();
	eq InstBaseClassDecl.imports()                = getBaseClassDecl().imports();
	eq InstExtends.imports()                      = myInstClass().imports();
	
	syn Iterable<Modification> InstNode.elementModifications() = Collections.<Modification>emptyList();
    eq InstComponentDecl.elementModifications()                = myInstClass().elementModifications();
    eq InstExtends.elementModifications()                      = myInstClass().elementModifications();
    eq InstBaseClassDecl.elementModifications()                = getBaseClassDecl().elementModifications();
	
	inh InstEnumClassDecl InstEnumLiteral.myInstEnumClassDecl();
	eq InstEnumClassDecl.getInstComponentDecl().myInstEnumClassDecl() = this;
	eq InstNode.getChild().myInstEnumClassDecl()                      = null;
	eq FlatRoot.getChild().myInstEnumClassDecl()                      = null;
	
	inh int InstEnumLiteral.myIndex();
	eq InstEnumClassDecl.getInstComponentDecl(int i).myIndex() = 
		enumLiterals().indexOf(getInstComponentDecl(i)) + 1;
	eq InstNode.getChild().myIndex()                           = 0;
	eq FlatRoot.getChild().myIndex()                           = 0;

	syn ArrayList<InstEnumLiteral> InstClassDecl.enumLiterals() =
		extendsEnum() ? getInstExtends(0).myInstClass().enumLiterals() : new ArrayList<InstEnumLiteral>();
	eq InstSimpleShortClassDecl.enumLiterals()                  = actualInstClass().enumLiterals();
	syn lazy ArrayList<InstEnumLiteral> InstEnumClassDecl.enumLiterals() {
		ArrayList<InstEnumLiteral> l = new ArrayList<InstEnumLiteral>();
		for (InstComponentDecl icd : getInstComponentDecls()) {
			if (icd.isEnumLiteral()) {
				l.add((InstEnumLiteral)icd);
			}
		}
		return l;
	}

	syn lazy ArrayList<InstClassDecl> InstNode.instClassDecls() {
		ArrayList<InstClassDecl> l = new ArrayList<InstClassDecl>();	
		for (InstClassDecl n : getInstClassDecls())
			l.add(n);	
		return l;
	}

	syn lazy ArrayList<InstComponentDecl> InstNode.instComponentDecls() {
		ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();	
		for (InstComponentDecl n : getInstComponentDecls())
			l.add(n);	
		return l;
	}

	syn lazy ArrayList<InstExtends> InstNode.instExtends() {
		ArrayList<InstExtends> l = new ArrayList<InstExtends>();	
		for (InstExtends n : getInstExtendss())
			l.add(n);	
		return l;
	}

	syn lazy ArrayList<InstImport> InstNode.instImports() {
		ArrayList<InstImport> l = new ArrayList<InstImport>();	
		for (InstImport n : getInstImports())
			l.add(n);	
		return l;
	}


    // Overridden in InstComponentDecl and InstBaseClassDecl by generated API for optional child
    syn boolean InstNode.hasInstConstraining() = false;
    syn InstConstraining InstNode.getInstConstraining() = null;

    /**
     * Is this declaration redeclared?
     */
    syn boolean InstNode.isRedeclared()                 = false;
    eq InstReplacingFullClassDecl.isRedeclared()        = true;
    eq InstReplacingShortClassDecl.isRedeclared()       = true;
    eq InstReplacingSimpleShortClassDecl.isRedeclared() = true;
    eq InstReplacingComposite.isRedeclared()            = true;
    eq InstReplacingRecord.isRedeclared()               = true;
    eq InstReplacingPrimitive.isRedeclared()            = true;

    /**
     * Is this declaration replaceable?
     */
    syn boolean InstNode.isReplaceable() = false;
    eq InstClassDecl.isReplaceable()     = getClassDecl().hasReplaceable();
    eq InstComponentDecl.isReplaceable() = getComponentDecl().hasReplaceable();

    /**
     * Is this declaration affected by a constraining type?
     */
    syn boolean InstNode.isConstrained() = isReplaceable() || isRedeclared();

    // Overridden in BaseClassDecl by generated API for optional child
    syn boolean ClassDecl.hasReplaceable() = false;

    syn boolean InstNode.extendsPrimitive()        = false;
    eq InstShortClassDecl.extendsPrimitive()       = getNumInstExtends() == 1 && getInstExtends(0).extendsPrimitive();
    eq InstFullClassDecl.extendsPrimitive()        = getNumInstExtends() == 1 && getInstExtends(0).extendsPrimitive();
    eq InstSimpleShortClassDecl.extendsPrimitive() = actualInstClass().isOrExtendsPrimitive();
    eq InstExtends.extendsPrimitive() {
        InstClassDecl icd = myInstClass();
        return !isRecursive() && icd.isOrExtendsPrimitive();
    }

	/**
	 * Check if this node is a class declaration or an extends in one.
	 */
	syn boolean InstNode.isClassDecl() = false;
	eq InstClassDecl.isClassDecl()     = true;
	eq InstExtends.isClassDecl()       = isInClassDecl();
    
    /**
     * Check if this node is an extends.
     */
    syn boolean InstNode.isExtends() = false;
    eq InstExtends.isExtends()     = true;

    /**
     * Check if this extends is part of a class declaration.
     */
    inh boolean InstExtends.isInClassDecl();
    eq InstClassDecl.getChild().isInClassDecl() = true;
    eq InstBaseNode.getChild().isInClassDecl()  = false;
    eq Root.getChild().isInClassDecl()          = false;
    
    /**
     * Check if this node is a component declaration or an extends in one.
     */
    syn boolean InstNode.isComponentDecl() = false;
    eq InstComponentDecl.isComponentDecl() = true;
    eq InstExtends.isComponentDecl()       = isInComponentDecl();
    
    /**
     * Check if this extends is part of a component declaration.
     */
    inh boolean InstExtends.isInComponentDecl();
    eq InstComponentDecl.getChild().isInComponentDecl() = true;
    eq InstBaseNode.getChild().isInComponentDecl()      = false;
    eq Root.getChild().isInComponentDecl()              = false;
	
	/**
	 * Check if this node is, is of, or extends a primitive type.
	 */
	syn boolean InstNode.isOrExtendsPrimitive() = isPrimitive() || extendsPrimitive();
	
	/**
	 * Check if this class is or extends an enumeration.
	 */
	syn boolean InstNode.extendsEnum()        = false;
	eq InstClassDecl.extendsEnum()            = getNumInstExtends() == 1 && getInstExtends(0).extendsEnum();
	eq InstSimpleShortClassDecl.extendsEnum() = actualInstClass().extendsEnum();
	eq InstEnumClassDecl.extendsEnum()        = true;
	eq InstExtends.extendsEnum()              = !isRecursive() && myInstClass().extendsEnum();
	
	syn InstClassDecl InstClassDecl.getBaseInstClass() = 
		(getNumInstExtends() > 0) ? getInstExtends(0).getBaseInstClass() : this;
	syn InstClassDecl InstExtends.getBaseInstClass()   = 
		myInstClass().getBaseInstClass();
	
	inh boolean InstNode.enclosedBy(InstNode node);
	eq InstNode.getChild().enclosedBy(InstNode node) = (node == this) || enclosedBy(node);
	eq InstRoot.getChild().enclosedBy(InstNode node) = (node == this);
    eq Root.getChild().enclosedBy(InstNode node)     = false;
    
    syn InstNode InstNode.commonAncestor(InstNode node) {
        HashSet<InstNode> theirs = new HashSet<InstNode>(node.instAncestors());
        for (InstNode mine : instAncestors())
            if (theirs.contains(mine))
                return mine;
        return null;
    }
    
    syn java.util.List<InstNode> InstNode.instAncestors() {
        ArrayList<InstNode> list = new ArrayList<InstNode>();
        InstNode cur = this;
        while (cur != null) {
            list.add(cur);
            cur = cur.instNodeParent();
        }
        return list;
    }

    inh InstNode InstNode.instNodeParent();
    eq InstNode.getChild().instNodeParent() = this;
    eq Root.getChild().instNodeParent()     = null;
    
	/**
	 * Find the component that this access should be evaluated in.
	 */
	inh InstComponentDecl InstAccess.containingInstComponent();
	inh InstComponentDecl InstNode.containingInstComponent();
	eq InstComponentDecl.getLocalFArraySubscripts().containingInstComponent() = 
		containingInstComponent();
	eq InstComponentDecl.getFArraySubscripts().containingInstComponent()      = 
		containingInstComponent();
	eq InstComponentDecl.getChild().containingInstComponent() = this;
	eq InstClassDecl.getChild().containingInstComponent()     = null;
	eq InstRoot.getChild().containingInstComponent()          = null;
	eq Root.getChild().containingInstComponent()              = null;

	
	/**
	 * Iterate over all components in this node and all InstExtends (recursively).
	 * 
	 * @return  an Iterable over the components
	 */
	public Iterable<InstComponentDecl> InstNode.allInstComponentDecls() {
		return new Iterable<InstComponentDecl>() {
			public Iterator<InstComponentDecl> iterator() {
				return allInstComponentDeclsIterator();
			}
		};
	}
	
	protected Iterator<InstComponentDecl> InstNode.allInstComponentDeclsIterator() {
		return new InstComponentIterator();
	}
	
	protected Iterator<InstComponentDecl> InstSimpleShortClassDecl.allInstComponentDeclsIterator() {
		return actualInstClass().allInstComponentDeclsIterator();
	}

    /**
     * Iterate over all classes in this node and all InstExtends (recursively).
     * 
     * @return  an Iterable over the classes
     */
    public Iterable<InstClassDecl> InstNode.allInstClassDecls() {
        return new Iterable<InstClassDecl>() {
            public Iterator<InstClassDecl> iterator() {
                return allInstClassDeclsIterator();
            }
        };
    }
    
    protected Iterator<InstClassDecl> InstNode.allInstClassDeclsIterator() {
        return new InstClassIterator();
    }
    
    protected Iterator<InstClassDecl> InstSimpleShortClassDecl.allInstClassDeclsIterator() {
        return actualInstClass().allInstClassDeclsIterator();
    }

	public class InstNode {
		
		private class InstComponentIterator implements Iterator<InstComponentDecl> {
			
			private Iterator<InstComponentDecl> current;
			private Iterator<InstExtends> exts;
            private Iterator<InstComponentDecl> last;
			
			public InstComponentIterator() {
				exts = getInstExtendss().iterator();
                last = getInstComponentDecls().iterator();
                if (exts.hasNext()) {
                    current = exts.next().allInstComponentDeclsIterator();
                } else {
                    current = last;
                }
				update();
			}
			
			public boolean hasNext() {
				return current.hasNext();
			}

			public InstComponentDecl next() {
				InstComponentDecl res = current.next();
				update();
				return res;
			}

			public void remove() {
				throw new UnsupportedOperationException();
			}
			
			private void update() {
				while (!current.hasNext() && exts.hasNext()) {
					current = exts.next().allInstComponentDeclsIterator();
				}
                if (!current.hasNext()) {
                    current = last;
                }
			}
			
		}

        private class InstClassIterator implements Iterator<InstClassDecl> {

            private Iterator<InstClassDecl> current;
            private Iterator<InstExtends> exts;
            private Iterator<InstClassDecl> last;

            public InstClassIterator() {
                exts = getInstExtendss().iterator();
                last = getInstClassDecls().iterator();
                if (exts.hasNext()) {
                    current = exts.next().allInstClassDeclsIterator();
                } else {
                    current = last;
                }
                update();
            }

            public boolean hasNext() {
                return current.hasNext();
            }

            public InstClassDecl next() {
                InstClassDecl res = current.next();
                update();
                return res;
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }

            private void update() {
                while (!current.hasNext() && exts.hasNext()) {
                    current = exts.next().allInstClassDeclsIterator();
                }
                if (!current.hasNext()) {
                    current = last;
                }
            }
            
        }

    }

    inh InstNode InstNode.containingInstNode();
    inh InstNode FExp.containingInstNode();
    eq InstNode.getChild().containingInstNode() = this;
    eq InstRoot.getChild().containingInstNode() = null;
    eq Root.getChild().containingInstNode()     = null;
    
    inh InstNode FExternalStmt.containingInstClassDecl();
    eq Root.getChild().containingInstClassDecl()          = null;
    eq InstClassDecl.getChild().containingInstClassDecl() = this;

}

aspect SourceAST_API {

	syn Iterable<AbstractEquation> ClassDecl.equations() = Collections.<AbstractEquation>emptyList();
	eq FullClassDecl.equations()                         = getEquations();

	syn Iterable<Algorithm> ClassDecl.algorithms() = Collections.<Algorithm>emptyList();
	eq FullClassDecl.algorithms()                  = getAlgorithms();
	
	syn Iterable<ExtendsClause> ClassDecl.superClasses() = Collections.<ExtendsClause>emptyList();
	eq FullClassDecl.superClasses()                      = getSupers();
	eq ShortClassDecl.superClasses()                     = 
	    Collections.<ExtendsClause>singletonList(getExtendsClauseShortClass());
	
	syn Iterable<ComponentDecl> ClassDecl.components() = Collections.<ComponentDecl>emptyList();
	eq FullClassDecl.components()                      = getComponentDecls();
    
    syn Iterable<Modification> BaseClassDecl.elementModifications() = Collections.<Modification>emptyList();
    eq FullClassDecl.elementModifications()                         = getElementModifications();

    public class ASTNode {
        protected static final Criteria<ASTNode> NOT_ERROR_NODE_CRITERIA = new Criteria<ASTNode>() {
            public boolean test(ASTNode elem) {
                return !elem.isError();
            }
        };
    
        public static <N extends ASTNode> Iterable<N> filterErrorNodes(final Iterable<N> parent) {
            return new Iterable<N>() {
                public Iterator<N> iterator() {
                    return new FilteredIterator<N>(parent.iterator(), NOT_ERROR_NODE_CRITERIA);
                }
            };
        }
    }

	syn Iterable<ClassDecl> ClassDecl.classes() = Collections.<ClassDecl>emptyList();
	eq FullClassDecl.classes()                  = filterErrorNodes(getClassDecls());
	syn lazy Iterable<ClassDecl> LibClassDecl.classes() {
		// Imposes ordering specified in LibClassDecl.order
		Map<String,ClassDecl> map = new LinkedHashMap<String,ClassDecl>();
		for (ClassDecl cd : super.classes())
			map.put(cd.name(), cd);
		for (LibNode ln : getLibNodes()) {
		    for (Element e : ln.getStoredDefinition().getElements()) {
		    	ClassDecl cd = (ClassDecl) e;
                if (!cd.isError())
                    map.put(cd.name(), cd);
			}
		}
		
		ArrayList<ClassDecl> l = new ArrayList<ClassDecl>();
		for (String name : order) {
			ClassDecl cd = map.get(name);
			if (cd != null) {
				l.add(cd);
				map.remove(name);
			}
		}
		for (ClassDecl cd : map.values())
			l.add(cd);

		return l;
	}
    syn Iterable<ClassDecl> Program.classes() {
    	ArrayList<ClassDecl> l = new ArrayList<ClassDecl>();
        for (StoredDefinition sd : getUnstructuredEntitys()) 
            for (Element e : sd.getElements()) 
                if (!e.isError())
                    l.add((ClassDecl) e);
    	// Libraries are loaded when needed in instance lookup instead
    	return l;
    } 

	syn Iterable<ImportClause> ClassDecl.imports() = Collections.<ImportClause>emptyList();
	eq FullClassDecl.imports()                     = getImports();

}

aspect InstArrays {
	
	/**
	 * Find the number of the dimension corresponding to this InstArrayComponentDecl.
	 */
	inh int InstArrayComponentDecl.myDimension();
	eq InstNode.getChild().myDimension()               = 0;
	eq InstArrayComponentDecl.getChild().myDimension() = myDimension() + 1;
	
	/**
	 * Efficiently check if this InstArrayComponentDecl is in the top dimension of the array.
	 */
	inh boolean InstArrayComponentDecl.isTopDimension();
	eq InstNode.getChild().isTopDimension()               = true;
	eq InstArrayComponentDecl.getChild().isTopDimension() = false;
	
	/**
	 * Find the length of the dimension corresponding to this InstArrayComponentDecl.
	 */
	syn int InstComponentDecl.myDimensionLength() = size().get(0);
	eq InstArrayComponentDecl.myDimensionLength() = dimensionLength(0);
	
	/**
	 * Find the length of the dimension corresponding to the level under 
	 *        this InstArrayComponentDecl. 
	 */
	syn int InstArrayComponentDecl.childDimensionLength() = dimensionLength(1);
	
	/**
	 * Find the length of the dimension corresponding to the InstArrayComponentDecl(s)
	 *        <code>i</code> levels under this one. 
	 */
	inh int InstArrayComponentDecl.dimensionLength(int i);
	eq InstArrayComponentDecl.getInstComponentDecl().dimensionLength(int i) = dimensionLength(i + 1);
	eq InstComponentDecl.getInstComponentDecl().dimensionLength(int i)      = size().get(i);
	eq InstRoot.getChild().dimensionLength(int i)                           = Size.UNKNOWN;
	eq FlatRoot.getChild().dimensionLength(int i)                           = Size.UNKNOWN;

    /**
     * Get an Index to my cell.
     * 
     * Only valid for bottom level in array.
     */
    syn Index InstArrayComponentDecl.myIndex() {
        Index i = parentIndex();
        i.set(myDimension(), getIndex());
        return i;
    }

    /**
     * Calculate Index of parent.
     * 
     * For internal use only - returns an incomplete Index. See {@link #myIndex()}.
     */
    inh Index InstArrayComponentDecl.parentIndex();
    eq InstNode.getChild().parentIndex()               = null;
    eq InstComponentDecl.getChild().parentIndex()      = new Index(new int[ndims()]);
    eq InstArrayComponentDecl.getChild().parentIndex() = myIndex();

    /**
     * The top level component for the array.
     */
    inh InstComponentDecl InstArrayComponentDecl.instComponentDecl();
    eq InstArrayComponentDecl.getChild().instComponentDecl() = instComponentDecl();
    eq InstComponentDecl.getChild().instComponentDecl()      = this;
    eq InstRoot.getChild().instComponentDecl()               = null;

	syn boolean InstComponentDecl.isArrayDecl() = hasFArraySubscripts() && 
		getFArraySubscripts().getNumFSubscript()>0;
	
    syn java.util.List<FSubscript> InstNode.myFSubscripts() = Collections.emptyList();
    eq InstSimpleShortClassDecl.myFSubscripts()             = actualInstClass().myFSubscripts();
    eq InstFullClassDecl.myFSubscripts()                    = 
        (getNumInstExtends() == 1) ? getInstExtends(0).myFSubscripts() : super.myFSubscripts();
    eq InstExtends.myFSubscripts()                          = 
		isRecursive() ? Collections.<FSubscript>emptyList() : myInstClass().myFSubscripts();
	syn lazy java.util.List<FSubscript> InstShortClassDecl.myFSubscripts() {
		java.util.List<FSubscript> l = new ArrayList<FSubscript>();
		if (hasFArraySubscripts()) 
			getFArraySubscripts().getFSubscripts().addAllTo(l);
		if (getNumInstExtends() == 1)
			l.addAll(getInstExtends(0).myFSubscripts());
		return l;
	}
	syn lazy java.util.List<FSubscript> InstComponentDecl.myFSubscripts() {
		java.util.List<FSubscript> l = new ArrayList<FSubscript>();
		addLocalFArraySubscriptsTo(l);
		l.addAll(myInstClass().myFSubscripts());
		return l;
	}
	
	public void InstComponentDecl.addLocalFArraySubscriptsTo(java.util.List<FSubscript> l) {
        if (hasLocalFArraySubscripts())
            getLocalFArraySubscripts().getFSubscripts().addAllTo(l);
        else
            addFSubscriptsFromOriginalDeclTo(l);
	}
	
    public void InstComponentDecl.addFSubscriptsFromOriginalDeclTo(java.util.List<FSubscript> l) {}
    public void InstReplacingComposite.addFSubscriptsFromOriginalDeclTo(java.util.List<FSubscript> l) {
        getOriginalInstComponent().addLocalFArraySubscriptsTo(l);
    }
    public void InstReplacingRecord.addFSubscriptsFromOriginalDeclTo(java.util.List<FSubscript> l) {
        getOriginalInstComponent().addLocalFArraySubscriptsTo(l);
    }
    public void InstReplacingPrimitive.addFSubscriptsFromOriginalDeclTo(java.util.List<FSubscript> l) {
        getOriginalInstComponent().addLocalFArraySubscriptsTo(l);
    }

	/**
	 * This is the definition of an NTA that collects both the local
	 * array subscripts given a component declaration and array subscripts
	 * given on the declaration's class (in the case of short
	 * class declarations).
	 */
	syn lazy FArraySubscripts InstComponentDecl.getFArraySubscripts() {
	    if (myFSubscripts().isEmpty())
	        return null;
		FArraySubscripts fas = new FArraySubscripts();
		for (FSubscript fs : myFSubscripts()) 
			fas.addFSubscript(fs.deferredCopy());
		return fas;
	}
	
	syn boolean InstComponentDecl.hasFArraySubscripts() = getFArraySubscripts()!=null;
	
}

aspect DeferredSubscripts {

    public FSubscript FSubscript.deferredCopy() {
        return fullCopy();
    }

    public FSubscript FExpSubscript.deferredCopy() {
        return copyLocationTo(new FDeferExpSubscript(getFExp().fullCopy(), this));
    }

    inh InstLookupResult<InstComponentDecl> FExpSubscript.lookupInstComponent(String name);
    eq FDeferExpSubscript.getFExp().lookupInstComponent(String name) = getDefer().lookupInstComponent(name);

}

aspect InstanceDumpTree {

	// Some basic dump routines
	public void InstNode.dumpTree(String indent) {
		System.out.println(indent + dump());
		System.out.println(toString(indent+"|"));
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

	}
	
	public void InstBaseClassDecl.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getBaseClassDecl().name());
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

	}


	
	public void InstExtends.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getExtendsClause().getSuper().name());
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

		}
	
	public void InstComposite.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      myInstClass().name() + " "+
		                      getComponentDecl().name());
        getClassName().dumpTree(indent + "|");
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

	}
	
	public void InstAssignable.dumpTree(String indent) {
		System.out.println(indent + dump()
							  + ": " + 
		                      myInstClass().name() + " "+
		                      getComponentDecl().name());
	    getClassName().dumpTree(indent + "|");
		System.out.println(toString(indent+"|"));

		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");


	}
	
//	public String InstNamedAccess.toString() {
//		String s = dump() +": "+name() + " at line: " + beginLine();
//        s+="\n";
//		return s;
//	}

	
// 	public String InstNode.toString() {
//		return toString("");
//    }
	public String InstNode.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent + "InstNode:\n");
	   str.append(prettyPrint(indent + " "));
	   appendEnvironment(str, indent);

	   return str.toString();	
	}
	
	protected void InstNode.appendEnvironment(StringBuilder str, String indent) {
		String next = indent + " ";
		str.append(indent);
		str.append(" myEnvironment():\n");
		str.append(myEnvironment().toString(next));
		str.append(indent);
		str.append(" myEnvironment('");
		str.append(name());
		str.append("'):\n");
		str.append(myEnvironment(name()).toString(next));
		str.append(indent);
		str.append(" mergedEnvironment():\n");
		str.append(getMergedEnvironment().toString(next));
	}
    
	public String InstComponentDecl.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstComponent:\n");
	   str.append(indent+" Original decl:  " + getComponentDecl().prettyPrint("") + "\n");
       str.append(indent+ " "+ getClassName().toString());
	   appendEnvironment(str, indent);
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   return str.toString();	
	}
    
	public String InstArrayComponentDecl.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+" InstArrayComponent ("+ getIndex() + "):\n");
	   str.append(indent+" Original decl:  " + getComponentDecl().prettyPrint("") + "\n");
       str.append(indent+ " "+ getClassName().toString());
	   appendEnvironment(str, indent);
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   return str.toString();	
	}
	
	public String InstReplacingRecord.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstReplacingRecord:\n");
	   str.append(indent+" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
       str.append(indent+ " "+getClassName().toString());
	   appendEnvironment(str, indent);
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   return str.toString();	
	}
	
	public String InstReplacingComposite.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstReplacingComposite:\n");
	   str.append(indent+" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
       str.append(indent+ " "+getClassName().toString());
	   appendEnvironment(str, indent);
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   return str.toString();	
	}

	public String InstRecord.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstRecord:\n");
	   str.append(indent+" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
       str.append(indent+ " " +getClassName().toString());	   
	   appendEnvironment(str, indent);
	   return str.toString();	
	}

	public String InstPrimitive.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstPrimitive:\n");
	   str.append(indent+" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
       str.append(indent+ " " +getClassName().toString());	   
	   appendEnvironment(str, indent);
	   return str.toString();	
	}

	public String InstExtends.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstExtendsDecl:\n");
	   str.append(indent+" Extends clause: " + getExtendsClause().getSuper().name() + "\n");
       str.append(indent+ " "+ getClassName().toString());
	   appendEnvironment(str, indent);
	   //str.append(indent+" Declared type:\n");
	   //str.append(indent+declaredType().toString());
	   
	   return str.toString();	
	}

	public String InstFullClassDecl.toString(String indent) {
	   StringBuilder str = new StringBuilder();
	   str.append(indent+"InstFullClassDecl:\n");
	   str.append(indent+" Class decl: " + getBaseClassDecl().name() + "\n");
	   appendEnvironment(str, indent);
	   //str.append(indent+" Declared type:\n");
	   //str.append(indent+declaredType().toString());
	   
	   return str.toString();	
	}

//	public String InstFullClassDecl.toString() {
//		return toString("");
//    }
//
//
//
//	public String InstModification.toString() {
//		return toString("");
//    }
    public String InstModification.toString(String indent) {
    	return getModification().prettyPrint(indent);
    
    }
    
    
    public String InstClassDecl.toString() {
    	return getClassDecl().toString();
    }
    
    public String InstExternal.toString() {
    	return getExternalClause().toString();
    }
    
    public String InstComponentDecl.toString() {
    	return getComponentDecl().toString();
    }
    
    public String InstExtends.toString() {
    	return getExtendsClause().toString();
    }
    
    public String InstModification.toString() {
    	return getModification().toString();
    }
	
}

/* TODO: If we are doing this, we should do it properly
aspect InstancePrettyPrint {

	public String InstNode.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent + str.substring(str.lastIndexOf('.')+1);
		return str;

	}

	public String InstBaseClassDecl.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + name();
		return str;

	}

	public String InstShortClassDecl.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getInstExtends(0).getClassName().name() + " "+ name();
		return str;
	}

	public String InstExtendsShortClass.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getClassName().name();
		return str;
		
	}

	public String InstExtends.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getClassName().name();
		return str;
		
	}

	public String InstComponentDecl.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getClassName().name() + " "+
		                      getComponentDecl().name();
		return str;

	}

	public String InstArrayComponentDecl.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getIndex();
		return str;

	}
	
	public String InstImport.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str += ": " + getPackageName().name();
		return str;
	}

	public String InstAccess.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str += ": " + name();
		return str;
	}

	
}
*/