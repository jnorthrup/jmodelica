/*
    Copyright (C) 2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.Set;
import java.util.HashSet;
import java.util.Collections;

aspect InstVariability {
    
    syn lazy TypePrefixVariability InstComponentDecl.definedVariability() {
        ComponentDecl cd = getComponentDecl();
        TypePrefixVariability var = cd.hasTypePrefixVariability() ? 
                cd.getTypePrefixVariability() : continuous();
        return overrideVariability(var);
    }

    inh TypePrefixVariability InstNode.overrideVariability(TypePrefixVariability var);
    eq InstBaseNode.getChild().overrideVariability(TypePrefixVariability var)  = var;
    eq Root.getChild().overrideVariability(TypePrefixVariability var)          = var;
    eq InstPrimitive.getChild().overrideVariability(TypePrefixVariability var) = var;
    eq InstComponentDecl.getInstComponentDecl().overrideVariability(TypePrefixVariability var) =
            var.combineDown(definedVariability());
    eq InstComponentDecl.getInstExtends().overrideVariability(TypePrefixVariability var) =
            var.combineDown(definedVariability());

    /* Using combinedVariability() for constant & parameter to avoid circular dependency.
     * It can only differ from variability() when combinedVariability() gives continuous. */
    syn boolean InstComponentDecl.isConstant()   = combinedVariability().constantVariability();
    syn boolean InstComponentDecl.isParameter()  = combinedVariability().parameterVariability();
    syn boolean InstComponentDecl.isDiscrete()   = variability().discreteVariability();
    syn boolean InstComponentDecl.isContinuous() = variability().continuousVariability();

    syn FTypePrefixVariability InstComponentDecl.combinedVariability() = 
        definedVariability().flatten().combineDown(defaultVariability());

    // This is used before errorcheck so we have to guard from circular parameter binding exps
    private boolean InstAssignable.circularVariability = false;
    eq InstAssignable.combinedVariability() {
        FTypePrefixVariability v = super.combinedVariability();
        if (v.parameterVariability()) {
            if (circularVariability)
                return v;
            circularVariability = true;
            if (annotation().forPath("Evaluate").bool() && valueIsFixed()) {
                v = fEvalParameter();
            } else if (isStructuralParam) {
                v = fStructParameter();
            } else if (hasBindingFExp() && !isExternalObject()) {
                FTypePrefixVariability expVariability = getBindingFExp().variability();
                if (expVariability.structParameterVariability() || expVariability.evalParameterVariability())
                    v = fStructParameter();
            }
            circularVariability = false;
        }
        return v;
    }

    syn lazy FTypePrefixVariability InstComponentDecl.variability() = combinedVariability();
    eq InstEnumLiteral.variability()                                = fConstant();
    eq UnknownInstComponentDecl.variability()                       = fConstant();

    syn FTypePrefixVariability InstComponentDecl.defaultVariability() = fContinuous();
    eq InstArrayComponentDecl.defaultVariability()                    = parentVariability();
    eq InstPrimitive.defaultVariability() {
        if (isReal())
            return fContinuous();
        else if (isExternalObject())
            return fParameter();
        else
            return fDiscrete();
    }
    eq InstRecord.defaultVariability() {
        InstComponentDecl rec = this;
        for (int i = 0; i < ndims(); i++) {
            if (rec.getNumInstComponentDecl() == 0)
                return fContinuous();
            rec = rec.getInstComponentDecl(0);
        }
        FTypePrefixVariability var = fConstant();
        for (InstComponentDecl icd : rec.allInstComponentDecls()) 
            var = var.combine(icd.variability());
        return var;
    }

    /**
     * The variability of the surrounding component, if any (null otherwise).
     */
    inh FTypePrefixVariability InstComponentDecl.parentVariability();
    eq InstComponentDecl.getChild().parentVariability() = variability();
    eq InstClassDecl.getChild().parentVariability()     = null;
    eq Root.getChild().parentVariability()              = null;

    protected static Set<InstComponentDecl> FAbstractEquation.assignedSetFromEqns(List<FAbstractEquation> eqns) {
        Set<InstComponentDecl> res = new HashSet<InstComponentDecl>();
        for (FAbstractEquation eqn : eqns)
            res.addAll(eqn.assignedSet());
        return res;
    }

    /**
     * Gives the set of components assigned in this equation.
     * 
     * Only works in instance tree.
     * For if and when equations, only the first branch is considered.
     */
    syn lazy Set<InstComponentDecl> FAbstractEquation.assignedSet() = Collections.emptySet();
    eq InstForClauseE.assignedSet()      = assignedSetFromEqns(getFAbstractEquations());
    eq FIfWhenElseEquation.assignedSet() = assignedSetFromEqns(getFAbstractEquations());
    eq FEquation.assignedSet()           = getLeft().accessedVarSet();
    eq FFunctionCallEquation.assignedSet() {
        LinkedHashSet<InstComponentDecl> s = new LinkedHashSet<InstComponentDecl>();
        for (FFunctionCallLeft left : getLefts()) {
            if (left.hasFExp()) {
                s.addAll(left.getFExp().accessedVarSet());
            }
        }
        return s;
    }

    /**
     * If this is an instance tree access, return set containing accessed var, otherwise empty set.
     */
    syn Set<InstComponentDecl> FExp.accessedVarSet() = Collections.emptySet();
    eq FInstAccessExp.accessedVarSet()               = getInstAccess().accessedVarSet();
    eq FIdUseExp.accessedVarSet()                    = getFIdUse().accessedVarSet();

    /**
     * If this is an instance tree access, return set containing accessed var, otherwise empty set.
     */
    syn Set<InstComponentDecl> FIdUse.accessedVarSet() = Collections.emptySet();
    eq FIdUseInstAccess.accessedVarSet()               = getInstAccess().accessedVarSet();

    /**
     * Get set containing accessed var.
     */
    syn Set<InstComponentDecl> InstAccess.accessedVarSet() = 
        Collections.singleton(myInstComponentDecl());


    eq FIdUseInstAccess.variability() = getInstAccess().myInstComponentDecl().variability();

}


aspect SourceVariability {

    syn boolean TypePrefixVariability.constantVariability() = false;
    eq Constant.constantVariability() = true;   
    syn boolean TypePrefixVariability.parameterVariability() = false;
    eq Parameter.parameterVariability() = true; 
    syn boolean TypePrefixVariability.discreteVariability() = false;
    eq Discrete.discreteVariability() = true;   
    syn boolean TypePrefixVariability.continuousVariability() = false;
    eq Continuous.continuousVariability() = true;


    /**
     * An ordering of the variability types.
     * 
     * To be used by methods for comparing variabilities. 
     * Should <em>never</em> be compared to literals, only to the return value from other 
     * FTypePrefixVariability objects. This simplifies adding new variabilities.
     *  
     * Also used to determine the behaviour of {@link #combine(TypePrefixVariability)}.
     */
    abstract protected int TypePrefixVariability.variabilityLevel();
    protected int Constant.variabilityLevel()   { return VARIABILITY_LEVEL; }
    protected int Parameter.variabilityLevel()  { return VARIABILITY_LEVEL; }
    protected int Discrete.variabilityLevel()   { return VARIABILITY_LEVEL; }
    protected int Continuous.variabilityLevel() { return VARIABILITY_LEVEL; }
    protected static final int Constant.VARIABILITY_LEVEL   = 0;
    protected static final int Parameter.VARIABILITY_LEVEL  = 10;
    protected static final int Discrete.VARIABILITY_LEVEL   = 20;
    protected static final int Continuous.VARIABILITY_LEVEL = 30;

    syn int TypePrefixVariability.combineLevel() = variabilityLevel() * 10;

    public TypePrefixVariability TypePrefixVariability.combine(TypePrefixVariability other) {
        return (other.combineLevel() > combineLevel()) ? other : this;
    }

    public TypePrefixVariability TypePrefixVariability.combineDown(TypePrefixVariability other) {
        return (other.combineLevel() < combineLevel()) ? other : this;
    }


    public static final Continuous Continuous.instance = new Continuous();
    public static final Discrete   Discrete.instance   = new Discrete();
    public static final Parameter  Parameter.instance  = new Parameter();
    public static final Constant   Constant.instance   = new Constant();

    public static Continuous ASTNode.continuous() {
        return Continuous.instance;
    }

    public static Discrete ASTNode.discrete() {
        return Discrete.instance;
    }

    public static Parameter ASTNode.parameter() {
        return Parameter.instance;
    }

    public static Constant ASTNode.constant() {
        return Constant.instance;
    }

}
