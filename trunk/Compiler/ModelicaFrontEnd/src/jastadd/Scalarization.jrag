/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;

aspect Scalarization {

	/**
	 * \brief Flag indicating if a variable is scalarized.
	 */
	boolean FQName.scalarized = false;
	
	syn boolean FVariable.isScalarized() = getFQName().isScalarized();
	syn boolean FQName.isScalarized() = scalarized;
	
	/**
	 * \brief Scalarize all variables and equations in the flat model.
	 */
	public void FClass.scalarize() {
		List<FVariable> vars = new List<FVariable>();
		List<FVariable> alias_vars = new List<FVariable>();
		//log.debug("FClass.scalarize(): l1 " + vars + " l2 " + alias_vars);
		// Scalarize all non-alias variables
		for (FVariable fv : getFVariables()) {
			fv.scalarize(vars);
		}
		// Scalarize alias variables
		for (FVariable fv : getAliasVariables()) {
			fv.scalarize(alias_vars);
		}
		
		// Scalarize equations
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFEquationBlock(0).getFAbstractEquations()) {
			ae.scalarize(eqns, vars, new HashMap<String,FExp>());
		}
		getFEquationBlock(0).setFAbstractEquationList(eqns);
		List<FAbstractEquation> ieqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFInitialEquations()) {
			ae.scalarize(ieqns, vars, new HashMap<String,FExp>());
		}
		setFInitialEquationList(ieqns);

		// Replace variables
		setFVariableList(vars);
		setAliasVariableList(alias_vars);
		
		// Replace subscript expressions with literals
		eqns.makeSubscriptsLiteral();
		ieqns.makeSubscriptsLiteral();
		
		// Scalarize functions
		List<FFunctionDecl> funcs = new List<FFunctionDecl>();
		for (FFunctionDecl f : getFFunctionDecls()) 
			funcs.add(f.scalarize());
		setFFunctionDeclList(funcs);

		flush();		
	}
	
	/**
	 * \brief Replace all expressions in array subscripts with literals.
	 */
	public void ASTNode.makeSubscriptsLiteral() {
		for (ASTNode child : this)
			child.makeSubscriptsLiteral();
	}
	
	public void FExpSubscript.makeSubscriptsLiteral() {
		setFExp(getFExp().ceval().buildLiteral());
	}
	
	
	/**
	 * \brief Scalarize the FVariable and put all scalarized variables in the
	 * list vars.
	 */
	public void FVariable.scalarize(List<FVariable> vars) {
		// Constants and parameters still have binding expressions, 
		// they should be scalarized but can't contain any FForIndex 
		// (except in reduction-expressions)
		HashMap<String,FExp> constIndexMap = null;
		if (isParameter() || isConstant())
			constIndexMap = new HashMap<String,FExp>();
		if (isRecord()) {
			scalarRecordFVariables(vars, new FQName(), null);
		} else if (isArray()) {
			for (Index i : indices()) {
				// Copy original declaration
				FVariable fv_tmp = (FVariable) fullCopy();
				// Set new array subscripts corresponding to index
				fv_tmp.getFQName().setLastFArraySubscripts(i.newFArraySubscripts());
				// Constants and parameters still have binding expressions
				if (constIndexMap != null && hasBindingExp())
					fv_tmp.setBindingExp(getBindingExp().getArray().get(i).scalarize(constIndexMap));
				// Iterate over all attributes and scalarize.
				for (FAttribute a : fv_tmp.getFAttributes()) 
					a.scalarize(i);
				// Mark variable as scalarized (affects name printing etc.)
				fv_tmp.getFQName().scalarized = true;
				// Add altered copy to list
				vars.addChild(fv_tmp);
			}
		} else {
			// Duplicate FVariable even if it is not an array declaration.
			FVariable fv_tmp = (FVariable) fullCopy();
			if (constIndexMap != null && hasBindingExp())
				fv_tmp.setBindingExp(getBindingExp().scalarize(constIndexMap));
			fv_tmp.getFQName().scalarized = true;
			vars.addChild(fv_tmp);
		}
	}
	
	/**
	 * \brief Generate scalar FVariables for this record or record component.
	 * 
	 * @param vars    the list of FVariables to add the variables to
	 * @param prefix  add this as a prefix to the name
	 * @param last    an FVariable containing the attributes, variability, etc inherited from surrounding record
	 */
	public void FVariable.scalarRecordFVariables(List<FVariable> vars, FQName prefix, FVariable last) {
		FQName name = prefix.fullCopy().append(getFQName());
		if (isArray()) {
			for (Index i : indices()) {
				name.setLastFArraySubscripts(i.newFArraySubscripts());
				scalarRecordCellFVariables(vars, name, last);
			}
		} else {
			scalarRecordCellFVariables(vars, name, last);
		}
	}
	
	/**
	 * \brief Generate scalar FVariables for a single array cell of this record or record component.
	 * 
	 * @param vars  the list of FVariables to add the variables to
	 * @param name  the name of the new variable
	 * @param last  an FVariable containing the attributes, variability, etc inherited from surrounding record
	 */
	public void FVariable.scalarRecordCellFVariables(List<FVariable> vars, FQName name, FVariable last) {
		FVariable fv = (FVariable) fullCopy();
		fv.inheritFrom(last);
		fv.setFQName(name.fullCopy());
		fv.getFQName().scalarized = true;
		vars.add(fv);
	}
	
	public void FRecordVariable.scalarRecordCellFVariables(List<FVariable> vars, FQName name, FVariable last) {
		FVariable tmp = (FVariable) fullCopy();
		tmp.inheritFrom(last);
		for (FVariable comp : myFRecordDecl().getFVariables())
			comp.scalarRecordFVariables(vars, name, tmp);
	}
	
	/**
	 * \brief Inherit prefixes and attributes from the FVariable representing the surrounding record.
	 */
	public void FVariable.inheritFrom(FVariable other) {
		if (other == null)
			return;
		setFVisibilityType(other.getFVisibilityType());
		setFTypePrefixVariability(getFTypePrefixVariability().combineDown(other.getFTypePrefixVariability()));
		if (other.hasFTypePrefixInputOutput())
			setFTypePrefixInputOutput(other.getFTypePrefixInputOutput());
		String myName = getFQName().getFQNamePart(0).getName();
		for (FAttribute a : other.getFAttributes()) {
			// TODO: support attributes on single cell in array (#599)
			String attrName = a.getName().getFQName().getFQNamePart(0).getName();
			if (myName.equals(attrName)) {
				if (a.getName().getFQName().getNumFQNamePart() > 1) {
					FAttribute na = a.fullCopy();
					na.getName().setFQName(a.getName().getFQName().copySuffix());
					addFAttribute(na);
				} else {
					for (FAttribute ia : a.getFAttributes()) 
						addFAttribute(ia);
				}
			}
		}
	}
	
	/**
	 * \brief Scalarize the attribute, picking out the specific element from an array 
	 *        expression or removing "each".
	 */
	public void FAttribute.scalarize(Index i) {
		if (getAttributeSet()) {
			if (hasFEach())
				setFEachOpt(new Opt());
			else if (hasValue() && getValue().ndims() > 0) 
				setValue(getValue().getArray().get(i));
			else if (hasValue())
				setValue(getValue().scalarize(new HashMap<String,FExp>()));
		}
	}
	
	/**
	 * \brief Scalarize the function variable, scalarizing any binding expression.
	 *        Binding expressions for array variables are added to statement list 
	 *        as an assignment instead.
	 */
	public void FFunctionVariable.scalarize(
			List<FFunctionVariable> vars, List<FStatement> stmts, HashMap<String,FExp> indexMap) {
		FFunctionVariable var = (FFunctionVariable) fullCopy();
		var.setBindingExpOpt(new Opt());
		if (hasBindingExp() && !isInput())
			scalarizeBindingExp(vars, stmts, indexMap);
		vars.add(var);
	}
	
	/**
	 * \brief Scalarize the binding expression of this variable and add assignment to list of statements.
	 * 
	 * Assumes that the variable has a binding expression.
	 */
	public void FFunctionVariable.scalarizeBindingExp(
			List<FFunctionVariable> vars, List<FStatement> stmts, HashMap<String,FExp> indexMap) {
		createArrayTemporaries(stmts, vars, indexMap, true);
		if (type().isRecord()) 
			type().scalarizeRecordArrayAssignment(vars, stmts, indexMap, getFQName(), getBindingExp());
		else
			stmts.add(new FAssignStmt(new FIdUse(getFQName().fullCopy()), getBindingExp().scalarize(indexMap)));
	}
	
	public void FFunctionArray.scalarizeBindingExp(
			List<FFunctionVariable> vars, List<FStatement> stmts, HashMap<String,FExp> indexMap) {
		if (type().isRecord()) {
			type().scalarizeRecordArrayAssignment(vars, stmts, indexMap, getFQName(), getBindingExp());
		} else if (size().isUnknown()) {
			scalarizeUnknownArrayAssignment(vars, stmts, indexMap, getBindingExp());
		} else {
			createArrayTemporaries(stmts, vars, indexMap, true);
			FIdUse id = new FIdUse(new FQName(name()));
			Array arr = getBindingExp().getArray();
			for (Index i : arr.indices()) {
				FExp exp = arr.get(i).scalarize(indexMap);
				FIdUse nid = (FIdUse) id.fullCopy();
				nid.getFQName().specify(i, false);
				stmts.add(new FAssignStmt(nid, exp));
			}
		}
	}
	
	/**
	 * \brief A node that can look up variable names in the flat tree.
	 */
	public interface FlatLookupNode {
		public AbstractFVariable lookupFV(FQName fqn);
	}
	public class FFunctionVariable implements FlatLookupNode {}
	public class FExp implements FlatLookupNode {}
	
	/**
	 * \brief Creates and organizes names of for indices for generated for loops.
	 */
	public class ForNames implements Iterable<String> {
		private ArrayList<String[]> names;
		private int last;
		private int pos;
		
		/**
		 * \brief Standard constructor.
		 */
		public ForNames() {
			names = new ArrayList<String[]>();
			last = 0;
		}
		
		/**
		 * \brief Creates a new ForNames with a single layer with space for <code>n</code> names.
		 */
		public ForNames(int n) {
			this();
			addLayer(n);
		}
		
		/**
		 * \brief Add a new layer of names, that can be filled with new names or names 
		 *        from the layer underneath.
		 * 
		 * @param n  the number of names in the new layer
		 */
		public void addLayer(int n) {
			names.add(new String[n]);
			pos = 0;
		}
		
		/**
		 * \brief Fills all empty spots in the top layer with newly created names.
		 */
		public void fillLayer(FlatLookupNode context) {
			String[] top = topLayer();
			for (int i = pos; i < top.length; i++) 
				create(context);
		}
		
		/**
		 * \brief Removes the top layer, exposing the layer underneath.
		 */
		public void removeLayer() {
			names.remove(names.size() - 1);
		}

		private String[] topLayer() {
			return names.get(names.size() - 1);
		}
		
		/**
		 * \brief Gets name with index <code>i</code> in the top layer.
		 */
		public String get(int i) {
			return topLayer()[i];
		}
		
		/**
		 * \brief Adds a name to the top layer.
		 */
		public void add(String name) {
			topLayer()[pos++] = name;
		}
		
		/**
		 * \brief Creates a new name and adds it to the top layer.
		 * 
		 * @return the created name
		 */
		public String create(FlatLookupNode context) {
			FQNamePart part = new FQNamePart();
			FQName fqn = new FQName(new List().add(part));
			String name;
			do {
				name = "i" + (++last);
				part.setName(name);
			} while (!context.lookupFV(fqn).isUnknown()); 
			add(name);
			return name;
		}
		
		/**
		 * \brief Adds a name from the underlying layer to the top layer.
		 * 
		 * @param i  the index in the underlying layer
		 */
		public void promote(int i) {
			add(names.get(names.size() - 2)[i]);
		}
		
		/**
		 * \brief Return the number of names in the top layer.
		 */
		public int size() {
			return topLayer().length;
		}
		
		/**
		 * \brief Iterates over the top layer.
		 */
		public Iterator<String> iterator() {
			return Arrays.asList(topLayer()).iterator();
		}
		
		/**
		 * \brief Creates nestled for loops over a single variable, using the top layer of names.
		 *  
		 * Adds the outermost for loop to a list of statements.
		 * 
		 * @param stmts  list to add the created for statements to
		 * @param var    name of the variable to loop over
		 * @return  the list of statements of the innermost loop
		 */
		public List<FStatement> createForLoops(List<FStatement> stmts, FQName var) {
			List<FStatement> cur = stmts;
			for (int i = 0; i < topLayer().length; i++) {
				FForIndex ffi = new FForIndex(topLayer()[i], new FSizeExp(var, i));
				FForStmt fs = new FForStmt(ffi, new List());
				cur.add(fs);
				cur = fs.getForStmts();
			}
			return cur;
		}
		
		/**
		 * \brief Creates a new FArraySubscripts with uses of the names in the top layer as subscripts.
		 */
		public FArraySubscripts createFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (String name : this)
				fas.addFSubscript(new FExpSubscript(new FIdUseExp(name)));
			return fas;
		}
	}

	/**
	 * \brief Scalarize an assignment to an array of unknown size and put the resulting statements in 
	 *        the list of statements.
	 */
	public void AbstractFVariable.scalarizeUnknownArrayAssignment(List<FFunctionVariable> vars, 
			List<FStatement> stmts, HashMap<String,FExp> indexMap, FExp exp) {}

	public void FFunctionArray.scalarizeUnknownArrayAssignment(List<FFunctionVariable> vars, 
			List<FStatement> stmts, HashMap<String,FExp> indexMap, FExp exp) {
		ForNames names = new ForNames(ndims());
		names.fillLayer(this);
		HashMap<String,FExp> myIndexMap = new HashMap<String,FExp>(indexMap);
		exp.addArrayUsesToIndexMap(myIndexMap, names);
		List<FStatement> inner = names.createForLoops(stmts, getFQName());
		exp.createArrayTemporaries(inner, vars, myIndexMap, true);
		FIdUse use = createUseWithNamedSubscripts(names);
		inner.add(new FAssignStmt(use, exp.scalarize(myIndexMap)));
	}
	
	/**
	 * \brief The names of the for indices of the surrounding generated for loops, if any.
	 */
	protected ForNames FExp.indexNames = null;
	
	/**
	 * \brief Add translations of all uses of array variables to the index map. 
	 *        The translations should add array subscripts that are uses of the given names.
	 * 
	 * Any expression node that needs it's own for loop(s) should override this method, 
	 * save <code>names</code> and create it's for loop in createArrayTemporaries().
	 */
	public void ASTNode.addArrayUsesToIndexMap(HashMap<String,FExp> indexMap, ForNames names) {
		for (ASTNode n : this)
			n.addArrayUsesToIndexMap(indexMap, names);
	}
	
	public void FIdUseExp.addArrayUsesToIndexMap(HashMap<String,FExp> indexMap, ForNames names) {
		if (isArray()) {
			FIdUse use = myFV().createUseWithNamedSubscripts(names);
			indexMap.put(name(), new FIdUseExp(use));
		}
	}
	
	public void FMulExp.addArrayUsesToIndexMap(HashMap<String,FExp> indexMap, ForNames names) {
		if (isArray() && !isElementWise())
			indexNames = names;
		else
			super.addArrayUsesToIndexMap(indexMap, names);
	}
	
	public void FMulExp.createArrayTemporaries(List clauses, List vars, 
			HashMap<String,FExp> indexMap, boolean addVar) {
		if (!isElementWise() && (getLeft().size().isUnknown() || getRight().size().isUnknown())) {
			if (indexNames == null)
				indexNames = new ForNames();
			useTempVar = true;
			
			// Create temp
			FType type = (FType) type().scalarType().fullCopy();
			if (addVar) 
				vars.add(new FFunctionVariable(type, tempVarName()));
			clauses.add(new FAssignStmt(new FIdUse(tempVarName()), type.zeroLiteral()));
			
			// Set up indices for the left operand
			FExp exp = getLeft();
			indexNames.addLayer(exp.ndims());
			if (indexNames.size() > 1)
				indexNames.promote(0);
			String i = indexNames.create(this);
			HashMap<String,FExp> myIndexMap = new HashMap<String,FExp>(indexMap);
			exp.addArrayUsesToIndexMap(myIndexMap, indexNames);
			
			// Create loop
			FForStmt fs = new FForStmt(new FForIndex(i, getRight().size().createFExp(0)), new List());
			clauses.add(fs);
			List<FStatement> fsl = fs.getForStmts();
			
			// Scalarize left operand
			exp.createArrayTemporaries(fsl, vars, myIndexMap, addVar);
			FExp left = exp.scalarize(myIndexMap);
			indexNames.removeLayer();
			
			// Set up indices and scalarize the right operand
			exp = getRight();
			indexNames.addLayer(exp.ndims());
			indexNames.add(i);
			if (indexNames.size() > 1)
				indexNames.promote(ndims() - 1);
			myIndexMap = new HashMap<String,FExp>(indexMap);
			exp.addArrayUsesToIndexMap(myIndexMap, indexNames);
			exp.createArrayTemporaries(fsl, vars, myIndexMap, addVar);
			FExp right = exp.scalarize(myIndexMap);
			indexNames.removeLayer();
			
			// Add statement updating temp var to loop
			FExp mul = new FMulExp(left, right);
			FExp add = new FAddExp(new FIdUseExp(tempVarName()), mul);
			fsl.add(new FAssignStmt(new FIdUse(tempVarName()), add));
		} else {
			super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		}
	}
	
	/**
	 * \brief Create a new FIdUse of this variable with uses of <code>names</code> as array subscripts.
	 */
	public FIdUse AbstractFVariable.createUseWithNamedSubscripts(ForNames names) {
		FIdUse use = new FIdUse(name());
		use.getFQName().setLastFArraySubscripts(names.createFArraySubscripts());
		return use;
	}
	
	/**
	 * \brief Scalarize an assignment to a record and put the resulting statements in 
	 *        the list of statements. 
	 * 
	 * This method delegates to scalarizeRecordAssignment() for each cell in the array, 
	 * or for the entire scalar expression.
	 */
	public void FType.scalarizeRecordArrayAssignment(
			List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap, FQName left, FExp right) {
		if (isArray()) {
			FQName fqn = left.fullCopy();
			if (size().isUnknown()) {
				ForNames names = new ForNames(ndims());
				names.fillLayer(right);
				List<FStatement> inner = names.createForLoops(stmts, left);
				fqn.setLastFArraySubscripts(names.createFArraySubscripts());
				FExp exp = right.extractUnknownRecordArrayCell(names);
				scalarizeRecordAssignment(vars, inner, indexMap, fqn, exp);
			} else {
				for (Index i : indices()) {
					fqn.setLastFArraySubscripts(i.newFArraySubscripts());
					FExp exp = right.getArray().get(i);
					scalarizeRecordAssignment(vars, stmts, indexMap, fqn, exp);
				}
			}
		} else {
			scalarizeRecordAssignment(vars, stmts, indexMap, left, right);
		}
	}
	
	/**
	 * \brief Scalarize an assignment to a record and put the resulting statements in 
	 *        the list of statements.
	 */
	public void FType.scalarizeRecordAssignment(
			List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap, FQName left, FExp right) {
		stmts.add(new FAssignStmt(new FIdUse(left.fullCopy()), (FExp) right.fullCopy()));
	}
	
	/**
	 * \brief Scalarize an assignment to a record and put the resulting statements in 
	 *        the list of statements.
	 */
	public void FRecordType.scalarizeRecordAssignment(
			List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap, FQName left, FExp right) {
		for (FRecordComponentType comp : getComponents()) {
			FQName fqn = left.copyAndAppend(comp.getName());
			FExp exp = right.scalarRecordFExp(indexMap, new FQName(comp.getName()));
			comp.getFType().scalarizeRecordArrayAssignment(vars, stmts, indexMap, fqn, exp);
		}
	}
	
	/**
	 * \brief Create an expression describing a specific cell of an unknown array.
	 * 
	 * @param names  the names of the for indices to use as array subscripts
	 */
	public FExp FExp.extractUnknownRecordArrayCell(ForNames names) {
		return null; // TODO: Implement this for all possible subtypes (or replace with default impl)
	}
	
	public FExp FFunctionCall.extractUnknownRecordArrayCell(ForNames names) {
		FIdUseExp exp = new FIdUseExp(tempVarName());
		FQName fqn = exp.getFIdUse().getFQName();
		fqn.setLastFArraySubscripts(names.createFArraySubscripts());
		return exp;
	}
	
	public FExp FIdUseExp.extractUnknownRecordArrayCell(ForNames names) {
		FIdUseExp exp = fullCopy();
		FQName fqn = exp.getFIdUse().getFQName();
		fqn.setLastFArraySubscripts(names.createFArraySubscripts());
		return exp;
	}
	
	/**
	 * \brief Scalarize the statement and put all resulting statements in the
	 *        list of statements.
	 */
	public void FStatement.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		stmts.add((FStatement) fullCopy());
	}
	
	public void FAssignStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		FIdUse left = getLeft();
		FExp right = getRight();
		if (left.type().isRecord()) {
			right.createArrayTemporaries(stmts, vars, indexMap, true);
			left.type().scalarizeRecordArrayAssignment(vars, stmts, indexMap, left.getFQName(), right);
		} else if (right.size().isUnknown()) {
			left.myFV().scalarizeUnknownArrayAssignment(vars, stmts, indexMap, right);
		} else {
			right.createArrayTemporaries(stmts, vars, indexMap, true);
			if (left.ndims() > 0) {
				Array arr = right.getArray();
				for (Index i : arr.indices()) {
					FExp exp = arr.get(i).scalarize(indexMap);
					stmts.add(new FAssignStmt(left.specify(i, false), exp));
				}
			} else {
				FExp exp = right.scalarize(indexMap);
				stmts.add(new FAssignStmt(left.scalarize(indexMap), exp));
			}
		}
	}
	
	public void FFunctionCallStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		getCall().createArrayTemporaries(stmts, vars, indexMap, true);
		FFunctionCallStmt stmt = new FFunctionCallStmt();
		for (FFunctionCallLeft left : getLefts())
			stmt.addLeft(left.scalarize(indexMap));
		stmt.setCall((FAbstractFunctionCall) getCall().scalarizeExp(indexMap));
		stmts.add(stmt);
	}
	
	public void FIfWhenStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		for (FIfWhenClause cl : getFIfWhenClauses())
			cl.getTest().createArrayTemporaries(stmts, vars, indexMap, true);
		FIfWhenStmt stmt = createEmptyNode();
		for (FIfWhenClause cl : getFIfWhenClauses())
			stmt.addFIfWhenClause(cl.scalarize(vars, indexMap));
		scalarizeElse(vars, stmt, indexMap);
		stmts.add(stmt);
	}
	
	/**
	 * \brief Scalarize the else part of an if statement. Does nothing for when statements.
	 */
	public void FIfWhenStmt.scalarizeElse(List<FFunctionVariable> vars, FIfWhenStmt stmt, 
			HashMap<String,FExp> indexMap) {}
	
	public void FIfStmt.scalarizeElse(List<FFunctionVariable> vars, FIfWhenStmt stmt, 
			HashMap<String,FExp> indexMap) {
		FIfStmt ifstmt = (FIfStmt) stmt;
		for (FStatement es : getElseStmts())
			es.scalarize(vars, ifstmt.getElseStmtList(), indexMap);
	}
	
	/**
	 * \brief Scalarize the if or when clause.
	 */
	public FIfWhenClause FIfWhenClause.scalarize(List<FFunctionVariable> vars, HashMap<String,FExp> indexMap) {
		FExp test = getTest().reduceToScalarized(new FOrExp(), indexMap);
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : getFStatements())
			stmt.scalarize(vars, stmts, indexMap);
		return createNode(test, stmts);
	}
	
	public void FForStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		getIndex().createArrayTemporaries(stmts, vars, indexMap, true);
		FForStmt stmt = new FForStmt();
		stmt.setIndex(getIndex().scalarize(indexMap));
		for (FStatement fs : getForStmts())
			fs.scalarize(vars, stmt.getForStmtList(), indexMap);
		stmts.add(stmt);
	}
	
	public void FWhileStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		getTest().createArrayTemporaries(stmts, vars, indexMap, true);
		FWhileStmt stmt = new FWhileStmt();
		stmt.setTest(getTest().scalarize(indexMap));
		for (FStatement ws : getWhileStmts())
			ws.scalarize(vars, stmt.getWhileStmtList(), indexMap);
		getTest().createArrayTemporaries(stmt.getWhileStmtList(), null, indexMap, false);
		stmts.add(stmt);
	}
	
	/**
	 * \brief Scalarize the function, replacing all array assignments with separate scalar 
	 *        assignments and scalarize all expressions.
	 */
	public FFunctionDecl FFunctionDecl.scalarize() {
		HashMap<String,FExp> emptyIndexMap = new HashMap<String,FExp>();
		List<FFunctionVariable> vars = new List<FFunctionVariable>();
		List<FStatement> stmts = new List<FStatement>();
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.scalarize(vars, stmts, emptyIndexMap);
		for (FStatement stmt : getFAlgorithmBlock().getFStatements())
			stmt.scalarize(vars, stmts, emptyIndexMap);
		
		// During scalarization, FQNames got their scalarized flag set, we need to clear it
		vars.clearScalarized();
		stmts.clearScalarized();
		
		FQName name = (FQName) getFQName().fullCopy();
		return new FFunctionDecl(name, vars, new FAlgorithmBlock(stmts));
	}
	
	/**
	 * Clear the scalarized flag for all FQNames.
	 */
	public void ASTNode.clearScalarized() {
		for (ASTNode node : this)
			node.clearScalarized();
	}
	
	public void FQName.clearScalarized() {
		scalarized = false;
	}
	
	
	public void FAbstractEquation.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, HashMap<String,FExp> indexMap) {}
	
	/**
	 * \brief Scalarize equation and put all resulting equations in list eqns.
	 */
	public void FEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, HashMap<String,FExp> indexMap) {
		//log.debug("FEquation.scalarize() " + ndims());
		createArrayTemporaries(eqns, vars, indexMap, true);
		if (ndims()==0) {
			/*
			 * If the equation is of dimension 0, i.e, already scalar,
			 * the equations is "scalarized" into a simple equation where
			 * e.g. built in functions are replaced by elementary operations.
			 */
			createScalarFEquations(eqns, indexMap, getLeft(), getRight());
		} else if (ndims() > 0) {
			/*
			 * If the expression is an array expression, then the FExp.getArray()
			 * element is used to generate scalar equations.
			 */
			// Iterate over array elements and create scalarized equation for each
			for (Index i : indices()) 
				createScalarFEquations(eqns, indexMap, 
						getLeft().getArray().get(i), getRight().getArray().get(i));
		}
	}
	
	/**
	 * \brief Scalarize left and right expressions and create new scalar equations.
	 */
	public void FEquation.createScalarFEquations(
			List<FAbstractEquation> eqns, HashMap<String,FExp> indexMap, FExp left, FExp right) {
		if (left.inferType().isRecord()) 
			left.inferType().scalarRecordFEquations(eqns, new FQName(), indexMap, left, right);
		else
			eqns.add(new FEquation(left.scalarize(indexMap), right.scalarize(indexMap)));
	}

	// TODO: Introduce parameter object?
	/**
	 * \brief Generate scalar FEquations for this record or record component.
	 * 
	 * @param eqns      the list of FEquations to add the equation to
	 * @param suffix    add this as a suffix to the name of the uppermost record in uses
	 * @param indexMap  translations for indices in the expressions
	 * @param left      the left expression from the original equation
	 * @param right     the right expression from the original equation
	 */
	public void FType.scalarRecordFEquations(
			List<FAbstractEquation> eqns, FQName suffix, 
			HashMap<String,FExp> indexMap, FExp left, FExp right) {
		eqns.add(new FEquation(left.scalarRecordFExp(indexMap, suffix), 
				right.scalarRecordFExp(indexMap, suffix)));
	}
	
	public void FRecordType.scalarRecordFEquations(
			List<FAbstractEquation> eqns, FQName suffix, 
			HashMap<String,FExp> indexMap, FExp left, FExp right) {
		for (FRecordComponentType comp : getComponents()) {
			FQName next = suffix.copyAndAppend(comp.getName());
			comp.getFType().scalarRecordComponentFEquations(eqns, next, indexMap, left, right);
		}
	}
	
	
	/**
	 * \brief Generate scalar FEquations for this record component.
	 * 
	 * @param eqns      the list of FEquations to add the equation to
	 * @param suffix    add this as a suffix to the name of the uppermost record in uses
	 * @param indexMap  translations for indices in the expressions
	 * @param left      the left expression from the original equation
	 * @param right     the right expression from the original equation
	 */
	public void FType.scalarRecordComponentFEquations(
			List<FAbstractEquation> eqns, FQName suffix, 
			HashMap<String,FExp> indexMap, FExp left, FExp right) {
		if (isArray()) {
			for (Index i : indices()) {
				suffix.setLastFArraySubscripts(i.newFArraySubscripts());
				scalarRecordFEquations(eqns, suffix, indexMap, left, right);
			}
		} else {
			scalarRecordFEquations(eqns, suffix, indexMap, left, right);
		}
	}
	
	/**
	 * \brief Create an FExp that represents a specific scalar component of this record.
	 * 
	 * If <code>suffix</code> denotes a record expression, not a scalar, then the returned expression 
	 * might not be scalarized.
	 * 
	 * @param indexMap  translations for indices in the expressions
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.scalarRecordFExp(HashMap<String,FExp> indexMap, FQName suffix) {
		if (suffix.getNumFQNamePart() > 0)  // TODO: this can be removed later, but is here for debugging
			throw new UnsupportedOperationException(getClass().getSimpleName() + " shouldn't have record type.");
		return scalarizeExp(indexMap);
	}
	
	public FExp FIdUseExp.scalarRecordFExp(HashMap<String,FExp> indexMap, FQName suffix) {
		return scalarizeExp(indexMap).extractRecordFExp(suffix);
	}
	
	public FExp FRecordConstructor.scalarRecordFExp(HashMap<String,FExp> indexMap, FQName suffix) {
		if (suffix.getNumFQNamePart() == 0)
			return this; // Not scalarized, see javadoc comment.
		FQNamePart first = suffix.getFQNamePart(0);
		FExp arg = getArg(getRecord().myFRecordDecl().indexOf(first.getName()));
		if (first.hasFArraySubscripts())
			arg = arg.getArray().get(first.getFArraySubscripts().index());
		return arg.scalarRecordFExp(indexMap, suffix.copySuffix());
	}
	
	public FExp FFunctionCall.scalarRecordFExp(HashMap<String,FExp> indexMap, FQName suffix) {
		return scalarizeExp(indexMap).extractRecordFExp(suffix);
	}
	
	/**
	 * \brief Create an FExp that represents a specific scalar component of this record.
	 * 
	 * Assumed that this expression is already scalarized.
	 * 
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.extractRecordFExp(FQName suffix) {
		return this;
	}
	
	public FExp FIdUseExp.extractRecordFExp(FQName suffix) {
		FQName name = getFIdUse().getFQName().append(suffix);
		name.scalarized = true;
		return new FIdUseExp(name);
	}
	
	/**
	 * \brief Scalarize equation and put all scalarized equations in list eqns.
	 */
	public void FFunctionCallEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, HashMap<String,FExp> indexMap) {
		List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft id : getLefts())
			lefts.add(id.scalarize(indexMap));
		eqns.addChild(new FFunctionCallEquation(lefts, (FAbstractFunctionCall) getCall().scalarizeExp(indexMap)));
	}
	
	public void FForClauseE.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, HashMap<String,FExp> indexMap) {
		Indices indices = Indices.create(getFForIndexs());
		
		HashMap<String,FExp> myIndexMap = new HashMap<String,FExp>();
		myIndexMap.putAll(indexMap);
		for (Index i : indices) {
			int j = 0;
			int[] ii = indices.translate(i).index();
			for (FForIndex fi : getFForIndexs()) {
				myIndexMap.put(fi.getFVariable().name(), new FIntegerLitExp(ii[j]));
				j++;
			}
			
			for (FAbstractEquation ae : getFAbstractEquations()) {
				ae.scalarize(eqns, vars, myIndexMap);
			}
		}
	}
	
	public FFunctionCallLeft FFunctionCallLeft.scalarize(HashMap<String,FExp> indexMap) {
		return new FFunctionCallLeft(hasFExp() ? new Opt(getFExp().scalarize(indexMap)) : new Opt());
	}
	
	/**
	 * \brief Add temporary variables and an equation/statement giving them values for each function 
	 *        call returning an array. Also add temporary variables and for loops for expressions 
	 *        (not assignments) of unknown array sizes. 
	 * 
	 * Creates statement if in function, equation otherwise.
	 * 
	 * @param clauses   the list to add the new equation or statement to
	 * @param vars      the list to add the new variables to
	 * @param indexMap  map of for indices to replace with literals
	 * @param addVar    if <code>true</code> create and add temporary variable(s)
	 */
	public void ASTNode.createArrayTemporaries(List clauses, 
			List vars, HashMap<String,FExp> indexMap, boolean addVar) {
		for (ASTNode node : this)
			node.createArrayTemporaries(clauses, vars, indexMap, addVar);
	}
	
	public void FFunctionCall.createArrayTemporaries(List clauses, 
			List vars, HashMap<String,FExp> indexMap, boolean addVar) {
		super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		if (!isFunctionCallClause()) {
			boolean equation = !inFunction();
			FExp temp = null;
			if (type().isRecord()) {
				if (addVar)
					type().createRecordTemporaries(vars, equation, tempVarName());
				if (equation)
					temp = type().createRecordConstructor(new FQName(tempVarName()));
				else
					temp = new FIdUseExp(tempVarName());
			} else if (isArray()) {
				if (equation) {
					if (addVar)
						type().createTempFVariables(vars, new FQName(tempVarName()));
					temp = getArray().buildScalarized(indexMap, this);
				} else {
					if (addVar)
						vars.add(new FFunctionArray((FType) type().fullCopy(), tempVarName()));
					temp = new FIdUseExp(tempVarName());
				}
			}
			if (temp != null) {
				List lefts = new List().add(new FFunctionCallLeft(new Opt(temp)));
				if (equation)
					clauses.add(new FFunctionCallEquation(lefts, scalarizeFunction(indexMap)));
				else
					clauses.add(new FFunctionCallStmt(lefts, scalarizeFunction(indexMap)));
			}
		}
	}
	
	/**
	 * \brief Creates temporary varables for a record with the given name.
	 * 
	 * @param vars      list of variable to add the new variables to
	 * @param equation  if <code>true</code>, generate FVariables, otherwise a FFunctionVariable
	 * @param name      the name of the record variable
	 */
	public void FType.createRecordTemporaries(List vars, boolean equation, String name) {}	
	
	public void FRecordType.createRecordTemporaries(List vars, boolean equation, String name) {
		if (equation) {
			createTempFVariables(vars, new FQName(name));
		} else {
			FFunctionVariable var = isArray() ? new FFunctionArray() : new FFunctionVariable();
			var.setType(fullCopy());
			var.setFQName(new FQName(name));
			vars.add(var);
		}
	}	
	
	/**
	 * \brief Create a record constructor (or FArray of record constructors),  
	 *        with the arguments taken from a record variable with the given name.
	 */
	public FExp FType.createRecordConstructor(FQName name) {
		if (isArray()) {
			FQName fqn = name.fullCopy();
			FArray arr = new FArray();
			for (Index i : indices()) {
				fqn.setLastFArraySubscripts(i.newFArraySubscripts());
				arr.addFExp(createRecordConstructorCell(fqn));
			}
			return arr;
		} else {
			return createRecordConstructorCell(name);
		}
	}
	
	/**
	 * \brief Create a record constructor with the arguments taken from a record 
	 *        variable with the given name.
	 * 
	 * Assumes that <code>name</code> refers to a non-array variable 
	 * (or a specific cell in an array variable).
	 */
	public FExp FType.createRecordConstructorCell(FQName name) {
		FQName fqn = name.fullCopy();
		fqn.scalarized = true;
		return new FIdUseExp(fqn);
	}
	
	public FExp FRecordType.createRecordConstructorCell(FQName name) {
		FRecordConstructor rc = new FRecordConstructor(new FIdUse(getName()), new List());
		for (FRecordComponentType comp : getComponents()) {
			FQName next = name.copyAndAppend(comp.getName());
			rc.addArg(comp.getFType().createRecordConstructor(next));
		}
		return rc;
	}
	
	/**
	 * \brief Creates a new temporary varable with the given name.
	 *        If this is an array, variables are created for each cell.
	 * 
	 * @param vars  list of variable to add the new variable to
	 * @param name  the name of the new variable
	 */
	public void FType.createTempFVariables(List vars, FQName name) {
		if (isArray()) {
			FQName fqn = name.fullCopy();
			for (Index i : indices()) {
				fqn.setLastFArraySubscripts(i.newFArraySubscripts());
				createTempCellFVariables(vars, fqn);
			}
		} else {
			createTempCellFVariables(vars, name);
		}
	}
	
	/**
	 * \brief Creates a new temporary variable with the given name.
	 * 
	 * @param vars  list of variable to add the new variable to
	 * @param name  the name of the new variable
	 */
	public void FType.createTempCellFVariables(List vars, FQName name) {
		FQName fqn = name.fullCopy();
		fqn.scalarized = true;
		vars.add(createFVariable(new FTemporaryVisibilityType(), fqn));
	}
	
	
	/**
	 * \brief Creates a new variable with the given visibility and name.
	 * 
	 * All optional children in the new variable are empty.
	 * 
	 * Default implementation returns <code>null</code>.
	 */
	public FVariable FType.createFVariable(FVisibilityType fvt, FQName name) {
		return null;
	}
		
	public FVariable FRealType.createFVariable(FVisibilityType fvt, FQName name) {
		return new FRealVariable(fvt, new FContinuous(), 
				new Opt(), new List(), new Opt(), new Opt(), name);
	}	
	
	public FVariable FIntegerType.createFVariable(FVisibilityType fvt, FQName name) {
		return new FIntegerVariable(fvt, new FDiscrete(), 
				new Opt(), new List(), new Opt(), new Opt(), name);
	}	
	
	public FVariable FBooleanType.createFVariable(FVisibilityType fvt, FQName name) {
		return new FBooleanVariable(fvt, new FDiscrete(), 
				new Opt(), new List(), new Opt(), new Opt(), name);
	}	
	
	public FVariable FStringType.createFVariable(FVisibilityType fvt, FQName name) {
		return new FStringVariable(fvt, new FDiscrete(), 
				new Opt(), new List(), new Opt(), new Opt(), name);
	}	
	
	/**
	 * \brief Creates temporary variables for a record with the given name.
	 * 
	 * @param vars  list of variable to add the new variables to
	 * @param name  the name of the record variable
	 */
	public void FRecordType.createTempCellFVariables(List vars, FQName name) {
		for (FRecordComponentType comp : getComponents()) {
			FQName next = name.copyAndAppend(comp.getName());
			comp.getFType().createTempFVariables(vars, next);
		}
	}
	
	
	/* Scalarization of expressions is needed in order to compute a simple
	 * scalar expression from an expression with ndims==0. For example, an
	 * FIdUse 'x[2]' needs to be marked as scalarized, and the expression
	 * scalar(x*A*x) needs to be replaced by a double sum.
	 */
	
	/**
	 * \brief Create an FArray containing scalarized subexpressions.
	 */
	public FExp Array.buildScalarized(HashMap<String,FExp> indexMap, FExp context) {
    	return buildFArray(iteratorFExp(), new ScalarizedBuilder(indexMap, context), 1);
    }
    
	public static class Array {
	    /**
	     * Helper object for {@link #buildScalarized(java.util.HashMap<String,FExp>)}.
	     */
	    protected class ScalarizedBuilder implements ElementBuilder {
	    	private HashMap<String,FExp> indexMap;
	    	private FExp context;
	    	
	    	public ScalarizedBuilder(HashMap<String,FExp> indexMap, FExp context) {
	    		this.indexMap = indexMap;
	    		this.context = context;
	    	}
	    	
			public FExp build(FExp e) {
				return context.dynamicFExp(e).scalarize(indexMap);
			}
	    }
	}
	
	/**
	 * \brief Flag that signals that this expression should be replaced with a use of a temporary variable.
	 */
	protected boolean FExp.useTempVar = false;

	/**
	 * \brief Scalarize expressions, replacing array expressions with FArrays of scalarized subexpressions.
	 * 
	 * The FArrays are needed because function calls need arrays to be passed as arrays.
	 */
	public FExp FExp.scalarize(HashMap<String,FExp> indexMap) {
		if (useTempVar) 
			return new FIdUseExp(tempVarName());
    	if (type().isRecord() && wantsRecordCon())
    		return buildRecordConstructor(indexMap);
 		else if (isArray() && !keepAsArray()) 
			return getArray().buildScalarized(indexMap, this);
		else
			return scalarizeExp(indexMap);
	}
	
	/**
	 * \brief Create a record constructor (or FArray of record constructors) 
	 *        describing this record expression.
	 */
	public FExp FExp.buildRecordConstructor(HashMap<String,FExp> indexMap) {
		return type().createRecordConstructor(new FQName(tempVarName()));
	}
	
	public FExp FIdUseExp.buildRecordConstructor(HashMap<String,FExp> indexMap) {
		return type().createRecordConstructor(getFIdUse().getFQName().scalarize(indexMap));
	}
	
	public FExp FRecordConstructor.buildRecordConstructor(HashMap<String,FExp> indexMap) {
		return scalarizeExp(indexMap);
	}
	
	syn boolean FExp.keepAsArray() = canKeepAsArray() && canAcceptArray() || size().isUnknown();

	syn boolean FExp.canKeepAsArray() = false;
	eq FIdUseExp.canKeepAsArray()     = true;
	eq FFunctionCall.canKeepAsArray() = true;
	
	inh boolean FExp.canAcceptArray();
	inh boolean List.canAcceptArray();
	inh boolean Opt.canAcceptArray();
	eq ASTNode.getChild().canAcceptArray()          = false;
	eq List.getChild().canAcceptArray()             = canAcceptArray();
	eq Opt.getChild().canAcceptArray()              = canAcceptArray();
	eq FFunctionCallLeft.getFExp().canAcceptArray() = inFunction();
	eq FFunctionCall.getArg().canAcceptArray()      = inFunction();
	eq FSizeExp.getFExp().canAcceptArray()          = inFunction();
	
	/**
	 * \brief Scalarize expressions.
	 */
	public FExp FExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return (FExp) fullCopy();
	}

	public FSubscript FSubscript.scalarize(HashMap<String,FExp> indexMap) {
		return (FSubscript) fullCopy();
	}
	
	public FSubscript FExpSubscript.scalarize(HashMap<String,FExp> indexMap) {
		return new FExpSubscript(getFExp().scalarize(indexMap));
	}
	
	public FArraySubscripts FArraySubscripts.scalarize(HashMap<String,FExp> indexMap) {
		FArraySubscripts fas = new FArraySubscripts();
		for (FSubscript fs : getFSubscripts()) {
			fas.addFSubscript(fs.scalarize(indexMap));
		}
		return fas;
	}
	
	public FQNamePart FQNamePart.scalarize(HashMap<String,FExp> indexMap) {
		return new FQNamePart(getName(),hasFArraySubscripts()? 
				new Opt(getFArraySubscripts().scalarize(indexMap)): new Opt());
	}
	
	public FQName FQName.scalarize(HashMap<String,FExp> indexMap) {
		FQName fqn = new FQName();
		for (FQNamePart fqnp : getFQNameParts()) 
			fqn.addFQNamePart(fqnp.scalarize(indexMap));
		fqn.scalarized = true;
		return fqn;
	}
	
    public FIdUse FIdUse.scalarize(HashMap<String,FExp> indexMap) {
    	return new FIdUse(getFQName().scalarize(indexMap));
    }

    public FExp FIdUseExp.scalarizeExp(HashMap<String,FExp> indexMap) {
    	if (indexMap.containsKey(name())) 
    		return (FExp) indexMap.get(name()).fullCopy();
    	return new FIdUseExp(getFIdUse().scalarize(indexMap));
    }
    
	inh boolean FExp.wantsRecordCon();
	inh boolean List.wantsRecordCon();
	inh boolean Opt.wantsRecordCon();
	eq ASTNode.getChild().wantsRecordCon()          = false;
	eq List.getChild().wantsRecordCon()             = wantsRecordCon();
	eq Opt.getChild().wantsRecordCon()              = wantsRecordCon();
	eq FFunctionCall.getArg().wantsRecordCon()      = !inFunction();
    
    /* These are needed because scalarize() is reused in Array.createExpanded(), that 
     * might be called on an instance tree.
     */
    public FExp FInstAccessExp.scalarizeExp(HashMap<String,FExp> indexMap) {
    	if (indexMap.containsKey(name())) 
    		return (FExp) indexMap.get(name()).fullCopy();
    	return new FInstAccessExp(getInstAccess().scalarize(indexMap));
    }
	
    public FIdUseInstAccess FIdUseInstAccess.scalarize(HashMap<String,FExp> indexMap) {
    	return new FIdUseInstAccess(new FQName(), getInstAccess().scalarize(indexMap));
    }
	
    public InstAccess InstAccess.scalarize(HashMap<String,FExp> indexMap) {
    	return (InstAccess) fullCopy();
    }
	
    public InstDot InstDot.scalarize(HashMap<String,FExp> indexMap) {
    	return new InstDot("", getLeft().scalarize(indexMap), getRight().scalarize(indexMap));
    }
	
    public InstArrayAccess InstArrayAccess.scalarize(HashMap<String,FExp> indexMap) {
    	InstArrayAccess res = (InstArrayAccess) fullCopy();
    	if (hasFArraySubscripts())
    		res.setFArraySubscripts(getFArraySubscripts().scalarize(indexMap));
    	return res;
    }
    // End of instance classes that need scalarize()
 
    public FExp FIfExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		List etl = new List();
		for (FElseIfExp elif : getFElseIfExps()) 
			etl.add(elif.scalarize(indexMap));
		return new FIfExp(getIfExp().scalarize(indexMap),
		                  getThenExp().scalarize(indexMap),
		                  etl,
		                  getElseExp().scalarize(indexMap));
	}
	
	public FExp FElseIfExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return new FElseIfExp(getIfExp().scalarize(indexMap),
		                      getThenExp().scalarize(indexMap));
	}
	
	public FExp FMulExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		if (getLeft().isArray() && !isArray()) 
			return dynamicFExp(composeScalarCellExp(Index.NULL)).scalarize(indexMap);
		else
			return super.scalarizeExp(indexMap);
	}
	
	public FExp FSizeExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		// Only the form with dim can be in the tree at this point
		FExp exp = getFExp();
		if (exp instanceof FIdUseExp && exp.size().isUnknown())
			return (FExp) fullCopy();
		else
			return dynamicFExp(getFExp().size().createFExp(dimension())).scalarize(indexMap);
	}
	
	public FExp FNdimsExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return ceval().buildLiteral();
	}
	
	public FExp FMinMaxExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		if (hasY())
			return createNode(getX().scalarize(indexMap), getY().scalarize(indexMap));
		else
			return getX().reduceToScalarized(this, indexMap);
	}
	
	public FExp FSumExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return getFExp().reduceToScalarized(new FAddExp(), indexMap);
	}
	
	/**
	 * \brief Scalarize an expression by recursively scalarizing and combining the contents in its Array.
	 * 
	 * New nodes are created with <code>template.createNodeBinary()</code>.
	 */
	public FExp FExp.reduceToScalarized(FExp template, HashMap<String,FExp> indexMap) {
		if (isArray()) {
			Iterator<FExp> it = getArray().iteratorFExp();
			FExp res = it.next().scalarize(indexMap);
			while (it.hasNext())
				res = template.createNodeBinary(res, it.next().scalarize(indexMap));
			return res;
		} else {
			return scalarize(indexMap);
		}
	}
	
	public FExp FBinExp.scalarizeExp(HashMap<String,FExp> indexMap) { return createNode(getLeft().scalarize(indexMap), getRight().scalarize(indexMap)); }
	public FExp FUnaryExp.scalarizeExp(HashMap<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FMathematicalFunctionCall.scalarizeExp(HashMap<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FAtan2Exp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FAtan2Exp(getFExp().scalarize(indexMap), getY().scalarize(indexMap)); }

	public FExp FAbsExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FAbsExp(getFExp().scalarize(indexMap)); }
	
	public FExp FLitExp.scalarizeExp(HashMap<String,FExp> indexMap) { return (FLitExp) fullCopy(); }
	public FExp FDerExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FDerExp(getFIdUse().scalarize(indexMap)); }

	public FExp FNoEventExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FNoEventExp(getFExp().scalarize(indexMap)); }

	public FExp FIntegerExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FIntegerExp(getFExp().scalarize(indexMap)); }
	
	public FExp FFunctionCall.scalarizeExp(HashMap<String,FExp> indexMap) {
		if (isComposite() && functionCallIsExp())
			return new FIdUseExp(tempVarName());
		else
			return scalarizeFunction(indexMap);
	}
	
	public FExp FRecordConstructor.scalarizeExp(HashMap<String,FExp> indexMap) {
		FRecordConstructor rc = new FRecordConstructor(getRecord().scalarize(indexMap), new List());
		for (FExp arg : getArgs())
			rc.addArg(arg.scalarize(indexMap));
		return rc;
	}
	
	public FFunctionCall FFunctionCall.scalarizeFunction(HashMap<String,FExp> indexMap) {
		List<FExp> args = new List<FExp>();
		for (FExp arg : getArgs())
			args.add(arg.scalarize(indexMap));
		return new FFunctionCall(getName().fullCopy(), args, getSizes()); 
	}
	
	public FExp FTimeExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FTimeExp(); }
	
	public FExp FEndExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return mySize().isUnknown() ? createFSizeExp() : mySize().createFExp(0);
	}
	
	inh FSizeExp FEndExp.createFSizeExp();
	eq FArraySubscripts.getFSubscript(int i).createFSizeExp() = createFSizeExp(i);
	eq FlatRoot.getChild().createFSizeExp()                   = null;
	eq InstRoot.getChild().createFSizeExp()                   = null;
	
	inh FSizeExp FArraySubscripts.createFSizeExp(int dim);
	eq FlatRoot.getChild().createFSizeExp(int dim) = null;
	eq InstRoot.getChild().createFSizeExp(int dim) = null;
	eq FQName.getChild().createFSizeExp(int dim) {
		FQName fqn = fullCopy();
		fqn.setLastFArraySubscripts(null);
		FExp dimExp = new FIntegerLitExp(dim + 1);
		return new FSizeExp(new FIdUseExp(fqn), new Opt(dimExp));
	}

	
	public FForIndex FForIndex.scalarize(HashMap<String,FExp> indexMap) {
		return new FForIndex(hasFExp() ? new Opt(getFExp().scalarizeIndexExp(indexMap)) : new Opt(), 
				(FVariable) getFVariable().fullCopy());
	}
	
	/**
	 * \brief Scalarize the expression of an FForIndex. 
	 */
	public FExp FExp.scalarizeIndexExp(HashMap<String,FExp> indexMap) {
		return scalarize(indexMap);
	}
	
	public FRangeExp FRangeExp.scalarizeIndexExp(HashMap<String,FExp> indexMap) {
		List<FExp> exps = new List<FExp>();
		for (FExp e : getFExps())
			exps.add(e.scalarize(indexMap));
		return new FRangeExp(exps);
	}

}
