/*
    Copyright (C) 2016 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect SrcUtil {

    syn boolean Exp.isLiteral()  = false;
    eq BooleanLitExp.isLiteral() = true;
    eq IntegerLitExp.isLiteral() = true;
    eq RealLitExp.isLiteral()    = true;
    eq StringLitExp.isLiteral()  = true;

    /**
     * Returns the class declaration which surrounds this element. Null if no
     * such declaration can be found.
     */
    inh ClassDecl Element.myClassDecl();
    eq ClassDecl.getChild().myClassDecl() = this;
    eq SourceRoot.getChild().myClassDecl() = null;

    /**
     * Returns true if this import is an unqualified import.
     */
    syn boolean ImportClause.isUnqualifiedImport()   = false;
    eq ImportClauseUnqualified.isUnqualifiedImport() = true;

    /**
     * Return true if this import is a renaming import
     */
    syn boolean ImportClause.isRenamingImport() = false;
    eq ImportClauseRename.isRenamingImport()    = true;

    /**
     * Returns the rename string for this import, or null if this import
     * isn't a renaming import.
     */
    syn String ImportClause.renameStringOrNull() = null;
    eq ImportClauseRename.renameStringOrNull() = getIdDecl().name();

    syn boolean Exp.isAccess() = false;
    eq AccessExp.isAccess() = true;
    
    syn Access Exp.asAccess() {
        throw new UnsupportedOperationException();
    }
    eq AccessExp.asAccess() = getAccess();
    
    syn boolean Access.isNamed() = false;
    eq NamedAccess.isNamed() = true;
    
    syn String Access.asID() {
        throw new UnsupportedOperationException();
    }
    eq NamedAccess.asID() = getID();

    /**************************************************************************
     *    Is and as methods for Clauses
     **************************************************************************/
    /**
     * Is this clause an element list?
     */
    syn boolean Clause.isElementList() = false;
    eq ElementList    .isElementList() = true;
    /**
     * Is this clause an public element list?
     */
    syn boolean Clause  .isPublicElementList() = false;
    eq PublicElementList.isPublicElementList() = true;
    /**
     * Is this clause an default element list?
     */
    syn boolean Clause   .isDefaultElementList() = false;
    eq DefaultElementList.isDefaultElementList() = true;
    /**
     * Is this clause an protected element list?
     */
    syn boolean Clause     .isProtectedElementList() = false;
    eq ProtectedElementList.isProtectedElementList() = true;
    /**
     * Upcasts this clause to an element list, or class cast exception if of
     * different type!
     */
    syn ElementList Clause.asElementList() = (ElementList) this;

    /**
     * Is this clause an equation clause?
     */
    syn boolean Clause.isEquationClause() = false;
    eq EquationClause .isEquationClause() = true;
    /**
     * Is this clause an initial equation clause?
     */
    syn boolean Clause      .isInitialEquationClause() = false;
    eq InitialEquationClause.isInitialEquationClause() = true;
    /**
     * Upcasts this clause to an equation clause, or class cast exception if of
     * different type!
     */
    syn EquationClause Clause.asEquationClause() = (EquationClause) this;

    /**
     * Is this clause an algorithm?
     */
    syn boolean Clause.isAlgorithm() = false;
    eq Algorithm      .isAlgorithm() = true;
    /**
     * Is this clause an initial algorithm?
     */
    syn boolean Clause .isInitialAlgorithm() = false;
    eq InitialAlgorithm.isInitialAlgorithm() = true;
    /**
     * Upcasts this clause to an algorithm, or class cast exception if of
     * different type!
     */
    syn Algorithm Clause.asAlgorithm() = (Algorithm) this;

    /**************************************************************************
     *    Is and as methods for Elements
     **************************************************************************/
    /**
     * Is this element a class declaration?
     */
    syn boolean Element.isClassDecl() = false;
    eq ClassDecl       .isClassDecl() = true;
    /**
     * Upcasts this element to an class decl, or class cast exception if of
     * different type!
     */
    syn ClassDecl Element.asClassDecl() = (ClassDecl) this;

    /**
     * Is this element a component clause declaration?
     */
    syn boolean Element.isComponentClause() = false;
    eq ComponentClause .isComponentClause() = true;
    /**
     * Upcasts this element to an component clause, or class cast exception if
     * of different type!
     */
    syn ComponentClause Element.asComponentClause() = (ComponentClause) this;

    /**
     * Is this element an extends caluse declaration?
     */
    syn boolean Element.isExtendsClause() = false;
    eq ExtendsClause   .isExtendsClause() = true;
    /**
     * Upcasts this element to an extends clause, or class cast exception if of
     * different type!
     */
    syn ExtendsClause Element.asExtendsClause() = (ExtendsClause) this;

    /**
     * Is this element an import caluse declaration?
     */
    syn boolean Element.isImportClause() = false;
    eq ImportClause    .isImportClause() = true;
    /**
     * Upcasts this element to an import clause, or class cast exception if of
     * different type!
     */
    syn ImportClause Element.asImportClause() = (ImportClause) this;

    
}


aspect ComponentClauseFields {

    syn boolean ComponentDecl.hasRedeclare() = myComponentClause().getRedeclare();

    syn boolean ComponentDecl.hasFinal() = myComponentClause().getFinal();

    syn boolean ComponentDecl.hasInner() = myComponentClause().getInner();

    syn boolean ComponentDecl.hasOuter() = myComponentClause().getOuter();

    syn boolean ComponentDecl.hasReplaceable() = myComponentClause().getReplaceable();

    syn boolean ComponentDecl.hasTypePrefixFlow() = myComponentClause().hasTypePrefixFlow();
    syn TypePrefixFlow ComponentDecl.getTypePrefixFlow() = myComponentClause().getTypePrefixFlow();

    syn boolean ComponentDecl.hasTypePrefixVariability() = 
        myComponentClause().hasTypePrefixVariability();
    syn TypePrefixVariability ComponentDecl.getTypePrefixVariability() = 
        myComponentClause().getTypePrefixVariability();

    syn boolean ComponentDecl.hasTypePrefixInputOutput() = 
        myComponentClause().hasTypePrefixInputOutput();
    syn TypePrefixInputOutput ComponentDecl.getTypePrefixInputOutput() = 
        myComponentClause().getTypePrefixInputOutput();

    syn Access ComponentDecl.getClassName() = myComponentClause().getClassName();

    syn boolean ComponentDecl.hasTypeArraySubscripts() = 
        myComponentClause().hasTypeArraySubscripts();
    syn ArraySubscripts ComponentDecl.getTypeArraySubscripts() = 
        myComponentClause().getTypeArraySubscripts();

    syn boolean ComponentDecl.hasConstrainingClause() = 
        myComponentClause().hasConstrainingClause();
    syn ConstrainingClause ComponentDecl.getConstrainingClause() = 
        myComponentClause().getConstrainingClause();

    syn boolean ComponentDecl.hasArraySubscripts() = 
        hasVarArraySubscripts() || hasTypeArraySubscripts();

}