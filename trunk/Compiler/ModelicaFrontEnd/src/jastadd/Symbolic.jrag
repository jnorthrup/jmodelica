/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect EquationSolve {
	
	syn boolean FAbstractEquation.isSolved(String name) {
		return !(solution(name) instanceof FNoExp);
	}
	
	syn nta FExp FAbstractEquation.solution(String name) {
		return new FNoExp();
	}
	
	eq FWhenEquation.solution(String name) {
		if (getNumFAbstractEquation()>1) {
			return null;
		} else {
			return getFAbstractEquation(0).solution(name);
		}
	}
	
	eq FEquation.solution(String name) {
		
		// Get terms
		ArrayList<FExp> t = terms();
		
		ArrayList<FExp> activeTerms = new ArrayList<FExp>();
		ArrayList<FExp> inactiveTerms = new ArrayList<FExp>();
		// Find terms
		//System.out.println("Equation:\n" + prettyPrint(""));			
		for (FExp e : t) {
			//System.out.println("Term" + (e.isNegativeTerm()? "(-): ": "(+): ") + e.prettyPrint(""));
			if (e.nbrUses(name)==1) {
			    //System.out.println(" - active");
				activeTerms.add(e);
			} else if (e.nbrUses(name)==0) {
				//System.out.println(" - inactive");
			    inactiveTerms.add(e);
			} else {
			    return new FNoExp();
			}
		}
		//System.out.println("Found term" + (theTerm.isNegativeTerm()? "(-): ": "(+): ") + theTerm.prettyPrint(""));	
		
		FExp sol = null;
		// Build new AST for the inactive terms
		for (FExp e : inactiveTerms) {
			FExp ee = (FExp)e.fullCopy();
			// Set references from the new tree to the original one
			ee.traverseSymbolic(e); 
			if (!e.isNegativeTerm()) {
			  	ee = new FNegExp(ee);
			}
			if (sol==null) {
				sol = ee;
			} else {
			    sol = new FAddExp(sol,ee);				  	
			}
		}
		
		FExp mulCoeff = null;
		// Build new AST for the active terms
		for (FExp e : activeTerms) {
			ArrayList<FExp> fac = e.factors();
			// There is only one reference to the active variable in each
			// term - this is checked above.			
			ArrayList<FExp> activeFactors = new ArrayList<FExp>();
			ArrayList<FExp> inactiveFactors = new ArrayList<FExp>();
			// Find terms
			//System.out.println("Equation:\n" + prettyPrint(""));
			boolean negatedFactor = false;			
			for (FExp ee : fac) {
				//System.out.println("Factor" + (ee.isNegativeTerm()? "(-): ": "(+): ") + ee.prettyPrint(""));
				if (ee.nbrUses(name)==1 && !ee.isInvertedFactor() && 
				    (ee.isIdentifier(name) || // Identifier 
				    (ee instanceof FPreExp))) { // pre expression 
					//System.out.println(" - active"); 
					activeFactors.add(ee);
				} else if (ee.nbrUses(name)==1 && !ee.isInvertedFactor() && 
				    ((ee instanceof FNegExp) && ((FNegExp)ee).getFExp().isIdentifier(name))) {
					//System.out.println(" - active"); 
					activeFactors.add(((FNegExp)ee).getFExp());
					negatedFactor = true;
				} else if (ee.nbrUses(name)==0) {
					//System.out.println(" - inactive"); 
				    inactiveFactors.add(ee);
				} else {
					// This equation cannot be solved
				    return new FNoExp();
				}
			}
			FExp coeff = null;
			for (FExp eee : inactiveFactors) {			
				FExp eeee = (FExp)eee.fullCopy();
				// Set references from the new tree to the original one
				eeee.traverseSymbolic(eee); 
				if (eee.isInvertedFactor()) {
				  	eeee = new FDivExp(new FRealLitExp("1"),eeee);
				}
				if (coeff==null) {
					coeff = eeee;
				} else {
				    coeff = new FMulExp(coeff,eeee);				  	
				}
			}
			if (coeff==null) {
				coeff = new FRealLitExp("1");
			}
			if (coeff!=null) {
				if (mulCoeff==null) {
					if (e.isNegativeTerm() || negatedFactor) {
						mulCoeff = new FNegExp(coeff);
					} else {
					    mulCoeff = coeff;
					}
				} else {
					if (e.isNegativeTerm() || negatedFactor) {
						mulCoeff = new FSubExp(mulCoeff,coeff);				  
					} else {
					    mulCoeff = new FAddExp(mulCoeff,coeff);				  
					}	
				}					
			}	
		}
	    
	    if (mulCoeff!=null && 
	        !((mulCoeff instanceof FRealLitExp) && mulCoeff.ceval().realValue()==1)) {
	    	sol = new FDivExp(sol,mulCoeff);
	    }

		return sol;
	}
	
	// Get terms
	syn ArrayList<FExp> FEquation.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().terms());
		t.addAll(getRight().terms());
		return t;
	}
	
	syn ArrayList<FExp> FExp.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.add(this);
		return t;
	}
	
	eq FDotAddExp.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().terms());
		t.addAll(getRight().terms());
		return t;
	}

	eq FDotSubExp.terms() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().terms());
		t.addAll(getRight().terms());
		return t;
	}

	// Get factors	
	syn ArrayList<FExp> FExp.factors() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.add(this);
		return t;
	}
	
	eq FDotMulExp.factors() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().factors());
		t.addAll(getRight().factors());
		return t;
	}

	eq FDotDivExp.factors() {
		ArrayList<FExp> t = new ArrayList<FExp>();
		t.addAll(getLeft().factors());
		t.addAll(getRight().factors());
		return t;
	}

	// Negated terms	
	inh boolean FExp.isNegativeTerm();
	eq FDotSubExp.getRight().isNegativeTerm() = !isNegativeTerm();
	eq FNegExp.getFExp().isNegativeTerm() = !isNegativeTerm();
	eq FEquation.getRight().isNegativeTerm() = true;
	eq FEquation.getLeft().isNegativeTerm() = false;
	eq Root.getChild().isNegativeTerm() = false;

	// Inverted factors
	inh boolean FExp.isInvertedFactor();
	eq FDotDivExp.getRight().isInvertedFactor() = !isInvertedFactor();
	eq FEquation.getChild().isInvertedFactor() = false;
	eq Root.getChild().isInvertedFactor() = false;
	
	// Classification of terms
	syn boolean FExp.isIdentifier(String name) = false;
	eq FIdUseExp.isIdentifier(String name) = name.equals(name());
	
	syn int FExp.isMulTerm(String name) = 0;
	eq FDotMulExp.isMulTerm(String name) {
		if (getLeft().isIdentifier(name)) {
			return 1;
		} else if (getRight().isIdentifier(name)) {
			return 2;
		} else {
			return 0;
		}
	}

	syn boolean FExp.isDivTerm(String name) = false;
	eq FDotDivExp.isDivTerm(String name) {
		if (getLeft().isIdentifier(name)) {
			return true;
		} else {
			return false;
		}
	}

	syn boolean FExp.isNegTerm(String name) = false;
	eq FNegExp.isNegTerm(String name) = getFExp().isIdentifier(name);
	
	syn int FEquation.nbrUses(String name) {
		return getLeft().nbrUses(name) + getRight().nbrUses(name);
	}
	
	syn int ASTNode.nbrUses(String name) {
		int n = 0;
		for (int i=0;i<getNumChild();i++) {
			n += getChild(i).nbrUses(name);
		}
		return n;
	}
	
	eq FIdUseExp.nbrUses(String name) = name.equals(name())? 1: 0;
	eq FDerExp.nbrUses(String name) = name.equals(name())? 1: 0;
	eq FPreExp.nbrUses(String name) = name.equals(name())? 1: 0;
	
	public FRelExp FRelExp.originalFRelExp = null;
	public FSampleExp FSampleExp.originalFSampleExp = null;
	public void ASTNode.traverseSymbolic(ASTNode e) {
		for (int i=0;i<getNumChild();i++) {
			getChild(i).traverseSymbolic(e.getChild(i));
		}
	}

	public void FRelExp.traverseSymbolic(ASTNode e) {
		originalFRelExp = (FRelExp)e;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).traverseSymbolic(e.getChild(i));
		}
	}

	public void FSampleExp.traverseSymbolic(ASTNode e) {
		originalFSampleExp = (FSampleExp)e;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).traverseSymbolic(e.getChild(i));
		}
	}
	
}


aspect Derivatives {

    public class EquationDifferentiationException extends RuntimeException {
    
    	public FAbstractEquation equation;
    	
    	public EquationDifferentiationException(FAbstractEquation e, String message) {
    		super(message);
    		this.equation = e;
    	}
    
    }

    public class ExpressionDifferentiationException extends RuntimeException {
    
    	public FExp fexp;
    	
    	public ExpressionDifferentiationException(FExp e) {
    		this.fexp = e;
    	}
    
    }

	public FAbstractEquation FAbstractEquation.diff(String name) {
		throw new EquationDifferentiationException(this, "Cannot differentate the equation \n   " + prettyPrint(""));
	}
	
	public FAbstractEquation FEquation.diff(String name) {
		try {
			return dynamicFAbstractEquation(new FEquation(getLeft().diff(name),
				getRight().diff(name)));
		} catch (ExpressionDifferentiationException e) {
			throw new EquationDifferentiationException(this,
			    "Cannot differentiate the expression '" + e.fexp.prettyPrint("") + 
			    "' in equation: \n   " + prettyPrint(""));
		}
	}

	public FExp FExp.diff(String name, int n) {
		FExp e = diff(name);
			
		int i = n-1;
		while (i>0) {
			e = e.diff(name,n-1);
		}
			
		return e;

	}

	public FExp FExp.diff(String name) {
		throw new ExpressionDifferentiationException(this);
	}
	
	public FExp FAddExp.diff(String name) {
		return dynamicFExp(new FAddExp(getLeft().diff(name),
			getRight().diff(name)));
	}

	public FExp FSubExp.diff(String name) {
		return dynamicFExp(new FSubExp(getLeft().diff(name),
			getRight().diff(name)));
	}

	public FExp FMulExp.diff(String name) {
		return dynamicFExp(new FAddExp(
		    new FMulExp((FExp)getLeft().fullCopy(),getRight().diff(name)),
			new	FMulExp(getLeft().diff(name),(FExp)getRight().fullCopy())));
	}

	public FExp FDivExp.diff(String name) {
		return dynamicFExp(new FDivExp(new FSubExp(
		    new FMulExp((FExp)getLeft().fullCopy(),getRight().diff(name)),
			new	FMulExp(getLeft().diff(name),(FExp)getRight().fullCopy())),
			new	FPowExp((FExp)getRight().fullCopy(),new FIntegerLitExp("2"))));
	}

	public FExp FPowExp.diff(String name) {
		FExp exponent;
		FExp e;
		if (getRight().variability().constantVariability()) {
			double exponentValue = getRight().ceval().realValue();
			if (exponentValue==2.0) {
				e = (FExp)getLeft().fullCopy();
			} else {
				exponent = new FRealLitExp((getRight().ceval().realValue()-1) + "");
				e = new FPowExp((FExp)getLeft().fullCopy(),exponent);	
			}
		} else {
			exponent = new FSubExp((FExp)getRight().fullCopy(),new FIntegerLitExp("1"));
			e = new FPowExp((FExp)getLeft().fullCopy(),exponent);
		}
			
		return dynamicFExp(new FMulExp(new FMulExp((FExp)getRight().fullCopy(),
		                        e),getLeft().diff(name)));	
	}

	public FExp FSinExp.diff(String name) {
		return dynamicFExp(new FMulExp(new FCosExp((FExp)getFExp().fullCopy()),
			getFExp().diff(name)));
	}
	/*
	public FExp FCosExp.diff(String name) {
		return dynamicFExp(new FMulExp(new FSinExp((FExp)getFExp().fullCopy()),
			getFExp().diff(name)));
	}
	*/
	public FExp FIdUseExp.diff(String name) {	
		if (variability().parameterOrLess()) {
			return dynamicFExp(new FRealLitExp("0"));		
		} else if (name.equals("time")) {
			return dynamicFExp(new FDerExp((FIdUse)getFIdUse().fullCopy()));
		} else if (name.equals(name())) {
			return dynamicFExp(new FRealLitExp("1"));
		} else {
			return dynamicFExp(new FRealLitExp("0"));
		}
	}
	
	public FExp FDerExp.diff(String name) {	
		if (name.equals("time")) {
			return dynamicFExp(new FHDerExp((FIdUse)getFIdUse().fullCopy(),2));
		} else if (name.equals(name())) {
			return dynamicFExp(new FRealLitExp("1"));
		} else {
			return dynamicFExp(new FRealLitExp("0"));
		}
	}

	public FExp FHDerExp.diff(String name) {	
		if (name.equals("time")) {
			return dynamicFExp(new FHDerExp((FIdUse)getFIdUse().fullCopy(),getOrder()+1));
		} else if (name.equals(name())) {
			return dynamicFExp(new FRealLitExp("1"));
		} else {
			return dynamicFExp(new FRealLitExp("0"));
		}
	}
	
	public FExp FLitExp.diff(String name) {
		return dynamicFExp(new FRealLitExp("0"));
	}
	
	public FExp FTimeExp.diff(String name) {			
			return dynamicFExp(new FRealLitExp("1"));		
	}
	
}
/*
 aspect ExpressionSimplification {
 
 	rewrite FMulExp {
		when (getLeft().variability().lessOrEqual(fConstant()) && getLeft().ceval().realValue()==0.) to FExp {
				return getRight();
			}
	}
 
 }
 */