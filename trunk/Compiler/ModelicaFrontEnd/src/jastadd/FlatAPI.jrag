/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.LinkedHashSet;
import java.util.ArrayList;

aspect FlatAPI {
	
    syn int FClass.numReals() = reals().size();
	coll ArrayList<FVariable> FClass.reals() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FRealVariable contributes this to FClass.reals() for myFClass();

    syn int FClass.numIntegers() = integers().size();
	coll ArrayList<FVariable> FClass.integers() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FIntegerVariable contributes this to FClass.integers() for myFClass();

    syn int FClass.numBooleans() = booleans().size();
	coll ArrayList<FVariable> FClass.booleans() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FBooleanVariable contributes this to FClass.booleans() for myFClass();

    syn int FClass.numStrings() = strings().size();
	coll ArrayList<FVariable> FClass.strings() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FStringVariable contributes this to FClass.strings() for myFClass();

    syn int FClass.numIndependentConstants() = independentConstants().size();
	coll ArrayList<FVariable> FClass.independentConstants() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isIndependentConstant()
	to FClass.independentConstants() for myFClass();

	syn int FClass.numIndependentRealConstants() = independentRealConstants().size();
	syn lazy ArrayList<FVariable> FClass.independentRealConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentConstants());
      set.retainAll(reals());
      return set;
     }
	syn int FVariable.independentRealConstantIndex() =
		myFClass().independentRealConstants().indexOf(this);
	
	syn int FClass.numIndependentIntegerConstants() = independentIntegerConstants().size();
	syn lazy ArrayList<FVariable> FClass.independentIntegerConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentConstants());
      set.retainAll(integers());
      return set;
     }
	syn int FVariable.independentIntegerConstantIndex() =
		myFClass().independentIntegerConstants().indexOf(this);

	
	syn int FClass.numIndependentBooleanConstants() = independentBooleanConstants().size();
	syn lazy ArrayList<FVariable> FClass.independentBooleanConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentConstants());
      set.retainAll(booleans());
      return set;
     }
	syn int FVariable.independentBooleanConstantIndex() =
		myFClass().independentBooleanConstants().indexOf(this);
	
	syn int FClass.numIndependentStringConstants() = independentStringConstants().size();
	syn lazy ArrayList<FVariable> FClass.independentStringConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentConstants());
      set.retainAll(strings());
      return set;
     }
	syn int FVariable.independentStringConstantIndex() =
		myFClass().independentStringConstants().indexOf(this);

	// TODO: Is there such a thing as a dependent constant??
    syn int FClass.numDependentConstants() = dependentConstants().size();
	coll ArrayList<FVariable> FClass.dependentConstants() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when false
	to FClass.dependentConstants() for myFClass();
	
	syn int FClass.numDependentRealConstants() = dependentRealConstants().size();
	syn lazy ArrayList<FVariable> FClass.dependentRealConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentConstants());
      set.retainAll(reals());
      return set;
     }
	syn int FVariable.dependentRealConstantIndex() =
		myFClass().dependentRealConstants().indexOf(this);
	
	syn int FClass.numDependentIntegerConstants() = dependentIntegerConstants().size();
	syn lazy ArrayList<FVariable> FClass.dependentIntegerConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentConstants());
      set.retainAll(integers());
      return set;
     }
	syn int FVariable.dependentIntegerConstantIndex() =
		myFClass().dependentIntegerConstants().indexOf(this);
	
	syn int FClass.numDependentBooleanConstants() = dependentBooleanConstants().size();
	syn lazy ArrayList<FVariable> FClass.dependentBooleanConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentConstants());
      set.retainAll(booleans());
      return set;
     }
	syn int FVariable.dependentBooleanConstantIndex() =
		myFClass().dependentBooleanConstants().indexOf(this);
	
	syn int FClass.numDependentStringConstants() = dependentStringConstants().size();
	syn lazy ArrayList<FVariable> FClass.dependentStringConstants() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentConstants());
      set.retainAll(strings());
      return set;
     }
	syn int FVariable.dependentStringConstantIndex() =
		myFClass().dependentStringConstants().indexOf(this);

    syn int FClass.numIndependentParameters() = independentParameters().size();
	coll ArrayList<FVariable> FClass.independentParameters() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isIndependentParameter()
	to FClass.independentParameters() for myFClass();
	
	syn int FClass.numIndependentRealParameters() = independentRealParameters().size();
	syn lazy ArrayList<FVariable> FClass.independentRealParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentParameters());
      set.retainAll(reals());
      return set;
     }
	syn int FVariable.independentRealParameterIndex() =
		myFClass().independentRealParameters().indexOf(this);

	syn int FClass.numIndependentIntegerParameters() = independentIntegerParameters().size();
	syn lazy ArrayList<FVariable> FClass.independentIntegerParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentParameters());
      set.retainAll(integers());
      return set;
     }
	syn int FVariable.independentIntegerParameterIndex() =
		myFClass().independentIntegerParameters().indexOf(this);
	
	syn int FClass.numIndependentBooleanParameters() = independentBooleanParameters().size();
	syn lazy ArrayList<FVariable> FClass.independentBooleanParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentParameters());
      set.retainAll(booleans());
      return set;
     }
	syn int FVariable.independentBooleanParameterIndex() =
		myFClass().independentBooleanParameters().indexOf(this);

	syn int FClass.numIndependentStringParameters() = independentStringParameters().size();
	syn lazy ArrayList<FVariable> FClass.independentStringParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(independentParameters());
      set.retainAll(strings());
      return set;
     }
	syn int FVariable.independentStringParameterIndex() =
		myFClass().independentStringParameters().indexOf(this);

    syn int FClass.numDependentParameters() = dependentParameters().size();
	coll ArrayList<FVariable> FClass.dependentParameters() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isDependentParameter()
	to FClass.dependentParameters() for myFClass();

	syn int FClass.numDependentRealParameters() = dependentRealParameters().size();
	syn lazy ArrayList<FVariable> FClass.dependentRealParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentParameters());
      set.retainAll(reals());
      return set;
     }
	syn int FVariable.dependentRealParameterIndex() =
		myFClass().dependentRealParameters().indexOf(this);

	syn int FClass.numDependentIntegerParameters() = dependentIntegerParameters().size();
	syn lazy ArrayList<FVariable> FClass.dependentIntegerParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentParameters());
      set.retainAll(integers());
      return set;
     }
	syn int FVariable.dependentIntegerParameterIndex() =
		myFClass().dependentIntegerParameters().indexOf(this);
	
	syn int FClass.numDependentBooleanParameters() = dependentBooleanParameters().size();
	syn lazy ArrayList<FVariable> FClass.dependentBooleanParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentParameters());
      set.retainAll(booleans());
      return set;
     }
	syn int FVariable.dependentBooleanParameterIndex() =
		myFClass().dependentBooleanParameters().indexOf(this);
	
	syn int FClass.numDependentStringParameters() = dependentStringParameters().size();
	syn lazy ArrayList<FVariable> FClass.dependentStringParameters() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(dependentParameters());
      set.retainAll(strings());
      return set;
     }
	syn int FVariable.dependentStringParameterIndex() =
		myFClass().dependentStringParameters().indexOf(this);
	
    syn int FClass.numDifferentiatedRealVariables() = differentiatedRealVariables().size();
	coll ArrayList<FVariable> FClass.differentiatedRealVariables() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FDer contributes
 		(FVariable)getFIdUseExp().myFV() when
 		!getFIdUseExp().myFV().isUnknown()
	to FClass.differentiatedRealVariables() for myFClass();
	syn int FVariable.differentiatedRealVariableIndex() =
		myFClass().differentiatedRealVariables().indexOf(this);
	
    syn int FClass.numVariables() = variables().size();
	coll ArrayList<FVariable> FClass.variables() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when  !isParameter() && !isConstant()
	to FClass.variables() for myFClass();
	
	syn int FClass.numRealVariables() = realVariables().size();
	syn lazy ArrayList<FVariable> FClass.realVariables() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variables());
      set.retainAll(reals());
      return set;
     }

	syn int FClass.numIntegerVariables() = integerVariables().size();
	syn lazy ArrayList<FVariable> FClass.integerVariables() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variables());
      set.retainAll(integers());
      return set;
     }

	syn int FClass.numBooleanVariables() = booleanVariables().size();
	syn lazy ArrayList<FVariable> FClass.booleanVariables() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variables());
      set.retainAll(booleans());
      return set;
     }

	syn int FClass.numStringVariables() = stringVariables().size();
	syn lazy ArrayList<FVariable> FClass.stringVariables() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variables());
      set.retainAll(strings());
      return set;
     }
	
    syn int FClass.numAlgebraicVariables() = algebraicVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicVariables() { 
	  ArrayList<FVariable> set = new ArrayList<FVariable>();
  	  set.addAll(variables());
  	  set.removeAll(differentiatedRealVariables());
  	  set.removeAll(inputs());
  /*
      for (FVariable fv : getFVariables()) {
      	if (!fv.isParameter() && !fv.isConstant() && !fv.isInput() && 
      	  !differentiatedRealVariables().contains(fv)) {
      		set.add(fv);
      	}
      }
    */
      return set;
	}
	
    syn int FClass.numAlgebraicRealVariables() = algebraicRealVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicRealVariables() { 
	  ArrayList<FVariable> set = new ArrayList<FVariable>();
	  set.addAll(algebraicVariables());
	  set.retainAll(reals());
      return set;
	}
	syn int FVariable.algebraicRealVariableIndex() =
		myFClass().algebraicRealVariables().indexOf(this);
	
    syn int FClass.numAlgebraicIntegerVariables() = algebraicIntegerVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicIntegerVariables() { 
	  ArrayList<FVariable> set = new ArrayList<FVariable>();
	    set.addAll(algebraicVariables());
	    set.retainAll(integers());
      return set;
	}
	syn int FVariable.algebraicIntegerVariableIndex() =
		myFClass().algebraicIntegerVariables().indexOf(this);
	
    syn int FClass.numAlgebraicBooleanVariables() = algebraicBooleanVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicBooleanVariables() { 
	  ArrayList<FVariable> set = new ArrayList<FVariable>();
	    set.addAll(algebraicVariables());
	    set.retainAll(booleans());
      return set;
	}
	syn int FVariable.algebraicBooleanVariableIndex() =
		myFClass().algebraicBooleanVariables().indexOf(this);

    syn int FClass.numAlgebraicStringVariables() = algebraicStringVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicStringVariables() { 
	  ArrayList<FVariable> set = new ArrayList<FVariable>();
	    set.addAll(algebraicVariables());
	    set.retainAll(strings());
      return set;
	}
	syn int FVariable.algebraicStringVariableIndex() =
		myFClass().algebraicStringVariables().indexOf(this);

    syn int FClass.numVariablesWithBindingExp() = variablesWithBindingExp().size();
	coll ArrayList<FVariable> FClass.variablesWithBindingExp() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when !isParameter() && !isConstant() &&
 		  hasBindingExp()
	to FClass.variablesWithBindingExp() for myFClass();

	syn int FClass.numRealVariablesWithBindingExp() = realVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.realVariablesWithBindingExp() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variablesWithBindingExp());
      set.retainAll(reals());
      return set;
     }

	syn int FClass.numIntegerVariablesWithBindingExp() = integerVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.integerVariablesWithBindingExp() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variablesWithBindingExp());
      set.retainAll(integers());
      return set;
     }

	syn int FClass.numBooleanVariablesWithBindingExp() = booleanVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.booleanVariablesWithBindingExp() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variablesWithBindingExp());
      set.retainAll(booleans());
      return set;
     }

	syn int FClass.numStringVariablesWithBindingExp() = stringVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.stringVariablesWithBindingExp() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(variablesWithBindingExp());
      set.retainAll(strings());
      return set;
     }
     
    syn int FClass.numInputs() = inputs().size();
	coll ArrayList<FVariable> FClass.inputs() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isInput()
	to FClass.inputs() for myFClass();

	syn int FClass.numRealInputs() = realInputs().size();
	syn lazy ArrayList<FVariable> FClass.realInputs() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(inputs());
      set.retainAll(reals());
      return set;
     }
	syn int FVariable.realInputIndex() =
		myFClass().realInputs().indexOf(this);
	
	syn int FClass.numIntegerInputs() = integerInputs().size();
	syn lazy ArrayList<FVariable> FClass.integerInputs() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(inputs());
      set.retainAll(integers());
      return set;
     }
	syn int FVariable.integerInputIndex() =
		myFClass().integerInputs().indexOf(this);

	syn int FClass.numBooleanInputs() = booleanInputs().size();
	syn lazy ArrayList<FVariable> FClass.booleanInputs() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(inputs());
      set.retainAll(booleans());
      return set;
     }
	syn int FVariable.booleanInputIndex() =
		myFClass().booleanInputs().indexOf(this);

	syn int FClass.numStringInputs() = stringInputs().size();
	syn lazy ArrayList<FVariable> FClass.stringInputs() {
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(inputs());
      set.retainAll(strings());
      return set;
     }
	syn int FVariable.stringInputIndex() =
		myFClass().stringInputs().indexOf(this);

    syn int FClass.numEquations() = equations().size();
	syn ArrayList<FAbstractEquation> FClass.equations() {
		ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
		for (FEquationBlock b : getFEquationBlocks()) {
			for (FAbstractEquation e : b.getFAbstractEquations()) {
				l.add(e);
			}
		}
		return l;
	}
	
	syn int FClass.numInitialEquations() = initialEquations().size(); 
	syn ArrayList<FAbstractEquation> FClass.initialEquations() {
		ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
		for (FAbstractEquation e : getFInitialEquations()) {
			l.add(e);
		}
		return l;
	}
	
	
	
	
/*	

	coll ArrayList<FVariable> FClass.structuralParameters() [new ArrayList<FVariable>()] with add root FlatRoot;
	FIdUseExp contributes
		(FVariable)myFV() when inArraySubscripts()
	to FClass.structuralParameters() for myFClass();

	coll ArrayList<FEquation> FVariable.variableIncidence() [new ArrayList<FEquation>()] with add root FlatRoot;
    FIdUseExp contributes
		myFEquation() when inFEquation()
	to FVariable.variableIncidence() for (FVariable)myFV();
	
	syn lazy ArrayList<ArrayList> FClass.variableIncidence() {
		ArrayList<ArrayList> l = new ArrayList<ArrayList>();
		for (FVariable fv : variables()) {
           l.add(fv.variableIncidence());
       } 
		return l;
	
	}
	
	inh boolean FExp.inFEquation();
	eq FEquation.getChild().inFEquation()=true;
	eq Root.getChild().inFEquation()=false;
	
	inh FEquation FExp.myFEquation();
	eq FEquation.getChild().myFEquation()=this;
	eq Root.getChild().myFEquation()=null;
*/	
	inh FClass FVariable.myFClass();
	inh FClass FExp.myFClass();
	inh FClass FIdUse.myFClass();
	eq FClass.getChild().myFClass() = this;
	eq Root.getChild().myFClass() = null; 

	syn lazy boolean FVariable.isIndependentConstant() = isConstant();
	syn lazy boolean FVariable.isDependentConstant() = false;
	syn lazy boolean FVariable.isIndependentParameter() = isParameter() &&
 		  (hasBindingExp()? getBindingExp().isConstantExp(): 
 		  (startAttributeSet()? startAttribute().isConstantExp(): true));
	syn lazy boolean FVariable.isDependentParameter() = isParameter() &&
 		  (hasBindingExp()? getBindingExp().isParameterExp(): 
 		  (startAttributeSet()? startAttribute().isParameterExp(): false));
	syn lazy boolean FVariable.isDifferentiatedVariable() = 
	  myFClass().differentiatedRealVariables().contains(this);
	syn lazy boolean FVariable.isAlgebraicVariable() = 
	  myFClass().algebraicRealVariables().contains(this);
}

aspect FlatCausality {

	syn boolean FTypePrefixInputOutput.inputCausality() = false;
	eq FInput.inputCausality() = true;	
	syn boolean FTypePrefixInputOutput.outputCausality() = false;
	eq FOutput.outputCausality() = true;	
	
    syn boolean FVariable.isInput() = 
      hasFTypePrefixInputOutput()? getFTypePrefixInputOutput().inputCausality(): false;    
    syn boolean FVariable.isOutput() = 
      hasFTypePrefixInputOutput()? getFTypePrefixInputOutput().outputCausality(): false;

}

aspect FlatTypes {

	syn boolean FVariable.isReal() = false;
	eq FRealVariable.isReal() = true;
	syn boolean FVariable.isInteger() = false;
	eq FIntegerVariable.isInteger() = true;
	syn boolean FVariable.isBoolean() = false;
	eq FBooleanVariable.isBoolean() = true;
	syn boolean FVariable.isString() = false;
	eq FStringVariable.isString() = true;
		
}

aspect Attributes {


	syn lazy FExp FVariable.startAttribute() {
		for (FAttribute a : getFAttributes()) {
			if (a.getName().name().equals("start")) {
				return a.hasValue()? a.getValue(): null;
			}
		}
		return null;
	}
	
	syn lazy boolean FVariable.startAttributeSet() {
		for (FAttribute a : getFAttributes()) {
			if (a.getName().name().equals("start")) {
				return a.getAttributeSet();
			}
		}
		return false;
	}
}

aspect VariableNumbering {
	/*
	syn int FVariable.variableIndex() 
*/


}


aspect FlatDiagnostics {

	syn String FClass.diagnostics() {
		StringBuffer str = new StringBuffer();
		str.append("Diagnostics for flattened class " + name() + "\n");

		str.append("Number of independent constants:              " + 
		  numIndependentConstants() + "\n");
		str.append("  Number of Real independent constants:       " + 
		  numIndependentRealConstants() + "\n");
		str.append("  Number of Integer independent constants:    " + 
		  numIndependentIntegerConstants() + "\n");
		str.append("  Number of Boolean independent constants:    " + 
		  numIndependentBooleanConstants() + "\n");
		str.append("  Number of String independent constants:     " + 
		  numIndependentStringConstants() + "\n");

		str.append("Number of dependent constants:                " + 
		  numDependentConstants() + "\n");
		str.append("  Number of Real dependent constants:         " + 
		  numDependentRealConstants() + "\n");
		str.append("  Number of Integer dependent constants:      " + 
		  numDependentIntegerConstants() + "\n");
		str.append("  Number of Boolean dependent constants:      " + 
		  numDependentBooleanConstants() + "\n");
		str.append("  Number of String dependent constants:       " + 
		  numDependentStringConstants() + "\n");

		str.append("Number of independent parameters:             " + 
		  numIndependentParameters() + "\n");
		str.append("  Number of Real independent parameters:      " + 
		  numIndependentRealParameters() + "\n");
		str.append("  Number of Integer independent parameters:   " + 
		  numIndependentIntegerParameters() + "\n");
		str.append("  Number of Boolean independent parameters:   " + 
		  numIndependentBooleanParameters() + "\n");
		str.append("  Number of String independent parameters:    " + 
		  numIndependentStringParameters() + "\n");
		  		  
		str.append("Number of dependent parameters:               " + 
		  numDependentParameters() + "\n");
		str.append("  Number of Real dependent parameters:        " + 
		  numDependentRealParameters() + "\n");
		str.append("  Number of Integer dependent parameters:     " + 
		  numDependentIntegerParameters() + "\n");
		str.append("  Number of Boolean dependent parameters:     " + 
		  numDependentBooleanParameters() + "\n");
		str.append("  Number of String dependent parameters:      " + 
		  numDependentStringParameters() + "\n");
		  
		  
		str.append("Number of differentiated variables:           " + 
		  numDifferentiatedRealVariables() + "\n"); 
		  
		str.append("Number of inputs:                             " + 
		  numInputs() + "\n");
		str.append("  Number of Real inputs:                      " + 
		  numRealInputs() + "\n");
		str.append("  Number of Integer inputs:                   " + 
		  numIntegerInputs() + "\n");
		str.append("  Number of Boolean inputs:                   " + 
		  numBooleanInputs() + "\n");
		str.append("  Number of String inputs:                    " + 
		  numStringInputs() + "\n");
		
		str.append("Number of variables :                         " + 
		  numVariables() + "\n");
		str.append("  Number of Real variables:                   " + 
		  numRealVariables() + "\n");
		str.append("  Number of Integer variables:                " + 
		  numIntegerVariables() + "\n");
		str.append("  Number of Boolean variables:                " + 
		  numBooleanVariables() + "\n");
		str.append("  Number of String variables:                 " + 
		  numStringVariables() + "\n");
		
		str.append("Number of algebraic variables :               " + 
		  numAlgebraicVariables() + "\n");
		str.append("  Number of Real algebraic variables:         " + 
		  numAlgebraicRealVariables() + "\n");
		str.append("  Number of Integer algebraic variables:      " + 
		  numAlgebraicIntegerVariables() + "\n");
		str.append("  Number of Boolean algebraic variables:      " + 
		  numAlgebraicBooleanVariables() + "\n");
		str.append("  Number of String algebraic variables:       " + 
		  numAlgebraicStringVariables() + "\n");

		
		str.append("Number of equations:                          " + 
		  numEquations() + "\n");
		
		str.append("Number of variables with binding expression:  " + 
		  numVariablesWithBindingExp() + "\n");
		str.append("  Number of Real variables with binding exp:  " + 
		  numRealVariablesWithBindingExp() + "\n");
		str.append("  Number of Integer variables binding exp:    " + 
		  numIntegerVariablesWithBindingExp() + "\n");
		str.append("  Number of Boolean variables binding exp:    " + 
		  numBooleanVariablesWithBindingExp() + "\n");
		str.append("  Number of String variables binding exp:     " + 
		  numStringVariablesWithBindingExp() + "\n");
		
		
		
		str.append("Total number of equations:                    " + 
		  (numEquations()+numVariablesWithBindingExp()) + "\n");
		
		
		
		str.append("Number of initial equations:                  " + 
		  numInitialEquations() + "\n");
		  
		str.append("\n");
		str.append("Independent constants: {");
		int i = 0;
		for (FVariable fv : independentConstants()) {
			str.append(fv.name());
			if (i<numIndependentConstants()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  
		str.append("Dependent constants: {");
		i = 0;
		for (FVariable fv : dependentConstants()) {
			str.append(fv.name());
			if (i<numDependentConstants()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  
		str.append("Independent parameters: {");
		i = 0;
		for (FVariable fv : independentParameters()) {
			str.append(fv.name());
			if (i<numIndependentParameters()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  
		str.append("Dependent parameters: {");
		i = 0;
		for (FVariable fv : dependentParameters()) {
			str.append(fv.name());
			if (i<numDependentParameters()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  
		str.append("Differentiated variables: {");
		i = 0;
		for (FVariable fv : differentiatedRealVariables()) {
			str.append(fv.name());
			if (i<numDifferentiatedRealVariables()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  
		str.append("Algebraic variables: {");
		i = 0;
		for (FVariable fv : algebraicRealVariables()) {
			str.append(fv.name());
			if (i<numAlgebraicRealVariables()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  
		str.append("Input variables: {");
		i = 0;
		for (FVariable fv : inputs()) {
			str.append(fv.name());
			if (i<numInputs()-1) {
				str.append(", ");
			}
			i++;
		}
		str.append("}\n");  


		return str.toString();
	}






}