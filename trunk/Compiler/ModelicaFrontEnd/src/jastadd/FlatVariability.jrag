/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect FlatVariability {
	
	syn boolean FTypePrefixVariability.constantVariability() = false;
	eq FConstant.constantVariability() = true;	
	syn boolean FTypePrefixVariability.parameterVariability() = false;
	eq FParameter.parameterVariability() = true;	
	syn boolean FTypePrefixVariability.discreteVariability() = false;
	eq FDiscrete.discreteVariability() = true;	
	syn boolean FTypePrefixVariability.continuousVariability() = false;
	eq FContinuous.continuousVariability() = true;	

	syn boolean TypePrefixVariability.constantVariability() = false;
	eq Constant.constantVariability() = true;	
	syn boolean TypePrefixVariability.parameterVariability() = false;
	eq Parameter.parameterVariability() = true;	
	syn boolean TypePrefixVariability.discreteVariability() = false;
	eq Discrete.discreteVariability() = true;	
	syn boolean TypePrefixVariability.continuousVariability() = false;
	eq Continuous.continuousVariability() = true;
	
	
	/**
	 * \brief Test if variablilty is at most the same as <code>other</code>.
	 * 
	 * Uses ordering of variabilities imposed by {@link #variabilityLevel()}.
	 */
	syn boolean FTypePrefixVariability.lessOrEqual(FTypePrefixVariability other) = 
		variabilityLevel() <= other.variabilityLevel();
	
	/**
	 * \brief An ordering of the variability types.
	 * 
	 * To be used by methods for comparing variabilities. 
	 * Should <em>never</em> be compared to literals, only to the return value from other 
	 * FTypePrefixVariability objects. This simplifies adding new variabilities.
	 *  
	 * Also used to determine the behaviour of {@link #combine(FTypePrefixVariability)}.
	 */
	abstract protected int FTypePrefixVariability.variabilityLevel();
	protected int FConstant.variabilityLevel()   { return VARIABILITY_LEVEL; }
	protected int FParameter.variabilityLevel()  { return VARIABILITY_LEVEL; }
	protected int FDiscrete.variabilityLevel()   { return VARIABILITY_LEVEL; }
	protected int FContinuous.variabilityLevel() { return VARIABILITY_LEVEL; }
	protected static final int FConstant.VARIABILITY_LEVEL   = 0;
	protected static final int FParameter.VARIABILITY_LEVEL  = 1;
	protected static final int FDiscrete.VARIABILITY_LEVEL   = 2;
	protected static final int FContinuous.VARIABILITY_LEVEL = 3;
	
	syn boolean FVariable.isConstant() = getFTypePrefixVariability().constantVariability();
    syn boolean FVariable.isParameter() = getFTypePrefixVariability().parameterVariability();
    syn boolean FVariable.isDiscrete() = getFTypePrefixVariability().discreteVariability();
    syn boolean FVariable.isContinuous() = getFTypePrefixVariability().continuousVariability();
    	
	syn boolean InstPrimitive.isConstant() = 
		getComponentDecl().hasTypePrefixVariability()?
		getComponentDecl().getTypePrefixVariability().constantVariability() : false;

	syn boolean InstPrimitive.isParameter() = 
		getComponentDecl().hasTypePrefixVariability()?
		getComponentDecl().getTypePrefixVariability().parameterVariability() : false;

	syn boolean InstPrimitive.isDiscrete() = 
		getComponentDecl().hasTypePrefixVariability()?
		getComponentDecl().getTypePrefixVariability().discreteVariability() : false;

	syn boolean InstPrimitive.isContinuous() = 
		getComponentDecl().hasTypePrefixVariability()?
		getComponentDecl().getTypePrefixVariability().continuousVariability() : true;

		
		
	syn boolean FExp.isConstantExp() = variability().constantVariability();
	syn boolean FExp.isParameterExp() = variability().parameterVariability();
	syn boolean FExp.isDiscreteExp() = variability().discreteVariability();
	syn boolean FExp.isContinuousExp() = variability().continuousVariability();
	
	syn lazy FTypePrefixVariability FExp.variability();
	// TODO this must be fixed.
	eq FInstAccessExp.variability() = getInstAccess().myInstComponentDecl().variability();
	eq FUnsupportedExp.variability() = null;
	
	syn lazy FTypePrefixVariability FVariable.variability() {
   		if (!isContinuous()) {
   			return getFTypePrefixVariability();
   		} else if (isInteger() || isBoolean() || isString()) {
   			/* TODO: Can this really occur?
   			 * This seems to cover the exact same cases as the first if.
   			 */
   			return(fDiscrete());
   		} else {
   			return fContinuous();
   		}
	}
	
	public static FTypePrefixVariability FExp.combineFExpListVariability(Iterable<? extends FExp> exps) {
		FTypePrefixVariability total = fConstant();
		for (FExp exp : exps) 
			total = total.combine(exp.variability());
		return total;
	}
	
	syn lazy FTypePrefixVariability InstComponentDecl.variability() = null;
	eq InstPrimitive.variability() {
		if (isContinuous())
			return fContinuous();
		if (isDiscrete())
			return fDiscrete();
		if (isParameter())
			return fParameter();
		return fConstant();
	}
	
	eq FBinExp.variability() = getLeft().variability().combine(getRight().variability());
	eq FUnaryExp.variability() = getFExp().variability();
	
	eq FLitExp.variability() = fConstant();

	eq FNoExp.variability() = fConstant();
	
	eq FTimeExp.variability() = fContinuous();
	
	eq FEndExp.variability() = fParameter();
	
	eq FMathematicalFunctionCall.variability() = getFExp().variability();
	
	eq FScalar.variability() = getFExp().variability();
	
	eq FTranspose.variability() = getFExp().variability();
	eq FCross.variability() = getX().variability().combine(getY().variability());
	
	eq FAbsExp.variability() = getFExp().variability();
	
	eq FIfExp.variability() {
		FTypePrefixVariability total = getThenExp().variability();
		total = total.combine(combineFExpListVariability(getFElseIfExps()));
		return total.combine(getElseExp().variability());
	}
	
	eq FElseIfExp.variability() = getThenExp().variability();

	eq FSizeExp.variability() = hasDim() ? getDim().variability() : fParameter();
	
	eq FMinMaxExp.variability() {
		FTypePrefixVariability res = getX().variability();
		if (hasY())
			res = res.combine(getY().variability());
		return res;
	}
	
	eq FFunctionCall.variability() = combineFExpListVariability(getArgs());

	eq InstFunctionCall.variability() {
		FTypePrefixVariability total = fConstant();
		for (InstFunctionArgument arg : getArgs()) 
			total = total.combine(arg.getFExp().variability());
		return total;
	}
	
	eq FIdUseExp.variability() {
		AbstractFVariable variable = this.myFV();
		if (variable instanceof FVariable) {
			FVariable fVariable = (FVariable) variable;
			return(fVariable.variability());
		} else {
			return (fContinuous());
		}
	}

	// TODO: Take care of IDENT in range-expr without the 'in rang-expr'
	syn FTypePrefixVariability FForIndex.variability() {
		if (hasFExp()) {
			return getFExp().variability();
		} else {
			return null;
		}
	}

	eq FRangeExp.variability() = combineFExpListVariability(getFExps());
	
	eq FArray.variability()      = combineFExpListVariability(getFExps());
	eq FParseArray.variability() = combineFExpListVariability(getFExps());
	
	eq FIterExp.variability() = getFExp().variability();
	eq FSumExp.variability()  = getFExp().variability();
	
	eq FSubscriptedExp.variability()  = combineFExpListVariability(getArray().iterable());
	
	eq FNoEventExp.variability() = getFExp().variability();
	eq FIdentity.variability() = fConstant();
	eq FOnes.variability() = fConstant();
	eq FZeros.variability() = fConstant();
	eq FFillExp.variability() = getFillExp().variability();
	
   	public FTypePrefixVariability FTypePrefixVariability.combine(FTypePrefixVariability other) {   			
   		if (this instanceof FContinuous) {
   			return this;
   		} else if (other instanceof FContinuous) {
   			return other;
   		// neither is a continuous variable
   		} else if (this instanceof FDiscrete) {
   			return this;
   		} else if (other instanceof FDiscrete) {
   			return other;
   	   		// neither is a continuous variable or discrete variable   			
   		} else if (this instanceof FParameter) {
   			return this;
   		} else if (other instanceof FParameter) {
   			return other;
   		// neither is a continuous variable, discrete variable, or a parameter value
   		} else {
   			return this;
   		}
	}	
	
}

aspect VariabilitySingletons {
	
	public static final FContinuous FContinuous.singleton = new FContinuous();	
	public static final FDiscrete FDiscrete.singleton = new FDiscrete();	
	public static final FParameter FParameter.singleton = new FParameter();
	public static final FConstant FConstant.singleton = new FConstant();	
	
	public static FContinuous ASTNode.fContinuous() {
		return FContinuous.singleton;
	}

	public static FDiscrete ASTNode.fDiscrete() {
		return FDiscrete.singleton;
	}	

	public static FParameter ASTNode.fParameter() {
		return FParameter.singleton;
	}
	
	public static FConstant ASTNode.fConstant() {
		return FConstant.singleton;
	}
}

