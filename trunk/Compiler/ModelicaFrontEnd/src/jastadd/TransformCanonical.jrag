/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Queue;
import java.util.Stack;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Collections;
import java.util.Iterator;


/* This causes conflicts
import org.jmodelica.graphs.EquationSystem;
import org.jmodelica.graphs.Equation;
import org.jmodelica.graphs.Variable;
*/

/**
 * \brief Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

	/**
	 * \brief Transform the raw flattened model into a structured form.
	 * 
	 * Currently, the following operations are performed:
	 *  <ul>
	 *    <li> Binding equations for variables are converted into regular
	 *         equations by calling genBindingEquations().
	 *    <li> For each non-function algorithm:
	 *         <ul>
	 *           <li> A function is generated with the algorithm as body, 
	 *                any assigned variables as outputs and any used 
	 *                variables as inputs.
	 *           <li> The original algorithm is replaced with a call to 
	 *                the generated function.
	 *         </ul>
	 *    <li> The model is scalarized, i.e., all array declarations and
	 *         equations are replaced by scalar declarations and equations
	 *    <li> Alias variables are eliminated from the model.
	 *    <li> Derivative variables are generated and inserted in the
	 *         list of FVariables by calling addFDerivativeVariables().
	 *    <li> Generate initial equations based on start attribute.
	 *    <li> Sort dependent parameters.
	 *  </ul>
	 */
	 
	 /**
	  *  transformCanonicalBase contains all transformation that should be
	  *  done by both the Modelica and the Optimica compilers.
	  */
	public void FClass.transformCanonicalBase() {
		addStateInitialEquationsIfSet();
		genAlgorithmFunctions();
		genBindingEquations();
		scalarize();
		genInitArrayStatements();
        enableIfEquationElimination();
		functionInliningIfSet();
		aliasEliminationIfSet();
		addFDerivativeVariables();
		addFPreVariables();
        enableIfEquationRewrite();
		enableWhenEquationRewrite();
		root().flushAllRecursive();
		genInitialEquations();
		sortDependentParameters();
	}
	
	public void FClass.transformCanonicalCleanup() {
		removeUnusedFunctions();
	    root().flushAllRecursive();
	}

	public void FClass.transformCanonical() {
    	beginStep("transformCanonical()");

		transformCanonicalBase();

		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			// Equations are added as part of this this method
			computeMatchingsAndBLT();			
		}
	    
	   	root().flushAllRecursive();	
	    
	    if (root().options.getBooleanOption("enable_tearing")) {
			// Equations are added as part of this this method
			//computeTearings();
		}
	    
	    transformCanonicalCleanup();
    	endStep("transformCanonical()");
	}
		
	public class BLT extends ArrayList<AbstractEquationBlock> {
	
		private FClass fclass;
		
		public BLT(FClass fclass) {
			this.fclass = fclass;	
		}
	
		public FClass getFClass() {
			return fclass;	
		}
	
		public ArrayList<Integer> unsolvedBlockSizes() {
			ArrayList<Integer> blockSizes = new ArrayList<Integer>();
			for (AbstractEquationBlock b : this) {
				if (!b.isSolvable()) {
					blockSizes.add(new Integer(b.activeVariables().size()));
				}		
			}
			return blockSizes;
		}

		public ArrayList<Integer> unsolvedBlockIterationSizes() {
			ArrayList<Integer> blockSizes = new ArrayList<Integer>();
			for (AbstractEquationBlock b : this) {
				if (!b.isSolvable()) {
					blockSizes.add(new Integer(b.iterationVariables().size()));
				}		
			}
			return blockSizes;
		}

		public void reset() {
			for (AbstractEquationBlock eb : this) {
				eb.reset();
			}	
		}

		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("-------------------------------\n");
			for (AbstractEquationBlock eb : this) {
				str.append(eb.toString());
				str.append("-------------------------------\n");
			}
			return str.toString();
		}
		
	}
	
	public class StructuredBLT extends BLT {
		private ArrayList<AbstractEquationBlock> topEquationBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> allBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> odeBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> realOutputBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> integerBooleanOutputBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> otherBlocks = new ArrayList<AbstractEquationBlock>();
		
		public StructuredBLT(FClass fclass) {
			super(fclass);	
		}
		
		public StructuredBLT(FClass fclass, BLT blt) {
			super(fclass);
			for (AbstractEquationBlock eb : blt) {
				this.add(eb);
				eb.setDAEPredecessors();
				if (eb.getPredecessors().size() == 0) {
					topEquationBlocks.add(eb);
				}
			}

			reset();
			// Loop over all derivatives
			for (FVariable fv : getFClass().derivativeVariables()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				if (!eb.isVisited()) {
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							odeBlocks.add(ebb);
						}
					}
					odeBlocks.add(eb);
				}
			}
			
			// Loop over all real outputs
			for (FVariable fv : getFClass().realOutputs()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				//States and inputs can be outputs in which case they don't have equation blocks associated with them
				if (eb!=null && !eb.isVisited()) { 
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							realOutputBlocks.add(ebb);
						}
					}
					realOutputBlocks.add(eb);
				}	
			}

			// Loop over integer and boolean outputs
			for (FVariable fv : getFClass().outputs()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				if (eb!=null && !eb.isVisited()) {
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							integerBooleanOutputBlocks.add(ebb);
						}
					}
					integerBooleanOutputBlocks.add(eb);
				}	
			}

			// Loop over all others
			for (FVariable fv : getFClass().variables()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				if (eb!=null && !eb.isVisited()) {
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							otherBlocks.add(ebb);
						}
					}
					otherBlocks.add(eb);
				}	
			}
			
			allBlocks.addAll(odeBlocks);
			allBlocks.addAll(realOutputBlocks);
			allBlocks.addAll(integerBooleanOutputBlocks);
			allBlocks.addAll(otherBlocks);

		}

	    public ArrayList<AbstractEquationBlock> getAllBlocks() {
			return allBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getOdeBlocks() {
			return odeBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getRealOutputBlocks() {
			return realOutputBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getIntegerBooleanOutputBlocks() {
			return integerBooleanOutputBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getOtherBlocks() {
			return otherBlocks;
		}

		public String printGraphPython() {
			StringBuffer str = new StringBuffer();
			str.append("##############################\n");
			int max_depth = 0;
			HashMap<String,ArrayList<AbstractEquationBlock>> map = new HashMap<String,ArrayList<AbstractEquationBlock>>();
			for (AbstractEquationBlock eb : allBlocks) {
				int d = eb.depth();
				if (d>max_depth) {
					max_depth = d;
				}
				if (map.get("" + d)==null) {
					map.put("" + d,new ArrayList<AbstractEquationBlock>());
				}
				map.get("" + d).add(eb);	
			}
			str.append("blocks={\n");
			int l = 0;
			
//			for (String key : map.keySet()) {
			for (int i=0;i<=max_depth;i++) {
				String key = "" + i;
				int k=0;
				str.append(key + ":[");
				for (AbstractEquationBlock eb : map.get(key)) {
					str.append("{'index':" + allBlocks.indexOf(eb) + ",'depth':" + l + ",'pred':" + "[" );
					int j = 0;
					for (AbstractEquationBlock peb : eb.getPredecessors()) {
						str.append(allBlocks.indexOf(peb));	
						if (j<eb.getPredecessors().size()-1) {
							str.append(",");
						}
						j++;
					}
					str.append("]}");
					if (k<map.get(key).size()-1) {
						str.append(",\n");
					}
					k++;
				}	
				str.append("]");
				if (l<max_depth) {
					str.append(",\n");
				}
				l++;		
			}	

			str.append("}\n");
			str.append("##############################");
			return str.toString();
		}

		public String toString() {
			
			HashSet<FVariable> solvedVars = new HashSet<FVariable>();
			
			int n_blocks = 0;
			/*
			for (AbstractEquationBlock eb : getOdeBlocks()) {
				n_blocks++;
				for (FVariable fv : eb.activeVariables()) {
					System.out.println("'" + fv.name() + "',");
				}
				for (FVariable fv : eb.inactiveVariables()) {
					if (!solvedVars.contains(fv)) {
						System.out.println("ERRROR:");
						System.out.println("Variable:");
						System.out.println(fv);
						System.out.println("needed by block:");
						System.out.println(eb.toStringVerbose());
						System.out.println("have not been solved");
					}							
				}
				solvedVars.addAll(eb.activeVariables());
			}
			
			for (AbstractEquationBlock eb : getOtherBlocks()) {
				n_blocks++;
				for (FVariable fv : eb.inactiveVariables()) {
					if (!solvedVars.contains(fv)) {
						System.out.println("ERRROR:");
						System.out.println("Variable:");
						System.out.println(fv);
						System.out.println("needed by block:");
						System.out.println(eb.toStringVerbose());
						System.out.println("have not been solved");
					}							
				}
				solvedVars.addAll(eb.activeVariables());
			}
			
			System.out.println("Number of blocks in generated code: " + n_blocks +  
			" Total number of blocks: " + size());
			*/

			StringBuffer str = new StringBuffer();
			str.append("************* Structured BLT*********\n");
			str.append("***********************************\n");	
			str.append("************* ODE section *********\n");	
			str.append("***********************************\n");	
			// Loop over all derivatives
			for (AbstractEquationBlock eb : getOdeBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}
			str.append("***********************************\n");	
			str.append("************ Real outputs *********\n");	
			str.append("***********************************\n");	
			for (AbstractEquationBlock eb : getRealOutputBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}
			str.append("***********************************\n");	
			str.append("****Integer and boolean outputs ***\n");	
			str.append("***********************************\n");	
			for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}
			str.append("***********************************\n");	
			str.append("**** Other variables ***\n");	
			str.append("***********************************\n");	
			for (AbstractEquationBlock eb : getOtherBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}

//			str.append(">>\n\n\n");
//			str.append(printGraphPython());

			return str.toString();
		}
	}

	/**
	 * Abstract class for equation blocks resulting from the BLT transformation
	 */
	public abstract class AbstractEquationBlock {
	
		private LinkedHashSet<AbstractEquationBlock> predecessors = new LinkedHashSet<AbstractEquationBlock>();
		private LinkedHashSet<AbstractEquationBlock> successors = new LinkedHashSet<AbstractEquationBlock>();
		private LinkedHashSet<FVariable> dependsOnVariables = null; 
	    private boolean visited = false;
	    
		private boolean predecessorsSet = false;
	
		public abstract ArrayList<FAbstractEquation> equations();
		
		/*
		 * The active variables are assigned their values when the block is solved.
		 */
		public abstract ArrayList<FVariable> activeVariables();

		/* 
		 * These are the variables that are solved for if an iterative
		 * Newton solver is applied. This set is not necessarily identical
		 * to the set of active variables, e.g., in the case of torn
		 * or mixed blocks.
		 */ 
		public ArrayList<FVariable> iterationVariables() {
			return activeVariables();
		}
		
		public ArrayList<FVariable> inactiveVariables() {
			ArrayList<FVariable> s = new ArrayList<FVariable>();
			for (FAbstractEquation e : equations()) {
				s.addAll(e.algebraicVariables());
				s.addAll(e.derivativeVariables());	
			}
			s.removeAll(activeVariables());
			return s;	
		}		

		public ArrayList<FVariable> independentVariables() {
			ArrayList<FVariable> s = new ArrayList<FVariable>();
			for (FAbstractEquation e : equations()) {
				s.addAll(e.inputs());
				s.addAll(e.differentiatedVariables());	
				s.addAll(e.discretePreVariables());	
			}
			return s;
		}		
		
		public abstract boolean isSolvable();
		
		public void setDAEPredecessors() {
			if (!predecessorsSet) {
				for (FVariable fv : inactiveVariables()) {
					if (!predecessors.contains(fv.myDAEEquationBlock())) {
						predecessors.add(fv.myDAEEquationBlock());
					}
					if (!fv.myDAEEquationBlock().getSuccessors().contains(this)) {
						fv.myDAEEquationBlock().getSuccessors().add(this);
					}
					fv.myDAEEquationBlock().setDAEPredecessors();
				}
				predecessorsSet = true;
			}		
		}
		
		public LinkedHashSet<FVariable> dependsOn() {
			if (this.dependsOnVariables==null) {
				dependsOnVariables = new LinkedHashSet<FVariable>();
				dependsOnVariables.addAll(independentVariables());
				for (AbstractEquationBlock eb : getPredecessors()) {
					dependsOnVariables.addAll(eb.dependsOn());
				}
			}
			return dependsOnVariables;
		}
				
		public boolean isMixed() {
			for (FAbstractEquation e : equations()) {
				if (e.isDiscrete()) {
					return true;
				}	
			}	
			return false;
		}
		
		public ArrayList<FAbstractEquation> differentiatedEquations() {
			ArrayList<FAbstractEquation> diffedEq = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation e : equations()) {
				if (e.getMeIntegrated()!=null) {
					diffedEq.add(e);
				}
			}
			return diffedEq;
		}

		public ArrayList<AbstractEquationBlock> getAllPredecessors() {
			ArrayList<AbstractEquationBlock> allPredecessors = new ArrayList<AbstractEquationBlock>(); 
			for (AbstractEquationBlock eb : getPredecessors()) {
				for (AbstractEquationBlock ebb : eb.getAllPredecessors()) {
					if (!allPredecessors.contains(ebb)) {
						allPredecessors.add(ebb);
					}
				}
				if (!allPredecessors.contains(eb)) {
					allPredecessors.add(eb);
				}
			}
			return allPredecessors;
		}	
		
		public LinkedHashSet<AbstractEquationBlock> getPredecessors() {
			return predecessors;
		}	

		public LinkedHashSet<AbstractEquationBlock> getSuccessors() {
			return successors;
		}	
		
		public boolean isPredecessorsSet() {
			return predecessorsSet;
		}
	
		public int depth() {
			int max_predecessor_depth = -1;
			for (AbstractEquationBlock eb : getAllPredecessors()) {
				int d = eb.depth();
				if (d>max_predecessor_depth) {
					max_predecessor_depth = d;
				}
			}
			return max_predecessor_depth + 1;
		}
	
		public boolean isVisited() {
			return visited;
		}
		
		public void setVisited(boolean visited) {
			this.visited = visited;	
		}
		
		public void reset() {
			visited  = false;	
		}
		
		public String toStringVerbose() {	
			StringBuffer str = new StringBuffer();
			str.append("**** Block ****\n");
			str.append(toString());
			str.append("**** Depends on ****\n");
			for (FVariable fv : dependsOn()) {
				str.append(fv.prettyPrint("") + "\n");
			} 
			str.append("**** Inactive variables ****\n");
			for (FVariable fv : inactiveVariables()) {
				str.append(fv.prettyPrint("") + "\n");
			} 
/*			str.append("**** Predecessors ****\n");
			for (AbstractEquationBlock eb : getPredecessors()) {
				str.append(eb.toString());
				str.append("---------\n");
			}
			str.append("**** All Predecessors ****\n");
			for (AbstractEquationBlock eb : getAllPredecessors()) {
				str.append(eb.toString());
				str.append("---------\n");
			}
			str.append("**** Successors ****\n");
			for (AbstractEquationBlock eb : getSuccessors()) {
				str.append(eb.toString());
				str.append("---------\n");
			}*/
		    str.append("**** Block ends ****\n");				
			return str.toString();
		}
	
		protected ArrayList<FAbstractEquation> equationList(
				ArrayList<MatchingPair> mps, MatchingPairFilter mpf) {
			Set<FAbstractEquation> s = new LinkedHashSet<FAbstractEquation>();
			for (MatchingPair mp : mps) {
				if (mpf.filter(mp))
					s.add(mp.getEquation());
			}
			ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>(s.size());
			l.addAll(s);
			return l;
		}
		
		protected ArrayList<FVariable> variableList(
			ArrayList<MatchingPair> mps, MatchingPairFilter mpf) {
			ArrayList<FVariable> l = new ArrayList<FVariable>();
			for (MatchingPair mp : mps) {
				if (mpf.filter(mp))
					l.add(mp.getFVariable());
			}
			return l;
		}
		
		protected interface MatchingPairFilter {
			public boolean filter(MatchingPair mp);
		}
		
		protected MatchingPairFilter ALL_MATCHING_PAIR_FILTER = new MatchingPairFilter() {
			public boolean filter(MatchingPair mp) {
				return true;
			}
		};
		
		
		public abstract String toString();
		
		public boolean mergeBlock(AbstractEquationBlock block) {
			return false;
		}
	
	}

   /**
    * SimpleEquationBlock is the base class of ScalarEquationBlock, FunctionCallEquationBlock
    * and WhenEquationBlock.
    */
   public abstract class SimpleEquationBlock extends AbstractEquationBlock {}

	/**
	 * EquationBlock is a general block that may contain one or more
	 * non-solved equations.
	 */
	public class EquationBlock extends AbstractEquationBlock {
		
		protected ArrayList<SimpleEquationBlock> blocks = new ArrayList<SimpleEquationBlock>();
		
		public EquationBlock(ArrayList<SimpleEquationBlock> blocks) {
			for (SimpleEquationBlock block : blocks)
				addBlock(block);
		}
				
		public void addBlock(SimpleEquationBlock b) {
			for (SimpleEquationBlock block : blocks) {
				if (block.mergeBlock(b))
					return;
			}
			blocks.add(b);
		}	
		
		public ArrayList<FVariable> activeVariables() {
			ArrayList<FVariable> l = new ArrayList<FVariable>();
			for (SimpleEquationBlock sb : blocks) {
				l.addAll(sb.activeVariables());
			}
			return l;
			//return variableList(matchingPairs, ALL_MATCHING_PAIR_FILTER);
		}		

		public ArrayList<FAbstractEquation> equations() {
			ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (SimpleEquationBlock sb : blocks) {
				l.addAll(sb.equations());
			}
			return l;
			//return equationList(matchingPairs, ALL_MATCHING_PAIR_FILTER);
		}
		
		public boolean isSolvable() {
			return false;	
		}
				
		public boolean containsDerivative() {
			for (FVariable fv : activeVariables()) {
				if (fv.isDerivativeVariable()) {
					return true;
				}
			}
			return false;
		}				
					  						
		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("Non-solved block of " + activeVariables().size() + " variables:\n");
			str.append("Unknown variables:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Equations:\n");
			for (FAbstractEquation feq : equations()) {
				str.append("  " + feq.prettyPrint("") + "\n");	
			}
			
			/*		
			str.append("---- Block Jacobian:\n");
			for (FAbstractEquation feq  : equations()) {
				int j = 0;
				str.append(feq.prettyPrint("") + "\n");
				for (FVariable fv : activeVariables()) {
					FExp dl = ((FEquation)feq).getLeft().dynamicFExp(((FEquation)feq).getLeft().diff(fv.name()));
					FExp dr = ((FEquation)feq).getRight().dynamicFExp(((FEquation)feq).getRight().diff(fv.name()));
					if (!(dl.variability().lessOrEqual(feq.fConstant()) && 
					    dl.ceval().realValue()==0. &&
					    dr.variability().lessOrEqual(feq.fConstant()) && 
					    dr.ceval().realValue()==0.)) {
						str.append("  " + fv.name() + " " + dl.prettyPrint("") + 
						              " - " + dr.prettyPrint("") + "\n");
					}
				}
			}
			*/
			return str.toString();
		}
	
	}

	/**
	 * LinearEquationBlock is a system of equations that may contain one or more
	 * non-solved equations, all of wich are linear in the active variables.
	 */
	public class LinearEquationBlock extends EquationBlock {

		private FExp[][] jacobian;
		private FTypePrefixVariability blockVariability;

		public LinearEquationBlock(ArrayList<SimpleEquationBlock> blocks) {
			super(blocks);
			
			// Compute Jacobian
			jacobian = new FExp[equations().size()][equations().size()];
			int row = 0;
			int col = 0;
			blockVariability = activeVariables().get(0).fConstant();
			for (FAbstractEquation fe : equations()) {
				col = 0;
				for (FVariable fv : activeVariables()) {
					FExp l = ((FEquation)fe).getLeft();
					FExp r = ((FEquation)fe).getRight();
					FExp dl = l.dynamicFExp(l.diff(fv.name()));
					FExp dr = r.dynamicFExp(r.diff(fv.name()));
					boolean lz = dl.equalsRealValue(0);
					boolean rz = dr.equalsRealValue(0);
					FExp je;
					if (rz && lz) {
						je = r.dynamicFExp(new FRealLitExp(0.0));
					} else if (lz) {
						je = r.dynamicFExp(new FNegExp(dr));
					} else if (rz) {
						je = dl;
					} else {
						je = r.dynamicFExp(new FSubExp(dl,dr));
					}
					if (!je.variability().lessOrEqual(blockVariability)) {
						blockVariability = je.variability();
					}
					jacobian[row][col] = je;
					col++;
				}	
				row++;
			}
		}

		public FTypePrefixVariability variability() {
			return blockVariability;	
		}
	
		public boolean isConstant() {
			return blockVariability.constantVariability();
		}

		public boolean isParameter() {
			return blockVariability.parameterVariability();
		}

		public boolean isDiscrete() {
			return blockVariability.discreteVariability();
		}

		public boolean isContinuous() {
			return blockVariability.continuousVariability();
		}
	
		public FExp[][] getJacobian() {
			return jacobian;	
		}
	
		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("Non-solved linear block of " + activeVariables().size() + " variables:\n");
			str.append("Coefficient variability: " + (isConstant()? "Constant":
			                                          isParameter()? "Parameter":
			                                          isDiscrete()? "Discrete":
			                                          isContinuous()? "Continuous":
			                                          "Unknown") + "\n");
			str.append("Unknown variables:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Equations:\n");
			for (FAbstractEquation feq : equations()) {
				str.append("  " + feq.prettyPrint("") + "\n");	
				//str.append("    Is linear: " + feq.checkLinearity(new HashSet<FVariable>(activeVariables())) + "\n");					
			}
					
			str.append("Jacobian:\n");
			for (int col=0;col<equations().size();col++) {
				str.append("  |");
				for (int row=0;row<equations().size();row++) {
					str.append(jacobian[col][row].prettyPrint(""));
					if (row<equations().size()-1) {
						str.append(", ");	
					}
				}
				str.append("|\n");
			}
			
			/*
			str.append("---- Block Jacobian:\n");
			for (FAbstractEquation feq  : equations()) {
				int j = 0;
				str.append(feq.prettyPrint("") + "\n");
				for (FVariable fv : activeVariables()) {
					FExp dl = ((FEquation)feq).getLeft().dynamicFExp(((FEquation)feq).getLeft().diff(fv.name()));
					FExp dr = ((FEquation)feq).getRight().dynamicFExp(((FEquation)feq).getRight().diff(fv.name()));
					if (!(dl.variability().lessOrEqual(feq.fConstant()) && 
					    dl.ceval().realValue()==0. &&
					    dr.variability().lessOrEqual(feq.fConstant()) && 
					    dr.ceval().realValue()==0.)) {
						str.append("  " + fv.name() + " " + dl.prettyPrint("") + 
						              " - " + dr.prettyPrint("") + "\n");
					}
				}
			}
			*/
			return str.toString();
		}


	}

	/**
	 * MixedEquationBlock is a general block that may contain 
	 * non-solved equations and which contains both continous
	 * and discrete equations.
	 */
	public class MixedEquationBlock extends EquationBlock {
		
		public MixedEquationBlock(ArrayList<SimpleEquationBlock> blocks) {
			super(blocks);	
		}
		
		
		/*
		protected MatchingPairFilter REAL_MATCHING_PAIR_FILTER = new MatchingPairFilter() {
			public boolean filter(MatchingPair mp) {
				return mp.getFVariable().isReal();
			}
		};
		
		protected MatchingPairFilter NON_REAL_MATCHING_PAIR_FILTER = new MatchingPairFilter() {
			public boolean filter(MatchingPair mp) {
				return !mp.getFVariable().isReal();
			}
		};
		*/
		
		public ArrayList<FVariable> activeContinuousVariables() {
			ArrayList<FVariable> l = new ArrayList<FVariable>();
			for (FVariable fv : activeVariables()) {
				if (fv.isReal()) {
					l.add(fv);
				}
			}
			return l;
			//return variableList(matchingPairs, REAL_MATCHING_PAIR_FILTER);
		}		

		public ArrayList<FVariable> activeDiscreteVariables() {
			ArrayList<FVariable> l = new ArrayList<FVariable>();
			for (FVariable fv : activeVariables()) {
				if (!fv.isReal()) {
					l.add(fv);
				}
			}
			return l;			
			//return variableList(matchingPairs, NON_REAL_MATCHING_PAIR_FILTER);
		}		

		public ArrayList<FAbstractEquation> continuousEquations() {
			ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (SimpleEquationBlock sb : blocks) {
				for (FAbstractEquation e : sb.equations()) {
					if (!e.isDiscrete()) {
						l.add(e);
					}	
				}
			}
			return l;
			//return equationList(matchingPairs, REAL_MATCHING_PAIR_FILTER);
		}

		public ArrayList<FAbstractEquation> discreteEquations() {
			ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (SimpleEquationBlock sb : blocks) {
				for (FAbstractEquation e : sb.equations()) {
					if (e.isDiscrete()) {
						l.add(e);
					}	
				}
			}
			return l;			
			//return equationList(matchingPairs, NON_REAL_MATCHING_PAIR_FILTER);
		}
									  						
		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("Mixed non-solved block of " + activeVariables().size() + " variables:\n");
			str.append("Unknown continuous variables:\n");
			for (FVariable fv : activeContinuousVariables()) {
				str.append("  " + fv.name() + "\n");
			}
			str.append("Unknown discrete variables:\n");
			for (FVariable fv : activeDiscreteVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Continuous equations:\n");
			for (FAbstractEquation feq : continuousEquations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}
			str.append("Discrete equations:\n");
			for (FAbstractEquation feq : discreteEquations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}
			return str.toString();
		}
	}

	/**
	 * ScalarEquationBlock represents a scalar equation. Base class for
	 * SolvedScalarEquationBlock and UnsolvedScalarEquationBlock.
	 */
	public class ScalarEquationBlock extends SimpleEquationBlock {
		protected FEquation eqn;
		protected FVariable fv;
		
		public ScalarEquationBlock(FEquation eqn, FVariable fv) {
			this.eqn = eqn;
			this.fv = fv;
		}
		
		public boolean isSolvable() {
			return eqn.isSolved(fv.name());
		}
		
		public ArrayList<FAbstractEquation> equations() {
			ArrayList<FAbstractEquation> s = new ArrayList<FAbstractEquation>();
			s.add(eqn);
			return s;
		}
		
		public ArrayList<FVariable> activeVariables() {
			ArrayList<FVariable> s = new ArrayList<FVariable>();
			s.add(fv);
			return s;
		}
		
		public boolean printStarted = false;

		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("Non-solved block of " + activeVariables().size() + " variables:\n");
			str.append("Unknown variables:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Equations:\n");
			for (FAbstractEquation feq : equations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}
			return str.toString();
		}	
				
	}
	
	/**
	 * SolvedScalarEquationBlock represents a solved scalar equation. 
	 */
	public class SolvedScalarEquationBlock extends ScalarEquationBlock {

		public SolvedScalarEquationBlock(FEquation eqn, FVariable fv) {
			super(eqn, fv);
		}

		public FExp solution() {
			return eqn.solution(fv.name());
		}
		
		public String toString() {
			
			StringBuffer str = new StringBuffer();
			str.append("Solved block of " + activeVariables().size() + " variables:\n"); 
			str.append("Computed variable:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Solution:\n");
			str.append("  " + solution().prettyPrint("") + "\n");
			return str.toString();
		}
		
	}

	/**
	 * UnscalarEquationBlock represents a solved scalar equation. 
	 */
	public class UnsolvedScalarEquationBlock extends ScalarEquationBlock {
		
		public UnsolvedScalarEquationBlock(FEquation eqn, FVariable fv) {
			super(eqn, fv);
		}	
		
	}

	/**
	 * FunctionCallEquationBlock serves as a base class for SolvedFunctionCallEquationBlock
	 * and UnsolvedFunctionCallEquationBlock.
	 */
	public abstract class FunctionCallEquationBlock extends SimpleEquationBlock {
		protected FFunctionCallEquation functionCallEquation;
		protected Collection<FVariable> activeVars = new LinkedHashSet<FVariable>();
		
		public FunctionCallEquationBlock(FFunctionCallEquation eqn, ArrayList<FVariable> activeVars) {
			this.functionCallEquation = eqn;
			this.activeVars.addAll(activeVars);
		}
		
		public boolean isSolvable() {
			return false;
		}
				
		public ArrayList<FAbstractEquation> equations() {
			ArrayList<FAbstractEquation> s = new ArrayList<FAbstractEquation>();
			s.add(functionCallEquation);
			return s;
		}
		
		public ArrayList<FVariable> activeVariables() {
			ArrayList<FVariable> s = new ArrayList<FVariable>();
			s.addAll(activeVars);
			return s;
		}
		
		public boolean printStarted = false;

		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("Non-solved block of " + activeVariables().size() + " variables:\n");
			str.append("Unknown variables:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Equations:\n");
			for (FAbstractEquation feq : equations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}			
			return str.toString();
		}	
		
		public boolean mergeBlock(AbstractEquationBlock block) {
			if (!(block instanceof FunctionCallEquationBlock))
				return false;
			
			FunctionCallEquationBlock fceb = (FunctionCallEquationBlock) block;
			
			if (functionCallEquation != fceb.functionCallEquation)
				return false;
			
			activeVars.addAll(fceb.activeVars);
			return true;
		}
	}	


	/*
	 * A solved function call equation.
	 */
	public class SolvedFunctionCallEquationBlock extends FunctionCallEquationBlock {
		
		public SolvedFunctionCallEquationBlock(FFunctionCallEquation eqn, ArrayList<FVariable> activeVariables) {
			super(eqn, activeVariables);
		}
		
		public boolean isSolvable() {
			return true;
		}
		
		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("Solved block of " + activeVariables().size() + " variables:\n");
			str.append("Unknown variables:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Equations:\n");
			for (FAbstractEquation feq : equations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}
			return str.toString();
		}	
		
	}

	/** 
	 * An unsolved function call equation
	 */
	public class UnsolvedFunctionCallEquationBlock extends FunctionCallEquationBlock {
		
		public UnsolvedFunctionCallEquationBlock(FFunctionCallEquation eqn, ArrayList<FVariable> activeVariables) {
			super(eqn, activeVariables);
		}
			
	}

	/**
	 * A when equation block.
	 */
	public class WhenEquationBlock extends SimpleEquationBlock {
		protected FWhenEquation whenEquation;
		// One list of blocks for each when branch
		protected ArrayList<ArrayList<SimpleEquationBlock>> blocks = new ArrayList<ArrayList<SimpleEquationBlock>>(); 
		protected ArrayList<FVariable> fvars = new ArrayList<FVariable>();
				
		public WhenEquationBlock(FWhenEquation whenEquation) {
			this.whenEquation = whenEquation;
		
			blocks.add(new ArrayList<SimpleEquationBlock>());		
			for (FAbstractEquation eqn : whenEquation.getFAbstractEquations()) {
				ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
				ArrayList<FVariable> fvs = new ArrayList<FVariable>();
				eqns.add(eqn);
				for (FIdUseExp e : eqn.simpleLefts()) {
					fvs.add((FVariable)e.myFV());
				}
				fvars.addAll(fvs);
				blocks.get(0).add(EquationBlockFactory.createSimpleEquationBlock(eqns,fvs,true));
			}
			
			// TODO: handle else when clauses 
		}
		
		public boolean isSolvable() {
        	return true;
		}
		
		public ArrayList<FAbstractEquation> equations() {
			ArrayList<FAbstractEquation> s = new ArrayList<FAbstractEquation>();
			s.add(whenEquation);
			return s;
		}
		
		public ArrayList<FVariable> activeVariables() {
			ArrayList<FVariable> s = new ArrayList<FVariable>();
			for (FVariable fv : fvars) {
				s.add(fv);
			}
			return s;
		}
		
		public boolean printStarted = false;

		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("When equation block of " + activeVariables().size() + " variables:\n");
			str.append("Unknown variables:\n");
			for (FVariable fv : activeVariables()) {
				str.append("  " + fv.name() + "\n");
			}
/*			str.append("Inactive variables:\n");
			for (FVariable fv : inactiveVariables()) {
				str.append("  " + fv.name() + "\n");
			}*/
			str.append("Equations:\n");
			for (FAbstractEquation feq : equations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}
			return str.toString();
		}	
			
		ArrayList<SimpleEquationBlock> blocks(int i) {
			return blocks.get(i);	
		}
				
	}

	/**
	 * TornEquationBlock represents an equation block resulting from tearing.
	 */
	public class TornEquationBlock extends AbstractEquationBlock {
		private ArrayList<SimpleEquationBlock> solvedBlocks = new ArrayList<SimpleEquationBlock>();
		private ArrayList<SimpleEquationBlock> unsolvedBlocks = new ArrayList<SimpleEquationBlock>();
		
		public TornEquationBlock() {
		}
		
		public void addSolvedBlock(SimpleEquationBlock aeb) {
			if (!solvedBlocks.isEmpty() && solvedBlocks.get(solvedBlocks.size() - 1).mergeBlock(aeb))
				return;
			solvedBlocks.add(aeb);
		}
		
		public java.util.List<SimpleEquationBlock> getSolvedBlocks() {
			return solvedBlocks;
		}
		
		public void addUnsolvedBlock(SimpleEquationBlock aeb) {
			if (!unsolvedBlocks.isEmpty() && unsolvedBlocks.get(unsolvedBlocks.size() - 1).mergeBlock(aeb))
				return;
			unsolvedBlocks.add(aeb);
		}
		
		public java.util.List<SimpleEquationBlock> getUnsolvedBlocks() {
			return unsolvedBlocks;
		}

		public ArrayList<FAbstractEquation> unsolvedEquations() {
			ArrayList<FAbstractEquation> eqs = new ArrayList<FAbstractEquation>();
			for (AbstractEquationBlock block : unsolvedBlocks) {
				eqs.addAll(block.equations());
			}
			return eqs;
		}

		public ArrayList<FAbstractEquation> solvedEquations() {
			ArrayList<FAbstractEquation> eqs = new ArrayList<FAbstractEquation>();
			for (AbstractEquationBlock block : solvedBlocks) {
				eqs.addAll(block.equations());
			}
			return eqs;
		}

		public ArrayList<FAbstractEquation> equations() {
			// Sort out any duplicated equations that has been introduced from records...
			// TODO: This should probably be handled in the compute_tearing() method..
			ArrayList<FAbstractEquation> s = new ArrayList<FAbstractEquation>();
			FAbstractEquation prev = null;
			for (FAbstractEquation e : solvedEquations()) {
				if (e != prev)
					s.add(e);
				prev = e;
			}
			for (FAbstractEquation e : unsolvedEquations()) {
				if (e != prev)
					s.add(e);
				prev = e;
			}
			return s;
		}

		public ArrayList<FVariable> activeVariables() {
			ArrayList<FVariable> vars = new ArrayList<FVariable>();
			for(AbstractEquationBlock block : solvedBlocks){
				vars.addAll(block.activeVariables());
			}
			for (AbstractEquationBlock block : unsolvedBlocks) {
				vars.addAll(block.activeVariables());
			}
			return vars;
		}	
		
		public ArrayList<FVariable> iterationVariables() {
			ArrayList<FVariable> vars = new ArrayList<FVariable>();
			for (AbstractEquationBlock block : unsolvedBlocks) {
				vars.addAll(block.activeVariables());
			}
			return vars;
		}
		
		public boolean isSolvable() {
			return false;
		}			
		
		public String toString() {
			StringBuffer str = new StringBuffer();
			java.util.List<FVariable> iterationVars = iterationVariables();
			java.util.List<FVariable> solvedVars = activeVariables();
			solvedVars.removeAll(iterationVars);

			str.append("Torn block of " + iterationVars.size() + " tearing variables");
			str.append(" and " + solvedVars.size() + " solved variables.\n");
			str.append("Solved variables:\n");
			for (FVariable fv : solvedVars) {
				str.append("  " + fv.name() + "\n");
			}
			str.append("Tearing variables:\n");
			for (FVariable fv : iterationVars) {
				str.append("  " + fv.name() + "\n");
			}
			str.append("Solved equations:\n");
			for(FAbstractEquation feq : solvedEquations()){
				str.append("  " + feq.prettyPrint("") + "\n");			
			}	
			str.append("Residual equations:\n");
			for (FAbstractEquation feq : unsolvedEquations()) {
				str.append("  " + feq.prettyPrint("") + "\n");			
			}
			return str.toString();
		}
	
	}

    public class MatchingPair {
    	private FAbstractEquation eqn;
    	private FVariable fv;
    	public MatchingPair(FAbstractEquation eqn, FVariable fv) {
    		this.eqn = eqn;
    		this.fv = fv;
    	}
    
    	public FAbstractEquation getEquation() {
			return eqn;    	
    	}
    	
    	public FVariable getFVariable() {
    		return fv;
    	}
    }

	syn lazy LinkedHashSet<FVariable> FVariable.dependsOn() {
		if (myDAEEquationBlock() != null) {
			return myDAEEquationBlock().dependsOn();
		} else {
			return new LinkedHashSet<FVariable>();
		}
	}

	syn lazy AbstractEquationBlock FVariable.myDAEEquationBlock() = 
		myFClass().getDAEFVariableEquationBlockMap().get(this);

	private HashMap<FVariable,AbstractEquationBlock> FClass.daeFVariableEquationBlockMap = null;
	syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEFVariableEquationBlockMap() {
		if (daeFVariableEquationBlockMap == null) 
			computeMatchingsAndBLT();
		return daeFVariableEquationBlockMap;
	}

	syn lazy AbstractEquationBlock FVariable.myDAEInitEquationBlock() = 
		myFClass().getDAEInitFVariableEquationBlockMap().get(this);
	
	private HashMap<FVariable,AbstractEquationBlock> FClass.daeInitFVariableEquationBlockMap = null;	
	syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEInitFVariableEquationBlockMap() {
		if (daeInitFVariableEquationBlockMap == null) 
			computeMatchingsAndBLT();
		return daeInitFVariableEquationBlockMap;
	}

	private ArrayList<MatchingPair> FClass.daeMatching = null;
	syn ArrayList<MatchingPair> FClass.getDAEMatching() {
		if (daeMatching == null) 
			computeMatchingsAndBLT();
		return daeMatching;
	}
	
	private ArrayList<MatchingPair> FClass.daeInitMatching = null;
	syn ArrayList<MatchingPair> FClass.getDAEInitMatching() { 
		if (daeInitMatching == null) 
			computeMatchingsAndBLT();
		return daeInitMatching;
	}	

	private ArrayList<FAbstractEquation> FClass.daeUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEUnmatchedEquations() { 
		if (daeUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedVariables;
	}	

	private ArrayList<FAbstractEquation> FClass.daeInitUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEInitUnmatchedEquations() { 
		if (daeInitUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeInitUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEInitUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedVariables;
	}	

	private BLT FClass.daeBLT = null;
	syn BLT FClass.getDAEBLT() {
		if (daeBLT == null) 
			computeMatchingsAndBLT();
		return daeBLT;
	}

	private StructuredBLT FClass.daeStructuredBLT = null;
	syn StructuredBLT FClass.getDAEStructuredBLT() {
		if (daeStructuredBLT == null) 
			computeMatchingsAndBLT();
		return daeStructuredBLT;
	}
	
	private BLT FClass.daeInitBLT = null;	
	syn BLT FClass.getDAEInitBLT() {
		if (daeInitBLT == null) 
			computeMatchingsAndBLT();
		return daeInitBLT;
	}	
	
	public ArrayList<String> FClass.indexReductionErrors = new ArrayList<String>();
	
	/**
	 * The symbolic equation sorting and canonicalization proceeds in the
	 * following steps:
	 * 
	 * - The DAE system consisting of the DAE equations with algebraics and
	 *   derivatives treated as unknowns is matched to obtain a pairing
	 *   between equations and variables. Discrete and continuous algebraic
	 *   variables are treated equally in this respect.
	 *
	 * - If a perfect matching is found, i.e., if there are no unmatched
	 *   equations or variables, the BLT algoritm is applied to compute
	 *   a sequence of stron components, corresponding to systems of equations.
	 * 
	 * - Having computed a matching and transformed the DAE into BLT form, 
	 *   the DAE initialization system is analyzed:
	 *    - The differentiated variables are added to the set of unknown 
	 *      variables of the system.
	 *    - The pre variables are added to the set of unknown variables of the
	 *      system.
	 *    - The initial equations are added to the set of equations of the 
	 *      system. This includes equations resulting from start values with
	 *      a corresonding fixed attribute set to true.
	 *    - When clauses are analyzed: if a when clause is explicitly enabled by
	 *      the initial() operator (whatever this means...), the when clause 
	 *      is excluded, otherwhise the equation pre(x) = x is added, where x 
	 *      is the variable that is solved for in the when clause.
	 *      
	 * - The matching algoritm is applied to the updated graph. Notice that it
	 *   is important that the result of the DAE matching is used as a starting
	 *   point: using this approach, derivatives and algebraics will remain
	 *   matched if possible and additional equations are added, if needed,
	 *   for differentiated variables. If there are 
	 *   unmatched equations, the transformation sequence terminates. If there
	 *   are unmatched variables, then additional initial equations are added 
	 *   in order to obtained a balanced system. For continuous variables, 
	 *   equations such as x = x.start are added, whereas for discrete variables
	 *   equations such as pre(x) = x.start are added.
	 *
	 *  - Finally, the BLT algorithm is applied to the resulting perfect
	 *    matchibng for the DAE initialization system.
     */	
	public void FClass.computeMatchingsAndBLT() {
		beginStep("computeMatchingsAndBLT()");
		computeMatchingsAndBLTWrapped();
		endStep("computeMatchingsAndBLT()");
	}
	
	private void FClass.computeMatchingsAndBLTWrapped() {
		daeMatching = new ArrayList<MatchingPair>();
		daeInitMatching = new ArrayList<MatchingPair>();		
	    daeBLT = new BLT(this);
	    daeStructuredBLT = new StructuredBLT(this);
	   	daeInitBLT = new BLT(this);		
		daeUnmatchedEquations = new ArrayList<FAbstractEquation>();		
		daeUnmatchedVariables = new ArrayList<FVariable>();			
		daeInitUnmatchedEquations = new ArrayList<FAbstractEquation>();		
		daeInitUnmatchedVariables = new ArrayList<FVariable>();			
		daeFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();	
		daeInitFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();	
			
		BiPGraph g = new BiPGraph(this,name(),"");
		
		Eq eqn = null;
		Var v = null;		
		
		int k = 1;
		
		// First try a global matching with all variables
		g.addVariables(this, BiPGraph.DERIVATIVE_VARIABLES | BiPGraph.ALGEBRAIC_VARIABLES);
		g.addEquations(equations(), BiPGraph.DERIVATIVE_VARIABLES | BiPGraph.ALGEBRAIC_VARIABLES,"eq_",1);
		
		log.info(g);
		g.maximumMatching(true);
		log.info("DAE system");
		log.info(g.printMatchingObj());
			
		daeMatching = g.getMatching();
			
		for (Var var : g.getUnmatchedVariables()) {
			daeUnmatchedVariables.add(var.getVariable());
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeUnmatchedEquations.add(ee.getEquation());
		}
	
		// If no complete matching found, then try index reduction
		if (g.getUnmatchedVariables().size()>0 || g.getUnmatchedEquations().size()>0) {
			if (root().options.getBooleanOption("index_reduction")) {
				// Only do index reduction based on real variables and equations
				g = new BiPGraph(this,name(),"");
				g.addVariables(this, BiPGraph.DERIVATIVE_VARIABLES | BiPGraph.CONTINUOUS_ALGEBRAIC_VARIABLES);
				g.addEquations(continuousEquations(), BiPGraph.DERIVATIVE_VARIABLES | BiPGraph.CONTINUOUS_ALGEBRAIC_VARIABLES,"eq_",1);
				log.info("Index reduction starts");
				log.info(g);
				g.maximumMatching(true);	
				log.info("DAE system real variables only");
				log.info(g.printMatchingObj());

				IndexReductionResult result = null;
				try {
					result = g.reduceIndex(false);
				} catch (EquationDifferentiationException e) {
					indexReductionErrors.add(e.getMessage());
					return; 
				}
				
				if (result != null) {
					// Add the new equations
					// Replace selected dummy derivatives with algebraics
					// Enable rewrite of identifiers? (not necessary?)
					for (FAbstractEquation fe : result.getEquations()) {
						addFEquation((FAbstractEquation)fe.fullCopy());
					}
					
					List<FVariable> l = new List<FVariable>();
					
					for (FVariable fv : getFVariables()) {
						if (result.getDummyDerivatives().contains(fv)) {
							if (fv instanceof FHDerivativeVariable) {
								FHDummyDerivativeVariable fdv = new FHDummyDerivativeVariable(fv.getFVisibilityType().fullCopy(),
									fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy(),
									((FHDerivativeVariable)fv).getOrder());
								l.add(fdv);
							} else if (fv instanceof FDerivativeVariable) {
								FDummyDerivativeVariable fdv = new FDummyDerivativeVariable(fv.getFVisibilityType().fullCopy(),
									fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy());
								l.add(fdv);					
							} else {
								l.add(fv);
							}
						} else if (fv instanceof FHDerivativeVariable) {
						    // Convert higher order derivative variables into
						    // first order derivatives
						    FHDerivativeVariable fhdv = (FHDerivativeVariable)fv;
							for (int i=0;i<fhdv.getOrder()-1;i++) {
								StringBuffer str = new StringBuffer();
								StringBuffer str2 = new StringBuffer();
								for (int j=0;j<i+1;j++) {
									str.append("_der");
									if (j<i) {
										str2.append("_der");
									}
								}
								str.append("_");
								if (i>0) {
									str2.append("_");
								}
								FQName fqn = fhdv.getFQName();
								FQName fqn2 = (FQName)fv.getFQName().fullCopy();
								str.append(fqn.getFQNamePart(fqn.getNumFQNamePart()-1).name());
								fqn.setFQNamePart(new FQNamePart(str.toString(),fqn.getFQNamePart(fqn.getNumFQNamePart()-1).getFArraySubscriptsOpt()),fqn.getNumFQNamePart()-1);
								l.add(new FRealVariable(fv.getFVisibilityType().fullCopy(),
									fv.getFTypePrefixVariability().fullCopy(), fqn));
								l.add(new FDerivativeVariable(fv.getFVisibilityType().fullCopy(),
									fv.getFTypePrefixVariability().fullCopy(), (FQName)fqn.fullCopy()));
								str2.append(fqn2.getFQNamePart(fqn2.getNumFQNamePart()-1).name());
								fqn2.setFQNamePart(new FQNamePart(str2.toString(),fqn2.getFQNamePart(fqn2.getNumFQNamePart()-1).getFArraySubscriptsOpt()),fqn2.getNumFQNamePart()-1);
								// Add equations for the new variables
								addFEquation(new FEquation(new FIdUseExp(new FIdUse((FQName)fqn.fullCopy())),new FDerExp(new FIdUse(fqn2))));
							}		
						} else {
							l.add(fv);
						}
					}	
	
					setFVariableList(l);		
	
					enableFHDerRewrite();
	
					// flushAllRecursiveClearFinal must be used here in order to
					// trigger rewrites of FDerExp -> FDummyDerExp
					root().flushAllRecursiveClearFinal();
	
					aliasEliminationIfSet();
	
	 				root().flushAllRecursive();
	
					//System.out.println(prettyPrint(""));
	
					//dumpTree("");
	
					log.info("States:");
					for (FVariable fv : differentiatedRealVariables()) {
						log.info(fv.prettyPrint("  ")); //TODO: fix so no call is made if log level < info
					}
				} else {
					return;
				}
				
				BiPGraph oldG = g;	

				g = new BiPGraph(this,name(),"");
				g.addVariables(this, BiPGraph.DERIVATIVE_VARIABLES | BiPGraph.ALGEBRAIC_VARIABLES);
				g.addEquations(equations(), BiPGraph.DERIVATIVE_VARIABLES | BiPGraph.ALGEBRAIC_VARIABLES,"eq_",1);

				log.info(g);
				g.maximumMatching(true);	
				log.info("DAE system ");
				log.info(g.printMatchingObj());
		
				daeMatching = g.getMatching();
		
				daeUnmatchedVariables.clear();
				for (Var var : g.getUnmatchedVariables()) {
					daeUnmatchedVariables.add(var.getVariable());
				}

				daeUnmatchedEquations.clear();
				for (Eq ee : g.getUnmatchedEquations()) {
					daeUnmatchedEquations.add(ee.getEquation());
				}
		
				if (g.getUnmatchedVariables().size()>0 || g.getUnmatchedEquations().size()>0) {
					return;
				}
				
			} else {
				return;
			}
		} 
			
		// Perform BLT
		if (root().options.getBooleanOption("equation_sorting") && g.getUnmatchedVariables().size()==0 && g.getUnmatchedEquations().size()==0) {	
			
			if (root().options.getBooleanOption("enable_tearing")){
				daeBLT = computeTearings(g);
				
			}else{
				daeBLT = g.computeBLT();
			}
			for (AbstractEquationBlock eb : daeBLT) {
				for (FVariable fv : eb.activeVariables()) {
					daeFVariableEquationBlockMap.put(fv,eb);
				}
			}	
			daeStructuredBLT = new StructuredBLT(this,daeBLT);
			log.info(daeStructuredBLT);
			
			log.info(daeBLT);
		
		}
						
		// Find matching for the initialization system	
		g.addVariables(this, BiPGraph.DIFFERENTIATED_VARIABLES | BiPGraph.DISCRETE_PRE_VARIABLES);
		g.addEquations(equations(), BiPGraph.DIFFERENTIATED_VARIABLES | BiPGraph.DISCRETE_PRE_VARIABLES, "eq_",1);

	    // Replace when equations	
		ArrayList<FAbstractEquation> equationsToReplace = 
			new ArrayList<FAbstractEquation>();
		for (FAbstractEquation e : equations()) {
			if (e.replacedAtInitialization()) {
				equationsToReplace.add(e);
			}
		}		
		
		// Loop over all equations to replace
		for (FAbstractEquation equationToReplace : equationsToReplace) {
						
			// How many equations are there in this when clause?
			List<FAbstractEquation> newEquations = equationToReplace.getInitialEquationList();
		
		    // Put the Equations in an ArrayList rather than a List
		    // TODO: There are probably more elegant ways to do this...
			ArrayList<FAbstractEquation> newEquations_ = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation e : newEquations) {
				newEquations_.add(e);	
			}

			 // - equationToReplace is an FAbstractEquation that should be replaced
			 // - newEquations contains the new equations that replaces the equationToReplace
			 // - Note that newEquations may contain several equations  
			 
			ArrayList<Eq> eq_list = g.getEquations(equationToReplace);
			
			for (Eq eqq : eq_list) {
				g.removeEquation(eqq);	
			}
			
			g.addEquations(newEquations_, BiPGraph.DERIVATIVE_VARIABLES | 
		                                   BiPGraph.ALGEBRAIC_VARIABLES | 
		                                   BiPGraph.DIFFERENTIATED_VARIABLES | 
		                                   BiPGraph.DISCRETE_PRE_VARIABLES, eq_list.get(0).getName(),
		                                   1);
		}		
	
		log.info(g);
		

		g.addEquations(initialEquations(), BiPGraph.DERIVATIVE_VARIABLES | 
		                                   BiPGraph.ALGEBRAIC_VARIABLES | 
		                                   BiPGraph.DIFFERENTIATED_VARIABLES | 
		                                   BiPGraph.DISCRETE_PRE_VARIABLES, "eq_",
		                                   g.getEquations().size() + 1);

		log.info(g);
		g.maximumMatching(false);	
		log.info("DAE initial ");
		log.info(g.printMatchingObj());

		if (g.getUnmatchedEquations().size()>0) {
		   	return;
		}

		// Add initial equations if needed
		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			List<FAbstractEquation> l = new List<FAbstractEquation>();
			for (FAbstractEquation e : initialEquations()) {
				l.add(e);
			}

			for (Var var : g.getUnmatchedVariables()) {	
			    FVariable fv = var.getVariable();
			    FEquation fe = null;
			    if (fv.isReal() && fv.isContinuous()) {
					fe = new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp(0.0));
				} else if (fv.isReal() && fv.isDiscrete()) {
					fe = new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp(0.0));
				} else if (fv.isInteger()) {
					fe = new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FIntegerLitExp(0));
				}
			    if (fv.isBoolean()) {
					fe = new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse());
				}
				if (fv.isString()) {
					fe = new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FStringLitExp(""));
				}
			    if (fv.isEnum()) {
					fe = new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse());
				}
				l.add(fe);
				
				eqn = g.addEquation("eq_"+(g.getEquations().size() + 1),fe.prettyPrint(""),fe);
				v = g.getVariable(var.getName());     
				g.addEdge(eqn,v); 
				k++;
				//j++;
			}
	
			setFInitialEquationList(l);	
	        root().flushAllRecursive();

			g.maximumMatching(false);	
			log.info("DAE initial after addition of initial equations");
			log.info(g);
			log.info(g.printMatchingObj());

		}

		for (Var var : g.getUnmatchedVariables()) {
			daeInitUnmatchedVariables.add(var.getVariable());
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeInitUnmatchedEquations.add(ee.getEquation());
		}

		daeInitMatching = g.getMatching();

		// TODO: If no complete matching found, then try index reduction
		if (g.getUnmatchedVariables().size()>0 || g.getUnmatchedEquations().size()>0) {
			return;
		}
				
		if (root().options.getBooleanOption("equation_sorting") && 
			g.getUnmatchedVariables().size()==0 && 
			g.getUnmatchedEquations().size()==0) {
		
			g.tarjanReset();
			if (root().options.getBooleanOption("enable_tearing")){
				daeInitBLT = computeTearings(g);
			}else{
				daeInitBLT = g.computeBLT();
			}
			for (AbstractEquationBlock eb : daeInitBLT) {
				for (FVariable fv : eb.activeVariables()) {
					daeInitFVariableEquationBlockMap.put(fv,eb);
				}
			}	
			log.info(daeInitBLT);
		}
	}	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////


	public BLT FClass.computeTearings(BiPGraph graph) {
		beginStep("computeTearings()");
		LinkedList<Stack<Eq>> blt = graph.computeRawBLT();
		BLT tearBLT = new BLT(this);
		for (Stack<Eq> block : blt) { // Iterate over all (global) BLT-blocks
			boolean singleEquation = true;
			Iterator<Eq> it = block.iterator();
			Eq last = it.next();
			while (it.hasNext()) {
				Eq e = it.next();
				if (last.getEquation() != e.getEquation()) {
					singleEquation = false;
					break;
				}
			}
			AbstractEquationBlock tearBlock = null;
			if (singleEquation) {
				tearBlock = EquationBlockFactory.createSimpleEquationBlock(block, true);
			}
			if (tearBlock != null && tearBlock.isSolvable()) {
				tearBLT.add(EquationBlockFactory.createEquationBlock(block));
			} else {
				TornEquationBlock eb = new TornEquationBlock();
				tear(block, eb);
				tearBLT.add(eb);
			}
		}
		endStep("computeTearings()");
		return tearBLT;
	}
	
	private void FClass.tear(Stack<Eq> block, TornEquationBlock eb) {
		Iterator<Eq> it = block.iterator();
		BiPGraph g = new BiPGraph(this, "", "");
		ArrayList<Eq> SUME = new ArrayList<Eq>();

		// ---------------------- Graph Info -----------------------------------
		for (Eq e : block) {
			Eq gEq = g.addEquation(e.getName(), "", e.getEquation());
			Var gVar = g.addVariable(e.getMatching().getName(), "", e.getMatching().getVariable());
			gEq.setMatching(gVar);
			gVar.setMatching(gEq);
			if (gEq.getEquation().isSolved(gVar.getName(), true)) { // Use old matching where possible
				gEq.setSolvableMatching(gVar);
				gVar.setSolvableMatching(gEq);
			} else {
				SUME.add(gEq);
			}
		}
		// Add edges between the active variables and equations
		for (Eq e : block) {
			Eq gEq = g.getEquation(e.getName());
			for (Var v : e.getVariables()) {
				Var gVar = g.getVariable(v.getName());
				if (gVar != null) {
					gEq.addVariable(gVar);
					gVar.occurrence();
					if (gEq.getEquation().isSolved(gVar.getName(), true)) {
						gEq.addSolvableVariable(gVar);
						gVar.solvableOccurrence();
					}
				}
			}
		}
		// Obtain Maximum Solvable Matching in two steps (greedy and augmenting paths)
		SUME = g.greedySM(SUME);
		Iterator<Eq> itr = SUME.iterator();
		while (itr.hasNext()) {
			Eq e = itr.next();
			if (g.SAP(e)) {
				itr.remove();
			} else {
				e.isRes(true);
			}
			g.lightReset();
		}

		// Now we have a Maximum Solvable Matching

		if (SUME.size() == 0) { // If: there exist a Pefect Solvable Matching
								//     proceed with recursive tearing of block
			SimpleEquationBlock tearBlock = EquationBlockFactory.createSimpleEquationBlock(block, true);
			if (tearBlock != null && tearBlock.isSolvable()) {
				eb.addSolvedBlock(tearBlock);
			} else {
				tear(g, eb);
			}
		} else {
			// Check for hand guided tearing
			while (it.hasNext()) {
				Eq e = it.next();
				if (e.getEquation().hasResidues()) {
					Var tearVar = null;
					FExp tearExp = null;
					for (FExp exp : e.getEquation().getResidues().getResidues()) {
						for (FVariable var : exp.referencedFVariablesInFExp()) {
							for (Eq eqn : block) {
								tearVar = eqn.getVariable(var.name());
								if (tearVar != null)
									break;
							}
							break;
						}
						if (tearVar != null) {
							tearExp = exp;
							break;
						}
					}
					if (tearVar == null) {
						for (Eq eqn : block) {
							for (Var var : eqn.getVariables()) {
								if (var.getVariable().getManualTearingVariable()) {
									tearVar = var;
									break;
								}
							}
							if (tearVar != null)
								break;
						}
					}
					if (tearVar == null) {
						tearVar = e.getMatching();
					} else if (e.getMatching() != tearVar) {
						BiPGraph newGraph = new BiPGraph(this, "", "");
						for (Eq eqn : block) {
							if (eqn != e)
								newGraph.addEquation(eqn.getName(), "", eqn.getEquation());
							if (eqn.getMatching() != tearVar)
								newGraph.addVariable(eqn.getMatching().getName(), "", eqn.getMatching().getVariable());
						}
						for (Eq eqn : block) {
							if (eqn == e)
								continue;
							Eq gEq = newGraph.getEquation(eqn.getName());
							for (Var v : eqn.getVariables()) {
								Var gVar = newGraph.getVariable(v.getName());
								if (gVar != null) {
									gEq.addVariable(gVar);
									gVar.occurrence();
								}
							}
						}
						newGraph.maximumMatching(true);
						if (newGraph.getUnmatchedEquations().size() > 0) {
								tearExp.warning("Unable to use hand guided tearing variable " + tearVar.getName() + " in equation " + e.getEquation().toString());
							continue;
						}
						Stack<Eq> newBlock = new Stack<Eq>();
						newBlock.addAll(newGraph.getEquations());
						block = newBlock;
					}
					it.remove();
					eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(e.getEquation(), tearVar.getVariable(), false));
					tear(block, eb);
					return;
				}
			}
			// Else: Start out by trying to insert residuals that contain
			// 		 few variables. 
			ArrayList<FAbstractEquation> residuals = new ArrayList<FAbstractEquation>();
			for (Eq e : SUME) {
				int nVars = e.getVariables().size();
				int nSVars = e.getSolvableVariables().size();
				Eq newRes = null;
				for (Var v : e.getSolvableVariables()) {
					Eq tmp = v.getSolvableMatching();
					int tmpNVars = tmp.getVariables().size();
					int tmpNSVars = tmp.getSolvableVariables().size();
					if (tmpNVars > nVars || (tmpNVars == nVars && tmpNSVars > nSVars)) {
						newRes = tmp;
						nVars = tmpNVars;
						nSVars = tmpNSVars;
					}
				}
				if (newRes != null) {
					Var tmpVar = newRes.getSolvableMatching();
					newRes.setSolvableMatching(null);
					newRes.isRes(true);
					e.setMatching(tmpVar);
					tmpVar.setMatching(e);
					e.setSolvableMatching(tmpVar);
					tmpVar.setSolvableMatching(e);
					e.isRes(false);
					residuals.add(newRes.getEquation());
				} else {
					residuals.add(e.getEquation());
				}
			}

			// Compute inner BLT and see if tearings can be changed 
			ArrayList<Var> SUMV = g.getSUMV();
			LinkedList<Stack<Eq>> innerBlocks = g.computeTearBlocks();
			ArrayList<FVariable> tearings = new ArrayList<FVariable>();

			for (Stack<Eq> bInner : innerBlocks) {
				if (bInner.size() == 1) {
					// If: the block is scalar, it will be a solvedMatchingPair
					Eq e = bInner.get(0);
					FAbstractEquation eqn = e.getEquation();
					FVariable var = e.getSolvableMatching().getVariable();
					eb.addSolvedBlock(EquationBlockFactory.createSimpleEquationBlock(eqn, var, true));
					// If the equation contains a Var in SUMV, that Var cannot be
					// reinserted and must be used as a tearing variable.
					for (Var vv : e.getVariables()) {
						if (SUMV.contains(vv)) {
							SUMV.remove(vv);
							tearings.add(vv.getVariable());
						}
					}
				} else {
					// Build Inner Graph and add info about tearing variables
					BiPGraph gInner = new BiPGraph(this, "", "");
					// Obtain info about block-graph
					for (Eq e : bInner) {
						Var gInnerVar = gInner.addVariable(e.getSolvableMatching().getName(), "", e.getSolvableMatching().getVariable());
						Eq gInnerEq = gInner.addEquation(e.getName(), "", e.getEquation());
						gInnerEq.setMatching(gInnerVar);
						gInnerVar.setMatching(gInnerEq);
						gInnerEq.setSolvableMatching(gInnerVar);
						gInnerVar.setSolvableMatching(gInnerEq);
					}
					// Build block-graph and look for interchangeable variables in SUMV
					ArrayList<Eq> eqs = new ArrayList<Eq>();
					boolean graphHasTear = false;
					for (Eq e : bInner) {
						Eq gInnerEq = gInner.getEquation(e.getName());
						for (Var v : e.getVariables()) {
							Var gInnerVar = gInner.getVariable(v.getName());
							if (gInnerVar != null) {
								gInnerEq.addVariable(gInnerVar);
								gInnerVar.occurrence();
								if (gInnerEq.getEquation().isSolved(gInnerVar.getName(), true)) {
									gInnerEq.addSolvableVariable(gInnerVar);
									gInnerVar.solvableOccurrence();
									if (gInnerVar.isTear() && !eqs.contains(gInnerEq)) {
										eqs.add(gInnerEq);
									}
								}
							} else if (SUMV.contains(v)) {
								Var newGInnerVar = gInner.addVariable(v.getName(), "", v.getVariable());
								newGInnerVar.isTear(true);
								newGInnerVar.occurrence();
								gInnerEq.addVariable(newGInnerVar);
								SUMV.remove(v);
								tearings.add(v.getVariable());
								graphHasTear = true;
								if (e.getEquation().isSolved(v.getName(), true)) {
									gInnerEq.addSolvableVariable(newGInnerVar);
									newGInnerVar.solvableOccurrence();
									if (!eqs.contains(gInnerEq)) {
										eqs.add(gInnerEq);
									}
								}
							}
						}
					}
					// Go through equations that might get a new matching
					boolean isChanged = false;
					for (Eq e : eqs) {
						int occ = e.getSolvableMatching().getNbrV();
						int solvOcc = e.getSolvableMatching().getNbrSV();
						for (Var v : e.getSolvableVariables()) {
							if (v.isTear()) {
								int vOcc = v.getNbrV();
								int vSolvOcc = v.getNbrSV();
								// Reinsert tearing if it is "better" than the matching	
								if (vOcc < occ || (vOcc == occ && vSolvOcc > solvOcc)) {
									Var tmp = e.getSolvableMatching();
									tmp.isTear(true);
									tmp.setSolvableMatching(null);
									tearings.remove(v.getVariable());
									tearings.add(tmp.getVariable());
									v.isTear(false);
									e.setSolvableMatching(v);
									v.setSolvableMatching(e);
									occ = vOcc;
									solvOcc = vSolvOcc;
									isChanged = true;
								}
							}
						}
					}

					if (graphHasTear) {
						if (isChanged) {
							LinkedList<Stack<Eq>> newBlocks = gInner.computeTearBlocks();
							for (Stack<Eq> bInnerInner : newBlocks) {
								if (bInnerInner.size() == 1) {
									Eq e = bInnerInner.get(0);
									FAbstractEquation eqn = e.getEquation();
									FVariable var = e.getSolvableMatching().getVariable();
									eb.addSolvedBlock(EquationBlockFactory.createSimpleEquationBlock(eqn, var, true));
								} else {
									tear(bInnerInner, eb);
								}
							}
						} else {
							tear(bInner, eb);
						}

					} else {
						// Reuse the already constructed graph
						tear(gInner, eb);
					}
				}
			}
			for (Var v : SUMV) {
				//SUMV ought to be empty, but there might exist variables that hasn't 
				// been altered before. 
				tearings.add(v.getVariable());
			}
			for (int i = 0; i < tearings.size(); i++) {
				eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(residuals.get(i), tearings.get(i), false));
			}
		}
	}	

	
	public TornEquationBlock FClass.tear(BiPGraph g, TornEquationBlock eb){
		Var tear = null;
		Eq res = null;
		int maxOcc = 0;
		int minSolvOcc = 0;
		for (Eq e : g.getEquations()) {
			if (e.getEquation().hasResidues()) {
				FResidues reidues = e.getEquation().getResidues();
				res = e;
				for (FExp exp : reidues.getResidues()) {
					for (FVariable var : exp.referencedFVariablesInFExp()) {
						tear = g.getVariable(var.name());
						break;
					}
					if (tear != null)
						break;
				}
				if (tear == null)
					tear = res.getSolvableMatching();
				break;
			}
		}
		if (tear == null) {
			for (Eq e : g.getEquations()) {
				Var tmp = e.getSolvableMatching();
				int occ = tmp.getNbrV();
				int sOcc = tmp.getNbrSV();
				if (occ > maxOcc) {
					tear = tmp;
					maxOcc = occ;
					minSolvOcc = sOcc;
				} else if (occ == maxOcc && sOcc < minSolvOcc) {
					tear = tmp;
					minSolvOcc = sOcc;
				}
			}
			res = tear.getSolvableMatching();
		}
		tear.isTear(true);
		res.isRes(true);
		eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(res.getEquation(), tear.getVariable(), false));
		LinkedList<Stack<Eq>> blt = g.computeTearBlocks();
		for (Stack<Eq> block : blt) {
			if (block.size() == 1) {
				Eq e = block.get(0);
				Var v = e.getSolvableMatching();
				eb.addSolvedBlock(EquationBlockFactory.createSimpleEquationBlock(e.getEquation(), v.getVariable(), true));
			} else {
				tear(block, eb);
			}
		}
		return eb;
	}
	
	/**
	 * Builds a FResidues instance for "this" equation.  
	 */
	protected FResidues AbstractEquation.buildResidues() {
		AnnotationNode residues = annotation("__JModelica/residue");
		if (!residues.exists())
			return null;

		FResidues fResidues = new FResidues();
		for (AnnotationNode residue : residues) {
			String var = residue.string();
			boolean isDer = false;
			if (residue.string().startsWith("der(")) {
				var = var.substring(4, var.length() - 1);
				isDer = true;
			}

			String[] varSplit = var.split("\\.");
			InstAccess access = new InstParseAccess(varSplit[varSplit.length - 1]);
			for (int i = varSplit.length - 2; i >= 0; i--)
				access = new InstDot(new InstParseAccess(varSplit[i]), access);

			FExp e = new FInstAccessExp(access);
			if (isDer)
				e = new InstDerExp(e);
			residue.ast().copyLocationTo(e);
			fResidues.addResidue(e);
		}
		return fResidues;
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////			
	
	syn lazy ArrayList<String> FClass.structuralErrors() {
		ArrayList<String> structuralErrors = new ArrayList<String>();
		if (root().options.getBooleanOption("enable_structural_diagnosis")) {
		boolean unbalanced = false;
		StringBuffer err_str = new StringBuffer();
		if (getDAEUnmatchedVariables().size() > 0 ) {
			err_str.append("The system is structurally singuar. The following varible(s) could not be matched to any equation:\n");
			for (FVariable fv : getDAEUnmatchedVariables()) {
				err_str.append("   " + fv.name());
				err_str.append("\n");
			}
			unbalanced = true;
		}
		if (getDAEUnmatchedEquations().size() > 0 ) {
			if (!unbalanced) {
				err_str.append("The system is structurally singuar. The following equation(s) could not be matched to any variable:\n");
			} else {
				err_str.append("\n  The follwowing equation(s) could not be matched to any variable:\n");
			}
			for (FAbstractEquation ee : getDAEUnmatchedEquations()) {
				err_str.append("   " + ee.prettyPrint(""));
				err_str.append("\n");
			}
			unbalanced = true;
		}
		
		if (unbalanced) {
			structuralErrors.add(err_str.toString());
		}
		}
		return structuralErrors;
	}

	
	/**
	 * Generate array initialization statements for unknown function arrays.
	 */
	public void FClass.genInitArrayStatements() {
		beginStep("genInitArrayStatements()");
		for (FFunctionDecl ffd : getFFunctionDecls()) {
			ffd.genInitArrayStatements();
			ffd.sortBindingAssignments();
		}
		endStep("genInitArrayStatements()");
	}
	
	public void FFunctionDecl.genInitArrayStatements() {
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable ffv : getFFunctionVariables())
			ffv.genInitArrayStatements(stmts);
		for (FStatement stmt : getFAlgorithmBlock().getFStatements())
			stmts.add(stmt);
		getFAlgorithmBlock().setFStatementList(stmts);
	}

	protected boolean FFunctionVariable.hasInitArrayStmt = false;

	public void FFunctionVariable.genInitArrayStatements(List<FStatement> stmts) {}
	
	public void FFunctionArray.genInitArrayStatements(List<FStatement> stmts) {
		if (size().isUnknown() && !isInput() && !isOutput()) {
			FInitArrayStmt stmt = new FInitArrayStmt(createUseExp());
			stmt.shouldBeSorted = true;
			stmts.add(stmt);
			hasInitArrayStmt = true;
		}
	}

	
	public void FFunctionDecl.sortBindingAssignments() {
		Map<String,FStatement> map = new LinkedHashMap<String,FStatement>();
		for (FStatement stmt : getFAlgorithmBlock().getFStatements())
			stmt.addToSortingMap(map);
		
		List<FStatement> stmts = new List<FStatement>();
		while (!map.isEmpty()) 
			map.values().iterator().next().addSortedByAssignmentOrder(stmts, map);
		
		for (FStatement stmt : getFAlgorithmBlock().getFStatements())
			if (!stmt.shouldBeSorted)
				stmts.add(stmt);
		getFAlgorithmBlock().setFStatementList(stmts);
	}
	
	public void FStatement.addToSortingMap(Map<String,FStatement> map) {
		if (shouldBeSorted) {
			for (String name : sortingAssignedNames()) {
				FStatement old = map.get(name);
				if (old != null && old != this)
					extraSortingDependencies().add(old);
				map.put(name, this);
			}
		}
	}
	
	
	private boolean FStatement.isBeingSorted = false;
	private boolean FStatement.addedDuringSorting = false;
	
	public void FStatement.addSortedByAssignmentOrder(
			List<FStatement> stmts, Map<String,FStatement> map) {
		if (isBeingSorted) 
			throw new CircularBindingExpressionException();
		isBeingSorted = true;
		
		for (String depName : sortingDependencies()) {
			FStatement dep = map.get(depName);
			if (dep != null && dep != this)
				dep.addSortedByAssignmentOrder(stmts, map);
		}
		for (FStatement dep : extraSortingDependencies()) {
			if (!dep.addedDuringSorting)
				dep.addSortedByAssignmentOrder(stmts, map);
		}
		
		stmts.add(this);
		addedDuringSorting = true;
		for (String name : sortingAssignedNames())
			map.remove(name);
		
		isBeingSorted = false;
	}
	
	public class CircularBindingExpressionException extends RuntimeException {}
	
	private Set<FStatement> FStatement.extraSortingDependencies = null;
	private Set<FStatement> FStatement.extraSortingDependencies() {
		if (extraSortingDependencies == null)
			extraSortingDependencies = new LinkedHashSet<FStatement>();
		return extraSortingDependencies;
	}
	
	
	syn lazy Set<String> FStatement.sortingAssignedNames() = Collections.<String>emptySet();
	eq FAssignStmt.sortingAssignedNames()      = Collections.singleton(getLeft().name());
	eq FInitArrayStmt.sortingAssignedNames()   = 
		Collections.singleton("size(" + getFIdUseExp().name() + ")");
	eq FForStmt.sortingAssignedNames()         = sortingAssignedNames(getForStmts());
	eq FWhileStmt.sortingAssignedNames()       = sortingAssignedNames(getWhileStmts());
	eq FFunctionCallStmt.sortingAssignedNames() {
		Set<String> res = new LinkedHashSet<String>(getNumLeft());
		for (FFunctionCallLeft left : getLefts())
			left.sortingAddNamesUsed(res);
		return res;
	}
	eq FIfStmt.sortingAssignedNames() {
		Set<String> res = new LinkedHashSet<String>();
		for (FIfWhenClause iwc : getFIfWhenClauses())
			res.addAll(iwc.sortingAssignedNames());
		for (FStatement stmt : getElseStmts())
			res.addAll(stmt.sortingAssignedNames());
		return res;
	}
	
	syn Set<String> FIfWhenClause.sortingAssignedNames() = 
		FStatement.sortingAssignedNames(getFStatements());
	
	public static Set<String> FStatement.sortingAssignedNames(List<FStatement> stmts) {
		Set<String> res = new LinkedHashSet<String>();
		for (FStatement stmt : stmts)
			res.addAll(stmt.sortingAssignedNames());
		return res;
	}
	
	
	syn lazy Set<String> FStatement.sortingDependencies() = Collections.<String>emptySet();
	eq FAssignStmt.sortingDependencies()       = 
		getRight().sortingAddNamesUsed(baseSortingDependencies());
	eq FInitArrayStmt.sortingDependencies()    = 
		getFIdUseExp().myFV().size().sortingAddNamesUsed(new LinkedHashSet<String>());
	eq FFunctionCallStmt.sortingDependencies() = 
		getCall().sortingAddNamesUsed(baseSortingDependencies());
	eq FForStmt.sortingDependencies()          = 
		addCompoundStmtSortingDependencies(baseSortingDependencies(), getIndex(), getForStmts());
	eq FWhileStmt.sortingDependencies()        = 
		addCompoundStmtSortingDependencies(baseSortingDependencies(), getTest(), getWhileStmts());
	eq FIfStmt.sortingDependencies() {
		Set<String> res = new LinkedHashSet<String>();
		for (FIfWhenClause iwc : getFIfWhenClauses())
			res.addAll(iwc.sortingDependencies());
		for (FStatement stmt : getElseStmts())
			res.addAll(stmt.sortingDependencies());
		return res;
	}
	
	syn Set<String> FIfWhenClause.sortingDependencies() = 
		FStatement.addCompoundStmtSortingDependencies(
				new LinkedHashSet<String>(), getTest(), getFStatements());
	
	protected Set<String> FStatement.baseSortingDependencies() {
		Set<String> res = new LinkedHashSet<String>();
		for (String name : sortingAssignedNames()) 
			res.add("size(" + name + ")");
		return res;
	}
	
	public static Set<String> FStatement.addCompoundStmtSortingDependencies(
			Set<String> set, ASTNode head, List<FStatement> body) {
		head.sortingAddNamesUsed(set);
		for (FStatement stmt : body)
			set.addAll(stmt.sortingDependencies());
		return set;
	}
	
	public Set<String> ASTNode.sortingAddNamesUsed(Set<String> set) {
		for (ASTNode n : this)
			n.sortingAddNamesUsed(set);
		return set;
	}
	
	public Set<String> FIdUse.sortingAddNamesUsed(Set<String> set) {
		if (!myFV().isUnknown())
			set.add(name());
		return super.sortingAddNamesUsed(set);
	}
	
	public Set<String> FSizeExp.sortingAddNamesUsed(Set<String> set) {
		Set<String> temp = new LinkedHashSet<String>();
		super.sortingAddNamesUsed(temp);
		for (String name : temp) {
			if (!name.startsWith("size("))
				name = "size(" + name + ")";
			set.add(name);
		}
		return set;
	}
	
	public Set<String> Size.sortingAddNamesUsed(Set<String> set) {
		return set;
	}
	
	public Set<String> MutableSize.sortingAddNamesUsed(Set<String> set) {
		for (FExp exp : exps)
			exp.sortingAddNamesUsed(set);
		return set;
	}
	
	
	
	/**
	 * \brief Convert variable binding equations into regular equations.
	 */
	public void FClass.genBindingEquations() {
		beginStep("genBindingEquations()");
		
		FQName empty = new FQName();
		for (FVariable fv : getFVariables()) 
			if (!fv.isConstant()) 
				fv.genBindingEquations(this, empty);
		for (FFunctionDecl ffd : getFFunctionDecls())
			ffd.genBindingAssignments();
//		flush();
		flushAllRecursive();

		endStep("genBindingEquations()");
	}
	
	public void FFunctionDecl.genBindingAssignments() {
		// TODO: To support Modelica 3.3, we need to sort the assignments
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable ffv : getFFunctionVariables())
			ffv.genBindingAssignments(stmts);
		for (FStatement stmt : getFAlgorithmBlock().getFStatements())
			stmts.add(stmt);
		getFAlgorithmBlock().setFStatementList(stmts);
	}
	
	/**
	 * Flag that controls if this statement should be a part of the set of statements at 
	 * the beginning of a function that are generated from variable declarations, and 
	 * should be sorted to ensure assignment before use among them.
	 */
	public boolean FStatement.shouldBeSorted = false;
	
	public void FFunctionVariable.genBindingAssignments(List<FStatement> stmts) {
		if (!isInput() && hasBindingExp()) {
			FAssignStmt stmt = new FAssignStmt(createFIdUse(), getBindingExp());
			stmt.shouldBeSorted = true;
			stmts.add(stmt);
			setBindingExpOpt(new Opt());
		}
	}
	
	
	public FExp FVariable.selectBindingFExp(FAttribute attr) {
		if (attr != null && attr.hasValue())
			return attr.getValue();
		else if (hasBindingExp())
			return getBindingExp();
		else
			return null;
	}
	
	public FQName FVariable.createNameForBindingEquation(FQName prefix, FAttribute attr) {
		FQName name = prefix.copyAndAppend(getFQName());
		FArraySubscripts fas = null;
		if (isArray()) {
			if (attr != null)
				attr = attr.findAttribute(FAttribute.SIZE);
			Size size = (attr != null && attr.hasValue()) ? new MutableSize(attr.getValue()) : size();
			fas = size.rangeFArraySubscripts();
		}
		name.setLastFArraySubscripts(fas);
		return name;
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix) {
		genBindingEquations(fc, prefix, null, false);
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, boolean param) {
		FExp bexp = selectBindingFExp(attr);
		boolean isAttr = attr != null && attr.hasValue();
		param = param || isParameter();
		if (bexp != null && !(param && bexp.isIndependentParameterExp())) {
			if (!inRecord())
				setBindingExpOpt(new Opt());
			genBindingEquationsFromExp(fc, prefix, attr, bexp, param);
			if (isAttr)
				attr.setValueOpt(new Opt());
		}
	}
	
	public void FRecordVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, boolean param) {
		/* TODO: Perhaps this is the wrong approach? Could we instead convert binding expressions 
		 *       for records into attributes on the variable, and sort it out into binding expressions 
		 *       during scalarization?
		 */
		FExp bexp = selectBindingFExp(attr);
		if (bexp != null) {
			super.genBindingEquations(fc, prefix, attr, param);
		} else {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				FAttribute cAttr = findMatching(attrs, comp.name());
				comp.genBindingEquations(fc, name, cAttr, param || isParameter());
			}
		}
	}
	
	protected void FVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, boolean param) {
		FQName name = createNameForBindingEquation(prefix, attr);
		param = param || isParameter();
		FEquation feq = new FEquation(new FIdUseExp(name), bexp.reflattenBindingExp(prefix, this));
		if (param)
			fc.addFParameterEquation(feq);
		else
			fc.addFEquation(feq);	
	}
	
	protected void FRecordVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, boolean param) {
		/* If we get here, then we won't be able to leave expressions for independent parameters 
		 * as binding expressions on the FVariable - we'll have to clean that up later. Since it 
		 * has to be done after records are broken into separate variables, we'll do it during 
		 * parameter equation sorting.
		 */
		if (bexp.canExtractRecordComponents()) {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				FAttribute cAttr = findMatching(attrs, comp.name());
				FExp cExp = bexp.dynamicFExp(bexp.extractRecordFExp(comp.name()));
				comp.genBindingEquationsFromExp(fc, name, cAttr, cExp, param || isParameter());
			}
		} else {
			super.genBindingEquationsFromExp(fc, prefix, attr, bexp, param);
		}
	}
	
	public FExp FExp.reflattenBindingExp(FQName prefix, FVariable var) {
		FExp res = dynamicFExp(fullCopy());
		FRecordDecl decl = var.containingRecordDecl();
		if (decl != null)
			res.prefixInternalUses(prefix, decl);
		return res;
	}
	
	public void FExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		for (FExp e : childFExps())
			e.prefixInternalUses(prefix, decl);
	}
	
	public void FIdUseExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		FQName fqn = getFIdUse().getFQName();
		for (FQNamePart p : fqn.getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.prefixInternalUses(prefix, decl);
		if (decl == lookupFV(fqn.copyFirstPrefix()).containingRecordDecl()) 
			getFIdUse().setFQName(prefix.copyAndAppend(fqn));
	}
	
	public void FSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {}
	
	public void FExpSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		getFExp().prefixInternalUses(prefix, decl);
	}
	
	protected List<FAttribute> FRecordVariable.selectFAttributeList(FAttribute attr) {
		if (attr != null && attr.getFAttributes().getNumChild() > 0)
			return attr.getFAttributes();
		else
			return getFAttributes();
	}
	
	syn boolean FExp.canExtractRecordComponents()      = false;
	eq FIdUseExp.canExtractRecordComponents()          = true;
	eq FRecordConstructor.canExtractRecordComponents() = true;
	eq FArray.canExtractRecordComponents()             = true;
	eq FAbstractCat.canExtractRecordComponents()       = true;
	
	/**
	 * \brief Create an FExp that represents a specific component of this record expression.
	 * 
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.extractRecordFExp(String suffix) {
		throw new UnsupportedOperationException("Can't extract record component of " + getClass().getSimpleName());
	}
	
	public FExp FIdUseExp.extractRecordFExp(String suffix) {
		FQName name = getFIdUse().getFQName().copyAndAppend(suffix);
		return new FIdUseExp(name);
	}
	
	public FExp FRecordConstructor.extractRecordFExp(String suffix) {
		return getArg(getRecord().myFRecordDecl().indexOf(suffix)).fullCopy();
	}
	
	public FExp FArray.extractRecordFExp(String suffix) {
		FArray res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FAbstractCat.extractRecordFExp(String suffix) {
		FInfArgsFunctionCall res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FCatExp.extractRecordFExp(String suffix) {
		FCatExp res = (FCatExp) super.extractRecordFExp(suffix);
		res.setDim(getDim().fullCopy());
		return res;
	}
	
	public FExp FNoEventExp.extractRecordFExp(String suffix) {
		return createNode(getFExp().extractRecordFExp(suffix));
	}
	
	/**
	 * \brief Generate equations from an attribute of a record variable.
	 */
	public void FAttribute.genBindingEquations(FClass fc, FRecordDecl rec, FQName prefix, boolean depPar) {
		FVariable comp = (FVariable) rec.findComponent(getName().getFQName());
		if (!comp.isUnknown() && !comp.isConstant()) {
			FQName fqn = prefix.copyAndAppend(getName().getFQName());
			
			if (hasValue()) {
				boolean indPar = !depPar && comp.isParameter() && getValue().isIndependentParameterExp();
				// TODO: handle 'each'
				if (!indPar) {
					FEquation feq = new FEquation(new FIdUseExp(fqn), getValue());
					if (depPar || comp.isParameter())
						fc.addFParameterEquation(feq);
					else
						fc.addFEquation(feq);
					setValueOpt(new Opt());
				}
			}
			
			if (comp.isRecord()) {
				FRecordDecl next = comp.myFRecordDecl();
				for (FAttribute a : getFAttributes())
					a.genBindingEquations(fc, next, fqn, depPar);
			}
		}
	}
	
	/**
	 * \brief Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		beginStep("genAlgorithmFunctions()");

		for (FAlgorithmBlock alg : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FQName funcName = new FQName(alg.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FIdUse use : alg.usedFIdUses()) {
				FAbstractVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FIdUse use : alg.assignedFIdUses()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
					FQName fqn = new FQName(name);
					ffv.setFQName(fqn);
					
					// Create and add binding expression for output
					bothInVars.get(i).setBindingExp(fqn.createFIdUseExp());
				}
			}
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
			FFunctionCall call = new FFunctionCall(funcName.createFIdUse(), args, sizes);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFQName().createFFunctionCallLeft());
			replaceEquation(alg, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			alg.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, alg, new Opt()));
		}
		
		endStep("genAlgorithmFunctions()");
	}
	
	/**
	 * \brief Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		for (FEquationBlock b : getFEquationBlocks())
			if (b.getFAbstractEquations().replaceChild(oldEq, newEq))
				return;
	}
	
	/**
	 * \brief Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FQName.createFFunctionCallLeft() {
		FQName fqn = fullCopy();
		fqn.setLastFArraySubscripts(null);
		return new FFunctionCallLeft(new Opt(new FIdUseExp(fqn)));
	}

	/**
	 * \brief Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return createFPreExp();
			if (isContinuous())
				return createStartAttributeExp();
		}
		return createUseExp();
	}
	
	/**
	 * \brief Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(new FOutput());
	}

	/**
	 * \brief Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(new FInput());
	}

	/**
	 * \brief Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(FTypePrefixInputOutput io) {
		FType type = (FType) type().fullCopy();
		return new FFunctionVariable(new Opt(io), type, new Opt(), getFQName().fullCopy());
	}

	/**
	 * \brief Add derivative variables to the list of FVariables, one for each
	 * differentiate variable.
	 */
	public void FClass.addFDerivativeVariables() {
		beginStep("addFDerivativeVariables()");
		ArrayList<FDerivativeVariable> l = new ArrayList<FDerivativeVariable>();
		for (FVariable fv : differentiatedRealVariables()) {
		    FDerivativeVariable fdv = new FDerivativeVariable(fv.getFVisibilityType().fullCopy(),
					fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy());
			fdv.setMeIntegrated(fv);
			fv.setMeDifferentiated(fdv);
			l.add(fdv);
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
		root().flushAllRecursive();
		endStep("addFDerivativeVariables()");
	}

	public FVariable FClass.addFDerivativeVariable(FVariable fv) {
		FVariable ffv = fv.createFDerivativeVariable();
		addFVariable(ffv);
		root().flushAllRecursive();
		return ffv;
	}

	public FVariable FVariable.createFDerivativeVariable() {
		return null;
	}

	public FVariable FRealVariable.createFDerivativeVariable() {
		return new FDerivativeVariable((FVisibilityType)getFVisibilityType().fullCopy(),
					getFTypePrefixVariability().fullCopy(), getFQName().fullCopy());
	}

	public FVariable FDerivativeVariable.createFDerivativeVariable() {
		return new FHDerivativeVariable((FVisibilityType)getFVisibilityType().fullCopy(),
					getFTypePrefixVariability().fullCopy(), getFQName().fullCopy(), 2);
	}

	public FVariable FHDerivativeVariable.createFDerivativeVariable() {
		return new FHDerivativeVariable((FVisibilityType)getFVisibilityType().fullCopy(),
					getFTypePrefixVariability().fullCopy(), getFQName().fullCopy(), getOrder() + 1);
	}

	/**
	 * \brief Add pre variables to the list of FVariables, one for each
	 * discrete variable.
	 */
	public void FClass.addFPreVariables() {
		beginStep("addFPreVariables()");
		ArrayList<FVariable> l = new ArrayList<FVariable>();
		for (FVariable fv : discreteVariables()) {
			l.add(fv.createPreVariable());
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
		root().flushAllRecursive();
		endStep("addFPreVariables()");
	}
	
	/**
	 * Create a pre variable for this variable.
	 */
	abstract public FVariable FVariable.createPreVariable();
	
	public FVariable FRealVariable.createPreVariable() {
		return new FPreRealVariable(this);
	}
	
	public FVariable FIntegerVariable.createPreVariable() {
		return new FPreIntegerVariable(this);
	}
	
	public FVariable FEnumVariable.createPreVariable() {
		return new FPreEnumVariable(this);
	}
	
	public FVariable FBooleanVariable.createPreVariable() {
		return new FPreBooleanVariable(this);
	}
	
	public FVariable FStringVariable.createPreVariable() {
		return new FPreStringVariable(this);
	}
	
	public FVariable FRecordVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}


	/**
	 * \brief Generate initial equations from variables with fixed start
	 * attributes.
	 * 
	 * Intitial equations corresponding to explicitly set start attributes of 
	 * differentiated variables are also generated, without taking the fixed
	 * attribute into account.
	 */
	public void FClass.genInitialEquations() {
		beginStep("genInitialEquations()");
		// TODO: Isn't there always a value for fv.startAttributeExp() now?
		if (!root().options.getBooleanOption("state_initial_equations")) {
			for (FRealVariable fv : differentiatedRealVariables()) {
				if (fv.fixedAttribute() ||
						(root().options.getBooleanOption("state_start_values_fixed") 
								&& fv.startAttributeSet())) {
					addFInitialEquation(new FEquation(new FIdUseExp(
							new FIdUse(fv.getFQName().fullCopy())),
							fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp(0.0)));
				}	
			}
			for (FRealVariable fv : algebraicRealVariables()) {
				if (fv.fixedAttribute()) {
					addFInitialEquation(new FEquation(new FIdUseExp(
							new FIdUse(fv.getFQName().fullCopy())),
							fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp(0.0)));
				}	
			}
		}
//		log.debug(prettyPrint(""));
		for (FRealVariable fv : discreteRealVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FIntegerLitExp(0)));
			}	
		}
		for (FIntegerVariable fv : discreteIntegerVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FIntegerLitExp(0)));
			}	
		}
		for (FBooleanVariable fv : discreteBooleanVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse()));
			}	
		}		
		for (FEnumVariable fv : discreteEnumVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FPreExp(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy()))),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse()));
			}	
		}		

		//flush();
		root().flushAllRecursive();
		endStep("genInitialEquations()");
	}
	

	/**
	 * Perform alias elimination if it is activated.
	 */
	public void FClass.aliasEliminationIfSet() {
		if (root().options.getBooleanOption("eliminate_alias_variables")) {
			beginStep("aliasEliminationIfSet()");
			genAlias();
			eliminateAliasVariables();
			removeUnusedTemporaries();
			mergeEquivalentRecords();
			endStep("aliasEliminationIfSet()");
		}
	}

	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * \brief A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public boolean FVariable.canBeAliasEliminated(FVariable that) {
	
		// The only case where it is allowed to eliminate an 
		// alias equation containing a derivative is when the
		// other access is to an algebraic: der(x) = w
	
		if ((this.isDerivativeVariable() /*&& !that.isAlgebraicVariable()*/) ||
		    (that.isDerivativeVariable() /*&& that.isDerivativeVariable()*/)) {
		    //System.out.println(">>>>>>>> " + this.name() + " " + that.name());
		 	return false;   	
		}
	
		return true;
		 
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	public boolean FAbstractEquation.aliasClassified = false;
	public boolean FAbstractEquation.classifiedAsAlias = false;
	
	/**
	 * \brief Detection of alias variables in equations
	 * 
	 * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
	 * as alias equations and an AliasPair object is returned.
	 */
	public AliasPair FEquation.aliasVariables() {
		AliasPair res = null;
		if (!hasResidues()) // This equation should not be alias-removed if it is marked as residue!
			res = aliasVariables(getLeft(), getRight(), 1);
		aliasClassified = true;
		classifiedAsAlias = res != null;
		return res;
	}
	
	/**
	 * Determine if two expressions would form an alias pair if on the left and right sides of 
	 * an equation.
	 * 
	 * @param e1    an expression that would form one side of the equation
	 * @param e2    an expression that would form the other side of the equation
	 * @param sign  alias sign is multiplied with this - useful for e.g. 0 = x + y
	 */
	public static AliasPair ASTNode.aliasVariables(FExp e1, FExp e2, int sign) {
		if (e1.canBeAlias() && e2.canBeAlias()) {   // x = y, etc.
			FVariable fv1 = e1.variableThatCanBeAlias();
			FVariable fv2 = e2.variableThatCanBeAlias();
			boolean negated = e1.aliasSign() * e2.aliasSign() * sign < 0;
			return new AliasPair(fv1, fv2, negated);
		} else {                                    // 0 = x + y, etc
			FExp eqZero = null;
			if (e1.isConstantZero())
				eqZero = e2;
			else if (e2.isConstantZero())
				eqZero = e1;
			if (eqZero != null)
				return eqZero.aliasVariables();
			else
				return null;
		}
	}
	
	/**
	 * \brief Detection of alias variables in expressions
	 * 
	 * Only valid when in an equation that gives that the value of this expression is always 0.
	 */
	public AliasPair FExp.aliasVariables() {
		return null;
	}
	
	public AliasPair FDotAddExp.aliasVariables() {
		return aliasVariables(getLeft(), getRight(), -1);
	}
	
	public AliasPair FDotSubExp.aliasVariables() {
		return aliasVariables(getLeft(), getRight(), 1);
	}
	
	syn boolean FExp.canBeAlias() = false;
	eq FIdUseExp.canBeAlias()     = myFV() instanceof FVariable;
	eq FDerExp.canBeAlias()       = false;
	eq FNegExp.canBeAlias()       = getFExp().canBeAlias();
	
	syn int FExp.aliasSign() = 1;
	eq FNegExp.aliasSign()   = -getFExp().aliasSign();
	
	syn FVariable FExp.variableThatCanBeAlias() = null;
	eq FIdUseExp.variableThatCanBeAlias()       = (FVariable) myFV();
	eq FNegExp.variableThatCanBeAlias()         = getFExp().variableThatCanBeAlias();
	
	syn boolean FExp.isConstantZero() = 
		isLiteralExp() && type().isNumericScalar() && ceval().realValue() == 0.0;
	
//	syn boolean FExp.isConstantOne() = 
//		isLiteralExp() && type().isNumericScalar() && ceval().realValue() == 1.0;
	
	syn boolean FExp.isLiteralExp() = false;
	eq FLitExp.isLiteralExp()       = true;
	
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	// If an equation has been classified, the result needs to be cached 
	// in order to avoid reclassification after alias rewrites.
	eq FEquation.isAliasEquation() = aliasClassified? classifiedAsAlias: aliasVariables()!=null;
	
	/**
	 * \brief Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		if (aliasManager==null) {
			aliasManager = new AliasManager();
		}
		//System.out.println("****************************************");
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations
			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
			//System.out.println(equation.prettyPrint(" -- "));
			// Check all alias equations, also those that that have bee
			// checked before.
			equation.aliasClassified = false; 
			if (equation.isAliasEquation()) {
				//System.out.println(equation.prettyPrint(" ----- "));
				AliasPair aliasPair = equation.aliasVariables();
				aliasManager.addAliasVariables(aliasPair.fv1,
						aliasPair.fv2, aliasPair.negated);
				//System.out.println(aliasManager.printAliasSets());
			}			
		}	
		//System.out.println("****************************************");
		//flush();
		root().flushAllRecursive(); // TODO: is this really needed? the tree isn't changed
	}

	/**
	 * \brief Flag indicating if alias variables have been eliminated from the
	 * model.
	 */
	public boolean FClass.aliasVariablesEliminated = false;
	
	/**
	 * \brief Eliminate alias variables from the flat model.
	 * 
	 * The non-alias variables are kept in the list FClass.FVariableList but the
	 * alias variables are moved to FClass.AliasVariablesList.
	 */
	public void FClass.eliminateAliasVariables() {
		ArrayList<FVariable> nonAliasVars = new ArrayList<FVariable>();
		ArrayList<FVariable> aliasVars    = new ArrayList<FVariable>();
		ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
		
		//log.debug("FClass.eliminateAliasVariables(): l1 " + nonAliasVars + " l2 " + aliasVars);
		
		// Go through all variables and insert in correct list
		int i = 1;
		for (FVariable fv : getAliasVariables()) {
				aliasVars.add(fv);
		}
		for (FVariable fv : getFVariables()) {
			if (fv.isAlias()) {
				aliasVars.add(fv);
			} else { 
				nonAliasVars.add(fv);
			}
		}
		
		// Remove alias equations.
		for (FAbstractEquation equation : getFEquationBlock(0).getFAbstractEquations()) 
			if (!equation.isAliasEquation()) 
				eqns.add(equation);

		setFVariableList(new List(nonAliasVars));
		setAliasVariableList(new List(aliasVars));
		getFEquationBlock(0).setFAbstractEquationList(new List(eqns));
		
		aliasVariablesEliminated = true;
		enableAliasRewrite();
		
		flush();
	}
	
	public void ASTNode.enableAliasRewrite() {
		for (ASTNode n : this)
			n.enableAliasRewrite();
	}
	
	public void FIdUseExp.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	public void FFunctionDecl.enableAliasRewrite() {
	}
	
	boolean FIdUseExp.rewriteAlias = false;
	
	/**
	 * \brief FIdUses referring to alias variables need to be changed to 
	 * FIdUses referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FIdUseExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (fv.isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
	
	/**
	 * \brief FDerExps referring to alias variables need to be changed to 
	 * FDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDerExp {
		when (rewriteAlias && !getFIdUse().myFV().isUnknown() && getFIdUse().myFV().isAlias()) to FExp {
			FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
			FExp new_exp = new FDerExp(new FIdUse(new_name));
			if (getFIdUse().myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/**
	 * \brief FDummyDerExps referring to alias variables need to be changed to 
	 * FDummyDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDummyDerExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/**
	 * \brief FHDummyDerExps referring to alias variables need to be changed to 
	 * FHDummyDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FHDummyDerExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/*
	 * Rewrite derivatives of parameters to zeros.
	 */
	rewrite FDerExp {
		when (!getFIdUse().myFV().isUnknown() &&
				((FVariable)getFIdUse().myFV()).variability().lessOrEqual(fParameter())) to FExp {
			return new FRealLitExp(0.0);
		}
	}
	
	
	/**
	 * Remove all unused temporary variables, and inline temporaries only used once.
	 */
	public void FClass.removeUnusedTemporaries() {
		ArrayList<FVariable> temps = tempVariables();
		int oldSize = Integer.MAX_VALUE;
		while (temps.size() < oldSize) {
			ArrayList<FVariable> temps2 = new ArrayList<FVariable>(temps.size());
			for (FVariable fv : temps) {
				if (fv.shouldEliminateTemporary())
					fv.inlineUses();
				else
					temps2.add(fv);
			}
			oldSize = temps.size();
			temps = temps2;
		}
		
		ArrayList<FVariable> vars = new ArrayList<FVariable>();
		for (FVariable fv : getFVariables())
			if (!fv.isTemporary())
				vars.add(fv);
		for (FVariable fv : temps)
			vars.add(fv);
		
		removeMarkedEqns();
		setFVariableList(new List(vars));
	}

	/**
	 * Check if this is a temporary variable that should be eliminated.
	 */
	syn boolean FVariable.shouldEliminateTemporary() = 
		isTemporary() && nonDefiningUses().size() <= 1 && definingUses().size() <= 1 && !usedAsFunctionCallLeft();
	
	/**
	 * Inline all non-defining uses of variable, and remove equation defining it.
	 * 
	 * NB: This assumes that the variable and any equations marked for removal will be removed.
	 */
	public void FVariable.inlineUses() {
		FExp value;
		if (hasBindingExp()) {
			value = getBindingExp();
		} else {
			if (definingUses().isEmpty())
				return;
			FAbstractEquation eqn = definingUses().iterator().next().myFEquation();
			if (!(eqn instanceof FEquation)) 
				return;
			value = ((FEquation) eqn).getRight();
			eqn.markedForRemoval = true;
		}
		
		if (nonDefiningUses().isEmpty())
			value.removeFromUses();
		value.parent = null;
		
		for (FIdUseExp use : nonDefiningUses())
			use.replaceMe(value.unboundCopy());
	}
	
	/**
	 * Flag for removing equation.
	 */
	public boolean FAbstractEquation.markedForRemoval = false;
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FExp.removeFromUses() {
		for (FExp e : childFExps())
			e.removeFromUses();
	}
	
	public void FIdUseExp.removeFromUses() {
		FAbstractVariable var = getFIdUse().myFV();
		var.uses().remove(this);
		var.definingUses().remove(this);
		var.nonDefiningUses().remove(this);
		for (FQNamePart p : getFIdUse().getFQName().getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.removeFromUses();
	}
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FSubscript.removeFromUses() {}
	
	public void FExpSubscript.removeFromUses() {
		getFExp().removeFromUses();
	}
	
	/**
	 * Remove all equations with <code>markedForRemoval == true</code>. 
	 */
	public void FClass.removeMarkedEqns() {
		setFInitialEquationList(removeMarkedEqns(getFInitialEquations()));
		setFParameterEquationList(removeMarkedEqns(getFParameterEquations()));
		FEquationBlock eb = getFEquationBlock(0);
		eb.setFAbstractEquationList(removeMarkedEqns(eb.getFAbstractEquations()));
	}
	
	/**
	 * Create a copy of the list with all equations with <code>markedForRemoval == true</code> removed. 
	 */
	private List<FAbstractEquation> FClass.removeMarkedEqns(List<FAbstractEquation> list) {
		List<FAbstractEquation> res = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : list)
			if (!eqn.markedForRemoval)
				res.add(eqn);
		return res;
	}
	
	/**
	 * Remove records that are equivalent, and update uses. 
	 */
	public void FClass.mergeEquivalentRecords() {
		computeEquivalentRecords();
		activateEquivalentRecordUseRewrite();
		List<FRecordDecl> list = new List<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			if (rec.equivalentRecordToKeep)
				list.add(rec);
		setFRecordDeclList(list);
	}
	
	public void FClass.computeEquivalentRecords() {
		ArrayList<FType> distinctTypes = new ArrayList<FType>();
		ArrayList<FRecordDecl> keptDecl = new ArrayList<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls()) {
			boolean found = false;
			FType type = rec.type();
			for (int i = 0; !found && i < distinctTypes.size(); i++) {
				if (type.typeCompatible(distinctTypes.get(i))) {
					found = true;
					rec.equivalentRecordGroup = i;
					if (rec.name().compareTo(keptDecl.get(i).name()) < 0) {
						keptDecl.get(i).equivalentRecordToKeep = false;
						rec.equivalentRecordToKeep = true;
						keptDecl.set(i, rec);
					}
				}
			}
			if (!found) {
				rec.equivalentRecordToKeep = true;
				rec.equivalentRecordGroup = distinctTypes.size();
				distinctTypes.add(type);
				keptDecl.add(rec);
			}
		}
		equivalentRecordMap = new HashMap<String,FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			equivalentRecordMap.put(rec.name(), keptDecl.get(rec.equivalentRecordGroup));
	}
	
	protected Map<String,FRecordDecl> FClass.equivalentRecordMap;
	
	public boolean FRecordDecl.equivalentRecordToKeep = false;
	public int FRecordDecl.equivalentRecordGroup = -1;
	
	public void ASTNode.activateEquivalentRecordUseRewrite() {
		for (ASTNode n : this)
			n.activateEquivalentRecordUseRewrite();
	}
	
	public void FFunctionVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		if (type().isRecord()) {
			rewriteEquivalentRecord = true;
			is$Final = false;
		}
	}
	
	public void FRecordVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	public void FRecordConstructor.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	private boolean FFunctionVariable.rewriteEquivalentRecord  = false;
	private boolean FRecordVariable.rewriteEquivalentRecord    = false;
	private boolean FRecordConstructor.rewriteEquivalentRecord = false;
	
	rewrite FFunctionVariable {
		when (rewriteEquivalentRecord)
		to FFunctionVariable {
			rewriteEquivalentRecord = false;
			setType(myFClass().createEquivalentRecordType(getType()));
			flushAll();
			return this;
		}
	}
	
	rewrite FRecordVariable {
		when (rewriteEquivalentRecord)
		to FRecordVariable {
			rewriteEquivalentRecord = false;
			setRecord(myFClass().createEquivalentRecordFQName(getRecord()));
			flushAll();
			return this;
		}
	}
	
	rewrite FRecordConstructor {
		when (rewriteEquivalentRecord)
		to FRecordConstructor {
			rewriteEquivalentRecord = false;
			getRecord().setFQName(myFClass().createEquivalentRecordFQName(getRecord().getFQName()));
			getRecord().flushAll();
			flushAll();
			return this;
		}
	}

	public FQName FClass.createEquivalentRecordFQName(FQName old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.getFQName().fullCopy() : old;
	}

	public FType FClass.createEquivalentRecordType(FType old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.type().sizedType(old.size()).fullCopy() : old;
	}
	
}

aspect MapWhenClauses{

	public void ASTNode.enableWhenEquationRewrite() {
		for (ASTNode n : this)
			n.enableWhenEquationRewrite();
	}

	public void FClass.enableWhenEquationRewrite() {
		beginStep("enableWhenEquationRewrite()");
		super.enableWhenEquationRewrite();
		endStep("enableWhenEquationRewrite()");
	}

	
	public void FWhenEquation.enableWhenEquationRewrite() {
		super.enableWhenEquationRewrite();
		rewriteWhenEquation = true;
		is$Final = false;
	}
	
	boolean FWhenEquation.rewriteWhenEquation = false;

	public abstract FIfWhenElseEquation FIfWhenElseEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause);
	
	public FIfWhenElseEquation FWhenEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FWhenEquation((FEquationType)getType().fullCopy(),eqns,guard,elseClause);
	}

	public FIfWhenElseEquation FIfEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FIfEquation((FEquationType)getType().fullCopy(),eqns,guard,elseClause);
	}

	public FIfWhenElseEquation FElseEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FElseEquation((FEquationType)getType().fullCopy(),eqns);
	}

	public FIfWhenElseEquation FIfWhenElseEquation.createSimpleIfWhenElseEquation(String varName, boolean copyGuard) {
		return null; //Not handled yet
	}

	public FIfWhenElseEquation FIfWhenEquation.createSimpleIfWhenElseEquation(String varName, boolean copyGuard) {
	
		// Copy guard
		FExp guard = null;
		if (copyGuard) {
			guard = getTest().fullCopy();
			guard.setParent(this);
			guard.traverseSymbolic(getTest());
		} else {
			guard = getTest();
		}
		
		// Find the right equation
		FAbstractEquation eqn = null;
		for (FAbstractEquation e : getFAbstractEquations()) {
		 	if (e.isSimple()) {
		 		for (FIdUseExp n : e.simpleLefts()) {
					if (n.name().equals(varName)) {
						eqn = e;
						break;
					}
		 		}
		 	}
		}
		
		if (eqn==null) {
			return null;
		}
		
		List eqns = new List().add(eqn);
		
		Opt o = null;
		// If there is an else when, split it
		if (hasElse()) {
			o = new Opt(getElse().createSimpleIfWhenElseEquation(varName,copyGuard));
		} else {
		    o = new Opt();
		}
		return createIfWhenElseEquation(eqns,guard,o);
	}

	public List FWhenEquation.splitWhenEquation() {
		List l = new List();
		int i = 0;
		for (FAbstractEquation e : getFAbstractEquations()) {
		 	if (e.isSimple()) {
		 		for (FIdUseExp n : e.simpleLefts()) {
		 			l.add(createSimpleIfWhenElseEquation(n.name(),i!=0));
		 		}
		 	}
		 	i++;
		}	
		return l;
	}

	rewrite FWhenEquation in FEquationBlock.getFAbstractEquation() {
		when (rewriteWhenEquation && getNumFAbstractEquation()>1) to List {
			return splitWhenEquation();
		}
	}
	
	syn lazy boolean FAbstractEquation.isSimple() = false;
	eq FEquation.isSimple() = (getLeft() instanceof FIdUseExp);
	
	syn lazy ArrayList<FIdUseExp> FAbstractEquation.simpleLefts() = new ArrayList<FIdUseExp>();
	
	eq FEquation.simpleLefts() {
		ArrayList<FIdUseExp> l = new ArrayList<FIdUseExp>();
		if (isSimple()) {
			l.add((FIdUseExp)getLeft());
		} 
		return l;
	}
	
	eq FFunctionCallEquation.simpleLefts() {
		ArrayList<FIdUseExp> l = new ArrayList<FIdUseExp>();
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
			    // Is this OK? According to spec function call lefts must be component refs.
				l.add((FIdUseExp)left.getFExp()); 
		return l;
	}
		
}


aspect TempVariables {
	
	protected ArrayList<FAbstractVariable> FAbstractEquation.ownedTempVars = null;
	
	protected ArrayList<FAbstractVariable> FAbstractEquation.NULL_EQUATION_LIST = 
		new ArrayList<FAbstractVariable>(0);
	
	
	/**
	 * Get the list of temporary variables that was created together with this equation.
	 */
	public ArrayList<FAbstractVariable> FAbstractEquation.ownedTempVariables() {
		return (ownedTempVars == null) ? NULL_EQUATION_LIST : ownedTempVars;
	}
	
	/**
	 * Add variable to the list of temporary variables that was created together with this equation.
	 */
	public void FAbstractEquation.addOwnedTempVariable(FAbstractVariable var) {
		if (ownedTempVars == null)
			ownedTempVars = new ArrayList<FAbstractVariable>();
		ownedTempVars.add(var);
	}
	
	/**
	 * Mark all owned temp variables for removal.
	 */
	public void FAbstractEquation.markTempVarsForRemoval() {
		for (FAbstractVariable var : ownedTempVariables())
			var.markedForRemoval = true;
	}
	
	public void FForClauseE.markTempVarsForRemoval() {
		super.markTempVarsForRemoval();
		for (FAbstractEquation eqn : getFAbstractEquations())
			eqn.markTempVarsForRemoval();
	}
	
	public void FIfWhenElseEquation.markTempVarsForRemoval() {
		super.markTempVarsForRemoval();
		for (FAbstractEquation eqn : getFAbstractEquations())
			eqn.markTempVarsForRemoval();
	}
	
	public void FIfWhenEquation.markTempVarsForRemoval() {
		super.markTempVarsForRemoval();
		if (hasElse())
			getElse().markTempVarsForRemoval();
	}
	
	/**
	 * Mark all temp variables that are owned by any eqiation in list for removal.
	 */
	public static void FAbstractEquation.markTempVarsForRemoval(List<FAbstractEquation> eqns) {
		for (FAbstractEquation eqn : eqns)
			eqn.markTempVarsForRemoval();
	}
	
	/**
	 * Flag for removing variable.
	 */
	public boolean FAbstractVariable.markedForRemoval = false;
	
	/**
	 * Remove all variables with <code>markedForRemoval == true</code>.
	 */
	public void FClass.removeMarkedVariables() {
		// TODO: consider alias variables
		List<FVariable> vars = new List<FVariable>();
		for (FVariable var : getFVariables())
			if (!var.markedForRemoval)
				vars.add(var);
		setFVariableList(vars);
		flushAllRecursive();
	}
	
}


aspect IfEquations {
	
	/*
	 * First rewrite those if equations that has constant or stuctural parameter test
	 * by evaluating the expressions and eliminating unreachable branches.
	 */

	public void ASTNode.enableIfEquationElimination() {
		for (ASTNode n : this)
			n.enableIfEquationElimination();
	}

	public void FClass.enableIfEquationElimination() {
		beginStep("enableIfEquationElimination()");
		super.enableIfEquationElimination();
		
		// Workaround for JastAdd bug
		setFInitialEquationList(cleanEmptyElse(getFInitialEquations()));
		FEquationBlock b = getFEquationBlock(0);
		b.setFAbstractEquationList(cleanEmptyElse(b.getFAbstractEquations()));
		
		// TODO: When workaround above is removed, add traversal to trigger the rewrites
		removeMarkedVariables();
		endStep("enableIfEquationElimination()");
	}
	
	public void FIfEquation.enableIfEquationElimination() {
		super.enableIfEquationElimination();
		eliminateIfEquation = true;
		is$Final = false;
	}
	
	private boolean FIfEquation.eliminateIfEquation = false;
	
	protected boolean FIfWhenElseEquation.hasEliminatedIfBranches = false;

	protected boolean FIfWhenElseEquation.eliminateOnParamTest = false;

	protected void FIfWhenElseEquation.setEliminateOnParamTest() {}

	protected void FIfEquation.setEliminateOnParamTest() {
		eliminateOnParamTest = true;
		getTest().markAsStructuralParameter();
		if (hasElse())
			getElse().setEliminateOnParamTest();
	}
	
	syn boolean FIfEquation.shouldEliminateIf() = 
		getTest().isConstantExp() || getTest().isParameterExp() && eliminateOnParamTest;
	
	rewrite FIfEquation {
		when (eliminateIfEquation && !hasEliminatedIfBranches) to FIfWhenElseEquation {
			hasEliminatedIfBranches = true;
			if (!shouldEliminateIf()) {
				return this;
			} else if (getTest().ceval().booleanValue()) {
				if (hasElse())
					getElse().markTempVarsForRemoval();
				return new FElseEquation(getType(), getFAbstractEquations());
			} else if (hasElse()) {
				markTempVarsForRemoval(getFAbstractEquations());
				return getElse();
			} else {
				markTempVarsForRemoval(getFAbstractEquations());
				return new FElseEquation(getType(), new List());
			}
		}	
	}	

	rewrite FElseEquation in FClass.getFInitialEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
	
	rewrite FElseEquation in FEquationBlock.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
	
	rewrite FElseEquation in FIfWhenElseEquation.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
			
	rewrite FElseEquation in FForClauseE.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}

	/*
	 * After we have eliminated if equations with constant (and possibly parameter)
	 * test expressions, then all if equations must be balanced, so we can rewrite to 
	 * a list of residual equations with if expressions.
	 */

	public void ASTNode.enableIfEquationRewrite() {
		for (ASTNode n : this)
			n.enableIfEquationRewrite();
	}

	public void FClass.enableIfEquationRewrite() {
		beginStep("enableIfEquationRewrite()");
		super.enableIfEquationRewrite();
		endStep("enableIfEquationRewrite()");
	}
	
	public void FIfEquation.enableIfEquationRewrite() {
		super.enableIfEquationRewrite();
		rewriteIfEquation = true;
		is$Final = false;
	}
	
	private boolean FIfEquation.rewriteIfEquation = false;
	
	syn Map<FAbstractVariable,FEquation> FIfWhenElseEquation.assignmentEquationMap() {
		calcAssignmentEquations();
		return assignmentEquationMap;
	}
	
	syn Set<FEquation> FIfWhenElseEquation.nonAssignmentEquationSet() {
		calcAssignmentEquations();
		return nonAssignmentEquationSet;
	}
	
	syn Set<FAbstractEquation> FIfWhenElseEquation.nonFEquationSet() {
		calcAssignmentEquations();
		return nonFEquationSet;
	}
	
	private Map<FAbstractVariable,FEquation> FIfWhenElseEquation.assignmentEquationMap = null;
	private Set<FEquation> FIfWhenElseEquation.nonAssignmentEquationSet = null;
	private Set<FAbstractEquation> FIfWhenElseEquation.nonFEquationSet = null;
	
	private void FIfWhenElseEquation.calcAssignmentEquations() {
		if (assignmentEquationMap == null || nonAssignmentEquationSet == null || nonFEquationSet == null) {
			assignmentEquationMap = new HashMap<FAbstractVariable,FEquation>();
			nonAssignmentEquationSet = new HashSet<FEquation>();
			nonFEquationSet = new HashSet<FAbstractEquation>();
			for (FAbstractEquation eqn : getFAbstractEquations()) {
				if (eqn instanceof FEquation) {
					FEquation feqn = (FEquation) eqn;
					FAbstractVariable var = feqn.assignedFV();
					if (var != null && !assignmentEquationMap.containsKey(var))
						assignmentEquationMap.put(var, feqn);
					else
						nonAssignmentEquationSet.add(feqn);
				} else {
					nonFEquationSet.add(eqn);
				}
			}
		}
	}
	

	syn FExp FAbstractEquation.createResidualExp() = null;
	eq FEquation.createResidualExp() {
		if (getLeft().isZeroLiteral())
			return getRight().fullCopy();
		if (getRight().isZeroLiteral())
			return getLeft().fullCopy();
		return new FSubExp(getLeft().fullCopy(), getRight().fullCopy());
	}
	
	// TODO: move to better suited source file
	syn boolean FExp.isZeroLiteral()  = false;
	eq FIntegerLitExp.isZeroLiteral() = getValue() == 0;
	eq FRealLitExp.isZeroLiteral()    = getValue() == 0.0;
	eq FArray.isZeroLiteral() {
		for (FExp e : getFExps())
			if (!e.isZeroLiteral())
				return false;
		return true;
	}
	
	syn FExp FAbstractEquation.assignmentExp() = null;
	eq FEquation.assignmentExp() =
		isAssignmentEqn() ? getRight() : null;	
	

	
	public static List<FAbstractEquation> ASTNode.cleanEmptyElse(List<FAbstractEquation> oldList) {
		List<FAbstractEquation> newList = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : oldList)
			if (!(eqn instanceof FElseEquation))
				newList.add(eqn);
		return newList;
	}
	
	public void FIfWhenElseEquation.cleanEmptyElse() {
		setFAbstractEquationList(cleanEmptyElse(getFAbstractEquations()));
	}
	
	public void FIfWhenEquation.cleanEmptyElse() {
		super.cleanEmptyElse();
		if (hasElse())
			getElse().cleanEmptyElse();
	}
	
	// TODO: Move to util
	public class ASTNode {
		
		public static <K, V> Set<V> valuesOfUnNamedKeys(Map<K, V> map, Set<K> namedKeys) {
			Set<V> res = new HashSet<V>();
			for (Map.Entry<K,V> e : map.entrySet())
				if (!namedKeys.contains(e.getKey()))
					res.add(e.getValue());
			return res;
		}
		
		public static <T> Set<T> intersection(Set<T> a, Set<T> b) {
			// TODO: use runtime type of a instead
			Set<T> res = new HashSet<T>();
			res.addAll(a);
			res.retainAll(b);
			return res;
		}
		
		public static <T> ArrayList<T> toSortedList(Collection<T> elems, Comparator<? super T> cmp) {
			ArrayList<T> res = new ArrayList<T>(elems.size());
			res.addAll(elems);
			Collections.sort(res, cmp);
			return res;
		}
		
	}
	
	protected static ArrayList<FEquation> FIfEquation.unmatchedEquations(
			FIfWhenElseEquation ifEqn, Set<FAbstractVariable> varsInBoth) {
		Set<FEquation> unMatchedAssign = 
			valuesOfUnNamedKeys(ifEqn.assignmentEquationMap(), varsInBoth);
		unMatchedAssign.addAll(ifEqn.nonAssignmentEquationSet());
		return toSortedList(unMatchedAssign, CHILD_ORDER_COMPARATOR);
	}

	syn List FIfEquation.createIfExpEquationList() {
		List<FAbstractEquation> l = new List<FAbstractEquation>();
		
		Set<FAbstractVariable> varsInBoth = 
			intersection(assignmentEquationMap().keySet(), getElse().assignmentEquationMap().keySet()); 
		for (FAbstractVariable v : toSortedList(varsInBoth, FAbstractVariable.NAME_COMPARATOR)) {
			FExp left = assignmentEquationMap().get(v).assignmentExp();
			FExp right = getElse().assignmentEquationMap().get(v).assignmentExp();
			FExp ifExp = new FIfExp(getTest().fullCopy(), left, right);
			l.add(new FEquation(getType().fullCopy(), v.createUseExp(), ifExp));
		}
		
		ParallelIterable<FEquation> unmatched = new ParallelIterable(new FEquation[2], 
				unmatchedEquations(this, varsInBoth), unmatchedEquations(getElse(), varsInBoth));
		for (FEquation[] eqs : unmatched) {
			FExp left = eqs[0].createResidualExp();
			FExp right = eqs[1].createResidualExp();
			FIfExp ifExp = new FIfExp(getTest().fullCopy(), left, right);
			l.add(new FEquation(getType().fullCopy(), eqs[0].type().zeroLiteral(), ifExp));
		}
		
		for (FAbstractEquation eqn : nonFEquationSet())
			l.add(eqn);
		for (FAbstractEquation eqn : getElse().nonFEquationSet())
			l.add(eqn);
		
		return l;
	}
	
	rewrite FIfEquation {
		when (rewriteIfEquation)
		to FElseEquation new FElseEquation(getType(), createIfExpEquationList());
	}

/*
	public boolean IfEquation.isSimpleIfEquation() {
		
	}


	syn boolean FIfWhenElseEquation.isSimpleIfWhenEquation(ArrayList<FVariable> vars) = false;
	
	eq FIfEquation.isSimpleIfWhenEquation(ArrayList<FVariable> vars) {
		// If list is empty, populate list
		for (FAbstractEquation eqn : getFAbstractEquations()) {
			if (!(eqn instanceof FEquation)) {
				return false;
			} 
			
			else if (((FEquation).getLeft()) instanceof {
				
			}	
		}
		
	}
	*/

}

aspect ParameterSorting {

	/**
	 * \brief Indicate if there exist cyclic parameter dependencies.
	 */
	public boolean FClass.cyclicParameters = false;
	
	/**
	 * \brief Index of equation during equation sorting.
	 */
	public int FAbstractEquation.sortingIndex = -1;
	
	public class FAbstractEquation {
		public static class SortingIndexComparator implements Comparator<FAbstractEquation> {
			public int compare(FAbstractEquation o1, FAbstractEquation o2) {
				return o1.sortingIndex - o2.sortingIndex;
			}
		}
	}
	
	public class FVariable {
		public static class SortingIndexComparator implements Comparator<FVariable> {
			public int compare(FVariable o1, FVariable o2) {
				return o1.parameterEquation().sortingIndex - o2.parameterEquation().sortingIndex;
			}
		}
	}
	
	/**
	 * \brief Creates a TreeSet that can hold FAbstractEquations, sorted by their sortingIndex.
	 */
	public static TreeSet<FAbstractEquation> FAbstractEquation.sortingSet() {
		return new TreeSet<FAbstractEquation>(new SortingIndexComparator());
	}
	
	/** 
	 * \brief Sorts a list of FVariables according to the sortingIndex of their equation.
	 */
	public static void FVariable.sortParameters(java.util.List<FVariable> vars) {
		Collections.sort(vars, new SortingIndexComparator());
	}
	
	/**
	 * \brief Sort dependent parameter equations.
	 * 
	 * This is a simple implementation of Kahn's topological sorting algorithm.
	 * This implementation will most likely be replaced by other graph 
	 * algorithms later on.
	 */
	public void FClass.sortDependentParameters() {
		beginStep("sortDependentParameters()");

		// Get the list of parameter equations and set up preliminary data.
		ArrayList<FAbstractEquation> eqns = getFParameterEquations().toArrayList();
		int n_eqns = eqns.size();
		List<FVariable> vars = getFVariables();
		int n_vars = getNumFVariable();
		for (int i = 0; i < n_eqns; i++)
			eqns.get(i).sortingIndex = i;
		for (FVariable fv : vars)
			fv.parameterEquation();  // Calculate these before changing anything
		
		// If there is nothing to do, return.
		if (n_eqns > 0) {
			
			// Set up data structures for the adjacency graph.
			ArrayList<HashSet<FAbstractEquation>> toNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
			ArrayList<HashSet<FAbstractEquation>> fromNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
			for (int i = 0; i < n_eqns; i++) {
				toNodes.add(new HashSet<FAbstractEquation>());
				fromNodes.add(new HashSet<FAbstractEquation>());
			}
			
			// For each equation
			for (FAbstractEquation eqn : eqns) {
				// Retrieve all variables referenced in right hand side
				Set<FVariable> deps = eqn.referencedFVariablesInRHS();
				// Build the actual adjacency graph.
				for (FVariable fv : deps) {
					FAbstractEquation depEqn = fv.parameterEquation();
					if (depEqn != null && depEqn.sortingIndex >= 0) {
						toNodes.get(depEqn.sortingIndex).add(eqn);		
						fromNodes.get(eqn.sortingIndex).add(depEqn);
					}
				}
			}	
					
			// Sort using algorithm described at
			// http://en.wikipedia.org/wiki/Topological_sorting
			List<FAbstractEquation> L = new List<FAbstractEquation>();
			Queue<FAbstractEquation> S = 
				new java.util.concurrent.ArrayBlockingQueue<FAbstractEquation>(n_eqns);
			
			// Add all nodes without incoming edges to S
			for (int i = 0; i < n_eqns; i++) 
				if (fromNodes.get(i).isEmpty()) 
					S.add(eqns.get(i));
			
			// Repeat while S is not empty
			int si = 0;
			int n_indep = 0;
			while (S.size() > 0) {
				// Remove a node n from S
				FAbstractEquation n = S.remove();
				// Take care of n
				if (n.isIndependentParameterEquation()) {
					/* This equation should be the binding expression of an independent parameter.
					 * There are several ways this could happen, e.g. using iteration expressions.
					 * These could be removed from list before sorting, but this way is simpler. */ 
					n.revertToBindingExp();
					n_indep++;
				} else {
					// Insert n into L
					L.add(n);
				}
				// For each node m with an edge e from n to m (in original order)
				Set<FAbstractEquation> nodes = FAbstractEquation.sortingSet();
				nodes.addAll(toNodes.get(n.sortingIndex));
				for (FAbstractEquation m : nodes) {
					// Remove edge e from fromNodes
					fromNodes.get(m.sortingIndex).remove(n);
					// If m has no incoming edges add m to S
					if (fromNodes.get(m.sortingIndex).isEmpty()) 
						S.add(m);
				}
				// Remove e from toNodes
				toNodes.get(n.sortingIndex).clear();
				// Done with n - update sortingIndex
				n.sortingIndex = si++;
			}
			
			// Not possible to find an ordering without cycles?
			if (L.getNumChild() != eqns.size() - n_indep) {
				cyclicParameters = true;
			} else {
			
				// Replace old parameter equation list
				setFParameterEquationList(L);
				
				// Rearrange parameters in same order as parameter equations
				ArrayList<FVariable> depParams = new ArrayList<FVariable>(n_eqns);
				ArrayList<Integer> depParamIndices = new ArrayList<Integer>(n_eqns);
				for (int i = 0; i < n_vars; i++) {
					FVariable fv = vars.getChild(i);
					if (fv.hasParameterEquation()) {
						depParams.add(fv);
						depParamIndices.add(new Integer(i));
					}
				}
				FVariable.sortParameters(depParams);
				for (int i = 0; i < depParams.size(); i++)
					vars.setChild(depParams.get(i), depParamIndices.get(i).intValue());
		
				// Flush AST since the structure has changed.
				flush();
				
				// Remove any binding expressions of variables with parameter equations
				for (FAbstractEquation eqn : L)
					eqn.removeBindingExpOfAssignedVars();
			}
		}

		endStep("sortDependentParameters()");
}
	
	/**
	 * Remove binding expression of variables assigned in this equation.
	 */
	public void FAbstractEquation.removeBindingExpOfAssignedVars() {}

	public void FEquation.removeBindingExpOfAssignedVars() {
		getLeft().removeBindingExpOfReferencedVars();
	}
	
	public void FFunctionCallEquation.removeBindingExpOfAssignedVars() {
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
				left.getFExp().removeBindingExpOfReferencedVars();
	}
	
	/**
	 * Remove binding expression of variables referenced in this expression.
	 */
	public void FExp.removeBindingExpOfReferencedVars() {
		for (FExp e : childFExps())
			e.removeBindingExpOfReferencedVars();
	}
	
	public void FIdUseExp.removeBindingExpOfReferencedVars() {
		getFIdUse().myFV().removeBindingExp();
	}
	
	/**
	 * Remove binding expression of this variable.
	 */
	public void FAbstractVariable.removeBindingExp() {}
	
	public void FVariable.removeBindingExp() {
		if (hasBindingExp())
			setBindingExpOpt(new Opt());
	}
	
	/**
	 * Test if this should be the binding expression of an independent parameter instead.
	 */
	syn boolean FAbstractEquation.isIndependentParameterEquation() = false;
	eq FEquation.isIndependentParameterEquation() = 
		getLeft().isFlatParameterUse() && getRight().isIndependentParameterExp();
	
	/**
	 * Test if this is a use of a parameter (in the flat tree).
	 */
	syn boolean FExp.isFlatParameterUse()   = false;
	eq FIdUseExp.isFlatParameterUse()       = getFIdUse().isFlatParameterUse();
	syn boolean FIdUse.isFlatParameterUse() = myFV().isParameter();
	
	/**
	 * Convert this parameter equation to a binding expression.
	 */
	public void FAbstractEquation.revertToBindingExp() {}
	public void FEquation.revertToBindingExp() {
		FVariable fv = (FVariable) ((FIdUseExp) getLeft()).getFIdUse().myFV();
		fv.setBindingExp(getRight());
	}

}

aspect DummyDerivatives {

	rewrite FDerExp {
		when (myFV().isDummyDer()) to FDummyDerExp {
			return new FDummyDerExp(getFIdUse());
		}
	}

	rewrite FHDerExp {
		when (myFV().isDummyDer()) to FHDummyDerExp {
			return new FHDummyDerExp(getFIdUse(),getOrder());
		}
	}
	
	syn boolean FAbstractVariable.isDummyDer() {
		return false;
	}
	
	eq FDummyDerivativeVariable.isDummyDer() {
		return true;
	}
	
	eq FHDummyDerivativeVariable.isDummyDer() {
		return true;	
	}

	public void ASTNode.enableFHDerRewrite() {
		for (ASTNode n : this)
			n.enableFHDerRewrite();
	}
	
	public void FHDerExp.enableFHDerRewrite() {
		rewriteFHDer = true;
		is$Final = false;
	}
	
	boolean FHDerExp.rewriteFHDer = false;

	public void FHDerivativeVariable.enableFHDerRewrite() {
		rewriteFHDer = true;
		is$Final = false;
	}
	
	boolean FHDerivativeVariable.rewriteFHDer = false;

	rewrite FHDerExp {
		when (rewriteFHDer) to FDerExp {
			StringBuffer str = new StringBuffer();
			for (int i=0;i<getOrder()-1;i++) {
				str.append("_der");
			}
			str.append("_");
			FQName fqn = getFIdUse().getFQName();
			str.append(fqn.getFQNamePart(fqn.getNumFQNamePart()-1).name());
			fqn.setFQNamePart(new FQNamePart(str.toString(),fqn.getFQNamePart(fqn.getNumFQNamePart()-1).getFArraySubscriptsOpt()),fqn.getNumFQNamePart()-1);
			return new FDerExp(new FIdUse(fqn));
		} 
	}

}

aspect TransformCanonicalErrorCheck {
	
	/**
	 * The number of DAE equations corresponds to the equivalent scalar number
	 * of equations.
	 */
	syn int FClass.numDAEEquations() = numScalarEquations();
	
	/**
	 * The number of equations in the DAE initialization system originating 
	 * from the DAE should be the same as the equivalent scalar number of
	 * equations. The equations may differ, however, due to inactive when
	 * clauses.
	 */
	syn int FClass.numDAEEquationsAtInitialization() 
		= numScalarEquationsAtInitialization();
	
	/**
	 * The number of unknown variables in the DAE corresponds to the number
	 * of real algebraic variables plus the number of derivative variables
	 * plus the number of discrete variables.
	 */
	syn int FClass.numDAEVariables() = 
		numAlgebraicRealVariables() + 
		numDifferentiatedRealVariables() + numDiscreteVariables();
	
	/**
	 * The number of equations in the DAE initialization system is the 
	 * number of scalar DAE equations plus the number of scalar initial
	 * equations.
	 */	
	syn int FClass.numDAEInitEquations() = numDAEEquationsAtInitialization() + 
		numInitialEquations();
	
	/**
	 * The number of unknowns in the DAE initialization system is the 
	 * number of unknowns in the DAE system plus the number of differentiated
	 * variables plus the number of (pre) discrete variables.
	 */
	syn int FClass.numDAEInitVariables() = numDAEVariables() + 
		numDifferentiatedRealVariables() + numDiscretePreVariables();
	
	public void FClass.checkFClassDimensions() {
		// Check dimensions of DAE
		int n_eq_F = numDAEEquations();
		int n_vars_F = numDAEVariables();
		if (n_eq_F != n_vars_F) 
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numDAEInitEquations();
		int n_vars_F0 = numDAEInitVariables();
		if (n_eq_F0 > n_vars_F0) 
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		
	}
	
	public void FClass.collectErrors() {
		if (cyclicParameters) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		}
		if (getAliasManager().aliasError()) {
			error(getAliasManager().getAliasErrorMessage());
		}
		for (String str : aliasErrors) {
			error(str);
		}
		for (String str : indexReductionErrors) {
			error(str);
		}
		checkDuplicateVariables();
		checkFClassDimensions();
		for (String str : structuralErrors()) {
			error(str);
		}		
		checkUnsupportedStreamConnections();
	}
}

aspect FlushFClass {
	/**
	 * \brief Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FIdUseExps and FDerExps in order to enable rewrites of such nodes
	 * after elimination of alias variables.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}
	
	public void FIdUseExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}
	
	public void FDerExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (ASTNode n : noTransform()) {
			n.flushAllRecursive();
		}
	}
	
	/**
	 * \brief Flush model AST and enable rewrites of FIdUseExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
}



aspect Tearing {
	
	
}



aspect FunctionInlining {

	/**
	 * If function inlining is enabled, inline all function calls that we can.
	 * 
	 * Then remove functions that aren't needed anymore.
	 */
	public void FClass.functionInliningIfSet() {
		String opt = root().options.getStringOption("inline_functions");
		if (opt != OptionRegistry.Inlining.NONE) {
			inlineFunctions(opt);
		}
	}
	
	/**
	 * Inline all function calls that we can.
	 */
	public void FClass.inlineFunctions(String opt) {
		beginStep("inlineFunctions()");
		new FunctionInliner(this, opt).inline();
		flushAllRecursive();
		removeUnusedTemporaries();
		flushAllRecursive();
		endStep("inlineFunctions()");
	}
	
	/**
	 * Helper class for inlining.
	 * 
	 * Keeps track of all required data and the current state of the inlining process.
	 */
	public class FunctionInliner {
		
		private String level;
		
		private FClass fc;
		private FFunctionDecl func;
		private List<FVariable> vars;
		private List<FAbstractEquation> normalEqns;
		private List<FAbstractEquation> paramEqns;
		
		private Map<String,FVariable> replMap;
		private Map<String,FVariable> lookupMap;
		private Map<String,Size> sizeMap;
		
		/**
		 * Create a new FunctionInliner to use with <code>fc</code>.
		 * 
		 * @param fc     the FClass to inline in
		 * @param level  decides how complex functions to inline, can take values 
		 *               from OptionRegistry.Inlining
		 */
		public FunctionInliner(FClass fc, String level) {
			this.fc = fc;
			this.level = level;
			vars = fc.getFVariables();
			normalEqns = fc.getFEquationBlock(0).getFAbstractEquations();
			paramEqns = fc.getFParameterEquations();
			// Make sure maps are calculated
			fc.parameterEquationsMap();
			fc.fullyQualifiedVariablesMap();
		}
		
		/**
		 * Inline all function calls that we can.
		 */
		public void inline() {
			inline(normalEqns);
			inline(paramEqns);
		}
		
		/**
		 * Inline all function calls that we can from a specific list of equations.
		 */
		public void inline(List<FAbstractEquation> eqns) {
			for (FAbstractEquation eqn : eqns) {
				while (eqn.hasInlinableFunctions(this)) {
					// Note that this will add new equations to eqns, so we depend on
					// List.iterator() to handle that correctly.
					eqn = eqn.inlineFunctions(this);
//					fc.clearFlatNameBinding();
				}
			}
		}
		
		/**
		 * Check if a given function should be inlined under the current inlining level.
		 */
		public boolean isInlinable(FFunctionDecl func) {
			if (level == OptionRegistry.Inlining.ALL)
				return func.isInlinable();
			if (level == OptionRegistry.Inlining.TRIVIAL)
				return func.isTrivialInlinable();
			return false;
		}
		
		/**
		 * Prepare for inlining a new function call.
		 * 
		 * @return  the map to use for lookups in the function during inlining.
		 */
		public Map<String,FVariable> startFunction(FFunctionDecl f) {
			replMap = new HashMap<String,FVariable>();
			lookupMap = new HashMap<String,FVariable>();
			sizeMap = new HashMap<String,Size>();
			func = f;
			return lookupMap;
		}
		
		public void setSizeOf(String name, Size size) {
			sizeMap.put(name, size);
		}

		/**
		 * Get the temporary variable that represents a specific variable of the function 
		 * currently being inlined.
		 * 
		 * @param name  the name of the variable
		 */
		public FVariable getReplacementVar(String name) {
			return replMap.get(name);
		}
		
		/**
		 * Check if this function inliner has created a temporary variable of the specified name.
		 * 
		 * @param name  the name of the temporary variable
		 */
		public boolean isReplacementVar(String name) {
			return lookupMap.get(name) != null;
		}

		/**
		 * Find the size of a specific variable of the function currently being inlined.
		 * 
		 * @param name  the name of the variable
		 */
		public Size lookupSize(String name) {
			return sizeMap.get(name);
		}

		/**
		 * Add a variable and (if not constant) an equation for an assignment.
		 * 
		 * @param oldName  the name of the variable that was assigned in the function
		 * @param value    the right-hand side of the equation
		 */
		public void addVarAndEqn(String oldName, FExp value) {
			FTypePrefixVariability variability = value.variability().fullCopy();
			FVariable var = addVar(oldName, variability, value.type());
			
			if (variability.constantVariability()) {
				var.setBindingExp(value.ceval().buildLiteral());
			} else {
				value = value.preventEvents();
				FEquation eqn = new FEquation(new FNormalEquation(), var.createUseExp(), value);
				addEquation(eqn, variability);
			}
		}

		/**
		 * Add variables and (if not constant) an equation for a function call statement.
		 * 
		 * @param lefts  the lefts of the function call statement
		 * @param call   the new function call
		 */
		public void addVarsAndFCEqn(List<FFunctionCallLeft> lefts, FAbstractFunctionCall call) {
			FTypePrefixVariability variability = call.variability().fullCopy();
			
			FExp[] exps = null;
			if (variability.constantVariability()) {
				try {
					CValue[] values = call.evaluate();
					exps = new FExp[values.length];
					for (int i = 0; i < values.length; i++)
						exps[i] = values[i].buildLiteral();
				} catch (ConstantEvaluationException e) {
					exps = null;
				}
			}

			int nLefts = lefts.getNumChild();
			if (exps == null)
				exps = new FExp[nLefts];
			FExp[] lExps = new FExp[nLefts];
			for (int i = 0; i < nLefts; i++) 
				lExps[i] = lefts.getChild(i).createInlineVars(this, exps[i], variability);
			
			if (!variability.constantVariability()) {
				call = (FAbstractFunctionCall) call.preventEvents();
				FFunctionCallEquation eqn = 
					new FFunctionCallEquation(new FNormalEquation(), new List(), call);
				for (FExp exp : lExps) {
					FFunctionCallLeft left = new FFunctionCallLeft();
					if (exp != null)
						left.setFExp(exp);
					eqn.addLeft(left);
				}
				addEquation(eqn, variability);
			}
		}
		
		private void addEquation(FAbstractEquation eqn, FTypePrefixVariability variability) {
			if (variability.parameterVariability()) {
				paramEqns.add(eqn);
				eqn.addToParameterEquationsMap(fc.parameterEquationsMap());
			} else {
				normalEqns.add(eqn);
			}
		}
		
		public FVariable addVar(String oldName, FTypePrefixVariability variability, FType type) {
			FQName name = new FQName(fc.nextTempVarName(func));
			if (type.isArray())
				name.setLastFArraySubscripts(type.size().flattenFArraySubscripts(new FQName()));
			
			FVariable var = type.createTempFVariable(name, variability);
			vars.add(var);
			vars.getChild(vars.getNumChild() - 1);
			
			replMap.put(oldName, var);
			lookupMap.put(var.name(), var);
			fc.fullyQualifiedVariablesMap().put(var.name(), var);
			return var;
		}
		
	}
	
	
	public void FExp.addInliningVarsAndEqns(FunctionInliner fi, String oldName) {
		fi.addVarAndEqn(oldName, this);
	}
	
	public void FArray.addInliningVarsAndEqns(FunctionInliner fi, String oldName) {
		fi.setSizeOf(oldName, size());
		Array arr = getArray();
		for (Index i : indices())
			arr.get(i).addInliningVarsAndEqns(fi, oldName + i);
	}
	
	public void FRecordConstructor.addInliningVarsAndEqns(FunctionInliner fi, String oldName) {
		oldName += ".";
		Iterator<FExp> exps = getArgs().iterator();
		for (FRecordComponentType part : ((FRecordType) type()).getComponents())
			exps.next().addInliningVarsAndEqns(fi, oldName + part.getName());
	}
	
	
	/**
	 * Create temporary variable(s) for this access when inlining a function call that 
	 * it is a left of, and return an access.
	 */
	public FExp FFunctionCallLeft.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		return hasFExp() ? getFExp().createInlineVars(fi, bExp, variability) : null;
	}
	
	/**
	 * Create temporary variable(s) for this access when inlining a function call that 
	 * it is a left of, and return an access. Non-access expressions returns null.
	 */
	public FExp FExp.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		return null;
	}
	
	public FExp FIdUseExp.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FVariable var = fi.addVar(scalarName(), variability, type());
		if (bExp != null)
			var.setBindingExp(bExp);
		return var.createUseExp();
	}
	
	public FExp FArray.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FArray bArr = (FArray) bExp;
		FArray res = new FArray();
		int n = getNumFExp();
		for (int i = 0; i < n; i++) {
			FExp cellBExp = (bArr != null) ? bArr.getFExp(i) : null;
			res.addFExp(getFExp(i).createInlineVars(fi, cellBExp, variability));
		}
		return res;
	}
	
	public FExp FRecordConstructor.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FRecordConstructor bRec = (FRecordConstructor) bExp;
		FRecordConstructor res = new FRecordConstructor(getRecord().fullCopy(), new List());
		Iterator<FExp> bArgs = (bRec != null) ? bRec.getArgs().iterator() : null;
		for (FExp arg : getArgs()) {
			FExp partBExp = (bArgs != null) ? bArgs.next() : null;
			res.addArg(arg.createInlineVars(fi, partBExp, variability));
		}
		return res;
	}
	

	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public FExp FExp.preventEvents() {
		if (generatesEvents()) {
			FNoEventExp res = new FNoEventExp();
			replaceMe(res);
			res.setFExp(this);
			return res;
		} else {
			for (FExp e : childFExps())
				e.preventEvents();
			return this;
		}
	}
	
	public FExp FNoEventExp.preventEvents() {
		return this;
	}
	
	public FExp FIdUseExp.preventEvents() {
		// TODO: traverse expressions in subscripts
		return this;
	}
	
	public FExp FFunctionCall.preventEvents() {
		for (FExp e : getArgs())
			e.preventEvents();
		return this;
	}
	
	/**
	 * Check if this expression generates events.
	 */
	syn boolean FExp.generatesEvents() = false;
	eq FIfExp.generatesEvents()        = true;
	// TODO: support more event-generating expressions
	
	/**
	 * Check if an equation contains any calls to functions that we can inline.
	 */
	syn boolean FAbstractEquation.hasInlinableFunctions(FunctionInliner fi) = false;
	eq FFunctionCallEquation.hasInlinableFunctions(FunctionInliner fi)      = 
		getCall().hasInlinableFunctions(fi);
	eq FEquation.hasInlinableFunctions(FunctionInliner fi)                  =
		getLeft().hasInlinableFunctions(fi) || getRight().hasInlinableFunctions(fi);
	eq FIfEquation.hasInlinableFunctions(FunctionInliner fi)                = 
		super.hasInlinableFunctions(fi) || (hasElse() && getElse().hasInlinableFunctions(fi));
	eq FWhenEquation.hasInlinableFunctions(FunctionInliner fi)              = false;
	eq FIfWhenElseEquation.hasInlinableFunctions(FunctionInliner fi) {
		for (FAbstractEquation eqn : getFAbstractEquations())
			if (eqn.hasInlinableFunctions(fi))
				return true;
		return false;
	}
	
	/**
	 * Check if an expression contains any calls to functions that we can inline.
	 */
	syn boolean FExp.hasInlinableFunctions(FunctionInliner fi) {
		for (FExp exp : childFExps())
			if (exp.hasInlinableFunctions(fi))
				return true;
		return false;
	}
	eq FFunctionCall.hasInlinableFunctions(FunctionInliner fi) =
		isInlinableFunctionCall(fi) || super.hasInlinableFunctions(fi);
	eq FIdUseExp.hasInlinableFunctions(FunctionInliner fi)     = 
		getFIdUse().getFQName().hasInlinableFunctions(fi);
	
	/**
	 * Check if any array subscripts contain any calls to functions that we can inline.
	 */
	syn boolean FQName.hasInlinableFunctions(FunctionInliner fi) {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
					if (sub.hasInlinableFunctions(fi))
						return true;
		return false;
	}
	
	/**
	 * Check if an array subscript contains any calls to functions that we can inline.
	 */
	syn boolean FSubscript.hasInlinableFunctions(FunctionInliner fi) = false;
	eq FExpSubscript.hasInlinableFunctions(FunctionInliner fi)       = 
		getFExp().hasInlinableFunctions(fi);
	
	/**
	 * Check if an expression is a call to a function that we can inline.
	 */
	syn boolean FExp.isInlinableFunctionCall(FunctionInliner fi) = false;
	eq FFunctionCall.isInlinableFunctionCall(FunctionInliner fi) = myFFunctionDecl().isInlinable(fi);
	

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public FAbstractEquation FAbstractEquation.inlineFunctions(FunctionInliner fi) {
		return this;
	}
	
	public FAbstractEquation FEquation.inlineFunctions(FunctionInliner fi) {
		getLeft().inlineFunctions(fi);
		getRight().inlineFunctions(fi);
		return this;
	}
	
	public FAbstractEquation FFunctionCallEquation.inlineFunctions(FunctionInliner fi) {
		if (getCall().isInlinableFunctionCall(fi)) {
			getCall().inline(fi);
			ArrayList<FFunctionVariable> outs = ((FFunctionCall) getCall()).myOutputs();
			int n = getNumLeft();
			ArrayList<FEquation> list = new ArrayList<FEquation>();
			for (int i = 0; i < n; i++) {
				if (getLeft(i).hasFExp()) {
					FQName name = outs.get(i).getFQName().fullCopy();
					name.setLastFArraySubscripts(null);
					name.scalarized = true;
					getLeft(i).getFExp().createInliningOutputEquations(list, fi, name, getType());
				}
			}
			replaceMeWithList(list);
			return (list.size() > 0) ? list.get(0) : null;
		} else {
			getCall().inlineFunctions(fi);
			return this;
		}
	}
	
	public FAbstractEquation FIfEquation.inlineFunctions(FunctionInliner fi) {
		super.inlineFunctions(fi);
		if (hasElse())
			getElse().inlineFunctions(fi);
		return this;
	}
	
	public FAbstractEquation FIfWhenElseEquation.inlineFunctions(FunctionInliner fi) {
		fi.inline(getFAbstractEquations());
		return this;
	}
	
	public void FExp.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		FVariable var = fi.getReplacementVar(name.name());
		FExp right = (var != null) ? var.createInlineUseFExp() : type().zeroLiteral();
		list.add(new FEquation(type.fullCopy(), this, right));
	}
	
	public void FArray.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		if (!name.hasFArraySubscripts())
			name.setLastFArraySubscripts(new FArraySubscripts());
		int i = 1;
		for (FExp exp : getFExps()) {
			FQName cellName = name.fullCopy();
			cellName.lastFQNamePart().getFArraySubscripts().addFSubscript(new FExpSubscript(i));
			exp.createInliningOutputEquations(list, fi, cellName, type);
			i++;
		}
	}
	
	public void FRecordConstructor.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		Iterator<FExp> args = getArgs().iterator();
		for (FRecordComponentType part : ((FRecordType) type()).getComponents()) {
			FQName partName = name.fullCopy();
			partName.addFQNamePart(part.getName());
			args.next().createInliningOutputEquations(list, fi, partName, type);
		}
	}
	
	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FExp.inlineFunctions(FunctionInliner fi) {
		for (FExp exp : childFExps())
			exp.inlineFunctions(fi);
	}
	
	public void FFunctionCall.inlineFunctions(FunctionInliner fi) {
		if (isInlinableFunctionCall(fi)) {
			inline(fi);
			FVariable var = fi.getReplacementVar(myOutputs().get(0).name());
			replaceMe(var.createInlineUseFExp());
		} else {
			super.inlineFunctions(fi);
		}
	}

	public void FIdUseExp.inlineFunctions(FunctionInliner fi) {
		getFIdUse().getFQName().inlineFunctions(fi);
	}

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FQName.inlineFunctions(FunctionInliner fi) {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
					sub.inlineFunctions(fi);
	}

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FSubscript.inlineFunctions(FunctionInliner fi) {}

	public void FExpSubscript.inlineFunctions(FunctionInliner fi) {
		getFExp().inlineFunctions(fi);
	}
	
	/**
	 * Inline this function call.
	 * 
	 * Base implementation throws exception.
	 */
	public void FAbstractFunctionCall.inline(FunctionInliner fi) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * Inline this function call. 
	 */
	public void FFunctionCall.inline(FunctionInliner fi) {
		myFFunctionDecl().inline(fi, getArgs());
	}
	
	/**
	 * Create a use exp for non-constant variables, and a literal for constant variables.
	 */
	public FExp FVariable.createInlineUseFExp() {
		try {
			return isConstant() ? ceval().buildLiteral() : createUseExp();
		} catch (ConstantEvaluationException e) {
			return createUseExp();
		}
	}
	
	private static final String ASTNode.REPLACE_UNKNOWN_CHILD_MSG = 
		"Trying to replace a child that is not found in the given position.";

	/**
	 * Replace a child of this node.
	 * 
	 * @param child  the child to replace
	 * @param repl   the node to replace it with
	 * @throws IllegalArgumentException  if <code>child</code> is not a child of this node
	 */
	private void ASTNode.replaceChild(ASTNode child, ASTNode repl) {
		int i = getIndexOfChild(child);
		if (i < 0)
			throw new IllegalArgumentException(REPLACE_UNKNOWN_CHILD_MSG);
		setChild(repl, i);
	}

	/**
	 * Replace a child of this node with a list of new nodes.
	 * 
	 * @param child  the child to replace
	 * @param repl   the node to replace it with
	 * @throws IllegalArgumentException  if <code>child</code> is not a child of this node
	 */
	private void ASTNode.replaceChildWithList(ASTNode child, Iterable<? extends ASTNode> repl) {
		int i = getIndexOfChild(child);
		if (i < 0)
			throw new IllegalArgumentException(REPLACE_UNKNOWN_CHILD_MSG);
		Iterator<? extends ASTNode> it = repl.iterator();
		if (it.hasNext()) {
			setChild(it.next(), i);
			while (it.hasNext())
				insertChild(it.next(), ++i);
		} else {
			removeChild(i);
		}
	}
	
	/**
	 * Replace this node in the tree.
	 * 
	 * @param repl  the node to replace it with
	 */
	protected void ASTNode.replaceMe(ASTNode repl) {
		ASTNode p = getParent();
		if (p != null)
			p.replaceChild(this, repl);
	}
	
	/**
	 * Replace this node in the tree with a list of new nodes.
	 * 
	 * @param repl  the list of nodes to replace it with
	 */
	protected void ASTNode.replaceMeWithList(Iterable<? extends ASTNode> repl) {
		ASTNode p = getParent();
		if (p != null)
			p.replaceChildWithList(this, repl);
	}
	
	
	// TODO: check for recursive functions
	/**
	 * Check if we can inline this function, given the inlining level set in <code>fi</code>.
	 */
	syn boolean FFunctionDecl.isInlinable(FunctionInliner fi) =
		fi.isInlinable(this);
	
	/**
	 * Check if we can inline this function.
	 */
	syn lazy boolean FFunctionDecl.isInlinable() =
		isAllInlinable(getFAlgorithmBlock().getFStatements());
	
	/**
	 * Check if this function falls under the "trivial" inlining category.
	 */
	syn lazy boolean FFunctionDecl.isTrivialInlinable() {
		if (myProtected().size() > 0)
			return false;
		for (FStatement stmt : getFAlgorithmBlock().getFStatements())
			if (!stmt.isOkTrivialInline())
				return false;
		for (FFunctionVariable out : myOutputs()) {
			TrivialInlineCheck chk = out.createTrivialInlineCheck();
			for (FIdUse use : out.assigningUses()) 
				chk.check(use);
			if (!chk.isOk())
				return false;
		}
		return true;
	}
	
	/**
	 * Helper method to find unsupported statements in isTrivialInlinable().
	 */
	syn boolean FStatement.isOkTrivialInline() = false;
	eq FAssignStmt.isOkTrivialInline()         = true;
	eq FFunctionCallStmt.isOkTrivialInline()   = getCall().isOkTrivialInline();
	eq FReturnStmt.isOkTrivialInline()         = isLast();
	eq FForStmt.isOkTrivialInline()            = isOkTrivialInlineInFor();
	
	/**
	 * Helper method to find unsupported statements in isTrivialInlinable().
	 */
	syn boolean FAbstractFunctionCall.isOkTrivialInline() = isIgnored();
	eq FFunctionCall.isOkTrivialInline()                  = myFFunctionDecl().isTrivialInlinable();
	
	/**
	 * Helper method to unsupported statements in isTrivialInlinable().
	 */
	syn boolean FStatement.isOkTrivialInlineInFor() = false;
	eq FAssignStmt.isOkTrivialInlineInFor()         = getLeft().myFV().size().isUnknown();
	eq FForStmt.isOkTrivialInlineInFor() {
		for (FStatement stmt : getForStmts())
			if (!stmt.isOkTrivialInlineInFor())
				return false;
		return true;
	}
	
	/**
	 * Create a TrivialInlineCheck object for this variable.
	 */
	public TrivialInlineCheck FAbstractVariable.createTrivialInlineCheck() {
		if (isArray()) {
			if (isRecord())
				return new TrivialInlineCheck.Unsupported();
			if (size().isUnknown())
				return new TrivialInlineCheck.UnknownArray();
			else
				return new TrivialInlineCheck.KnownArray(size().numElements());
		} else {
			if (isRecord())
				return new TrivialInlineCheck.Record(myFRecordDecl());
			else
				return new TrivialInlineCheck.Scalar();
		}
	}
	
	/**
	 * Recordkeeper object for checking that each output is assigned exactly once.
	 * 
	 * For arrays, a rough guess heuristic is used. Arrays of records and records 
	 * containing arrays of unknown size are not supported.
	 */
	public abstract class TrivialInlineCheck {
		protected abstract void check(FIdUse use, int i);
		public abstract boolean isOk();
		
		public void check(FIdUse use) { check(use, 1); }
		
		public static class Scalar extends TrivialInlineCheck {
			protected int n = 0;
			protected void check(FIdUse use, int i) { n++; }
			public boolean isOk()                   { return n == 1; }
		}
		
		public static class KnownArray extends Scalar {
			// TODO: check that each cell is assigned?
			protected int size;
			public KnownArray(int nElems) { size = nElems; };
			public boolean isOk()         { return n == size; }
		}
		
		public static class UnknownArray extends Scalar {
			// TODO: check sizes, and how loop indices are used?
			protected void check(FIdUse use, int i) { n += use.inForLoop() ? 1 : 2; }
		}
		
		public static class Record extends TrivialInlineCheck {
			protected Map<String,TrivialInlineCheck> parts;
			protected boolean namesOk;
			
			public Record(FRecordDecl rec) {
				namesOk = true;
				parts = new HashMap<String,TrivialInlineCheck>();
				for (FVariable v : rec.getFVariables())
					parts.put(v.name(), v.createTrivialInlineCheck());
			}
			
			protected void check(FIdUse use, int i) {
				TrivialInlineCheck part = parts.get(use.getFQName().getFQNamePart(i).getName());
				if (part != null)
					part.check(use, i + 1);
				else
					namesOk = false;
			}

			public boolean isOk() {
				for (TrivialInlineCheck part : parts.values())
					if (!part.isOk())
						return false;
				return namesOk;
			}
		}
		
		public static class Unsupported extends TrivialInlineCheck {
			protected void check(FIdUse use, int i) { }
			public boolean isOk()                   { return false; }
		}
		
		// TODO: records
	}
	
	inh boolean FIdUse.inForLoop();
	eq FForStmt.getForStmt().inForLoop()      = true;
	eq FAlgorithmBlock.getChild().inForLoop() = false;
	eq FlatRoot.getChild().inForLoop()        = false;
	eq InstRoot.getChild().inForLoop()        = false;
	
	
	/**
	 * Helper method to check if a list of statements are all inlinable.
	 */
	public static boolean ASTNode.isAllInlinable(Iterable<? extends FStatement> list) {
		for (FStatement stmt : list)
			if (!stmt.isInlinable())
				return false;
		return true;
	}
	
	/**
	 * Check if we can inline this statement.
	 */
	syn boolean FStatement.isInlinable() = false;
	eq FInitArrayStmt.isInlinable()      = true;
	eq FAssignStmt.isInlinable()         = true;
	eq FFunctionCallStmt.isInlinable()   = getCall().isIgnored() || !insideBranchedStmt();
	eq FReturnStmt.isInlinable()         = isLast();
	eq FForStmt.isInlinable()            = isAllInlinable(getForStmts());
	eq FIfStmt.isInlinable() {
		for (FIfWhenClause branch : getFIfWhenClauses())
			if (!isAllInlinable(branch.getFStatements()))
				return false;
		return isAllInlinable(getElseStmts());
	}
	// TODO: handle more types of stmts
	
	
	/**
	 * Flags that this function is being inlined.
	 */
	private boolean FFunctionDecl.duringInlining = false;
	
	/**
	 * Keep reference to function inliner during inlining for size lookup.
	 */
	public FunctionInliner FFunctionVariable.functionInliner = null;
	
	/**
	 * Inline a call to this function.
	 * 
	 * @param fi    the function inlining helper to use
	 * @param args  the argument list for the function call
	 */
	public void FFunctionDecl.inline(FunctionInliner fi, List<FExp> args) {
		duringInlining = true;
		tempLookupMap = fi.startFunction(this);
		flushAllRecursive();
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.functionInliner = fi;
		
		ArrayList<FFunctionVariable> inp = myInputs();
		for (int i = 0; i < inp.size(); i++) 
			args.getChild(i).addInliningVarsAndEqns(fi, inp.get(i).name());
		
		ArrayList<FFunctionVariable> outp = myOutputs();
		for (FFunctionVariable fv : outp) 
			if (fv.isArray())
				fi.setSizeOf(fv.name(), fv.size().copyAndReplaceReferences(fi, getDummyExp()));
		
		for (FStatement stmt : getFAlgorithmBlock().getFStatements()) 
			stmt.inline(fi);
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.functionInliner = null;
		
		tempLookupMap = null;
		duringInlining = false;
	}
	
	syn lazy FExp FFunctionDecl.getDummyExp() = new FNoExp();
	
	/**
	 * Inline this statement.
	 * 
	 * @param fi      the function inlining helper to use
	 */
	public void FStatement.inline(FunctionInliner fi) {}
	
	public void FAssignStmt.inline(FunctionInliner fi) {
		FExp right = getRight().fullCopy();
		right = getRight().dynamicFExp(right);
		right = right.replaceReferences(fi);
		FIdUse left = getLeft().fullCopy();
		left = ((FIdUseExp) getRight().dynamicFExp(new FIdUseExp(left))).getFIdUse();
		left.replaceReferencesInSubscripts(fi);
		right.addInliningVarsAndEqns(fi, left.scalarName());
	}

	public void FFunctionCallStmt.inline(FunctionInliner fi) {
		// Temporarily replace lefts with scalarized versions
		Map<String,FExp> empty = Collections.emptyMap();
		List<FFunctionCallLeft> oldLefts = getLefts();
		List<FFunctionCallLeft> newLefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft left : oldLefts)
			newLefts.add(left.scalarize(empty));
		setLeftList(newLefts);
		newLefts.clearScalarized();
		
		// Scalarize and replace references
		FExp call = getCall().scalarizeExp(empty);
		call = getCall().dynamicFExp(call);
		call.clearScalarized();
		call = call.replaceReferences(fi);
		
		fi.addVarsAndFCEqn(getLefts(), (FAbstractFunctionCall) call);
		
		// Restore old left list
		setLeftList(oldLefts);
	}

	public void FInitArrayStmt.inline(FunctionInliner fi) {
		FAbstractVariable fv = getFIdUseExp().myFV();
		fi.setSizeOf(fv.name(), fv.size().copyAndReplaceReferences(fi, getFIdUseExp()));
		fv.flushCache();
	}
	
	public void FIfStmt.inline(FunctionInliner fi) {
		// Reduce to list of assignments
		List<FStatement> stmts = new List<FStatement>();
		inlinePrepare(fi, stmts);
		
		// Add assignments to tree temporarily
		List<FStatement> oldElse = getElseStmts();
		setElseStmtList((List) stmts);
		getElseStmtList();
		
		// Inline them
		for (FStatement stmt : stmts)
			stmt.inline(fi);
		
		// Restore old else branch
		setElseStmtList(oldElse);
	}
	
	public void FForStmt.inline(FunctionInliner fi) {
		// Reduce to list of assignments
		List<FStatement> stmts = new List<FStatement>();
		inlinePrepare(fi, stmts);
		
		// Add assignments to tree temporarily
		List<FStatement> oldStmt = getForStmts();
		setForStmtList((List) stmts);
		getForStmtList();
		
		// Inline them
		for (FStatement stmt : stmts)
			stmt.inline(fi);
		
		// Restore old else branch
		setForStmtList(oldStmt);
	}
	
	// TODO: handle more types of stmts
	
	/**
	 * Simplify a statement into a list of assignments, that can then easily be inlined.
	 */
	public void FStatement.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {}

	public void FAssignStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		stmts.add(fullCopy());
	}

	public void FFunctionCallStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		if (!getCall().isIgnored())
			stmts.add(fullCopy());
	}

	public void FIfStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		List<FStatement> oldElse = getElseStmts();
		
		// Prepare contents
		List<FStatement> newElse = new List<FStatement>();
		for (FStatement stmt : oldElse)
			stmt.inlinePrepare(fi, newElse);
		setElseStmtList((List) newElse);
		
		// Combine branches to assignments with if-else expressions
		for (int i = getNumFIfWhenClause() - 1; i >= 0; i--) {
			newElse = getFIfWhenClause(i).inlineCombineBranches(fi, newElse);
			setElseStmtList((List) newElse);
		}
		
		// Write result to target list
		for (FStatement stmt : newElse)
			stmts.add(stmt);
		setElseStmtList(oldElse);
	}

	public void FForStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		List<FStatement> oldStmts = getForStmts();
		
		// Prepare contents
		List<FStatement> newStmts = new List<FStatement>();
		for (FStatement stmt : oldStmts)
			stmt.inlinePrepare(fi, newStmts);
		setForStmtList((List) newStmts);
		
		// Unroll loop
		FVariable index = getIndex().getFVariable();
		FExp loopExp = getIndex().getFExp();
		loopExp = loopExp.dynamicFExp(loopExp.fullCopy()).replaceReferences(fi);
		for (FExp e : loopExp.getArray().iterable()) {
			stmts.add(new FAssignStmt(index.createFIdUse(), e.fullCopy()));
			for (FStatement stmt : newStmts)
				stmts.add(stmt.fullCopy());
		}
		setForStmtList(oldStmts);
	}
	
	/**
	 * Create a list of assign statements with if-else expressions that is the 
	 * equivalent of two branches of an if-else statement.
	 * 
	 * @param fi         the function inliner to use
	 * @param elseStmts  the else branch to combine
	 */
	protected List<FStatement> FIfWhenClause.inlineCombineBranches(
			FunctionInliner fi, List<FStatement> elseStmts) {
		// Prepare contents
		List<FStatement> oldStmts = getFStatements();
		List<FStatement> newStmts = new List<FStatement>();
		for (FStatement stmt : oldStmts)
			stmt.inlinePrepare(fi, newStmts);
		setFStatementList((List) newStmts);
		
		// First inefficient implementation
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : newStmts)
			stmts.add(createIfElseAssignment(stmt, null));
		for (FStatement stmt : elseStmts)
			stmts.add(createIfElseAssignment(null, stmt));
		// End first implementation
		
		// Clean up
		setFStatementList(oldStmts);
		return stmts;
	}
	
	/**
	 * Create an assign statement with an if-else exception as the right side, 
	 * that is equivalent to two assignments to the the same variable. One 
	 * assignment from this if branch, and one other from the next branch.
	 * If one of the assignments is null, then an access to the variable being 
	 * assigned is used there (i.e. a no-op). At least one must be non-null.
	 * 
	 * If any of the statements is not an assign statement, then 
	 * IllegalArgumentException is thrown.
	 * 
	 * @param left   the assignment from this branch
	 * @param right  the assignment from the next branch
	 */
	protected FAssignStmt FIfWhenClause.createIfElseAssignment(FStatement leftStmt, FStatement rightStmt) {
		try {
			FAssignStmt left = (FAssignStmt) leftStmt;
			FAssignStmt right = (FAssignStmt) rightStmt;
			FIdUse var = ((left != null) ? left : right).getLeft().fullCopy();
			FExp test = getTest().fullCopy(); // TODO: use temp var instead
			FExp leftExp = createIfElseExpBranch(left, var);
			FExp rightExp = createIfElseExpBranch(right, var);
			return new FAssignStmt(var, new FIfExp(test, leftExp, rightExp));
		} catch (ClassCastException e) {
			throw new IllegalArgumentException();
		}
	}
	
	private FExp FIfWhenClause.createIfElseExpBranch(FAssignStmt ass, FIdUse var) {
		return (ass != null) ? ass.getRight().fullCopy() : new FIdUseExp(var.fullCopy());
	}
	
	/**
	 * Replace all variable references according to the inlining helper.
	 */
	public ASTNode ASTNode.replaceReferences(FunctionInliner fi) {
		for (ASTNode n : this)
			n.replaceReferences(fi);
		return this;
	}
	
	public FExp FExp.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		return this;
	}
	
	public FExp FSizeExp.replaceReferences(FunctionInliner fi) {
		if (getFExp() instanceof FIdUseExp) {
			String name = ((FIdUseExp) getFExp()).getFIdUse().name();
			FExp exp = fi.lookupSize(name).createFExp(dimension());
			replaceMe(exp);
			return exp;
		} else {
			return super.replaceReferences(fi);
		}
	}
	
	// TODO: Should probably be removed after simplification step has been added
	public FExp FIfExp.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		if (getIfExp().isConstantExp()) {
			boolean useThen = getIfExp().ceval().booleanValue();
			FExp exp = useThen ? getThenExp() : getElseExp();
			replaceMe(exp);
			return exp;
		}
		return this;
	}
	
	public FExp FIdUseExp.replaceReferences(FunctionInliner fi) {
		replaceReferencesInSubscripts(fi);
		FVariable var = fi.getReplacementVar(scalarName());
		FExp exp;
		if (var != null) {
			exp = dynamicFExp(var.createUseExp());
			if (var.isConstant()) {
				try {
					exp = exp.ceval().buildLiteral();
				} catch (ConstantEvaluationException e) {}
			}
		} else {
			if (fi.isReplacementVar(name())) {
				exp = this;
			} else if (isArray() && !size().isUnknown()) { 
				exp = getArray().buildWithReplacedReferences(fi, this);
			} else if (type().isRecord()) {
				exp = dynamicFExp(type().createRecordConstructor(getFIdUse().getFQName()));
				exp = exp.replaceReferences(fi);
			} else {
				exp = type().zeroLiteral();
			}
		}
		if (exp != this)
			replaceMe(exp);
		return exp;
	}
	
	public FExp FFunctionCall.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		Size[] old = getSizes();
		Size[] sizes = new Size[old.length];
		for (int i = 0; i < old.length; i++)
			if (old[i] != null)
				sizes[i] = old[i].copyAndReplaceReferences(fi, this);
		setSizes(sizes);
		return this;
	}
	
	public class Array {
		
		public FExp buildWithReplacedReferences(FunctionInliner fi, FExp context) {
			return buildFArray(new ReplaceReferenceBuilder(fi, context));
		}

		protected class ReplaceReferenceBuilder implements ElementBuilder {
	    	private FunctionInliner fi;
	    	private FExp context;
	    	
	    	public ReplaceReferenceBuilder(FunctionInliner fi, FExp context) {
	    		this.fi = fi;
	    		this.context = context;
	    	}
	    	
			public FExp build(FExp e) {
				return context.dynamicFExp(e).replaceReferences(fi);
			}
	    }
		
	}
	
	/**
	 * Replace all variable references in array subscripts according to the inlining helper.
	 */
	public void ASTNode.replaceReferencesInSubscripts(FunctionInliner fi) {
		for (ASTNode n : this)
			n.replaceReferencesInSubscripts(fi);
	}
	
	public void FExpSubscript.replaceReferencesInSubscripts(FunctionInliner fi) {
		getFExp().replaceReferences(fi);
	}
	
	/**
	 * Make a copy of this size with all variable references replaced according to the 
     * function inliner.
	 */
	public Size Size.copyAndReplaceReferences(FunctionInliner fi, FExp context) {
		return clone();
	}
	
	public MutableSize MutableSize.copyAndReplaceReferences(FunctionInliner fi, FExp context) {
		MutableSize res = clone();
		for (int i = 0; i < exps.length; i++)
			if (res.exps[i] != null)
				res.exps[i] = context.dynamicFExp(exps[i].fullCopy()).replaceReferences(fi);
		return res;
	}
	
	/*
	 * We must be able to tell the difference between discrete and continous expressions 
	 * during function inlining. Normally all expressions in functions are considered discrete.
	 */
	refine FlatVariability eq FFunctionDecl.getChild().inDiscreteLocation() = !duringInlining;
	
	/*
	 * We want to be able to scalarize all expressions (except size exps) fully during inlining.
	 */
	refine Scalarization eq FFunctionCallLeft.getFExp().canAcceptArray() = 
		Scalarization.FFunctionCallLeft.getFExp().canAcceptArray() && !duringFunctionInlining();
	refine Scalarization eq FFunctionCall.getArg().canAcceptArray()      = 
		Scalarization.FFunctionCallLeft.getArg().canAcceptArray() && !duringFunctionInlining();
	refine Scalarization eq FFunctionCall.getArg().wantsRecordCon()      = 
		Scalarization.FFunctionCall.getArg().wantsRecordCon() || duringFunctionInlining();
	eq FFunctionCallLeft.getFExp().wantsRecordCon()                      = 
		!inFunction() || duringFunctionInlining();

	inh boolean FFunctionCallLeft.duringFunctionInlining();
	inh boolean FExp.duringFunctionInlining();
	eq FFunctionDecl.getChild().duringFunctionInlining() = duringInlining;
	eq Root.getChild().duringFunctionInlining()          = false;
	
	/*
	 * Use the information we have on unknown sizes during inlining.
	 */
	refine Arrays eq FFunctionArray.size() {
		Size s = null;
		if (functionInliner != null)
			s = functionInliner.lookupSize(name());
		return (s == null) ? Arrays.FFunctionArray.size() : s;
	}
	
	
	/**
	 * Remove unused function declarations from the flat model.
	 */
	public void FClass.removeUnusedFunctions() {
		beginStep("removeUnusedFunctions()");
		getFVariables().markUsedFunctions();
		getFInitialEquations().markUsedFunctions();
		getFParameterEquations().markUsedFunctions();
		getFEquationBlocks().markUsedFunctions();
		List<FFunctionDecl> funcs = new List<FFunctionDecl>();
		for (FFunctionDecl func : getFFunctionDecls())
			if (func.functionIsUsed())
				funcs.add(func);
		setFFunctionDeclList(funcs);
		endStep("removeUnusedFunctions()");
	}
	
	private boolean FFunctionDecl.functionUsed = false;
	
	/**
	 * Has this function been marked as used?
	 */
	syn boolean FFunctionDecl.functionIsUsed() = functionUsed;
	
	/**
	 * Mark all called functions as used.
	 */
	public void ASTNode.markUsedFunctions() {
		for (ASTNode node : this)
			node.markUsedFunctions();
	}
	
	public void FFunctionCall.markUsedFunctions() {
		myFFunctionDecl().markUsedFunctions();
		super.markUsedFunctions();
	}
	
	public void FFunctionDecl.markUsedFunctions() {
		if (!functionUsed) {
			functionUsed = true;
			if (hasFDerivativeFunction() && 
			    (root().options.getBooleanOption("generate_ode_jacobian") || 
			     root().options.getBooleanOption("generate_dae_jacobian"))) {
				  getFDerivativeFunction().myFFunctionDecl().markUsedFunctions();	
			}
			super.markUsedFunctions();
		}
	}

}

aspect StateInitialEquations {
	
	public void FClass.addStateInitialEquationsIfSet() {
		if (root().options.getBooleanOption("state_initial_equations")) {
			beginStep("addStateInitialEquationsIfSet()");
			
			setFInitialEquationList(new List());
			
			for (FRealVariable fv : differentiatedRealVariables()) {
	            
				FQName nameToAdd = fv.getFQName().fullCopy();
				nameToAdd.getFQNamePart(0).setName("_start_" + nameToAdd.getFQNamePart(0).getName());
				FRealVariable fvToAdd = new FRealVariable(
						new FPublicVisibilityType(), new FParameter(), nameToAdd);
				fvToAdd.setBindingExp(fv.startAttributeExp().fullCopy());
				addFVariable(fvToAdd);                
				FEquation eqnToAdd = new FEquation(new FIdUseExp(fv.getFQName().fullCopy()),
				                                   new FIdUseExp(nameToAdd.fullCopy()));
				addFInitialEquation(eqnToAdd);    
				flushAllRecursive();               
			}
		
			endStep("addStateInitialEquationsIfSet()");
		}
	}
	
}