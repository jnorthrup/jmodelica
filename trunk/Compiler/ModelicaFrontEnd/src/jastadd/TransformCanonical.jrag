
/**
 * \brief Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical{

	/**
	 * \brief Transform the raw flattened model into a structured form.
	 * 
	 * Currently, the following operations are performed:
	 *  <ul>
	 *    <li> Binding equations for variables are converted into regular
	 *         equations by calling genBindingEquations().
	 *    <li> The model is scalarized, i.e., all array declarations and
	 *         equations are replaced by scalar declarations and equations
	 *    <li> Alias variables are eliminated from the model.
	 *    <li> Derivative variables are generated and inserted in the
	 *         list of FVariables by calling addFDerivativeVariables().
	 *    <li> Generate initial equations based on start attribute.
	 *    <li> Sort dependent parameters.
	 *  </ul>
	 */
	public void FClass.transformCanonical() {
		genBindingEquations();
		scalarize();
		if (root().options.getBooleanOption("eliminate_alias_variables")) {
			genAlias();
			eliminateAliasVariables();
		}
//		System.out.println(prettyPrint(""));
		addFDerivativeVariables();
		genInitialEquations();
		sortDependentParameters();
		//System.out.println(prettyPrint(""));
		root().flushAllRecursive();
		
	}
		
	/**
	 * \brief Convert variable binding equations into regular equations.
	 */
	public void FClass.genBindingEquations() {
		for (FVariable fv : getFVariables()) {
			if (fv.hasBindingExp() && !fv.isParameter() && !fv.isConstant()) {
				FExp bexp = fv.getBindingExp();
				fv.setBindingExpOpt(new Opt());
				// Do not copy array indices
				FQName var_name = fv.getFQName().fullCopy();
				var_name.getFQNamePart(var_name.getNumFQNamePart()-1).
				   setFArraySubscriptsOpt(new Opt());
				FEquation feq = new FEquation(new FIdUseExp(
						new FIdUse(var_name)),bexp);
				getFEquationBlock(0).addFAbstractEquation(feq);
			}
		}
//		flush();
		flushAllRecursive();
	}

	/**
	 * \brief Add derivative variables to the list of FVariables, one for each
	 * differentiate variable.
	 */
	public void FClass.addFDerivativeVariables() {
		ArrayList<FDerivativeVariable> l = new ArrayList<FDerivativeVariable>();
		for (FVariable fv : differentiatedRealVariables()) {
			l.add(new FDerivativeVariable((FVisibilityType)fv.getFVisibilityType().fullCopy(),
					(FTypePrefixVariability)fv.getFTypePrefixVariability().fullCopy(),
					new Opt(),
					new List(),
					new Opt(),
					new Opt(),
					fv.getFQName().fullCopy()));
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
				root().flushAllRecursive();
	}

	/**
	 * \brief Generate initial equations from variables with fixed start
	 * attributes.
	 * 
	 * Intitial equations corresponding to explicitly set start attributes of 
	 * differentiated variables are also generated, without taking the fixed
	 * attribute into account.
	 */
	public void FClass.genInitialEquations() {
		for (FRealVariable fv : realVariables()) {
			if (fv.fixedAttribute() ||
					(root().options.getBooleanOption("state_start_values_fixed") 
							&&  fv.isDifferentiatedVariable() && fv.startAttributeSet())) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp("0.0")));
			}	
		}
//		System.out.println(prettyPrint(""));
		for (FIntegerVariable fv : integerVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FIntegerLitExp("0")));
			}	
		}
		for (FBooleanVariable fv : booleanVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse()));
			}	
		}		
		//flush();
				root().flushAllRecursive();
	}
	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * \brief A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	/**
	 * \brief Detection of alias variables in equations
	 * 
	 * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
	 * as alias equations and an AliasPair object is returned.
	 */
	public AliasPair FEquation.aliasVariables() {

		AbstractFVariable afv1 = null;
		AbstractFVariable afv2 = null;
		
		FVariable fv1 = null;
		FVariable fv2 = null;
		boolean negated = false;
		
		if (getLeft() instanceof FIdUseExp && // x = y
					getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)getLeft()).myFV();
			afv2 = ((FIdUseExp)getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = false;
			}
		} else if (getLeft() instanceof FNegExp && // -x = y
				((FNegExp)getLeft()).getFExp() instanceof FIdUseExp &&
				getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)((FNegExp)getLeft()).getFExp()).myFV();
			afv2 = ((FIdUseExp)getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if (getLeft() instanceof FIdUseExp && // x = -y
					getRight() instanceof FNegExp &&
				((FNegExp)getRight()).getFExp() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)getLeft()).myFV();
			afv2 = ((FIdUseExp)((FNegExp)getRight()).getFExp()).myFV();	
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if (getLeft() instanceof FNegExp && // -x = -y
				((FNegExp)getLeft()).getFExp() instanceof FIdUseExp &&
				getRight() instanceof FNegExp &&
				((FNegExp)getRight()).getFExp() instanceof FIdUseExp
				) {
			afv1 = ((FIdUseExp)((FNegExp)getLeft()).getFExp()).myFV();
			afv2 = ((FIdUseExp)((FNegExp)getRight()).getFExp()).myFV();	
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = false;
			}
		} else if (getLeft() instanceof FLitExp && getLeft().ceval().realValue() == 0 && // 0 = x + y
				getRight() instanceof FAddExp &&
				((FAddExp)getRight()).getLeft() instanceof FIdUseExp &&
				((FAddExp)getRight()).getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)((FAddExp)getRight()).getLeft()).myFV();
			afv2 = ((FIdUseExp)((FAddExp)getRight()).getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		}
		
		if (fv1!=null && fv2!=null) {
			return new AliasPair(fv1,fv2,negated);
		} else {
			return null;
		}
		
	}
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	eq FEquation.isAliasEquation() = aliasVariables()!=null;
	
	/**
	 * \brief Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		aliasManager = new AliasManager();
		
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations

			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
			if (equation.isAliasEquation()) {
				AliasPair aliasPair = equation.aliasVariables();
				aliasManager.addAliasVariables(aliasPair.fv1,
						aliasPair.fv2, aliasPair.negated);
			}			
		}	
		//flush();
		root().flushAllRecursive();
	}

	/**
	 * \brief Flag indicating if alias variables have been eliminated from the
	 * model.
	 */
	public boolean FClass.aliasVariablesEliminated = false;
	
	/**
	 * \brief Eliminate alias variabels from the flat model.
	 * 
	 * The non-alias variables are kept in the list FClass.FVariableList but the
	 * alias variables are moved to FClass.AliasVariablesList.
	 */
	public void FClass.eliminateAliasVariables() {
		List<FVariable> nonAliasVars = new List<FVariable>();
		List<FVariable> aliasVars = new List<FVariable>();
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		
		//System.out.println("FClass.eliminateAliasVariables(): l1 " + nonAliasVars + " l2 " + aliasVars);
		
		// Go through all variables and insert in correct list
		for (FVariable fv : getFVariables()) {
			if (fv.isAlias()) {
				aliasVars.add(fv);
			} else {
				nonAliasVars.add(fv);
			}
		}
		
		// Remove alias equations.
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations
			if (!equation.isAliasEquation()) {
				eqns.add(equation);
			}			
		}	

		setFVariableList(nonAliasVars);
		setAliasVariableList(aliasVars);
		getFEquationBlock(0).setFAbstractEquationList(eqns);
		
		aliasVariablesEliminated = true;
		
		//root().flushAllRecursive();
		flush();
	}
	
	
	boolean FIdUseExp.rewritten = false;
	
	/**
	 * \brief FIdUses referring to alias variables need to be changed to 
	 * FIdUses referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FIdUseExp {
		when (!rewritten && myFClass() != null && 
				myFClass().aliasVariablesEliminated &&
				!myFV().isUnknown() && myFV().isAlias()) to FExp {
			FQName new_name = (FQName)((FVariable)myFV()).alias().getFQName().fullCopy();
			//FQName old_name = getFIdUse().getFQName();
//			System.out.println(" ************************************* FIdUseExp.rewrite " + old_name.name() + " -> " + new_name.name());
			FExp new_exp = null;
			FIdUseExp id = new FIdUseExp(new FIdUse(new_name));
			id.rewritten = true;
			if (myFV().isNegated()) {
				new_exp = new FNegExp(id);
			} else {
				new_exp = id;
			}
			return new_exp;
		}
	}
	
	/**
	 * \brief FDers referring to alias variables need to be changed to 
	 * FDers referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDer {
		when (!rewritten && myFClass() != null && 
				myFClass().aliasVariablesEliminated &&
				!getFIdUse().myFV().isUnknown() && getFIdUse().myFV().isAlias()) to FExp {
			FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
			//FQName old_name = getFIdUse().getFQName();
			FExp new_exp = null;
			FDer der_exp = new FDer(new FIdUse(new_name));
			der_exp.rewritten = true;
			if (getFIdUse().myFV().isNegated()) {
				new_exp = new FNegExp(der_exp);
			} else {
				new_exp = der_exp;
			}
			return new_exp;
		}
	}
}

aspect Scalarization {

	/**
	 * \brief Flag indicating if a variable is scalarized.
	 */
	boolean FQName.scalarized = false;
	
	syn boolean FVariable.isScalarized() = getFQName().isScalarized();
	syn boolean FQName.isScalarized() = scalarized;
	
	/**
	 * \brief Scalarize all variables and equations in the flat model.
	 */
	public void FClass.scalarize() {
		List<FVariable> vars = new List<FVariable>();
		List<FVariable> alias_vars = new List<FVariable>();
		//System.out.println("FClass.scalarize(): l1 " + vars + " l2 " + alias_vars);
		// Scalarize all non-alias variables
		for (FVariable fv : getFVariables()) {
			fv.scalarize(vars);
		}	
		// Scalarize alias variables
		for (FVariable fv : getAliasVariables()) {
			fv.scalarize(alias_vars);
		}			
		// Scalarize equations
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFEquationBlock(0).getFAbstractEquations()) {
			ae.scalarize(eqns);
		}
		getFEquationBlock(0).setFAbstractEquationList(eqns);
		setFVariableList(vars);
		setAliasVariableList(alias_vars);

		flush();		
	}
	
	/**
	 * \brief Scalarize the FVariable and put all scalarized variables in the
	 * list vars.
	 */
	public void FVariable.scalarize(List<FVariable> vars) {
		if (isArray()) {
			int ndims = ndims();
			int[] size = size();
			int[] index = new int[ndims];
			// Create an index counter
			IndexCounter ic = new IndexCounter(size);
			// Iterate over all indices
			for (int i=0;i<ic.numElements();i++) {
				// Copy original declaration
				FVariable fv_tmp = (FVariable)fullCopy();
				// Set new array subscripts corresponding to index counter
				fv_tmp.getFQName().getFQNamePart(fv_tmp.getFQName().getNumFQNamePart()-1).
				  setFArraySubscripts(ic.newFArraySubscripts());
				// Mark variable as scalarized (affects name printing etc.)
				fv_tmp.getFQName().scalarized = true;
				vars.addChild(fv_tmp);
				// Increase index counter
				ic.inc();
			}
			
		} else {
			// Duplicate FVariable even if it is not an array declaration.
			FVariable fv_tmp = (FVariable)fullCopy();
			fv_tmp.getFQName().scalarized = true;
			vars.addChild(fv_tmp);
		}
	}
	
	public void FAbstractEquation.scalarize(List<FAbstractEquation> eqns) {}
	
	/**
	 * \brief Scalarize equation and put all scalarized equations in list eqns.
	 */
	public void FEquation.scalarize(List<FAbstractEquation> eqns) {
		//System.out.println("FEquation.scalarize() " + ndims());
		if (ndims()==0) {
			/**
			 * If the equation is of dimension 0, i.e, already scalar,
			 * the equations is "scalarized" into a simple equation where
			 * e.g. built in functions are replaced by elementary operations.
			 */
			eqns.addChild(new FEquation(getLeft().scalarize(),
					getRight().scalarize()));
		} else if (ndims()>0) {
			/**
			 * If the expression is an array expression, then the FExp.array()
			 * element is used to generate scalar equations.
			 */
			// Get array size
			int[] size = size();
			// Create index counter
			IndexCounter cnt = new IndexCounter(size);
			// Iterate over all indices in index counter
			for (int i=0;i<cnt.numElements();i++) {
				eqns.addChild(new FEquation((FExp)getLeft().array().getElement(cnt.getCounterMinusOne()).fullCopy(),
						(FExp)getRight().array().getElement(cnt.getCounterMinusOne()).fullCopy()));
				cnt.inc();
			}

		}
	}
	
	/* Scalarization of expressions is needed in order to compute a simple
	 * scalar expression from an expression with ndims==0. For example, an
	 * FIdUse 'x[2]' needs to be marked as scalarized, and the expression
	 * scalar(x*A*x) needs to be replaced by a double sum.
	 */
	
	/**
	 * \brief Scalarize expressions.
	 */
	public FExp FExp.scalarize() {
		return null;
	}

    public FIdUse FIdUse.scalarize() {
    	FIdUse fid = (FIdUse)fullCopy();
    	fid.getFQName().scalarized = true;
    	return fid;
    }

    public FExp FIdUseExp.scalarize() {
    	return new FIdUseExp(getFIdUse().scalarize());
    }
    
    public FExp FIfExp.scalarize() {
		List etl = new List();
		for (int i=0;i<getNumFElseIfExp();i++) {
			etl.add(getFElseIfExp(i).scalarize());
		}
		return new FIfExp(getIfExp().scalarize(),
		                  getThenExp().scalarize(),
		                  etl,
		                  getElseExp().scalarize());
	}
	
	public FExp FElseIfExp.scalarize() {
		return new FElseIfExp(getIfExp().scalarize(),
		                      getThenExp().scalarize());
	}
	
	public FExp FAddExp.scalarize() { return new FAddExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FSubExp.scalarize() { return new FSubExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FMulExp.scalarize() { return new FMulExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FDivExp.scalarize() { return new FDivExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FPowExp.scalarize() { return new FPowExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FNegExp.scalarize() { return new FNegExp(getFExp().scalarize()); }

	public FExp FLtExp.scalarize() { return new FLtExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FLeqExp.scalarize() { return new FLeqExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FGtExp.scalarize() { return new FGtExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FGeqExp.scalarize() { return new FGeqExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FEqExp.scalarize() { return new FEqExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FNeqExp.scalarize() { return new FNeqExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FNotExp.scalarize() { return new FNotExp(getFExp().scalarize()); }
	public FExp FOrExp.scalarize() { return new FOrExp(getLeft().scalarize(),getRight().scalarize()); }
	public FExp FAndExp.scalarize() { return new FAndExp(getLeft().scalarize(),getRight().scalarize()); }

	public FExp FRealLitExp.scalarize() { return (FRealLitExp)fullCopy(); }
	public FExp FIntegerLitExp.scalarize() { return (FIntegerLitExp)fullCopy(); }
	public FExp FStringLitExp.scalarize() { return (FStringLitExp)fullCopy(); }
	public FExp FBooleanLitExpTrue.scalarize() { return (FBooleanLitExpTrue)fullCopy(); }
	public FExp FBooleanLitExpFalse.scalarize() { return (FBooleanLitExpFalse)fullCopy(); }
	
	public FExp FDer.scalarize() {return new FDer(getFIdUse().scalarize());}
	public FExp FSinExp.scalarize() { return new FSinExp(getFExp().scalarize()); }
	public FExp FCosExp.scalarize() { return new FCosExp(getFExp().scalarize()); }
	public FExp FTanExp.scalarize() { return new FTanExp(getFExp().scalarize()); }
	public FExp FAsinExp.scalarize() { return new FAsinExp(getFExp().scalarize()); }
	public FExp FAcosExp.scalarize() { return new FAcosExp(getFExp().scalarize()); }
	public FExp FAtanExp.scalarize() { return new FAtanExp(getFExp().scalarize()); }
	public FExp FAtan2Exp.scalarize() { return new FAtan2Exp(getFExp().scalarize(),getY().scalarize()); }
	public FExp FSinhExp.scalarize() { return new FSinhExp(getFExp().scalarize()); }
	public FExp FCoshExp.scalarize() { return new FCoshExp(getFExp().scalarize()); }
	public FExp FTanhExp.scalarize() { return new FTanhExp(getFExp().scalarize()); }
	public FExp FExpExp.scalarize() { return new FExpExp(getFExp().scalarize()); }
	public FExp FLogExp.scalarize() { return new FLogExp(getFExp().scalarize()); }
	public FExp FLog10Exp.scalarize() { return new FLog10Exp(getFExp().scalarize()); }
	public FExp FSqrtExp.scalarize() { return new FSqrtExp(getFExp().scalarize()); }
	
	public FExp FTimeExp.scalarize() { return new FTimeExp(); }
	public FExp FEndExp.scalarize() { return new FEndExp(); }

	/*
	public FExp FFunctionCall.scalarize() {
		List l = new List();
		List args = new List();
		for (FExp e : getArgss()) {
			l.add(e.scalarize());
		}
		return new FFunctionCall(getName().flatten(new FQName()),l);		
	}

	public FExp FSumRedExp.scalarize() {
		return new FSumRedExp(getFExp().scalarize(),
		                     getFForIndex().scalarize());
	}
	*/
	/*	
	public FForIndex FForIndex.scalarize() {
		return new FForIndex(getFIdDecl().scalarize(),
		                     hasFExp()? new Opt(getFExp().scalarize()): new Opt());
	}

	public void FForClauseE.flatten(FQName prefix, FClass fc) {
		List forIndex = new List();
		List eqns = new List();
		for (int i=0;i<getNumFForIndex();i++)
			forIndex.add(getFForIndex(i).scalarize());
		FClass fcc = new FClass();
		fcc.setFQName(new FQName().append("tmp")); 
		fcc.addFEquationBlock(new FEquationBlock(new List()));
		//fcc.dumpTree("");
		for (int i=0;i<getNumForEqns();i++)
			getForEqns(i).flatten(prefix,fcc);
		for (int i=0;i<fcc.getFEquationBlock(0).getNumFAbstractEquation();i++)
			eqns.add(fcc.getFEquationBlock(0).getFAbstractEquation(i));
		fc.getFEquationBlock(0).addFAbstractEquation(new FForClauseE(forIndex,eqns));
	}
	*/
}

aspect ParameterSorting {

	/**
	 * \brief Indicate if there exist cyclic parameter dependencies.
	 */
	public boolean FClass.cyclicParameters = false;
	
	/**
	 * \brief Sort dependent parameters.
	 * 
	 * This is a simple implementation of Kahn's topological sorting algorithm.
	 * This implementation will most likely be replaced by other graph 
	 * algorithms later on.
	 */
	public void FClass.sortDependentParameters() {
		
		// Retrieve the dependent parameter that will be sorted
		ArrayList<FVariable> dps = dependentParameters();
		
		// Create data structures for the adjacency graph.
		ArrayList<ArrayList<FVariable>> toNodes = new ArrayList<ArrayList<FVariable>>();	
		ArrayList<ArrayList<FVariable>> fromNodes = new ArrayList<ArrayList<FVariable>>();	
		
		// Initialize data structures.
		for(int i=0;i<numDependentParameters();i++) {
			toNodes.add(new ArrayList<FVariable>());
			fromNodes.add(new ArrayList<FVariable>());
		}
		
		// For each flat variable
		for (FVariable fv : dps) {
			// Retreive all variables referenced in binding expression
			ArrayList<FVariable> deps = fv.referencedFVariablesInBindingExp();
			// Build the actual adjacency graph.
			for (FVariable fv_add : deps) {
				if (!(dps.indexOf(fv_add)<0) && !toNodes.get(dps.indexOf(fv_add)).contains(fv)) {
					toNodes.get(dps.indexOf(fv_add)).add(fv);		
					fromNodes.get(dps.indexOf(fv)).add(fv_add);
				}
			}
		}	
				
		// Sort using algorithm described at
		// http://en.wikipedia.org/wiki/Topological_sorting
		ArrayList<FVariable> L = new ArrayList<FVariable>();
		ArrayList<FVariable> S = new ArrayList<FVariable>();
		
		// Add all nodes without incoming edges to S
		int i = 0;
		for (ArrayList<FVariable> l : fromNodes) {
			if (l.isEmpty()) {
				S.add(dps.get(i));
			}
			i++;
		}
		// Repeat while S is not empty
		while (!S.isEmpty()) {
			// Remove a node n from S
			FVariable n = S.remove(0);
			// Insert n into L
			L.add(n);
			// For each node m with an edge e from n to m
			for (FVariable m : toNodes.get(dps.indexOf(n))) {
				// Remove edge e from fromNodes
				fromNodes.get(dps.indexOf(m)).remove(n);
				// If m has no incoming edges add m to S
				if (fromNodes.get(dps.indexOf(m)).isEmpty()) {
					S.add(m);
				}
			}
			// Remove e from toNodes
			toNodes.get(dps.indexOf(n)).clear();
		}
		
		// Not possible to find an ordering without cycles?
		if (L.size()!=dps.size()) {
			cyclicParameters = true;
			return;
		}
		
		// Remove all dependent parameters from (in reversed order)
		for (i=getNumFVariable()-1;i>=0;i--) {
			if (dps.contains(getFVariable(i))) {
				getFVariableList().removeChild(i);
			}
		}

		// Add all dependent parameters in sorted order.
		for (FVariable fv : L) {
			addFVariable(fv);
		}

		// Flush AST since the structure has changed.
		//flush();
		root().flushAllRecursive();
	}	
		
}

aspect TransformCanonicalErrorCheck {
	
	public void FClass.checkFClassDimensions() {
		// Check dimensions of DAE
		int n_eq_F = numEquations();
		int n_vars_F = numAlgebraicRealVariables() + numDifferentiatedRealVariables();
		if (n_eq_F!=n_vars_F) {
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		}
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numInitialEquations() + numEquations();
		int n_vars_F0 = numAlgebraicRealVariables() + 2*numDifferentiatedRealVariables();
		if (n_eq_F0>n_vars_F0) {
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		}
		
	}
	
	public void FClass.collectErrors() {
		if (cyclicParameters) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		}
		if (getAliasManager().aliasError()) {
			error(getAliasManager().getAliasErrorMessage());
		}
		for (String str : aliasErrors) {
			error(str);
		}
		checkFClassDimensions();
	}
	
}


aspect FlushFClass {
	/**
	 * \brief Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FIdUseExps and FDers in order to enable rewrites of such nodes
	 * after elimination of alias variables.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
	public void FIdUseExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
	public void FDer.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursive();
		}
	}
	
	/**
	 * \brief Flush model AST and enable rewrites of FIdUseExps and FDers
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
}
