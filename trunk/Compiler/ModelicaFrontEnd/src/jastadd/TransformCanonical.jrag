/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * \brief Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

	/**
	 * \brief Transform the raw flattened model into a structured form.
	 * 
	 * Currently, the following operations are performed:
	 *  <ul>
	 *    <li> Binding equations for variables are converted into regular
	 *         equations by calling genBindingEquations().
	 *    <li> For each non-function algorithm:
	 *         <ul>
	 *           <li> A function is generated with the algorithm as body, 
	 *                any assigned variables as outputs and any used 
	 *                variables as inputs.
	 *           <li> The original algorithm is replaced with a call to 
	 *                the generated function.
	 *         </ul>
	 *    <li> The model is scalarized, i.e., all array declarations and
	 *         equations are replaced by scalar declarations and equations
	 *    <li> Alias variables are eliminated from the model.
	 *    <li> Derivative variables are generated and inserted in the
	 *         list of FVariables by calling addFDerivativeVariables().
	 *    <li> Generate initial equations based on start attribute.
	 *    <li> Sort dependent parameters.
	 *  </ul>
	 */
	public void FClass.transformCanonical() {
		genBindingEquations();
		genAlgorithmFunctions();
		scalarize();
		if (root().options.getBooleanOption("eliminate_alias_variables")) {
			genAlias();
			eliminateAliasVariables();
		}
//		System.out.println(prettyPrint(""));
		addFDerivativeVariables();
		genInitialEquations();
		sortDependentParameters();
		//System.out.println(prettyPrint(""));
		root().flushAllRecursive();
		
	}
		
	/**
	 * \brief Convert variable binding equations into regular equations.
	 */
	public void FClass.genBindingEquations() {
		for (FVariable fv : getFVariables()) {
			if (fv.hasBindingExp() && !fv.isParameter() && !fv.isConstant()) {
				FExp bexp = fv.getBindingExp();
				fv.setBindingExpOpt(new Opt());
				// Do not copy array indices
				FQName var_name = fv.getFQName().fullCopy();
				var_name.getFQNamePart(var_name.getNumFQNamePart()-1).
				   setFArraySubscriptsOpt(new Opt());
				FEquation feq = new FEquation(new FIdUseExp(
						new FIdUse(var_name)),bexp);
				getFEquationBlock(0).addFAbstractEquation(feq);
			}
		}
//		flush();
		flushAllRecursive();
	}
	
	/**
	 * \brief Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		for (FAlgorithmBlock a : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FQName funcName = new FQName(a.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FIdUse use : a.usedFIdUses()) {
				AbstractFVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FIdUse use : a.assignedFIdUses()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
					FQName fqn = new FQName(name);
					ffv.setFQName(fqn);
					
					// Create and add binding expression for output
					bothInVars.get(i).setBindingExp(fqn.createFIdUseExp());
				}
			}
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
			FFunctionCall call = new FFunctionCall(funcName.createFIdUse(), args, sizes);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFQName().createFFunctionCallLeft());
			replaceEquation(a, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			a.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, new Opt(a)));
		}
	}
	
	/**
	 * \brief Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		for (FEquationBlock b : getFEquationBlocks())
			if (b.getFAbstractEquations().replaceChild(oldEq, newEq))
				return;
	}
	
	/**
	 * \brief Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FQName.createFFunctionCallLeft() {
		return new FFunctionCallLeft(new Opt(new FIdUseExp(createFIdUse())));
	}

	/**
	 * \brief Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return null; // TODO: Return pre() value.
			if (isContinuous())
				return startAttributeExp();
		}
		return getFQName().createFIdUseExp();
	}
	
	/**
	 * \brief Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(new FOutput());
	}

	/**
	 * \brief Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(new FInput());
	}

	/**
	 * \brief Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(FTypePrefixInputOutput io) {
		FPrimitiveType type = (FPrimitiveType) type().fullCopy();
		return new FFunctionVariable(new Opt(io), type, new Opt(), getFQName().fullCopy());
	}

	/**
	 * \brief Add derivative variables to the list of FVariables, one for each
	 * differentiate variable.
	 */
	public void FClass.addFDerivativeVariables() {
		ArrayList<FDerivativeVariable> l = new ArrayList<FDerivativeVariable>();
		for (FVariable fv : differentiatedRealVariables()) {
			l.add(new FDerivativeVariable((FVisibilityType)fv.getFVisibilityType().fullCopy(),
					(FTypePrefixVariability)fv.getFTypePrefixVariability().fullCopy(),
					new Opt(),
					new List(),
					new Opt(),
					new Opt(),
					fv.getFQName().fullCopy()));
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
				root().flushAllRecursive();
	}

	/**
	 * \brief Generate initial equations from variables with fixed start
	 * attributes.
	 * 
	 * Intitial equations corresponding to explicitly set start attributes of 
	 * differentiated variables are also generated, without taking the fixed
	 * attribute into account.
	 */
	public void FClass.genInitialEquations() {
		// TODO: Isn't there always a value for fv.startAttributeExp() now?
		for (FRealVariable fv : realVariables()) {
			if (fv.fixedAttribute() ||
					(root().options.getBooleanOption("state_start_values_fixed") 
							&&  fv.isDifferentiatedVariable() && fv.startAttributeSet())) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp("0.0")));
			}	
		}
//		System.out.println(prettyPrint(""));
		for (FIntegerVariable fv : integerVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FIntegerLitExp("0")));
			}	
		}
		for (FBooleanVariable fv : booleanVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse()));
			}	
		}		
		//flush();
				root().flushAllRecursive();
	}
	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * \brief A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	/**
	 * \brief Detection of alias variables in equations
	 * 
	 * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
	 * as alias equations and an AliasPair object is returned.
	 */
	public AliasPair FEquation.aliasVariables() {

		AbstractFVariable afv1 = null;
		AbstractFVariable afv2 = null;
		
		FVariable fv1 = null;
		FVariable fv2 = null;
		boolean negated = false;
		
		if (getLeft() instanceof FIdUseExp && // x = y
					getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)getLeft()).myFV();
			afv2 = ((FIdUseExp)getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = false;
			}
		} else if (getLeft() instanceof FNegExp && // -x = y
				((FNegExp)getLeft()).getFExp() instanceof FIdUseExp &&
				getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)((FNegExp)getLeft()).getFExp()).myFV();
			afv2 = ((FIdUseExp)getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if (getLeft() instanceof FIdUseExp && // x = -y
					getRight() instanceof FNegExp &&
				((FNegExp)getRight()).getFExp() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)getLeft()).myFV();
			afv2 = ((FIdUseExp)((FNegExp)getRight()).getFExp()).myFV();	
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if (getLeft() instanceof FNegExp && // -x = -y
				((FNegExp)getLeft()).getFExp() instanceof FIdUseExp &&
				getRight() instanceof FNegExp &&
				((FNegExp)getRight()).getFExp() instanceof FIdUseExp
				) {
			afv1 = ((FIdUseExp)((FNegExp)getLeft()).getFExp()).myFV();
			afv2 = ((FIdUseExp)((FNegExp)getRight()).getFExp()).myFV();	
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = false;
			}
		} else if (getLeft() instanceof FLitExp && getLeft().ceval().realValue() == 0 && // 0 = x + y
				getRight() instanceof FDotAddExp &&
				((FDotAddExp)getRight()).getLeft() instanceof FIdUseExp &&
				((FDotAddExp)getRight()).getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)((FDotAddExp)getRight()).getLeft()).myFV();
			afv2 = ((FIdUseExp)((FDotAddExp)getRight()).getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if ((getLeft() instanceof FDotAddExp &&  //  x + y = 0
				((FDotAddExp)getLeft()).getLeft() instanceof FIdUseExp &&
				((FDotAddExp)getLeft()).getRight() instanceof FIdUseExp) &&
				(getRight() instanceof FLitExp && getRight().ceval().realValue() == 0)) {
			afv1 = ((FIdUseExp)((FDotAddExp)getLeft()).getLeft()).myFV();
			afv2 = ((FIdUseExp)((FDotAddExp)getLeft()).getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		}
		
		if ((fv1!=null) && 
				(fv2!=null)) {
			return new AliasPair(fv1,fv2,negated);
		} else {
			return null;
		}
		
	}
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	eq FEquation.isAliasEquation() = aliasVariables()!=null;
	
	/**
	 * \brief Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		aliasManager = new AliasManager();
		
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations

			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
			if (equation.isAliasEquation()) {
				AliasPair aliasPair = equation.aliasVariables();
				aliasManager.addAliasVariables(aliasPair.fv1,
						aliasPair.fv2, aliasPair.negated);
			}			
		}	
		//flush();
		root().flushAllRecursive();
	}

	/**
	 * \brief Flag indicating if alias variables have been eliminated from the
	 * model.
	 */
	public boolean FClass.aliasVariablesEliminated = false;
	
	/**
	 * \brief Eliminate alias variabels from the flat model.
	 * 
	 * The non-alias variables are kept in the list FClass.FVariableList but the
	 * alias variables are moved to FClass.AliasVariablesList.
	 */
	public void FClass.eliminateAliasVariables() {
		List<FVariable> nonAliasVars = new List<FVariable>();
		List<FVariable> aliasVars = new List<FVariable>();
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		
		//System.out.println("FClass.eliminateAliasVariables(): l1 " + nonAliasVars + " l2 " + aliasVars);
		
		// Go through all variables and insert in correct list
		for (FVariable fv : getFVariables()) {
			if (fv.isAlias()) {
				aliasVars.add(fv);
			} else {
				nonAliasVars.add(fv);
			}
		}
		
		// Remove alias equations.
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations
			if (!equation.isAliasEquation()) {
				eqns.add(equation);
			}			
		}	

		setFVariableList(nonAliasVars);
		setAliasVariableList(aliasVars);
		getFEquationBlock(0).setFAbstractEquationList(eqns);
		
		aliasVariablesEliminated = true;
		enableAliasRewrite();
		
		//root().flushAllRecursive();
		flush();   // TODO: Is this still needed despite enableAliasRewrite()?
	}
	
	public void ASTNode.enableAliasRewrite() {
		for (ASTNode n : this)
			n.enableAliasRewrite();
	}
	
	public void FIdUseExp.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	boolean FIdUseExp.rewriteAlias = false;
	
	/**
	 * \brief FIdUses referring to alias variables need to be changed to 
	 * FIdUses referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FIdUseExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FQName new_name = (FQName) ((FVariable) myFV()).alias().getFQName().fullCopy();
			FExp new_exp = new FIdUseExp(new FIdUse(new_name));
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
	
	/**
	 * \brief FDerExps referring to alias variables need to be changed to 
	 * FDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDerExp {
		when (rewriteAlias && !getFIdUse().myFV().isUnknown() && getFIdUse().myFV().isAlias()) to FExp {
			FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
			FExp new_exp = new FDerExp(new FIdUse(new_name));
			if (getFIdUse().myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
}

aspect Scalarization {

	/**
	 * \brief Flag indicating if a variable is scalarized.
	 */
	boolean FQName.scalarized = false;
	
	syn boolean FVariable.isScalarized() = getFQName().isScalarized();
	syn boolean FQName.isScalarized() = scalarized;
	
	/**
	 * \brief Scalarize all variables and equations in the flat model.
	 */
	public void FClass.scalarize() {
		List<FVariable> vars = new List<FVariable>();
		List<FVariable> alias_vars = new List<FVariable>();
		//System.out.println("FClass.scalarize(): l1 " + vars + " l2 " + alias_vars);
		// Scalarize all non-alias variables
		for (FVariable fv : getFVariables()) {
			fv.scalarize(vars);
		}
		// Scalarize alias variables
		for (FVariable fv : getAliasVariables()) {
			fv.scalarize(alias_vars);
		}
		
		// Scalarize equations
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFEquationBlock(0).getFAbstractEquations()) {
			ae.scalarize(eqns, vars, new HashMap<String,FExp>());
		}
		getFEquationBlock(0).setFAbstractEquationList(eqns);
		List<FAbstractEquation> ieqns = new List<FAbstractEquation>();
		for (FAbstractEquation ae : getFInitialEquations()) {
			ae.scalarize(ieqns, vars, new HashMap<String,FExp>());
		}
		setFInitialEquationList(ieqns);

		// Replace variables
		setFVariableList(vars);
		setAliasVariableList(alias_vars);
		
		// Replace subscript expressions with literals
		eqns.makeSubscriptsLiteral();
		ieqns.makeSubscriptsLiteral();
		
		// Scalarize functions
		List<FFunctionDecl> funcs = new List<FFunctionDecl>();
		for (FFunctionDecl f : getFFunctionDecls()) 
			funcs.add(f.scalarize());
		setFFunctionDeclList(funcs);

		flush();		
	}
	
	/**
	 * \brief Replace all expressions in array subscripts with literals.
	 */
	public void ASTNode.makeSubscriptsLiteral() {
		for (ASTNode child : this)
			child.makeSubscriptsLiteral();
	}
	
	public void FExpSubscript.makeSubscriptsLiteral() {
		setFExp(getFExp().ceval().buildLiteral());
	}
	
	
	/**
	 * \brief Scalarize the FVariable and put all scalarized variables in the
	 * list vars.
	 */
	public void FVariable.scalarize(List<FVariable> vars) {
		// Constants and parameters still have binding expressions, 
		// they should be scalarized but can't contain any FForIndex 
		// (except in reduction-expressions)
		HashMap<String,FExp> constIndexMap = null;
		if (isParameter() || isConstant())
			constIndexMap = new HashMap<String,FExp>();
		if (isArray()) {
			for (Index i : indices()) {
				// Copy original declaration
				FVariable fv_tmp = (FVariable) fullCopy();
				// Set new array subscripts corresponding to index
				fv_tmp.getFQName().setLastFArraySubscripts(i.newFArraySubscripts());
				// Constants and parameters still have binding expressions
				if (constIndexMap != null && hasBindingExp())
					fv_tmp.setBindingExp(getBindingExp().getArray().get(i).scalarize(constIndexMap));
				// Iterate over all attributes and scalarize.
				for (FAttribute a : fv_tmp.getFAttributes()) 
					a.scalarize(i);
				// Mark variable as scalarized (affects name printing etc.)
				fv_tmp.getFQName().scalarized = true;
				// Add altered copy to list
				vars.addChild(fv_tmp);
			}
		} else {
			// Duplicate FVariable even if it is not an array declaration.
			FVariable fv_tmp = (FVariable) fullCopy();
			if (constIndexMap != null && hasBindingExp())
				fv_tmp.setBindingExp(getBindingExp().scalarize(constIndexMap));
			fv_tmp.getFQName().scalarized = true;
			vars.addChild(fv_tmp);
		}
	}
	
	/**
	 * \brief Scalarize the attribute, picking out the specific element from an array 
	 *        expression or removing "each".
	 */
	public void FAttribute.scalarize(Index i) {
		if (getAttributeSet()) {
			if (hasFEach())
				setFEachOpt(new Opt());
			else if (hasValue() && getValue().ndims() > 0) 
				setValue(getValue().getArray().get(i));
			else if (hasValue())
				setValue(getValue().scalarize(new HashMap<String,FExp>()));
		}
	}
	
	/**
	 * \brief Scalarize the function variable, scalarizing any binding expression.
	 *        Binding expressions for array variables are added to statement list 
	 *        as an assignment instead.
	 */
	public void FFunctionVariable.scalarize(
			List<FFunctionVariable> vars, List<FStatement> stmts, HashMap<String,FExp> indexMap) {
		FFunctionVariable var = (FFunctionVariable) fullCopy();
		var.setBindingExpOpt(new Opt());
		if (hasBindingExp() && !isInput())
			scalarizeBindingExp(vars, stmts, indexMap);
		vars.add(var);
	}
	
	/**
	 * \brief Scalarize the binding expression of this variable and add assignment to list of statements.
	 * 
	 * Assumes that the variable has a binding expression.
	 */
	public void FFunctionVariable.scalarizeBindingExp(
			List<FFunctionVariable> vars, List<FStatement> stmts, HashMap<String,FExp> indexMap) {
		createFunctionCallTemporaries(stmts, vars, indexMap, true);
		stmts.add(new FAssignStmt(new FIdUse(getFQName().fullCopy()), getBindingExp().scalarize(indexMap)));
	}
	
	public void FFunctionArray.scalarizeBindingExp(
			List<FFunctionVariable> vars, List<FStatement> stmts, HashMap<String,FExp> indexMap) {
		createFunctionCallTemporaries(stmts, vars, indexMap, true);
		FIdUse id = new FIdUse(new FQName(name()));
		Array arr = getBindingExp().getArray();
		for (Index i : arr.indices()) {
			FExp exp = arr.get(i).scalarize(indexMap);
			FIdUse nid = (FIdUse) id.fullCopy();
			nid.getFQName().specify(i, false);
			stmts.add(new FAssignStmt(nid, exp));
		}
	}
	
	/**
	 * \brief Scalarize the statement and put all resulting statements in the
	 *        list of statements.
	 */
	public void FStatement.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		stmts.add((FStatement) fullCopy());
	}
	
	public void FAssignStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		FIdUse left = getLeft();
		FExp right = getRight();
		if (right.size().isUnknown()) {
			String[] names = new String[right.ndims()];
			for (int i = 0, j = 0; i < names.length; i++, j++) {
				names[i] = "i" + j;
				while (!lookupFV(names[i]).isUnknown())
					names[i] = "i" + (++j);
			}
			throw new UnsupportedOperationException(); // TODO: Implement this
		} else {
			right.createFunctionCallTemporaries(stmts, vars, indexMap, true);
			if (left.ndims() > 0) {
				Array arr = right.getArray();
				for (Index i : arr.indices()) {
					FExp exp = arr.get(i).scalarize(indexMap);
					stmts.add(new FAssignStmt(left.specify(i, false), exp));
				}
			} else {
				FExp exp = getRight().scalarize(indexMap);
				stmts.add(new FAssignStmt(left.scalarize(indexMap), exp));
			}
		}
	}
	
	public void FFunctionCallStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		getCall().createFunctionCallTemporaries(stmts, vars, indexMap, true);
		FFunctionCallStmt stmt = new FFunctionCallStmt();
		for (FFunctionCallLeft left : getLefts())
			stmt.addLeft(left.scalarize(indexMap));
		stmt.setCall((FAbstractFunctionCall) getCall().scalarizeExp(indexMap));
		stmts.add(stmt);
	}
	
	public void FIfWhenStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		for (FIfWhenClause cl : getFIfWhenClauses())
			cl.getTest().createFunctionCallTemporaries(stmts, vars, indexMap, true);
		FIfWhenStmt stmt = createEmptyNode();
		for (FIfWhenClause cl : getFIfWhenClauses())
			stmt.addFIfWhenClause(cl.scalarize(vars, indexMap));
		scalarizeElse(vars, stmt, indexMap);
		stmts.add(stmt);
	}
	
	/**
	 * \brief Scalarize the else part of an if statement. Does nothing for when statements.
	 */
	public void FIfWhenStmt.scalarizeElse(List<FFunctionVariable> vars, FIfWhenStmt stmt, 
			HashMap<String,FExp> indexMap) {}
	
	public void FIfStmt.scalarizeElse(List<FFunctionVariable> vars, FIfWhenStmt stmt, 
			HashMap<String,FExp> indexMap) {
		FIfStmt ifstmt = (FIfStmt) stmt;
		for (FStatement es : getElseStmts())
			es.scalarize(vars, ifstmt.getElseStmtList(), indexMap);
	}
	
	/**
	 * \brief Scalarize the if or when clause.
	 */
	public FIfWhenClause FIfWhenClause.scalarize(List<FFunctionVariable> vars, HashMap<String,FExp> indexMap) {
		FExp test = getTest().reduceToScalarized(new FOrExp(), indexMap);
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : getFStatements())
			stmt.scalarize(vars, stmts, indexMap);
		return createNode(test, stmts);
	}
	
	public void FForStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		getIndex().createFunctionCallTemporaries(stmts, vars, indexMap, true);
		FForStmt stmt = new FForStmt();
		stmt.setIndex(getIndex().scalarize(indexMap));
		for (FStatement fs : getForStmts())
			fs.scalarize(vars, stmt.getForStmtList(), indexMap);
		stmts.add(stmt);
	}
	
	public void FWhileStmt.scalarize(List<FFunctionVariable> vars, List<FStatement> stmts, 
			HashMap<String,FExp> indexMap) {
		getTest().createFunctionCallTemporaries(stmts, vars, indexMap, true);
		FWhileStmt stmt = new FWhileStmt();
		stmt.setTest(getTest().scalarize(indexMap));
		for (FStatement ws : getWhileStmts())
			ws.scalarize(vars, stmt.getWhileStmtList(), indexMap);
		getTest().createFunctionCallTemporaries(stmt.getWhileStmtList(), null, indexMap, false);
		stmts.add(stmt);
	}
	
	/**
	 * \brief Scalarize the function, replacing all array assignments with separate scalar 
	 *        assignments and scalarize all expressions.
	 */
	public FFunctionDecl FFunctionDecl.scalarize() {
		HashMap<String,FExp> emptyIndexMap = new HashMap<String,FExp>();
		List<FFunctionVariable> vars = new List<FFunctionVariable>();
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable var : getFFunctionVariables())
			var.scalarize(vars, stmts, emptyIndexMap);
		
		if (hasFAlgorithmBlock())
			for (FStatement stmt : getFAlgorithmBlock().getFStatements())
				stmt.scalarize(vars, stmts, emptyIndexMap);
		
		// During scalarization, FQNames got their scalarized flag set, we need to clear it
		vars.clearScalarized();
		stmts.clearScalarized();
		
		Opt<FAlgorithmBlock> alg;
		if (stmts.getNumChild() > 0)
			alg = new Opt<FAlgorithmBlock>(new FAlgorithmBlock(stmts));
		else 
			alg = new Opt<FAlgorithmBlock>();
		
		FQName name = (FQName) getFQName().fullCopy();
		return new FFunctionDecl(name, vars, alg);
	}
	
	/**
	 * Clear the scalarized flag for all FQNames.
	 */
	public void ASTNode.clearScalarized() {
		for (ASTNode node : this)
			node.clearScalarized();
	}
	
	public void FQName.clearScalarized() {
		scalarized = false;
	}
	
	
	public void FAbstractEquation.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, HashMap<String,FExp> indexMap) {}
	
	/**
	 * \brief Scalarize equation and put all scalarized equations in list eqns.
	 */
	public void FEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, HashMap<String,FExp> indexMap) {
		//System.out.println("FEquation.scalarize() " + ndims());
		createFunctionCallTemporaries(eqns, vars, indexMap, true);
		if (ndims()==0) {
			/*
			 * If the equation is of dimension 0, i.e, already scalar,
			 * the equations is "scalarized" into a simple equation where
			 * e.g. built in functions are replaced by elementary operations.
			 */
			eqns.addChild(new FEquation(getLeft().scalarize(indexMap),
					getRight().scalarize(indexMap)));
		} else if (ndims() > 0) {
			/*
			 * If the expression is an array expression, then the FExp.getArray()
			 * element is used to generate scalar equations.
			 */
			// Iterate over array elements and create scalarized equation for each
			for (Index i : indices()) 
				eqns.addChild(new FEquation((FExp) getLeft().getArray().get(i).scalarize(indexMap), 
						(FExp) getRight().getArray().get(i).scalarize(indexMap)));
		}
	}
	
	/**
	 * \brief Scalarize equation and put all scalarized equations in list eqns.
	 */
	public void FFunctionCallEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, HashMap<String,FExp> indexMap) {
		List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft id : getLefts())
			lefts.add(id.scalarize(indexMap));
		eqns.addChild(new FFunctionCallEquation(lefts, (FAbstractFunctionCall) getCall().scalarizeExp(indexMap)));
	}
	
	public void FForClauseE.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, HashMap<String,FExp> indexMap) {
		Indices indices = Indices.create(getFForIndexs());
		
		HashMap<String,FExp> myIndexMap = new HashMap<String,FExp>();
		myIndexMap.putAll(indexMap);
		for (Index i : indices) {
			int j = 0;
			int[] ii = indices.translate(i).index();
			for (FForIndex fi : getFForIndexs()) {
				myIndexMap.put(fi.getFVariable().name(), new FIntegerLitExp(ii[j]));
				j++;
			}
			
			for (FAbstractEquation ae : getFAbstractEquations()) {
				ae.scalarize(eqns, vars, myIndexMap);
			}
		}
	}
	
	public FFunctionCallLeft FFunctionCallLeft.scalarize(HashMap<String,FExp> indexMap) {
		return new FFunctionCallLeft(hasFExp() ? new Opt(getFExp().scalarize(indexMap)) : new Opt());
	}
	
	/**
	 * \brief Add temporary variables and an equation/statement giving them values for each function 
	 *        call returning an array.
	 * 
	 * Creates statement if in function, equation otherwise.
	 * 
	 * @param clauses   the list to add the new equation or statement to
	 * @param vars      the list to add the new variables to
	 * @param indexMap  map of for indices to replace with literals
	 * @param addVar    if <code>true</code> create and add temporary variable(s)
	 */
	public void ASTNode.createFunctionCallTemporaries(List clauses, 
			List vars, HashMap<String,FExp> indexMap, boolean addVar) {
		for (ASTNode node : this)
			node.createFunctionCallTemporaries(clauses, vars, indexMap, addVar);
	}
	
	public void FFunctionCall.createFunctionCallTemporaries(List clauses, 
			List vars, HashMap<String,FExp> indexMap, boolean addVar) {
		super.createFunctionCallTemporaries(clauses, vars, indexMap, addVar);
		if (isArray() && !isFunctionCallClause()) {
			boolean equation = !inFunction();
			if (addVar) {
				if (equation) {
					for (FExp e : getArray().iterable())
						vars.add(createTemporaryVariable((FIdUseExp) e));
				} else {
					FPrimitiveType type = (FPrimitiveType) type().fullCopy();
					vars.add(new FFunctionArray(type, tempVarName()));
				}
			}
			FExp temp = equation ? 
					getArray().buildScalarized(indexMap) : 
					new FIdUseExp(tempVarName());
			List lefts = new List().add(new FFunctionCallLeft(new Opt(temp)));
			if (equation)
				clauses.add(new FFunctionCallEquation(lefts, scalarizeFunction(indexMap)));
			else
				clauses.add(new FFunctionCallStmt(lefts, scalarizeFunction(indexMap)));
		}
	}
	
	/**
	 * \brief Creates a new temporary varable with the same name as the given FIdUseExp.
	 */
	protected AbstractFVariable FFunctionCall.createTemporaryVariable(FIdUseExp idExp) {
		FVisibilityType fvt = new FTemporaryVisibilityType();
		FQName n = (FQName) idExp.getFIdUse().getFQName().fullCopy();
		n.scalarized = true;
		if (type().isReal()) {
			return new FRealVariable(
					fvt, new FContinuous(), new Opt(), new List(), new Opt(), new Opt(), n);
		} else if (type().isInteger()) {
			return new FIntegerVariable(
					fvt, new FDiscrete(),   new Opt(), new List(), new Opt(), new Opt(), n);
		} else if (type().isBoolean()) {
			return new FBooleanVariable(
					fvt, new FDiscrete(),   new Opt(), new List(), new Opt(), new Opt(), n);
		} else if (type().isString()) {
			return new FStringVariable(
					fvt, new FDiscrete(),   new Opt(), new List(), new Opt(), new Opt(), n);
		}
		return null;
	}
	
	/* Scalarization of expressions is needed in order to compute a simple
	 * scalar expression from an expression with ndims==0. For example, an
	 * FIdUse 'x[2]' needs to be marked as scalarized, and the expression
	 * scalar(x*A*x) needs to be replaced by a double sum.
	 */
	
	/**
	 * \brief Create an FArray containing scalarized subexpressions.
	 */
	public FExp Array.buildScalarized(HashMap<String,FExp> indexMap) {
    	return buildFArray(iteratorFExp(), new ScalarizedBuilder(indexMap), 1);
    }
    
	public static class Array {
	    /**
	     * Helper object for {@link #buildScalarized(java.util.HashMap<String,FExp>)}.
	     */
	    protected class ScalarizedBuilder implements ElementBuilder {
	    	private HashMap<String,FExp> indexMap;
	    	
	    	public ScalarizedBuilder(HashMap<String,FExp> indexMap) {
	    		this.indexMap = indexMap;
	    	}
	    	
			public FExp build(FExp e) {
				return e.scalarize(indexMap);
			}
	    }
	}

	/**
	 * \brief Scalarize expressions, replacing array expressions with FArrays of scalarized subexpressions.
	 * 
	 * The FArrays are needed because function calls need arrays to be passed as arrays.
	 */
	public FExp FExp.scalarize(HashMap<String,FExp> indexMap) {
		if (isArray() && !keepAsArray()) 
			return getArray().buildScalarized(indexMap);
		else
			return scalarizeExp(indexMap);
	}
	
	syn boolean FExp.keepAsArray() = canKeepAsArray() && canAcceptArray();

	syn boolean FExp.canKeepAsArray() = false;
	eq FIdUseExp.canKeepAsArray()     = true;
	eq FFunctionCall.canKeepAsArray() = true;
	
	inh boolean FExp.canAcceptArray();
	inh boolean List.canAcceptArray();
	inh boolean Opt.canAcceptArray();
	eq ASTNode.getChild().canAcceptArray()          = false;
	eq List.getChild().canAcceptArray()             = canAcceptArray();
	eq Opt.getChild().canAcceptArray()              = canAcceptArray();
	eq FFunctionCallLeft.getFExp().canAcceptArray() = inFunction();
	eq FFunctionCall.getArg().canAcceptArray()      = inFunction();
	
	/**
	 * \brief Scalarize expressions.
	 */
	public FExp FExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return null;
	}

	public FSubscript FSubscript.scalarize(HashMap<String,FExp> indexMap) {
		return (FSubscript) fullCopy();
	}
	
	public FSubscript FExpSubscript.scalarize(HashMap<String,FExp> indexMap) {
		return new FExpSubscript(getFExp().scalarize(indexMap));
	}
	
	public FArraySubscripts FArraySubscripts.scalarize(HashMap<String,FExp> indexMap) {
		FArraySubscripts fas = new FArraySubscripts();
		for (FSubscript fs : getFSubscripts()) {
			fas.addFSubscript(fs.scalarize(indexMap));
		}
		return fas;
	}
	
	public FQNamePart FQNamePart.scalarize(HashMap<String,FExp> indexMap) {
		return new FQNamePart(getName(),hasFArraySubscripts()? 
				new Opt(getFArraySubscripts().scalarize(indexMap)): new Opt());
	}
	
	public FQName FQName.scalarize(HashMap<String,FExp> indexMap) {
		FQName fqn = new FQName();
		for (FQNamePart fqnp : getFQNameParts()) 
			fqn.addFQNamePart(fqnp.scalarize(indexMap));
		fqn.scalarized = true;
		return fqn;
	}
	
    public FIdUse FIdUse.scalarize(HashMap<String,FExp> indexMap) {
    	return new FIdUse(getFQName().scalarize(indexMap));
    }

    public FExp FIdUseExp.scalarizeExp(HashMap<String,FExp> indexMap) {
    	if (indexMap.containsKey(name())) 
    		return (FExp) indexMap.get(name()).fullCopy();
    	return new FIdUseExp(getFIdUse().scalarize(indexMap));
    }
    
    /* These are needed because scalarize() is reused in Array.createExpanded(), that 
     * might be called on an instance tree.
     */
    public FExp FInstAccessExp.scalarizeExp(HashMap<String,FExp> indexMap) {
    	if (indexMap.containsKey(name())) 
    		return (FExp) indexMap.get(name()).fullCopy();
    	return new FInstAccessExp(getInstAccess().scalarize(indexMap));
    }
	
    public FIdUseInstAccess FIdUseInstAccess.scalarize(HashMap<String,FExp> indexMap) {
    	return new FIdUseInstAccess(new FQName(), getInstAccess().scalarize(indexMap));
    }
	
    public InstAccess InstAccess.scalarize(HashMap<String,FExp> indexMap) {
    	return (InstAccess) fullCopy();
    }
	
    public InstDot InstDot.scalarize(HashMap<String,FExp> indexMap) {
    	return new InstDot("", getLeft().scalarize(indexMap), getRight().scalarize(indexMap));
    }
	
    public InstArrayAccess InstArrayAccess.scalarize(HashMap<String,FExp> indexMap) {
    	InstArrayAccess res = (InstArrayAccess) fullCopy();
    	if (hasFArraySubscripts())
    		res.setFArraySubscripts(getFArraySubscripts().scalarize(indexMap));
    	return res;
    }
    // End of instance classes that need scalarize()
 
    public FExp FIfExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		List etl = new List();
		for (FElseIfExp elif : getFElseIfExps()) 
			etl.add(elif.scalarize(indexMap));
		return new FIfExp(getIfExp().scalarize(indexMap),
		                  getThenExp().scalarize(indexMap),
		                  etl,
		                  getElseExp().scalarize(indexMap));
	}
	
	public FExp FElseIfExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return new FElseIfExp(getIfExp().scalarize(indexMap),
		                      getThenExp().scalarize(indexMap));
	}
	
	public FExp FMulExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		if (getLeft().isArray() && !isArray()) 
			return composeScalarCellExp(Index.NULL).scalarize(indexMap);
		else
			return super.scalarizeExp(indexMap);
	}
	
	public FExp FSizeExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		// Only the form with dim can be in the tree at this point
		int dim = dimension();
		return getFExp().size().createFExp(dim);
	}
	
	public FExp FMinMaxExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		if (hasY())
			return createNode(getX().scalarize(indexMap), getY().scalarize(indexMap));
		else
			return getX().reduceToScalarized(this, indexMap);
	}
	
	public FExp FSumExp.scalarizeExp(HashMap<String,FExp> indexMap) {
		return getFExp().reduceToScalarized(new FAddExp(), indexMap);
	}
	
	/**
	 * \brief Scalarize an expression by recursively scalarizing and combining the contents in its Array.
	 * 
	 * New nodes are created with <code>template.createNodeBinary()</code>.
	 */
	public FExp FExp.reduceToScalarized(FExp template, HashMap<String,FExp> indexMap) {
		if (isArray()) {
			Iterator<FExp> it = getArray().iteratorFExp();
			FExp res = it.next().scalarize(indexMap);
			while (it.hasNext())
				res = template.createNodeBinary(res, it.next().scalarize(indexMap));
			return res;
		} else {
			return scalarize(indexMap);
		}
	}
	
	public FExp FBinExp.scalarizeExp(HashMap<String,FExp> indexMap) { return createNode(getLeft().scalarize(indexMap), getRight().scalarize(indexMap)); }
	public FExp FUnaryExp.scalarizeExp(HashMap<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FMathematicalFunctionCall.scalarizeExp(HashMap<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FAtan2Exp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FAtan2Exp(getFExp().scalarize(indexMap), getY().scalarize(indexMap)); }

	public FExp FAbsExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FAbsExp(getFExp().scalarize(indexMap)); }
	
	public FExp FLitExp.scalarizeExp(HashMap<String,FExp> indexMap) { return (FLitExp) fullCopy(); }
	public FExp FDerExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FDerExp(getFIdUse().scalarize(indexMap)); }

	public FExp FNoEventExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FNoEventExp(getFExp().scalarize(indexMap)); }
	
	public FExp FFunctionCall.scalarizeExp(HashMap<String,FExp> indexMap) {
		if (isArray() && functionCallIsExp())
			return new FIdUseExp(tempVarName());
		else
			return scalarizeFunction(indexMap);
	}
	
	public FFunctionCall FFunctionCall.scalarizeFunction(HashMap<String,FExp> indexMap) {
		List<FExp> args = new List<FExp>();
		for (FExp arg : getArgs())
			args.add(arg.scalarize(indexMap));
		return new FFunctionCall((FIdUse) getName().fullCopy(), args, getSizes()); 
	}
	
	public FExp FTimeExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FTimeExp(); }
	public FExp FEndExp.scalarizeExp(HashMap<String,FExp> indexMap) { return new FEndExp(); }

	public FForIndex FForIndex.scalarize(HashMap<String,FExp> indexMap) {
		return new FForIndex(hasFExp() ? new Opt(getFExp().scalarizeIndexExp(indexMap)) : new Opt(), 
				(FVariable) getFVariable().fullCopy());
	}
	
	/**
	 * \brief Scalarize the expression of an FForIndex. 
	 */
	public FExp FExp.scalarizeIndexExp(HashMap<String,FExp> indexMap) {
		return scalarize(indexMap);
	}
	
	public FRangeExp FRangeExp.scalarizeIndexExp(HashMap<String,FExp> indexMap) {
		List<FExp> exps = new List<FExp>();
		for (FExp e : getFExps())
			exps.add(e.scalarize(indexMap));
		return new FRangeExp(exps);
	}

}

aspect ParameterSorting {

	/**
	 * \brief Indicate if there exist cyclic parameter dependencies.
	 */
	public boolean FClass.cyclicParameters = false;
	
	/**
	 * \brief Sort dependent parameters.
	 * 
	 * This is a simple implementation of Kahn's topological sorting algorithm.
	 * This implementation will most likely be replaced by other graph 
	 * algorithms later on.
	 */
	public void FClass.sortDependentParameters() {
		
		// Retrieve the dependent parameter that will be sorted
		ArrayList<FVariable> dps = dependentParameters();
		
		// Create data structures for the adjacency graph.
		ArrayList<ArrayList<FVariable>> toNodes = new ArrayList<ArrayList<FVariable>>();	
		ArrayList<ArrayList<FVariable>> fromNodes = new ArrayList<ArrayList<FVariable>>();	
		
		// Initialize data structures.
		for(int i=0;i<numDependentParameters();i++) {
			toNodes.add(new ArrayList<FVariable>());
			fromNodes.add(new ArrayList<FVariable>());
		}
		
		// For each flat variable
		for (FVariable fv : dps) {
			// Retreive all variables referenced in binding expression
			ArrayList<FVariable> deps = fv.referencedFVariablesInBindingExp();
			// Build the actual adjacency graph.
			for (FVariable fv_add : deps) {
				if (!(dps.indexOf(fv_add)<0) && !toNodes.get(dps.indexOf(fv_add)).contains(fv)) {
					toNodes.get(dps.indexOf(fv_add)).add(fv);		
					fromNodes.get(dps.indexOf(fv)).add(fv_add);
				}
			}
		}	
				
		// Sort using algorithm described at
		// http://en.wikipedia.org/wiki/Topological_sorting
		ArrayList<FVariable> L = new ArrayList<FVariable>();
		ArrayList<FVariable> S = new ArrayList<FVariable>();
		
		// Add all nodes without incoming edges to S
		int i = 0;
		for (ArrayList<FVariable> l : fromNodes) {
			if (l.isEmpty()) {
				S.add(dps.get(i));
			}
			i++;
		}
		// Repeat while S is not empty
		while (!S.isEmpty()) {
			// Remove a node n from S
			FVariable n = S.remove(0);
			// Insert n into L
			L.add(n);
			// For each node m with an edge e from n to m
			for (FVariable m : toNodes.get(dps.indexOf(n))) {
				// Remove edge e from fromNodes
				fromNodes.get(dps.indexOf(m)).remove(n);
				// If m has no incoming edges add m to S
				if (fromNodes.get(dps.indexOf(m)).isEmpty()) {
					S.add(m);
				}
			}
			// Remove e from toNodes
			toNodes.get(dps.indexOf(n)).clear();
		}
		
		// Not possible to find an ordering without cycles?
		if (L.size()!=dps.size()) {
			cyclicParameters = true;
			return;
		}
		
		// Remove all dependent parameters from (in reversed order)
		for (i=getNumFVariable()-1;i>=0;i--) {
			if (dps.contains(getFVariable(i))) {
				getFVariableList().removeChild(i);
			}
		}

		// Add all dependent parameters in sorted order.
		for (FVariable fv : L) {
			addFVariable(fv);
		}

		// Flush AST since the structure has changed.
		//flush();
		root().flushAllRecursive();
	}	
		
}

aspect TransformCanonicalErrorCheck {
	
	public void FClass.checkFClassDimensions() {
		// Check dimensions of DAE
		int n_eq_F = numScalarEquations();
		int n_vars_F = numAlgebraicRealVariables() + 
		               numDifferentiatedRealVariables() + 
		               numDiscreteVariables();
		if (n_eq_F!=n_vars_F) {
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		}
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numInitialEquations() + numScalarEquations();
		int n_vars_F0 = numAlgebraicRealVariables() + 
		                2*numDifferentiatedRealVariables() + 
		                numDiscreteVariables();
		if (n_eq_F0>n_vars_F0) {
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		}
		
	}
	
	public void FClass.collectErrors() {
		if (cyclicParameters) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		}
		if (getAliasManager().aliasError()) {
			error(getAliasManager().getAliasErrorMessage());
		}
		for (String str : aliasErrors) {
			error(str);
		}
		checkFClassDimensions();
	}
	
}


aspect FlushFClass {
	/**
	 * \brief Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FIdUseExps and FDerExps in order to enable rewrites of such nodes
	 * after elimination of alias variables.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
	public void FIdUseExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
	public void FDerExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursive();
		}
	}
	
	/**
	 * \brief Flush model AST and enable rewrites of FIdUseExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
}
