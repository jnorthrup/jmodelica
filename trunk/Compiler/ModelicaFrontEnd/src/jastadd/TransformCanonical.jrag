/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//import java.util.ArrayDeque;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.Queue;
import java.util.Set;
import java.util.Stack;
import java.util.HashSet;
import java.util.Collections;

import org.jmodelica.util.BiPGraph;
import org.jmodelica.util.Eq;
import org.jmodelica.util.Var;


/* This causes conflicts
import org.jmodelica.graphs.EquationSystem;
import org.jmodelica.graphs.Equation;
import org.jmodelica.graphs.Variable;
*/

/**
 * \brief Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

	/**
	 * \brief Transform the raw flattened model into a structured form.
	 * 
	 * Currently, the following operations are performed:
	 *  <ul>
	 *    <li> Binding equations for variables are converted into regular
	 *         equations by calling genBindingEquations().
	 *    <li> For each non-function algorithm:
	 *         <ul>
	 *           <li> A function is generated with the algorithm as body, 
	 *                any assigned variables as outputs and any used 
	 *                variables as inputs.
	 *           <li> The original algorithm is replaced with a call to 
	 *                the generated function.
	 *         </ul>
	 *    <li> The model is scalarized, i.e., all array declarations and
	 *         equations are replaced by scalar declarations and equations
	 *    <li> Alias variables are eliminated from the model.
	 *    <li> Derivative variables are generated and inserted in the
	 *         list of FVariables by calling addFDerivativeVariables().
	 *    <li> Generate initial equations based on start attribute.
	 *    <li> Sort dependent parameters.
	 *  </ul>
	 */
	 
	 /**
	  *  transformCanonicalBase contains all transformation that should be
	  *  done by both the Modelica and the Optimica compilers.
	  */
	public void FClass.transformCanonicalBase() {
		genBindingEquations();
		genAlgorithmFunctions();
		scalarize();
		
		// This must be done after scalarization
		enableStreamsRewrite();
		root().flushAllRecursive();
		
		if (root().options.getBooleanOption("eliminate_alias_variables")) {
			genAlias();
			eliminateAliasVariables();
		}
		enableWhenEquationRewrite();
		root().flushAllRecursive();
//		log.debug(prettyPrint(""));
		addFDerivativeVariables();
		genInitialEquations();
		sortDependentParameters();

		if (root().options.getBooleanOption("index_reduction")) {
			indexReduction();
			blt();
		}
	
	}

	public void FClass.transformCanonical() {

		transformCanonicalBase();

		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			// Equations are added as part of this this method
			computeMatchingsAndBLT();
		}
	    
	    root().flushAllRecursive();
		
	}
		
	private org.jmodelica.graphs.EquationSystem FClass.eqSys = null;
	
	public void FClass.indexReduction() {
		
		eqSys = new org.jmodelica.graphs.EquationSystem(name());
		org.jmodelica.graphs.Equation eqn;
		org.jmodelica.graphs.Variable v = null;
		
		int k = 1;
		for (FAbstractEquation e : equations()) {
			eqn = eqSys.addEquation("eq_"+k);
			k++;
			
			for (FVariable y : e.algebraicVariables()) { 
				log.debug("  Algebraic: " + y.name()); 
					 	 
				v = eqSys.addVariable(y.name());     
				eqn.addVariable(v); 
			} 
					 
			for (FVariable x : e.differentiatedVariables()) { 
				log.debug("  State: " + x.name()); 
					 	 
				v = eqSys.addVariable(x.name());     
				eqn.addVariable(v); 
			} 
				 	 
			for (FDerivativeVariable dx : e.derivativeVariables()) { 
				FVariable x = dx.myDifferentiatedVariable(); 
				log.debug("  Diffed state: " + x.name()); 
 
				v = eqSys.addVariable(x.name(), 1);     
				eqn.addVariable(v); 
			} 
			
		}
		
		try {
			int index = eqSys.pantelides();
		} catch (org.jmodelica.graphs.EquationSystem.PantelidesMaxDepthException e) {
            System.out.println("Pantelides reached max depth");
        } catch (org.jmodelica.graphs.EquationSystem.PantelidesEmptyEquationException e) {
            System.out.println("Pantelides encountered empty equation");
        }
        
        eqSys.dumpGraph();
			
	}

       public void FClass.blt() { 
 		                 
 		                LinkedList<Stack<org.jmodelica.graphs.Equation>> blt_result = eqSys.blt(); 
 		 
 	                StringBuffer str = new StringBuffer(); 
 		                str.append("BLT:\n"); 
 		                LinkedList<Stack<org.jmodelica.graphs.Equation>> blt = eqSys.blt(); 
 	                int i = 0; 
 		                for (Stack<org.jmodelica.graphs.Equation> s : blt_result) { 
 	                        str.append("Block "+i+":\n"); 
 		                        for (org.jmodelica.graphs.Equation e : s) { 
 		                                str.append(e + " (" + e.getMatch()+")\n"); 
 		                        } 
 		                        i++; 
 		                } 
 		                System.out.println(str.toString()); 
 		        } 


	public class BLT extends ArrayList<EquationBlock> {
	
	}

	public class EquationBlock {
		private ArrayList<MatchingPair> mps = new ArrayList<MatchingPair>();
		
		public EquationBlock() {
		}
		
		public void addMatchingPair(MatchingPair m) {
			mps.add(m);
		}	
		
		public ArrayList<FAbstractEquation> equations() {
			ArrayList<FAbstractEquation> s = new ArrayList<FAbstractEquation>();
			for (MatchingPair mp : mps) {
				s.add(mp.getEquation());
			}
			return s;
		}

		public ArrayList<FVariable> activeVariables() {
			ArrayList<FVariable> s = new ArrayList<FVariable>();
			for (MatchingPair mp : mps) {
				s.add(mp.getFVariable());
			}
			return s;
		}		
		
		public boolean isSolved() {
			return equations().size()==1 && equations().get(0).isSolved(activeVariables().get(0).name());
		}
		
		public FExp solution() {
			if (isSolved()) {
				return equations().get(0).solution(activeVariables().get(0).name());
			} else {
			    return null;
			}
		}
		
	}

    public class MatchingPair {
    	private FAbstractEquation eqn;
    	private FVariable fv;
    	
    	public MatchingPair(FAbstractEquation eqn, FVariable fv) {
    		this.eqn = eqn;
    		this.fv = fv;
    	}
    
    	public FAbstractEquation getEquation() {
			return eqn;    	
    	}
    	
    	public FVariable getFVariable() {
    		return fv;
    	}
    }

	private ArrayList<MatchingPair> FClass.daeMatching = null;
	syn ArrayList<MatchingPair> FClass.getDAEMatching() {
		if (daeMatching == null) 
			computeMatchingsAndBLT();
		return daeMatching;
	}
	
	private ArrayList<MatchingPair> FClass.daeInitMatching = null;
	syn ArrayList<MatchingPair> FClass.getDAEInitMatching() { 
		if (daeInitMatching == null) 
			computeMatchingsAndBLT();
		return daeInitMatching;
	}	

	private ArrayList<FAbstractEquation> FClass.daeUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEUnmatchedEquations() { 
		if (daeUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedVariables;
	}	

	private ArrayList<FAbstractEquation> FClass.daeInitUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEInitUnmatchedEquations() { 
		if (daeInitUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeInitUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEInitUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedVariables;
	}	

	private BLT FClass.daeBLT = null;
	syn BLT FClass.getDAEBLT() {
		if (daeBLT == null) 
			computeMatchingsAndBLT();
		return daeBLT;
	}
	
	private BLT FClass.daeInitBLT = null;	
	syn BLT FClass.getDAEInitBLT() {
		if (daeInitBLT == null) 
			computeMatchingsAndBLT();
		return daeInitBLT;
	}	
		
	public void FClass.computeMatchingsAndBLT() {
		
		daeMatching = new ArrayList<MatchingPair>();
		daeInitMatching = new ArrayList<MatchingPair>();		
	    daeBLT = new BLT();
	   	daeInitBLT = new BLT();		
		daeUnmatchedEquations = new ArrayList<FAbstractEquation>();		
		daeUnmatchedVariables = new ArrayList<FVariable>();			
		daeInitUnmatchedEquations = new ArrayList<FAbstractEquation>();		
		daeInitUnmatchedVariables = new ArrayList<FVariable>();			
			
		BiPGraph g = new BiPGraph(name(),"");
		
		Eq eqn = null;
		Var v = null;
		
		// Add all derivatives
		for (FVariable fv : derivativeVariables()) {
			g.addVariable(fv.name(),"");     
		}
		
		// Add all algebraics
		for (FVariable fv : algebraicRealVariables()) {
			g.addVariable(fv.name(),"");     
		}
		for (FVariable fv : integerVariables()) {
			g.addVariable(fv.name(),"");     
		}
		for (FVariable fv : booleanVariables()) {
			g.addVariable(fv.name(),"");     
		}
		for (FVariable fv : stringVariables()) {
			g.addVariable(fv.name(),"");     
		}
		for (FVariable fv : discreteRealVariables()) {
			g.addVariable(fv.name(),"");     
		}
		for (FVariable fv : enumVariables()) {
			g.addVariable(fv.name(),"");     
		}
		
		int k = 1;
		int j = 0;
		for (FAbstractEquation e : equations()) {
			//k = e.extractDerAlgIncidence(g,k);
			int n_eq = e.numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				eqn = g.addEquation("eq_"+k,e.prettyPrint(""),j);
				k++;
//				System.out.println(" ** " + e.prettyPrint(""));
				for (FVariable y : e.algebraicVariables()) { 
//					System.out.println(" -- Algebraic: " + y.name()); 
						 	 
					v = g.getVariable(y.name());     
					g.addEdge(eqn,v); 
				} 

				for (FDerivativeVariable dx : e.derivativeVariables()) { 
//					System.out.println(" -- Diffed state: " + dx.name()); 

					v = g.getVariable(dx.name());     
					g.addEdge(eqn,v); 
				} 
			}
			j++;
		}
		
		log.info(g.toString());
		g.maximumMatching(true);	
		log.info("DAE system ");
		log.info(g.printMatching());
		
		k = 1;
		for (FAbstractEquation e : equations()) {				
			//k = e.extractDerAlgIncidence(g,k);
			int n_eq = e.numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				eqn = g.getEquation("eq_"+k);
				v = eqn.getMatching();
				if (v!=null) {
					daeMatching.add(new MatchingPair(e,(FVariable)lookupFV(new FQName(v.getName()),false)));
				}
				k++;
			}
		}
	
		for (Var var : g.getUnmatchedVariables()) {
			daeUnmatchedVariables.add((FVariable)lookupFV(new FQName(var.getName()),false));
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeUnmatchedEquations.add(equations().get(ee.getId()));
		}
	
		// TODO: If no complete matching found, then try index reduction
		if (g.getUnmatchedVariables().size()>0 || g.getUnmatchedEquations().size()>0) {
			return;
		}
	
		// Perform BLT
		if (root().options.getBooleanOption("equation_sorting") && g.getUnmatchedVariables().size()==0 && g.getUnmatchedEquations().size()==0) {	
		
			LinkedList<Stack<Eq>> blt = g.computeBLT();
		
			log.info("BLT: " + blt.size() + " blocks");
			for (Stack<Eq> bl : blt) {
				log.info("Block: " + bl.size() + "-----");
				EquationBlock b = new EquationBlock();
				daeBLT.add(b);
				for (Eq bl_eqn : bl) {
					v = bl_eqn.getMatching();
					b.addMatchingPair(new MatchingPair(equations().get(bl_eqn.getId()),(FVariable)lookupFV(new FQName(v.getName()),false)));
					log.info(bl_eqn.getMatching() + ": " + bl_eqn.getDescription());
				}
				log.info("-----------------");
			}
		}
			
		// Find matching for the initialization system	
			
		// Add all differentiated variables
		for (FVariable fv : differentiatedRealVariables()) {
			g.addVariable(fv.name(),"");     
		}
		
		k = 1;
		j = 0;
		for (FAbstractEquation e : equations()) {
			int n_eq = e.numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				eqn = g.addEquation("eq_"+k,e.prettyPrint(""),j);
				k++;

				for (FVariable x : e.differentiatedVariables()) { 
					log.debug("  State: " + x.name()); 
					 	 
					v = g.getVariable(x.name());     
					g.addEdge(eqn,v); 
				} 			
			}
			j++;
			//k = e.extractStateIncidence(g,k);
		}
		
		j = equations().size();
		for (FAbstractEquation e : initialEquations()) {

			//k = e.extractIncidence(g,k);
			
			int n_eq = e.numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				eqn = g.addEquation("eq_"+k,e.prettyPrint(""),j);
				k++;
			
				for (FVariable y : e.algebraicVariables()) { 
					log.debug("  Algebraic: " + y.name()); 
					 	 
					v = g.getVariable(y.name());     
					g.addEdge(eqn,v); 
				} 
					
				for (FVariable x : e.differentiatedVariables()) { 
					log.debug("  State: " + x.name()); 
					 	 
					v = g.addVariable(x.name(),"");     
					g.addEdge(eqn,v); 
				} 
				 	
				for (FDerivativeVariable dx : e.derivativeVariables()) { 
					log.debug("  Diffed state: " + dx.name()); 
 
					v = g.addVariable(dx.name(),"");     
					g.addEdge(eqn,v); 
				} 
			}
			j++;
		}

		log.info(g.toString());
		g.maximumMatching(false);	
		log.info("DAE initial ");
		log.info(g.printMatching());

		if (g.getUnmatchedEquations().size()>0) {
		   	return;
		}

		// Add initial equations if needed
		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			List<FAbstractEquation> l = new List<FAbstractEquation>();
			for (FAbstractEquation e : initialEquations()) {
				l.add(e);
			}

			for (Var var : g.getUnmatchedVariables()) {	
			    FVariable fv = (FVariable)lookupFV(new FQName(var.getName()),false);
				FEquation fe = new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp("0.0"));
				l.add(fe);

				eqn = g.addEquation("eq_"+k,fe.prettyPrint(""),j);
				v = g.getVariable(var.getName());     
				g.addEdge(eqn,v); 
				k++;
				j++;
			}
	
			setFInitialEquationList(l);	
	        root().flushAllRecursive();

			g.maximumMatching(false);	
			log.info("DAE initial after addition of initial equations");
			log.info(g.printMatching());

		}

		for (Var var : g.getUnmatchedVariables()) {
			daeInitUnmatchedVariables.add((FVariable)lookupFV(new FQName(var.getName()),false));
		}

		for (Eq ee : g.getUnmatchedEquations()) {
				FAbstractEquation eee = ee.getId()<equations().size()?
				    equations().get(ee.getId()): initialEquations().get(ee.getId()-equations().size());
			daeInitUnmatchedEquations.add(eee);
		}

 		k = 1;
		for (FAbstractEquation e : equations()) {				
			//k = e.extractDerAlgIncidence(g,k);
			int n_eq = e.numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				eqn = g.getEquation("eq_"+k);
				v = eqn.getMatching();
				if (v!=null) {
					daeInitMatching.add(new MatchingPair(e,(FVariable)lookupFV(new FQName(v.getName()),false)));
				}
				k++;
			}
		}

		for (FAbstractEquation e : initialEquations()) {				
			//k = e.extractDerAlgIncidence(g,k);
			int n_eq = e.numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				eqn = g.getEquation("eq_"+k);
				v = eqn.getMatching();
				if (v!=null) {
					daeInitMatching.add(new MatchingPair(e,(FVariable)lookupFV(new FQName(v.getName()),false)));
				}
				k++;
			}
		}
		
		// TODO: If no complete matching found, then try index reduction
		if (g.getUnmatchedVariables().size()>0 || g.getUnmatchedEquations().size()>0) {
			return;
		}
				
		if (root().options.getBooleanOption("equation_sorting") && g.getUnmatchedVariables().size()==0 && g.getUnmatchedEquations().size()==0) {
		
			g.tarjanReset();
			LinkedList<Stack<Eq>> blt = g.computeBLT();
		
			log.info("BLT: " + blt.size() + " blocks");
			for (Stack<Eq> bl : blt) {
				log.info("Block: " + bl.size() + "-----");
				EquationBlock b = new EquationBlock();
				daeInitBLT.add(b);
				for (Eq bl_eqn : bl) {
					v = bl_eqn.getMatching();
					//log.info(">> " + bl_eqn.getId());
					FAbstractEquation eee = bl_eqn.getId()<equations().size()?
					    equations().get(bl_eqn.getId()): initialEquations().get(bl_eqn.getId()-equations().size());
					b.addMatchingPair(new MatchingPair(eee,(FVariable)lookupFV(new FQName(v.getName()),false)));
					log.info(bl_eqn.getMatching() + ": " + bl_eqn.getDescription());
				}
				log.info("-----------------");
			}
		}
	}	
	
	syn lazy ArrayList<String> FClass.structuralErrors() {
		ArrayList<String> structuralErrors = new ArrayList<String>();
		if (root().options.getBooleanOption("enable_structural_diagnosis")) {
		boolean unbalanced = false;
		StringBuffer err_str = new StringBuffer();
		if (getDAEUnmatchedVariables().size() > 0 ) {
			err_str.append("The system is structurally singuar (or of high index). The following varible(s) could not be matched to any equation:\n");
			for (FVariable fv : getDAEUnmatchedVariables()) {
				err_str.append("   " + fv.name());
				err_str.append("\n");
			}
			unbalanced = true;
		}
		if (getDAEUnmatchedEquations().size() > 0 ) {
			if (!unbalanced) {
				err_str.append("The system is structurally singuar (or of high index). The following equation(s) could not be matched to any variable:\n");
			} else {
				err_str.append("\n  The follwowing equation(s) could not be matched to any variable:\n");
			}
			for (FAbstractEquation ee : getDAEUnmatchedEquations()) {
				err_str.append("   " + ee.prettyPrint(""));
				err_str.append("\n");
			}
			unbalanced = true;
		}
		
		if (unbalanced) {
			structuralErrors.add(err_str.toString());
		}
		}
		return structuralErrors;
	}

	
	/**
	 * \brief Convert variable binding equations into regular equations.
	 */
	public void FClass.genBindingEquations() {
		FQName empty = new FQName();
		for (FVariable fv : getFVariables()) 
			if (!fv.isConstant()) 
				fv.genBindingEquations(this, empty);
//		flush();
		flushAllRecursive();
	}
	
	public FExp FVariable.selectBindingFExp(FAttribute attr) {
		if (attr != null && attr.hasValue())
			return attr.getValue();
		else if (hasBindingExp())
			return getBindingExp();
		else
			return null;
	}
	
	public FQName FVariable.createNameForBindingEquation(FQName prefix, FAttribute attr) {
		FQName name = prefix.copyAndAppend(getFQName());
		FArraySubscripts fas = null;
		if (isArray()) {
			if (attr != null)
				attr = attr.findAttribute(FAttribute.SIZE);
			Size size = (attr != null && attr.hasValue()) ? new MutableSize(attr.getValue()) : size();
			fas = size.rangeFArraySubscripts();
		}
		name.setLastFArraySubscripts(fas);
		return name;
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix) {
		genBindingEquations(fc, prefix, null, false);
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, boolean param) {
		FExp bexp = selectBindingFExp(attr);
		boolean isAttr = attr != null && attr.hasValue();
		param = param || isParameter();
		if (bexp != null && !(param && bexp.isIndependentParameterExp())) {
			if (!inRecord())
				setBindingExpOpt(new Opt());
			genBindingEquationsFromExp(fc, prefix, attr, bexp, param);
			if (isAttr)
				attr.setValueOpt(new Opt());
		}
	}
	
	public void FRecordVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, boolean param) {
		/* TODO: Perhaps this is the wrong approach? Could we instead convert binding expressions 
		 *       for records into attributes on the variable, and sort it out into binding expressions 
		 *       during scalarization?
		 */
		FExp bexp = selectBindingFExp(attr);
		if (bexp != null) {
			super.genBindingEquations(fc, prefix, attr, param);
		} else {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				FAttribute cAttr = findMatching(attrs, comp.name());
				comp.genBindingEquations(fc, name, cAttr, param || isParameter());
			}
		}
	}
	
	protected void FVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, boolean param) {
		FQName name = createNameForBindingEquation(prefix, attr);
		param = param || isParameter();
		FEquation feq = new FEquation(new FIdUseExp(name), bexp.reflattenBindingExp(prefix, this));
		if (param)
			fc.addFParameterEquation(feq);
		else
			fc.addFEquation(feq);	
	}
	
	protected void FRecordVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, boolean param) {
		/* If we get here, then we won't be able to leave expressions for independent parameters 
		 * as binding expressions on the FVariable - we'll have to clean that up later. Since it 
		 * has to be done after records are broken into separate variables, we'll do it during 
		 * parameter equation sorting.
		 */
		if (bexp.canExtractRecordComponents()) {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				FAttribute cAttr = findMatching(attrs, comp.name());
				FExp cExp = bexp.dynamicFExp(bexp.extractRecordFExp(comp.name()));
				comp.genBindingEquationsFromExp(fc, name, cAttr, cExp, param || isParameter());
			}
		} else {
			super.genBindingEquationsFromExp(fc, prefix, attr, bexp, param);
		}
	}
	
	public FExp FExp.reflattenBindingExp(FQName prefix, FVariable var) {
		FExp res = dynamicFExp((FExp) fullCopy());
		FRecordDecl decl = var.containingRecordDecl();
		if (decl != null)
			res.prefixInternalUses(prefix, decl);
		return res;
	}
	
	public void FExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		for (FExp e : childFExps())
			e.prefixInternalUses(prefix, decl);
	}
	
	public void FIdUseExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		FQName fqn = getFIdUse().getFQName();
		for (FQNamePart p : fqn.getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.prefixInternalUses(prefix, decl);
		if (decl == lookupFV(fqn.copyPrefix()).containingRecordDecl()) 
			getFIdUse().setFQName(prefix.copyAndAppend(fqn));
	}
	
	public void FSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {}
	
	public void FExpSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		getFExp().prefixInternalUses(prefix, decl);
	}
	
	protected List<FAttribute> FRecordVariable.selectFAttributeList(FAttribute attr) {
		if (attr != null && attr.getFAttributes().getNumChild() > 0)
			return attr.getFAttributes();
		else
			return getFAttributes();
	}
	
	syn boolean FExp.canExtractRecordComponents()      = false;
	eq FIdUseExp.canExtractRecordComponents()          = true;
	eq FRecordConstructor.canExtractRecordComponents() = true;
	eq FArray.canExtractRecordComponents()             = true;
	eq FAbstractCat.canExtractRecordComponents()       = true;
	
	/**
	 * \brief Create an FExp that represents a specific component of this record expression.
	 * 
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.extractRecordFExp(String suffix) {
		throw new UnsupportedOperationException("Can't extract record component of " + getClass().getSimpleName());
	}
	
	public FExp FIdUseExp.extractRecordFExp(String suffix) {
		FQName name = getFIdUse().getFQName().copyAndAppend(suffix);
		return new FIdUseExp(name);
	}
	
	public FExp FRecordConstructor.extractRecordFExp(String suffix) {
		return (FExp) getArg(getRecord().myFRecordDecl().indexOf(suffix)).fullCopy();
	}
	
	public FExp FArray.extractRecordFExp(String suffix) {
		FArray res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FAbstractCat.extractRecordFExp(String suffix) {
		FInfArgsFunctionCall res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FCatExp.extractRecordFExp(String suffix) {
		FCatExp res = (FCatExp) super.extractRecordFExp(suffix);
		res.setDim((FExp) getDim().fullCopy());
		return res;
	}
	
	public FExp FNoEventExp.extractRecordFExp(String suffix) {
		return createNode(getFExp().extractRecordFExp(suffix));
	}
	
	/**
	 * \brief Generate equations from an attribute of a record variable.
	 */
	public void FAttribute.genBindingEquations(FClass fc, FRecordDecl rec, FQName prefix, boolean depPar) {
		FVariable comp = (FVariable) rec.findComponent(getName().getFQName());
		if (!comp.isUnknown() && !comp.isConstant()) {
			FQName fqn = prefix.copyAndAppend(getName().getFQName());
			
			if (hasValue()) {
				boolean indPar = !depPar && comp.isParameter() && getValue().isIndependentParameterExp();
				// TODO: handle 'each'
				if (!indPar) {
					FEquation feq = new FEquation(new FIdUseExp(fqn), getValue());
					if (depPar || comp.isParameter())
						fc.addFParameterEquation(feq);
					else
						fc.addFEquation(feq);
					setValueOpt(new Opt());
				}
			}
			
			if (comp.isRecord()) {
				FRecordDecl next = comp.myFRecordDecl();
				for (FAttribute a : getFAttributes())
					a.genBindingEquations(fc, next, fqn, depPar);
			}
		}
	}
	
	/**
	 * \brief Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		for (FAlgorithmBlock alg : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FQName funcName = new FQName(alg.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FIdUse use : alg.usedFIdUses()) {
				AbstractFVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FIdUse use : alg.assignedFIdUses()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
					FQName fqn = new FQName(name);
					ffv.setFQName(fqn);
					
					// Create and add binding expression for output
					bothInVars.get(i).setBindingExp(fqn.createFIdUseExp());
				}
			}
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
			FFunctionCall call = new FFunctionCall(funcName.createFIdUse(), args, sizes);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFQName().createFFunctionCallLeft());
			replaceEquation(alg, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			alg.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, alg));
		}
	}
	
	/**
	 * \brief Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		for (FEquationBlock b : getFEquationBlocks())
			if (b.getFAbstractEquations().replaceChild(oldEq, newEq))
				return;
	}
	
	/**
	 * \brief Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FQName.createFFunctionCallLeft() {
		FQName fqn = fullCopy();
		fqn.setLastFArraySubscripts(null);
		return new FFunctionCallLeft(new Opt(new FIdUseExp(fqn)));
	}

	/**
	 * \brief Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return null; // TODO: Return pre() value.
			if (isContinuous())
				return startAttributeExp();
		}
		return getFQName().createFIdUseExp();
	}
	
	/**
	 * \brief Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(new FOutput());
	}

	/**
	 * \brief Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(new FInput());
	}

	/**
	 * \brief Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(FTypePrefixInputOutput io) {
		FType type = (FType) type().fullCopy();
		return new FFunctionVariable(new Opt(io), type, new Opt(), getFQName().fullCopy());
	}

	/**
	 * \brief Add derivative variables to the list of FVariables, one for each
	 * differentiate variable.
	 */
	public void FClass.addFDerivativeVariables() {
		ArrayList<FDerivativeVariable> l = new ArrayList<FDerivativeVariable>();
		for (FVariable fv : differentiatedRealVariables()) {
			l.add(new FDerivativeVariable((FVisibilityType)fv.getFVisibilityType().fullCopy(),
					(FTypePrefixVariability)fv.getFTypePrefixVariability().fullCopy(),
					new Opt(),
					new List(),
					new Opt(),
					new Opt(),
					fv.getFQName().fullCopy()));
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
				root().flushAllRecursive();
	}

	/**
	 * \brief Generate initial equations from variables with fixed start
	 * attributes.
	 * 
	 * Intitial equations corresponding to explicitly set start attributes of 
	 * differentiated variables are also generated, without taking the fixed
	 * attribute into account.
	 */
	public void FClass.genInitialEquations() {
		// TODO: Isn't there always a value for fv.startAttributeExp() now?
		for (FRealVariable fv : realVariables()) {
			if (fv.fixedAttribute() ||
					(root().options.getBooleanOption("state_start_values_fixed") 
							&&  fv.isDifferentiatedVariable() && fv.startAttributeSet())) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FRealLitExp("0.0")));
			}	
		}
//		log.debug(prettyPrint(""));
		for (FIntegerVariable fv : integerVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FIntegerLitExp("0")));
			}	
		}
		for (FBooleanVariable fv : booleanVariables()) {
			if (fv.fixedAttribute()) {
				addFInitialEquation(new FEquation(new FIdUseExp(
						new FIdUse(fv.getFQName().fullCopy())),
						fv.startAttributeSet()? fv.startAttributeExp(): new FBooleanLitExpFalse()));
			}	
		}		
		//flush();
				root().flushAllRecursive();
	}
	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * \brief A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	/**
	 * \brief Detection of alias variables in equations
	 * 
	 * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
	 * as alias equations and an AliasPair object is returned.
	 */
	public AliasPair FEquation.aliasVariables() {

		AbstractFVariable afv1 = null;
		AbstractFVariable afv2 = null;
		
		FVariable fv1 = null;
		FVariable fv2 = null;
		boolean negated = false;
		
		if (getLeft() instanceof FIdUseExp && // x = y
					getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)getLeft()).myFV();
			afv2 = ((FIdUseExp)getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = false;
			}
		} else if (getLeft() instanceof FNegExp && // -x = y
				((FNegExp)getLeft()).getFExp() instanceof FIdUseExp &&
				getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)((FNegExp)getLeft()).getFExp()).myFV();
			afv2 = ((FIdUseExp)getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if (getLeft() instanceof FIdUseExp && // x = -y
					getRight() instanceof FNegExp &&
				((FNegExp)getRight()).getFExp() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)getLeft()).myFV();
			afv2 = ((FIdUseExp)((FNegExp)getRight()).getFExp()).myFV();	
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if (getLeft() instanceof FNegExp && // -x = -y
				((FNegExp)getLeft()).getFExp() instanceof FIdUseExp &&
				getRight() instanceof FNegExp &&
				((FNegExp)getRight()).getFExp() instanceof FIdUseExp
				) {
			afv1 = ((FIdUseExp)((FNegExp)getLeft()).getFExp()).myFV();
			afv2 = ((FIdUseExp)((FNegExp)getRight()).getFExp()).myFV();	
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = false;
			}
		} else if (getLeft() instanceof FLitExp && getLeft().ceval().realValue() == 0 && // 0 = x + y
				getRight() instanceof FDotAddExp &&
				((FDotAddExp)getRight()).getLeft() instanceof FIdUseExp &&
				((FDotAddExp)getRight()).getRight() instanceof FIdUseExp) {
			afv1 = ((FIdUseExp)((FDotAddExp)getRight()).getLeft()).myFV();
			afv2 = ((FIdUseExp)((FDotAddExp)getRight()).getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		} else if ((getLeft() instanceof FDotAddExp &&  //  x + y = 0
				((FDotAddExp)getLeft()).getLeft() instanceof FIdUseExp &&
				((FDotAddExp)getLeft()).getRight() instanceof FIdUseExp) &&
				(getRight() instanceof FLitExp && getRight().ceval().realValue() == 0)) {
			afv1 = ((FIdUseExp)((FDotAddExp)getLeft()).getLeft()).myFV();
			afv2 = ((FIdUseExp)((FDotAddExp)getLeft()).getRight()).myFV();
			if (!afv1.isUnknown() && !afv2.isUnknown()) {
				fv1 = (FVariable)afv1;
				fv2 = (FVariable)afv2;
				negated = true;
			}
		}
		
		if ((fv1!=null) && 
				(fv2!=null)) {
			return new AliasPair(fv1,fv2,negated);
		} else {
			return null;
		}
		
	}
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	eq FEquation.isAliasEquation() = aliasVariables()!=null;
	
	/**
	 * \brief Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		aliasManager = new AliasManager();
		
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations
			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
//			System.out.println(equation.prettyPrint(" -- "));
			if (equation.isAliasEquation()) {
				AliasPair aliasPair = equation.aliasVariables();
				aliasManager.addAliasVariables(aliasPair.fv1,
						aliasPair.fv2, aliasPair.negated);
//				System.out.println(aliasManager.printAliasSets());
			}			
		}	
		//flush();
		root().flushAllRecursive(); // TODO: is this really needed? the tree isn't changed
	}

	/**
	 * \brief Flag indicating if alias variables have been eliminated from the
	 * model.
	 */
	public boolean FClass.aliasVariablesEliminated = false;
	
	/**
	 * \brief Eliminate alias variables from the flat model.
	 * 
	 * The non-alias variables are kept in the list FClass.FVariableList but the
	 * alias variables are moved to FClass.AliasVariablesList.
	 */
	public void FClass.eliminateAliasVariables() {
		ArrayList<FVariable> nonAliasVars = new ArrayList<FVariable>();
		ArrayList<FVariable> aliasVars    = new ArrayList<FVariable>();
		ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
		
		//log.debug("FClass.eliminateAliasVariables(): l1 " + nonAliasVars + " l2 " + aliasVars);
		
		// Go through all variables and insert in correct list
		for (FVariable fv : getFVariables()) {
			if (fv.isAlias()) 
				aliasVars.add(fv);
			else 
				nonAliasVars.add(fv);
		}
		
		// Remove alias equations.
		for (FAbstractEquation equation : getFEquationBlock(0).getFAbstractEquations()) 
			if (!equation.isAliasEquation()) 
				eqns.add(equation);

		setFVariableList(new List(nonAliasVars));
		setAliasVariableList(new List(aliasVars));
		getFEquationBlock(0).setFAbstractEquationList(new List(eqns));
		
		aliasVariablesEliminated = true;
		enableAliasRewrite();
		
		flush();
	}
	
	public void ASTNode.enableAliasRewrite() {
		for (ASTNode n : this)
			n.enableAliasRewrite();
	}
	
	public void FIdUseExp.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	boolean FIdUseExp.rewriteAlias = false;
	
	/**
	 * \brief FIdUses referring to alias variables need to be changed to 
	 * FIdUses referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FIdUseExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().getFQName().createFIdUseExp();
			if (fv.isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
	
	/**
	 * \brief FDerExps referring to alias variables need to be changed to 
	 * FDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDerExp {
		when (rewriteAlias && !getFIdUse().myFV().isUnknown() && getFIdUse().myFV().isAlias()) to FExp {
			FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
			FExp new_exp = new FDerExp(new FIdUse(new_name));
			if (getFIdUse().myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/*
	 * Rewrite derivatives of parameters to zeros.
	 */
	rewrite FDerExp {
		when (!getFIdUse().myFV().isUnknown() &&
				((FVariable)getFIdUse().myFV()).variability().lessOrEqual(fParameter())) to FExp {
			return new FRealLitExp("0.0");
		}
	}

}

aspect MapWhenClauses{

	public void ASTNode.enableWhenEquationRewrite() {
		for (ASTNode n : this)
			n.enableWhenEquationRewrite();
	}
	
	public void FWhenEquation.enableWhenEquationRewrite() {
		super.enableWhenEquationRewrite();
		rewriteWhenEquation = true;
		is$Final = false;
	}
	
	boolean FWhenEquation.rewriteWhenEquation = false;

	public abstract FIfWhenElseEquation FIfWhenElseEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause);
	
	public FIfWhenElseEquation FWhenEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FWhenEquation((FEquationType)getType().fullCopy(),eqns,guard,elseClause);
	}

	public FIfWhenElseEquation FIfEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FIfEquation((FEquationType)getType().fullCopy(),eqns,guard,elseClause);
	}

	public FIfWhenElseEquation FElseEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FElseEquation((FEquationType)getType().fullCopy(),eqns);
	}


	public FIfWhenElseEquation FIfWhenElseEquation.createSimpleIfWhenElseEquation(String varName, boolean copyGuard) {
		return null; //Not handled yet
	}

	public FIfWhenElseEquation FIfWhenEquation.createSimpleIfWhenElseEquation(String varName, boolean copyGuard) {
	
		// Copy guard
		FExp guard = null;
		if (copyGuard) {
			System.out.println("FIfWhenEquation.createSimpleIfWhenElseEquation - copy guard");
			guard = (FExp)getTest().fullCopy();
			guard.setParent(this);
			guard.traverseSymbolic(getTest());
		} else {
			System.out.println("FIfWhenEquation.createSimpleIfWhenElseEquation - copy guard");
			guard = getTest();
		}
		
		// Find the right equation
		FAbstractEquation eqn = null;
		for (FAbstractEquation e : getFAbstractEquations()) {
		 	if (e.isSimple()) {
		 		for (FIdUseExp n : e.simpleLefts()) {
					if (n.name().equals(varName)) {
						eqn = e;
						break;
					}
		 		}
		 	}
		}
		
		if (eqn==null) {
			return null;
		}
		
		List eqns = new List().add(eqn);
		
		Opt o = null;
		// If there is an else when, split it
		if (hasElse()) {
			o = new Opt(getElse().createSimpleIfWhenElseEquation(varName,copyGuard));
		} else {
		    o = new Opt();
		}
		return createIfWhenElseEquation(eqns,guard,o);
	}

	public List FWhenEquation.splitWhenEquation() {
		List l = new List();
		int i = 0;
		for (FAbstractEquation e : getFAbstractEquations()) {
		 	if (e.isSimple()) {
		 		for (FIdUseExp n : e.simpleLefts()) {
		 			l.add(createSimpleIfWhenElseEquation(n.name(),i!=0));
		 		}
		 	}
		 	i++;
		}	
		return l;
	}

	rewrite FWhenEquation in FEquationBlock.getFAbstractEquation() {
		when (rewriteWhenEquation && getNumFAbstractEquation()>1) to List {
			return splitWhenEquation();
			/*
			List l = new List();
			l.setParent(this);
			FExp guard = getTest();
			// Create the first FWhenClause and use the original rel exp
			l.add(new FWhenEquation(getType(),new List().add(getFAbstractEquation(0)),guard,new Opt()));
			// Loop over the remaining and copy the guard and replace the guard exps
			for (int i=1;i<getNumFAbstractEquation();i++) {
				FExp guard_new = (FExp)guard.fullCopy();
				l.add(new FWhenEquation((FEquationType)getType().fullCopy(),
				          new List().add(getFAbstractEquation(i)),guard_new,new Opt()));
				guard_new.traverseSymbolic(guard);
			}
			return l;	*/
		}
	}
	
	syn lazy boolean FAbstractEquation.isSimple() = false;
	eq FEquation.isSimple() = (getLeft() instanceof FIdUseExp);
	
	syn lazy ArrayList<FIdUseExp> FAbstractEquation.simpleLefts() = new ArrayList<FIdUseExp>();
	eq FEquation.simpleLefts() {
		ArrayList<FIdUseExp> l = new ArrayList<FIdUseExp>();
		if (isSimple()) {
			l.add((FIdUseExp)getLeft());
		} 
		return l;
	}
	
}

aspect ParameterSorting {

	/**
	 * \brief Indicate if there exist cyclic parameter dependencies.
	 */
	public boolean FClass.cyclicParameters = false;
	
	/**
	 * \brief Index of equation during equation sorting.
	 */
	public int FAbstractEquation.sortingIndex = -1;
	
	public class FAbstractEquation {
		public static class SortingIndexComparator implements Comparator<FAbstractEquation> {
			public int compare(FAbstractEquation o1, FAbstractEquation o2) {
				return o1.sortingIndex - o2.sortingIndex;
			}
		}
	}
	
	public class FVariable {
		public static class SortingIndexComparator implements Comparator<FVariable> {
			public int compare(FVariable o1, FVariable o2) {
				return o1.parameterEquation().sortingIndex - o2.parameterEquation().sortingIndex;
			}
		}
	}
	
	/**
	 * \brief Creates a TreeSet that can hold FAbstractEquations, sorted by their sortingIndex.
	 */
	public static TreeSet<FAbstractEquation> FAbstractEquation.sortingSet() {
		return new TreeSet<FAbstractEquation>(new SortingIndexComparator());
	}
	
	/** 
	 * \brief Sorts a list of FVariables according to the sortingIndex of their equation.
	 */
	public static void FVariable.sortParameters(java.util.List<FVariable> vars) {
		Collections.sort(vars, new SortingIndexComparator());
	}
	
	/**
	 * \brief Sort dependent parameter equations.
	 * 
	 * This is a simple implementation of Kahn's topological sorting algorithm.
	 * This implementation will most likely be replaced by other graph 
	 * algorithms later on.
	 */
	public void FClass.sortDependentParameters() {
		// Get the list of parameter equations and set up preliminary data.
		ArrayList<FAbstractEquation> eqns = getFParameterEquations().toArrayList();
		int n_eqns = eqns.size();
		List<FVariable> vars = getFVariables();
		int n_vars = getNumFVariable();
		for (int i = 0; i < n_eqns; i++)
			eqns.get(i).sortingIndex = i;
		for (FVariable fv : vars)
			fv.parameterEquation();  // Calculate these before changing anything
		
		// If there is nothing to do, return.
		if (n_eqns == 0)
			return;
		
		// Set up data structures for the adjacency graph.
		ArrayList<HashSet<FAbstractEquation>> toNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		ArrayList<HashSet<FAbstractEquation>> fromNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		for (int i = 0; i < n_eqns; i++) {
			toNodes.add(new HashSet<FAbstractEquation>());
			fromNodes.add(new HashSet<FAbstractEquation>());
		}
		
		// For each equation
		for (FAbstractEquation eqn : eqns) {
			// Retreive all variables referenced in right hand side
			Set<AbstractFVariable> deps = eqn.referencedFVariablesInRHS();
			// Build the actual adjacency graph.
			for (AbstractFVariable fv : deps) {
				FAbstractEquation depEqn = fv.parameterEquation();
				if (depEqn != null && depEqn.sortingIndex >= 0) {
					toNodes.get(depEqn.sortingIndex).add(eqn);		
					fromNodes.get(eqn.sortingIndex).add(depEqn);
				}
			}
		}	
				
		// Sort using algorithm described at
		// http://en.wikipedia.org/wiki/Topological_sorting
		List<FAbstractEquation> L = new List<FAbstractEquation>();
		Queue<FAbstractEquation> S = 
			new java.util.concurrent.ArrayBlockingQueue<FAbstractEquation>(n_eqns);
		
		// Add all nodes without incoming edges to S
		for (int i = 0; i < n_eqns; i++) 
			if (fromNodes.get(i).isEmpty()) 
				S.add(eqns.get(i));
		
		// Repeat while S is not empty
		int si = 0;
		int n_indep = 0;
		while (S.size() > 0) {
			// Remove a node n from S
			FAbstractEquation n = S.remove();
			// Take care of n
			if (n.isIndependentParameterEquation()) {
				/* This equation should be the binding expression of an independent parameter.
				 * There are several ways this could happen, e.g. using iteration expressions.
				 * These could be removed from list before sorting, but this way is simpler. */ 
				n.revertToBindingExp();
				n_indep++;
			} else {
				// Insert n into L
				L.add(n);
			}
			// For each node m with an edge e from n to m (in original order)
			Set<FAbstractEquation> nodes = FAbstractEquation.sortingSet();
			nodes.addAll(toNodes.get(n.sortingIndex));
			for (FAbstractEquation m : nodes) {
				// Remove edge e from fromNodes
				fromNodes.get(m.sortingIndex).remove(n);
				// If m has no incoming edges add m to S
				if (fromNodes.get(m.sortingIndex).isEmpty()) 
					S.add(m);
			}
			// Remove e from toNodes
			toNodes.get(n.sortingIndex).clear();
			// Done with n - update sortingIndex
			n.sortingIndex = si++;
		}
		
		// Not possible to find an ordering without cycles?
		if (L.getNumChild() != eqns.size() - n_indep) {
			cyclicParameters = true;
			return;
		}
		
		// Replace old parameter equation list
		setFParameterEquationList(L);
		
		// Rearrange parameters in same order as parameter equations
		ArrayList<FVariable> depParams = new ArrayList<FVariable>(n_eqns);
		ArrayList<Integer> depParamIndices = new ArrayList<Integer>(n_eqns);
		for (int i = 0; i < n_vars; i++) {
			FVariable fv = vars.getChild(i);
			if (fv.hasParameterEquation()) {
				depParams.add(fv);
				depParamIndices.add(new Integer(i));
			}
		}
		FVariable.sortParameters(depParams);
		for (int i = 0; i < depParams.size(); i++)
			vars.setChild(depParams.get(i), depParamIndices.get(i).intValue());

		// Flush AST since the structure has changed.
		flush();
		
		// Remove any binding expressions of variables with parameter equations
		for (FAbstractEquation eqn : L)
			eqn.removeBindingExpOfAssignedVars();
	}
	
	/**
	 * Remove binding expression of variables assigned in this equation.
	 */
	public void FAbstractEquation.removeBindingExpOfAssignedVars() {}

	public void FEquation.removeBindingExpOfAssignedVars() {
		getLeft().removeBindingExpOfReferencedVars();
	}
	
	public void FFunctionCallEquation.removeBindingExpOfAssignedVars() {
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
				left.getFExp().removeBindingExpOfReferencedVars();
	}
	
	/**
	 * Remove binding expression of variables referenced in this expression.
	 */
	public void FExp.removeBindingExpOfReferencedVars() {
		for (FExp e : childFExps())
			e.removeBindingExpOfReferencedVars();
	}
	
	public void FIdUseExp.removeBindingExpOfReferencedVars() {
		getFIdUse().myFV().removeBindingExp();
	}
	
	/**
	 * Remove binding expression of this variable.
	 */
	public void AbstractFVariable.removeBindingExp() {}
	
	public void FVariable.removeBindingExp() {
		if (hasBindingExp())
			setBindingExpOpt(new Opt());
	}
	
	/**
	 * Test if this should be the binding expression of an independent parameter instead.
	 */
	syn boolean FAbstractEquation.isIndependentParameterEquation() = false;
	eq FEquation.isIndependentParameterEquation() = 
		getLeft().isFlatParameterUse() && getRight().isIndependentParameterExp();
	
	/**
	 * Test if this is a use of a parameter (in the flat tree).
	 */
	syn boolean FExp.isFlatParameterUse()   = false;
	eq FIdUseExp.isFlatParameterUse()       = getFIdUse().isFlatParameterUse();
	syn boolean FIdUse.isFlatParameterUse() = myFV().isParameter();
	
	/**
	 * Convert this parameter equation to a binding expression.
	 */
	public void FAbstractEquation.revertToBindingExp() {}
	public void FEquation.revertToBindingExp() {
		FVariable fv = (FVariable) ((FIdUseExp) getLeft()).getFIdUse().myFV();
		fv.setBindingExp(getRight());
	}

}

aspect TransformCanonicalErrorCheck {
	
	syn int FClass.numDAEEquations()     = numScalarEquations();
	syn int FClass.numDAEVariables()     = 
		numAlgebraicRealVariables() + numDifferentiatedRealVariables() + numDiscreteVariables();
	syn int FClass.numDAEInitEquations() = numDAEEquations() + numInitialEquations();
	syn int FClass.numDAEInitVariables() = numDAEVariables() + numDifferentiatedRealVariables();
	
	public void FClass.checkFClassDimensions() {
		// Check dimensions of DAE
		int n_eq_F = numDAEEquations();
		int n_vars_F = numDAEVariables();
		if (n_eq_F != n_vars_F) 
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numDAEInitEquations();
		int n_vars_F0 = numDAEInitVariables();
		if (n_eq_F0 > n_vars_F0) 
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		
	}
	
	public void FClass.collectErrors() {
		if (cyclicParameters) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		}
		if (getAliasManager().aliasError()) {
			error(getAliasManager().getAliasErrorMessage());
		}
		for (String str : aliasErrors) {
			error(str);
		}
		checkDuplicateVariables();
		checkFClassDimensions();
		for (String str : structuralErrors()) {
			error(str);
		}		
		checkUnsupportedStreamConnections();
	}
}

aspect FlushFClass {
	/**
	 * \brief Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FIdUseExps and FDerExps in order to enable rewrites of such nodes
	 * after elimination of alias variables.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
	public void FIdUseExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}
	
	public void FDerExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursiveClearFinal();
		}
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flushAllRecursive();
		}
	}
	
	/**
	 * \brief Flush model AST and enable rewrites of FIdUseExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
}
