/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//import java.util.ArrayDeque;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Queue;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Collections;
import java.util.Iterator;
import org.jmodelica.util.ParallelIterable;


/* This causes conflicts
import org.jmodelica.graphs.EquationSystem;
import org.jmodelica.graphs.Equation;
import org.jmodelica.graphs.Variable;
*/

/**
 * \brief Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

	/**
	 * \brief Transform the raw flattened model into a structured form.
	 * 
	 * Currently, the following operations are performed:
	 *  <ul>
	 *    <li> Binding equations for variables are converted into regular
	 *         equations by calling genBindingEquations().
	 *    <li> For each non-function algorithm:
	 *         <ul>
	 *                any assigned variables as outputs and any used 
	 *                variables as inputs.
	 *           <li> The original algorithm is replaced with a call to 
	 *                the generated function.
	 *         </ul>
	 *    <li> The model is scalarized, i.e., all array declarations and
	 *         equations are replaced by scalar declarations and equations
	 *    <li> Alias variables are eliminated from the model.
	 *    <li> Derivative variables are generated and inserted in the
	 *         list of FVariables by calling addFDerivativeVariables().
	 *    <li> Generate initial equations based on start attribute.
	 *    <li> Sort dependent parameters.
	 *  </ul>
	 */
	 
	 /**
	  *  transformCanonicalBase contains all transformation that should be
	  *  done by both the Modelica and the Optimica compilers.
	  */
	public void FClass.transformCanonicalBase() {
		enableIfEquationElimination();
		addStateInitialEquationsIfSet();
		genAlgorithmFunctions();
		genBindingEquations();
		scalarize();
		genAlgoInitStmts();
		propagateResidualPairs();
		genInitArrayStatements();
		functionInliningIfSet();
		aliasEliminationIfSet();
		addFDerivativeVariables();
		extractEventGeneratingExps();
		addFPreVariables();
		enableIfEquationRewrite();
		enableWhenEquationRewrite();
		variabilityPropagationIfSet();
		evaluateAsserts();
		enableSemiLinearRewrite();
		genInitialEquations();
		sortDependentParameters();
		addRuntimeOptionParameters();
	}
	
	public void FClass.transformCanonicalCleanup() {
		removeUnusedFunctions();
	    root().flushAllRecursive();
		for (FRecordDecl rec : getFRecordDecls())
			rec.clearBindingEquations();
	}

	/**
	 * After scalarization, binding expressions on members of record declarations are no longer needed. 
	 */
	public void FRecordDecl.clearBindingEquations() {
		for (FVariable fv : getFVariables())
			fv.setBindingExpOpt(new Opt());
	}
	

	public void FClass.transformCanonical() {
		beginStep("transformCanonical()");
	
		transformCanonicalBase();
	
		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			// Equations are added as part of this this method
			computeMatchingsAndBLT();
			computeInteractiveFMUIfSet();
			daeBLT.complianceCheck();
		}
	
		root().flushAllRecursive();	
		transformCanonicalCleanup();

		endStep("transformCanonical()");
	}
		
	public class BLT extends ArrayList<AbstractEquationBlock> {
	
		public ArrayList<Integer> unsolvedBlockSizes() {
			ArrayList<Integer> blockSizes = new ArrayList<Integer>();
			for (AbstractEquationBlock b : this) {
				if (!b.isSolvable()) {
					blockSizes.add(new Integer(b.activeVariables().size()));
				}		
			}
			return blockSizes;
		}

		public ArrayList<Integer> unsolvedBlockIterationSizes() {
			ArrayList<Integer> blockSizes = new ArrayList<Integer>();
			for (AbstractEquationBlock b : this) {
				if (!b.isSolvable()) {
					blockSizes.add(new Integer(b.iterationVariables().size()));
				}		
			}
			return blockSizes;
		}

		public void reset() {
			for (AbstractEquationBlock eb : this) {
				eb.reset();
			}	
		}

		public String toString() {
			StringBuffer str = new StringBuffer();
			str.append("-------------------------------\n");
			for (AbstractEquationBlock eb : this) {
				str.append(eb.toString());
				str.append("-------------------------------\n");
			}
			return str.toString();
		}
		
		public void writeIterationVariablesToFile(File file) throws FileNotFoundException {
			PrintStream out = new PrintStream(file);
			for (AbstractEquationBlock block : this)
				block.printIterationVariables(out);
			out.close();
		}
		
		public void writeTearingPairsToFile(File file) throws FileNotFoundException {
			PrintStream out = new PrintStream(file);
			int count = 0;
			for (AbstractEquationBlock block : this)
				block.printTearingPairs(out, count++);
			out.close();
		}
		
		public void complianceCheck() {
			for (AbstractEquationBlock block : this) {
				if (!block.isSolvable()) {
					for (FAbstractEquation equ : block.equations()) {
						if (equ instanceof FWhenEquation) {
							if (block.equations().size() == 1) {
								equ.compliance("Unsolved equations in when-clause is not supported. \n" + equ.prettyPrint(""));
							} else {
								equ.compliance("When-clause in unsolved equations is not supported. \n" + equ.prettyPrint(""));
							}
						}
					}
				}
			}
		}
	}
	
	public class StructuredBLT extends BLT {
		private ArrayList<AbstractEquationBlock> topEquationBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> allBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> odeBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> realOutputBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> integerBooleanOutputBlocks = new ArrayList<AbstractEquationBlock>();
		private ArrayList<AbstractEquationBlock> otherBlocks = new ArrayList<AbstractEquationBlock>();
		
		private FClass fclass;
	
		public StructuredBLT(FClass fclass) {
			this.fclass = fclass;	
		}
		
		public StructuredBLT(FClass fclass, BLT blt) {
			this(fclass);
			for (AbstractEquationBlock eb : blt) {
				this.add(eb);
				eb.setDAEPredecessors();
				if (eb.getPredecessors().size() == 0) {
					topEquationBlocks.add(eb);
				}
			}

			reset();
			// Loop over all derivatives
			for (FVariable fv : getFClass().derivativeVariables()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				if (!eb.isVisited()) {
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							odeBlocks.add(ebb);
						}
					}
					odeBlocks.add(eb);
				}
			}
			
			// Loop over all real outputs
			for (FVariable fv : getFClass().realOutputs()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				//States and inputs can be outputs in which case they don't have equation blocks associated with them
				if (eb!=null && !eb.isVisited()) { 
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							realOutputBlocks.add(ebb);
						}
					}
					realOutputBlocks.add(eb);
				}	
			}

			// Loop over integer and boolean outputs
			for (FVariable fv : getFClass().outputs()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				if (eb!=null && !eb.isVisited()) {
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()){
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							integerBooleanOutputBlocks.add(ebb);
						}
					}
					integerBooleanOutputBlocks.add(eb);
				}	
			}

			// Loop over all others
			for (FVariable fv : getFClass().variables()) {
				// Get the block where the variable is solved for	
				AbstractEquationBlock eb = fv.myDAEEquationBlock();
				if (eb!=null && !eb.isVisited()) {
					eb.setVisited(true);
					for (AbstractEquationBlock ebb : eb.getAllPredecessors()) {
						if (!ebb.isVisited()) {	
							ebb.setVisited(true);
							otherBlocks.add(ebb);
						}
					}
					otherBlocks.add(eb);
				}	
			}
			// Add any blocks not visited (generally meta blocks)
			for (AbstractEquationBlock eb : this) {
				if (!eb.isVisited()) {
					eb.setVisited(true);
					otherBlocks.add(eb);
				}
			}
			
			allBlocks.addAll(odeBlocks);
			allBlocks.addAll(realOutputBlocks);
			allBlocks.addAll(integerBooleanOutputBlocks);
			allBlocks.addAll(otherBlocks);

		}
		
		public FClass getFClass() {
			return fclass;	
		}
		

	    public ArrayList<AbstractEquationBlock> getAllBlocks() {
			return allBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getOdeBlocks() {
			return odeBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getRealOutputBlocks() {
			return realOutputBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getIntegerBooleanOutputBlocks() {
			return integerBooleanOutputBlocks;
		}

	    public ArrayList<AbstractEquationBlock> getOtherBlocks() {
			return otherBlocks;
		}

		public String printGraphPython() {
			StringBuffer str = new StringBuffer();
			str.append("##############################\n");
			int max_depth = 0;
			HashMap<String,ArrayList<AbstractEquationBlock>> map = new HashMap<String,ArrayList<AbstractEquationBlock>>();
			for (AbstractEquationBlock eb : allBlocks) {
				int d = eb.depth();
				if (d>max_depth) {
					max_depth = d;
				}
				if (map.get("" + d)==null) {
					map.put("" + d,new ArrayList<AbstractEquationBlock>());
				}
				map.get("" + d).add(eb);	
			}
			str.append("blocks={\n");
			int l = 0;
			
//			for (String key : map.keySet()) {
			for (int i=0;i<=max_depth;i++) {
				String key = "" + i;
				int k=0;
				str.append(key + ":[");
				for (AbstractEquationBlock eb : map.get(key)) {
					str.append("{'index':" + allBlocks.indexOf(eb) + ",'depth':" + l + ",'pred':" + "[" );
					int j = 0;
					for (AbstractEquationBlock peb : eb.getPredecessors()) {
						str.append(allBlocks.indexOf(peb));	
						if (j<eb.getPredecessors().size()-1) {
							str.append(",");
						}
						j++;
					}
					str.append("]}");
					if (k<map.get(key).size()-1) {
						str.append(",\n");
					}
					k++;
				}	
				str.append("]");
				if (l<max_depth) {
					str.append(",\n");
				}
				l++;		
			}	

			str.append("}\n");
			str.append("##############################");
			return str.toString();
		}

		public String toString() {
			
			HashSet<FVariable> solvedVars = new HashSet<FVariable>();
			
			int n_blocks = 0;
			/*
			for (AbstractEquationBlock eb : getOdeBlocks()) {
				n_blocks++;
				for (FVariable fv : eb.activeVariables()) {
					System.out.println("'" + fv.name() + "',");
				}
				for (FVariable fv : eb.inactiveVariables()) {
					if (!solvedVars.contains(fv)) {
						System.out.println("ERRROR:");
						System.out.println("Variable:");
						System.out.println(fv);
						System.out.println("needed by block:");
						System.out.println(eb.toStringVerbose());
						System.out.println("have not been solved");
					}							
				}
				solvedVars.addAll(eb.activeVariables());
			}
			
			for (AbstractEquationBlock eb : getOtherBlocks()) {
				n_blocks++;
				for (FVariable fv : eb.inactiveVariables()) {
					if (!solvedVars.contains(fv)) {
						System.out.println("ERRROR:");
						System.out.println("Variable:");
						System.out.println(fv);
						System.out.println("needed by block:");
						System.out.println(eb.toStringVerbose());
						System.out.println("have not been solved");
					}							
				}
				solvedVars.addAll(eb.activeVariables());
			}
			
			System.out.println("Number of blocks in generated code: " + n_blocks +  
			" Total number of blocks: " + size());
			*/

			StringBuffer str = new StringBuffer();
			str.append("************* Structured BLT*********\n");
			str.append("***********************************\n");	
			str.append("************* ODE section *********\n");	
			str.append("***********************************\n");	
			// Loop over all derivatives
			for (AbstractEquationBlock eb : getOdeBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}
			str.append("***********************************\n");	
			str.append("************ Real outputs *********\n");	
			str.append("***********************************\n");	
			for (AbstractEquationBlock eb : getRealOutputBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}
			str.append("***********************************\n");	
			str.append("****Integer and boolean outputs ***\n");	
			str.append("***********************************\n");	
			for (AbstractEquationBlock eb : getIntegerBooleanOutputBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}
			str.append("***********************************\n");	
			str.append("**** Other variables ***\n");	
			str.append("***********************************\n");	
			for (AbstractEquationBlock eb : getOtherBlocks()) {
				str.append(eb.toString());
				str.append("******\n");
			}

//			str.append(">>\n\n\n");
//			str.append(printGraphPython());

			return str.toString();
		}
	}

	/**
	 * Abstract class for equation blocks resulting from the BLT transformation
	 */
	public abstract class AbstractEquationBlock {
	
		private Set<AbstractEquationBlock> allPredecessors = null;
		private Set<AbstractEquationBlock> predecessors = new LinkedHashSet<AbstractEquationBlock>();
		private Set<AbstractEquationBlock> successors = new LinkedHashSet<AbstractEquationBlock>();
		private Set<FVariable> dependsOnVariables = null; 
		private boolean visited = false;
		private boolean predecessorsSet = false;
	
		public abstract Collection<FAbstractEquation> equations();
		
		/*
		 * The active variables are assigned their values when the block is solved.
		 */
		public abstract Collection<FVariable> activeVariables();

		/* 
		 * These are the variables that are solved for if an iterative
		 * Newton solver is applied. This set is not necessarily identical
		 * to the set of active variables, e.g., in the case of torn
		 * or mixed blocks.
		 */ 
		public Collection<FVariable> iterationVariables() {
			return activeVariables();
		}
		
		public Collection<FVariable> continuousIterationVariables() {
			Collection<FVariable> l = new ArrayList<FVariable>();
			for (FVariable fv : iterationVariables())
				if (fv.isReal())
					l.add(fv);
			return l;
		}
		
		public Collection<FVariable> descreteIterationVariables() {
			Collection<FVariable> l = new ArrayList<FVariable>();
			for (FVariable fv : iterationVariables())
				if (!fv.isReal())
					l.add(fv);
			return l;
		}
		
		public FTypePrefixVariability variability() {
			return FContinuous.instance;
		}
		
		public Collection<FVariable> inactiveVariables() {
			java.util.List<FVariable> s = new ArrayList<FVariable>();
			for (FAbstractEquation e : equations()) {
				s.addAll(e.algebraicVariables());
				s.addAll(e.derivativeVariables());	
			}
			s.removeAll(activeVariables());
			return s;	
		}		

		public Collection<FVariable> independentVariables() {
			java.util.List<FVariable> s = new ArrayList<FVariable>();
			for (FAbstractEquation e : equations()) {
				s.addAll(e.inputs());
				s.addAll(e.differentiatedRealVariables());	
				s.addAll(e.discretePreVariables());	
			}
			return s;
		}		
		
		public abstract boolean isSolvable();
		
		public void setDAEPredecessors() {
			if (!predecessorsSet) {
				for (FVariable fv : inactiveVariables()) {
					if (!predecessors.contains(fv.myDAEEquationBlock())) {
						predecessors.add(fv.myDAEEquationBlock());
					}
					if (!fv.myDAEEquationBlock().getSuccessors().contains(this)) {
						fv.myDAEEquationBlock().getSuccessors().add(this);
					}
					fv.myDAEEquationBlock().setDAEPredecessors();
				}
				predecessorsSet = true;
			}		
		}
		
		public Set<FVariable> dependsOn() {
			if (this.dependsOnVariables==null) {
				dependsOnVariables = new LinkedHashSet<FVariable>();
				dependsOnVariables.addAll(independentVariables());
				for (AbstractEquationBlock eb : getPredecessors()) {
					dependsOnVariables.addAll(eb.dependsOn());
				}
			}
			return dependsOnVariables;
		}
				
		public boolean isMixed() {
			for (FAbstractEquation e : equations()) {
				if (e.isDiscrete()) {
					return true;
				}	
			}	
			return false;
		}
		
		public Collection<FAbstractEquation> differentiatedEquations() {
			java.util.List<FAbstractEquation> diffedEq = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation e : equations()) {
				if (e.getMeIntegrated()!=null) {
					diffedEq.add(e);
				}
			}
			return diffedEq;
		}

		public Collection<AbstractEquationBlock> getAllPredecessors() {
			if (allPredecessors == null) {
				allPredecessors = new LinkedHashSet<AbstractEquationBlock>(); 
				for (AbstractEquationBlock eb : getPredecessors()) {
					allPredecessors.addAll(eb.getAllPredecessors());
					allPredecessors.add(eb);
				}
			}
			return allPredecessors;
		}	
		
		public Set<AbstractEquationBlock> getPredecessors() {
			return predecessors;
		}	

		public Set<AbstractEquationBlock> getSuccessors() {
			return successors;
		}	
		
		public boolean isPredecessorsSet() {
			return predecessorsSet;
		}
	
		public int depth() {
			int max_predecessor_depth = -1;
			for (AbstractEquationBlock eb : getAllPredecessors()) {
				int d = eb.depth();
				if (d>max_predecessor_depth) {
					max_predecessor_depth = d;
				}
			}
			return max_predecessor_depth + 1;
		}
	
		public boolean isVisited() {
			return visited;
		}
		
		public void setVisited(boolean visited) {
			this.visited = visited;	
		}
		
		public void reset() {
			visited  = false;	
		}
		
		public boolean isSimple() {
			return false;
		}
		
		public final String toString() {
			ByteArrayOutputStream os = new ByteArrayOutputStream();
			prettyPrint(new NotNullPrintStream(os));
			return os.toString();
		}
		
		public abstract void prettyPrint(PrintStream str);
		
		public boolean mergeBlock(AbstractEquationBlock block) {
			return false;
		}
		
		protected void printIterationVariables(PrintStream str) {}
		
		protected void printTearingPairs(PrintStream str, int blockNumber) {}
		
	}

	/**
	 * EquationBlock is a general block that may contain one or more
	 * non-solved equations.
	 */
	public class EquationBlock extends AbstractEquationBlock {
		
		protected Collection<SimpleEquationBlock> blocks = new ArrayList<SimpleEquationBlock>();
		
		public EquationBlock(Collection<SimpleEquationBlock> blocks) {
			for (SimpleEquationBlock block : blocks)
				addBlock(block);
		}
				
		public void addBlock(SimpleEquationBlock b) {
			for (SimpleEquationBlock block : blocks)
				if (block.mergeBlock(b))
					return;
			if (!isLinear())
				b.checkStartValues();
			blocks.add(b);
		}	
		
		/**
		 * Returns true if the block is linear.
		 * 
		 * @return boolean True if linear
		 */
		public boolean isLinear() {
			return false;
		}
		
		@Override
		public Collection<FVariable> activeVariables() {
			Collection<FVariable> l = new ArrayList<FVariable>();
			for (SimpleEquationBlock sb : blocks)
				l.addAll(sb.activeVariables());
			return l;
		}		

		public Collection<SimpleEquationBlock> subBlocks() {
			return blocks;
		}

		public Collection<FAbstractEquation> equations() {
			Collection<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (SimpleEquationBlock sb : blocks)
				l.add(sb.equation());
			return l;
		}
		
		@Override
		public boolean isSolvable() {
			return false;	
		}
		
		public boolean containsDerivative() {
			for (FVariable fv : activeVariables())
				if (fv.isDerivativeVariable())
					return true;
			return false;
		}

		public void prettyPrint(PrintStream str) {
			str.println("Non-solved block of " + activeVariables().size() + " variables:");
			str.println("Unknown variables:");
			for (SimpleEquationBlock seb : blocks)
				seb.prettyPrintActiveVariables(str);
			str.println("Equations:");
			for (SimpleEquationBlock seb : blocks)
				seb.prettyPrintEquation(str);
		}
	
	}

	/**
	 * LinearEquationBlock is a system of equations that may contain one or more
	 * non-solved equations, all of wich are linear in the active variables.
	 */
	public class LinearEquationBlock extends EquationBlock {

		private FExp[][] jacobian;
		private FTypePrefixVariability blockVariability;

		public LinearEquationBlock(Collection<SimpleEquationBlock> blocks) {
			super(blocks);
			
			// Compute Jacobian
			jacobian = new FExp[equations().size()][equations().size()];
			int row = 0;
			int col = 0;
			blockVariability = ASTNode.fConstant();
			for (FAbstractEquation fe : equations()) {
				col = 0;
				for (FVariable fv : activeVariables()) {
					FExp l = ((FEquation)fe).getLeft();
					FExp r = ((FEquation)fe).getRight();
					FExp dl = l.dynamicFExp(l.diff(fv.name()));
					FExp dr = r.dynamicFExp(r.diff(fv.name()));
					boolean lz = dl.equalsRealValue(0);
					boolean rz = dr.equalsRealValue(0);
					FExp je;
					if (rz && lz) {
						je = r.dynamicFExp(new FRealLitExp(0.0));
					} else if (lz) {
						je = r.dynamicFExp(new FNegExp(dr));
					} else if (rz) {
						je = dl;
					} else {
						je = r.dynamicFExp(new FSubExp(dl,dr));
					}
					if (!je.variability().lessOrEqual(blockVariability)) {
						blockVariability = je.variability();
					}
					jacobian[row][col] = je;
					col++;
				}	
				row++;
			}
		}
		
		@Override
		public boolean isLinear() {
			return true;
		}
		
		public FTypePrefixVariability variability() {
			return blockVariability;	
		}
	
		public FExp[][] getJacobian() {
			return jacobian;	
		}

		public void prettyPrint(PrintStream str) {
			str.println("Non-solved linear block of " + activeVariables().size() + " variables:");
			str.println("Coefficient variability: " + variability().toStringLiteral());
			str.println("Unknown variables:");
			for (SimpleEquationBlock seb : blocks)
				seb.prettyPrintActiveVariables(str);
			str.println("Equations:");
			for (SimpleEquationBlock seb : blocks)
				seb.prettyPrintEquation(str);
			str.println("Jacobian:");
			for (int col=0;col<equations().size();col++) {
				str.print("  |");
				for (int row=0;row<equations().size();row++) {
					str.print(jacobian[col][row].prettyPrint(""));
					if (row<equations().size()-1) {
						str.print(", ");	
					}
				}
				str.println("|");
			}
		}


	}

	/**
	 * MixedEquationBlock is a general block that may contain 
	 * non-solved equations and which contains both continous
	 * and discrete equations.
	 */
	public class MixedEquationBlock extends EquationBlock {
		
		public MixedEquationBlock(Collection<SimpleEquationBlock> blocks) {
			super(blocks);
		}
		
		public Collection<FVariable> activeContinuousVariables() {
			Collection<FVariable> l = new ArrayList<FVariable>();
			for (FVariable fv : activeVariables())
				if (fv.isReal())
					l.add(fv);
			return l;
		}
		
		public Collection<FVariable> activeDiscreteVariables() {
			Collection<FVariable> l = new ArrayList<FVariable>();
			for (FVariable fv : activeVariables())
				if (!fv.isReal())
					l.add(fv);
			return l;
		}
		
		public Collection<FAbstractEquation> continuousEquations() {
			Collection<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (SimpleEquationBlock seb : continuousEquationBlocks())
				l.add(seb.equation());
			return l;
		}
		
		public Collection<FAbstractEquation> discreteEquations() {
			Collection<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (SimpleEquationBlock seb : discreteEquationBlocks())
				l.add(seb.equation());
			return l;
		}
		
		public Collection<SimpleEquationBlock> continuousEquationBlocks() {
			Collection<SimpleEquationBlock> l = new ArrayList<SimpleEquationBlock>();
			for (SimpleEquationBlock seb : blocks) {
				if (seb.equation().isReal())
					l.add(seb);
			}
			return l;
		}
		
		public Collection<SimpleEquationBlock> discreteEquationBlocks() {
			Collection<SimpleEquationBlock> l = new ArrayList<SimpleEquationBlock>();
			for (SimpleEquationBlock seb : blocks)
				if (!seb.equation().isReal())
					l.add(seb);
			return l;
		}
		
		public void prettyPrint(PrintStream str) {
			str.println("Mixed non-solved block of " + activeVariables().size() + " variables:");
			str.println("Unknown continuous variables:");
			for (SimpleEquationBlock seb : continuousEquationBlocks())
				seb.prettyPrintActiveVariables(str);
			str.println("Unknown discrete variables:");
			for (SimpleEquationBlock seb : discreteEquationBlocks())
				seb.prettyPrintActiveVariables(str);
			str.println("Continuous equations:");
			for (SimpleEquationBlock seb : continuousEquationBlocks())
				seb.prettyPrintEquation(str);
			str.println("Discrete equations:");
			for (SimpleEquationBlock seb : discreteEquationBlocks())
				seb.prettyPrintEquation(str);
		}
	}

	public class MixedLinearEquationBlock extends MixedEquationBlock {
		
		private FExp[][] jacobian;
		private FTypePrefixVariability blockVariability;

		public MixedLinearEquationBlock(Collection<SimpleEquationBlock> blocks) {
			super(blocks);
			jacobian = computeJacobian();
		}
		
		private FExp[][] computeJacobian() {
			FExp[][] jacobian = new FExp[continuousEquations().size()][activeContinuousVariables().size()];
			int row = 0;
			int col = 0;
			blockVariability = ASTNode.fConstant();
			for (FAbstractEquation fe : continuousEquations()) {
				col = 0;
				for (FVariable fv : activeContinuousVariables()) {
					FExp l = ((FEquation)fe).getLeft();
					FExp r = ((FEquation)fe).getRight();
					FExp dl = l.dynamicFExp(l.diff(fv.name()));
					FExp dr = r.dynamicFExp(r.diff(fv.name()));
					boolean lz = dl.equalsRealValue(0);
					boolean rz = dr.equalsRealValue(0);
					FExp je;
					if (rz && lz) {
						je = r.dynamicFExp(new FRealLitExp(0.0));
					} else if (lz) {
						je = r.dynamicFExp(new FNegExp(dr));
					} else if (rz) {
						je = dl;
					} else {
						je = r.dynamicFExp(new FSubExp(dl,dr));
					}
					if (!je.variability().lessOrEqual(blockVariability)) {
						blockVariability = je.variability();
					}
					jacobian[row][col] = je;
					col++;
				}	
				row++;
			}
			return jacobian;
		}
		
		@Override
		public boolean isLinear() {
			return true;
		}
		
		@Override
		public FTypePrefixVariability variability() {
			return blockVariability;	
		}
	
		public FExp[][] getJacobian() {
			return jacobian;	
		}

		public void prettyPrint(PrintStream str) {
			str.println("Non-solved mixed linear block of " + activeVariables().size() + " variables:\n");
			str.println("Coefficient variability: " + variability().toStringLiteral());
		
			Collection<SimpleEquationBlock> continuousEquationBlocks = continuousEquationBlocks();
			str.println("Unknown continuous variables:");
			for (SimpleEquationBlock seb : continuousEquationBlocks)
				seb.prettyPrintActiveVariables(str);
			str.println("Unknown discrete variables:");
			for (SimpleEquationBlock seb : discreteEquationBlocks())
				seb.prettyPrintActiveVariables(str);
			str.println("Continuous equations:");
			for (SimpleEquationBlock seb : continuousEquationBlocks)
				seb.prettyPrintEquation(str);
			str.println("Discrete equations:");
			for (SimpleEquationBlock seb : discreteEquationBlocks())
				seb.prettyPrintEquation(str);
			str.println("Jacobian:");
			for (int col=0;col<continuousEquationBlocks.size();col++) {
				str.print("  |");
				for (int row=0;row<continuousEquationBlocks.size();row++) {
					str.print(jacobian[col][row].prettyPrint(""));
					if (row<continuousEquationBlocks.size()-1) {
						str.print(", ");
					}
				}
				str.println("|");
			}
		}

		
		
	}
	
	/**
	 * SimpleEquationBlock is the base class of ScalarEquationBlock, FunctionCallEquationBlock
	 * AlgorithmBLock and WhenEquationBlock.
	 */
	public abstract class SimpleEquationBlock extends AbstractEquationBlock {
		private FAbstractEquation equation;
		
		public SimpleEquationBlock(FAbstractEquation equation) {
			this.equation = equation;
		}
		
		public FAbstractEquation equation() {
			return equation;
		}
		
		public Collection<FAbstractEquation> equations() {
			return Arrays.asList(equation());
		}
		
		public void prettyPrintActiveVariables(PrintStream str) {
			prettyPrintActiveVariables(str, false);
		}
		
		/**
		 * This method is call on blocks that are used in iterations. This
		 * method should check the start values of its variable and verify
		 * that a start value is set.
		 */
		public void checkStartValues() {}

		public void prettyPrintActiveVariables(PrintStream str, boolean printAttributes) {
			for (FVariable fv : activeVariables()) {
				str.print("  " + fv.name());
				if (printAttributes) {
					str.print("(");
					fv.printFAttributes(str, FAttribute.MIN, FAttribute.MAX, FAttribute.START, FAttribute.NOMINAL);
					str.print(")");
				}
				str.println();
			}
		}
		
		public void prettyPrintEquation(PrintStream str) {
			str.print("  " + equation());
			if (equation().hasNominal())
				str.print("    (Nominal=" + equation().getNominal().getValue() + ")");
			str.println();
		}
		
		
		public void prettyPrintIterationVariables(PrintStream str) {
			if (!isSolvable())
				doPrettyPrintIterationVariables(str);
		}
		
		public void doPrettyPrintIterationVariables(PrintStream str) {
			boolean first = true;
			for (FVariable var : activeVariables()) {
				if (first)
					str.print(" Iteration variables: ");
				else
					str.print("                      ");
				first = false;
				str.println(var.name());
			}
		}

		public boolean isSimple() {
			return true;
		}
		
	}
	
	/**
	 * An equation that does not affect the values of any variables. 
	 *
	 * Examples: asserts, calls to functions without outputs.
	 */
	public class MetaEquationBlock extends SimpleEquationBlock {

		public MetaEquationBlock(FFunctionCallEquation equation) {
			super(equation);
		}

		public Collection<FVariable> activeVariables() {
			return Collections.<FVariable>emptyList();
		}

		public boolean isSolvable() {
			return true;
		}

		@Override
		public FFunctionCallEquation equation() {
			return (FFunctionCallEquation) super.equation();
		}
		
		public void prettyPrint(PrintStream str) {
			str.println("Meta equation block:");
			str.println("Equation:");
			prettyPrintEquation(str);
		}
		
	}

	/**
	 * ScalarEquationBlock represents a scalar equation. Base class for
	 * SolvedScalarEquationBlock and UnsolvedScalarEquationBlock.
	 */
	public abstract class ScalarEquationBlock extends SimpleEquationBlock {
		protected FVariable fv;
		
		public ScalarEquationBlock(FEquation eqn, FVariable fv) {
			super(eqn);
			this.fv = fv;
		}
		
		public FEquation equation() {
			return (FEquation) super.equation();
		}
		
		public Collection<FVariable> activeVariables() {
			return Arrays.asList(fv);
		}
		
	}
	
	/**
	 * SolvedScalarEquationBlock represents a solved scalar equation. 
	 */
	public class SolvedScalarEquationBlock extends ScalarEquationBlock {

		public SolvedScalarEquationBlock(FEquation eqn, FVariable fv) {
			super(eqn, fv);
		}

		@Override
		public boolean isSolvable() {
			return true;
		}
		
		public FExp solution() {
			return equation().solution(fv.name());
		}
		
		@Override
		public void prettyPrint(PrintStream str) {
			str.println("Solved block of 1 variables:");
			str.println("Computed variable:");
			prettyPrintActiveVariables(str);
			str.println("Solution:");
			str.println("  " + solution());
		}
		
	}

	/**
	 * UnsolvedScalarEquationBlock represents a solved scalar equation. 
	 */
	public class UnsolvedScalarEquationBlock extends ScalarEquationBlock {
		
		public UnsolvedScalarEquationBlock(FEquation eqn, FVariable fv) {
			super(eqn, fv);
		}
		
		@Override
		public void checkStartValues() {
			fv.warnStartAttributeNotSet();
		}
		
		@Override
		public boolean isSolvable() {
			return false;
		}
		
		@Override
		public void prettyPrint(PrintStream str) {
			str.println("Non-solved block of 1 variables:");
			str.println("Unknown variables:");
			prettyPrintActiveVariables(str);
			str.println("Equations:");
			prettyPrintEquation(str);
		}

	}

	/**
	 * NumericallySolvedScalarEquationBlock represents a numerically solved scalar equation. 
	 */
	public class NumericallySolvedScalarEquationBlock extends ScalarEquationBlock {
		
		public NumericallySolvedScalarEquationBlock(FEquation eqn, FVariable fv) {
			super(eqn, fv);
		}

		@Override
		public void checkStartValues() {
			fv.warnStartAttributeNotSet();
		}
		
		@Override
		public boolean isSolvable() {
			return true;
		}

		@Override
		public void prettyPrintActiveVariables(PrintStream str, boolean printAttributes) {
			super.prettyPrintActiveVariables(str, true);
		}
		
		@Override
		public void prettyPrintIterationVariables(PrintStream str) {
			doPrettyPrintIterationVariables(str);
		}
		
		@Override
		public void prettyPrint(PrintStream str) {
			str.println("Numerically solved block of 1 variables:");
			str.println("Computed variable:");
			prettyPrintActiveVariables(str);
			str.println("Equations:");
			prettyPrintEquation(str);
		}
		
	}

	/**
	 * FunctionCallEquationBlock serves as a base class for SolvedFunctionCallEquationBlock
	 * and UnsolvedFunctionCallEquationBlock.
	 */
	public abstract class FunctionCallEquationBlock extends SimpleEquationBlock {
		
		protected Collection<FVariable> activeVars = new LinkedHashSet<FVariable>();
		protected Collection<Integer> assignedIndices = new ArrayList<Integer>();
		
		public FunctionCallEquationBlock(FFunctionCallEquation eqn, Collection<FVariable> activeVars, Collection<Integer> assignedIndices) {
			super(eqn);
			this.activeVars.addAll(activeVars);
			this.assignedIndices.addAll(assignedIndices);
		}
		
		public FFunctionCallEquation equation() {
			return (FFunctionCallEquation) super.equation();
		}
		
		public Collection<FVariable> activeVariables() {
			return new ArrayList<FVariable>(activeVars);
		}
		
		public boolean mergeBlock(AbstractEquationBlock block) {
			if (!(block instanceof FunctionCallEquationBlock))
				return false;
			
			FunctionCallEquationBlock fceb = (FunctionCallEquationBlock) block;
			
			if (equation() != fceb.equation())
				return false;
			
			activeVars.addAll(fceb.activeVars);
			assignedIndices.addAll(fceb.assignedIndices);
			return true;
		}
		
		public void prettyPrint(PrintStream str) {
			str.print(isSolvable() ? "Solved" : "Non-solved");
			str.println(" block of " + activeVariables().size() + " variables:");
			str.println("Unknown variables:");
			prettyPrintActiveVariables(str);
			str.println("Equations:");
			prettyPrintEquation(str);
		}
	}


	/**
	 * A solved function call equation.
	 */
	public class SolvedFunctionCallEquationBlock extends FunctionCallEquationBlock {
		
		public SolvedFunctionCallEquationBlock(FFunctionCallEquation eqn, Collection<FVariable> activeVariables, Collection<Integer> assignedIndices) {
			super(eqn, activeVariables, assignedIndices);
		}
		
		@Override
		public boolean isSolvable() {
			return true;
		}
		
	}

	/** 
	 * An unsolved function call equation
	 */
	public class UnsolvedFunctionCallEquationBlock extends FunctionCallEquationBlock {
		
		public UnsolvedFunctionCallEquationBlock(FFunctionCallEquation eqn, Collection<FVariable> activeVariables, Collection<Integer> assignedIndices) {
			super(eqn, activeVariables, assignedIndices);
		}
		
		@Override
		public void checkStartValues() {
			for (FVariable var : activeVars)
				var.warnStartAttributeNotSet();
		}
		

		@Override
		public boolean isSolvable() {
			return false;
		}

	}

	/**
	 * A when equation block.
	 */
	public class WhenEquationBlock extends SimpleEquationBlock {
		// One list of blocks for each when branch
		protected Collection<Collection<SimpleEquationBlock>> blocks = new ArrayList<Collection<SimpleEquationBlock>>(); 
		protected Collection<FVariable> fvars = new ArrayList<FVariable>();
				
		public WhenEquationBlock(FWhenEquation whenEquation) {
			super(whenEquation);
		
			blocks.add(new ArrayList<SimpleEquationBlock>());
			for (FAbstractEquation eqn : equation().getFAbstractEquations()) {
				Collection<FVariable> fvs = new ArrayList<FVariable>();
				Collection<Integer> assignedIndices = new ArrayList<Integer>();
				int i = 0;
				for (FIdUseExp e : eqn.simpleLefts()) {
					fvs.add((FVariable)e.myFV());
					assignedIndices.add(i++);
				}
				fvars.addAll(fvs);
				blocks.iterator().next().add(EquationBlockFactory.createSimpleEquationBlock(eqn, fvs, assignedIndices, true));
			}
			
			// TODO: handle else when clauses 
		}
		
		public boolean isSolvable() {
			boolean solvable = true;
			for (Collection<SimpleEquationBlock> c: blocks) {
				for (SimpleEquationBlock b: c) {
					solvable = solvable && b.isSolvable();
				}
			}
			return solvable;
		}
		
		public FWhenEquation equation() {
			return (FWhenEquation) super.equation();
		}
		
		public Collection<FVariable> activeVariables() {
			return new ArrayList<FVariable>(fvars);
		}
		
		public void prettyPrint(PrintStream str) {
			str.println("When equation block of " + activeVariables().size() + " variables:");
			str.println("Unknown variables:");
			prettyPrintActiveVariables(str);
			str.println("Equations:");
			prettyPrintEquation(str);
		}
		
	}

	/**
	 * Base class for blocks representing an algorithm block.
	 */
	public abstract class AlgorithmBlock extends SimpleEquationBlock {
		
		protected Collection<FVariable> activeVars;
		
		public AlgorithmBlock(FAlgorithm alg, Collection<FVariable> activeVariables) {
			super(alg);
			activeVars = activeVariables;
		}
	
		public FAlgorithm equation() {
			return (FAlgorithm) super.equation();
		}
		
		public Collection<FVariable> activeVariables() {
			return activeVars;
		}	
				
		public boolean isMixed() {
			return false;
		}
		
		public Collection<FAbstractEquation> differentiatedEquations() {
			return new ArrayList<FAbstractEquation>();
		}
		
		public void prettyPrint(PrintStream str) {
			String prefix = isSolvable() ? "Solved" : "Non-solved";
			str.format("%s algorithm block of %d variables:\n", prefix, activeVariables().size());
			str.println("Unknown variables:");
			prettyPrintActiveVariables(str);
			str.println("Algorithm:");
			prettyPrintEquation(str);
		}
		
	}

	/**
	 * An algorithm block that is solved in its active variables.
	 */
	public class SolvedAlgorithmBlock extends AlgorithmBlock {
		
		public SolvedAlgorithmBlock(FAlgorithm alg, Collection<FVariable> activeVariables) {
			super(alg, activeVariables);
		}
		
		public boolean isSolvable() {
			return true;
		}
		
	}

	/** 
	 * An algorithm block that isn't solved in its active variables.
	 */
	public class UnsolvedAlgorithmBlock extends AlgorithmBlock {
		
		public UnsolvedAlgorithmBlock(FAlgorithm alg, Collection<FVariable> activeVariables) {
			super(alg, activeVariables);
		}

		public boolean isSolvable() {
			return false;
		}

	}
	
	/**
	 * TornEquationBlock represents an equation block resulting from tearing.
	 */
	public class TornEquationBlock extends AbstractEquationBlock {
		private java.util.List<SimpleEquationBlock> solvedBlocks = new ArrayList<SimpleEquationBlock>();
		private java.util.List<SimpleEquationBlock> unsolvedBlocks = new ArrayList<SimpleEquationBlock>();
		
		public TornEquationBlock() {
		}
		
		public void addSolvedBlock(SimpleEquationBlock aeb) {
			if (!solvedBlocks.isEmpty() && solvedBlocks.get(solvedBlocks.size() - 1).mergeBlock(aeb))
				return;
			solvedBlocks.add(aeb);
		}
		
		public Collection<SimpleEquationBlock> getSolvedBlocks() {
			return solvedBlocks;
		}
		
		public void addUnsolvedBlock(SimpleEquationBlock aeb) {
			if (!unsolvedBlocks.isEmpty() && unsolvedBlocks.get(unsolvedBlocks.size() - 1).mergeBlock(aeb))
				return;
			aeb.checkStartValues();
			unsolvedBlocks.add(aeb);
		}
		
		public Collection<SimpleEquationBlock> getUnsolvedBlocks() {
			return unsolvedBlocks;
		}

		public Collection<FAbstractEquation> unsolvedEquations() {
			Collection<FAbstractEquation> eqs = new ArrayList<FAbstractEquation>();
			for (AbstractEquationBlock block : unsolvedBlocks) {
				eqs.addAll(block.equations());
			}
			return eqs;
		}

		public Collection<FAbstractEquation> solvedEquations() {
			Collection<FAbstractEquation> eqs = new ArrayList<FAbstractEquation>();
			for (AbstractEquationBlock block : solvedBlocks) {
				eqs.addAll(block.equations());
			}
			return eqs;
		}

		public Collection<FAbstractEquation> equations() {
			// Sort out any duplicated equations that has been introduced from records...
			// TODO: This should probably be handled in the compute_tearing() method..
			Collection<FAbstractEquation> s = new ArrayList<FAbstractEquation>();
			FAbstractEquation prev = null;
			for (FAbstractEquation e : solvedEquations()) {
				if (e != prev)
					s.add(e);
				prev = e;
			}
			for (FAbstractEquation e : unsolvedEquations()) {
				if (e != prev)
					s.add(e);
				prev = e;
			}
			return s;
		}

		public Collection<FVariable> activeVariables() {
			Collection<FVariable> vars = new ArrayList<FVariable>();
			for(AbstractEquationBlock block : solvedBlocks){
				vars.addAll(block.activeVariables());
			}
			for (AbstractEquationBlock block : unsolvedBlocks) {
				vars.addAll(block.activeVariables());
			}
			return vars;
		}	
		
		public Collection<FVariable> iterationVariables() {
			Collection<FVariable> vars = new ArrayList<FVariable>();
			for (AbstractEquationBlock block : unsolvedBlocks) {
				vars.addAll(block.activeVariables());
			}
			return vars;
		}
		
		public boolean isSolvable() {
			return false;
		}			
		
		public void prettyPrint(PrintStream str) {
			Collection<FVariable> iterationVars = iterationVariables();
			Collection<FVariable> solvedVars = activeVariables();
			solvedVars.removeAll(iterationVars);
			str.println("Torn block of " + iterationVars.size() + " iteration variables" +
					" and " + solvedVars.size() + " solved variables.");
			str.println("Solved variables:");
			for (SimpleEquationBlock seb : solvedBlocks)
				seb.prettyPrintActiveVariables(str);
			str.println("Iteration variables:");
			for (SimpleEquationBlock seb : unsolvedBlocks)
				seb.prettyPrintActiveVariables(str, true);
			str.println("Solved equations:");
			for (SimpleEquationBlock seb : solvedBlocks) {
				seb.prettyPrintIterationVariables(str);
				seb.prettyPrintEquation(str);
			}
			str.println("Residual equations:");
			for (SimpleEquationBlock seb : unsolvedBlocks) {
				seb.prettyPrintIterationVariables(str);
				seb.prettyPrintEquation(str);
			}
		}
	
		protected void printIterationVariables(PrintStream str) {
			for (AbstractEquationBlock block : unsolvedBlocks)
				for (FVariable var : block.activeVariables())
					str.println(var.name());
		}
		
		protected void printTearingPairs(PrintStream str, int blockNumber) {
			int counter = 0;
			str.println("In block #" + blockNumber);
			for (SimpleEquationBlock block : unsolvedBlocks) {
				boolean equationHasHGT = block.equation().hasResidual();
				FVariable iterVar = (equationHasHGT) ? block.equation().getResidual().iterationVariable() : null;
				for (FVariable var : block.activeVariables()) {
					boolean variableHasHGT = var.getHGTType() == FClass.HGTVariableType.COMPONENT || var == iterVar;
					str.print(" (");
					str.print(variableHasHGT ? 'M' : 'A');
					str.print(") " + (counter++) + " " + var.name() + " (");
					var.printFAttributes(str, FAttribute.MIN, FAttribute.MAX, FAttribute.START, FAttribute.NOMINAL);
					str.println(")");
					str.print("   (");
					str.print(equationHasHGT ? 'M' : 'A');
					str.print(") " + block.equation().toString()); 
					if (block.equation().hasNominal())
						str.print("    (Nominal=" + block.equation().getNominal().getValue() + ")");
					str.println();
				}
				str.println();
			}
			str.println();
		}
		
	}

	syn lazy Set<FVariable> FVariable.dependsOn() {
		if (myDAEEquationBlock() != null)
			return myDAEEquationBlock().dependsOn();
		else
			return new LinkedHashSet<FVariable>();
	}

	syn lazy AbstractEquationBlock FVariable.myDAEEquationBlock() = 
		myFClass().getDAEFVariableEquationBlockMap().get(this);

	private HashMap<FVariable,AbstractEquationBlock> FClass.daeFVariableEquationBlockMap = null;
	syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEFVariableEquationBlockMap() {
		if (daeFVariableEquationBlockMap == null) 
			computeMatchingsAndBLT();
		return daeFVariableEquationBlockMap;
	}

	syn lazy AbstractEquationBlock FVariable.myDAEInitEquationBlock() = 
		myFClass().getDAEInitFVariableEquationBlockMap().get(this);
	
	private HashMap<FVariable,AbstractEquationBlock> FClass.daeInitFVariableEquationBlockMap = null;	
	syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEInitFVariableEquationBlockMap() {
		if (daeInitFVariableEquationBlockMap == null) 
			computeMatchingsAndBLT();
		return daeInitFVariableEquationBlockMap;
	}

	private ArrayList<FAbstractEquation> FClass.daeUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEUnmatchedEquations() { 
		if (daeUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedVariables;
	}	

	private ArrayList<FAbstractEquation> FClass.daeInitUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEInitUnmatchedEquations() { 
		if (daeInitUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeInitUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEInitUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedVariables;
	}	

	private BLT FClass.daeBLT = null;
	syn BLT FClass.getDAEBLT() {
		if (daeBLT == null) 
			computeMatchingsAndBLT();
		return daeBLT;
	}

	private StructuredBLT FClass.daeStructuredBLT = null;
	syn StructuredBLT FClass.getDAEStructuredBLT() {
		if (daeStructuredBLT == null) 
			computeMatchingsAndBLT();
		return daeStructuredBLT;
	}
	
	private BLT FClass.daeInitBLT = null;	
	syn BLT FClass.getDAEInitBLT() {
		if (daeInitBLT == null) 
			computeMatchingsAndBLT();
		return daeInitBLT;
	}	
	
	/**
	 * The symbolic equation sorting and canonicalization proceeds in the
	 * following steps:
	 * 
	 * - The DAE system consisting of the DAE equations with algebraics and
	 *   derivatives treated as unknowns is matched to obtain a pairing
	 *   between equations and variables. Discrete and continuous algebraic
	 *   variables are treated equally in this respect.
	 *
	 * - If a perfect matching is found, i.e., if there are no unmatched
	 *   equations or variables, the BLT algoritm is applied to compute
	 *   a sequence of stron components, corresponding to systems of equations.
	 * 
	 * - Having computed a matching and transformed the DAE into BLT form, 
	 *   the DAE initialization system is analyzed:
	 *    - The differentiated variables are added to the set of unknown 
	 *      variables of the system.
	 *    - The pre variables are added to the set of unknown variables of the
	 *      system.
	 *    - The initial equations are added to the set of equations of the 
	 *      system. This includes equations resulting from start values with
	 *      a corresonding fixed attribute set to true.
	 *    - When clauses are analyzed: if a when clause is explicitly enabled by
	 *      the initial() operator (whatever this means...), the when clause 
	 *      is excluded, otherwhise the equation pre(x) = x is added, where x 
	 *      is the variable that is solved for in the when clause.
	 *      
	 * - The matching algoritm is applied to the updated graph. Notice that it
	 *   is important that the result of the DAE matching is used as a starting
	 *   point: using this approach, derivatives and algebraics will remain
	 *   matched if possible and additional equations are added, if needed,
	 *   for differentiated variables. If there are 
	 *   unmatched equations, the transformation sequence terminates. If there
	 *   are unmatched variables, then additional initial equations are added 
	 *   in order to obtained a balanced system. For continuous variables, 
	 *   equations such as x = x.start are added, whereas for discrete variables
	 *   equations such as pre(x) = x.start are added.
	 *
	 *  - Finally, the BLT algorithm is applied to the resulting perfect
	 *    matchibng for the DAE initialization system.
     */	
	public void FClass.computeMatchingsAndBLT() {
		beginStep("computeMatchingsAndBLT()");
		computeMatchingsAndBLTWrapped();
		endStep("computeMatchingsAndBLT()");
	}
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_NORMAL = 
			EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
					   BiPGraph.VarType.ALGEBRAIC_VARIABLES);
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_REAL = 
			EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
					   BiPGraph.VarType.CONTINUOUS_ALGEBRAIC_VARIABLES);
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_INIT = 
			EnumSet.of(BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
					   BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
					   BiPGraph.VarType.NON_FIXED_PARAMETERS);
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_ALL = 
			EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
					   BiPGraph.VarType.ALGEBRAIC_VARIABLES, 
					   BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
					   BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
					   BiPGraph.VarType.NON_FIXED_PARAMETERS);
	
	private void FClass.computeMatchingsAndBLTWrapped() {
        log.info("Flat tree before index reduction and BLT:");
		log.info(this);

		daeBLT = new BLT();
		daeStructuredBLT = new StructuredBLT(this);
		daeInitBLT = new BLT();		
		daeUnmatchedEquations = new ArrayList<FAbstractEquation>();
		daeUnmatchedVariables = new ArrayList<FVariable>();
		daeInitUnmatchedEquations = new ArrayList<FAbstractEquation>();
		daeInitUnmatchedVariables = new ArrayList<FVariable>();
		daeFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();
		daeInitFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();
			
		BiPGraph g = new BiPGraph();
		
		Eq eqn = null;
		Var v = null;		
		
		// First try a global matching with all variables
		g.addVariables(this, VAR_TYPES_NORMAL);
		g.addEquations(equations(), VAR_TYPES_NORMAL,"eq_",1);
		
		log.info(g);
		g.maximumMatching(true);
		log.info("DAE system");
		log.info(g.printMatchingObj());
			
		for (Var var : g.getUnmatchedVariables()) {
			daeUnmatchedVariables.add(var.getVariable());
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeUnmatchedEquations.add(ee.getEquation());
		}
	
		// If no complete matching found, then try index reduction
		if (!g.isComplete()) {
			g = reduceIndex();
			breakOnErrors();
			if (g == null)
				return;
		} 
			
		// Perform BLT
		if (root().options.getBooleanOption("equation_sorting") && g.isComplete()) {	
			
			if (root().options.getBooleanOption("automatic_tearing") || root().options.getBooleanOption("hand_guided_tearing")) {
				try {
					daeBLT = computeTearings(g);
				} catch (TearingException e) {
					return;
				}
			} else {
				daeBLT = g.computeBLT();
			}
			for (AbstractEquationBlock eb : daeBLT) {
				for (FVariable fv : eb.activeVariables()) {
					daeFVariableEquationBlockMap.put(fv,eb);
				}
			}
			for (FAbstractEquation e : equations())
				if (e.numScalarEquations() == 0)
					daeBLT.add(e.createSimpleEquationBlock(Collections.<FVariable>emptyList(), null, Solvability.ANALYTICALLY_SOLVABLE));
			daeStructuredBLT = new StructuredBLT(this, daeBLT);
			log.info(daeStructuredBLT);
			
			log.info(daeBLT);
		
		}
						
		// Find matching for the initialization system	
		g.addVariables(this, VAR_TYPES_INIT);
		g.addEquations(equations(), VAR_TYPES_INIT, "eq_",1);

	    // Replace when equations	
		java.util.List<FAbstractEquation> equationsToReplace = new ArrayList<FAbstractEquation>();
		for (FAbstractEquation e : equations()) {
			if (e.replacedAtInitialization()) {
				equationsToReplace.add(e);
			}
		}		
		
		// Loop over all equations to replace
		for (FAbstractEquation equationToReplace : equationsToReplace) {
						
			// How many equations are there in this when clause?
			List<FAbstractEquation> newEquations = equationToReplace.getInitialEquations();
		
		    // Put the Equations in an ArrayList rather than a List
		    // TODO: There are probably more elegant ways to do this...
			java.util.List<FAbstractEquation> newEquations_ = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation e : newEquations) {
				newEquations_.add(e);	
			}

			 // - equationToReplace is an FAbstractEquation that should be replaced
			 // - newEquations contains the new equations that replaces the equationToReplace
			 // - Note that newEquations may contain several equations  
			 
			java.util.List<Eq> eq_list = new ArrayList<Eq>(g.getEquations(equationToReplace));
			
			for (Eq eqq : eq_list) {
				g.removeEquation(eqq);	
			}
			
			if (!eq_list.isEmpty())
				g.addEquations(newEquations_, VAR_TYPES_ALL, eq_list.get(0).getName() + "_", 1);
		}		
	
		log.info(g);
		

		g.addEquations(initialEquations(), VAR_TYPES_ALL, "eq_", g.getEquations().size() + 1);

		log.info(g);
		g.maximumMatching(false);	
		log.info("DAE initial ");
		log.info(g.printMatchingObj());

		if (g.getUnmatchedEquations().size() > 0) {
			return;
		}

		// Add initial equations if needed
		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			for (Var var : g.getUnmatchedVariables()) {	
				FVariable fv = var.getVariable();
				FExp lhs = new FIdUseExp(new FIdUse(fv.getFQName().fullCopy()));
				FExp rhs = fv.startAttributeSet() ? fv.startAttributeExp() : fv.type().zeroLiteral();
				if (fv.isDiscrete()) {
					fv = (FVariable) fv.myPreVariable();
					lhs = new FPreExp(lhs);
				}
				FEquation fe = new FEquation(lhs, rhs);
				addFInitialEquation(fe);
				
				eqn = g.addEquation("eq_" + (g.getEquations().size() + 1), fe, 0);
				v = g.getVariable(fv.name());
				g.addEdge(eqn,v);
			}
			root().flushAllRecursive();

			g.maximumMatching(false);	
			log.info("DAE initial after addition of initial equations");
			log.info(g);
			log.info(g.printMatchingObj());

		}

		for (Var var : g.getUnmatchedVariables()) {
			daeInitUnmatchedVariables.add(var.getVariable());
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeInitUnmatchedEquations.add(ee.getEquation());
		}

		// TODO: If no complete matching found, then try index reduction
		if (!g.isComplete()) {
			return;
		}
				
		if (root().options.getBooleanOption("equation_sorting") && g.isComplete()) {
			g.tarjanReset();
			if (root().options.getBooleanOption("automatic_tearing") || root().options.getBooleanOption("hand_guided_tearing")){
				try {
					daeInitBLT = computeTearings(g);
				} catch (TearingException e) {
					return;
				}
			}else{
				daeInitBLT = g.computeBLT();
			}
			for (AbstractEquationBlock eb : daeInitBLT) {
				for (FVariable fv : eb.activeVariables()) {
					daeInitFVariableEquationBlockMap.put(fv,eb);
				}
			}	
			log.info(daeInitBLT);
		}
	}	
	//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
	
	/**
	 * Perform index reduction on model.
	 * 
	 * @return  the new graph
	 */
	private BiPGraph FClass.reduceIndex() {
		if (root().options.getBooleanOption("index_reduction")) {
			// Only do index reduction based on real variables and equations
			BiPGraph g = new BiPGraph();
			g.addVariables(this, VAR_TYPES_REAL);
			g.addEquations(continuousEquations(), VAR_TYPES_REAL, "eq_", 1);
			log.info("Index reduction starts");
			log.info(g);
			g.maximumMatching(true);	
			log.info("DAE system real variables only");
			log.info(g.printMatchingObj());
			
			String errMsg = "Index reduction failed";
	
			IndexReductionResult result = null;
			try {
				result = g.reduceIndex(false);
			} catch (EquationDifferentiationException e) {
			    errMsg = e.getMessage();
			}
			
			if (result != null) {
				// Add the new equations
				// Replace selected dummy derivatives with algebraics
				// Enable rewrite of identifiers? (not necessary?)
				for (FAbstractEquation fe : result.getEquations()) {
					addFEquation((FAbstractEquation)fe.fullCopy());
				}
				
				Collection<FVariable> l = new ArrayList<FVariable>();
				
				for (FVariable fv : getFVariables()) {
					if (result.getDummyDerivatives().contains(fv)) {
						if (fv instanceof FHDerivativeVariable) {
							FHDummyDerivativeVariable fdv = new FHDummyDerivativeVariable(fv.getFVisibilityType().fullCopy(),
								fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy(),
								((FHDerivativeVariable)fv).getOrder());
							l.add(fdv);
						} else if (fv instanceof FDerivativeVariable) {
							FDummyDerivativeVariable fdv = new FDummyDerivativeVariable(fv.getFVisibilityType().fullCopy(),
								fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy());
							l.add(fdv);
						} else {
							l.add(fv);
						}
					} else if (fv instanceof FDerivativeVariable &&
							((FRealVariable)fv.getMeIntegrated()).stateSelectAttribute() == FRealVariable.StateSelect.NEVER) {
						FDummyDerivativeVariable fdv = new FDummyDerivativeVariable(fv.getFVisibilityType().fullCopy(),
								fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy());
						l.add(fdv);
					} else if (fv instanceof FHDerivativeVariable) {
						// Convert higher order derivative variables into
						// first order derivatives, generating variables for each step
						FHDerivativeVariable fhdv = (FHDerivativeVariable) fv;
						FQName fqnPrev = fv.getFQName().fullCopy();
						for (int i = 1; i < fhdv.getOrder(); i++) {
							FQName fqn = fv.getFQName().createDerPrefixedName(i);
							l.add(new FRealVariable(fv.getFVisibilityType().fullCopy(),
								fv.getFTypePrefixVariability().fullCopy(), fqn.fullCopy()));
							l.add(new FDerivativeVariable(fv.getFVisibilityType().fullCopy(),
								fv.getFTypePrefixVariability().fullCopy(), fqn.fullCopy()));
							addFEquation(new FEquation(new FIdUseExp(fqn), new FDerExp(fqnPrev.fullCopy())));
							fqnPrev = fqn;
						}
					} else {
						l.add(fv);
					}
				}
	
				setFVariableList(new List<FVariable>(l));
	
				enableFHDerRewrite();
	
				// flushAllRecursiveClearFinal must be used here in order to
				// trigger rewrites of FDerExp -> FDummyDerExp
				root().flushAllRecursiveClearFinal();
	
				aliasEliminationIfSet();
	
				root().flushAllRecursive();
	
				//System.out.println(prettyPrint(""));
	
				//dumpTree("");
	
				log.info("States:");
				for (FVariable fv : differentiatedRealVariables()) {
					log.info(new PrettyPrintDelegate(fv, "  "));
				}
    			
				// Calculate new graph
    			g = new BiPGraph();
    			g.addVariables(this, VAR_TYPES_NORMAL);
    			g.addEquations(equations(), VAR_TYPES_NORMAL, "eq_", 1);
    	
    			log.info(g);
    			g.maximumMatching(true);	
    			log.info("DAE system ");
    			log.info(g.printMatchingObj());
    
    			if (g.isComplete()) {
    	            daeUnmatchedVariables.clear();
    	            daeUnmatchedEquations.clear();
    			    return g;
    			}
			}
			
			// If we get here, index reduction failed
            error(errMsg);
		}
		
		// If we get here, generate an error for singular equation system
        checkStructure();
        return null;
	}

	
	private static String FQName.derPrefixString = "_der_der_der_der";
	
	/**
	 * Create a new FQName that is a copy of this one, prefixed with "_der" <code>order</code> times in the last name part.
	 */
	public FQName FQName.createDerPrefixedName(int order) {
		FQName pref = copyPrefix();
		while (4 * order >= derPrefixString.length())
			derPrefixString = derPrefixString + derPrefixString;
		String name = derPrefixString.substring(0, 4 * order + 1) + lastActualPartName();
		if (hasFArraySubscripts())
			return pref.copyAndAppend(name, getFArraySubscripts().fullCopy());
		else
			return pref.copyAndAppend(name);
	}


	public BLT FClass.computeTearings(BiPGraph graph) throws TearingException {
		beginStep("computeTearings()");
		try {
			Collection<Collection<Eq>> blt = graph.computeRawBLT(root().options.getBooleanOption("merge_blt_blocks"));
			log.info("Computing tearing for %d BLT blocks...", blt.size());
			BLT tearBLT = new BLT();
			for (Collection<Eq> block : blt) { // Iterate over all (global) BLT-blocks
				SimpleEquationBlock seb = EquationBlockFactory.createSimpleEquationBlock(block, true);
				if (seb != null && seb.isSolvable()) {
					if (seb.equation().hasResidual() && seb.equation().getResidual().hasIterationVariable())
						seb.equation().getResidual().warning("Can not use hand guided tearing pair, equation and variable resides in solved block. Variable: " + seb.equation().getResidual().getIterationVariable().name() + ". Equation: " + seb.equation());
					log.info("Found solved block");
					tearBLT.add(seb);
				} else if (seb != null && block.size() == 1) {
					log.info("Found simple unsolved block");
					tearBLT.add(seb);
				} else {
					log.info("Found tearing block, tearing...");
					TornEquationBlock eb = new TornEquationBlock();
					tearBLT.add(eb);
					tearHandGuided(block, eb, tearBLT.size());
				}
			}
			log.info("Done with tearing");
			return tearBLT;
		} finally {
			endStep("computeTearings()");
		}
	}
	
	private void FClass.tearHandGuided(Collection<Eq> block, TornEquationBlock eb, int blockNum) throws TearingException {
		boolean recalculateMatchings = false;
		Map<FVariable, Var> varsInBlock = new LinkedHashMap<FVariable, Var>();
		for (Eq e : block) {
			varsInBlock.put(e.getMatching().getVariable(), e.getMatching());
		}
		Iterator<Eq> it = block.iterator();
		Collection<Eq> unmatchedHGTEquations = new ArrayList<Eq>();
		Collection<Var> unmatchedHGTVariables = new ArrayList<Var>();
		for (Eq eqn : block) {
			if (eqn.getEquation().hasResidual() && !eqn.getEquation().getResidual().hasIterationVariable())
				unmatchedHGTEquations.add(eqn);
		}
		for (Var var : varsInBlock.values()) {
			if (var.getVariable().getHGTType() == HGTVariableType.COMPONENT)
				unmatchedHGTVariables.add(var);
		}
		if (unmatchedHGTEquations.size() == unmatchedHGTVariables.size()) {
			Iterator<Eq> eqnIt = unmatchedHGTEquations.iterator();
			Iterator<Var> varIt = unmatchedHGTVariables.iterator();
			while (eqnIt.hasNext() && varIt.hasNext()) {
				Eq eqn = eqnIt.next();
				Var var = varIt.next();
				eqn.getEquation().getResidual().setIterationVariable(new FIdUse(var.getName()));
				var.getVariable().setHGTType(HGTVariableType.PAIR);
			}
		} else {
			StringBuilder sb = new StringBuilder();
			sb.append("Unable to apply hand-guided tearing selections on block " + blockNum + ". The number of unmatched hand guided equations and variables are not equal.\n");
			sb.append("  Unmatched hand guided equations(" + unmatchedHGTEquations.size() + "):\n");
			for (Eq eqn : unmatchedHGTEquations)
				sb.append("    " + eqn.getEquation() + "\n");
			sb.append("\n");
			sb.append("  Unmatched hand guided variables(" + unmatchedHGTVariables.size() + "):\n");
			for (Var var : unmatchedHGTVariables)
				sb.append("    " + var.getName() + "\n");
			error(sb.toString());
			throw new TearingException();
		}
		while (it.hasNext()) {
			Eq e = it.next();
			if (e.getEquation().hasResidual() && e.getEquation().getResidual().hasIterationVariable()) {
				FVariable fIterVar = e.getEquation().getResidual().iterationVariable();
				Var iterVar = varsInBlock.get(fIterVar);
				if (iterVar == null) {
					e.getEquation().getResidual().warning("Can not use hand guided tearing pair, equation and variable resides in different blocks. Variable: " + fIterVar.name() + ". Equation: " + e.getEquation());
					continue;
				}
				it.remove();
				varsInBlock.remove(fIterVar);
				recalculateMatchings = true;
				log.info("Hand guided tearing pair, equation: %s, tearing with variable: %s", e.getEquation(), iterVar.getVariable().name());
				eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(e, iterVar));
			}
		}
		if (recalculateMatchings) {
			BiPGraph newGraph = new BiPGraph(block, varsInBlock.values());
			newGraph.maximumMatching(true);
			Collection<Eq> unmatchedEquations = newGraph.getUnmatchedEquations();
			Collection<Var> unmatchedVariables = newGraph.getUnmatchedVariables();
			if (unmatchedEquations.size() > 0 || unmatchedVariables.size() > 0) {
				log.info("Unmatched equations and variables in block after hand guided, adding them as tearing pairs!");
				Iterator<Eq> eIt = unmatchedEquations.iterator();
				Iterator<Var> vIt = unmatchedVariables.iterator();
				while (eIt.hasNext() && vIt.hasNext()) {
					Eq e = eIt.next();
					Var v = vIt.next();
					log.info("Unmatched tearing pair, equation: %s, tearing with variable: %s", e.getEquation(), v.getVariable().name());
					newGraph.removeEquation(e);
					newGraph.removeVariable(v);
					eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(e, v));
				}
				if (eIt.hasNext() || vIt.hasNext()) {
					StringBuilder sb = new StringBuilder();
					sb.append("Hand guided tearing selections in block " + blockNum + " results in a structurally singular block.\n");
					if (eIt.hasNext()) {
						sb.append("  The follwowing equation(s) could not be matched to any variable:\n");
							while (eIt.hasNext())
								sb.append("    " + eIt.next().getEquation());
					}
					if (vIt.hasNext()) {
						sb.append("  The following varible(s) could not be matched to any equation:\n");
						while (vIt.hasNext())
							sb.append("    " + vIt.next().getVariable().name());
					}
					error(sb.toString());
					throw new TearingException();
				}
			}
			Collection<Collection<Eq>> innerBLT = newGraph.computeRawBLT(false);
			boolean allInnerAreSolved = true;
			Collection<SimpleEquationBlock> solvedBlocks = new ArrayList<SimpleEquationBlock>();
			for (Collection<Eq> innerBlock : innerBLT) {
				SimpleEquationBlock seb = EquationBlockFactory.createSimpleEquationBlock(innerBlock, true, true);
				if (seb != null && seb.isSolvable()) {
					solvedBlocks.add(seb);
				} else {
					allInnerAreSolved = false;
					break;
				}
			}
			if (allInnerAreSolved) {
				log.info("Remaining system is solvable.");
				for (SimpleEquationBlock seb : solvedBlocks)
					eb.addSolvedBlock(seb);
				return;
			} else if (!root().options.getBooleanOption("automatic_tearing")) {
				error("Hand guided tearing selections in block " + blockNum + " does not result in a torn system. Consider adding additional selections of hand guided equations and variables, or enable automatic tearing.");
				throw new TearingException();
			}
			block = new ArrayList<Eq>();
			block.addAll(newGraph.getEquations());
			log.info("Additional tearing is needed, continuing with automatic tearing.");
		}
		tear(block, eb);
	}
	
	private void FClass.tear(Collection<Eq> block, TornEquationBlock eb) {
		SolvingBiPGraph g = new SolvingBiPGraph(block);
		
		// Obtain Maximum Solvable Matching in two steps (greedy and augmenting paths)
		Collection<Eq> SUME = g.greedyMatching();
		Iterator<Eq> itr = SUME.iterator();
		while (itr.hasNext()) {
			Eq e = itr.next();
			if (g.augmentPath(e)) {
				itr.remove();
			} else {
				e.isRes(true);
			}
			g.lightReset();
		}

		// Now we have a Maximum Solvable Matching

		if (SUME.isEmpty()) { // If: there exist a Pefect Solvable Matching
								//     proceed with recursive tearing of block
			SimpleEquationBlock tearBlock = EquationBlockFactory.createSimpleEquationBlock(block, true, true);
			if (tearBlock != null && tearBlock.isSolvable()) {
				eb.addSolvedBlock(tearBlock);
			} else {
				tearInner(g, eb);
			}
		} else {
			// Else: Start out by trying to insert residuals that contain
			// 		 few variables. 
			java.util.List<Eq> residuals = new ArrayList<Eq>();
			for (Eq e : SUME) {
				Eq bestRes = e;
				for (Var v : e.getSolvableVariables()) {
					Eq ee = v.getMatching();
					if (ee.compareTo(bestRes) > 0)
						bestRes = ee;
				}
				if (bestRes != e) {
					bestRes.isRes(true);
					g.match(e, bestRes.getMatching());
					e.isRes(false);
					residuals.add(bestRes);
				} else {
					residuals.add(e);
				}
			}

			// Compute inner BLT and see if tearings can be changed 
			Set<Var> SUMV = new LinkedHashSet<Var>(g.getUnmatchedVariables());
			Collection<Collection<Eq>> innerBlocks = g.computeRawBLT(false);
			java.util.List<Var> tearings = new ArrayList<Var>();

			for (Collection<Eq> bInner : innerBlocks) {
				SimpleEquationBlock tearBlock = EquationBlockFactory.createSimpleEquationBlock(bInner, true, true);
				if (tearBlock != null && tearBlock.isSolvable()) {
					eb.addSolvedBlock(tearBlock);
					// If the equation contains a Var in SUMV, that Var cannot be
					// reinserted and must be used as a iteration variable.
					for (Eq e : bInner) {
						for (Var vv : e.getVariables()) {
							if (SUMV.remove(vv))
								tearings.add(vv);
						}
					}
				} else {
					// Build Inner Graph and add info about iteration variables
					SolvingBiPGraph gInner = new SolvingBiPGraph(bInner);
					// Build block-graph and look for interchangeable variables in SUMV
					java.util.List<Eq> eqs = new ArrayList<Eq>();
					boolean graphHasTear = false;
					for (Eq e : bInner) {
						Eq gInnerEq = gInner.getEquation(e.getName());
						for (Var v : e.getVariables()) {
							Var gInnerVar = gInner.getVariable(v.getName());
							if (gInnerVar != null) {
								if (gInner.canMatch(gInnerEq, gInnerVar) && gInnerVar.isIter() && !eqs.contains(gInnerEq)) {
									eqs.add(gInnerEq);
								}
							} else if (SUMV.contains(v)) {
								gInnerVar = gInner.addVariable(v.getName(), v.getVariable());
								gInnerVar.isIter(true);
								SUMV.remove(v);
								tearings.add(v);
								graphHasTear = true;
								gInner.addInsidence(gInnerEq, gInnerVar);
								if (gInner.canMatch(gInnerEq, gInnerVar) && !eqs.contains(gInnerEq)) {
									eqs.add(gInnerEq);
								}
							}
						}
					}
					// Go through equations that might get a new matching
					boolean isChanged = false;
					for (Eq e : eqs) {
						Var bestMatch = e.getMatching();
						for (Var v : e.getSolvableVariables()) {
							if (v.isIter() && v.compareTo(bestMatch) < 0)
								bestMatch = v;
						}
						if (bestMatch != e.getMatching()) {
							Var tmp = e.getMatching();
							tmp.isIter(true);
							bestMatch.isIter(false);
							tearings.add(tmp);
							tearings.remove(bestMatch);
							gInner.match(e, bestMatch);
							isChanged = true;
						}
					}

					if (graphHasTear) {
						if (isChanged) {
							Collection<Collection<Eq>> newBlocks = gInner.computeRawBLT(false);
							for (Collection<Eq> bInnerInner : newBlocks) {
								tearBlock = EquationBlockFactory.createSimpleEquationBlock(bInnerInner, true, true);
								if (tearBlock != null && tearBlock.isSolvable()) {
									eb.addSolvedBlock(tearBlock);
								} else {
									tearInner(new SolvingBiPGraph(bInnerInner), eb);
								}
							}
						} else {
							tearInner(new SolvingBiPGraph(bInner), eb);
						}
					} else {
						// Reuse the already constructed graph
						tearInner(gInner, eb);
					}
				}
			}
			for (Var v : SUMV) {
				//SUMV ought to be empty, but there might exist variables that hasn't 
				// been altered before. 
				tearings.add(v);
			}
			for (int i = 0; i < tearings.size(); i++) {
				log.info("Automatic tearing pair, equation: %s, tearing with variable: %s", residuals.get(i).getEquation(), tearings.get(i).getName());
				eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(residuals.get(i), tearings.get(i)));
			}
		}
	}	

	
	private TornEquationBlock FClass.tearInner(SolvingBiPGraph g, TornEquationBlock eb){
		Var bestIter = null;
		for (Eq e : g.getEquations()) {
			Var v = e.getMatching();
			if (bestIter == null || v.compareTo(bestIter) > 0)
				bestIter = v;
		}
		Eq res = bestIter.getMatching();
		bestIter.isIter(true);
		res.isRes(true);
		log.info("Automatic tearing pair, equation: %s, tearing with variable: %s", res.getEquation(), bestIter.getVariable().name());
		eb.addUnsolvedBlock(EquationBlockFactory.createSimpleEquationBlock(res, bestIter));
		Collection<Collection<Eq>> blt = g.computeRawBLT(false);
		for (Collection<Eq> block : blt) {
			SimpleEquationBlock tearBlock = EquationBlockFactory.createSimpleEquationBlock(block, true, true);
			if (tearBlock != null && tearBlock.isSolvable()) {
				eb.addSolvedBlock(tearBlock);
			} else {
				tearInner(new SolvingBiPGraph(block), eb);
			}
		}
		return eb;
	}
	
	public class TearingException extends ModelicaException {
	}
	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////			
	
	public void FClass.checkStructure() {
		if (root().options.getBooleanOption("enable_structural_diagnosis")) {
			boolean unbalanced = false;
			StringBuffer err_str = new StringBuffer("The system is structurally singular. ");
			if (getDAEUnmatchedVariables().size() > 0 ) {
				err_str.append("The following varible(s) could not be matched to any equation:\n");
				for (FVariable fv : getDAEUnmatchedVariables()) {
					err_str.append("     " + fv.name());
					err_str.append("\n");
				}
				unbalanced = true;
			}
			
			if (getDAEUnmatchedEquations().size() > 0 ) {
				if (unbalanced) 
					err_str.append("\n  ");
				err_str.append("The following equation(s) could not be matched to any variable:\n");
				for (FAbstractEquation ee : getDAEUnmatchedEquations()) {
					err_str.append(ee.prettyPrint("    "));
					err_str.append("\n");
				}
				unbalanced = true;
			}
			
			if (unbalanced) 
				error(err_str.toString());
		}
	}

	
	/**
	 * Generate array initialization statements for unknown function arrays.
	 */
	public void FClass.genInitArrayStatements() {
		beginStep("genInitArrayStatements()");
		for (FFunctionDecl ffd : getFFunctionDecls()) {
			ffd.genInitArrayStatements();
			ffd.sortBindingAssignments();
		}
		endStep("genInitArrayStatements()");
	}
	
	public void FFunctionDecl.genInitArrayStatements() {
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable ffv : getFFunctionVariables())
			ffv.genInitArrayStatements(stmts);
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmts.add(stmt);
		getFAlgorithm().setFStatementList(stmts);
	}

	protected boolean FFunctionVariable.hasInitArrayStmt = false;

	public void FFunctionVariable.genInitArrayStatements(List<FStatement> stmts) {}
	
	public void FFunctionArray.genInitArrayStatements(List<FStatement> stmts) {
		if (size().isUnknown() && !isInput() && !isOutput()) {
			FInitArrayStmt stmt = new FInitArrayStmt(createUseExp());
			stmt.shouldBeSorted = true;
			stmts.add(stmt);
			hasInitArrayStmt = true;
		}
	}

	
	public void FFunctionDecl.sortBindingAssignments() {
		Map<String,FStatement> map = new LinkedHashMap<String,FStatement>();
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmt.addToSortingMap(map);
		
		List<FStatement> stmts = new List<FStatement>();
		while (!map.isEmpty()) 
			map.values().iterator().next().addSortedByAssignmentOrder(stmts, map);
		
		for (FStatement stmt : getFAlgorithm().getFStatements())
			if (!stmt.shouldBeSorted)
				stmts.add(stmt);
		getFAlgorithm().setFStatementList(stmts);
	}
	
	public void FStatement.addToSortingMap(Map<String,FStatement> map) {
		if (shouldBeSorted) {
			for (String name : sortingAssignedNames()) {
				FStatement old = map.get(name);
				if (old != null && old != this)
					extraSortingDependencies().add(old);
				map.put(name, this);
			}
		}
	}
	
	
	private boolean FStatement.isBeingSorted = false;
	private boolean FStatement.addedDuringSorting = false;
	
	public void FStatement.addSortedByAssignmentOrder(
			List<FStatement> stmts, Map<String,FStatement> map) {
		if (isBeingSorted) 
			throw new CircularBindingExpressionException();
		isBeingSorted = true;
		
		for (String depName : sortingDependencies()) {
			FStatement dep = map.get(depName);
			if (dep != null && dep != this)
				dep.addSortedByAssignmentOrder(stmts, map);
		}
		for (FStatement dep : extraSortingDependencies()) {
			if (!dep.addedDuringSorting)
				dep.addSortedByAssignmentOrder(stmts, map);
		}
		
		stmts.add(this);
		addedDuringSorting = true;
		for (String name : sortingAssignedNames())
			map.remove(name);
		
		isBeingSorted = false;
	}
	
	public class CircularBindingExpressionException extends RuntimeException {}
	
	private Set<FStatement> FStatement.extraSortingDependencies = null;
	private Set<FStatement> FStatement.extraSortingDependencies() {
		if (extraSortingDependencies == null)
			extraSortingDependencies = new LinkedHashSet<FStatement>();
		return extraSortingDependencies;
	}
	
	
	syn lazy Set<String> FStatement.sortingAssignedNames() = Collections.<String>emptySet();
	eq FAssignStmt.sortingAssignedNames()      = Collections.singleton(getLeft().name());
	eq FInitArrayStmt.sortingAssignedNames()   = 
		Collections.singleton("size(" + getFIdUseExp().name() + ")");
	eq FForStmt.sortingAssignedNames()         = sortingAssignedNames(getForStmts());
	eq FWhileStmt.sortingAssignedNames()       = sortingAssignedNames(getWhileStmts());
	eq FFunctionCallStmt.sortingAssignedNames() {
		Set<String> res = new LinkedHashSet<String>(getNumLeft());
		for (FFunctionCallLeft left : getLefts())
			left.sortingAddNamesUsed(res);
		return res;
	}
	eq FIfStmt.sortingAssignedNames() {
		Set<String> res = new LinkedHashSet<String>();
		for (FIfWhenClause iwc : getFIfWhenClauses())
			res.addAll(iwc.sortingAssignedNames());
		for (FStatement stmt : getElseStmts())
			res.addAll(stmt.sortingAssignedNames());
		return res;
	}
	
	syn Set<String> FIfWhenClause.sortingAssignedNames() = 
		FStatement.sortingAssignedNames(getFStatements());
	
	public static Set<String> FStatement.sortingAssignedNames(List<FStatement> stmts) {
		Set<String> res = new LinkedHashSet<String>();
		for (FStatement stmt : stmts)
			res.addAll(stmt.sortingAssignedNames());
		return res;
	}
	
	
	syn lazy Set<String> FStatement.sortingDependencies() = Collections.<String>emptySet();
	eq FAssignStmt.sortingDependencies()       = 
		getRight().sortingAddNamesUsed(baseSortingDependencies());
	eq FInitArrayStmt.sortingDependencies()    = 
		getFIdUseExp().myFV().size().sortingAddNamesUsed(new LinkedHashSet<String>());
	eq FFunctionCallStmt.sortingDependencies() = 
		getCall().sortingAddNamesUsed(baseSortingDependencies());
	eq FForStmt.sortingDependencies()          = 
		addCompoundStmtSortingDependencies(baseSortingDependencies(), getIndex(), getForStmts());
	eq FWhileStmt.sortingDependencies()        = 
		addCompoundStmtSortingDependencies(baseSortingDependencies(), getTest(), getWhileStmts());
	eq FIfStmt.sortingDependencies() {
		Set<String> res = new LinkedHashSet<String>();
		for (FIfWhenClause iwc : getFIfWhenClauses())
			res.addAll(iwc.sortingDependencies());
		for (FStatement stmt : getElseStmts())
			res.addAll(stmt.sortingDependencies());
		return res;
	}
	
	syn Set<String> FIfWhenClause.sortingDependencies() = 
		FStatement.addCompoundStmtSortingDependencies(
				new LinkedHashSet<String>(), getTest(), getFStatements());
	
	protected Set<String> FStatement.baseSortingDependencies() {
		Set<String> res = new LinkedHashSet<String>();
		for (String name : sortingAssignedNames()) 
			res.add("size(" + name + ")");
		return res;
	}
	
	public static Set<String> FStatement.addCompoundStmtSortingDependencies(
			Set<String> set, ASTNode head, List<FStatement> body) {
		head.sortingAddNamesUsed(set);
		for (FStatement stmt : body)
			set.addAll(stmt.sortingDependencies());
		return set;
	}
	
	public Set<String> ASTNode.sortingAddNamesUsed(Set<String> set) {
		for (ASTNode n : this)
			n.sortingAddNamesUsed(set);
		return set;
	}
	
	public Set<String> FIdUse.sortingAddNamesUsed(Set<String> set) {
		if (!myFV().isUnknown())
			set.add(name());
		return super.sortingAddNamesUsed(set);
	}
	
	public Set<String> FSizeExp.sortingAddNamesUsed(Set<String> set) {
		Set<String> temp = new LinkedHashSet<String>();
		super.sortingAddNamesUsed(temp);
		for (String name : temp) {
			if (!name.startsWith("size("))
				name = "size(" + name + ")";
			set.add(name);
		}
		return set;
	}
	
	public Set<String> Size.sortingAddNamesUsed(Set<String> set) {
		return set;
	}
	
	public Set<String> MutableSize.sortingAddNamesUsed(Set<String> set) {
		for (FExp exp : exps)
			if (exp != null)
				exp.sortingAddNamesUsed(set);
		return set;
	}
	
	
	
	/**
	 * \brief Convert variable binding equations into regular equations.
	 */
	public void FClass.genBindingEquations() {
		beginStep("genBindingEquations()");
		
		FQName empty = new FQNameEmpty();
		for (FVariable fv : getFVariables()) 
			if (!fv.isConstant()) 
				fv.genBindingEquations(this, empty);
		for (FFunctionDecl ffd : getFFunctionDecls())
			ffd.genBindingAssignments();
//		flush();
		root().flushAllRecursive();

		endStep("genBindingEquations()");
	}
	
	public void FFunctionDecl.genBindingAssignments() {
		// TODO: To support Modelica 3.3, we need to sort the assignments
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable ffv : getFFunctionVariables())
			ffv.genBindingAssignments(stmts);
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmts.add(stmt);
		getFAlgorithm().setFStatementList(stmts);
	}
	
	/**
	 * Flag that controls if this statement should be a part of the set of statements at 
	 * the beginning of a function that are generated from variable declarations, and 
	 * should be sorted to ensure assignment before use among them.
	 */
	public boolean FStatement.shouldBeSorted = false;
	
	public void FFunctionVariable.genBindingAssignments(List<FStatement> stmts) {
		if (!isInput() && hasBindingExp()) {
			FAssignStmt stmt = new FAssignStmt(createFIdUse(), getBindingExp());
			stmt.shouldBeSorted = true;
			stmts.add(stmt);
			setBindingExpOpt(new Opt());
		}
	}
	
	
	public FExp FVariable.selectBindingFExp(FAttribute attr) {
		if (attr != null && attr.hasValue())
			return attr.getValue();
		else if (hasBindingExp())
			return getBindingExp();
		else
			return null;
	}
	
	public FQName FVariable.createNameForBindingEquation(FQName prefix, FAttribute attr) {
		FArraySubscripts fas = null;
		if (isArray()) {
			if (attr != null)
				attr = attr.findAttribute(FAttribute.SIZE);
			Size size = (attr != null && attr.hasValue()) ? new MutableSize(attr.getValue()) : size();
			fas = size.rangeFArraySubscripts();
		}
		return prefix.copyAndAppend(getFQName(), fas);
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix) {
		genBindingEquations(fc, prefix, null, false);
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, boolean param) {
		FExp bexp = selectBindingFExp(attr);
		boolean isAttr = attr != null && attr.hasValue();
		param = param || isParameter();
		if (bexp != null && !(param && bexp.isIndependentParameterExp())) {
			if (!inRecord())
				setBindingExpOpt(new Opt());
			genBindingEquationsFromExp(fc, prefix, attr, bexp, param);
			if (isAttr)
				attr.setValueOpt(new Opt());
		}
	}
	
	public void FRecordVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, boolean param) {
		/* TODO: Perhaps this is the wrong approach? Could we instead convert binding expressions 
		 *       for records into attributes on the variable, and sort it out into binding expressions 
		 *       during scalarization?
		 */
		FExp bexp = selectBindingFExp(attr);
		if (bexp != null) {
			super.genBindingEquations(fc, prefix, attr, param);
		} else {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				if (!comp.isConstant()) {
					FAttribute cAttr = findMatching(attrs, comp.name());
					comp.genBindingEquations(fc, name, cAttr, param || isParameter());
				}
			}
		}
	}
	
	protected void FVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, boolean param) {
		FQName name = createNameForBindingEquation(prefix, attr);
		param = param || isParameter();
		FEquation feq = new FEquation(new FIdUseExp(name), bexp.reflattenBindingExp(prefix, this));
		if (param)
			fc.addFParameterEquation(feq);
		else
			fc.addFEquation(feq);	
	}
	
	protected void FRecordVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, boolean param) {
		/* If we get here, then we won't be able to leave expressions for independent parameters 
		 * as binding expressions on the FVariable - we'll have to clean that up later. Since it 
		 * has to be done after records are broken into separate variables, we'll do it during 
		 * parameter equation sorting.
		 */
		if (bexp.canExtractRecordComponents()) {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				if (!comp.isConstant()) {
					FAttribute cAttr = findMatching(attrs, comp.name());
					FExp cExp = bexp.dynamicFExp(bexp.extractRecordFExp(comp.name()));
					comp.genBindingEquationsFromExp(fc, name, cAttr, cExp, param || isParameter());
				}
			}
		} else {
			super.genBindingEquationsFromExp(fc, prefix, attr, bexp, param);
		}
	}
	
	public FExp FExp.reflattenBindingExp(FQName prefix, FVariable var) {
		FExp res = dynamicFExp(fullCopy());
		FRecordDecl decl = var.containingRecordDecl();
		if (decl != null)
			res.prefixInternalUses(prefix, decl);
		return res;
	}
	
	public void FExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		for (FExp e : childFExps())
			e.prefixInternalUses(prefix, decl);
	}
	
	public void FIdUseExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		FQName fqn = getFIdUse().getFQName();
		fqn.prefixInternalUses(prefix, decl);
		if (decl == lookupFV(fqn.copyFirstPrefix()).containingRecordDecl()) 
			getFIdUse().setFQName(prefix.copyAndAppend(fqn));
	}
	
	public void FQName.prefixInternalUses(FQName prefix, FRecordDecl decl) {}
	
	public void FQNameFull.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		for (FQNamePart p : getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.prefixInternalUses(prefix, decl);
	}
	
	public void FSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {}
	
	public void FExpSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		getFExp().prefixInternalUses(prefix, decl);
	}
	
	protected List<FAttribute> FRecordVariable.selectFAttributeList(FAttribute attr) {
		if (attr != null && attr.getFAttributes().getNumChild() > 0)
			return attr.getFAttributes();
		else
			return getFAttributes();
	}
	
	syn boolean FExp.canExtractRecordComponents()      = false;
	eq FIdUseExp.canExtractRecordComponents()          = true;
	eq FRecordConstructor.canExtractRecordComponents() = true;
	eq FArray.canExtractRecordComponents() {
		for (FExp e : childFExps())
			if (!e.canExtractRecordComponents())
				return false;
		return true;
	}
	eq FAbstractCat.canExtractRecordComponents(){
		for (FExp e : childFExps())
			if (!e.canExtractRecordComponents())
				return false;
		return true;
	}
	
	/**
	 * \brief Create an FExp that represents a specific component of this record expression.
	 * 
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.extractRecordFExp(String suffix) {
		throw new UnsupportedOperationException("Can't extract record component of " + getClass().getSimpleName());
	}
	
	public FExp FIdUseExp.extractRecordFExp(String suffix) {
		FQName name = getFIdUse().getFQName().copyAsFQNameFull().append(suffix);
		return new FIdUseExp(name);
	}
	
	public FExp FRecordConstructor.extractRecordFExp(String suffix) {
		return getArg(getRecord().myFRecordDecl().indexOf(suffix)).fullCopy();
	}
	
	public FExp FArray.extractRecordFExp(String suffix) {
		FArray res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FAbstractCat.extractRecordFExp(String suffix) {
		FInfArgsFunctionCall res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FCatExp.extractRecordFExp(String suffix) {
		FCatExp res = (FCatExp) super.extractRecordFExp(suffix);
		res.setDim(getDim().fullCopy());
		return res;
	}
	
	public FExp FNoEventExp.extractRecordFExp(String suffix) {
		return createNode(getFExp().extractRecordFExp(suffix));
	}
	
	/**
	 * \brief Generate equations from an attribute of a record variable.
	 */
	public void FAttribute.genBindingEquations(FClass fc, FRecordDecl rec, FQName prefix, boolean depPar) {
		FVariable comp = (FVariable) rec.lookupHierarchical(getName().getFQName(), 0);
		if (!comp.isUnknown() && !comp.isConstant()) {
			FQName fqn = prefix.copyAndAppend(getName().getFQName());
			
			if (hasValue()) {
				boolean indPar = !depPar && comp.isParameter() && getValue().isIndependentParameterExp();
				// TODO: handle 'each'
				if (!indPar) {
					FEquation feq = new FEquation(new FIdUseExp(fqn), getValue());
					if (depPar || comp.isParameter())
						fc.addFParameterEquation(feq);
					else
						fc.addFEquation(feq);
					setValueOpt(new Opt());
				}
			}
			
			if (comp.isRecord()) {
				FRecordDecl next = comp.myFRecordDecl();
				for (FAttribute a : getFAttributes())
					a.genBindingEquations(fc, next, fqn, depPar);
			}
		}
	}
	
	/**
	 * \brief Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		if (!root().options.getBooleanOption("algorithms_as_functions"))
			return;

		beginStep("genAlgorithmFunctions()");
		
		for (FAlgorithm alg : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FQName funcName = new FQNameString(alg.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FIdUse use : alg.usedFIdUses()) {
				FAbstractVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FIdUse use : alg.assignedFIdUses()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
					FQName fqn = new FQNameString(name);
					ffv.setFQName(fqn);
					
					// Create and add binding expression for output
					bothInVars.get(i).setBindingExp(fqn.createFIdUseExp());
				}
			}
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
			FFunctionCall call = new FFunctionCall(funcName.createFIdUse(), args, sizes);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFQName().createFFunctionCallLeft());
			replaceEquation(alg, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			alg.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, alg, new Opt()));
		}
		
		endStep("genAlgorithmFunctions()");
	}
	
	public void FClass.genAlgoInitStmts() {
		beginStep("genAlgoInitStmts()");
		for (FAbstractEquation equation : equations()) {
			equation.genAlgoInitStmts();
		}
		endStep("genAlgoInitStmts()");
	}
	
	public void FAbstractEquation.genAlgoInitStmts() {}
	public void FAlgorithm.genAlgoInitStmts() {
		
		List<FStatement> stmts = new List<FStatement>();
		for (FVariable fv : referencedFVariablesInLHS()) {
			FStatement stmt = new FAssignStmt(fv.createFIdUse(),fv.createAlgorithmArgument(true));
			stmts.add(stmt);
		}
		for (FStatement stmt : getFStatements()) {
			stmts.add(stmt);
		}
		setFStatementList(stmts);
	}
	
	/**
	 * \brief Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		for (FEquationBlock b : getFEquationBlocks())
			if (b.getFAbstractEquations().replaceChild(oldEq, newEq))
				return;
	}
	
	/**
	 * \brief Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FQName.createFFunctionCallLeft() {
		FQName fqn = fullCopy();
		fqn.removeFArraySubscripts();
		return new FFunctionCallLeft(new Opt(new FIdUseExp(fqn)));
	}

	/**
	 * \brief Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return createFPreExp();
			if (isContinuous())
				return createStartAttributeExp();
		}
		return createUseExp();
	}
	
	/**
	 * \brief Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(new FOutput());
	}

	/**
	 * \brief Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(new FInput());
	}

	/**
	 * \brief Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(FTypePrefixInputOutput io) {
		FType type = (FType) type().fullCopy();
		return new FFunctionVariable(new Opt(io), type, new Opt(), getFQName().fullCopy());
	}

	/**
	 * \brief Add derivative variables to the list of FVariables, one for each
	 * differentiate variable.
	 */
	public void FClass.addFDerivativeVariables() {
		beginStep("addFDerivativeVariables()");
		ArrayList<FDerivativeVariable> l = new ArrayList<FDerivativeVariable>();
		for (FVariable fv : differentiatedRealVariables()) {
		    FDerivativeVariable fdv = new FDerivativeVariable(fv.getFVisibilityType().fullCopy(),
					fv.getFTypePrefixVariability().fullCopy(), fv.getFQName().fullCopy());
			fdv.setMeIntegrated(fv);
			fv.setMeDifferentiated(fdv);
			l.add(fdv);
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
		root().flushAllRecursive();
		endStep("addFDerivativeVariables()");
	}

	public FVariable FClass.addFDerivativeVariable(FVariable fv) {
		FVariable ffv = fv.createFDerivativeVariable();
		addFVariable(ffv);
		root().flushAllRecursive();
		return ffv;
	}

	public FVariable FVariable.createFDerivativeVariable() {
		return null;
	}

	public FVariable FRealVariable.createFDerivativeVariable() {
		return new FDerivativeVariable((FVisibilityType)getFVisibilityType().fullCopy(),
					getFTypePrefixVariability().fullCopy(), getFQName().fullCopy());
	}

	public FVariable FDerivativeVariable.createFDerivativeVariable() {
		return new FHDerivativeVariable((FVisibilityType)getFVisibilityType().fullCopy(),
					getFTypePrefixVariability().fullCopy(), getFQName().fullCopy(), 2);
	}

	public FVariable FHDerivativeVariable.createFDerivativeVariable() {
		return new FHDerivativeVariable((FVisibilityType)getFVisibilityType().fullCopy(),
					getFTypePrefixVariability().fullCopy(), getFQName().fullCopy(), getOrder() + 1);
	}

	/**
	 * \brief Add pre variables to the list of FVariables, one for each
	 * discrete variable.
	 */
	public void FClass.addFPreVariables() {
		beginStep("addFPreVariables()");
		ArrayList<FVariable> l = new ArrayList<FVariable>();
		for (FVariable fv : discreteVariables()) {
			l.add(fv.createPreVariable());
		}
		for (FVariable fv : l) {
			addFVariable(fv);
		}
//		flush();
		root().flushAllRecursive();
		endStep("addFPreVariables()");
	}
	
	/**
	 * Create a pre variable for this variable.
	 */
	abstract public FVariable FVariable.createPreVariable();
	
	public FVariable FRealVariable.createPreVariable() {
		return new FPreRealVariable(this);
	}
	
	public FVariable FIntegerVariable.createPreVariable() {
		return new FPreIntegerVariable(this);
	}
	
	public FVariable FEnumVariable.createPreVariable() {
		return new FPreEnumVariable(this);
	}
	
	public FVariable FBooleanVariable.createPreVariable() {
		return new FPreBooleanVariable(this);
	}
	
	public FVariable FStringVariable.createPreVariable() {
		return new FPreStringVariable(this);
	}
	
	public FVariable FRecordVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}
	
	public FVariable FExternalObjectVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}


	/**
	 * \brief Generate initial equations from variables with fixed start
	 * attributes.
	 * 
	 * Intitial equations corresponding to explicitly set start attributes of 
	 * differentiated variables are also generated, without taking the fixed
	 * attribute into account.
	 */
	public void FClass.genInitialEquations() {
		beginStep("genInitialEquations()");
		// TODO: Isn't there always a value for fv.startAttributeExp() now?
		for (FVariable fv : variables()) {
			boolean generate = false;
			if (!root().options.getBooleanOption("state_initial_equations") &&
					fv.isDifferentiatedVariable() && (fv.fixedAttribute() ||
					root().options.getBooleanOption("state_start_values_fixed")))
				generate = true;
			else if (!root().options.getBooleanOption("state_initial_equations") &&
					fv.isAlgebraicContinousRealVariable() && fv.fixedAttribute())
				generate = true;
			else if (fv.isDiscrete() && !fv.isString() && fv.fixedAttribute())
				generate = true;
			
			if (generate) {
				FExp lhs = new FIdUseExp(new FIdUse(fv.getFQName().fullCopy()));
				if (fv.isDiscrete())
					lhs = new FPreExp(lhs);
				FExp rhs = fv.startAttributeSet() ? fv.startAttributeExp() : fv.type().zeroLiteral();
				addFInitialEquation(new FEquation(lhs, rhs));
			}
		}
		root().flushAllRecursive();
		endStep("genInitialEquations()");
	}
	

	/**
	 * Perform alias elimination if it is activated.
	 */
	public void FClass.aliasEliminationIfSet() {
		if (root().options.getBooleanOption("eliminate_alias_variables")) {
			beginStep("aliasEliminationIfSet()");
			genAlias();
			eliminateAliasVariables();
			checkForEliminatedHGTVars();
			removeUnusedTemporaries();
			mergeEquivalentRecords();
			insertTempsInLHS();
			endStep("aliasEliminationIfSet()");
		}
	}
	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * \brief A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public boolean FVariable.canBeAliasEliminated(FVariable that) {
	
		// The only case where it is allowed to eliminate an 
		// alias equation containing a derivative is when the
		// other access is to an algebraic: der(x) = w
	
		if ((this.isDerivativeVariable() /*&& !that.isAlgebraicVariable()*/) ||
		    (that.isDerivativeVariable() /*&& that.isDerivativeVariable()*/)) {
		    //System.out.println(">>>>>>>> " + this.name() + " " + that.name());
		 	return false;   	
		}
	
		return true;
		 
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	public boolean FAbstractEquation.aliasClassified = false;
	public boolean FAbstractEquation.classifiedAsAlias = false;
	
	/**
	 * \brief Detection of alias variables in equations
	 * 
	 * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
	 * as alias equations and an AliasPair object is returned.
	 */
	public AliasPair FEquation.aliasVariables() {
		AliasPair res = null;
		if (!hasResidual()) // This equation should not be alias-removed if it is marked as residual!
			res = aliasVariables(getLeft(), getRight(), 1);
		aliasClassified = true;
		classifiedAsAlias = res != null;
		return res;
	}
	
	/**
	 * Determine if two expressions would form an alias pair if on the left and right sides of 
	 * an equation.
	 * 
	 * @param e1    an expression that would form one side of the equation
	 * @param e2    an expression that would form the other side of the equation
	 * @param sign  alias sign is multiplied with this - useful for e.g. 0 = x + y
	 */
	public static AliasPair ASTNode.aliasVariables(FExp e1, FExp e2, int sign) {
		if (e1.canBeAlias() && e2.canBeAlias() && e1.type().typeAliasCompatible(e2.type())) {   // x = y, etc.
			FVariable fv1 = e1.variableThatCanBeAlias();
			FVariable fv2 = e2.variableThatCanBeAlias();
			boolean negated = e1.aliasSign() * e2.aliasSign() * sign < 0;
			return new AliasPair(fv1, fv2, negated);
		} else {                                    // 0 = x + y, etc
			FExp eqZero = null;
			if (e1.isLiteralZero())
				eqZero = e2;
			else if (e2.isLiteralZero())
				eqZero = e1;
			if (eqZero != null)
				return eqZero.aliasVariables();
			else
				return null;
		}
	}
	
	/**
	 * \brief Detection of alias variables in expressions
	 * 
	 * Only valid when in an equation that gives that the value of this expression is always 0.
	 */
	public AliasPair FExp.aliasVariables() {
		return null;
	}
	
	public AliasPair FDotAddExp.aliasVariables() {
		return aliasVariables(getLeft(), getRight(), -1);
	}
	
	public AliasPair FDotSubExp.aliasVariables() {
		return aliasVariables(getLeft(), getRight(), 1);
	}
	
	syn boolean FExp.canBeAlias() = false;
	eq FIdUseExp.canBeAlias()     = myFV() instanceof FVariable;
	eq FDerExp.canBeAlias()       = false;
	eq FNegExp.canBeAlias()       = getFExp().canBeAlias();
	
	syn int FExp.aliasSign() = 1;
	eq FNegExp.aliasSign()   = -getFExp().aliasSign();
	
	syn FVariable FExp.variableThatCanBeAlias() = null;
	eq FIdUseExp.variableThatCanBeAlias()       = (FVariable) myFV();
	eq FNegExp.variableThatCanBeAlias()         = getFExp().variableThatCanBeAlias();
	
	syn boolean FExp.isLiteralExp() = false;
	eq FLitExp.isLiteralExp()       = true;
	
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	// If an equation has been classified, the result needs to be cached 
	// in order to avoid reclassification after alias rewrites.
	eq FEquation.isAliasEquation() = aliasClassified? classifiedAsAlias: aliasVariables()!=null;
	
	/**
	 * \brief Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		if (aliasManager == null) {
			aliasManager = new AliasManager();
		}
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			// Iterate over all equations
			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
			// Check all alias equations, also those that that have been
			// checked before.
			equation.aliasClassified = false; 
			if (equation.isAliasEquation()) 
				aliasManager.addAliasVariables(equation.aliasVariables());
		}
		aliasManager.reportAliasErrors(this);
		//flush();
		root().flushAllRecursive(); // TODO: is this really needed? the tree isn't changed
	}

	/**
	 * \brief Flag indicating if alias variables have been eliminated from the
	 * model.
	 */
	public boolean FClass.aliasVariablesEliminated = false;
	
	/**
	 * \brief Eliminate alias variables from the flat model.
	 * 
	 * The non-alias variables are kept in the list FClass.FVariableList but the
	 * alias variables are moved to FClass.AliasVariablesList.
	 */
	public void FClass.eliminateAliasVariables() {
		ArrayList<FVariable> nonAliasVars = new ArrayList<FVariable>();
		ArrayList<FVariable> aliasVars    = new ArrayList<FVariable>();
		ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
		
		//log.debug("FClass.eliminateAliasVariables(): l1 " + nonAliasVars + " l2 " + aliasVars);
		
		// Go through all variables and insert in correct list
		int i = 1;
		for (FVariable fv : getAliasVariables()) {
				aliasVars.add(fv);
		}
		for (FVariable fv : getFVariables()) {
			if (fv.isAlias()) {
				aliasVars.add(fv);
			} else { 
				nonAliasVars.add(fv);
				fv.propagateAttributesFromAlias();
			}
		}
		
		// Remove alias equations.
		for (FAbstractEquation equation : getFEquationBlock(0).getFAbstractEquations()) 
			if (!equation.isAliasEquation()) 
				eqns.add(equation);

		setFVariableList(new List(nonAliasVars));
		setAliasVariableList(new List(aliasVars));
		getFEquationBlock(0).setFAbstractEquationList(new List(eqns));
		
		aliasVariablesEliminated = true;
		enableAliasRewrite();
		
		flush();
	}
	
	public void FClass.checkForEliminatedHGTVars() {
		for (FVariable var : getAliasVariables()) {
			if (var.getHGTType() == FClass.HGTVariableType.COMPONENT || var.getHGTType() == FClass.HGTVariableType.PAIR)
				var.warning("Hand guided tearing variable '%s' has been alias eliminated. Selected model variable is:\n    %s", var.name(), var.alias());
		}
	}
	
	public void ASTNode.enableAliasRewrite() {
		for (ASTNode n : this)
			n.enableAliasRewrite();
	}
	
	public void FIdUseExp.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	public void FAssignStmt.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	public void FFunctionDecl.enableAliasRewrite() {
	}
	
	boolean FIdUseExp.rewriteAlias = false;
	boolean FAssignStmt.rewriteAlias = false;
	
	/**
	 * \brief FIdUses referring to alias variables need to be changed to 
	 * FIdUses referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FIdUseExp {
		when (rewriteAlias && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (fv.isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
	
	rewrite FAssignStmt {
		when (rewriteAlias && getLeft().myFV().isAlias()) to FAssignStmt {
			FVariable fv = (FVariable) getLeft().myFV();
			setLeft(fv.alias().createFIdUse());
			if (fv.isNegated()) 
				setRight(new FNegExp(getRight()));
			return this;
		}
	}
	
	/**
	 * \brief FDerExps referring to alias variables need to be changed to 
	 * FDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDerExp {
		when (rewriteAlias && !getFIdUse().myFV().isUnknown() && 
				(myFV().isAlias() || getFIdUse().myFV().isAlias())) to FExp {
			if (myFV().isAlias()) {
				FVariable fv = (FVariable) myFV();
				FExp new_exp = fv.alias().createUseExp();
				if (myFV().isNegated()) 
					new_exp = new FNegExp(new_exp);
				return new_exp;				
			} else {			
				FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
				FExp new_exp = new FDerExp(new FIdUse(new_name));
				if (getFIdUse().myFV().isNegated()) 
					new_exp = new FNegExp(new_exp);
				return new_exp;
			}
		}
	}

	/**
	 * \brief FDummyDerExps referring to alias variables need to be changed to 
	 * FDummyDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDummyDerExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/**
	 * \brief FHDummyDerExps referring to alias variables need to be changed to 
	 * FHDummyDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FHDummyDerExp {
		when (rewriteAlias && !myFV().isUnknown() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/*
	 * Rewrite derivatives of parameters to zeros.
	 */
	rewrite FDerExp {
		when (!getFIdUse().myFV().isUnknown() &&
				((FVariable)getFIdUse().myFV()).variability().lessOrEqual(fParameter())) to FExp {
			return new FRealLitExp(0.0);
		}
	}
	
	
	/**
	 * Remove all unused temporary variables, and inline temporaries only used once.
	 */
	public void FClass.removeUnusedTemporaries() {
		ArrayList<FVariable> temps = tempVariables();
		int oldSize = Integer.MAX_VALUE;
		while (temps.size() < oldSize) {
			ArrayList<FVariable> temps2 = new ArrayList<FVariable>(temps.size());
			for (FVariable fv : temps) {
				if (fv.shouldEliminateTemporary())
					fv.inlineUses();
				else
					temps2.add(fv);
			}
			oldSize = temps.size();
			temps = temps2;
		}
		
		ArrayList<FVariable> vars = new ArrayList<FVariable>();
		for (FVariable fv : getFVariables())
			if (!fv.isTemporary())
				vars.add(fv);
		for (FVariable fv : temps)
			vars.add(fv);
		
		removeMarkedEqns();
		setFVariableList(new List(vars));
	}

	/**
	 * Check if this is a temporary variable that should be eliminated.
	 */
	syn boolean FVariable.shouldEliminateTemporary() = 
		isTemporary() && 
		nonDefiningUses().size() <= 1 && 
		definingUses().size() <= 1 && 
		!usedAsFunctionCallLeft() && 
		(definingUses().isEmpty() || !definingUses().iterator().next().myFEquation().generatesEvents());
	
	/**
	 * Inline all non-defining uses of variable, and remove equation defining it.
	 * 
	 * NB: This assumes that the variable and any equations marked for removal will be removed.
	 */
	public void FVariable.inlineUses() {
		FExp value;
		if (hasBindingExp()) {
			value = getBindingExp();
		} else {
			if (definingUses().isEmpty())
				return;
			FAbstractEquation eqn = definingUses().iterator().next().myFEquation();
			if (!(eqn instanceof FEquation)) 
				return;
			value = ((FEquation) eqn).getRight();
			eqn.markedForRemoval = true;
		}
		
		if (nonDefiningUses().isEmpty())
			value.removeFromUses();
		value.parent = null;
		
		for (FIdUseExp use : nonDefiningUses())
			use.replaceMe(value.unboundCopy());
	}
	
	/**
	 * Flag for removing equation.
	 */
	public boolean FAbstractEquation.markedForRemoval = false;
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FExp.removeFromUses() {
		for (FExp e : childFExps())
			e.removeFromUses();
	}
	
	public void FIdUseExp.removeFromUses() {
		FAbstractVariable var = getFIdUse().myFV();
		var.uses().remove(this);
		var.definingUses().remove(this);
		var.nonDefiningUses().remove(this);
		getFIdUse().getFQName().removeFromUses();
	}
	
	/**
	 * Remove all uses in expressions in array subscripts from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FQName.removeFromUses() {}
	
	public void FQNameFull.removeFromUses() {
		for (FQNamePart p : getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.removeFromUses();
	}
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FSubscript.removeFromUses() {}
	
	public void FExpSubscript.removeFromUses() {
		getFExp().removeFromUses();
	}
	
	/**
	 * Remove all equations with <code>markedForRemoval == true</code>. 
	 */
	public void FClass.removeMarkedEqns() {
		setFInitialEquationList(removeMarkedEqns(getFInitialEquations()));
		setFParameterEquationList(removeMarkedEqns(getFParameterEquations()));
		FEquationBlock eb = getFEquationBlock(0);
		eb.setFAbstractEquationList(removeMarkedEqns(eb.getFAbstractEquations()));
	}
	
	/**
	 * Create a copy of the list with all equations with <code>markedForRemoval == true</code> removed. 
	 */
	protected static List<FAbstractEquation> ASTNode.removeMarkedEqns(List<FAbstractEquation> list) {
		List<FAbstractEquation> res = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : list) {
			if (!eqn.markedForRemoval) {
				eqn.removeMarkedEqns();
				res.add(eqn);
			}
		}
		return res;
	}
	
	/**
	 * Remove all contained equations with <code>markedForRemoval == true</code>. 
	 */
	public void FAbstractEquation.removeMarkedEqns() {}
	
	public void FForClauseE.removeMarkedEqns() {
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	public void FIfWhenElseEquation.removeMarkedEqns() {
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	public void FIfWhenEquation.removeMarkedEqns() {
		super.removeMarkedEqns();
		if (hasElse())
			getElse().removeMarkedEqns();
	}
	
	/**
	 * Remove records that are equivalent, and update uses. 
	 */
	public void FClass.mergeEquivalentRecords() {
		computeEquivalentRecords();
		activateEquivalentRecordUseRewrite();
		List<FRecordDecl> list = new List<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			if (rec.equivalentRecordToKeep)
				list.add(rec);
		setFRecordDeclList(list);
	}
	
	public void FClass.computeEquivalentRecords() {
		ArrayList<FType> distinctTypes = new ArrayList<FType>();
		ArrayList<FRecordDecl> keptDecl = new ArrayList<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls()) {
			boolean found = false;
			FType type = rec.type();
			for (int i = 0; !found && i < distinctTypes.size(); i++) {
				if (type.typeCompatible(distinctTypes.get(i))) {
					found = true;
					rec.equivalentRecordGroup = i;
				}
			}
			if (!found) {
				rec.equivalentRecordToKeep = true;
				rec.equivalentRecordGroup = distinctTypes.size();
				distinctTypes.add(type);
				keptDecl.add(rec);
			}
		}
		equivalentRecordMap = new HashMap<String,FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			equivalentRecordMap.put(rec.name(), keptDecl.get(rec.equivalentRecordGroup));
	}
	
	protected Map<String,FRecordDecl> FClass.equivalentRecordMap;
	
	public boolean FRecordDecl.equivalentRecordToKeep = false;
	public int FRecordDecl.equivalentRecordGroup = -1;
	
	public void ASTNode.activateEquivalentRecordUseRewrite() {
		for (ASTNode n : this)
			n.activateEquivalentRecordUseRewrite();
	}
	
	public void FFunctionVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		if (type().isRecord()) {
			rewriteEquivalentRecord = true;
			is$Final = false;
		}
	}
	
	public void FRecordVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	public void FRecordConstructor.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	private boolean FFunctionVariable.rewriteEquivalentRecord  = false;
	private boolean FRecordVariable.rewriteEquivalentRecord    = false;
	private boolean FRecordConstructor.rewriteEquivalentRecord = false;
	
	rewrite FFunctionVariable {
		when (rewriteEquivalentRecord)
		to FFunctionVariable {
			rewriteEquivalentRecord = false;
			setType(myFClass().createEquivalentRecordType(getType()));
			flushAll();
			return this;
		}
	}
	
	rewrite FRecordVariable {
		when (rewriteEquivalentRecord)
		to FRecordVariable {
			rewriteEquivalentRecord = false;
			setRecord(myFClass().createEquivalentRecordFQName(getRecord()));
			flushAll();
			return this;
		}
	}
	
	rewrite FRecordConstructor {
		when (rewriteEquivalentRecord)
		to FRecordConstructor {
			rewriteEquivalentRecord = false;
			getRecord().setFQName(myFClass().createEquivalentRecordFQName(getRecord().getFQName()));
			getRecord().flushAll();
			flushAll();
			return this;
		}
	}

	public FQName FClass.createEquivalentRecordFQName(FQName old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.getFQName().fullCopy() : old;
	}

	public FType FClass.createEquivalentRecordType(FType old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.type().sizedType(old.size()).fullCopy() : old;
	}
	
	public void FClass.insertTempsInLHS() {
		for (FAbstractEquation equation : 
			getFEquationBlock(0).getFAbstractEquations()) {
			equation.insertTempsInLHS(this);
		}
	}
	
	public void FAbstractEquation.insertTempsInLHS(FClass fClass) {}
	public void FFunctionCallEquation.insertTempsInLHS(FClass fClass) {
		for (FFunctionCallLeft left : getLefts())
			left.insertTempsInLHS(fClass);
	}
	
	public void FFunctionCallLeft.insertTempsInLHS(FClass fClass) {
		if (hasFExp())
			getFExp().insertTempsInLHS(fClass);
	}
	
	public void FExp.insertTempsInLHS(FClass fClass) {
		String tempName = calcTempVarName();
		fClass.addFVariable(type().createTempFVariable(new FQNameString(tempName), false));
		replaceMe(new FIdUseExp(tempName));
		fClass.addFEquation(new FEquation(this, new FIdUseExp(tempName)));
	}
	
	public void FIdUseExp.insertTempsInLHS(FClass fClass) {}
	public void FArray.insertTempsInLHS(FClass fClass) {
		for (FExp fExp : getFExps())
			fExp.insertTempsInLHS(fClass);
	}
	public void FRecordConstructor.insertTempsInLHS(FClass fClass) {
		for (FExp fExp : getArgs())
			fExp.insertTempsInLHS(fClass);
	}
	
}

aspect MapWhenClauses{

	public void ASTNode.enableWhenEquationRewrite() {
		for (ASTNode n : this)
			n.enableWhenEquationRewrite();
	}

	public void FClass.enableWhenEquationRewrite() {
		beginStep("enableWhenEquationRewrite()");
		super.enableWhenEquationRewrite();
		endStep("enableWhenEquationRewrite()");
	}

	
	public void FWhenEquation.enableWhenEquationRewrite() {
		super.enableWhenEquationRewrite();
		rewriteWhenEquation = true;
		is$Final = false;
	}
	
	boolean FWhenEquation.rewriteWhenEquation = false;

	public abstract FIfWhenElseEquation FIfWhenElseEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause);
	
	public FIfWhenElseEquation FWhenEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FWhenEquation((FEquationType)getType().fullCopy(),eqns,guard,elseClause);
	}

	public FIfWhenElseEquation FIfEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FIfEquation((FEquationType)getType().fullCopy(),eqns,guard,elseClause);
	}

	public FIfWhenElseEquation FElseEquation.createIfWhenElseEquation(List eqns, 
	                         FExp guard, Opt elseClause) {
		return new FElseEquation((FEquationType)getType().fullCopy(),eqns);
	}

	public FIfWhenElseEquation FIfWhenElseEquation.createSimpleIfWhenElseEquation(String varName, boolean copyGuard) {
		return null; //Not handled yet
	}

	public FIfWhenElseEquation FIfWhenEquation.createSimpleIfWhenElseEquation(String varName, boolean copyGuard) {
	
		// Copy guard
		FExp guard = null;
		if (copyGuard) {
			guard = getTest().fullCopy();
			guard.setParent(this);
			guard.traverseSymbolic(getTest());
		} else {
			guard = getTest();
		}
		
		// Find the right equation
		FAbstractEquation eqn = null;
		for (FAbstractEquation e : getFAbstractEquations()) {
		 	if (e.isSimple()) {
		 		for (FIdUseExp n : e.simpleLefts()) {
					if (n.name().equals(varName)) {
						eqn = e;
						break;
					}
		 		}
		 	}
		}
		
		if (eqn==null) {
			return null;
		}
		
		List eqns = new List().add(eqn);
		
		Opt o = null;
		// If there is an else when, split it
		if (hasElse()) {
			o = new Opt(getElse().createSimpleIfWhenElseEquation(varName,copyGuard));
		} else {
		    o = new Opt();
		}
		return createIfWhenElseEquation(eqns,guard,o);
	}

	public List FWhenEquation.splitWhenEquation() {
		List l = new List();
		int i = 0;
		for (FAbstractEquation e : getFAbstractEquations()) {
		 	if (e.isSimple()) {
		 		for (FIdUseExp n : e.simpleLefts()) {
		 			l.add(createSimpleIfWhenElseEquation(n.name(),i!=0));
		 		}
		 	}
		 	i++;
		}	
		return l;
	}

	rewrite FWhenEquation in FEquationBlock.getFAbstractEquation() {
		when (rewriteWhenEquation && getNumFAbstractEquation()>1) to List {
			return splitWhenEquation();
		}
	}
	
	syn lazy boolean FAbstractEquation.isSimple() = false;
	eq FEquation.isSimple() = (getLeft() instanceof FIdUseExp);
	
	syn lazy ArrayList<FIdUseExp> FAbstractEquation.simpleLefts() = new ArrayList<FIdUseExp>();
	
	eq FEquation.simpleLefts() {
		ArrayList<FIdUseExp> l = new ArrayList<FIdUseExp>();
		if (isSimple()) {
			l.add((FIdUseExp)getLeft());
		} 
		return l;
	}
	
	eq FFunctionCallEquation.simpleLefts() {
		ArrayList<FIdUseExp> l = new ArrayList<FIdUseExp>();
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
			    // Is this OK? According to spec function call lefts must be component refs.
				l.add((FIdUseExp)left.getFExp()); 
		return l;
	}
		
}


aspect IfEquations {
	
	/*
	 * First rewrite those if equations that has constant or stuctural parameter test
	 * by evaluating the expressions and eliminating unreachable branches.
	 */

	public void ASTNode.enableIfEquationElimination() {
		for (ASTNode n : this)
			n.enableIfEquationElimination();
	}

	public void FClass.enableIfEquationElimination() {
		beginStep("enableIfEquationElimination()");
		super.enableIfEquationElimination();
		
		// Workaround for JastAdd bug
		setFInitialEquationList(cleanEmptyElse(getFInitialEquations()));
		FEquationBlock b = getFEquationBlock(0);
		b.setFAbstractEquationList(cleanEmptyElse(b.getFAbstractEquations()));
		
		// Remove orphaned temporaries
		flushAllRecursive();
		removeUnusedTemporaries();
		endStep("enableIfEquationElimination()");
	}
	
	public void FIfEquation.enableIfEquationElimination() {
		super.enableIfEquationElimination();
		eliminateIfEquation = true;
		is$Final = false;
	}
	
	public void FIfExp.enableIfEquationElimination() {
		super.enableIfEquationElimination();
		eliminateIfEquation = true;
		is$Final = false;
	}
	
	private boolean FIfEquation.eliminateIfEquation = false;
	private boolean FIfExp.eliminateIfEquation = false;

	// TODO: not needed, since structural parameters are replaced 
	protected boolean FIfWhenElseEquation.eliminateOnParamTest = false;

	protected void FIfWhenElseEquation.setEliminateOnParamTest() {}

	protected void FIfEquation.setEliminateOnParamTest() {
		eliminateOnParamTest = true;
		getTest().markAsStructuralParameter();
		if (hasElse())
			getElse().setEliminateOnParamTest();
	}
	
	syn boolean FIfEquation.shouldEliminateIf() = 
		getTest().isConstantExp() || getTest().isParameterExp() && eliminateOnParamTest;
	
	rewrite FIfEquation {
		when (eliminateIfEquation) to FIfWhenElseEquation {
			eliminateIfEquation = false;
			
			if (shouldEliminateIf()) {
				try {
					if (getTest().ceval().booleanValue())
						return new FElseEquation(getType(), getFAbstractEquations());
					else if (hasElse())
						return getElse();
					else
						return new FElseEquation(getType(), new List());
				} catch (ConstantEvaluationException e) {}
			}
			
			return this;
		}	
	}
	
	rewrite FIfExp {
		when (eliminateIfEquation) to FExp {
			eliminateIfEquation = false;
			
			try {
				if (getIfExp().isConstantExp()) 
					return getIfExp().ceval().booleanValue() ? getThenExp() : getElseExp();
			} catch (ConstantEvaluationException e) {}
			
			return this;
		}
	}

	rewrite FElseEquation in FClass.getFInitialEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
	
	rewrite FElseEquation in FEquationBlock.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
	
	rewrite FElseEquation in FIfWhenElseEquation.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
			
	rewrite FElseEquation in FForClauseE.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}

	/*
	 * After we have eliminated if equations with constant (and possibly parameter)
	 * test expressions, then all if equations must be balanced, so we can rewrite to 
	 * a list of residual equations with if expressions.
	 */

	public void ASTNode.enableIfEquationRewrite() {
		for (ASTNode n : this)
			n.enableIfEquationRewrite();
	}

	public void FClass.enableIfEquationRewrite() {
		beginStep("enableIfEquationRewrite()");
		super.enableIfEquationRewrite();
		endStep("enableIfEquationRewrite()");
	}
	
	public void FIfEquation.enableIfEquationRewrite() {
		super.enableIfEquationRewrite();
		rewriteIfEquation = true;
		is$Final = false;
	}
	
	private boolean FIfEquation.rewriteIfEquation = false;
	
	syn Map<FAbstractVariable,FEquation> FIfWhenElseEquation.assignmentEquationMap() {
		calcAssignmentEquations();
		return assignmentEquationMap;
	}
	
	syn Set<FEquation> FIfWhenElseEquation.nonAssignmentEquationSet() {
		calcAssignmentEquations();
		return nonAssignmentEquationSet;
	}
	
	syn Set<FAbstractEquation> FIfWhenElseEquation.nonFEquationSet() {
		calcAssignmentEquations();
		return nonFEquationSet;
	}
	
	private Map<FAbstractVariable,FEquation> FIfWhenElseEquation.assignmentEquationMap = null;
	private Set<FEquation> FIfWhenElseEquation.nonAssignmentEquationSet = null;
	private Set<FAbstractEquation> FIfWhenElseEquation.nonFEquationSet = null;
	
	private void FIfWhenElseEquation.calcAssignmentEquations() {
		if (assignmentEquationMap == null || nonAssignmentEquationSet == null || nonFEquationSet == null) {
			assignmentEquationMap = new HashMap<FAbstractVariable,FEquation>();
			nonAssignmentEquationSet = new HashSet<FEquation>();
			nonFEquationSet = new HashSet<FAbstractEquation>();
			for (FAbstractEquation eqn : getFAbstractEquations()) {
				if (eqn instanceof FEquation) {
					FEquation feqn = (FEquation) eqn;
					FAbstractVariable var = feqn.assignedFV();
					if (var != null && !assignmentEquationMap.containsKey(var))
						assignmentEquationMap.put(var, feqn);
					else
						nonAssignmentEquationSet.add(feqn);
				} else {
					nonFEquationSet.add(eqn);
				}
			}
		}
	}
	

	syn FExp FAbstractEquation.createResidualExp() = null;
	eq FEquation.createResidualExp() {
		if (getLeft().isZeroLiteral())
			return getRight().fullCopy();
		if (getRight().isZeroLiteral())
			return getLeft().fullCopy();
		return new FSubExp(getLeft().fullCopy(), getRight().fullCopy());
	}
	
	// TODO: move to better suited source file
	syn boolean FExp.isZeroLiteral()  = false;
	eq FIntegerLitExp.isZeroLiteral() = getValue() == 0;
	eq FRealLitExp.isZeroLiteral()    = getValue() == 0.0;
	eq FArray.isZeroLiteral() {
		for (FExp e : getFExps())
			if (!e.isZeroLiteral())
				return false;
		return true;
	}
	
	syn FExp FAbstractEquation.assignmentExp() = null;
	eq FEquation.assignmentExp() =
		isAssignmentEqn() ? getRight() : null;	
	

	
	public static List<FAbstractEquation> ASTNode.cleanEmptyElse(List<FAbstractEquation> oldList) {
		List<FAbstractEquation> newList = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : oldList)
			if (!(eqn instanceof FElseEquation))
				newList.add(eqn);
		return newList;
	}
	
	public void FIfWhenElseEquation.cleanEmptyElse() {
		setFAbstractEquationList(cleanEmptyElse(getFAbstractEquations()));
	}
	
	public void FIfWhenEquation.cleanEmptyElse() {
		super.cleanEmptyElse();
		if (hasElse())
			getElse().cleanEmptyElse();
	}
	
	// TODO: Move to util
	public class ASTNode {
		
		public static <K, V> Set<V> valuesOfUnNamedKeys(Map<K, V> map, Set<K> namedKeys) {
			Set<V> res = new HashSet<V>();
			for (Map.Entry<K,V> e : map.entrySet())
				if (!namedKeys.contains(e.getKey()))
					res.add(e.getValue());
			return res;
		}
		
		public static <T> Set<T> intersection(Set<T> a, Set<T> b) {
			// TODO: use runtime type of a instead
			Set<T> res = new HashSet<T>();
			res.addAll(a);
			res.retainAll(b);
			return res;
		}
		
		public static <T> ArrayList<T> toSortedList(Collection<T> elems, Comparator<? super T> cmp) {
			ArrayList<T> res = new ArrayList<T>(elems.size());
			res.addAll(elems);
			Collections.sort(res, cmp);
			return res;
		}
		
	}
	
	protected static ArrayList<FEquation> FIfEquation.unmatchedEquations(
			FIfWhenElseEquation ifEqn, Set<FAbstractVariable> varsInBoth) {
		Set<FEquation> unMatchedAssign = 
			valuesOfUnNamedKeys(ifEqn.assignmentEquationMap(), varsInBoth);
		unMatchedAssign.addAll(ifEqn.nonAssignmentEquationSet());
		return toSortedList(unMatchedAssign, CHILD_ORDER_COMPARATOR);
	}

	syn List FIfEquation.createIfExpEquationList() {
		List<FAbstractEquation> l = new List<FAbstractEquation>();
		
		Set<FAbstractVariable> varsInBoth = 
			intersection(assignmentEquationMap().keySet(), getElse().assignmentEquationMap().keySet()); 
		for (FAbstractVariable v : toSortedList(varsInBoth, FAbstractVariable.NAME_COMPARATOR)) {
			FExp left = assignmentEquationMap().get(v).assignmentExp();
			FExp right = getElse().assignmentEquationMap().get(v).assignmentExp();
			FExp ifExp = new FIfExp(getTest().fullCopy(), left, right);
			l.add(new FEquation(getType().fullCopy(), v.createUseExp(), ifExp));
		}
		
		ParallelIterable<FEquation> unmatched = new ParallelIterable(new FEquation[2], true, 
				unmatchedEquations(this, varsInBoth), unmatchedEquations(getElse(), varsInBoth));
		for (FEquation[] eqs : unmatched) {
			FExp left = eqs[0].createResidualExp();
			FExp right = eqs[1].createResidualExp();
			FIfExp ifExp = new FIfExp(getTest().fullCopy(), left, right);
			l.add(new FEquation(getType().fullCopy(), eqs[0].type().zeroLiteral(), ifExp));
		}
		
		// TODO: handle this better once we have support for if equation that can't be rewritten in later steps
		for (FAbstractEquation eqn : nonFEquationSet())
			if (eqn.allowGlobalOnIfRewrite())
				l.add(eqn);
		for (FAbstractEquation eqn : getElse().nonFEquationSet())
			if (eqn.allowGlobalOnIfRewrite())
				l.add(eqn);
		
		return l;
	}
	
	syn boolean FAbstractEquation.allowGlobalOnIfRewrite() = false;
	eq FFunctionCallEquation.allowGlobalOnIfRewrite()      = getNumLeft() > 0;
	
	rewrite FIfEquation {
		when (rewriteIfEquation)
		to FElseEquation new FElseEquation(getType(), createIfExpEquationList());
	}

}

aspect ParameterSorting {

	/**
	 * \brief Index of equation during equation sorting.
	 */
	public int FAbstractEquation.sortingIndex = -1;
	
	public class FAbstractEquation {
		public static class SortingIndexComparator implements Comparator<FAbstractEquation> {
			public int compare(FAbstractEquation o1, FAbstractEquation o2) {
				return o1.sortingIndex - o2.sortingIndex;
			}
		}
	}
	
	public class FVariable {
		public static class SortingIndexComparator implements Comparator<FVariable> {
			public int compare(FVariable o1, FVariable o2) {
				return o1.parameterEquation().sortingIndex - o2.parameterEquation().sortingIndex;
			}
		}
	}
	
	/**
	 * \brief Creates a TreeSet that can hold FAbstractEquations, sorted by their sortingIndex.
	 */
	public static TreeSet<FAbstractEquation> FAbstractEquation.sortingSet() {
		return new TreeSet<FAbstractEquation>(new SortingIndexComparator());
	}
	
	/** 
	 * \brief Sorts a list of FVariables according to the sortingIndex of their equation.
	 */
	public static void FVariable.sortParameters(java.util.List<FVariable> vars) {
		Collections.sort(vars, new SortingIndexComparator());
	}
	
	/**
	 * \brief Sort dependent parameter equations.
	 * 
	 * This is a simple implementation of Kahn's topological sorting algorithm.
	 * This implementation will most likely be replaced by other graph 
	 * algorithms later on.
	 */
	public void FClass.sortDependentParameters() {
		beginStep("sortDependentParameters()");
		
		// Check that all independet parameters can be evaluated.
		for (FVariable var : getFVariables()) {
			FTypePrefixVariability variability = var.variability();
			if (variability.parameterVariability()) {
				if (var.hasBindingExp() && !var.getBindingExp().isLiteralExp() && !var.isExternalObject()) {
					try {
						var.setBindingExp(var.getBindingExp().ceval().buildLiteral());
					} catch (ConstantEvaluationException e) {
						getFParameterEquations().add(new FEquation(var.createUseExp(), var.getBindingExp()));
						var.removeBindingExp();
					}
				}
			}
		}
		// Get the list of parameter equations and set up preliminary data.
		ArrayList<FAbstractEquation> eqns = getFParameterEquations().toArrayList();
		
		// Check if there is any dependent parameters that can be made independent.
		Iterator<FAbstractEquation> it = eqns.iterator();
		while (it.hasNext()) {
			FAbstractEquation eqn = it.next();
			if (eqn != null && eqn.isIndependentParameterEquation()) {
				try {
					eqn.revertToBindingExp();
					it.remove();
				} catch (ConstantEvaluationException e) {
					// Doh, we were unable to evaluate the expression
				}
			}
		}
		int n_eqns = eqns.size();
		List<FVariable> vars = getFVariables();
		int n_vars = getNumFVariable();
		for (int i = 0; i < n_eqns; i++)
			eqns.get(i).sortingIndex = i;
		for (FVariable fv : vars)
			fv.parameterEquation();  // Calculate these before changing anything
		
		
		// Set up data structures for the adjacency graph.
		ArrayList<HashSet<FAbstractEquation>> toNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		ArrayList<HashSet<FAbstractEquation>> fromNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		for (int i = 0; i < n_eqns; i++) {
			toNodes.add(new HashSet<FAbstractEquation>());
			fromNodes.add(new HashSet<FAbstractEquation>());
		}
		
		// For each equation
		for (FAbstractEquation eqn : eqns) {
			// Retrieve all variables referenced in right hand side
			Set<FVariable> deps = eqn.referencedFVariablesInRHS();
			// Build the actual adjacency graph.
			for (FVariable fv : deps) {
				FAbstractEquation depEqn = fv.parameterEquation();
				if (depEqn != null && depEqn.sortingIndex >= 0) {
					toNodes.get(depEqn.sortingIndex).add(eqn);		
					fromNodes.get(eqn.sortingIndex).add(depEqn);
				}
			}
		}	
				
		// Sort using algorithm described at
		// http://en.wikipedia.org/wiki/Topological_sorting
		List<FAbstractEquation> L = new List<FAbstractEquation>();
		Queue<FAbstractEquation> S = new ArrayDeque<FAbstractEquation>();
		
		// Add all nodes without incoming edges to S
		for (int i = 0; i < n_eqns; i++) 
			if (fromNodes.get(i).isEmpty()) 
				S.add(eqns.get(i));
		
		// Repeat while S is not empty
		int si = 0;
		int n_indep = 0;
		while (S.size() > 0) {
			// Remove a node n from S
			FAbstractEquation n = S.remove();
			L.add(n);
			// For each node m with an edge e from n to m (in original order)
			Set<FAbstractEquation> nodes = FAbstractEquation.sortingSet();
			nodes.addAll(toNodes.get(n.sortingIndex));
			for (FAbstractEquation m : nodes) {
				// Remove edge e from fromNodes
				fromNodes.get(m.sortingIndex).remove(n);
				// If m has no incoming edges add m to S
				if (fromNodes.get(m.sortingIndex).isEmpty()) 
					S.add(m);
			}
			// Remove e from toNodes
			toNodes.get(n.sortingIndex).clear();
			// Done with n - update sortingIndex
			n.sortingIndex = si++;
		}
		
		// Not possible to find an ordering without cycles?
		if (L.getNumChild() != eqns.size() - n_indep) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		} else {
			// Replace old parameter equation list
			setFParameterEquationList(L);
			
			// Rearrange parameters in same order as parameter equations
			ArrayList<FVariable> depParams = new ArrayList<FVariable>(n_eqns);
			ArrayList<Integer> depParamIndices = new ArrayList<Integer>(n_eqns);
			for (int i = 0; i < n_vars; i++) {
				FVariable fv = vars.getChild(i);
				if (fv.hasParameterEquation()) {
					depParams.add(fv);
					depParamIndices.add(new Integer(i));
				}
			}
			FVariable.sortParameters(depParams);
			for (int i = 0; i < depParams.size(); i++)
				vars.setChild(depParams.get(i), depParamIndices.get(i).intValue());
	
			// Flush AST since the structure has changed.
				root().flushAllRecursive();
			
			// Remove any binding expressions of variables with parameter equations
			for (FAbstractEquation eqn : L)
				eqn.removeBindingExpOfAssignedVars();
		}

		endStep("sortDependentParameters()");
}
	
	/**
	 * Remove binding expression of variables assigned in this equation.
	 */
	public void FAbstractEquation.removeBindingExpOfAssignedVars() {}

	public void FEquation.removeBindingExpOfAssignedVars() {
		getLeft().removeBindingExpOfReferencedVars();
	}
	
	public void FFunctionCallEquation.removeBindingExpOfAssignedVars() {
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
				left.getFExp().removeBindingExpOfReferencedVars();
	}
	
	/**
	 * Remove binding expression of variables referenced in this expression.
	 */
	public void FExp.removeBindingExpOfReferencedVars() {
		for (FExp e : childFExps())
			e.removeBindingExpOfReferencedVars();
	}
	
	public void FIdUseExp.removeBindingExpOfReferencedVars() {
		getFIdUse().myFV().removeBindingExp();
	}
	
	/**
	 * Remove binding expression of this variable.
	 */
	public void FAbstractVariable.removeBindingExp() {}
	
	public void FVariable.removeBindingExp() {
		if (hasBindingExp())
			setBindingExpOpt(new Opt());
	}
	
	/**
	 * Test if this should be the binding expression of an independent parameter instead.
	 */
	syn boolean FAbstractEquation.isIndependentParameterEquation() = false;
	eq FEquation.isIndependentParameterEquation() = 
		getLeft().isFlatParameterUse() && getRight().isIndependentParameterExp();
	
	/**
	 * Test if this is a use of a parameter (in the flat tree).
	 */
	syn boolean FExp.isFlatParameterUse()   = false;
	eq FIdUseExp.isFlatParameterUse()       = getFIdUse().isFlatParameterUse();
	syn boolean FIdUse.isFlatParameterUse() = myFV().isParameter();
	
	/**
	 * Convert this parameter equation to a binding expression.
	 */
	public void FAbstractEquation.revertToBindingExp() {}
	public void FEquation.revertToBindingExp() throws ConstantEvaluationException {
		FVariable fv = (FVariable) ((FIdUseExp) getLeft()).getFIdUse().myFV();
		fv.setBindingExp(getRight().ceval().buildLiteral());
	}

}

aspect DummyDerivatives {

	rewrite FDerExp {
		when (myFV().isDummyDer()) to FDummyDerExp {
			return new FDummyDerExp(getFIdUse());
		}
	}

	rewrite FHDerExp {
		when (myFV().isDummyDer()) to FHDummyDerExp {
			return new FHDummyDerExp(getFIdUse(),getOrder());
		}
	}
	
	syn boolean FAbstractVariable.isDummyDer() {
		return false;
	}
	
	eq FDummyDerivativeVariable.isDummyDer() {
		return true;
	}
	
	eq FHDummyDerivativeVariable.isDummyDer() {
		return true;	
	}

	public void ASTNode.enableFHDerRewrite() {
		for (ASTNode n : this)
			n.enableFHDerRewrite();
	}
	
	public void FHDerExp.enableFHDerRewrite() {
		rewriteFHDer = true;
		is$Final = false;
	}
	
	boolean FHDerExp.rewriteFHDer = false;

	public void FHDerivativeVariable.enableFHDerRewrite() {
		rewriteFHDer = true;
		is$Final = false;
	}
	
	boolean FHDerivativeVariable.rewriteFHDer = false;

	rewrite FHDerExp {
		when (rewriteFHDer) to FDerExp 
		new FDerExp(getFIdUse().getFQName().createDerPrefixedName(getOrder() - 1));
	}

}

aspect TransformCanonicalErrorCheck {
	
	/**
	 * The number of DAE equations corresponds to the equivalent scalar number
	 * of equations.
	 */
	syn int FClass.numDAEEquations() = numScalarEquations();
	
	/**
	 * The number of equations in the DAE initialization system originating 
	 * from the DAE should be the same as the equivalent scalar number of
	 * equations. The equations may differ, however, due to inactive when
	 * clauses.
	 */
	syn int FClass.numDAEEquationsAtInitialization() 
		= numScalarEquationsAtInitialization();
	
	/**
	 * The number of unknown variables in the DAE corresponds to the number
	 * of real algebraic variables plus the number of derivative variables
	 * plus the number of discrete variables.
	 */
	syn int FClass.numDAEVariables() = 
		numAlgebraicContinousRealVariables() + 
		numDifferentiatedRealVariables() + numDiscreteVariables();
	
	/**
	 * The number of equations in the DAE initialization system is the 
	 * number of scalar DAE equations plus the number of scalar initial
	 * equations.
	 */	
	syn int FClass.numDAEInitEquations() = numDAEEquationsAtInitialization() + 
		numInitialEquations();
	
	/**
	 * The number of unknowns in the DAE initialization system is the 
	 * number of unknowns in the DAE system plus the number of differentiated
        * variables plus the number of (pre) discrete variables.
        */
       syn int FClass.numDAEInitVariables() = numDAEVariables() +
               numDifferentiatedRealVariables() + numDiscretePreVariables() +
               numNonFixedParameters();

       public void FClass.checkFClassDimensions() {
               // Check dimensions of DAE
		int n_eq_F = numDAEEquations();
		int n_vars_F = numDAEVariables();
		if (n_eq_F != n_vars_F) 
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numDAEInitEquations();
		int n_vars_F0 = numDAEInitVariables();
		if (n_eq_F0 > n_vars_F0) 
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		
	}
	
	public void FClass.collectErrors() {
		checkDuplicateVariables();
		checkFClassDimensions();
		checkStructure();
		checkUnsupportedStreamConnections();
	}
}

aspect FlushFClass {
	/**
	 * \brief Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FExps in order to enable rewrites of such nodes after elimination 
	 * of alias variables and after function inlining.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}
	
	public void FExp.flushAllRecursiveClearFinal() {
		flushAll();
		is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (ASTNode n : noTransform()) {
			n.flushAllRecursive();
		}
	}
	
	/**
	 * \brief Flush model AST and enable rewrites of FIdUseExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
}



aspect Tearing {
	
	
}



aspect FunctionInlining {

	/**
	 * If function inlining is enabled, inline all function calls that we can.
	 * 
	 * Then remove functions that aren't needed anymore.
	 */
	public void FClass.functionInliningIfSet() {
		String opt = root().options.getStringOption("inline_functions");
		if (opt != OptionRegistry.Inlining.NONE) {
			inlineFunctions(opt);
		}
	}
	
	/**
	 * Inline all function calls that we can.
	 */
	public void FClass.inlineFunctions(String opt) {
		beginStep("inlineFunctions()");
		new FunctionInliner(this, opt).inline();
		root().flushAllRecursive();
		removeUnusedTemporaries();
		root().flushAllRecursiveClearFinal();
		endStep("inlineFunctions()");
	}
	
	public class FFunctionDecl {
		/**
		 * Describes the possible inputs from the user concerning if and how to inline the function.
		 */
		public enum InlineAnnotation { 
			DEFAULT     (true, false), 
			NONE        (false, false), 
			INLINE      (true, true), 
			LATE        (true, true), 
			AFTER_INDEX (true, true);
			
			private boolean may;
			private boolean always;
			
			private InlineAnnotation(boolean may, boolean always) {
				this.may = may;
				this.always = always;
			}
			
			/**
			 * Check if the annotation says that we may try to inline the function.
			 */
			public boolean may() {
				return may;
			}
			
			/**
			 * Check if the annotation says that we should always try to inline the function.
			 */
			public boolean always() {
				return always;
			}
			
		}
		// TODO: handle LATE & AFTER_INDEX diffrently
		
		private InlineAnnotation inlineAnnotation = InlineAnnotation.DEFAULT;
		
		public void readInlineAnnotation(AnnotationNode a) {
			AnnotationNode inline = a.forPath("Inline");
			AnnotationNode late = a.forPath("LateInline");
			AnnotationNode index = a.forPath("InlineAfterIndexReduction");
			if (late.isBoolValue())
				inlineAnnotation = late.bool() ? InlineAnnotation.LATE : InlineAnnotation.NONE;
			if (inline.isBoolValue() && !(late.isBoolValue() && late.bool()))
				inlineAnnotation = inline.bool() ? InlineAnnotation.INLINE : InlineAnnotation.NONE;
			if (index.isBoolValue())
				inlineAnnotation = index.bool() ? InlineAnnotation.AFTER_INDEX : InlineAnnotation.NONE;
		}
	}
	
	/**
	 * Helper class for inlining.
	 * 
	 * Keeps track of all required data and the current state of the inlining process.
	 */
	public class FunctionInliner {
		
		private String level;
		
		private FClass fc;
		private FFunctionDecl func;
		private List<FVariable> vars;
		private List<FAbstractEquation> normalEqns;
		private List<FAbstractEquation> paramEqns;
		
		private Map<String,FExp> replMap;
		private FlatVariableMap lookupMap;
		private Map<String,Size> sizeMap;
		
		/**
		 * Create a new FunctionInliner to use with <code>fc</code>.
		 * 
		 * @param fc     the FClass to inline in
		 * @param level  decides how complex functions to inline, can take values 
		 *               from OptionRegistry.Inlining
		 */
		public FunctionInliner(FClass fc, String level) {
			this.fc = fc;
			this.level = level;
			vars = fc.getFVariables();
			normalEqns = fc.getFEquationBlock(0).getFAbstractEquations();
			paramEqns = fc.getFParameterEquations();
			// Make sure maps are calculated
			fc.parameterEquationsMap();
			fc.variablesMap();
		}
		
		/**
		 * Inline all function calls that we can.
		 */
		public void inline() {
			inline(normalEqns);
			inline(paramEqns);
		}
		
		/**
		 * Inline all function calls that we can from a specific list of equations.
		 */
		public void inline(List<FAbstractEquation> eqns) {
			for (FAbstractEquation eqn : eqns) {
				while (eqn != null && eqn.hasInlinableFunctions(this)) {
					// Note that this will add new equations to eqns, so we depend on
					// List.iterator() to handle that correctly.
					eqn = eqn.inlineFunctions(this);
				}
			}
		}
		
		/**
		 * Check if a given function should be inlined under the current inlining level.
		 */
		public boolean isInlinable(FFunctionDecl func) {
			if (level == OptionRegistry.Inlining.ALL)
				return func.isInlinable();
			if (level == OptionRegistry.Inlining.TRIVIAL)
				return func.isTrivialInlinable();
			return false;
		}
		
		/**
		 * Prepare for inlining a new function call.
		 * 
		 * @return  the map to use for lookups in the function during inlining.
		 */
		public FlatVariableMap startFunction(FFunctionDecl f) {
			replMap = new HashMap<String,FExp>();
			lookupMap = new FlatVariableMap();
			sizeMap = new HashMap<String,Size>();
			func = f;
			return lookupMap;
		}
		
		public void setSizeOf(String name, Size size) {
			sizeMap.put(name, size);
		}

		/**
		 * Get the expression to use for a specific variable of the function 
		 * currently being inlined.
		 * 
		 * @param name  the name of the variable
		 */
		public FExp getReplacementExp(String name) {
			return replMap.get(name);
		}

		/**
		 * Set the expression to use for a specific variable of the function 
		 * currently being inlined.
		 * 
		 * @param name  the name of the variable
		 * @param exp   the expression to use
		 */
		public void setReplacementExp(String name, FExp exp) {
			replMap.put(name, exp);
		}
		
		/**
		 * Check if this function inliner has created a temporary variable of the specified name.
		 * 
		 * @param name  the name of the temporary variable
		 */
		public boolean isReplacementVar(String name) {
			return lookupMap.lookup(name) != null;
		}

		/**
		 * Find the size of a specific variable of the function currently being inlined.
		 * 
		 * @param name  the name of the variable
		 */
		public Size lookupSize(String name) {
			return sizeMap.get(name);
		}

		/**
		 * Add a variable and (if not constant) an equation for an assignment.
		 * 
		 * @param oldName  the name of the variable that was assigned in the function
		 * @param value    the right-hand side of the equation
		 * @param noEvent  if true, make sure no events are generated for the equation
		 */
		public void addVarAndEqn(String oldName, FExp value, boolean noEvent) {
			FTypePrefixVariability variability = value.variability().fullCopy();
			if (value.type().addVarInInline()) {
				FVariable var = addVar(oldName, variability, value.type());
				if (variability.constantVariability()) {
					value = value.ceval().buildLiteral();
					var.setBindingExp(value);
					replMap.put(oldName, value);
				} else {
					if (noEvent)
						value = value.preventEvents();
					FEquation eqn = new FEquation(new FNormalEquation(), var.createUseExp(), value);
					addEquation(eqn, variability);
				}
			} else {
				replMap.put(oldName, value);
			}
		}

		/**
		 * Add variables and (if not constant) an equation for a function call statement.
		 * 
		 * @param lefts  the lefts of the function call statement
		 * @param call   the new function call
		 */
		public void addVarsAndFCEqn(List<FFunctionCallLeft> lefts, FAbstractFunctionCall call) {
            int nLefts = lefts.getNumChild();
            FTypePrefixVariability variability = (nLefts == 0) ? ASTNode.fContinuous() : call.variability().fullCopy();
			
			FExp[] exps = null;
			if (variability.constantVariability()) {
				try {
					CValue[] values = call.evaluate();
					exps = new FExp[values.length];
					for (int i = 0; i < values.length; i++)
						exps[i] = values[i].buildLiteral();
				} catch (ConstantEvaluationException e) {
					exps = null;
				}
			}

			if (exps == null)
				exps = new FExp[nLefts];
			FExp[] lExps = new FExp[nLefts];
			for (int i = 0; i < nLefts; i++) 
				lExps[i] = lefts.getChild(i).createInlineVars(this, exps[i], variability);
			
			if (!variability.constantVariability()) {
				call = (FAbstractFunctionCall) call.preventEvents();
				FFunctionCallEquation eqn = 
					new FFunctionCallEquation(new FNormalEquation(), new List(), call);
				for (FExp exp : lExps) {
					FFunctionCallLeft left = new FFunctionCallLeft();
					if (exp != null)
						left.setFExp(exp);
					eqn.addLeft(left);
				}
				addEquation(eqn, variability);
			}
		}
		
		private void addEquation(FAbstractEquation eqn, FTypePrefixVariability variability) {
			if (variability.parameterVariability()) {
				paramEqns.add(eqn);
				eqn.addToParameterEquationsMap(fc.parameterEquationsMap());
			} else {
				normalEqns.add(eqn);
			}
		}
		
		public FVariable addVar(String oldName, FTypePrefixVariability variability, FType type) {
			String n = fc.nextTempVarName(func);
			FQName name = type.isArray() ? 
					new FQNameFull(n, type.size().flattenFArraySubscripts(new FQNameEmpty())) : 
					new FQNameString(n);
			
			FVariable var = type.createTempFVariable(name, variability);
			vars.add(var);
			vars.getChild(vars.getNumChild() - 1);
			
			setSizeOf(oldName, type.size());
			lookupMap.addVariable(var);
			fc.variablesMap().addVariable(var);
			replMap.put(oldName, var.createUseExp());
			return var;
		}
		
	}
	
	
	public void FExp.addInliningVarsAndEqns(FunctionInliner fi, String oldName, boolean noEvent) {
		fi.addVarAndEqn(oldName, this, noEvent);
	}
	
	public void FArray.addInliningVarsAndEqns(FunctionInliner fi, String oldName, boolean noEvent) {
		fi.setSizeOf(oldName, size());
		Array arr = getArray();
		for (Index i : indices())
			arr.get(i).addInliningVarsAndEqns(fi, oldName + i, noEvent);
	}
	
	public void FRecordConstructor.addInliningVarsAndEqns(FunctionInliner fi, String oldName, boolean noEvent) {
		oldName += ".";
		Iterator<FExp> exps = getArgs().iterator();
		for (FRecordComponentType part : ((FRecordType) type()).getComponents())
			exps.next().addInliningVarsAndEqns(fi, oldName + part.getName(), noEvent);
	}
	
	
	/**
	 * Should expressions of this type generate new varriables during inlining?
	 */
	syn boolean FType.addVarInInline()      = true;
	eq FExternalObjectType.addVarInInline() = false;
	
	
	/**
	 * Create temporary variable(s) for this access when inlining a function call that 
	 * it is a left of, and return an access.
	 */
	public FExp FFunctionCallLeft.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		return hasFExp() ? getFExp().createInlineVars(fi, bExp, variability) : null;
	}
	
	/**
	 * Create temporary variable(s) for this access when inlining a function call that 
	 * it is a left of, and return an access. Non-access expressions returns null.
	 */
	public FExp FExp.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		return null;
	}
	
	public FExp FIdUseExp.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FVariable var = fi.addVar(scalarName(), variability, type());
		if (bExp != null) {
			var.setBindingExp(bExp);
			fi.setReplacementExp(scalarName(), bExp);
		}
		return var.createUseExp();
	}
	
	public FExp FArray.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FArray bArr = (FArray) bExp;
		FArray res = new FArray();
		int n = getNumFExp();
		for (int i = 0; i < n; i++) {
			FExp cellBExp = (bArr != null) ? bArr.getFExp(i) : null;
			res.addFExp(getFExp(i).createInlineVars(fi, cellBExp, variability));
		}
		return res;
	}
	
	public FExp FRecordConstructor.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FRecordConstructor bRec = (FRecordConstructor) bExp;
		FRecordConstructor res = new FRecordConstructor(getRecord().fullCopy(), new List());
		Iterator<FExp> bArgs = (bRec != null) ? bRec.getArgs().iterator() : null;
		for (FExp arg : getArgs()) {
			FExp partBExp = (bArgs != null) ? bArgs.next() : null;
			res.addArg(arg.createInlineVars(fi, partBExp, variability));
		}
		return res;
	}
	

	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public FExp FExp.preventEvents() {
		if (eventGenerating()) {
			FNoEventExp res = new FNoEventExp();
			replaceMe(res);
			res.setFExp(this);
			return res;
		} else {
			for (FExp e : childFExps())
				e.preventEvents();
			return this;
		}
	}
	
	public FExp FNoEventExp.preventEvents() {
		return this;
	}
	
	public FExp FFunctionCall.preventEvents() {
		for (FExp e : getArgs())
			e.preventEvents();
		return this;
	}
	
	public FExp FIdUseExp.preventEvents() {
		getFIdUse().getFQName().preventEvents();
		return this;
	}

	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public void FQName.preventEvents() {}
	public void FQNameFull.preventEvents() {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript s : part.getFArraySubscripts().getFSubscripts())
					s.preventEvents();
	}
	
	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public void FSubscript.preventEvents() {}
	public void FExpSubscript.preventEvents() {
		getFExp().preventEvents();
	}
	
	/**
	 * Check if this expression generates events.
	 * 
	 * Does not consider subexpressions.
	 */
	syn boolean FExp.eventGenerating() = false;
	eq FIfExp.eventGenerating()        = true;
	eq FRelExp.eventGenerating()       = getLeft().isContinuousExp() || getRight().isContinuousExp();
	eq FEventGenExp.eventGenerating() = true;
	// TODO: support more event-generating expressions
	
	/**
	 * Check if this expression or any subexpressions can cause events. 
	 */
	syn boolean FExp.generatesEvents() {
		if (eventGenerating())
			return true;
		for (FExp e : childFExps())
			if (e.generatesEvents())
				return true;
		return false;
	}
	eq FNoEventExp.generatesEvents() = false;
	eq FIdUseExp.generatesEvents()   = getFIdUse().getFQName().generatesEvents();
	
	syn boolean FQName.generatesEvents() = false;
	eq FQNameFull.generatesEvents() {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript s : part.getFArraySubscripts().getFSubscripts())
					if (s.generatesEvents())
						return true;
		return false;
	}
	
	syn boolean FSubscript.generatesEvents() = false;
	eq FExpSubscript.generatesEvents()       = getFExp().generatesEvents();
	
	/**
	 * Check if this equation can cause events. 
	 */
	syn boolean FAbstractEquation.generatesEvents() = false;
	eq FEquation.generatesEvents()                  = getLeft().generatesEvents() || getRight().generatesEvents();
	eq FFunctionCallEquation.generatesEvents()      = getCall().generatesEvents();
	
	/**
	 * Check if an equation contains any calls to functions that we can inline.
	 */
	syn boolean FAbstractEquation.hasInlinableFunctions(FunctionInliner fi) = false;
	eq FFunctionCallEquation.hasInlinableFunctions(FunctionInliner fi)      = 
		getCall().hasInlinableFunctions(fi);
	eq FEquation.hasInlinableFunctions(FunctionInliner fi)                  =
		getLeft().hasInlinableFunctions(fi) || getRight().hasInlinableFunctions(fi);
	eq FIfEquation.hasInlinableFunctions(FunctionInliner fi)                = 
		super.hasInlinableFunctions(fi) || (hasElse() && getElse().hasInlinableFunctions(fi));
	eq FWhenEquation.hasInlinableFunctions(FunctionInliner fi)              = false;
	eq FIfWhenElseEquation.hasInlinableFunctions(FunctionInliner fi) {
		for (FAbstractEquation eqn : getFAbstractEquations())
			if (eqn.hasInlinableFunctions(fi))
				return true;
		return false;
	}
	
	/**
	 * Check if an expression contains any calls to functions that we can inline.
	 */
	syn boolean FExp.hasInlinableFunctions(FunctionInliner fi) {
		for (FExp exp : childFExps())
			if (exp.hasInlinableFunctions(fi))
				return true;
		return false;
	}
	eq FFunctionCall.hasInlinableFunctions(FunctionInliner fi) =
		isInlinableFunctionCall(fi) || super.hasInlinableFunctions(fi);
	eq FIdUseExp.hasInlinableFunctions(FunctionInliner fi)     = 
		getFIdUse().getFQName().hasInlinableFunctions(fi);
	
	/**
	 * Check if any array subscripts contain any calls to functions that we can inline.
	 */
	syn boolean FQName.hasInlinableFunctions(FunctionInliner fi) {
		return false;
	}
	
	syn boolean FQNameFull.hasInlinableFunctions(FunctionInliner fi) {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
					if (sub.hasInlinableFunctions(fi))
						return true;
		return false;
	}
	
	/**
	 * Check if an array subscript contains any calls to functions that we can inline.
	 */
	syn boolean FSubscript.hasInlinableFunctions(FunctionInliner fi) = false;
	eq FExpSubscript.hasInlinableFunctions(FunctionInliner fi)       = 
		getFExp().hasInlinableFunctions(fi);
	
	/**
	 * Check if an expression is a call to a function that we can inline.
	 */
	syn boolean FExp.isInlinableFunctionCall(FunctionInliner fi) = false;
	eq FFunctionCall.isInlinableFunctionCall(FunctionInliner fi) = myFFunctionDecl().isInlinable(fi);
	

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public FAbstractEquation FAbstractEquation.inlineFunctions(FunctionInliner fi) {
		return this;
	}
	
	public FAbstractEquation FEquation.inlineFunctions(FunctionInliner fi) {
		getLeft().inlineFunctions(fi);
		getRight().inlineFunctions(fi);
		return this;
	}
	
	public FAbstractEquation FFunctionCallEquation.inlineFunctions(FunctionInliner fi) {
		if (getCall().isInlinableFunctionCall(fi)) {
			getCall().inline(fi);
			ArrayList<FFunctionVariable> outs = ((FFunctionCall) getCall()).myOutputs();
			int n = getNumLeft();
			ArrayList<FEquation> list = new ArrayList<FEquation>();
			for (int i = 0; i < n; i++) {
				if (getLeft(i).hasFExp()) {
					FQName name = outs.get(i).getFQName().fullCopy();
					name.removeFArraySubscripts();
					name.scalarized = true;
					getLeft(i).getFExp().createInliningOutputEquations(list, fi, name, getType());
				}
			}
			replaceMeWithList(list);
			return (list.size() > 0) ? list.get(0) : null;
		} else {
			getCall().inlineFunctions(fi);
			return this;
		}
	}
	
	public FAbstractEquation FIfEquation.inlineFunctions(FunctionInliner fi) {
		super.inlineFunctions(fi);
		if (hasElse())
			getElse().inlineFunctions(fi);
		return this;
	}
	
	public FAbstractEquation FIfWhenElseEquation.inlineFunctions(FunctionInliner fi) {
		fi.inline(getFAbstractEquations());
		return this;
	}
	
	public void FExp.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		FExp right = fi.getReplacementExp(name.scalarName());
		right = (right == null) ? type().zeroLiteral() : right.fullCopy();
		list.add(new FEquation(type.fullCopy(), this, right));
	}
	
	public void FArray.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		int i = 1;
		for (FExp exp : getFExps()) {
			FQName cellName = name.copyAndAddSubscript(new FIntegerSubscript(i));
			exp.createInliningOutputEquations(list, fi, cellName, type);
			i++;
		}
	}
	
	public void FRecordConstructor.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		Iterator<FExp> args = getArgs().iterator();
		for (FRecordComponentType part : ((FRecordType) type()).getComponents()) {
			FQName partName = name.copyAndAppend(part.getName());
			args.next().createInliningOutputEquations(list, fi, partName, type);
		}
	}
	
	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FExp.inlineFunctions(FunctionInliner fi) {
		for (FExp exp : childFExps())
			exp.inlineFunctions(fi);
	}
	
	public void FFunctionCall.inlineFunctions(FunctionInliner fi) {
		if (isInlinableFunctionCall(fi)) {
			inline(fi);
			replaceMe(fi.getReplacementExp(myOutputs().get(0).name()).fullCopy());
		} else {
			super.inlineFunctions(fi);
		}
	}

	public void FIdUseExp.inlineFunctions(FunctionInliner fi) {
		getFIdUse().getFQName().inlineFunctions(fi);
	}

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FQName.inlineFunctions(FunctionInliner fi) {}

	public void FQNameFull.inlineFunctions(FunctionInliner fi) {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
					sub.inlineFunctions(fi);
	}

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FSubscript.inlineFunctions(FunctionInliner fi) {}

	public void FExpSubscript.inlineFunctions(FunctionInliner fi) {
		getFExp().inlineFunctions(fi);
	}
	
	/**
	 * Inline this function call.
	 * 
	 * Base implementation throws exception.
	 */
	public void FAbstractFunctionCall.inline(FunctionInliner fi) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * Inline this function call. 
	 */
	public void FFunctionCall.inline(FunctionInliner fi) {
		myFFunctionDecl().inline(fi, getArgs());
	}
	
	/**
	 * Create a use exp for non-constant variables, and a literal for constant variables.
	 */
	public FExp FVariable.createInlineUseFExp() {
		try {
			return isConstant() ? ceval().buildLiteral() : createUseExp();
		} catch (ConstantEvaluationException e) {
			return createUseExp();
		}
	}
	
	private static final String ASTNode.REPLACE_UNKNOWN_CHILD_MSG = 
		"Trying to replace a child that is not found in the given position.";

	/**
	 * Replace a child of this node.
	 * 
	 * @param child  the child to replace
	 * @param repl   the node to replace it with
	 * @throws IllegalArgumentException  if <code>child</code> is not a child of this node
	 */
	private void ASTNode.replaceChild(ASTNode child, ASTNode repl) {
		int i = getIndexOfChild(child);
		if (i < 0)
			throw new IllegalArgumentException(REPLACE_UNKNOWN_CHILD_MSG);
		setChild(repl, i);
	}

	/**
	 * Replace a child of this node with a list of new nodes.
	 * 
	 * @param child  the child to replace
	 * @param repl   the node to replace it with
	 * @throws IllegalArgumentException  if <code>child</code> is not a child of this node
	 */
	private void ASTNode.replaceChildWithList(ASTNode child, Iterable<? extends ASTNode> repl) {
		int i = getIndexOfChild(child);
		if (i < 0)
			throw new IllegalArgumentException(REPLACE_UNKNOWN_CHILD_MSG);
		Iterator<? extends ASTNode> it = repl.iterator();
		if (it.hasNext()) {
			setChild(it.next(), i);
			while (it.hasNext())
				insertChild(it.next(), ++i);
		} else {
			removeChild(i);
		}
	}
	
	/**
	 * Replace this node in the tree.
	 * 
	 * @param repl  the node to replace it with
	 */
	protected void ASTNode.replaceMe(ASTNode repl) {
		ASTNode p = getParent();
		if (p != null) { 
			if (p instanceof DynamicOpt)
				p.setChild(repl, 0);
			else
				p.replaceChild(this, repl);
		}
	}
	
	/**
	 * Replace this node in the tree with a list of new nodes.
	 * 
	 * @param repl  the list of nodes to replace it with
	 */
	protected void ASTNode.replaceMeWithList(Iterable<? extends ASTNode> repl) {
		ASTNode p = getParent();
		if (p != null)
			p.replaceChildWithList(this, repl);
	}
	
	
	// TODO: check for recursive functions
	/**
	 * Check if we can inline this function, given the inlining level set in <code>fi</code>.
	 */
	syn boolean FFunctionDecl.isInlinable(FunctionInliner fi) =
		fi.isInlinable(this);
	
	/**
	 * Check if we can inline this function.
	 */
	syn lazy boolean FFunctionDecl.isInlinable() =
		inlineAnnotation.may() && isAllInlinable(getFAlgorithm().getFStatements());
	// TODO: Add warning if a function where user suggests inlining can't be inlined?

	/**
	 * Check if this function falls under the "trivial" inlining category.
	 */
	syn lazy boolean FFunctionDecl.isTrivialInlinable() {
		if (!inlineAnnotation.may())
			return false;
		if (inlineAnnotation.always())
			return isInlinable();
		if (myProtected().size() > 0)
			return false;
		for (FStatement stmt : getFAlgorithm().getFStatements())
			if (!stmt.isOkTrivialInline())
				return false;
		for (FFunctionVariable out : myOutputs()) {
			TrivialInlineCheck chk = out.createTrivialInlineCheck();
			for (FIdUse use : out.assigningUses()) 
				chk.check(use);
			if (!chk.isOk())
				return false;
		}
		return true;
	}
	
	/**
	 * Helper method to find unsupported statements in isTrivialInlinable().
	 */
	syn boolean FStatement.isOkTrivialInline() = false;
	eq FAssignStmt.isOkTrivialInline()         = true;
	eq FFunctionCallStmt.isOkTrivialInline()   = getCall().isOkTrivialInline();
	eq FReturnStmt.isOkTrivialInline()         = isLast();
	eq FForStmt.isOkTrivialInline()            = isOkTrivialInlineInFor();
	
	/**
	 * Helper method to find unsupported statements in isTrivialInlinable().
	 */
	syn boolean FAbstractFunctionCall.isOkTrivialInline() = isIgnored();
	eq FFunctionCall.isOkTrivialInline()                  = myFFunctionDecl().isTrivialInlinable();
	
	/**
	 * Helper method to unsupported statements in isTrivialInlinable().
	 */
	syn boolean FStatement.isOkTrivialInlineInFor() = false;
	eq FAssignStmt.isOkTrivialInlineInFor()         = getLeft().myFV().size().isUnknown();
	eq FForStmt.isOkTrivialInlineInFor() {
		for (FStatement stmt : getForStmts())
			if (!stmt.isOkTrivialInlineInFor())
				return false;
		return true;
	}
	
	/**
	 * Create a TrivialInlineCheck object for this variable.
	 */
	public TrivialInlineCheck FAbstractVariable.createTrivialInlineCheck() {
		if (isArray()) {
			if (isRecord())
				return new TrivialInlineCheck.Unsupported();
			if (size().isUnknown())
				return new TrivialInlineCheck.UnknownArray();
			else
				return new TrivialInlineCheck.KnownArray(size().numElements());
		} else {
			if (isRecord())
				return new TrivialInlineCheck.Record(myFRecordDecl());
			else
				return new TrivialInlineCheck.Scalar();
		}
	}
	
	/**
	 * Record keeper object for checking that each output is assigned exactly once.
	 * 
	 * For arrays, a rough guess heuristic is used. Arrays of records and records 
	 * containing arrays of unknown size are not supported.
	 */
	public abstract class TrivialInlineCheck {
		protected abstract void check(FIdUse use, int i);
		protected abstract void checkAll(FIdUse use);
		public abstract boolean isOk();
		
		public void check(FIdUse use) { check(use, 1); }
		
		public static class Scalar extends TrivialInlineCheck {
			protected int n = 0;
			protected void check(FIdUse use, int i) { n++; }
			protected void checkAll(FIdUse use)     { n++; }
			public boolean isOk()                   { return n == 1; }
		}
		
		public static class KnownArray extends Scalar {
			// TODO: check that each cell is assigned?
			protected int size;
			public KnownArray(int nElems)       { size = nElems; };
			protected void checkAll(FIdUse use) { n += size; }
			public boolean isOk()               { return n == size; }
		}
		
		public static class UnknownArray extends Scalar {
			// TODO: check sizes, and how loop indices are used?
			protected void check(FIdUse use, int i) { n += use.inForLoop() ? 1 : 2; }
			protected void checkAll(FIdUse use)     { n++; }
		}
		
		public static class Record extends TrivialInlineCheck {
			protected Map<String,TrivialInlineCheck> parts;
			protected boolean namesOk;
			
			public Record(FRecordDecl rec) {
				namesOk = true;
				parts = new HashMap<String,TrivialInlineCheck>();
				for (FVariable v : rec.getFVariables())
					parts.put(v.name(), v.createTrivialInlineCheck());
			}
			
			protected void check(FIdUse use, int i) {
				if (i < use.getFQName().numParts()) {
					TrivialInlineCheck part = parts.get(use.getFQName().partName(i));
					if (part != null)
						part.check(use, i + 1);
					else
						namesOk = false;
				} else {
					checkAll(use);
				}
			}
			
			protected void checkAll(FIdUse use) {
				for (TrivialInlineCheck part : parts.values())
					part.checkAll(use);
			}

			public boolean isOk() {
				for (TrivialInlineCheck part : parts.values())
					if (!part.isOk())
						return false;
				return namesOk;
			}
		}
		
		public static class Unsupported extends TrivialInlineCheck {
			protected void check(FIdUse use, int i) { }
			protected void checkAll(FIdUse use)     { }
			public boolean isOk()                   { return false; }
		}
		
		// TODO: records
	}
	
	inh boolean FIdUse.inForLoop();
	eq FForStmt.getForStmt().inForLoop() = true;
	eq FAlgorithm.getChild().inForLoop() = false;
	eq FlatRoot.getChild().inForLoop()   = false;
	eq InstRoot.getChild().inForLoop()   = false;
	
	
	/**
	 * Helper method to check if a list of statements are all inlinable.
	 */
	public static boolean ASTNode.isAllInlinable(Iterable<? extends FStatement> list) {
		for (FStatement stmt : list)
			if (!stmt.isInlinable())
				return false;
		return true;
	}
	
	/**
	 * Check if we can inline this statement.
	 */
	syn boolean FStatement.isInlinable() = false;
	eq FInitArrayStmt.isInlinable()      = true;
	eq FAssignStmt.isInlinable()         = true;
	eq FFunctionCallStmt.isInlinable()   = getCall().isIgnored() || !insideBranchedStmt();
	eq FReturnStmt.isInlinable()         = isLast();
	eq FForStmt.isInlinable()            = isAllInlinable(getForStmts());
	eq FIfStmt.isInlinable() {
		for (FIfWhenClause branch : getFIfWhenClauses())
			if (!isAllInlinable(branch.getFStatements()))
				return false;
		return isAllInlinable(getElseStmts());
	}
	// TODO: handle more types of stmts
	
	
	/**
	 * Flags that this function is being inlined.
	 */
	private boolean FFunctionDecl.duringInlining = false;
	
	/**
	 * Keep reference to function inliner during inlining for size lookup.
	 */
	public FunctionInliner FFunctionVariable.functionInliner = null;
	
	/**
	 * Inline a call to this function.
	 * 
	 * @param fi    the function inlining helper to use
	 * @param args  the argument list for the function call
	 */
	public void FFunctionDecl.inline(FunctionInliner fi, List<FExp> args) {
		duringInlining = true;
		tempLookupMap = fi.startFunction(this);
		flushAllRecursive();
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.functionInliner = fi;
		
		ArrayList<FFunctionVariable> inp = myInputs();
		for (int i = 0; i < inp.size(); i++) 
			args.getChild(i).addInliningVarsAndEqns(fi, inp.get(i).name(), false);
		
		ArrayList<FFunctionVariable> outp = myOutputs();
		for (FFunctionVariable fv : outp) 
			if (fv.isArray())
				fi.setSizeOf(fv.name(), fv.size().copyAndReplaceReferences(fi, getDummyExp()));
		
		for (FStatement stmt : getFAlgorithm().getFStatements()) 
			stmt.inline(fi);
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.functionInliner = null;
		
		tempLookupMap = null;
		duringInlining = false;
	}
	
	syn lazy FExp FFunctionDecl.getDummyExp() = new FNoExp();
	
	/**
	 * Inline this statement.
	 * 
	 * @param fi      the function inlining helper to use
	 */
	public void FStatement.inline(FunctionInliner fi) {}
	
	public void FAssignStmt.inline(FunctionInliner fi) {
		FExp right = getRight().fullCopy();
		right = getRight().dynamicFExp(right);
		right = right.replaceReferences(fi);
		FIdUse left = getLeft().fullCopy();
		left = ((FIdUseExp) getRight().dynamicFExp(new FIdUseExp(left))).getFIdUse();
		left.replaceReferencesInSubscripts(fi);
		right.addInliningVarsAndEqns(fi, left.scalarName(), true);
	}

	public void FFunctionCallStmt.inline(FunctionInliner fi) {
		// Temporarily replace lefts with scalarized versions
		Map<String,FExp> empty = Collections.emptyMap();
		List<FFunctionCallLeft> oldLefts = getLefts();
		List<FFunctionCallLeft> newLefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft left : oldLefts)
			newLefts.add(left.scalarize(empty));
		setLeftList(newLefts);
		newLefts.clearScalarized();
		
		// Scalarize and replace references
		FExp call = getCall().scalarizeExp(empty);
		call = getCall().dynamicFExp(call);
		call.clearScalarized();
		call = call.replaceReferences(fi);
		
		fi.addVarsAndFCEqn(getLefts(), (FAbstractFunctionCall) call);
		
		// Restore old left list
		setLeftList(oldLefts);
	}

	public void FInitArrayStmt.inline(FunctionInliner fi) {
		FAbstractVariable fv = getFIdUseExp().myFV();
		fi.setSizeOf(fv.name(), fv.size().copyAndReplaceReferences(fi, getFIdUseExp()));
		fv.flushCache();
	}
	
	public void FIfStmt.inline(FunctionInliner fi) {
		// Reduce to list of assignments
		List<FStatement> stmts = new List<FStatement>();
		inlinePrepare(fi, stmts);
		
		// Add assignments to tree temporarily
		List<FStatement> oldElse = getElseStmts();
		setElseStmtList((List) stmts);
		getElseStmtList();
		
		// Inline them
		for (FStatement stmt : stmts)
			stmt.inline(fi);
		
		// Restore old else branch
		setElseStmtList(oldElse);
	}
	
	public void FForStmt.inline(FunctionInliner fi) {
		// Reduce to list of assignments
		List<FStatement> stmts = new List<FStatement>();
		inlinePrepare(fi, stmts);
		
		// Add assignments to tree temporarily
		List<FStatement> oldStmt = getForStmts();
		setForStmtList((List) stmts);
		getForStmtList();
		
		// Inline them
		for (FStatement stmt : stmts)
			stmt.inline(fi);
		
		// Restore old else branch
		setForStmtList(oldStmt);
	}
	
	// TODO: handle more types of stmts
	
	/**
	 * Simplify a statement into a list of assignments, that can then easily be inlined.
	 */
	public void FStatement.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {}

	public void FAssignStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		stmts.add(fullCopy());
	}

	public void FFunctionCallStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		if (!getCall().isIgnored())
			stmts.add(fullCopy());
	}

	public void FIfStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		List<FStatement> oldElse = getElseStmts();
		
		// Prepare contents
		List<FStatement> newElse = new List<FStatement>();
		for (FStatement stmt : oldElse)
			stmt.inlinePrepare(fi, newElse);
		setElseStmtList((List) newElse);
		
		// Combine branches to assignments with if-else expressions
		for (int i = getNumFIfWhenClause() - 1; i >= 0; i--) {
			newElse = getFIfWhenClause(i).inlineCombineBranches(fi, newElse);
			setElseStmtList((List) newElse);
		}
		
		// Write result to target list
		for (FStatement stmt : newElse)
			stmts.add(stmt);
		setElseStmtList(oldElse);
	}

	public void FForStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		List<FStatement> oldStmts = getForStmts();
		
		// Prepare contents
		List<FStatement> newStmts = new List<FStatement>();
		for (FStatement stmt : oldStmts)
			stmt.inlinePrepare(fi, newStmts);
		setForStmtList((List) newStmts);
		
		// Unroll loop
		FVariable index = getIndex().getFVariable();
		FExp loopExp = getIndex().getFExp();
		loopExp = loopExp.dynamicFExp(loopExp.fullCopy()).replaceReferences(fi);
		for (FExp e : loopExp.getArray().iterable()) {
			stmts.add(new FAssignStmt(index.createFIdUse(), e.fullCopy()));
			for (FStatement stmt : newStmts)
				stmts.add(stmt.fullCopy());
		}
		setForStmtList(oldStmts);
	}
	
	/**
	 * Create a list of assign statements with if-else expressions that is the 
	 * equivalent of two branches of an if-else statement.
	 * 
	 * @param fi         the function inliner to use
	 * @param elseStmts  the else branch to combine
	 */
	protected List<FStatement> FIfWhenClause.inlineCombineBranches(
			FunctionInliner fi, List<FStatement> elseStmts) {
		// Prepare contents
		List<FStatement> oldStmts = getFStatements();
		List<FStatement> newStmts = new List<FStatement>();
		for (FStatement stmt : oldStmts)
			stmt.inlinePrepare(fi, newStmts);
		setFStatementList((List) newStmts);
		
		// First inefficient implementation
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : newStmts)
			stmts.add(createIfElseAssignment(stmt, null));
		for (FStatement stmt : elseStmts)
			stmts.add(createIfElseAssignment(null, stmt));
		// End first implementation
		
		// Clean up
		setFStatementList(oldStmts);
		return stmts;
	}
	
	/**
	 * Create an assign statement with an if-else exception as the right side, 
	 * that is equivalent to two assignments to the the same variable. One 
	 * assignment from this if branch, and one other from the next branch.
	 * If one of the assignments is null, then an access to the variable being 
	 * assigned is used there (i.e. a no-op). At least one must be non-null.
	 * 
	 * If any of the statements is not an assign statement, then 
	 * IllegalArgumentException is thrown.
	 * 
	 * @param left   the assignment from this branch
	 * @param right  the assignment from the next branch
	 */
	protected FAssignStmt FIfWhenClause.createIfElseAssignment(FStatement leftStmt, FStatement rightStmt) {
		try {
			FAssignStmt left = (FAssignStmt) leftStmt;
			FAssignStmt right = (FAssignStmt) rightStmt;
			FIdUse var = ((left != null) ? left : right).getLeft().fullCopy();
			FExp test = getTest().fullCopy(); // TODO: use temp var instead
			FExp leftExp = createIfElseExpBranch(left, var);
			FExp rightExp = createIfElseExpBranch(right, var);
			return new FAssignStmt(var, new FIfExp(test, leftExp, rightExp));
		} catch (ClassCastException e) {
			throw new IllegalArgumentException();
		}
	}
	
	private FExp FIfWhenClause.createIfElseExpBranch(FAssignStmt ass, FIdUse var) {
		return (ass != null) ? ass.getRight().fullCopy() : new FIdUseExp(var.fullCopy());
	}
	
	/**
	 * Replace all variable references according to the inlining helper.
	 */
	public ASTNode ASTNode.replaceReferences(FunctionInliner fi) {
		for (ASTNode n : this)
			n.replaceReferences(fi);
		return this;
	}
	
	public FExp FExp.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		return this;
	}
	
	public FExp FSizeExp.replaceReferences(FunctionInliner fi) {
		if (getFExp() instanceof FIdUseExp) {
			String name = ((FIdUseExp) getFExp()).getFIdUse().name();
			FExp exp = fi.lookupSize(name).createFExp(dimension());
			replaceMe(exp);
			return exp;
		} else {
			return super.replaceReferences(fi);
		}
	}
	
	// TODO: Should probably be removed after simplification step has been added
	public FExp FIfExp.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		if (getIfExp().isConstantExp()) {
			boolean useThen = getIfExp().ceval().booleanValue();
			FExp exp = useThen ? getThenExp() : getElseExp();
			replaceMe(exp);
			return exp;
		}
		return this;
	}
	
	public FExp FIdUseExp.replaceReferences(FunctionInliner fi) {
		replaceReferencesInSubscripts(fi);
		FExp exp = fi.getReplacementExp(scalarName());
		if (exp != null) {
			exp = dynamicFExp(exp.fullCopy());
		} else {
			if (fi.isReplacementVar(name())) {
				exp = this;
			} else if (isArray() && !size().isUnknown()) { 
				exp = getArray().buildWithReplacedReferences(fi, this);
			} else if (type().isRecord()) {
				exp = dynamicFExp(type().createRecordConstructor(getFIdUse().getFQName()));
				exp = exp.replaceReferences(fi);
			} else {
				exp = type().zeroLiteral();
			}
		}
		if (exp != this)
			replaceMe(exp);
		return exp;
	}
	
	public FExp FFunctionCall.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		Size[] old = getSizes();
		Size[] sizes = new Size[old.length];
		for (int i = 0; i < old.length; i++)
			if (old[i] != null)
				sizes[i] = old[i].copyAndReplaceReferences(fi, this);
		setSizes(sizes);
		return this;
	}
	
	public class Array {
		
		public FExp buildWithReplacedReferences(FunctionInliner fi, FExp context) {
			return buildFArray(new ReplaceReferenceBuilder(fi, context));
		}

		protected class ReplaceReferenceBuilder implements ElementBuilder {
	    	private FunctionInliner fi;
	    	private FExp context;
	    	
	    	public ReplaceReferenceBuilder(FunctionInliner fi, FExp context) {
	    		this.fi = fi;
	    		this.context = context;
	    	}
	    	
			public FExp build(FExp e) {
				return context.dynamicFExp(e).replaceReferences(fi);
			}
	    }
		
	}
	
	/**
	 * Replace all variable references in array subscripts according to the inlining helper.
	 */
	public void ASTNode.replaceReferencesInSubscripts(FunctionInliner fi) {
		for (ASTNode n : this)
			n.replaceReferencesInSubscripts(fi);
	}
	
	public void FExpSubscript.replaceReferencesInSubscripts(FunctionInliner fi) {
		getFExp().replaceReferences(fi);
	}
	
	/**
	 * Make a copy of this size with all variable references replaced according to the 
     * function inliner.
	 */
	public Size Size.copyAndReplaceReferences(FunctionInliner fi, FExp context) {
		return clone();
	}
	
	public MutableSize MutableSize.copyAndReplaceReferences(FunctionInliner fi, FExp context) {
		MutableSize res = clone();
		for (int i = 0; i < exps.length; i++)
			if (res.exps[i] != null)
				res.exps[i] = context.dynamicFExp(exps[i].fullCopy()).replaceReferences(fi);
		return res;
	}
	
	/*
	 * We must be able to tell the difference between discrete and continous expressions 
	 * during function inlining. Normally all expressions in functions are considered discrete.
	 */
	refine FlatVariability eq FFunctionDecl.getChild().inDiscreteLocation() = !duringInlining;
	
	/*
	 * We want to be able to scalarize all expressions (except size exps) fully during inlining.
	 */
	refine Scalarization eq FFunctionCallLeft.getFExp().canAcceptArray() = 
		Scalarization.FFunctionCallLeft.getFExp().canAcceptArray() && !duringFunctionInlining();
	refine Scalarization eq FFunctionCall.getArg().canAcceptArray()      = 
		Scalarization.FFunctionCallLeft.getArg().canAcceptArray() && !duringFunctionInlining();
	refine Scalarization eq FFunctionCall.getArg().wantsRecordCon()      = 
		Scalarization.FFunctionCall.getArg().wantsRecordCon() || duringFunctionInlining();
	eq FFunctionCallLeft.getFExp().wantsRecordCon()                      = 
		!inFunction() || duringFunctionInlining();

	inh boolean FFunctionCallLeft.duringFunctionInlining();
	inh boolean FExp.duringFunctionInlining();
	eq FFunctionDecl.getChild().duringFunctionInlining() = duringInlining;
	eq Root.getChild().duringFunctionInlining()          = false;
	
	/*
	 * Use the information we have on unknown sizes during inlining.
	 */
	refine Arrays eq FFunctionArray.size() {
		Size s = null;
		if (functionInliner != null)
			s = functionInliner.lookupSize(name());
		return (s == null) ? Arrays.FFunctionArray.size() : s;
	}
	
	
	/**
	 * Remove unused function declarations from the flat model.
	 */
	public void FClass.removeUnusedFunctions() {
		beginStep("removeUnusedFunctions()");
		getFVariables().markUsedFunctions();
		getFInitialEquations().markUsedFunctions();
		getFParameterEquations().markUsedFunctions();
		getFEquationBlocks().markUsedFunctions();
		List<FFunctionDecl> funcs = new List<FFunctionDecl>();
		for (FFunctionDecl func : getFFunctionDecls())
			if (func.functionIsUsed())
				funcs.add(func);
		setFFunctionDeclList(funcs);
		endStep("removeUnusedFunctions()");
	}
	
	class FFunctionDecl {
		public enum UseType{
			NONE(false, false),
			ALIAS_ATTRIBUTE_USE(false, false),
			ANNOTATION_DERIVATIVE(true, false),
			DIRECT(true, true);
			
			private final boolean normalUse;
			private final boolean derivativeUse;
			UseType(boolean normalUse, boolean derivativeUse) {
				this.normalUse = normalUse;
				this.derivativeUse = derivativeUse;
			}
			public boolean normalUse() {
				return normalUse;
			}
			public boolean derivativeUse() {
				return derivativeUse;
			}
			
			public UseType combine(UseType other) {
				return compareTo(other) > 0 ? this : other;
			}
		}
	}
	
	private UseType FFunctionDecl.functionUsed = UseType.NONE;
	
	/**
	 * Has this function been marked as used?
	 */
	syn boolean FFunctionDecl.functionIsUsed() = functionUsed != UseType.NONE;
	
	/**
	 * Has this function been marked as used?
	 */
	syn boolean FFunctionDecl.functionIsUsedAsDerivative() = functionUsed.derivativeUse();
	
	/**
	 * Mark all called functions as used.
	 */
	public void ASTNode.markUsedFunctions() {
		markUsedFunctions(FFunctionDecl.UseType.DIRECT);
	}
	public void ASTNode.markUsedFunctions(FFunctionDecl.UseType type) {
		for (ASTNode node : this)
			node.markUsedFunctions(type);
	}
	
	public void FVariable.markUsedFunctions(FFunctionDecl.UseType type) {
		AliasManager.AliasSet set = aliasSet();
		if (type != FFunctionDecl.UseType.ALIAS_ATTRIBUTE_USE && set != null)
			for (AliasManager.AliasVariable alias : set)
				if (alias.getFVariable() != this)
					alias.getFVariable().markUsedFunctions(FFunctionDecl.UseType.ALIAS_ATTRIBUTE_USE);
		super.markUsedFunctions(type);
	}
	
	public void FFunctionCall.markUsedFunctions(FFunctionDecl.UseType type) {
		myFFunctionDecl().markUsedFunctions(type);
		super.markUsedFunctions(type);
	}
	
	public void FFunctionDecl.markUsedFunctions(UseType type) {
		UseType oldType = functionUsed;
		functionUsed = functionUsed.combine(type);
		if (functionUsed != oldType) {
			if (functionUsed == UseType.DIRECT &&
			   (root().options.getBooleanOption("generate_block_jacobian") ||
			    root().options.getBooleanOption("generate_dae_jacobian") ||
			    root().options.getBooleanOption("generate_ode_jacobian"))) {
				if (requiresDerivative() && !canDifferentiate()) {
					error("Unable to determine derivative function for function '" + name() + "'");
				} else if (hasFDerivativeFunction()) {
					getFDerivativeFunction().myFFunctionDecl().markUsedFunctions(UseType.ANNOTATION_DERIVATIVE);
				}
			}
			super.markUsedFunctions(functionUsed);
		}
	}

}

aspect StateInitialEquations {
	
	public void FClass.addStateInitialEquationsIfSet() {
		if (root().options.getBooleanOption("state_initial_equations")) {
			beginStep("addStateInitialEquationsIfSet()");
			
			setFInitialEquationList(new List());
			
			for (FRealVariable fv : differentiatedRealVariables()) {
				FQName nameToAdd = fv.getFQName().copyAndAddPrefix("_start_");
				FRealVariable fvToAdd = new FRealVariable(new FPublicVisibilityType(), new FParameter(), nameToAdd);
				fvToAdd.setBindingExp(fv.startAttributeExp().fullCopy());
				addFVariable(fvToAdd);
				FEquation eqnToAdd = new FEquation(fv.createUseExp(), fvToAdd.createUseExp());
				addFInitialEquation(eqnToAdd);
				flushAllRecursive();
			}
		
			endStep("addStateInitialEquationsIfSet()");
		}
	}
	
}

aspect RuntimeOptions {
	
	/**
	 * Add parameters for all defined runtime options.
	 */
	public void FClass.addRuntimeOptionParameters() {
		OptionRegistry opt = root().options;
		if (opt.getBooleanOption("generate_runtime_option_parameters") && opt.getBooleanOption("generate_ode")) {
			for (String key : opt.getRuntimeOptionKeys()) {
				FVariable v = null;
				String name = "_" + key;
				if (opt.isBooleanOption(key))
					v = createBooleanRuntimeOptionParameter(name, opt.getBooleanOption(key));
				else if (opt.isStringOption(key))
					v = createStringRuntimeOptionParameter(name, opt.getStringOption(key));
				else if (opt.isIntegerOption(key))
					v = createIntegerRuntimeOptionParameter(name, opt.getIntegerOption(key));
				else if (opt.isRealOption(key))
					v = createRealRuntimeOptionParameter(name, opt.getRealOption(key));
				addFVariable(v);
			}
		}
	}
	
	/**
	 * Create a parameter for a boolean runtime option. 
	 */
	public FVariable FClass.createBooleanRuntimeOptionParameter(String name, boolean val) {
		return commonCreateRuntimeOptionParameter(new FBooleanVariable(), name, FBooleanLitExp.create(val));
	}
	
	/**
	 * Create a parameter for a string runtime option. 
	 */
	public FVariable FClass.createStringRuntimeOptionParameter(String name, String val) {
		return commonCreateRuntimeOptionParameter(new FStringVariable(), name, new FStringLitExp(val));
	}
	
	/**
	 * Create a parameter for a integer runtime option. 
	 */
	public FVariable FClass.createIntegerRuntimeOptionParameter(String name, int val) {
		return commonCreateRuntimeOptionParameter(new FIntegerVariable(), name, new FIntegerLitExp(val));
	}
	
	/**
	 * Create a parameter for a real runtime option. 
	 */
	public FVariable FClass.createRealRuntimeOptionParameter(String name, double val) {
		return commonCreateRuntimeOptionParameter(new FRealVariable(), name, new FRealLitExp(val));
	}
	
	/**
	 * Set the children of a runtime option parameter.
	 * 
	 * @param v     the variable to set fields on
	 * @param name  the name of the variable
	 * @param bExp  the burrent value of the option
	 * @return  <code>v</code>, for convenience
	 */
	public FVariable FClass.commonCreateRuntimeOptionParameter(FVariable v, String name, FExp bExp) {
		v.setFVisibilityType(new FRuntimeOptionVisibilityType());
		v.setFTypePrefixVariability(new FParameter());
		v.setBindingExp(bExp);
		v.setFQName(new FQNameString(name));
		return v;
	}
	
	syn int FClass.numRuntimeOptionParameters() = runtimeOptionParameters().size();
	syn lazy ArrayList<FVariable> FClass.runtimeOptionParameters() {
		ArrayList<FVariable> res = new ArrayList<FVariable>();
		for (FVariable fv : independentParameters())  // They are always independent
			if (fv.isRuntimeOption())
				res.add(fv);
		return res;
	}
	
	syn boolean FVariable.isRuntimeOption() = getFVisibilityType().isRuntimeOptionVisibility();
	
	syn boolean FVisibilityType.isRuntimeOptionVisibility()     = false;
	eq FRuntimeOptionVisibilityType.isRuntimeOptionVisibility() = true;
	
}

aspect ResidualPairPropagation{
	
	public class FClass {
		public enum HGTVariableType{
			NONE,
			COMPONENT,
			PAIR
		}
	}
	
	public void FAbstractVariable.setHGTType(FClass.HGTVariableType type) {}
	
	private void FClass.propagateResidualPairs() {
		for (FAbstractEquation eqn : getFEquationBlock(0).getFAbstractEquations()) {
			if (eqn.hasResidual() && eqn.getResidual().hasIterationVariable())
				eqn.getResidual().getIterationVariable().myFV().setHGTType(FClass.HGTVariableType.PAIR);
				
		}
		for (FResidualPair pair : getFResidualPairs()) {
			pair.propagate();
		}
	}
	
	protected void FResidualPair.propagate() {
		FAbstractEquation fae = getResidualEquation().myFEquation();
		if (fae == null) {
			error("Internal HGT Error, unable to find fae");
			return;
		}
		FAbstractVariable fv = getIterationVariable().myFV();
		int otherLevel = fae.hasResidual() ? fae.getResidual().getLevel() : Integer.MAX_VALUE;
		if (otherLevel == getLevel()) {
			error("Internal HGT Error, same level, decalred twise?");
			return;
		}
		if (otherLevel > getLevel()) {
			fae.setResidual(new FResidual(new Opt<FIdUse>(getIterationVariable().fullCopy()), getLevel()));
			getIterationVariable().myFV().setHGTType(FClass.HGTVariableType.PAIR);
		}
	}
}



aspect EventGeneratingExps {
	/**
	 * Extracts event generating expressions into when equations.
	 * Replaces the exp with a temp var, introduces an intial equation
	 * and a when equation for the temp var.
	 * 
	 * After this step, event generating expressions with higher than 
	 * parameter variability are only allowed in discrete locations.
	 */
	public void FClass.extractEventGeneratingExps() {

		ArrayList<FEventGenExp> eventExps = collectEventGeneratingExps();
		Collections.reverse(eventExps);
		
		// Calculating type() needs to be done before expressions are changed
		// in case of nested event generating expressions.
		ArrayList<FVariable> tempVars = new ArrayList<FVariable>();
		for (FEventGenExp exp: eventExps) {
			FVariable tempVar = exp.type().createTempFVariable(
					new FQNameFull(exp.tempVarName()), FTypePrefixVariability.fDiscrete());
			tempVars.add(tempVar);
		}
		
		for (int i = 0; i < eventExps.size(); i++) {
			FEventGenExp exp = eventExps.get(i);
			FVariable tempVar = tempVars.get(i);
			
			addFVariable(tempVar);
			exp.replaceMe(tempVar.createUseExp());
			addFInitialEquation(new FEquation(tempVar.createUseExp(), exp.fullCopy()));
			
			// Add when equation
			List<FAbstractEquation> eqList = new List<FAbstractEquation>();
			eqList.add(new FEquation(tempVar.createUseExp(), exp.fullCopy()));
			addFEquation(new FWhenEquation(new FNormalEquation(), eqList, 
					exp.createGuardExp(tempVar), new Opt<FIfWhenElseEquation>()));
			
		}
		
		root().flushAllRecursive();
	}
		
	/**
	 * Collects event generating expressions.
	 */
	coll ArrayList<FEventGenExp> FClass.collectEventGeneratingExps() 
		[new ArrayList<FEventGenExp>()] with add root FClass;
	FEventGenExp contributes this
		when inEquationSection() && !inDiscreteLocation() && !inNoEventExp() && !getX().variability().parameterOrLess() 
		to FClass.collectEventGeneratingExps()
		for myFClass();
	
	/**
	 * Creates a guard expression for an event generating expression
	 * extracted to a when equation. (Integer inherits from floor.)
	 */
	syn FExp FEventGenExp.createGuardExp(FVariable var);
	eq FFloorFuncExp.createGuardExp(FVariable var) {
		FArray guards = new FArray();
		guards.addFExp(new FLtExp(getX().fullCopy(), new FPreExp(var.createUseExp())));
		guards.addFExp(new FGeqExp(getX().fullCopy(), new FAddExp(new FPreExp(var.createUseExp()), new FIntegerLitExp(1))));
		return guards;
	}
	eq FCeilFuncExp.createGuardExp(FVariable var) {
		FArray guards = new FArray();
		guards.addFExp(new FLeqExp(getX().fullCopy(), new FSubExp(new FPreExp(var.createUseExp()), new FIntegerLitExp(1))));
		guards.addFExp(new FGtExp(getX().fullCopy(), new FPreExp(var.createUseExp())));
		return guards;
	}
	eq FDivFuncExp.createGuardExp(FVariable var) {
		FArray guards = new FArray();
		guards.addFExp(new FLtExp(new FDivFuncExp(getX().fullCopy(), getY().fullCopy()), new FPreExp(var.createUseExp())));
		guards.addFExp(new FGeqExp(new FDivFuncExp(getX().fullCopy(), getY().fullCopy()), new FAddExp(new FPreExp(var.createUseExp()), new FIntegerLitExp(1))));
		return guards;
	} 
	
	// These two are rewritten to floor and div containing expressions during flattening.
	eq FModFuncExp.createGuardExp(FVariable var) {
		throw new UnsupportedOperationException();
	}
	eq FRemFuncExp.createGuardExp(FVariable var) {
		throw new UnsupportedOperationException();
	}
}

aspect SemiLinear {
	public void FClass.enableSemiLinearRewrite() {

		// Transform equations 0 = semiLinear(0,x,y) into x = y;
		for (FAbstractEquation equation : getFEquationBlock(0).getFAbstractEquations()) {
			equation.enableSemiLinearRewrite();
		}
		
		// TODO: Rewrite chained semiLinear equations
		
		// Change remaining semiLinear exps to if exps. 
		HashSet<FSemiLinearExp> exps = collectSemiLinearExps();
		for (FSemiLinearExp exp: exps) {
			FExp ifExp = exp.asIfExp();
			exp.replaceMe(ifExp);
		}
	}
	
	public void FAbstractEquation.enableSemiLinearRewrite() {}
	public void FEquation.enableSemiLinearRewrite() {
		FExp left;
		FSemiLinearExp right;
		
		if (!getLeft().isSemiLinear() && !getRight().isSemiLinear())
			return;
		
		if (getLeft().isSemiLinear()) {
			right = (FSemiLinearExp) getLeft();
			left = getRight();
		} else {
			left = getLeft();
			right = (FSemiLinearExp) getRight();
		}
		
		if (left.isZeroLiteral() && right.getX().isZeroLiteral()) {
			setLeft(right.getPosSlope());
			setRight(right.getNegSlope());
		}
	}
	
	syn boolean FExp.isSemiLinear() = false;
	eq FSemiLinearExp.isSemiLinear() = true;
	
	syn FExp FSemiLinearExp.asIfExp() {
		FIfExp exp = new FIfExp(new FGeqExp(getX(), new FRealLitExp(0)),
			new FMulExp(getX(),getPosSlope()),
			new FMulExp(getX(),getNegSlope()));
		return exp;
	}
	
	/**
	 * Collects semiLinear expressions.
	 */
	coll HashSet<FSemiLinearExp> FClass.collectSemiLinearExps() 
		[new HashSet<FSemiLinearExp>()] with add root FClass;
	FSemiLinearExp contributes this
		when inEquationSection()
		to FClass.collectSemiLinearExps()
		for myFClass();
}
