/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

//import java.util.ArrayDeque;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Comparator;
import java.util.EnumSet;
import java.util.Queue;
import java.util.Set;
import java.util.HashSet;
import java.util.LinkedHashSet;
import java.util.Map;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Collections;
import java.util.Iterator;
import org.jmodelica.util.ParallelIterable;
import org.jmodelica.util.ErrorCheckType;
import org.jmodelica.util.munkres.MunkresProblem;
import org.jmodelica.util.munkres.IntegerCost;


/* This causes conflicts
import org.jmodelica.graphs.EquationSystem;
import org.jmodelica.graphs.Equation;
import org.jmodelica.graphs.Variable;
*/

/**
 * \brief Contains transformations on the flattened model which converts
 * it into a canonical form.
 */
aspect TransformCanonical {

    /**
     * \brief Transform the raw flattened model into a structured form.
     * 
     * Currently, the following operations are performed:
     *  <ul>
     *    <li> Binding equations for variables are converted into regular
     *         equations by calling genBindingEquations().
     *    <li> For each non-function algorithm:
     *         <ul>
     *                any assigned variables as outputs and any used 
     *                variables as inputs.
     *           <li> The original algorithm is replaced with a call to 
     *                the generated function.
     *         </ul>
     *    <li> The model is scalarized, i.e., all array declarations and
     *         equations are replaced by scalar declarations and equations
     *    <li> Alias variables are eliminated from the model.
     *    <li> Derivative variables are generated and inserted in the
     *         list of FVariables by calling setFDerivativeVariables().
     *    <li> Generate initial equations based on start attribute.
     *    <li> Sort dependent parameters.
     *  </ul>
     */

    /**
     *  transformCanonicalBase contains all transformation that should be
     *  done by both the Modelica and the Optimica compilers.
     */
    public void FClass.transformCanonicalBase() {
        Transformation[] transformations = new Transformation[] {
            new enableIfEquationElimination(),
            new addStateInitialEquationsIfSet(),
            new enableArrayAccessRewrite(),
            new genAlgorithmFunctionsIfSet(),
            new genBindingEquations(),
            new scalarize(),
            new MakeReinitedVarsStates(),
            new enableIfEquationElimination(),
            new extractEventGeneratingExps(),
            new transformAlgorithms(),
            new enableWhenClauseRewrite(),
            new propagateResidualPairs(),
            new genInitArrayStatements(),
            new functionInliningIfSet(),
            setFDerivativeVariables,
            new addFPreVariables(),
            new enableIfEquationRewrite(),
            aliasElimination,
            new variabilityPropagationIfSet(),
            aliasElimination,
            new evaluateAsserts(),
            new enableSemiLinearRewrite(),
            new eliminateEqualSwitches(),
            new genInitialEquations(),
            new setFDerivativeVariablesPreBLT(),
            new propagateNonFixedParameters(),
            new sortDependentParameters(),
            new addRuntimeOptionParameters()
        };
        for (Transformation t : transformations)
            t.apply();
    }

	public void FClass.transformCanonicalCleanup() {
		removeUnusedFunctions();
	    root().flushAllRecursive();
		for (FRecordDecl rec : getFRecordDecls())
			rec.clearBindingEquations();
	}
	
	public class FClass {
	    
	    /**
	     * Base class for transformations on the flat tree.
	     */
    	public abstract class Transformation {
    	    
    	    private String option;
    	    
    	    /**
    	     * Create a transformation with default settings:
    	     * <ul>
    	     * <li>Not coupled to a compiler option.</li>
    	     * </ul>
    	     */
    	    public Transformation() {
    	        this(null);
    	    }
    	    
    	    /**
    	     * Create a transformation with specific settings.
    	     * 
    	     * @param option  boolean option the transfomation depends on (null for none)
    	     */
    	    public Transformation(String option) {
    	        this.option = option;
    	    }
    	    
    	    /**
    	     * Perform the transformation.
    	     */
    	    public abstract void perform();
    	    
    	    /**
    	     * Determine if this transformation should be perfomed.
    	     * 
    	     * Defaults to true if this transformation does not depend on an option or the option is true.
    	     */
    	    public boolean active() {
    	        return (option == null) || root().options.getBooleanOption(option);
    	    }
    	    
    	    /**
    	     * The name of this transformation.
    	     * 
    	     * Defaults to the name of the class.
    	     */
    	    public String name() {
    	        return getClass().getSimpleName();
    	    }
    	    
    	    /**
    	     * Apply this transformation, if active.
    	     * 
    	     * Subclasses should not override this method.
    	     */
    	    public void apply() {
    	        if (active()) {
    	            try {
            	        beginStep(name());
            	        log.info("Applying transformation: " + name() + "...");
            	        perform();
    	            } finally {
            	        completedTransformationSteps++;
    	                endStep(name());
    	            }
        	        generateStepMof(name());
    	        }
    	    }
    	    
    	}
    	
	}

	
    /**
     * Generate a .mof file with the current flat tree.
     */
    public void FClass.generateStepMof(String stepName) {
        if (root().options.getBooleanOption("log_transformation_steps")) {
            TRANSFORMATION_STEP_DIR.mkdir();
            String fileName = String.format("%02d_%s.mof", completedTransformationSteps, stepName);
            File file = new File(TRANSFORMATION_STEP_DIR, fileName);
            log.debug("Writing flat tree after step " + stepName + " to " + fileName);
            try {
                CodeStream out = new CodeStream(file);
                prettyPrint(out, "");
                out.close();
            } catch (FileNotFoundException e) {
                log.warning("Failed to write step info to file " + file);
            }
        }
    }
    
    private static final File FClass.TRANSFORMATION_STEP_DIR = new File("transformation_steps");
    
	private int FClass.completedTransformationSteps = 0;
	
	/**
	 * After scalarization, binding expressions on members of record declarations are no longer needed. 
	 */
	public void FRecordDecl.clearBindingEquations() {
		for (FVariable fv : getFVariables())
			fv.setBindingExpOpt(new Opt());
	}
	

	public void FClass.transformCanonical() {
		beginStep("transformCanonical()");
	
		transformCanonicalBase();
	
		if (root().options.getBooleanOption("automatic_add_initial_equations")) {
			// Equations are added as part of this this method
			computeMatchingsAndBLT();
			computeInteractiveFMUIfSet();
			daeBLT.complianceCheck(ErrorCheckType.COMPILE);
		}
	
		root().flushAllRecursive();	
		transformCanonicalCleanup();

		endStep("transformCanonical()");
	}
	
	syn lazy Set<FVariable> FVariable.initDependsOn() {
		if (myDAEInitEquationBlock() != null)
			return myDAEInitEquationBlock().dependsOn();
		else
			return new LinkedHashSet<FVariable>();
	}
		
	syn lazy Set<FVariable> FVariable.dependsOn() {
		if (myDAEEquationBlock() != null)
			return myDAEEquationBlock().dependsOn();
		else
			return new LinkedHashSet<FVariable>();
	}

	syn lazy AbstractEquationBlock FVariable.myDAEEquationBlock() = 
		myFClass().getDAEFVariableEquationBlockMap().get(this);

	private HashMap<FVariable,AbstractEquationBlock> FClass.daeFVariableEquationBlockMap = null;
	syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEFVariableEquationBlockMap() {
		if (daeFVariableEquationBlockMap == null) 
			computeMatchingsAndBLT();
		return daeFVariableEquationBlockMap;
	}

	syn lazy AbstractEquationBlock FVariable.myDAEInitEquationBlock() = 
		myFClass().getDAEInitFVariableEquationBlockMap().get(this);
	
	private HashMap<FVariable,AbstractEquationBlock> FClass.daeInitFVariableEquationBlockMap = null;	
	syn HashMap<FVariable,AbstractEquationBlock> FClass.getDAEInitFVariableEquationBlockMap() {
		if (daeInitFVariableEquationBlockMap == null) 
			computeMatchingsAndBLT();
		return daeInitFVariableEquationBlockMap;
	}

	private ArrayList<FAbstractEquation> FClass.daeUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEUnmatchedEquations() { 
		if (daeUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeUnmatchedVariables;
	}	

	private ArrayList<FAbstractEquation> FClass.daeInitUnmatchedEquations = null;
	syn ArrayList<FAbstractEquation> FClass.getDAEInitUnmatchedEquations() { 
		if (daeInitUnmatchedEquations == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedEquations;
	}	

	private ArrayList<FVariable> FClass.daeInitUnmatchedVariables = null;
	syn ArrayList<FVariable> FClass.getDAEInitUnmatchedVariables() { 
		if (daeUnmatchedVariables == null) 
			computeMatchingsAndBLT();
		return daeInitUnmatchedVariables;
	}	

	private BLT FClass.daeBLT = null;
	syn BLT FClass.getDAEBLT() {
		if (daeBLT == null) 
			computeMatchingsAndBLT();
		return daeBLT;
	}

	private StructuredBLT FClass.daeStructuredBLT = null;
	syn StructuredBLT FClass.getDAEStructuredBLT() {
		if (daeStructuredBLT == null) 
			computeMatchingsAndBLT();
		return daeStructuredBLT;
	}
	
	private BLT FClass.daeInitBLT = null;	
	syn BLT FClass.getDAEInitBLT() {
		if (daeInitBLT == null) 
			computeMatchingsAndBLT();
		return daeInitBLT;
	}	
	
	/**
	 * The symbolic equation sorting and canonicalization proceeds in the
	 * following steps:
	 * 
	 * - The DAE system consisting of the DAE equations with algebraics and
	 *   derivatives treated as unknowns is matched to obtain a pairing
	 *   between equations and variables. Discrete and continuous algebraic
	 *   variables are treated equally in this respect.
	 *
	 * - If a perfect matching is found, i.e., if there are no unmatched
	 *   equations or variables, the BLT algoritm is applied to compute
	 *   a sequence of stron components, corresponding to systems of equations.
	 * 
	 * - Having computed a matching and transformed the DAE into BLT form, 
	 *   the DAE initialization system is analyzed:
	 *    - The differentiated variables are added to the set of unknown 
	 *      variables of the system.
	 *    - The pre variables are added to the set of unknown variables of the
	 *      system.
	 *    - The initial equations are added to the set of equations of the 
	 *      system. This includes equations resulting from start values with
	 *      a corresonding fixed attribute set to true.
	 *    - When clauses are analyzed: if a when clause is explicitly enabled by
	 *      the initial() operator (whatever this means...), the when clause 
	 *      is excluded, otherwhise the equation pre(x) = x is added, where x 
	 *      is the variable that is solved for in the when clause.
	 *      
	 * - The matching algoritm is applied to the updated graph. Notice that it
	 *   is important that the result of the DAE matching is used as a starting
	 *   point: using this approach, derivatives and algebraics will remain
	 *   matched if possible and additional equations are added, if needed,
	 *   for differentiated variables. If there are 
	 *   unmatched equations, the transformation sequence terminates. If there
	 *   are unmatched variables, then additional initial equations are added 
	 *   in order to obtained a balanced system. For continuous variables, 
	 *   equations such as x = x.start are added, whereas for discrete variables
	 *   equations such as pre(x) = x.start are added.
	 *
	 *  - Finally, the BLT algorithm is applied to the resulting perfect
	 *    matchibng for the DAE initialization system.
     */	
	public void FClass.computeMatchingsAndBLT() {
        computeMatchingsAndBLT(false);
    }
	
	
	public void FClass.computeMatchingsAndBLT(boolean duringInteractiveFMU) {
		beginStep("computeMatchingsAndBLT()");
		computeMatchingsAndBLTWrapped(duringInteractiveFMU);
		endStep("computeMatchingsAndBLT()");
	}
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_NORMAL = 
			EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
					   BiPGraph.VarType.ALGEBRAIC_VARIABLES);
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_REAL = 
			EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
					   BiPGraph.VarType.CONTINUOUS_ALGEBRAIC_VARIABLES);
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_INIT = 
			EnumSet.of(BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
					   BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
					   BiPGraph.VarType.NON_FIXED_PARAMETERS);
	
	private static final EnumSet<BiPGraph.VarType> FClass.VAR_TYPES_ALL = 
			EnumSet.of(BiPGraph.VarType.DERIVATIVE_VARIABLES, 
					   BiPGraph.VarType.ALGEBRAIC_VARIABLES, 
					   BiPGraph.VarType.DIFFERENTIATED_VARIABLES, 
					   BiPGraph.VarType.DISCRETE_PRE_VARIABLES, 
					   BiPGraph.VarType.NON_FIXED_PARAMETERS);
	
	private void FClass.computeMatchingsAndBLTWrapped(boolean duringInteractiveFMU) {
        // Make sure that we don't do this if any errors have been reported
        breakOnErrors();

        log.info("Flat tree before index reduction and BLT:");
		log.info(this);

		daeBLT = new BLT();
		daeStructuredBLT = new StructuredBLT(this);
		daeInitBLT = new BLT();		
		daeUnmatchedEquations = new ArrayList<FAbstractEquation>();
		daeUnmatchedVariables = new ArrayList<FVariable>();
		daeInitUnmatchedEquations = new ArrayList<FAbstractEquation>();
		daeInitUnmatchedVariables = new ArrayList<FVariable>();
		daeFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();
		daeInitFVariableEquationBlockMap = new HashMap<FVariable,AbstractEquationBlock>();
			
		BiPGraph g = new BiPGraph();
		
		Eq eqn = null;
		Var v = null;		
		
		// First try a global matching with all variables
		g.addVariables(this, VAR_TYPES_NORMAL);
		g.addEquations(equations(), VAR_TYPES_NORMAL,"eq_",1);
		
		log.info(g);
		g.maximumMatching(true);
		log.info("DAE system");
		log.info(g.printMatchingObj());
			
		for (Var var : g.getUnmatchedVariables()) {
			daeUnmatchedVariables.add(var.getVariable());
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeUnmatchedEquations.add(ee.getEquation());
		}
	
		// If no complete matching found, then try index reduction
		if (!g.isComplete()) {
			g = reduceIndex();
			breakOnErrors();
			if (g == null)
				return;
		} 
			
		// Perform BLT
		if (root().options.getBooleanOption("equation_sorting") && g.isComplete()) {	
			try {
				daeBLT = g.computeBLT(root().options, duringInteractiveFMU);
			} catch (BLTException e) {
				error(e.getMessage());
				return;
			}
			for (AbstractEquationBlock eb : daeBLT) {
				for (FVariable fv : eb.allVariables()) {
					daeFVariableEquationBlockMap.put(fv,eb);
				}
			}
			for (FAbstractEquation e : equations())
				if (e.numScalarEquations() == 0)
					daeBLT.add(e.createSimpleEquationBlock(Collections.<FVariable>emptyList(), null, Solvability.ANALYTICALLY_SOLVABLE));
			daeStructuredBLT = new StructuredBLT(this, daeBLT);
			daeStructuredBLT.errorCheck();
			log.info(daeStructuredBLT);
			
			log.info(daeBLT);
		
		}
		
		// Find matching for the initialization system
		g.addVariables(this, VAR_TYPES_INIT);
		g.addEquations(equations(), VAR_TYPES_INIT, "eq_",1);
		g.isInitialSystem();

		// Replace when equations
		java.util.List<FAbstractEquation> equationsToReplace = new ArrayList<FAbstractEquation>();
		for (FAbstractEquation e : equations()) {
			if (e.replacedAtInitialization()) {
				equationsToReplace.add(e);
			}
		}		
		
		// Loop over all equations to replace
		for (FAbstractEquation equationToReplace : equationsToReplace) {
						
			// How many equations are there in this when clause?
			List<FAbstractEquation> newEquations = equationToReplace.getInitialEquations();
		
		    // Put the Equations in an ArrayList rather than a List
		    // TODO: There are probably more elegant ways to do this...
			java.util.List<FAbstractEquation> newEquations_ = new ArrayList<FAbstractEquation>();
			for (FAbstractEquation e : newEquations) {
				newEquations_.add(e);	
			}

			 // - equationToReplace is an FAbstractEquation that should be replaced
			 // - newEquations contains the new equations that replaces the equationToReplace
			 // - Note that newEquations may contain several equations  
			 
			java.util.List<Eq> eq_list = new ArrayList<Eq>(g.getEquations(equationToReplace));
			
			for (Eq eqq : eq_list) {
				g.removeEquation(eqq);	
			}
			
			if (!eq_list.isEmpty())
				g.addEquations(newEquations_, VAR_TYPES_ALL, eq_list.get(0).getName() + "_", 1);
		}		
	
		log.info(g);
		

		g.addEquations(initialEquations(), VAR_TYPES_ALL, "eq_", g.getEquations().size() + 1);

		log.info(g);
		g.maximumMatching(false);	
		log.info("DAE initial ");
		log.info(g.printMatchingObj());

		// Add initial equations if needed
		if (g.getUnmatchedEquations().isEmpty() && root().options.getBooleanOption("automatic_add_initial_equations")) {
			for (Var var : g.getUnmatchedVariables()) {	
				FVariable fv = var.getVariable();
				FIdUseExp lhs = fv.isDiscrete() ? fv.createFPreExp() : fv.createUseExp();
				FExp rhs = fv.startAttributeSet() ? fv.startAttributeExp() : fv.type().zeroLiteral();
				FEquation fe = new FEquation(lhs, rhs);
				addFInitialEquation(fe);
				
				eqn = g.addEquation("eq_" + (g.getEquations().size() + 1), fe, 0, fe.variability());
				v = g.getVariable(lhs.name());
				g.addEdge(eqn,v);
			}
			root().flushAllRecursive();

			g.maximumMatching(false);	
			log.info("DAE initial after addition of initial equations");
			log.info(g);
			log.info(g.printMatchingObj());

		}

		for (Var var : g.getUnmatchedVariables()) {
			daeInitUnmatchedVariables.add(var.getVariable());
		}

		for (Eq ee : g.getUnmatchedEquations()) {
			daeInitUnmatchedEquations.add(ee.getEquation());
		}
		
		// TODO: If no complete matching found, then try index reduction
		collectErrors(ErrorCheckType.COMPILE);
		breakOnErrors();
		
		if (root().options.getBooleanOption("equation_sorting") && g.isComplete()) {
			g.tarjanReset();
			try {
				daeInitBLT = g.computeBLT(root().options, duringInteractiveFMU);
			} catch (BLTException e) {
				error(e.getMessage());
				return;
			}
			for (AbstractEquationBlock eb : daeInitBLT) {
				for (FVariable fv : eb.allVariables()) {
					daeInitFVariableEquationBlockMap.put(fv,eb);
				}
			}	
			daeInitBLT.errorCheck();
			log.info(daeInitBLT);
		}
	}	
	////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////			
	
	public void FClass.checkStructure() {
		if (root().options.getBooleanOption("enable_structural_diagnosis")) {
			StringBuffer err_str = new StringBuffer("The system is structurally singular. ");
			if (writeUnmatchedElements(err_str, getDAEUnmatchedVariables(), getDAEUnmatchedEquations())) 
				error(err_str.toString());
			err_str = new StringBuffer("The initialization system is structurally singular. ");
			if (writeUnmatchedElements(err_str, getDAEInitUnmatchedVariables(), getDAEInitUnmatchedEquations())) 
				error(err_str.toString());
		}
	}
	
	public static boolean FClass.writeUnmatchedElements(StringBuffer str, Collection<FVariable> unmatchedVariables, Collection<FAbstractEquation> unmatchedEquations) {
		boolean unbalanced = false;
		if (!unmatchedVariables.isEmpty()) {
			str.append("The following varible(s) could not be matched to any equation:\n");
			for (FVariable fv : unmatchedVariables) {
				str.append("     " + fv.name());
				str.append("\n");
			}
			unbalanced = true;
		}
		
		if (!unmatchedEquations.isEmpty()) {
			if (unbalanced) 
				str.append("\n  ");
			str.append("The following equation(s) could not be matched to any variable:\n");
			for (FAbstractEquation ee : unmatchedEquations) {
				str.append(ee.prettyPrint("    "));
				str.append("\n");
			}
			unbalanced = true;
		}
		return unbalanced;
	}


    public class FClass {
    	/**
    	 * Generate array initialization statements for unknown function arrays.
    	 */
        public class genInitArrayStatements extends Transformation {
            public void perform() {
                for (FFunctionDecl ffd : getFFunctionDecls()) {
                    ffd.genInitArrayStatements();
                    ffd.sortBindingAssignments();
                }
            }
        }
    }
	
	public void FFunctionDecl.genInitArrayStatements() {
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable ffv : getFFunctionVariables())
			ffv.genInitArrayStatements(stmts);
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmts.add(stmt);
		getFAlgorithm().setFStatementList(stmts);
	}

	protected boolean FFunctionVariable.hasInitArrayStmt = false;

	public void FFunctionVariable.genInitArrayStatements(List<FStatement> stmts) {}
	
	public void FFunctionArray.genInitArrayStatements(List<FStatement> stmts) {
		if (size().isUnknown() && !isInput() && !isOutput()) {
			FInitArrayStmt stmt = new FInitArrayStmt(createUseExp());
			stmt.shouldBeSorted = true;
			stmts.add(stmt);
			hasInitArrayStmt = true;
		}
	}

	
	public void FFunctionDecl.sortBindingAssignments() {
		Map<String,FStatement> map = new LinkedHashMap<String,FStatement>();
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmt.addToSortingMap(map);
		
		List<FStatement> stmts = new List<FStatement>();
		while (!map.isEmpty()) 
			map.values().iterator().next().addSortedByAssignmentOrder(stmts, map);
		
		for (FStatement stmt : getFAlgorithm().getFStatements())
			if (!stmt.shouldBeSorted)
				stmts.add(stmt);
		getFAlgorithm().setFStatementList(stmts);
	}
	
	public void FStatement.addToSortingMap(Map<String,FStatement> map) {
		if (shouldBeSorted) {
			for (String name : sortingAssignedNames()) {
				FStatement old = map.get(name);
				if (old != null && old != this)
					extraSortingDependencies().add(old);
				map.put(name, this);
			}
		}
	}
	
	
	private boolean FStatement.isBeingSorted = false;
	private boolean FStatement.addedDuringSorting = false;
	
	public void FStatement.addSortedByAssignmentOrder(
			List<FStatement> stmts, Map<String,FStatement> map) {
		if (isBeingSorted) 
			throw new CircularBindingExpressionException();
		isBeingSorted = true;
		
		for (String depName : sortingDependencies()) {
			FStatement dep = map.get(depName);
			if (dep != null && dep != this)
				dep.addSortedByAssignmentOrder(stmts, map);
		}
		for (FStatement dep : extraSortingDependencies()) {
			if (!dep.addedDuringSorting)
				dep.addSortedByAssignmentOrder(stmts, map);
		}
		
		stmts.add(this);
		addedDuringSorting = true;
		for (String name : sortingAssignedNames())
			map.remove(name);
		
		isBeingSorted = false;
	}
	
	public class CircularBindingExpressionException extends RuntimeException {}
	
	private Set<FStatement> FStatement.extraSortingDependencies = null;
	private Set<FStatement> FStatement.extraSortingDependencies() {
		if (extraSortingDependencies == null)
			extraSortingDependencies = new LinkedHashSet<FStatement>();
		return extraSortingDependencies;
	}
    private boolean FStatement.hasExtraSortingDependencies() {
        return extraSortingDependencies != null;
    }
	
	
	syn lazy Set<String> FStatement.sortingAssignedNames() = Collections.<String>emptySet();
	eq FAssignStmt.sortingAssignedNames()      = Collections.singleton(getLeft().name());
	eq FInitArrayStmt.sortingAssignedNames()   = 
		Collections.singleton("size(" + getFIdUseExp().name() + ")");
	eq FForStmt.sortingAssignedNames()         = sortingAssignedNames(getForStmts());
	eq FWhileStmt.sortingAssignedNames()       = sortingAssignedNames(getWhileStmts());
	eq FFunctionCallStmt.sortingAssignedNames() {
		Set<String> res = new LinkedHashSet<String>(getNumLeft());
		for (FFunctionCallLeft left : getLefts())
			left.sortingAddNamesUsed(res);
		return res;
	}
	eq FIfStmt.sortingAssignedNames() {
		Set<String> res = new LinkedHashSet<String>();
		for (FIfWhenClause iwc : getFIfWhenClauses())
			res.addAll(iwc.sortingAssignedNames());
		for (FStatement stmt : getElseStmts())
			res.addAll(stmt.sortingAssignedNames());
		return res;
	}
	
	syn Set<String> FIfWhenClause.sortingAssignedNames() = 
		FStatement.sortingAssignedNames(getFStatements());
	
	public static Set<String> FStatement.sortingAssignedNames(List<FStatement> stmts) {
		Set<String> res = new LinkedHashSet<String>();
		for (FStatement stmt : stmts)
			res.addAll(stmt.sortingAssignedNames());
		return res;
	}
	
	
	syn lazy Set<String> FStatement.sortingDependencies() = Collections.<String>emptySet();
	eq FAssignStmt.sortingDependencies()       = 
		getRight().sortingAddNamesUsed(baseSortingDependencies());
	eq FInitArrayStmt.sortingDependencies()    = 
		getFIdUseExp().myFV().size().sortingAddNamesUsed(new LinkedHashSet<String>());
	eq FFunctionCallStmt.sortingDependencies() = 
		getCall().sortingAddNamesUsed(baseSortingDependencies());
	eq FForStmt.sortingDependencies()          = 
		addCompoundStmtSortingDependencies(baseSortingDependencies(), getIndex(), getForStmts());
	eq FWhileStmt.sortingDependencies()        = 
		addCompoundStmtSortingDependencies(baseSortingDependencies(), getTest(), getWhileStmts());
	eq FIfStmt.sortingDependencies() {
		Set<String> res = new LinkedHashSet<String>();
		for (FIfWhenClause iwc : getFIfWhenClauses())
			res.addAll(iwc.sortingDependencies());
		for (FStatement stmt : getElseStmts())
			res.addAll(stmt.sortingDependencies());
		return res;
	}
	
	syn Set<String> FIfWhenClause.sortingDependencies() = 
		FStatement.addCompoundStmtSortingDependencies(
				new LinkedHashSet<String>(), getTest(), getFStatements());
	
	protected Set<String> FStatement.baseSortingDependencies() {
		Set<String> res = new LinkedHashSet<String>();
		for (String name : sortingAssignedNames()) 
			res.add("size(" + name + ")");
		return res;
	}
	
	public static Set<String> FStatement.addCompoundStmtSortingDependencies(
			Set<String> set, ASTNode head, List<FStatement> body) {
		head.sortingAddNamesUsed(set);
		for (FStatement stmt : body)
			set.addAll(stmt.sortingDependencies());
		return set;
	}
	
	public Set<String> ASTNode.sortingAddNamesUsed(Set<String> set) {
		for (ASTNode n : this)
			n.sortingAddNamesUsed(set);
		return set;
	}
	
	public Set<String> FIdUse.sortingAddNamesUsed(Set<String> set) {
		if (!myFV().isUnknown())
			set.add(name());
		return super.sortingAddNamesUsed(set);
	}
	
	public Set<String> FSizeExp.sortingAddNamesUsed(Set<String> set) {
		Set<String> temp = new LinkedHashSet<String>();
		super.sortingAddNamesUsed(temp);
		for (String name : temp) {
			if (!name.startsWith("size("))
				name = "size(" + name + ")";
			set.add(name);
		}
		return set;
	}
	
	public Set<String> Size.sortingAddNamesUsed(Set<String> set) {
		return set;
	}
	
	public Set<String> MutableSize.sortingAddNamesUsed(Set<String> set) {
		for (FExp exp : exps)
			if (exp != null)
				exp.sortingAddNamesUsed(set);
		return set;
	}
	
	
	

    public class FClass {
        /**
         * Convert variable binding equations into regular equations.
         */
        public class genBindingEquations extends Transformation {
            public void perform() {
                FQName empty = new FQNameEmpty();
                for (FVariable fv : getFVariables()) 
                    if (!fv.isConstant()) 
                        fv.genBindingEquations(FClass.this, empty);
                for (FFunctionDecl ffd : getFFunctionDecls())
                    ffd.genBindingAssignments();
//              flush();
                root().flushAllRecursive();
           }
        }
    }
	
	public void FFunctionDecl.genBindingAssignments() {
		// TODO: To support Modelica 3.3, we need to sort the assignments
		List<FStatement> stmts = new List<FStatement>();
		for (FFunctionVariable ffv : getFFunctionVariables())
			ffv.genBindingAssignments(stmts);
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmts.add(stmt);
		getFAlgorithm().setFStatementList(stmts);
	}
	
	/**
	 * Flag that controls if this statement should be a part of the set of statements at 
	 * the beginning of a function that are generated from variable declarations, and 
	 * should be sorted to ensure assignment before use among them.
	 */
	public boolean FStatement.shouldBeSorted = false;
	
	public void FFunctionVariable.genBindingAssignments(List<FStatement> stmts) {
		if (!isInput() && hasBindingExp()) {
			FAssignStmt stmt = new FAssignStmt(createUseExp(), getBindingExp());
			stmt.shouldBeSorted = true;
			stmts.add(stmt);
			setBindingExpOpt(new Opt());
		}
	}
	
	
	public FExp FVariable.selectBindingFExp(FAttribute attr) {
		if (attr != null && attr.hasValue())
			return attr.getValue();
		else if (hasBindingExp())
			return getBindingExp();
		else
			return null;
	}
	
	public FQName FVariable.createNameForBindingEquation(FQName prefix, FAttribute attr) {
		FArraySubscripts fas = null;
		if (isArray()) {
			if (attr != null)
				attr = attr.findAttribute(FAttribute.SIZE);
			Size size = (attr != null && attr.hasValue()) ? new MutableSize(attr.getValue()) : size();
			fas = size.rangeFArraySubscripts();
		}
		return prefix.copyAndAppend(getFQName(), fas);
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix) {
		genBindingEquations(fc, prefix, null, prefix, false);
	}
	
	public void FVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, 
	        FQName attrPrefix, boolean param) {
		FExp bexp = selectBindingFExp(attr);
		boolean isAttr = attr != null && attr.hasValue();
		param = param || isParameter();
		if (bexp != null && !(param && bexp.isIndependentParameterExp())) {
            FQName bexpPrefix = isAttr ? attrPrefix : prefix;
			if (!inRecord())
				setBindingExpOpt(new Opt());
			genBindingEquationsFromExp(fc, prefix, attr, bexp, bexpPrefix, param);
			if (isAttr)
				attr.setValueOpt(new Opt());
		}
	}
	
	public void FRecordVariable.genBindingEquations(FClass fc, FQName prefix, FAttribute attr, 
	        FQName attrPrefix, boolean param) {
		/* TODO: Perhaps this is the wrong approach? Could we instead convert binding expressions 
		 *       for records into attributes on the variable, and sort it out into binding expressions 
		 *       during scalarization?
		 */
		FExp bexp = selectBindingFExp(attr);
		if (bexp != null) {
			super.genBindingEquations(fc, prefix, attr, attrPrefix, param);
		} else {
			List<FAttribute> attrs = selectFAttributeList(attr);
			if (attrs == getFAttributes())
			    attrPrefix = prefix;
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				if (!comp.isConstant()) {
					FAttribute cAttr = findMatching(attrs, comp.name());
					comp.genBindingEquations(fc, name, cAttr, attrPrefix, param || isParameter());
				}
			}
		}
	}
	
	protected void FVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, FQName bexpPrefix, boolean param) {
		FQName name = createNameForBindingEquation(prefix, attr);
		param = param || isParameter();
		FEquation feq = new FEquation(new FIdUseExp(name), bexp.reflattenBindingExp(bexpPrefix));
		if (param)
			fc.addFParameterEquation(feq);
		else
			fc.addFEquation(feq);	
	}
	
	protected void FRecordVariable.genBindingEquationsFromExp(FClass fc, FQName prefix, 
			FAttribute attr, FExp bexp, FQName bexpPrefix, boolean param) {
		/* If we get here, then we won't be able to leave expressions for independent parameters 
		 * as binding expressions on the FVariable - we'll have to clean that up later. Since it 
		 * has to be done after records are broken into separate variables, we'll do it during 
		 * parameter equation sorting.
		 */
		if (bexp.canExtractRecordComponents()) {
			List<FAttribute> attrs = selectFAttributeList(attr);
			FQName name = createNameForBindingEquation(prefix, attr);
			for (FVariable comp : myFRecordDecl().getFVariables()) {
				if (!comp.isConstant()) {
					FAttribute cAttr = findMatching(attrs, comp.name());
					FExp cExp = bexp.dynamicFExp(bexp.extractRecordFExp(comp.name()));
					comp.genBindingEquationsFromExp(fc, name, cAttr, cExp, bexpPrefix, param || isParameter());
				}
			}
		} else {
			super.genBindingEquationsFromExp(fc, prefix, attr, bexp, bexpPrefix, param);
		}
	}
	
	public FExp FExp.reflattenBindingExp(FQName prefix) {
		FExp res = dynamicFExp(fullCopy());
		FRecordDecl decl = containingRecordDecl();
		if (decl != null)
			res.prefixInternalUses(prefix, decl);
		return res;
	}
	
	public void FExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		for (FExp e : childFExps())
			e.prefixInternalUses(prefix, decl);
	}
	
	public void FIdUseExp.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		FQName fqn = getFIdUse().getFQName();
		fqn.prefixInternalUses(prefix, decl);
		if (decl == lookupFV(fqn.copyFirstPrefix()).containingRecordDecl()) 
			getFIdUse().setFQName(prefix.copyAndAppend(fqn));
	}
	
	public void FQName.prefixInternalUses(FQName prefix, FRecordDecl decl) {}
	
	public void FQNameFull.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		for (FQNamePart p : getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.prefixInternalUses(prefix, decl);
	}
	
	public void FSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {}
	
	public void FExpSubscript.prefixInternalUses(FQName prefix, FRecordDecl decl) {
		getFExp().prefixInternalUses(prefix, decl);
	}
	
	protected List<FAttribute> FRecordVariable.selectFAttributeList(FAttribute attr) {
		if (attr != null && attr.getFAttributes().getNumChild() > 0)
			return attr.getFAttributes();
		else
			return getFAttributes();
	}
	
	syn boolean FExp.canExtractRecordComponents()      = false;
	eq FIdUseExp.canExtractRecordComponents()          = true;
	eq FRecordConstructor.canExtractRecordComponents() = true;
	eq FArray.canExtractRecordComponents() {
		for (FExp e : childFExps())
			if (!e.canExtractRecordComponents())
				return false;
		return true;
	}
	eq FAbstractCat.canExtractRecordComponents(){
		for (FExp e : childFExps())
			if (!e.canExtractRecordComponents())
				return false;
		return true;
	}
	
	/**
	 * \brief Create an FExp that represents a specific component of this record expression.
	 * 
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.extractRecordFExp(String suffix) {
		throw new UnsupportedOperationException("Can't extract record component of " + getClass().getSimpleName());
	}
	
	public FExp FIdUseExp.extractRecordFExp(String suffix) {
		FQName name = getFIdUse().getFQName().copyAsFQNameFull().append(suffix);
		return new FIdUseExp(name);
	}
	
	public FExp FRecordConstructor.extractRecordFExp(String suffix) {
		return getArg(getRecord().myFRecordDecl().indexOf(suffix)).fullCopy();
	}
	
	public FExp FArray.extractRecordFExp(String suffix) {
		FArray res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FAbstractCat.extractRecordFExp(String suffix) {
		FInfArgsFunctionCall res = createEmptyNode();
		for (FExp e : getFExps())
			res.addFExp(e.extractRecordFExp(suffix));
		return res;
	}
	
	public FExp FCatExp.extractRecordFExp(String suffix) {
		FCatExp res = (FCatExp) super.extractRecordFExp(suffix);
		res.setDim(getDim().fullCopy());
		return res;
	}
	
	public FExp FNoEventExp.extractRecordFExp(String suffix) {
		return createNode(getFExp().extractRecordFExp(suffix));
	}

    public class FClass {
        public class genAlgorithmFunctionsIfSet extends Transformation {
            public genAlgorithmFunctionsIfSet() {
                super("algorithms_as_functions");
            }
            
            public void perform() {
                genAlgorithmFunctions();
            }
        }
    }
	
	/**
	 * \brief Generate functions from algorithms.
	 */
	public void FClass.genAlgorithmFunctions() {
		for (FAlgorithm alg : myAlgorithms()) {
			// Create function declaration
			List<FFunctionVariable> vars = new List<FFunctionVariable>();
			FQName funcName = new FQNameString(alg.generateFunctionName());
			
			// - Find inputs
			ArrayList<FVariable> inVars = new ArrayList<FVariable>();
			ArrayList<FFunctionVariable> bothInVars = new ArrayList<FFunctionVariable>();
			for (FIdUseExp use : alg.FIdUseExpsInRHS()) {
				FAbstractVariable fv = use.myFV();
				if (!fv.isUnknown() && !inVars.contains(fv) && !fv.isForIndex()) {
					inVars.add((FVariable) fv);
					bothInVars.add(null);
				}
			}
			
			// - Create outputs, add to vars and locate those that are inputs as well
			ArrayList<FVariable> outVars = new ArrayList<FVariable>();
			for (FIdUseExp use : alg.FIdUseExpsInLHS()) {
				if (!use.myFV().isUnknown() && !outVars.contains(use.myFV())) {
					FVariable fv = (FVariable) use.myFV();
					FFunctionVariable ffv = fv.createFFunctionOutput();
					vars.add(ffv);
					outVars.add(fv);
					int i = inVars.indexOf(fv);
					if (i >= 0) 
						bothInVars.set(i, ffv);
				}
			}
			
			// - Create inputs, add to vars and update inputs and outputs that are the same
			ArrayList<FVariable> allVars = new ArrayList<FVariable>();
			allVars.addAll(inVars);
			allVars.addAll(outVars);
			
			for (int i = 0; i < inVars.size(); i++) {
				FVariable fv = inVars.get(i);
				FFunctionVariable ffv = fv.createFFunctionInput();
				vars.add(ffv);
				if (bothInVars.get(i) != null) {
					
					// Generate a new (unique) name for variable
					boolean nameExists = true;
					String name = null;
					for (int j = 0; nameExists; j++) {
						name = fv.name() + "_" + j;
						nameExists = false;
						for (FVariable fv2 : allVars)
							if (fv2.name().equals(name))
								nameExists = true;
					}
					
					// Rename input
					FQName fqn = new FQNameString(name);
					ffv.setFQName(fqn);
					
					// Create and add binding expression for output
					bothInVars.get(i).setBindingExp(fqn.createFIdUseExp());
				}
			}
			
			// Create function call equation and replace algorithm
			List<FExp> args = new List<FExp>();
			for (int i = 0; i < inVars.size(); i++) 
				args.add(inVars.get(i).createAlgorithmArgument(bothInVars.get(i) != null));
			Size[] sizes = new Size[outVars.size()];
			for (int i = 0; i < outVars.size(); i++)
				sizes[i] = outVars.get(i).size();
			FFunctionCall call = new FFunctionCall(funcName.createFIdUse(), args, sizes);
			List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
			for (FVariable fv : outVars)
				lefts.add(fv.getFQName().createFFunctionCallLeft());
			replaceEquation(alg, new FFunctionCallEquation(lefts, call));
			
			// Add return statement, create function declaration and add it to FClass 
			alg.addFStatement(new FReturnStmt());
			addFFunctionDecl(new FFunctionDecl(funcName, vars, alg, new Opt(), SMOOTH_ORDER_ANNOTATION_DEFAULT));
		}
	}

	public class FClass {
		public class transformAlgorithms extends Transformation {
			public void perform() {
				AlgorithmTransformer.visit(algorithms(), new IndicatorAlgoTransformer());
				flushAllRecursive();
			}
		}
	}
	
	/**
	 * \brief Visitor pattern for inserting new statements in an algorithm
	 * <code>transform(FAlgorithm)</code> is called at start of algorithm
	 * <code>transform(FStatement)</code> is called at each statement
	 */
	public abstract class AlgorithmTransformer {
		private ArrayList<ArrayList<FStatement>> blocks = new ArrayList<ArrayList<FStatement>>();
		
		protected void add(FStatement stmt) {
			blocks.get(blocks.size()-1).add(stmt);
		}
		
		public static void visit(Collection<FAlgorithm> algs, AlgorithmTransformer tf) {
			for (FAlgorithm alg : algs)
				tf.visit(alg);
		}
		
		public void visit(FAlgorithm alg) {
			blocks.add(new ArrayList<FStatement>());
			if (transform(alg))
				for (FStatement stmt : alg.getFStatements())
					stmt.acceptTransform(this);
			else
				for (FStatement stmt : alg.getFStatements())
					add(stmt);
			alg.setFStatementList(new List<FStatement>(blocks.remove(blocks.size()-1)));
		}
		
		public List<FStatement> visit(List<FStatement> stmts) {
			blocks.add(new ArrayList<FStatement>());
			for (FStatement stmt : stmts)
				stmt.acceptTransform(this);
			return new List<FStatement>(blocks.remove(blocks.size()-1));
		}
		
		public void visit(FStatement stmt) {
			transform(stmt);
		}
		
		public void visit(FForStmt stmt) {
			stmt.setForStmtList(visit(stmt.getForStmts()));
			transform(stmt);
		}
		
		public void visit(FWhileStmt stmt) {
			stmt.setWhileStmtList(visit(stmt.getWhileStmts()));
			transform(stmt);
		}
		
		public void visit(FIfStmt stmt) {
			for (FIfWhenClause clause : stmt.getFIfWhenClauses()) {
				clause.setFStatementList(visit(clause.getFStatements()));
			}
			stmt.setElseStmtList(visit(stmt.getElseStmts()));
			transform(stmt);
		}
		
		public void visit(FWhenStmt stmt) {
			for (FIfWhenClause clause : stmt.getFIfWhenClauses()) {
				clause.setFStatementList(visit(clause.getFStatements()));
			}
			transform(stmt);
		}
		
		/**
		 * Returns true if other statements should be visited
		 */
		public boolean transform(FAlgorithm alg) {return true;}
		
		public void transform(FStatement stmt) {add(stmt);}
	}
	
	public void FAlgorithm.acceptTransform(AlgorithmTransformer tf)  { tf.visit(this); }
	public void FStatement.acceptTransform(AlgorithmTransformer tf)  { tf.visit(this); }
	public void FAssignStmt.acceptTransform(AlgorithmTransformer tf) { tf.visit(this); }
	public void FIfStmt.acceptTransform(AlgorithmTransformer tf)     { tf.visit(this); }
	public void FForStmt.acceptTransform(AlgorithmTransformer tf)    { tf.visit(this); }
	public void FWhileStmt.acceptTransform(AlgorithmTransformer tf)  { tf.visit(this); }
	public void FWhenStmt.acceptTransform(AlgorithmTransformer tf)   { tf.visit(this); }
	
	/**
	 * \brief Generates initial statements and indicator statements for relational expressions.
	 */
	public class IndicatorAlgoTransformer extends AlgorithmTransformer {
		public boolean transform(FAlgorithm alg) {
			// Generate indicator ntas
			for (FRelExp exp : alg.relExpInEquation())
				if (exp.dependsOn(alg.referencedFVariablesInLHS()))
					exp.genIndicator();
			// Add indicator initial statements
			for (FRelExp exp : alg.relExpInEquation())
				if (exp.hasIndicator() && exp.needsIndicatorInit())
					add(exp.indicatorInitStmt());
			return true;
		}
		
		public void transform(FStatement stmt) {
			// Add indicator stmts
			for (FRelExp exp : stmt.relExpInStmt())
				if (exp.hasIndicator())
					add(exp.indicatorStmt());
			add(stmt);
		}
	}

	syn boolean FExp.dependsOn(Collection<FVariable> fvs) {
		for (FVariable fv : lookupFVariablesInSet(findFIdUseExpsInTree()))
			if (fvs.contains(fv))
				return true;
		return false;
	}
	
	
	inh boolean FRelExp.needsIndicatorInit();
	eq Root.getChild().needsIndicatorInit()                = false;
	eq FAlgorithm.getChild().needsIndicatorInit()          = false;
	eq FForStmt.getForStmt().needsIndicatorInit()          = true;
	eq FIfStmt.getElseStmt().needsIndicatorInit()          = true;
	eq FIfWhenClause.getFStatement().needsIndicatorInit()  = true;
	eq FWhileStmt.getWhileStmt().needsIndicatorInit()      = true;
	
	/**
	 * \brief A reference to the FVariable set as indicator for a FRelExp
	 * Only used in algorithms
	 */
	syn nta Opt<FIdUseExp> FRelExp.getIndicatorOpt() = new Opt<FIdUseExp>();
	
	/**
	 * \brief Creates an indicator for this FRelExp
	 */
	public void FRelExp.genIndicator() {
		FVariable v = new FRealVariable(new FPublicVisibilityType(), fContinuous(), new FQNameFull(calcTempVarName()));
		myFClass().addFVariable(v);
		setIndicatorOpt(new Opt<FIdUseExp>(v.createUseExp()));
	}
	
	/**
	 * \brief Creates an initial assign statement for the indicator
	 */
	syn FStatement FRelExp.indicatorInitStmt() = 
			new FAssignStmt(getIndicator().fullCopy(), new FIntegerLitExp(1));
	
	/**
	 * \brief Creates an assign statement for the indicator
	 */
	syn FStatement FRelExp.indicatorStmt() =
			new FAssignStmt(getIndicator().fullCopy(), new FSubExp(getLeft(), getRight()));
	
	/**
	 * \brief Replace one equation with another.
	 */
	public void FClass.replaceEquation(FAbstractEquation oldEq, FAbstractEquation newEq) {
		getFAbstractEquations().replaceChild(oldEq, newEq);
	}
	
	/**
	 * \brief Create an FFunctionCallLeft using a copy of this name.
	 */
	public FFunctionCallLeft FQName.createFFunctionCallLeft() {
		FQName fqn = fullCopy();
		fqn.removeFArraySubscripts();
		return new FFunctionCallLeft(new Opt(new FIdUseExp(fqn)));
	}

	/**
	 * \brief Create an expression to serve as argument to a generated algorithm function.
	 * 
	 * @param init  <code>true</code> if the argument is to initialize an assigned variable
	 */
	public FExp FVariable.createAlgorithmArgument(boolean init) {
		if (init) {
			if (isDiscrete())
				return createFPreExp();
			if (isContinuous())
				return createStartAttributeExp();
		}
		return createUseExp();
	}
	
	/**
	 * \brief Create an input representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionOutput() {
		return createFFunctionVariable(new FOutput());
	}

	/**
	 * \brief Create an output representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionInput() {
		return createFFunctionVariable(new FInput());
	}

	/**
	 * \brief Create an function variable representing this variable in a generated algorithm function.
	 */
	public FFunctionVariable FVariable.createFFunctionVariable(FTypePrefixInputOutput io) {
		FType type = (FType) type().fullCopy();
		return new FFunctionVariable(new Opt(io), type, new Opt(), getFQName().fullCopy());
	}

    public class FClass {
        
        public setFDerivativeVariables setFDerivativeVariables = new setFDerivativeVariables();
        
        /**
         * Remake all FDerivativeVariables.
         */
        public class setFDerivativeVariables extends Transformation {
            protected Set<FVariable> variablesToVisit() {
                return new LinkedHashSet<FVariable>(differentiatedRealVariablesSet());
            }
            
            public void perform() {
                ArrayList<FVariable> l = new ArrayList<FVariable>();
                for (FVariable fv : getFVariables())
                    if (!fv.isDerivativeVariable())
                        l.add(fv);
                for (FVariable fv : variablesToVisit())
                    l.add(fv.createFDerivativeVariable());
                setFVariableList(new List<FVariable>(l));
                root().flushAllRecursive();
            }
        }
        /**
         * Add derivative variables to the list of FVariables.
         * Derivative variable is added for a variable of either of the following is true:
         *  - Occurres differentiated
         *  - Have StateSelect always or prefer
         */
        public class setFDerivativeVariablesPreBLT extends setFDerivativeVariables {
            @Override
            protected Set<FVariable> variablesToVisit() {
                Set<FVariable> fvsToVisit = super.variablesToVisit();
                for (FVariable fv : variables()) {
                    if (!fv.isReal())
                        continue;
                    FRealVariable.StateSelect ss = ((FRealVariable)fv).stateSelectAttribute();
                    if (ss != FRealVariable.StateSelect.ALWAYS && ss != FRealVariable.StateSelect.PREFER)
                        continue;
                    fvsToVisit.add(fv);
                }
                return fvsToVisit;
            }
        }
    }

    public void FClass.addFDerivativeVariables(Collection<FVariable> fvs) {
        for (FVariable fv : fvs)
            addFVariable(fv);
        root().flushAllRecursive();
    }

	public FDerivativeVariable FVariable.createFDerivativeVariable() {
	    throw new UnsupportedOperationException("Trying to create a derivative variable from the non real variable " + name() + "! Java class type: '" + getClass().getSimpleName() + "'");
	}

	public FDerivativeVariable FRealVariable.createFDerivativeVariable() {
	    FDerivativeVariable fdv = new FDerivativeVariable(getFVisibilityType().fullCopy(),
	            getFTypePrefixVariability().fullCopy(), getFQName().fullCopy());
	    fdv.setMeIntegrated(this);
	    this.setMeDifferentiated(fdv);
        FAttribute ssAttr = findAttributeLocal(FAttribute.STATE_SELECT);
        if (ssAttr != null) {
            StateSelect ss = stateSelectAttribute();
            if (ss == StateSelect.NEVER || ss == StateSelect.AVOID)
                fdv.addFAttribute(ssAttr.fullCopy());
        }
	    return fdv;
	}

	public FDerivativeVariable FDerivativeVariable.createFDerivativeVariable() {
	    FHDerivativeVariable fhdv = new FHDerivativeVariable(getFVisibilityType().fullCopy(),
	            getFTypePrefixVariability().fullCopy(), getFQName().fullCopy(), order() + 1);
	    fhdv.setMeIntegrated(this);
	    this.setMeDifferentiated(fhdv);
        FAttribute ssAttr = findAttributeLocal(FAttribute.STATE_SELECT);
        if (ssAttr != null) {
            StateSelect ss = stateSelectAttribute();
            if (ss == StateSelect.NEVER || ss == StateSelect.AVOID)
                fhdv.addFAttribute(ssAttr.fullCopy());
        }
	    return fhdv;
	}

    public class FClass {
        /**
         * Add pre variables to the list of FVariables, one for each
         * discrete variable and one for each continuous variable that is 
         * used in a pre() expression in an initial equation.
         */
        public class addFPreVariables extends Transformation {
            public void perform() {
                ArrayList<FVariable> l = new ArrayList<FVariable>();
                for (FVariable fv : discreteVariables()) 
                    l.add(fv.createPreVariable());
                for (FVariable fv : continuousVariablesUsedInPreInInitial())
                    l.add(fv.createPreVariable());
                for (FVariable fv : l) 
                    addFVariable(fv);
                root().flushAllRecursive();
            }
        }
    }
    
    syn lazy Collection<FVariable> FClass.continuousVariablesUsedInPreInInitial() {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        getFInitialEquations().gatherContinuousVariablesUsedInPre(res);
        return new ArrayList<FVariable>(res);
    }
    
    public void ASTNode.gatherContinuousVariablesUsedInPre(Set<FVariable> res) {
        for (ASTNode n : this) 
            n.gatherContinuousVariablesUsedInPre(res);
    }
    
    public void FPreExp.gatherContinuousVariablesUsedInPre(Set<FVariable> res) {
        FAbstractVariable fv = getFIdUse().myFV();
        if (fv.isContinuous())
            res.add((FVariable) fv);
    }
    
	
	/**
	 * Create a pre variable for this variable.
	 */
	abstract public FVariable FVariable.createPreVariable();
	
	public FVariable FRealVariable.createPreVariable() {
		return new FPreRealVariable(this);
	}
	
	public FVariable FIntegerVariable.createPreVariable() {
		return new FPreIntegerVariable(this);
	}
	
	public FVariable FEnumVariable.createPreVariable() {
		return new FPreEnumVariable(this);
	}
	
	public FVariable FBooleanVariable.createPreVariable() {
		return new FPreBooleanVariable(this);
	}
	
	public FVariable FStringVariable.createPreVariable() {
		return new FPreStringVariable(this);
	}
	
	public FVariable FRecordVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}
	
	public FVariable FExternalObjectVariable.createPreVariable() {
		throw new UnsupportedOperationException();
	}


    public class FClass {
        /**
         * \brief Generate initial equations from variables with fixed start
         * attributes.
         * 
         * Intitial equations corresponding to explicitly set start attributes of 
         * differentiated variables are also generated, without taking the fixed
         * attribute into account.
         */
        public class genInitialEquations extends Transformation {
            public void perform() {
                // TODO: Isn't there always a value for fv.startAttributeExp() now?
                for (FVariable fv : variables()) {
                    boolean generate = false;
                    if (!root().options.getBooleanOption("state_initial_equations") &&
                            fv.isDifferentiatedVariable() && (fv.fixedAttribute() ||
                            root().options.getBooleanOption("state_start_values_fixed")))
                        generate = true;
                    else if (!root().options.getBooleanOption("state_initial_equations") &&
                            fv.isAlgebraicContinousRealVariable() && fv.fixedAttribute())
                        generate = true;
                    else if (fv.isDiscrete() && !fv.isString() && fv.fixedAttribute())
                        generate = true;
                    
                    if (generate) {
                        FExp lhs = fv.isDiscrete() ? fv.createFPreExp() : fv.createUseExp();
                        FExp rhs = fv.startAttributeSet() ? fv.startAttributeExp() : fv.type().zeroLiteral();
                        addFInitialEquation(new FEquation(lhs, rhs));
                    }
                }
                root().flushAllRecursive();
            }
        }
    }

    public class FClass {
        /**
         * Perform alias elimination if it is activated.
         */
        public class aliasEliminationIfSet extends Transformation {
            public aliasEliminationIfSet() {
                super("eliminate_alias_variables");
            }
            
            public void perform() {
                genAlias();
                eliminateAliasVariables();
                checkForEliminatedHGTVars();
                removeUnusedTemporaries();
                mergeEquivalentRecords();
                insertTempsInLHS();
            }
        }
        
        public aliasEliminationIfSet aliasElimination = new aliasEliminationIfSet();
    }
	
	ArrayList<String> FClass.aliasErrors = new ArrayList<String>();
	
	
	/**
	 * \brief A helper class containing information about an alias pair.
	 */
	public class AliasPair {
		public FVariable fv1;
		public FVariable fv2;
		public boolean negated;
		public AliasPair(FVariable fv1, FVariable fv2, boolean negated) {
			this.fv1 = fv1;
			this.fv2 = fv2;
			this.negated = negated;
		}
	}
	
	public AliasPair FAbstractEquation.aliasVariables() {
		return null;
	}
	
	public boolean FAbstractEquation.aliasClassified = false;
	public boolean FAbstractEquation.classifiedAsAlias = false;
	
	/**
	 * \brief Detection of alias variables in equations
	 * 
	 * Equations of the type 'x=y', 'x=-y', '-x=y' and '-x=-y' are detected
	 * as alias equations and an AliasPair object is returned.
	 */
	public AliasPair FEquation.aliasVariables() {
		AliasPair res = null;
		if (!isHGTResidual()) // This equation should not be alias-removed if it is marked as residual!
			res = aliasVariables(getLeft(), getRight(), 1);
		aliasClassified = true;
		classifiedAsAlias = res != null;
		return res;
	}
	
	/**
	 * Determine if two expressions would form an alias pair if on the left and right sides of 
	 * an equation.
	 * 
	 * @param e1    an expression that would form one side of the equation
	 * @param e2    an expression that would form the other side of the equation
	 * @param sign  alias sign is multiplied with this - useful for e.g. 0 = x + y
	 */
	public static AliasPair ASTNode.aliasVariables(FExp e1, FExp e2, int sign) {
		if (e1.canBeAlias() && e2.canBeAlias() 
				&& e1.type().typeAliasCompatible(e2.type()) 
				&& e1.variability().aliasCompatible(e2.variability())) {   // x = y, etc.
			FVariable fv1 = e1.variableThatCanBeAlias();
			FVariable fv2 = e2.variableThatCanBeAlias();
			
			boolean negated = e1.aliasSign() * e2.aliasSign() * sign < 0;
			return new AliasPair(fv1, fv2, negated);
		} else {                                    // 0 = x + y, etc
			FExp eqZero = null;
			if (e1.isLiteralZero())
				eqZero = e2;
			else if (e2.isLiteralZero())
				eqZero = e1;
			if (eqZero != null)
				return eqZero.aliasVariables();
			else
				return null;
		}
	}
	
	syn boolean FTypePrefixVariability.aliasCompatible(FTypePrefixVariability that) {
        return this.equals(that);
	}
	
	/**
	 * \brief Detection of alias variables in expressions
	 * 
	 * Only valid when in an equation that gives that the value of this expression is always 0.
	 */
	public AliasPair FExp.aliasVariables() {
		return null;
	}
	
	public AliasPair FDotAddExp.aliasVariables() {
		return aliasVariables(getLeft(), getRight(), -1);
	}
	
	public AliasPair FDotSubExp.aliasVariables() {
		return aliasVariables(getLeft(), getRight(), 1);
	}
	
	syn boolean FExp.canBeAlias() = false;
	eq FIdUseExp.canBeAlias()     = myFV().canBeAlias();
	eq FDerExp.canBeAlias()       = false;
	eq FNegExp.canBeAlias()       = getFExp().canBeAlias();
	
	syn boolean FAbstractVariable.canBeAlias() = false;
	eq FVariable.canBeAlias() = !lookupDerFV(getFQName()).isDummyDerivativeVariable() 
	        && !isPreVariable() && !isDerivativeVariable() 
	        && !isInput() && !isOutput();
	
	syn int FExp.aliasSign() = 1;
	eq FNegExp.aliasSign()   = -getFExp().aliasSign();
	
	syn FVariable FExp.variableThatCanBeAlias() = null;
	eq FIdUseExp.variableThatCanBeAlias()       = (FVariable) myFV();
	eq FNegExp.variableThatCanBeAlias()         = getFExp().variableThatCanBeAlias();
	
	syn boolean FExp.isLiteralExp() = false;
	eq FLitExp.isLiteralExp()       = true;
	
	
	syn lazy boolean FAbstractEquation.isAliasEquation() = false;
	// If an equation has been classified, the result needs to be cached 
	// in order to avoid reclassification after alias rewrites.
	eq FEquation.isAliasEquation() = aliasClassified? classifiedAsAlias: aliasVariables()!=null;
	
	/**
	 * \brief Generate alias information and remove alias equations.
	 */
	public void FClass.genAlias() {
		if (aliasManager == null) {
			aliasManager = new AliasManager();
		}
		for (FAbstractEquation equation : getFAbstractEquations()) {
			// Iterate over all equations
			// If the equation is an alias equation, then register
			// the alias variables in the alias manager.
			// Check all alias equations, also those that that have been
			// checked before.
			equation.aliasClassified = false; 
			if (equation.isAliasEquation()) 
				aliasManager.addAliasVariables(equation.aliasVariables());
		}
		aliasManager.reportAliasErrors(this);
		//flush();
		root().flushAllRecursive(); // TODO: is this really needed? the tree isn't changed
	}

	/**
	 * \brief Flag indicating if alias variables have been eliminated from the
	 * model.
	 */
	public boolean FClass.aliasVariablesEliminated = false;
	
	/**
	 * \brief Eliminate alias variables from the flat model.
	 * 
	 * The non-alias variables are kept in the list FClass.FVariableList but the
	 * alias variables are moved to FClass.AliasVariablesList.
	 */
	public void FClass.eliminateAliasVariables() {
		ArrayList<FVariable> nonAliasVars = new ArrayList<FVariable>();
		ArrayList<FVariable> aliasVars    = new ArrayList<FVariable>();
		ArrayList<FAbstractEquation> eqns = new ArrayList<FAbstractEquation>();
		
		//log.debug("FClass.eliminateAliasVariables(): l1 " + nonAliasVars + " l2 " + aliasVars);
		
		// Go through all variables and insert in correct list
		int i = 1;
		for (FVariable fv : getAliasVariables()) {
				aliasVars.add(fv);
		}
		for (FVariable fv : getFVariables()) {
			fv.aliasSort(aliasVars, nonAliasVars);
		}
		
		// Remove alias equations.
		for (FAbstractEquation equation : getFAbstractEquations()) 
			if (!equation.isAliasEquation()) 
				eqns.add(equation);

		setFVariableList(new List(nonAliasVars));
		setAliasVariableList(new List(aliasVars));
		setFAbstractEquationList(new List(eqns));
		
		aliasVariablesEliminated = true;
		enableAliasRewrite();
		
		flush();
	}
	
    /**
     * Adds this variable to <code>aliasVars</code>, if it is an alias, or 
     * <code>nonAliasVars</code>, if it is not.
     */
    public void FVariable.aliasSort(ArrayList<FVariable> aliasVars, ArrayList<FVariable> nonAliasVars) {
        if (isAlias()) {
            aliasVars.add(this);
        } else if (aliasSortKeep()) { 
            nonAliasVars.add(this);
            this.propagateAttributesFromAlias();
        }
    }
    
    /**
     * A derivative variable of an alias is removed, if there is no suitable 
     * alias derivative variable one is created. 
     */
    public void FDerivativeVariable.aliasSort(ArrayList<FVariable> aliasVars, ArrayList<FVariable> nonAliasVars) {
        FVariable itg = getMeIntegrated();
        if (itg.isAlias()) {
            FVariable alias = itg.alias();
            if (alias.getMeDifferentiated() == null) {
                FVariable fdv = alias.createFDerivativeVariable();
                alias.setMeDifferentiated(fdv);
                fdv.setMeIntegrated(alias);
                nonAliasVars.add(fdv);
            }
        } else {
            super.aliasSort(aliasVars, nonAliasVars);
        }
    }
    
    /**
     * If this is a pre variable of an alias it should be left out/removed.
     */
    syn boolean FVariable.aliasSortKeep() = !isPreVariable() || !myNonPreVariable().isAlias();
    
	
	public void FClass.checkForEliminatedHGTVars() {
		for (FVariable var : getAliasVariables()) {
			if (var.isHGTVar())
				var.error("Hand guided tearing variable '%s' has been alias eliminated. Selected model variable is:\n    %s", var.name(), var.alias());
		}
	}
	
	public void ASTNode.enableAliasRewrite() {
		for (ASTNode n : this)
			n.enableAliasRewrite();
	}
	
	public void FIdUseExp.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
	public void FAssignStmt.enableAliasRewrite() {
		super.enableAliasRewrite();
		rewriteAlias = true;
		is$Final = false;
	}
	
    public void FInternalAttribute.enableAliasRewrite() {
        // We do not want to rewrite attributes that are of reference type
        if (!getType().name().equals("*"))
            super.enableAliasRewrite();
    }
	
	public void FFunctionDecl.enableAliasRewrite() {
	}
	
	boolean FIdUseExp.rewriteAlias = false;
	boolean FAssignStmt.rewriteAlias = false;
	
	/**
	 * \brief FIdUses referring to alias variables need to be changed to 
	 * FIdUses referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FIdUseExp {
		when (rewriteAlias && myFV().isFVariable() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (fv.isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
	
	rewrite FPreExp {
		when (rewriteAlias && myNonPreFV().isFVariable() && myNonPreFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myNonPreFV();
			FExp new_exp = fv.alias().createFPreExp();
			if (fv.isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}
	
	rewrite FAssignStmt {
		when (rewriteAlias && getLeft().myFV().isFVariable() && getLeft().myFV().isAlias()) to FAssignStmt {
			FVariable fv = (FVariable) getLeft().myFV();
			setLeft(fv.alias().createUseExp());
			if (fv.isNegated()) 
				setRight(new FNegExp(getRight()));
			return this;
		}
	}
	
	/**
	 * \brief FDerExps referring to alias variables need to be changed to 
	 * FDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDerExp {
		when (rewriteAlias && getFIdUse().myFV().isFVariable() && (myFV().isAlias() || getFIdUse().myFV().isAlias())) to FExp {
			if (myFV().isAlias()) {
				FVariable fv = (FVariable) myFV();
				FExp new_exp = fv.alias().createUseExp();
				if (myFV().isNegated()) 
					new_exp = new FNegExp(new_exp);
				return new_exp;				
			} else {			
				FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).alias().getFQName().fullCopy();
				FExp new_exp = new FDerExp(new FIdUse(new_name));
				if (getFIdUse().myFV().isNegated()) 
					new_exp = new FNegExp(new_exp);
				return new_exp;
			}
		}
	}

	/**
	 * \brief FDummyDerExps referring to alias variables need to be changed to 
	 * FDummyDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FDummyDerExp {
		when (rewriteAlias && myFV().isFVariable() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/**
	 * \brief FHDummyDerExps referring to alias variables need to be changed to 
	 * FHDummyDerExps referring to their alias targets. 
	 * 
	 * This is done by rewrites which are activated once FClass.aliasVariablesEliminated
	 * is true. Notice that in order for the rewrite to be enable, the is$final
	 * field of FIdUseExp needs to be set to false: this is done by the recursive
	 * method ASTNode.flushAllRecursiveClearFinal. 
	 */
	rewrite FHDummyDerExp {
		when (rewriteAlias && myFV().isFVariable() && myFV().isAlias()) to FExp {
			FVariable fv = (FVariable) myFV();
			FExp new_exp = fv.alias().createUseExp();
			if (myFV().isNegated()) 
				new_exp = new FNegExp(new_exp);
			return new_exp;
		}
	}

	/*
	 * Rewrite derivatives of parameters to zeros.
	 */
	rewrite FDerExp {
		when (getFIdUse().myFV().isFVariable() && getFIdUse().myFV().variability().lessOrEqual(fParameter())) to FExp {
			return new FRealLitExp(0.0);
		}
	}
	
	
	/**
	 * Remove all unused temporary variables, and inline temporaries only used once.
	 */
	public void FClass.removeUnusedTemporaries() {
		ArrayList<FVariable> temps = tempVariables();
		int oldSize = Integer.MAX_VALUE;
		while (temps.size() < oldSize) {
			ArrayList<FVariable> temps2 = new ArrayList<FVariable>(temps.size());
			for (FVariable fv : temps) {
				if (fv.shouldEliminateTemporary())
					fv.inlineUses();
				else
					temps2.add(fv);
			}
			oldSize = temps.size();
			temps = temps2;
		}
		
		ArrayList<FVariable> vars = new ArrayList<FVariable>();
		for (FVariable fv : getFVariables())
			if (!fv.isTemporary())
				vars.add(fv);
		for (FVariable fv : temps)
			vars.add(fv);
		
		removeMarkedEqns();
		setFVariableList(new List(vars));
	}

	/**
	 * Check if this is a temporary variable that should be eliminated.
	 */
	syn boolean FVariable.shouldEliminateTemporary() = 
		isTemporary() && 
		nonDefiningUses().size() <= 1 && 
		definingUses().size() <= 1 && 
		!usedAsFunctionCallLeft() && 
        !isPreVariable() && myPreVariable().isUnknown() && 
		(definingUses().isEmpty() || !definingUses().iterator().next().myFEquation().generatesEvents());
	
	/**
	 * Inline all non-defining uses of variable, and remove equation defining it.
	 * 
	 * NB: This assumes that the variable and any equations marked for removal will be removed.
	 */
	public void FVariable.inlineUses() {
		FExp value;
		if (hasBindingExp()) {
			value = getBindingExp();
		} else {
			if (definingUses().isEmpty())
				return;
			FAbstractEquation eqn = definingUses().iterator().next().myFEquation();
			if (!(eqn instanceof FEquation)) 
				return;
			value = ((FEquation) eqn).getRight();
			eqn.markedForRemoval = true;
		}
		
		if (nonDefiningUses().isEmpty())
			value.removeFromUses();
		value.parent = null;
		
		for (FIdUseExp use : nonDefiningUses())
			use.replaceMe(value.unboundCopy());
	}
	
	/**
	 * Flag for removing equation.
	 */
	public boolean FAbstractEquation.markedForRemoval = false;
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FExp.removeFromUses() {
		for (FExp e : childFExps())
			e.removeFromUses();
	}
	
	public void FIdUseExp.removeFromUses() {
		FAbstractVariable var = getFIdUse().myFV();
		var.uses().remove(this);
		var.definingUses().remove(this);
		var.nonDefiningUses().remove(this);
		getFIdUse().getFQName().removeFromUses();
	}
	
	/**
	 * Remove all uses in expressions in array subscripts from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FQName.removeFromUses() {}
	
	public void FQNameFull.removeFromUses() {
		for (FQNamePart p : getFQNameParts())
			if (p.hasFArraySubscripts())
				for (FSubscript s : p.getFArraySubscripts().getFSubscripts())
					s.removeFromUses();
	}
	
	/**
	 * Remove all uses in an expression from the uses lists of their respective variables.
	 * 
	 * Should only be used to allow iterative algorithms to use updated uses lists while 
	 * removing expressions. Only valid in flat tree.
	 */
	public void FSubscript.removeFromUses() {}
	
	public void FExpSubscript.removeFromUses() {
		getFExp().removeFromUses();
	}
	
	/**
	 * Remove all equations with <code>markedForRemoval == true</code>. 
	 */
	public void FClass.removeMarkedEqns() {
		setFInitialEquationList(removeMarkedEqns(getFInitialEquations()));
		setFParameterEquationList(removeMarkedEqns(getFParameterEquations()));
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	/**
	 * Create a copy of the list with all equations with <code>markedForRemoval == true</code> removed. 
	 */
	protected static List<FAbstractEquation> ASTNode.removeMarkedEqns(List<FAbstractEquation> list) {
		List<FAbstractEquation> res = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : list) {
			if (!eqn.markedForRemoval) {
				eqn.removeMarkedEqns();
				res.add(eqn);
			}
		}
		return res;
	}
	
	/**
	 * Remove all contained equations with <code>markedForRemoval == true</code>. 
	 */
	public void FAbstractEquation.removeMarkedEqns() {}
	
	public void FForClauseE.removeMarkedEqns() {
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	public void FIfWhenElseEquation.removeMarkedEqns() {
		setFAbstractEquationList(removeMarkedEqns(getFAbstractEquations()));
	}
	
	public void FIfWhenEquation.removeMarkedEqns() {
		super.removeMarkedEqns();
		if (hasElse())
			getElse().removeMarkedEqns();
	}
	
	/**
	 * Remove records that are equivalent, and update uses. 
	 */
	public void FClass.mergeEquivalentRecords() {
		computeEquivalentRecords();
		activateEquivalentRecordUseRewrite();
		List<FRecordDecl> list = new List<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			if (rec.equivalentRecordToKeep)
				list.add(rec);
		setFRecordDeclList(list);
	}
	
	public void FClass.computeEquivalentRecords() {
		ArrayList<FType> distinctTypes = new ArrayList<FType>();
		ArrayList<FRecordDecl> keptDecl = new ArrayList<FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls()) {
			boolean found = false;
			FType type = rec.type();
			for (int i = 0; !found && i < distinctTypes.size(); i++) {
				if (type.typeCompatible(distinctTypes.get(i))) {
					found = true;
					rec.equivalentRecordGroup = i;
				}
			}
			if (!found) {
				rec.equivalentRecordToKeep = true;
				rec.equivalentRecordGroup = distinctTypes.size();
				distinctTypes.add(type);
				keptDecl.add(rec);
			}
		}
		equivalentRecordMap = new HashMap<String,FRecordDecl>();
		for (FRecordDecl rec : getFRecordDecls())
			equivalentRecordMap.put(rec.name(), keptDecl.get(rec.equivalentRecordGroup));
	}
	
	protected Map<String,FRecordDecl> FClass.equivalentRecordMap;
	
	public boolean FRecordDecl.equivalentRecordToKeep = false;
	public int FRecordDecl.equivalentRecordGroup = -1;
	
	public void ASTNode.activateEquivalentRecordUseRewrite() {
		for (ASTNode n : this)
			n.activateEquivalentRecordUseRewrite();
	}
	
	public void FFunctionVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		if (type().isRecord()) {
			rewriteEquivalentRecord = true;
			is$Final = false;
		}
	}
	
	public void FRecordVariable.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	public void FRecordConstructor.activateEquivalentRecordUseRewrite() {
		super.activateEquivalentRecordUseRewrite();
		rewriteEquivalentRecord = true;
		is$Final = false;
	}
	
	private boolean FFunctionVariable.rewriteEquivalentRecord  = false;
	private boolean FRecordVariable.rewriteEquivalentRecord    = false;
	private boolean FRecordConstructor.rewriteEquivalentRecord = false;
	
	rewrite FFunctionVariable {
		when (rewriteEquivalentRecord)
		to FFunctionVariable {
			rewriteEquivalentRecord = false;
			setType(myFClass().createEquivalentRecordType(getType()));
			flushAll();
			return this;
		}
	}
	
	rewrite FRecordVariable {
		when (rewriteEquivalentRecord)
		to FRecordVariable {
			rewriteEquivalentRecord = false;
			setRecord(myFClass().createEquivalentRecordFQName(getRecord()));
			flushAll();
			return this;
		}
	}
	
	rewrite FRecordConstructor {
		when (rewriteEquivalentRecord)
		to FRecordConstructor {
			rewriteEquivalentRecord = false;
			getRecord().setFQName(myFClass().createEquivalentRecordFQName(getRecord().getFQName()));
			getRecord().flushAll();
			flushAll();
			return this;
		}
	}

	public FQName FClass.createEquivalentRecordFQName(FQName old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.getFQName().fullCopy() : old;
	}

	public FType FClass.createEquivalentRecordType(FType old) {
		FRecordDecl rec = equivalentRecordMap.get(old.name());
		return (rec != null) ? rec.type().sizedType(old.size()).fullCopy() : old;
	}
	
	public void FClass.insertTempsInLHS() {
		for (FAbstractEquation equation : getFAbstractEquations()) {
			equation.insertTempsInLHS(this);
		}
	}
	
	public void FAbstractEquation.insertTempsInLHS(FClass fClass) {}
	public void FFunctionCallEquation.insertTempsInLHS(FClass fClass) {
		for (FFunctionCallLeft left : getLefts())
			left.insertTempsInLHS(fClass);
	}
	
	public void FFunctionCallLeft.insertTempsInLHS(FClass fClass) {
		if (hasFExp())
			getFExp().insertTempsInLHS(fClass);
	}
	
	public void FExp.insertTempsInLHS(FClass fClass) {
		String tempName = calcTempVarName();
		fClass.addFVariable(type().createTempFVariable(new FQNameString(tempName), variability()));
		replaceMe(new FIdUseExp(tempName));
		fClass.addFEquation(new FEquation(this, new FIdUseExp(tempName)));
	}
	
	public void FIdUseExp.insertTempsInLHS(FClass fClass) {}
	public void FArray.insertTempsInLHS(FClass fClass) {
		for (FExp fExp : getFExps())
			fExp.insertTempsInLHS(fClass);
	}
	public void FRecordConstructor.insertTempsInLHS(FClass fClass) {
		for (FExp fExp : getArgs())
			fExp.insertTempsInLHS(fClass);
	}
	
}

aspect WhenClauses{
	
	public class FClass {
		/**
		 * Rewrites when clauses to if clauses.
		 */
		public class enableWhenClauseRewrite extends Transformation {
			public void perform() {
				createGuardTemporaries();
				enableWhenClauseRewrite();
				flushAllRecursive();
			}
			
			public void createGuardTemporaries() {
				for (FExp e : guardExpInEquations()) {
					if (e.shouldExtractGuard()) {
						addFVariable(e.type().createFVariable(new FPublicVisibilityType(), 
								new FQNameFull(e.tempVarName()), e.variability().combine(fDiscrete())));
						
						if (e.inAlgorithm() && !e.dependsOn(e.myFAlgorithm().referencedFVariablesInLHS())) {
							addFAbstractEquation(new FEquation(e.tempUseExp(), e.fullCopy()));
						}
					}
				}
			}
		}
	}
	
	/**
	 * Should this guard expression be extracted into a temp variable?
	 */
	syn boolean FExp.shouldExtractGuard() = true;
	eq FInitialExp.shouldExtractGuard() = false;
	eq FIdUseExp.shouldExtractGuard() = false;
	eq FPreExp.shouldExtractGuard() = true;
	eq FDerExp.shouldExtractGuard() = true;
	eq FDummyDerExp.shouldExtractGuard() = true;
	
	/**
	 * Flag for whether or not this if clause/expression 
	 * originates from a when clause.
	 */
	private boolean FAbstractEquation.isWhen = false;
	private boolean FStatement.isWhen        = false;
	private boolean FIfExp.isWhen            = false;
	
	syn boolean FAbstractEquation.isWhen() = isWhen;
	eq FWhenEquation.isWhen()              = true;
	syn boolean FStatement.isWhen()        = isWhen;
	eq FWhenStmt.isWhen()                  = true;
	syn boolean FIfExp.isWhen()            = isWhen;
	public void FAbstractEquation.setWhen() { isWhen = true; }
	public void FStatement.setWhen()        { isWhen = true; }
	public void FIfExp.setWhen()            { isWhen = true; }
	
	
	
	/**
	 * Rewrite mechanisms
	 */
	boolean FWhenEquation.rewriteWhenClause = false;
	boolean FWhenStmt.rewriteWhenClause     = false;
	boolean FRelExp.rewriteWhenClause       = false;
	boolean FEventGenExp.rewriteWhenClause  = false;

	public void ASTNode.enableWhenClauseRewrite() {
		for (ASTNode n : this)
			n.enableWhenClauseRewrite();
	}
	
	public void FWhenEquation.enableWhenClauseRewrite() {
		super.enableWhenClauseRewrite();
		rewriteWhenClause = true;
		is$Final = false;
	}
	
	public void FWhenStmt.enableWhenClauseRewrite() {
		rewriteWhenClause = true;
		is$Final = false;
	}
	
	/**
	 * Rewrites this when clause to an equivalent if clause
	 */
	rewrite FWhenEquation in FClass.getFAbstractEquation() {
		when (rewriteWhenClause) to List {
			ArrayList<FAbstractEquation> eqs = new ArrayList<FAbstractEquation>();
			convertGuard(eqs, true);
			eqs.add(asIfClause());
			return new List<FAbstractEquation>(eqs);
		}
	}
	rewrite FWhenEquation {
		when (rewriteWhenClause) to FIfEquation {
			return asIfClause();
		}
	}
	
	/**
	 * Rewrites this when clause to an equivalent if clause
	 */
	rewrite FWhenStmt in FAlgorithm.getFStatement() {
		when (rewriteWhenClause) to List {
			return asIfClause();
		}
	}
	
	/**
	 * Converts this when clause to an equivalent if clause
	 */
	public FIfEquation FWhenEquation.asIfClause() {
		
		FIfEquation e = new FIfEquation();
		
		if (hasElse()) {
			e.setElse(getElse());
		} else {
			ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
			for (FVariable fv : referencedFVariablesInLHS()) {
				l.add(new FEquation(fv.createUseExp(), fv.createFPreExp()));
			}
			e.setElse(new FElseEquation(getType(), new List<FAbstractEquation>(l)));
		}
		e.setType(getType());
		e.setTest(getTest());
		e.setFAbstractEquationList(getFAbstractEquations());
		e.setWhen();
		
		return e;
	}
	
	/**
	 * Converts this when clause to an equivalent if clause
	 */
	public List<FStatement> FWhenStmt.asIfClause() {
		ArrayList<FStatement> stmts = new ArrayList<FStatement>();
		ArrayList<FIfWhenClause> clauses = new ArrayList<FIfWhenClause>();
		
		for (FIfWhenClause clause : getFIfWhenClauses()) {	
			FIfClause c = new FIfClause();
			c.setTest(clause.getTest().transformGuard(stmts, false));
			c.setFStatementList(clause.getFStatements().fullCopy());
			clauses.add(c);
		}
		
		FIfStmt e = new FIfStmt();
		e.setWhen();
		myFEquation().setWhen();
		e.setFIfWhenClauseList(new List<FIfWhenClause>(clauses));
		
		stmts.add(e);
		
		return new List<FStatement>(stmts);
	}
	
	public void FIfWhenElseEquation.convertGuard(ArrayList l, boolean equation) {}
	public void FIfWhenEquation.convertGuard(ArrayList l, boolean equation) {
		setTest(getTest().transformGuard(l,equation));
		if (hasElse())
			getElse().convertGuard(l,equation);
	}
	
	/**
	 * Converts this guard expression from a when clause to a guard expression
	 * to be used in an if clause.
	 */
    public FExp FExp.transformGuard(ArrayList l, boolean equation) {
        Iterator<FExp> it = guards().iterator();
        FExp res = it.next().asGuard(l, equation);
        while (it.hasNext())
            res = new FOrExp(res,it.next().asGuard(l, equation));
        return res;
    }
	public FExp FExp.asGuard(ArrayList l, boolean equation) {
		if (equation)
			l.add(new FEquation(tempUseExp(), fullCopy()));
		else if(dependsOn(myFAlgorithm().referencedFVariablesInLHS()))
			l.add(new FAssignStmt(tempUseExp(), fullCopy()));
		return new FAndExp(tempUseExp(), new FNotExp(tempPreExp()));
	}
	
	public FExp FInitialExp.asGuard(ArrayList l, boolean equation) {
		return fullCopy();
	}
	
	public FExp FIdUseExp.asGuard(ArrayList l, boolean equation) {
		if (!shouldExtractGuard())
			return new FAndExp(fullCopy(), new FNotExp(new FPreExp(getFIdUse().fullCopy())));
		else
			return super.asGuard(l, equation);
	}
}


aspect IfEquations {
	
	/*
	 * First rewrite those if equations that has constant or stuctural parameter test
	 * by evaluating the expressions and eliminating unreachable branches.
	 */
    
    public class FClass {
        public class enableIfEquationElimination extends Transformation {
            public void perform() {
                enableIfEquationElimination();
                
                // Workaround for JastAdd bug
                setFInitialEquationList(cleanEmptyElse(getFInitialEquations()));
                setFAbstractEquationList(cleanEmptyElse(getFAbstractEquations()));
                
                // Remove orphaned temporaries
                flushAllRecursive();
                removeUnusedTemporaries();
            }
        }
    }

	public void ASTNode.enableIfEquationElimination() {
		for (ASTNode n : this)
			n.enableIfEquationElimination();
	}
	
	public void FIfEquation.enableIfEquationElimination() {
		super.enableIfEquationElimination();
		eliminateIfEquation = true;
		is$Final = false;
	}
	
	public void FIfExp.enableIfEquationElimination() {
		super.enableIfEquationElimination();
		eliminateIfEquation = true;
		is$Final = false;
	}
	
	private boolean FIfEquation.eliminateIfEquation = false;
	private boolean FIfExp.eliminateIfEquation = false;

	// TODO: not needed, since structural parameters are replaced 
	protected boolean FIfWhenElseEquation.eliminateOnParamTest = false;

	protected void FIfWhenElseEquation.setEliminateOnParamTest(ErrorCheckType checkType) {}

	protected void FIfEquation.setEliminateOnParamTest(ErrorCheckType checkType) {
		eliminateOnParamTest = true;
		getTest().markAsStructuralParameter(checkType);
		if (hasElse())
			getElse().setEliminateOnParamTest(checkType);
	}
	
	syn boolean FIfEquation.shouldEliminateIf() = 
		getTest().isConstantExp() || getTest().isParameterExp() && eliminateOnParamTest;
	
	rewrite FIfEquation {
		when (eliminateIfEquation) to FIfWhenElseEquation {
			eliminateIfEquation = false;
			
			if (shouldEliminateIf()) {
				try {
					if (getTest().ceval().booleanValue())
						return new FElseEquation(getType(), getFAbstractEquations());
					else if (hasElse())
						return getElse();
					else
						return new FElseEquation(getType(), new List());
				} catch (ConstantEvaluationException e) {}
			}
			
			return this;
		}	
	}
	
	rewrite FIfExp {
		when (eliminateIfEquation) to FExp {
			eliminateIfEquation = false;
			
			try {
				if (getIfExp().isConstantExp()) 
					return getIfExp().ceval().booleanValue() ? getThenExp() : getElseExp();
			} catch (ConstantEvaluationException e) {}
			
			return this;
		}
	}

	rewrite FElseEquation in FClass.getFInitialEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
	
	rewrite FElseEquation in FClass.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
	
	rewrite FElseEquation in FIfWhenElseEquation.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}	
			
	rewrite FElseEquation in FForClauseE.getFAbstractEquation() {
		when (getNumFAbstractEquation() > 0) to List getFAbstractEquations();
	}

	/*
	 * After we have eliminated if equations with constant (and possibly parameter)
	 * test expressions, then all if equations must be balanced, so we can rewrite to 
	 * a list of residual equations with if expressions.
	 */

	public void ASTNode.enableIfEquationRewrite() {
		for (ASTNode n : this)
			n.enableIfEquationRewrite();
	}

    public class FClass {
        public class enableIfEquationRewrite extends Transformation {
            public void perform() {
                enableIfEquationRewrite();
                checkIfEquationCompliance();
            }
        }
    }
	
	public void FIfEquation.enableIfEquationRewrite() {
		super.enableIfEquationRewrite();
		rewriteIfEquation = true;
		is$Final = false;
	}
	
	private boolean FIfEquation.rewriteIfEquation = false;
	
    public void ASTNode.checkIfEquationCompliance() {
        for (ASTNode n : this)
            n.checkIfEquationCompliance();
    }
    
    public void FIfEquation.checkIfEquationCompliance() {
        int numAssigned = referencedFVariablesInLHS().size();
        int numEqs = numScalarEquations();
        if (numAssigned != numEqs)
            compliance("If equations that has non-parameter tests and contains function calls using multiple " +
                    "outputs must assign the same variables in all branches");
    }

	syn Map<FAbstractVariable,FEquation> FIfWhenElseEquation.assignmentEquationMap() {
		calcAssignmentEquations();
		return assignmentEquationMap;
	}
	
	syn Set<FEquation> FIfWhenElseEquation.nonAssignmentEquationSet() {
		calcAssignmentEquations();
		return nonAssignmentEquationSet;
	}
	
	syn Set<FAbstractEquation> FIfWhenElseEquation.nonFEquationSet() {
		calcAssignmentEquations();
		return nonFEquationSet;
	}
	
	private Map<FAbstractVariable,FEquation> FIfWhenElseEquation.assignmentEquationMap = null;
	private Set<FEquation> FIfWhenElseEquation.nonAssignmentEquationSet = null;
	private Set<FAbstractEquation> FIfWhenElseEquation.nonFEquationSet = null;
	
	private void FIfWhenElseEquation.calcAssignmentEquations() {
		if (assignmentEquationMap == null || nonAssignmentEquationSet == null || nonFEquationSet == null) {
			assignmentEquationMap = new HashMap<FAbstractVariable,FEquation>();
			nonAssignmentEquationSet = new HashSet<FEquation>();
			nonFEquationSet = new HashSet<FAbstractEquation>();
			for (FAbstractEquation eqn : getFAbstractEquations()) {
				if (eqn instanceof FEquation) {
					FEquation feqn = (FEquation) eqn;
					FAbstractVariable var = feqn.assignedFV();
					if (var != null && !assignmentEquationMap.containsKey(var))
						assignmentEquationMap.put(var, feqn);
					else
						nonAssignmentEquationSet.add(feqn);
				} else {
					nonFEquationSet.add(eqn);
				}
			}
		}
	}
	

	syn FExp FAbstractEquation.createResidualExp() = null;
	eq FEquation.createResidualExp() {
		if (getLeft().isZeroLiteral())
			return getRight().fullCopy();
		if (getRight().isZeroLiteral())
			return getLeft().fullCopy();
		return new FSubExp(getLeft().fullCopy(), getRight().fullCopy());
	}
	
	// TODO: move to better suited source file
	syn boolean FExp.isZeroLiteral()  = false;
	eq FIntegerLitExp.isZeroLiteral() = getValue() == 0;
	eq FRealLitExp.isZeroLiteral()    = getValue() == 0.0;
	eq FArray.isZeroLiteral() {
		for (FExp e : getFExps())
			if (!e.isZeroLiteral())
				return false;
		return true;
	}
	
	syn FExp FAbstractEquation.assignmentExp() = null;
	eq FEquation.assignmentExp() =
		isAssignmentEqn() ? getRight() : null;	
	

	
	public static List<FAbstractEquation> ASTNode.cleanEmptyElse(List<FAbstractEquation> oldList) {
		List<FAbstractEquation> newList = new List<FAbstractEquation>();
		for (FAbstractEquation eqn : oldList)
			if (!(eqn instanceof FElseEquation))
				newList.add(eqn);
		return newList;
	}
	
	public void FIfWhenElseEquation.cleanEmptyElse() {
		setFAbstractEquationList(cleanEmptyElse(getFAbstractEquations()));
	}
	
	public void FIfWhenEquation.cleanEmptyElse() {
		super.cleanEmptyElse();
		if (hasElse())
			getElse().cleanEmptyElse();
	}
	
	// TODO: Move to util
	public class ASTNode {
		
		public static <K, V> Set<V> valuesOfUnNamedKeys(Map<K, V> map, Set<K> namedKeys) {
			Set<V> res = new HashSet<V>();
			for (Map.Entry<K,V> e : map.entrySet())
				if (!namedKeys.contains(e.getKey()))
					res.add(e.getValue());
			return res;
		}
		
		public static <T> Set<T> intersection(Set<T> a, Set<T> b) {
			// TODO: use runtime type of a instead - problematic if it is something like HashMap.KeySet
			Set<T> res = new HashSet<T>();
			res.addAll(a);
			res.retainAll(b);
			return res;
		}
		
		public static <T> ArrayList<T> toSortedList(Collection<T> elems, Comparator<? super T> cmp) {
			ArrayList<T> res = new ArrayList<T>(elems.size());
			res.addAll(elems);
			Collections.sort(res, cmp);
			return res;
		}
		
	}
	
	protected static ArrayList<FEquation> FIfEquation.unmatchedEquations(
			FIfWhenElseEquation ifEqn, Set<FAbstractVariable> varsInBoth) {
		Set<FEquation> unMatchedAssign = 
			valuesOfUnNamedKeys(ifEqn.assignmentEquationMap(), varsInBoth);
		unMatchedAssign.addAll(ifEqn.nonAssignmentEquationSet());
		return toSortedList(unMatchedAssign, CHILD_ORDER_COMPARATOR);
	}
	
	private int[][] FIfEquation.matchEquationsMinimizeIncidences(ArrayList<FEquation> left, ArrayList<FEquation> right) {
        int nl = left.size();
        int nr = right.size();
        if (nl == 0 || nr == 0)
            return new int[0][0];
        int[][] weights = new int[nl][nr];
        for (int i = 0; i < nl; i++) {
            for (int j = 0; j < nr; j++) {
                Set<FVariable> rightVars = right.get(j).variables();
                weights[i][j] = rightVars.size();
                for (FVariable var : left.get(i).variables()) 
                    weights[i][j] += rightVars.contains(var) ? -1 : 1;
            }
        }
        return new MunkresProblem(IntegerCost.create(weights)).solve();
	}
	
	private void FIfEquation.sortOutMatchedEquations(ArrayList<FEquation> eqns, int[][] match, int col, 
	        ArrayList<FEquation> matched, List<FAbstractEquation> remaining) {
	    int n = eqns.size();
        boolean used[] = new boolean[n];
        for (int i = 0; i < match.length; i++) {
            matched.add(eqns.get(match[i][col]));
            used[match[i][col]] = true;
        }
        for (int i = 0; i < n; i++)
            if (!used[i])
                remaining.add(eqns.get(i));
	}

	syn List FIfEquation.createIfExpEquationList() {
		List<FAbstractEquation> l = new List<FAbstractEquation>();
		
		// Generate equations for assignment equations that can be matched
		Set<FAbstractVariable> varsInBoth = assignmentEquationMap().keySet();
		if (hasElse())
		    varsInBoth = intersection(varsInBoth, getElse().assignmentEquationMap().keySet()); 
		for (FAbstractVariable v : toSortedList(varsInBoth, FAbstractVariable.NAME_COMPARATOR)) {
			FExp left = assignmentEquationMap().get(v).assignmentExp();
			FExp right = getElse().assignmentEquationMap().get(v).assignmentExp();
			FIfExp ifExp = new FIfExp(getTest().fullCopy(), left, right);
			FEquation e = new FEquation(getType().fullCopy(), v.createUseExp(), ifExp);
			if (isWhen()) {
				ifExp.setWhen();
				e.setWhen();
			}
			l.add(e);
		}
		
		// Find equations to match up among remaining FEquations based on indices
        ArrayList<FEquation> unmatchedLeft = unmatchedEquations(this, varsInBoth);
        ArrayList<FEquation> unmatchedRight;
        if (hasElse())
            unmatchedRight = unmatchedEquations(getElse(), varsInBoth);
        else
            unmatchedRight = new ArrayList<FEquation>();
        
        int[][] match = matchEquationsMinimizeIncidences(unmatchedLeft, unmatchedRight);
        
		// Sort remaining equations into those that should remain in if equation and those that should become residual eqns
        // Left side
		ArrayList<FEquation> residualLeft = new ArrayList<FEquation>();
        List<FAbstractEquation> keepLeft = new List<FAbstractEquation>();
        sortOutMatchedEquations(unmatchedLeft, match, 0, residualLeft, keepLeft);
        keepLeft.addAll(toSortedList(nonFEquationSet(), CHILD_ORDER_COMPARATOR));
        // Right side
        ArrayList<FEquation> residualRight = new ArrayList<FEquation>();
        List<FAbstractEquation> keepRight = new List<FAbstractEquation>();
        sortOutMatchedEquations(unmatchedRight, match, 1, residualRight, keepRight);
        if (hasElse())
            keepRight.addAll(toSortedList(getElse().nonFEquationSet(), CHILD_ORDER_COMPARATOR));
        
        // Generate residual equations
		for (FEquation[] eqs : new ParallelIterable<FEquation>(new FEquation[2], true, residualLeft, residualRight)) {
			FExp left = eqs[0].createResidualExp();
			FExp right = eqs[1].createResidualExp();
			FIfExp ifExp = new FIfExp(getTest().fullCopy(), left, right);
			l.add(new FEquation(getType().fullCopy(), eqs[0].type().zeroLiteral(), ifExp));
		}
		
		// Generate new if equation with remaining equations
		FIfEquation e;
		if (keepLeft.getNumChild() > 0) {
		    Opt<FIfWhenElseEquation> elseOpt = new Opt<FIfWhenElseEquation>();
		    if (keepRight.getNumChild() > 0) 
		        elseOpt.addChild(new FElseEquation(getType().fullCopy(), keepRight));
		    e = new FIfEquation(getType().fullCopy(), keepLeft, getTest(), elseOpt);
		    if (isWhen())
		    	e.setWhen();
		    l.add(e);
		} else if (keepRight.getNumChild() > 0) {
            e = new FIfEquation(getType().fullCopy(), keepRight, new FNotExp(getTest()), new Opt());
		    if (isWhen())
		    	e.setWhen();
            l.add(e);
		}
		
		return l;
	}
	
	syn boolean FAbstractEquation.allowGlobalOnIfRewrite() = false;
	eq FFunctionCallEquation.allowGlobalOnIfRewrite()      = getNumLeft() > 0;
	
	rewrite FIfEquation {
		when (rewriteIfEquation)
		to FElseEquation new FElseEquation(getType(), createIfExpEquationList());
	}

}

aspect NonFixedParametersPropagation {
	public class FClass {
		/**
		 * Propagate non-fixed parameters.
		 * 
		 * This transformation sets a parameter to fixed=false if it depends on
		 * a parameter with fixed=false.
		 */
		public class propagateNonFixedParameters extends Transformation {
			public void perform() {
				Set<FAbstractEquation> newInitEqns = new LinkedHashSet<FAbstractEquation>();
				Stack<FVariable> s = new Stack<FVariable>();
				
				// Add all parameters that depend on a non-fixed parameter
				for (FVariable v : nonFixedParameters())
					s.addAll(v.dependentParameters());
				
				// Go through all variables that depend on a parameter with fixed=false and do:
				// - Add parameter equation to list of new initial equations
				// - Add dependent variables to the stack
				// - Set fixed=false
				while (!s.empty()) {
					FVariable fv = s.pop();
					boolean visited = !newInitEqns.add(fv.parameterEquation());
					if (visited)
						continue;
					s.addAll(fv.dependentParameters());
					fv.setFixedAttribute(false);
				}
				
				// Construct new parameter equation list and add all but the new initial equations
				List<FAbstractEquation> newParameterEqns = new List<FAbstractEquation>();
				for (FAbstractEquation eqn : getFParameterEquationList())
					if (!newInitEqns.contains(eqn))
						newParameterEqns.add(eqn);
				setFParameterEquationList(newParameterEqns);
				
				// Add new initial equations to list of initial equations
				getFInitialEquations().addAll(newInitEqns);
				
				// Flush tree if change has been made
				if (!newInitEqns.isEmpty())
					root().flushAllRecursive();
			}
		}
	}
}

aspect ParameterSorting {

	/**
	 * \brief Index of equation during equation sorting.
	 */
	public int FAbstractEquation.sortingIndex = -1;
	
	public class FAbstractEquation {
		public static class SortingIndexComparator implements Comparator<FAbstractEquation> {
			public int compare(FAbstractEquation o1, FAbstractEquation o2) {
				return o1.sortingIndex - o2.sortingIndex;
			}
		}
	}
	
	public class FVariable {
		public static class SortingIndexComparator implements Comparator<FVariable> {
			public int compare(FVariable o1, FVariable o2) {
				return o1.parameterEquation().sortingIndex - o2.parameterEquation().sortingIndex;
			}
		}
	}
	
	/**
	 * \brief Creates a TreeSet that can hold FAbstractEquations, sorted by their sortingIndex.
	 */
	public static TreeSet<FAbstractEquation> FAbstractEquation.sortingSet() {
		return new TreeSet<FAbstractEquation>(new SortingIndexComparator());
	}
	
	/** 
	 * \brief Sorts a list of FVariables according to the sortingIndex of their equation.
	 */
	public static void FVariable.sortParameters(java.util.List<FVariable> vars) {
		Collections.sort(vars, new SortingIndexComparator());
	}

    public class FClass {
        /**
         * Sort dependent parameter equations.
         * 
         * This is a simple implementation of Kahn's topological sorting algorithm.
         * This implementation will most likely be replaced by other graph 
         * algorithms later on.
         */
        public class sortDependentParameters extends Transformation {
            public void perform() {
                sortDependentParameters();
            }
        }
    }
	
	/**
	 * Sort dependent parameter equations.
	 * 
	 * This is a simple implementation of Kahn's topological sorting algorithm.
	 * This implementation will most likely be replaced by other graph 
	 * algorithms later on.
	 */
	public void FClass.sortDependentParameters() {
		// Check that all independent parameters can be evaluated.
		for (FVariable var : getFVariables()) {
			FTypePrefixVariability variability = var.variability();
			if (variability.parameterVariability()) {
				if (var.hasBindingExp() && !var.getBindingExp().isLiteralExp() && !var.isExternalObject()) {
					try {
						var.setBindingExp(var.getBindingExp().ceval().buildLiteral());
					} catch (ConstantEvaluationException e) {
						getFParameterEquations().add(new FEquation(var.createUseExp(), var.getBindingExp()));
						var.removeBindingExp();
					}
				}
			}
		}
		// Get the list of parameter equations and set up preliminary data.
		ArrayList<FAbstractEquation> eqns = getFParameterEquations().toArrayList();
		
		// Check if there is any dependent parameters that can be made independent.
		Iterator<FAbstractEquation> it = eqns.iterator();
		while (it.hasNext()) {
			FAbstractEquation eqn = it.next();
			if (eqn != null && eqn.isIndependentParameterEquation()) {
				try {
					eqn.revertToBindingExp();
					it.remove();
				} catch (ConstantEvaluationException e) {
					// Doh, we were unable to evaluate the expression
				}
			}
		}
		int n_eqns = eqns.size();
		List<FVariable> vars = getFVariables();
		int n_vars = getNumFVariable();
		for (int i = 0; i < n_eqns; i++)
			eqns.get(i).sortingIndex = i;
		for (FVariable fv : vars)
			fv.parameterEquation();  // Calculate these before changing anything
		
		
		// Set up data structures for the adjacency graph.
		ArrayList<HashSet<FAbstractEquation>> toNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		ArrayList<HashSet<FAbstractEquation>> fromNodes = new ArrayList<HashSet<FAbstractEquation>>(n_eqns);
		for (int i = 0; i < n_eqns; i++) {
			toNodes.add(new HashSet<FAbstractEquation>());
			fromNodes.add(new HashSet<FAbstractEquation>());
		}
		
		// For each equation
		for (FAbstractEquation eqn : eqns) {
			// Retrieve all variables referenced in right hand side
			Set<FVariable> deps = eqn.referencedFVariablesInRHS();
			// Build the actual adjacency graph.
			for (FVariable fv : deps) {
				FAbstractEquation depEqn = fv.parameterEquation();
				if (depEqn != null && depEqn.sortingIndex >= 0) {
					toNodes.get(depEqn.sortingIndex).add(eqn);		
					fromNodes.get(eqn.sortingIndex).add(depEqn);
				}
			}
		}	
				
		// Sort using algorithm described at
		// http://en.wikipedia.org/wiki/Topological_sorting
		List<FAbstractEquation> L = new List<FAbstractEquation>();
		Queue<FAbstractEquation> S = new ArrayDeque<FAbstractEquation>();
		
		// Add all nodes without incoming edges to S
		for (int i = 0; i < n_eqns; i++) 
			if (fromNodes.get(i).isEmpty()) 
				S.add(eqns.get(i));
		
		// Repeat while S is not empty
		int si = 0;
		int n_indep = 0;
		while (S.size() > 0) {
			// Remove a node n from S
			FAbstractEquation n = S.remove();
			L.add(n);
			// For each node m with an edge e from n to m (in original order)
			Set<FAbstractEquation> nodes = FAbstractEquation.sortingSet();
			nodes.addAll(toNodes.get(n.sortingIndex));
			for (FAbstractEquation m : nodes) {
				// Remove edge e from fromNodes
				fromNodes.get(m.sortingIndex).remove(n);
				// If m has no incoming edges add m to S
				if (fromNodes.get(m.sortingIndex).isEmpty()) 
					S.add(m);
			}
			// Remove e from toNodes
			toNodes.get(n.sortingIndex).clear();
			// Done with n - update sortingIndex
			n.sortingIndex = si++;
		}
		
		// Not possible to find an ordering without cycles?
		if (L.getNumChild() != eqns.size() - n_indep) {
			error("The model "+ name() +" contains cyclic parameter dependencies.");
		} else {
			// Replace old parameter equation list
			setFParameterEquationList(L);
			
			// Rearrange parameters in same order as parameter equations
			ArrayList<FVariable> depParams = new ArrayList<FVariable>(n_eqns);
			ArrayList<Integer> depParamIndices = new ArrayList<Integer>(n_eqns);
			for (int i = 0; i < n_vars; i++) {
				FVariable fv = vars.getChild(i);
				if (fv.hasParameterEquation()) {
					depParams.add(fv);
					depParamIndices.add(new Integer(i));
				}
			}
			FVariable.sortParameters(depParams);
			for (int i = 0; i < depParams.size(); i++)
				vars.setChild(depParams.get(i), depParamIndices.get(i).intValue());
	
			// Flush AST since the structure has changed.
				root().flushAllRecursive();
			
			// Remove any binding expressions of variables with parameter equations
			for (FAbstractEquation eqn : L)
				eqn.removeBindingExpOfAssignedVars();
		}
	}
	
	/**
	 * Remove binding expression of variables assigned in this equation.
	 */
	public void FAbstractEquation.removeBindingExpOfAssignedVars() {}

	public void FEquation.removeBindingExpOfAssignedVars() {
		getLeft().removeBindingExpOfReferencedVars();
	}
	
	public void FFunctionCallEquation.removeBindingExpOfAssignedVars() {
		for (FFunctionCallLeft left : getLefts())
			if (left.hasFExp())
				left.getFExp().removeBindingExpOfReferencedVars();
	}
	
	/**
	 * Remove binding expression of variables referenced in this expression.
	 */
	public void FExp.removeBindingExpOfReferencedVars() {
		for (FExp e : childFExps())
			e.removeBindingExpOfReferencedVars();
	}
	
	public void FIdUseExp.removeBindingExpOfReferencedVars() {
		getFIdUse().myFV().removeBindingExp();
	}
	
	/**
	 * Remove binding expression of this variable.
	 */
	public void FAbstractVariable.removeBindingExp() {}
	
	public void FVariable.removeBindingExp() {
		if (hasBindingExp())
			setBindingExpOpt(new Opt());
	}
	
	/**
	 * Test if this should be the binding expression of an independent parameter instead.
	 */
	syn boolean FAbstractEquation.isIndependentParameterEquation() = false;
	eq FEquation.isIndependentParameterEquation() = 
		getLeft().isFlatParameterUse() && getRight().isIndependentParameterExp();
	
	/**
	 * Test if this is a use of a parameter (in the flat tree).
	 */
	syn boolean FExp.isFlatParameterUse()   = false;
	eq FIdUseExp.isFlatParameterUse()       = getFIdUse().isFlatParameterUse();
	syn boolean FIdUse.isFlatParameterUse() = myFV().isParameter();
	
	/**
	 * Convert this parameter equation to a binding expression.
	 */
	public void FAbstractEquation.revertToBindingExp() {}
	public void FEquation.revertToBindingExp() throws ConstantEvaluationException {
		FVariable fv = (FVariable) ((FIdUseExp) getLeft()).getFIdUse().myFV();
		fv.setBindingExp(getRight().ceval().buildLiteral());
	}

}

aspect DummyDerivatives {

	rewrite FDerExp {
		when (myFV().isDummyDerivativeVariable()) to FDummyDerExp {
			return new FDummyDerExp(getFIdUse());
		}
	}

	rewrite FHDerExp {
		when (myFV().isDummyDerivativeVariable()) to FHDummyDerExp {
			return new FHDummyDerExp(getFIdUse(),getOrder());
		}
	}
	
	public void ASTNode.enableFHDerRewrite() {
		for (ASTNode n : this)
			n.enableFHDerRewrite();
	}
	
	public void FHDerExp.enableFHDerRewrite() {
		rewriteFHDer = true;
		is$Final = false;
	}
	
	boolean FHDerExp.rewriteFHDer = false;

	public void FHDerivativeVariable.enableFHDerRewrite() {
		rewriteFHDer = true;
		is$Final = false;
	}
	
	boolean FHDerivativeVariable.rewriteFHDer = false;

	rewrite FHDerExp {
		when (rewriteFHDer) to FDerExp 
		new FDerExp(getFIdUse().getFQName().createDerPrefixedName(getOrder() - 1));
	}

}

aspect TransformCanonicalErrorCheck {
	
	/**
	 * The number of DAE equations corresponds to the equivalent scalar number
	 * of equations.
	 */
	syn int FClass.numDAEEquations() = numScalarEquations();
	
	/**
	 * The number of equations in the DAE initialization system originating 
	 * from the DAE should be the same as the equivalent scalar number of
	 * equations. The equations may differ, however, due to inactive when
	 * clauses.
	 */
	syn int FClass.numDAEEquationsAtInitialization() 
		= numScalarEquationsAtInitialization();
	
	/**
	 * The number of unknown variables in the DAE corresponds to the number
	 * of real algebraic variables plus the number of derivative variables
	 * plus the number of discrete variables.
	 */
	syn int FClass.numDAEVariables() = 
		numAlgebraicContinousRealVariables() + 
		numDifferentiatedRealVariables() + numDiscreteVariables();
	
	/**
	 * The number of equations in the DAE initialization system is the 
	 * number of scalar DAE equations plus the number of scalar initial
	 * equations.
	 */	
	syn int FClass.numDAEInitEquations() = numDAEEquationsAtInitialization() + 
        numInitialScalarEquations();
	
	/**
	 * The number of unknowns in the DAE initialization system is the 
	 * number of unknowns in the DAE system plus the number of differentiated
        * variables plus the number of (pre) discrete variables.
        */
       syn int FClass.numDAEInitVariables() = numDAEVariables() +
               numDifferentiatedRealVariables() + numDiscretePreVariables() +
               numNonFixedParameters();

       public void FClass.checkFClassDimensions() {
               // Check dimensions of DAE
		int n_eq_F = numDAEEquations();
		int n_vars_F = numDAEVariables();
		if (n_eq_F != n_vars_F) 
			error("The DAE system has " + n_eq_F + " equations and " + n_vars_F + " free variables.");
		
		// Check dimensions of DAE initialization system
		int n_eq_F0 = numDAEInitEquations();
		int n_vars_F0 = numDAEInitVariables();
		if (n_eq_F0 > n_vars_F0) 
			error("The DAE initialization system has " + n_eq_F0 + " equations and " + n_vars_F0 + " free variables.");
		
	}
	
	public void FClass.collectErrors(ErrorCheckType checkType) {
		checkDuplicateVariables();
		checkFClassDimensions();
		checkStructure();
	}
}

aspect FlushFClass {
	/**
	 * \brief Flush all caches, including collection attributes.
	 */
	public void ASTNode.flushAll() {
		flushCache();
		flushCollectionCache();
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. In addition, the is$final attribute is set to false
	 * for FExps in order to enable rewrites of such nodes after elimination 
	 * of alias variables and after function inlining.
	 */
	public void ASTNode.flushAllRecursiveClearFinal() {
		flushAll();
		//is$Final = false;
		for (ASTNode n : noTransform()) {
			n.flushAllRecursiveClearFinal();
		}
	}
	
	public void FExp.flushAllRecursiveClearFinal() {
		super.flushAllRecursiveClearFinal();
		is$Final = false;
	}

	/**
	 * \brief Flush all caches, including collection attributes, and also
	 * flush all children. 
	 */
	public void ASTNode.flushAllRecursive() {
		flushAll();
		for (ASTNode n : noTransform()) {
			n.flushAllRecursive();
		}
	}
	
	/**
	 * \brief Flush model AST and enable rewrites of FIdUseExps and FDerExps
	 * after alias elimination.
	 */
	public void FClass.flush() {
		flushAllRecursiveClearFinal();
		//is$Final = true;
	}
	
	/**
	 * Traverse entire tree, forcing any pending rewrites to occur.
	 */
	public void ASTNode.forceRewrites() {
        for (ASTNode n : this) 
            n.forceRewrites();
	}
	
}



aspect Tearing {
	
	
}



aspect FunctionInlining {


    public class FClass {
        /**
         * If function inlining is enabled, inline all function calls that we can.
         * 
         * Then remove functions that aren't needed anymore.
         */
        public class functionInliningIfSet extends Transformation {
            private String opt;
            
            public boolean active() {
                opt = root().options.getStringOption("inline_functions");
                return opt != OptionRegistry.Inlining.NONE;
            }
            
            public void perform() {
                inlineFunctions(opt);
            }
        }
    }
	
	/**
	 * Inline all function calls that we can.
	 */
	public void FClass.inlineFunctions(String opt) {
		new FunctionInliner(this, opt).inline();
		root().flushAllRecursive();
		removeUnusedTemporaries();
		root().flushAllRecursiveClearFinal();
	}
	
	public class FFunctionDecl {
		/**
		 * Describes the possible inputs from the user concerning if and how to inline the function.
		 */
		public enum InlineAnnotation { 
			DEFAULT     (true, false), 
			NONE        (false, false), 
			INLINE      (true, true), 
			LATE        (true, true), 
			AFTER_INDEX (true, true);
			
			private boolean may;
			private boolean always;
			
			private InlineAnnotation(boolean may, boolean always) {
				this.may = may;
				this.always = always;
			}
			
			/**
			 * Check if the annotation says that we may try to inline the function.
			 */
			public boolean may() {
				return may;
			}
			
			/**
			 * Check if the annotation says that we should always try to inline the function.
			 */
			public boolean always() {
				return always;
			}
			
		}
		// TODO: handle LATE & AFTER_INDEX diffrently
		
		private InlineAnnotation inlineAnnotation = InlineAnnotation.DEFAULT;
		
		public void readInlineAnnotation(AnnotationNode a) {
			AnnotationNode inline = a.forPath("Inline");
			AnnotationNode late = a.forPath("LateInline");
			AnnotationNode index = a.forPath("InlineAfterIndexReduction");
			if (late.isBoolValue())
				inlineAnnotation = late.bool() ? InlineAnnotation.LATE : InlineAnnotation.NONE;
			if (inline.isBoolValue() && !(late.isBoolValue() && late.bool()))
				inlineAnnotation = inline.bool() ? InlineAnnotation.INLINE : InlineAnnotation.NONE;
			if (index.isBoolValue())
				inlineAnnotation = index.bool() ? InlineAnnotation.AFTER_INDEX : InlineAnnotation.NONE;
		}
		
		public void setInlineAnnotation(InlineAnnotation ia) {
		    inlineAnnotation = ia;
		}
	}
	
	/**
	 * Helper class for inlining.
	 * 
	 * Keeps track of all required data and the current state of the inlining process.
	 */
	public class FunctionInliner {
		
		private String level;
		
		private FClass fc;
		private FFunctionDecl func;
		private List<FVariable> vars;
		private List<FAbstractEquation> normalEqns;
		private List<FAbstractEquation> paramEqns;
		
		private Map<String,FExp> replMap;
		private FlatVariableMap lookupMap;
		private Map<String,Size> sizeMap;
		
		/**
		 * Create a new FunctionInliner to use with <code>fc</code>.
		 * 
		 * @param fc     the FClass to inline in
		 * @param level  decides how complex functions to inline, can take values 
		 *               from OptionRegistry.Inlining
		 */
		public FunctionInliner(FClass fc, String level) {
			this.fc = fc;
			this.level = level;
			vars = fc.getFVariables();
			normalEqns = fc.getFAbstractEquations();
			paramEqns = fc.getFParameterEquations();
			// Make sure maps are calculated
			fc.parameterEquationsMap();
			fc.variablesMap();
		}
		
		/**
		 * Inline all function calls that we can.
		 */
		public void inline() {
			inline(normalEqns);
			inline(paramEqns);
		}
		
		/**
		 * Inline all function calls that we can from a specific list of equations.
		 */
		public void inline(List<FAbstractEquation> eqns) {
			for (FAbstractEquation eqn : eqns) {
				while (eqn != null && eqn.hasInlinableFunctions(this)) {
					// Note that this will add new equations to eqns, so we depend on
					// List.iterator() to handle that correctly.
					eqn = eqn.inlineFunctions(this);
				}
			}
		}
		
		/**
		 * Check if a given function should be inlined under the current inlining level.
		 */
		public boolean isInlinable(FFunctionDecl func) {
			if (level == OptionRegistry.Inlining.ALL)
				return func.isInlinable();
			if (level == OptionRegistry.Inlining.TRIVIAL)
				return func.isTrivialInlinable();
			return false;
		}
		
		/**
		 * Prepare for inlining a new function call.
		 * 
		 * @return  the map to use for lookups in the function during inlining.
		 */
		public FlatVariableMap startFunction(FFunctionDecl f) {
			replMap = new HashMap<String,FExp>();
			lookupMap = new FlatVariableMap();
			sizeMap = new HashMap<String,Size>();
			func = f;
			return lookupMap;
		}
		
		public void setSizeOf(String name, Size size) {
			sizeMap.put(name, size);
		}

		/**
		 * Get the expression to use for a specific variable of the function 
		 * currently being inlined.
		 * 
		 * @param name  the name of the variable
		 */
		public FExp getReplacementExp(String name) {
			return replMap.get(name);
		}

		/**
		 * Set the expression to use for a specific variable of the function 
		 * currently being inlined.
		 * 
		 * @param name  the name of the variable
		 * @param exp   the expression to use
		 */
		public void setReplacementExp(String name, FExp exp) {
			replMap.put(name, exp);
		}
		
		/**
		 * Check if this function inliner has created a temporary variable of the specified name.
		 * 
		 * @param name  the name of the temporary variable
		 */
		public boolean isReplacementVar(String name) {
			return lookupMap.lookup(name) != null;
		}

		/**
		 * Find the size of a specific variable of the function currently being inlined.
		 * 
		 * @param name  the name of the variable
		 */
		public Size lookupSize(String name) {
			return sizeMap.get(name);
		}

		/**
		 * Add a variable and (if not constant) an equation for an assignment.
		 * 
		 * @param oldName  the name of the variable that was assigned in the function
		 * @param value    the right-hand side of the equation
		 * @param noEvent  if true, make sure no events are generated for the equation
		 */
		public void addVarAndEqn(String oldName, FExp value, boolean noEvent) {
			FTypePrefixVariability variability = value.variability().fullCopy();
			if (value.type().addVarInInline()) {
				FVariable var = addVar(oldName, variability, value.type());
				if (variability.constantVariability()) {
					value = value.ceval().buildLiteral();
					var.setBindingExp(value);
					replMap.put(oldName, value);
				} else {
					if (noEvent)
						value = value.preventEvents();
					FEquation eqn = new FEquation(new FNormalEquation(), var.createUseExp(), value);
					addEquation(eqn, variability);
				}
			} else {
				replMap.put(oldName, value);
			}
		}

		/**
		 * Add variables and (if not constant) an equation for a function call statement.
		 * 
		 * @param lefts  the lefts of the function call statement
		 * @param call   the new function call
		 */
		public void addVarsAndFCEqn(List<FFunctionCallLeft> lefts, FAbstractFunctionCall call) {
            int nLefts = lefts.getNumChild();
            FTypePrefixVariability variability = (nLefts == 0) ? ASTNode.fContinuous() : call.variability().fullCopy();
			
			FExp[] exps = null;
			if (variability.constantVariability()) {
				try {
					CValue[] values = call.evaluate();
					exps = new FExp[values.length];
					for (int i = 0; i < values.length; i++)
						exps[i] = values[i].buildLiteral();
				} catch (ConstantEvaluationException e) {
					exps = null;
				}
			}

			if (exps == null)
				exps = new FExp[nLefts];
			FExp[] lExps = new FExp[nLefts];
			for (int i = 0; i < nLefts; i++) 
				lExps[i] = lefts.getChild(i).createInlineVars(this, exps[i], variability);
			
			if (!variability.constantVariability()) {
				call = (FAbstractFunctionCall) call.preventEvents();
				FFunctionCallEquation eqn = 
					new FFunctionCallEquation(new FNormalEquation(), new List(), call);
				for (FExp exp : lExps) {
					FFunctionCallLeft left = new FFunctionCallLeft();
					if (exp != null)
						left.setFExp(exp);
					eqn.addLeft(left);
				}
				addEquation(eqn, variability);
			}
		}
		
		private void addEquation(FAbstractEquation eqn, FTypePrefixVariability variability) {
			if (variability.parameterVariability()) {
				paramEqns.add(eqn);
				eqn.addToParameterEquationsMap(fc.parameterEquationsMap());
			} else {
				normalEqns.add(eqn);
			}
		}
		
		public FVariable addVar(String oldName, FTypePrefixVariability variability, FType type) {
			String n = fc.nextTempVarName(func);
			FQName name = type.isArray() ? 
					new FQNameFull(n, type.size().flattenFArraySubscripts(new FQNameEmpty())) : 
					new FQNameString(n);
			
			FVariable var = type.createTempFVariable(name, variability);
			vars.add(var);
			vars.getChild(vars.getNumChild() - 1);
			
			setSizeOf(oldName, type.size());
			lookupMap.addVariable(var);
			fc.variablesMap().addVariable(var);
			replMap.put(oldName, var.createUseExp());
			return var;
		}
		
	}
	
	
	public void FExp.addInliningVarsAndEqns(FunctionInliner fi, String oldName, boolean noEvent) {
		fi.addVarAndEqn(oldName, this, noEvent);
	}
	
	public void FArray.addInliningVarsAndEqns(FunctionInliner fi, String oldName, boolean noEvent) {
		fi.setSizeOf(oldName, size());
		Array arr = getArray();
		for (Index i : indices())
			arr.get(i).addInliningVarsAndEqns(fi, oldName + i, noEvent);
	}
	
	public void FRecordConstructor.addInliningVarsAndEqns(FunctionInliner fi, String oldName, boolean noEvent) {
		oldName += ".";
		Iterator<FExp> exps = getArgs().iterator();
		for (FRecordComponentType part : ((FRecordType) type()).getComponents())
			exps.next().addInliningVarsAndEqns(fi, oldName + part.getName(), noEvent);
	}
	
	
	/**
	 * Should expressions of this type generate new varriables during inlining?
	 */
	syn boolean FType.addVarInInline()      = true;
	eq FExternalObjectType.addVarInInline() = false;
	
	
	/**
	 * Create temporary variable(s) for this access when inlining a function call that 
	 * it is a left of, and return an access.
	 */
	public FExp FFunctionCallLeft.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		return hasFExp() ? getFExp().createInlineVars(fi, bExp, variability) : null;
	}
	
	/**
	 * Create temporary variable(s) for this access when inlining a function call that 
	 * it is a left of, and return an access. Non-access expressions returns null.
	 */
	public FExp FExp.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		return null;
	}
	
	public FExp FIdUseExp.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FVariable var = fi.addVar(scalarName(), variability, type());
		if (bExp != null) {
			var.setBindingExp(bExp);
			fi.setReplacementExp(scalarName(), bExp);
		}
		return var.createUseExp();
	}
	
	public FExp FArray.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FArray bArr = (FArray) bExp;
		FArray res = new FArray();
		int n = getNumFExp();
		for (int i = 0; i < n; i++) {
			FExp cellBExp = (bArr != null) ? bArr.getFExp(i) : null;
			res.addFExp(getFExp(i).createInlineVars(fi, cellBExp, variability));
		}
		return res;
	}
	
	public FExp FRecordConstructor.createInlineVars(
			FunctionInliner fi, FExp bExp, FTypePrefixVariability variability) {
		FRecordConstructor bRec = (FRecordConstructor) bExp;
		FRecordConstructor res = new FRecordConstructor(getRecord().fullCopy(), new List());
		Iterator<FExp> bArgs = (bRec != null) ? bRec.getArgs().iterator() : null;
		for (FExp arg : getArgs()) {
			FExp partBExp = (bArgs != null) ? bArgs.next() : null;
			res.addArg(arg.createInlineVars(fi, partBExp, variability));
		}
		return res;
	}
	

	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public FExp FExp.preventEvents() {
		if (eventGenerating()) {
			FNoEventExp res = new FNoEventExp();
			replaceMe(res);
			res.setFExp(this);
			return res;
		} else {
			for (FExp e : childFExps())
				e.preventEvents();
			return this;
		}
	}
	
	public FExp FNoEventExp.preventEvents() {
		return this;
	}
	
	public FExp FFunctionCall.preventEvents() {
		for (FExp e : getArgs())
			e.preventEvents();
		return this;
	}
	
	public FExp FIdUseExp.preventEvents() {
		getFIdUse().getFQName().preventEvents();
		return this;
	}

	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public void FQName.preventEvents() {}
	public void FQNameFull.preventEvents() {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript s : part.getFArraySubscripts().getFSubscripts())
					s.preventEvents();
	}
	
	/**
	 * Encapsulate any event-generating expressions in noEvent().
	 */
	public void FSubscript.preventEvents() {}
	public void FExpSubscript.preventEvents() {
		getFExp().preventEvents();
	}
	
	/**
	 * Check if this expression generates events.
	 * 
	 * Does not consider subexpressions.
	 */
	syn boolean FExp.eventGenerating() = false;
	eq FIfExp.eventGenerating()        = true;
	eq FRelExp.eventGenerating()       = getLeft().isContinuousExp() || getRight().isContinuousExp();
	eq FEventGenExp.eventGenerating() = true;
	// TODO: support more event-generating expressions
	
	/**
	 * Check if this expression or any subexpressions can cause events. 
	 */
	syn boolean FExp.generatesEvents() {
		if (eventGenerating())
			return true;
		for (FExp e : childFExps())
			if (e.generatesEvents())
				return true;
		return false;
	}
	eq FNoEventExp.generatesEvents() = false;
	eq FIdUseExp.generatesEvents()   = getFIdUse().getFQName().generatesEvents();
	
	syn boolean FQName.generatesEvents() = false;
	eq FQNameFull.generatesEvents() {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript s : part.getFArraySubscripts().getFSubscripts())
					if (s.generatesEvents())
						return true;
		return false;
	}
	
	syn boolean FSubscript.generatesEvents() = false;
	eq FExpSubscript.generatesEvents()       = getFExp().generatesEvents();
	
	/**
	 * Check if this equation can cause events. 
	 */
	syn boolean FAbstractEquation.generatesEvents() = false;
	eq FEquation.generatesEvents()                  = getLeft().generatesEvents() || getRight().generatesEvents();
	eq FFunctionCallEquation.generatesEvents()      = getCall().generatesEvents();
	eq FAlgorithm.generatesEvents()                 = relExpInEquation().size() > 0;
	
	/**
	 * Check if an equation contains any calls to functions that we can inline.
	 */
	syn boolean FAbstractEquation.hasInlinableFunctions(FunctionInliner fi) = false;
	eq FFunctionCallEquation.hasInlinableFunctions(FunctionInliner fi)      = 
		getCall().hasInlinableFunctions(fi);
	eq FEquation.hasInlinableFunctions(FunctionInliner fi)                  =
		getLeft().hasInlinableFunctions(fi) || getRight().hasInlinableFunctions(fi);
	eq FIfEquation.hasInlinableFunctions(FunctionInliner fi)                = 
		super.hasInlinableFunctions(fi) || (hasElse() && getElse().hasInlinableFunctions(fi));
	eq FIfWhenElseEquation.hasInlinableFunctions(FunctionInliner fi) {
	    if (isWhen())
	        return false;
		for (FAbstractEquation eqn : getFAbstractEquations())
			if (eqn.hasInlinableFunctions(fi))
				return true;
		return false;
	}
	
	/**
	 * Check if an expression contains any calls to functions that we can inline.
	 */
	syn boolean FExp.hasInlinableFunctions(FunctionInliner fi) {
		for (FExp exp : childFExps())
			if (exp.hasInlinableFunctions(fi))
				return true;
		return false;
	}
	eq FFunctionCall.hasInlinableFunctions(FunctionInliner fi) =
		isInlinableFunctionCall(fi) || super.hasInlinableFunctions(fi);
	eq FIdUseExp.hasInlinableFunctions(FunctionInliner fi)     = 
		getFIdUse().getFQName().hasInlinableFunctions(fi);
	
	/**
	 * Check if any array subscripts contain any calls to functions that we can inline.
	 */
	syn boolean FQName.hasInlinableFunctions(FunctionInliner fi) {
		return false;
	}
	
	syn boolean FQNameFull.hasInlinableFunctions(FunctionInliner fi) {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
					if (sub.hasInlinableFunctions(fi))
						return true;
		return false;
	}
	
	/**
	 * Check if an array subscript contains any calls to functions that we can inline.
	 */
	syn boolean FSubscript.hasInlinableFunctions(FunctionInliner fi) = false;
	eq FExpSubscript.hasInlinableFunctions(FunctionInliner fi)       = 
		getFExp().hasInlinableFunctions(fi);
	
	/**
	 * Check if an expression is a call to a function that we can inline.
	 */
	syn boolean FExp.isInlinableFunctionCall(FunctionInliner fi) = false;
	eq FFunctionCall.isInlinableFunctionCall(FunctionInliner fi) = myFFunctionDecl().isInlinable(fi);
	

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public FAbstractEquation FAbstractEquation.inlineFunctions(FunctionInliner fi) {
		return this;
	}
	
	public FAbstractEquation FEquation.inlineFunctions(FunctionInliner fi) {
		getLeft().inlineFunctions(fi);
		getRight().inlineFunctions(fi);
		return this;
	}
	
	public FAbstractEquation FFunctionCallEquation.inlineFunctions(FunctionInliner fi) {
		if (getCall().isInlinableFunctionCall(fi)) {
			getCall().inline(fi);
			ArrayList<FFunctionVariable> outs = ((FFunctionCall) getCall()).myOutputs();
			int n = getNumLeft();
			ArrayList<FEquation> list = new ArrayList<FEquation>();
			for (int i = 0; i < n; i++) {
				if (getLeft(i).hasFExp()) {
					FQName name = outs.get(i).getFQName().fullCopy();
					name.removeFArraySubscripts();
					name.scalarized = true;
					getLeft(i).getFExp().createInliningOutputEquations(list, fi, name, getType());
				}
			}
			replaceMeWithList(list);
			return (list.size() > 0) ? list.get(0) : null;
		} else {
			getCall().inlineFunctions(fi);
			return this;
		}
	}
	
	public FAbstractEquation FIfEquation.inlineFunctions(FunctionInliner fi) {
		super.inlineFunctions(fi);
		if (hasElse())
			getElse().inlineFunctions(fi);
		return this;
	}
	
	public FAbstractEquation FIfWhenElseEquation.inlineFunctions(FunctionInliner fi) {
		fi.inline(getFAbstractEquations());
		return this;
	}
	
	public void FExp.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		FExp right = fi.getReplacementExp(name.scalarName());
		right = (right == null) ? type().zeroLiteral() : right.fullCopy();
		list.add(new FEquation(type.fullCopy(), this, right));
	}
	
	public void FArray.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		int i = 1;
		for (FExp exp : getFExps()) {
			FQName cellName = name.copyAndAddSubscript(new FIntegerSubscript(i));
			exp.createInliningOutputEquations(list, fi, cellName, type);
			i++;
		}
	}
	
	public void FRecordConstructor.createInliningOutputEquations(
			ArrayList<FEquation> list, FunctionInliner fi, FQName name, FEquationType type) {
		Iterator<FExp> args = getArgs().iterator();
		for (FRecordComponentType part : ((FRecordType) type()).getComponents()) {
			FQName partName = name.copyAndAppend(part.getName());
			args.next().createInliningOutputEquations(list, fi, partName, type);
		}
	}
	
	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FExp.inlineFunctions(FunctionInliner fi) {
		for (FExp exp : childFExps())
			exp.inlineFunctions(fi);
	}
	
	public void FFunctionCall.inlineFunctions(FunctionInliner fi) {
		if (isInlinableFunctionCall(fi)) {
			inline(fi);
			replaceMe(fi.getReplacementExp(myOutputs().get(0).name()).fullCopy());
		} else {
			super.inlineFunctions(fi);
		}
	}

	public void FIdUseExp.inlineFunctions(FunctionInliner fi) {
		getFIdUse().getFQName().inlineFunctions(fi);
	}

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FQName.inlineFunctions(FunctionInliner fi) {}

	public void FQNameFull.inlineFunctions(FunctionInliner fi) {
		for (FQNamePart part : getFQNameParts())
			if (part.hasFArraySubscripts())
				for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
					sub.inlineFunctions(fi);
	}

	/**
	 * Inline all calls to functions that we can inline.
	 */
	public void FSubscript.inlineFunctions(FunctionInliner fi) {}

	public void FExpSubscript.inlineFunctions(FunctionInliner fi) {
		getFExp().inlineFunctions(fi);
	}
	
	/**
	 * Inline this function call.
	 * 
	 * Base implementation throws exception.
	 */
	public void FAbstractFunctionCall.inline(FunctionInliner fi) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * Inline this function call. 
	 */
	public void FFunctionCall.inline(FunctionInliner fi) {
		myFFunctionDecl().inline(fi, getArgs());
	}
	
	/**
	 * Create a use exp for non-constant variables, and a literal for constant variables.
	 */
	public FExp FVariable.createInlineUseFExp() {
		try {
			return isConstant() ? ceval().buildLiteral() : createUseExp();
		} catch (ConstantEvaluationException e) {
			return createUseExp();
		}
	}
	
	private static final String ASTNode.REPLACE_UNKNOWN_CHILD_MSG = 
		"Trying to replace a child that is not found in the given position.";

	/**
	 * Replace a child of this node.
	 * 
	 * @param child  the child to replace
	 * @param repl   the node to replace it with
	 * @throws IllegalArgumentException  if <code>child</code> is not a child of this node
	 */
	private void ASTNode.replaceChild(ASTNode child, ASTNode repl) {
		int i = getIndexOfChild(child);
		if (i < 0)
			throw new IllegalArgumentException(REPLACE_UNKNOWN_CHILD_MSG);
		setChild(repl, i);
	}

	/**
	 * Replace a child of this node with a list of new nodes.
	 * 
	 * @param child  the child to replace
	 * @param repl   the node to replace it with
	 * @throws IllegalArgumentException  if <code>child</code> is not a child of this node
	 */
	private void ASTNode.replaceChildWithList(ASTNode child, Iterable<? extends ASTNode> repl) {
		int i = getIndexOfChild(child);
		if (i < 0)
			throw new IllegalArgumentException(REPLACE_UNKNOWN_CHILD_MSG);
		Iterator<? extends ASTNode> it = repl.iterator();
		if (it.hasNext()) {
			setChild(it.next(), i);
			while (it.hasNext())
				insertChild(it.next(), ++i);
		} else {
			removeChild(i);
		}
	}
	
	/**
	 * Replace this node in the tree.
	 * 
	 * @param repl  the node to replace it with
	 */
	protected void ASTNode.replaceMe(ASTNode repl) {
		ASTNode p = getParent();
		if (p != null) { 
			if (p instanceof DynamicOpt)
				p.setChild(repl, 0);
			else
				p.replaceChild(this, repl);
		}
	}
	
	/**
	 * Replace this node in the tree with a list of new nodes.
	 * 
	 * @param repl  the list of nodes to replace it with
	 */
	protected void ASTNode.replaceMeWithList(Iterable<? extends ASTNode> repl) {
		ASTNode p = getParent();
		if (p != null)
			p.replaceChildWithList(this, repl);
	}
	
	
	// TODO: check for recursive functions
	/**
	 * Check if we can inline this function, given the inlining level set in <code>fi</code>.
	 */
	syn boolean FFunctionDecl.isInlinable(FunctionInliner fi) =
		fi.isInlinable(this);
	
	
	private boolean FFunctionDecl.containsExtObjArrays(ArrayList<FFunctionVariable> variables) {
		for (FFunctionVariable var : variables)
			if (var.getType().isExternalObjectArray())
				return true;
		return false;
	}
	
	private boolean FFunctionDecl.hasInlinableIO() {
		return !containsExtObjArrays(myInputs()) && !containsExtObjArrays(myOutputs());
	}
	
	/**
	 * Check if we can inline this function.
	 */
	syn lazy boolean FFunctionDecl.isInlinable() =
		inlineAnnotation.may() && isAllInlinable(getFAlgorithm().getFStatements()) && hasInlinableIO();
	// TODO: Add warning if a function where user suggests inlining can't be inlined?

	/**
	 * Check if this function falls under the "trivial" inlining category.
	 */
	syn lazy boolean FFunctionDecl.isTrivialInlinable() {
		if (!inlineAnnotation.may())
			return false;
		if (inlineAnnotation.always())
			return isInlinable();
		if (myProtected().size() > 0)
			return false;
		if (!hasInlinableIO())
			return false;
		for (FStatement stmt : getFAlgorithm().getFStatements())
			if (!stmt.isOkTrivialInline())
				return false;
		for (FFunctionVariable out : myOutputs()) {
			TrivialInlineCheck chk = out.createTrivialInlineCheck();
			for (FIdUse use : out.assigningUses()) 
				chk.check(use);
			if (!chk.isOk())
				return false;
		}
		return true;
	}
	
	/**
	 * Helper method to find unsupported statements in isTrivialInlinable().
	 */
	syn boolean FStatement.isOkTrivialInline() = false;
	eq FAssignStmt.isOkTrivialInline()         = true;
	eq FFunctionCallStmt.isOkTrivialInline()   = getCall().isOkTrivialInline();
	eq FReturnStmt.isOkTrivialInline()         = isLast();
	eq FForStmt.isOkTrivialInline()            = isOkTrivialInlineInFor();
	
	/**
	 * Helper method to find unsupported statements in isTrivialInlinable().
	 */
	syn boolean FAbstractFunctionCall.isOkTrivialInline() = isIgnored();
	eq FFunctionCall.isOkTrivialInline()                  = myFFunctionDecl().isTrivialInlinable();
	
	/**
	 * Helper method to unsupported statements in isTrivialInlinable().
	 */
	syn boolean FStatement.isOkTrivialInlineInFor() = false;
	eq FAssignStmt.isOkTrivialInlineInFor()         = getLeft().myFV().size().isUnknown();
	eq FForStmt.isOkTrivialInlineInFor() {
		for (FStatement stmt : getForStmts())
			if (!stmt.isOkTrivialInlineInFor())
				return false;
		return true;
	}
	
	/**
	 * Create a TrivialInlineCheck object for this variable.
	 */
	public TrivialInlineCheck FAbstractVariable.createTrivialInlineCheck() {
		if (isArray()) {
			if (isRecord())
				return new TrivialInlineCheck.Unsupported();
			if (size().isUnknown())
				return new TrivialInlineCheck.UnknownArray();
			else
				return new TrivialInlineCheck.KnownArray(size().numElements());
		} else {
			if (isRecord())
				return new TrivialInlineCheck.Record(myFRecordDecl());
			else
				return new TrivialInlineCheck.Scalar();
		}
	}
	
	/**
	 * Record keeper object for checking that each output is assigned exactly once.
	 * 
	 * For arrays, a rough guess heuristic is used. Arrays of records and records 
	 * containing arrays of unknown size are not supported.
	 */
	public abstract class TrivialInlineCheck {
		protected abstract void check(FIdUse use, int i);
		protected abstract void checkAll(FIdUse use);
		public abstract boolean isOk();
		
		public void check(FIdUse use) { check(use, 1); }
		
		public static class Scalar extends TrivialInlineCheck {
			protected int n = 0;
			protected void check(FIdUse use, int i) { n++; }
			protected void checkAll(FIdUse use)     { n++; }
			public boolean isOk()                   { return n == 1; }
		}
		
		public static class KnownArray extends Scalar {
			// TODO: check that each cell is assigned?
			protected int size;
			public KnownArray(int nElems)       { size = nElems; };
			protected void checkAll(FIdUse use) { n += size; }
			public boolean isOk()               { return n == size; }
		}
		
		public static class UnknownArray extends Scalar {
			// TODO: check sizes, and how loop indices are used?
			protected void check(FIdUse use, int i) { n += use.inForLoop() ? 1 : 2; }
			protected void checkAll(FIdUse use)     { n++; }
		}
		
		public static class Record extends TrivialInlineCheck {
			protected Map<String,TrivialInlineCheck> parts;
			protected boolean namesOk;
			
			public Record(FRecordDecl rec) {
				namesOk = true;
				parts = new HashMap<String,TrivialInlineCheck>();
				for (FVariable v : rec.getFVariables())
					parts.put(v.name(), v.createTrivialInlineCheck());
			}
			
			protected void check(FIdUse use, int i) {
				if (i < use.getFQName().numParts()) {
					TrivialInlineCheck part = parts.get(use.getFQName().partName(i));
					if (part != null)
						part.check(use, i + 1);
					else
						namesOk = false;
				} else {
					checkAll(use);
				}
			}
			
			protected void checkAll(FIdUse use) {
				for (TrivialInlineCheck part : parts.values())
					part.checkAll(use);
			}

			public boolean isOk() {
				for (TrivialInlineCheck part : parts.values())
					if (!part.isOk())
						return false;
				return namesOk;
			}
		}
		
		public static class Unsupported extends TrivialInlineCheck {
			protected void check(FIdUse use, int i) { }
			protected void checkAll(FIdUse use)     { }
			public boolean isOk()                   { return false; }
		}
		
		// TODO: records
	}
	
	inh boolean FIdUse.inForLoop();
	eq FForStmt.getForStmt().inForLoop() = true;
	eq FAlgorithm.getChild().inForLoop() = false;
	eq FlatRoot.getChild().inForLoop()   = false;
	eq InstRoot.getChild().inForLoop()   = false;
	
	
	/**
	 * Helper method to check if a list of statements are all inlinable.
	 */
	public static boolean ASTNode.isAllInlinable(Iterable<? extends FStatement> list) {
		for (FStatement stmt : list)
			if (!stmt.isInlinable())
				return false;
		return true;
	}
	
	/**
	 * Check if we can inline this statement.
	 */
	syn boolean FStatement.isInlinable() = false;
	eq FInitArrayStmt.isInlinable()      = true;
	eq FAssignStmt.isInlinable()         = true;
	eq FFunctionCallStmt.isInlinable()   = getCall().isIgnored() || !insideBranchedStmt();
	eq FReturnStmt.isInlinable()         = isLast();
	eq FForStmt.isInlinable()            = isAllInlinable(getForStmts());
	eq FIfStmt.isInlinable() {
		for (FIfWhenClause branch : getFIfWhenClauses())
			if (!isAllInlinable(branch.getFStatements()))
				return false;
		return isAllInlinable(getElseStmts());
	}
	// TODO: handle more types of stmts
	
	
	/**
	 * Flags that this function is being inlined.
	 */
	private boolean FFunctionDecl.duringInlining = false;
	
	/**
	 * Keep reference to function inliner during inlining for size lookup.
	 */
	public FunctionInliner FFunctionVariable.functionInliner = null;
	
	/**
	 * Inline a call to this function.
	 * 
	 * @param fi    the function inlining helper to use
	 * @param args  the argument list for the function call
	 */
	public void FFunctionDecl.inline(FunctionInliner fi, List<FExp> args) {
		duringInlining = true;
		tempLookupMap = fi.startFunction(this);
		flushAllRecursive();
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.functionInliner = fi;
		
		ArrayList<FFunctionVariable> inp = myInputs();
		for (int i = 0; i < inp.size(); i++) 
			args.getChild(i).addInliningVarsAndEqns(fi, inp.get(i).name(), false);
		
		ArrayList<FFunctionVariable> outp = myOutputs();
		for (FFunctionVariable fv : outp) 
			if (fv.isArray())
				fi.setSizeOf(fv.name(), fv.size().copyAndReplaceReferences(fi, getDummyExp()));
		
		for (FStatement stmt : getFAlgorithm().getFStatements()) 
			stmt.inline(fi);
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.functionInliner = null;
		
		tempLookupMap = null;
		duringInlining = false;
	}
	
	syn lazy FExp FFunctionDecl.getDummyExp() = new FNoExp();
	
	/**
	 * Inline this statement.
	 * 
	 * @param fi      the function inlining helper to use
	 */
	public void FStatement.inline(FunctionInliner fi) {}
	
	public void FAssignStmt.inline(FunctionInliner fi) {
		FExp right = getRight().fullCopy();
		right = getRight().dynamicFExp(right);
		right = right.replaceReferences(fi);
		FIdUseExp left = (FIdUseExp)getLeft().dynamicFExp(getLeft().fullCopy());
		left.replaceReferencesInSubscripts(fi);
		right.addInliningVarsAndEqns(fi, left.scalarName(), true);
	}

	public void FFunctionCallStmt.inline(FunctionInliner fi) {
		// Temporarily replace lefts with scalarized versions
		Map<String,FExp> empty = Collections.emptyMap();
		List<FFunctionCallLeft> oldLefts = getLefts();
		List<FFunctionCallLeft> newLefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft left : oldLefts)
			newLefts.add(left.scalarize(empty));
		setLeftList(newLefts);
		newLefts.clearScalarized();
		
		// Scalarize and replace references
		FExp call = getCall().scalarizeExp(empty);
		call = getCall().dynamicFExp(call);
		call.clearScalarized();
		call = call.replaceReferences(fi);
		
		fi.addVarsAndFCEqn(getLefts(), (FAbstractFunctionCall) call);
		
		// Restore old left list
		setLeftList(oldLefts);
	}

	public void FInitArrayStmt.inline(FunctionInliner fi) {
		FAbstractVariable fv = getFIdUseExp().myFV();
		fi.setSizeOf(fv.name(), fv.size().copyAndReplaceReferences(fi, getFIdUseExp()));
		fv.flushCache();
	}
	
	public void FIfStmt.inline(FunctionInliner fi) {
		// Reduce to list of assignments
		List<FStatement> stmts = new List<FStatement>();
		inlinePrepare(fi, stmts);
		
		// Add assignments to tree temporarily
		List<FStatement> oldElse = getElseStmts();
		setElseStmtList((List) stmts);
		getElseStmtList();
		
		// Inline them
		for (FStatement stmt : stmts)
			stmt.inline(fi);
		
		// Restore old else branch
		setElseStmtList(oldElse);
	}
	
	public void FForStmt.inline(FunctionInliner fi) {
		// Reduce to list of assignments
		List<FStatement> stmts = new List<FStatement>();
		inlinePrepare(fi, stmts);
		
		// Add assignments to tree temporarily
		List<FStatement> oldStmt = getForStmts();
		setForStmtList((List) stmts);
		getForStmtList();
		
		// Inline them
		for (FStatement stmt : stmts)
			stmt.inline(fi);
		
		// Restore old else branch
		setForStmtList(oldStmt);
	}
	
	// TODO: handle more types of stmts
	
	/**
	 * Simplify a statement into a list of assignments, that can then easily be inlined.
	 */
	public void FStatement.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {}

	public void FAssignStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		stmts.add(fullCopy());
	}

	public void FFunctionCallStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		if (!getCall().isIgnored())
			stmts.add(fullCopy());
	}

	public void FIfStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		List<FStatement> oldElse = getElseStmts();
		
		// Prepare contents
		List<FStatement> newElse = new List<FStatement>();
		for (FStatement stmt : oldElse)
			stmt.inlinePrepare(fi, newElse);
		setElseStmtList((List) newElse);
		
		// Combine branches to assignments with if-else expressions
		for (int i = getNumFIfWhenClause() - 1; i >= 0; i--) {
			newElse = getFIfWhenClause(i).inlineCombineBranches(fi, newElse);
			setElseStmtList((List) newElse);
		}
		
		// Write result to target list
		for (FStatement stmt : newElse)
			stmts.add(stmt);
		setElseStmtList(oldElse);
	}

	public void FForStmt.inlinePrepare(FunctionInliner fi, List<FStatement> stmts) {
		List<FStatement> oldStmts = getForStmts();
		
		// Prepare contents
		List<FStatement> newStmts = new List<FStatement>();
		for (FStatement stmt : oldStmts)
			stmt.inlinePrepare(fi, newStmts);
		setForStmtList((List) newStmts);
		
		// Unroll loop
		FVariable index = getIndex().getFVariable();
		FExp loopExp = getIndex().getFExp();
		loopExp = loopExp.dynamicFExp(loopExp.fullCopy()).replaceReferences(fi);
		for (FExp e : loopExp.getArray().iterable()) {
			stmts.add(new FAssignStmt(index.createUseExp(), e.fullCopy()));
			for (FStatement stmt : newStmts)
				stmts.add(stmt.fullCopy());
		}
		setForStmtList(oldStmts);
	}
	
	/**
	 * Create a list of assign statements with if-else expressions that is the 
	 * equivalent of two branches of an if-else statement.
	 * 
	 * @param fi         the function inliner to use
	 * @param elseStmts  the else branch to combine
	 */
	protected List<FStatement> FIfWhenClause.inlineCombineBranches(
			FunctionInliner fi, List<FStatement> elseStmts) {
		// Prepare contents
		List<FStatement> oldStmts = getFStatements();
		List<FStatement> newStmts = new List<FStatement>();
		for (FStatement stmt : oldStmts)
			stmt.inlinePrepare(fi, newStmts);
		setFStatementList((List) newStmts);
		
		// First inefficient implementation
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : newStmts)
			stmts.add(createIfElseAssignment(stmt, null));
		for (FStatement stmt : elseStmts)
			stmts.add(createIfElseAssignment(null, stmt));
		// End first implementation
		
		// Clean up
		setFStatementList(oldStmts);
		return stmts;
	}
	
	/**
	 * Create an assign statement with an if-else exception as the right side, 
	 * that is equivalent to two assignments to the the same variable. One 
	 * assignment from this if branch, and one other from the next branch.
	 * If one of the assignments is null, then an access to the variable being 
	 * assigned is used there (i.e. a no-op). At least one must be non-null.
	 * 
	 * If any of the statements is not an assign statement, then 
	 * IllegalArgumentException is thrown.
	 * 
	 * @param left   the assignment from this branch
	 * @param right  the assignment from the next branch
	 */
	protected FAssignStmt FIfWhenClause.createIfElseAssignment(FStatement leftStmt, FStatement rightStmt) {
		try {
			FAssignStmt left = (FAssignStmt) leftStmt;
			FAssignStmt right = (FAssignStmt) rightStmt;
			FIdUseExp lhs = ((left != null) ? left : right).getLeft().fullCopy();
			FExp test = getTest().fullCopy(); // TODO: use temp var instead
			FExp leftExp = createIfElseExpBranch(left, lhs);
			FExp rightExp = createIfElseExpBranch(right, lhs);
			return new FAssignStmt(lhs, new FIfExp(test, leftExp, rightExp));
		} catch (ClassCastException e) {
			throw new IllegalArgumentException();
		}
	}
	
	private FExp FIfWhenClause.createIfElseExpBranch(FAssignStmt ass, FIdUseExp var) {
		return (ass != null) ? ass.getRight().fullCopy() : var.fullCopy();
	}
	
	/**
	 * Replace all variable references according to the inlining helper.
	 */
	public ASTNode ASTNode.replaceReferences(FunctionInliner fi) {
		for (ASTNode n : this)
			n.replaceReferences(fi);
		return this;
	}
	
	public FExp FExp.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		return this;
	}
	
	public FExp FSizeExp.replaceReferences(FunctionInliner fi) {
		if (getFExp() instanceof FIdUseExp) {
			String name = ((FIdUseExp) getFExp()).getFIdUse().name();
			FExp exp = fi.lookupSize(name).createFExp(dimension());
			replaceMe(exp);
			return exp;
		} else {
			return super.replaceReferences(fi);
		}
	}
	
	// TODO: Should probably be removed after simplification step has been added
	public FExp FIfExp.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		if (getIfExp().isConstantExp()) {
			boolean useThen = getIfExp().ceval().booleanValue();
			FExp exp = useThen ? getThenExp() : getElseExp();
			replaceMe(exp);
			return exp;
		}
		return this;
	}
	
	public FExp FIdUseExp.replaceReferences(FunctionInliner fi) {
		replaceReferencesInSubscripts(fi);
		FExp exp = fi.getReplacementExp(scalarName());
		if (exp != null) {
			exp = dynamicFExp(exp.fullCopy());
		} else {
			if (fi.isReplacementVar(name())) {
				exp = this;
			} else if (isArray() && !size().isUnknown()) { 
				exp = getArray().buildWithReplacedReferences(fi, this);
			} else if (type().isRecord()) {
				exp = dynamicFExp(type().createRecordConstructor(getFIdUse().getFQName()));
				exp = exp.replaceReferences(fi);
			} else {
				exp = type().zeroLiteral();
			}
		}
		if (exp != this)
			replaceMe(exp);
		return exp;
	}
	
	public FExp FFunctionCall.replaceReferences(FunctionInliner fi) {
		super.replaceReferences(fi);
		Size[] old = getSizes();
		Size[] sizes = new Size[old.length];
		for (int i = 0; i < old.length; i++)
			if (old[i] != null)
				sizes[i] = old[i].copyAndReplaceReferences(fi, this);
		setSizes(sizes);
		return this;
	}
	
	public class Array {
		
		public FExp buildWithReplacedReferences(FunctionInliner fi, FExp context) {
			return buildFArray(new ReplaceReferenceBuilder(fi, context));
		}

		protected class ReplaceReferenceBuilder implements ElementBuilder {
	    	private FunctionInliner fi;
	    	private FExp context;
	    	
	    	public ReplaceReferenceBuilder(FunctionInliner fi, FExp context) {
	    		this.fi = fi;
	    		this.context = context;
	    	}
	    	
			public FExp build(FExp e) {
				return context.dynamicFExp(e).replaceReferences(fi);
			}
	    }
		
	}
	
	/**
	 * Replace all variable references in array subscripts according to the inlining helper.
	 */
	public void ASTNode.replaceReferencesInSubscripts(FunctionInliner fi) {
		for (ASTNode n : this)
			n.replaceReferencesInSubscripts(fi);
	}
	
	public void FExpSubscript.replaceReferencesInSubscripts(FunctionInliner fi) {
		getFExp().replaceReferences(fi);
	}
	
	/**
	 * Make a copy of this size with all variable references replaced according to the 
     * function inliner.
	 */
	public Size Size.copyAndReplaceReferences(FunctionInliner fi, FExp context) {
		return clone();
	}
	
	public MutableSize MutableSize.copyAndReplaceReferences(FunctionInliner fi, FExp context) {
		MutableSize res = clone();
		for (int i = 0; i < exps.length; i++)
			if (res.exps[i] != null)
				res.exps[i] = context.dynamicFExp(exps[i].fullCopy()).replaceReferences(fi);
		return res;
	}
	
	/*
	 * We must be able to tell the difference between discrete and continous expressions 
	 * during function inlining. Normally all expressions in functions are considered discrete.
	 */
	refine FlatVariability eq FExp.inDiscreteLocation() = inWhen() || (inFunction() && !duringFunctionInlining());
	
	/*
	 * We want to be able to scalarize all expressions (except size exps) fully during inlining.
	 */
	refine Scalarization eq FFunctionCallLeft.getFExp().canAcceptArray() = 
		Scalarization.FFunctionCallLeft.getFExp().canAcceptArray() && !duringFunctionInlining();
	refine Scalarization eq FFunctionCall.getArg().canAcceptArray()      = 
		Scalarization.FFunctionCallLeft.getArg().canAcceptArray() && !duringFunctionInlining();
	refine Scalarization eq FFunctionCall.getArg().wantsRecordCon()      = 
		Scalarization.FFunctionCall.getArg().wantsRecordCon() || duringFunctionInlining();
	eq FFunctionCallLeft.getFExp().wantsRecordCon()                      = 
		!inFunction() || duringFunctionInlining();

	inh boolean FFunctionCallLeft.duringFunctionInlining();
	inh boolean FExp.duringFunctionInlining();
	eq FFunctionDecl.getChild().duringFunctionInlining() = duringInlining;
	eq Root.getChild().duringFunctionInlining()          = false;
	
	/*
	 * Use the information we have on unknown sizes during inlining.
	 */
	refine Arrays eq FFunctionArray.size() {
		Size s = null;
		if (functionInliner != null)
			s = functionInliner.lookupSize(name());
		return (s == null) ? Arrays.FFunctionArray.size() : s;
	}
	
	
	/**
	 * Remove unused function declarations from the flat model.
	 */
	public void FClass.removeUnusedFunctions() {
		beginStep("removeUnusedFunctions()");
		getFVariables().markUsedFunctions();
		getFInitialEquations().markUsedFunctions();
		getFParameterEquations().markUsedFunctions();
		getFAbstractEquations().markUsedFunctions();
		List<FFunctionDecl> funcs = new List<FFunctionDecl>();
		for (FFunctionDecl func : getFFunctionDecls())
			if (func.functionIsUsed())
				funcs.add(func);
		setFFunctionDeclList(funcs);
		endStep("removeUnusedFunctions()");
	}
	
	public class FFunctionDecl {
		public enum UseType{
			NONE(false, false),
			ALIAS_ATTRIBUTE_USE(false, false),
			ANNOTATION_DERIVATIVE(true, false),
			DIRECT(true, true);
			
			private final boolean normalUse;
			private final boolean derivativeUse;
			UseType(boolean normalUse, boolean derivativeUse) {
				this.normalUse = normalUse;
				this.derivativeUse = derivativeUse;
			}
			public boolean normalUse() {
				return normalUse;
			}
			public boolean derivativeUse() {
				return derivativeUse;
			}
			
			public UseType combine(UseType other) {
				return compareTo(other) > 0 ? this : other;
			}
		}
	}
	
	private UseType FFunctionDecl.functionUsed = UseType.NONE;
	
	/**
	 * Has this function been marked as used?
	 */
	syn boolean FFunctionDecl.functionIsUsed() = functionUsed != UseType.NONE;
	
	/**
	 * Has this function been marked as used?
	 */
	syn boolean FFunctionDecl.functionIsUsedAsDerivative() = functionUsed.derivativeUse();
	
	/**
	 * Mark all called functions as used.
	 */
	public void ASTNode.markUsedFunctions() {
		markUsedFunctions(FFunctionDecl.UseType.DIRECT);
	}
	public void ASTNode.markUsedFunctions(FFunctionDecl.UseType type) {
		for (ASTNode node : this)
			node.markUsedFunctions(type);
	}
	
	public void FVariable.markUsedFunctions(FFunctionDecl.UseType type) {
		AliasManager.AliasSet set = aliasSet();
		if (type != FFunctionDecl.UseType.ALIAS_ATTRIBUTE_USE && set != null)
			for (AliasManager.AliasVariable alias : set)
				if (alias.getFVariable() != this)
					alias.getFVariable().markUsedFunctions(FFunctionDecl.UseType.ALIAS_ATTRIBUTE_USE);
		super.markUsedFunctions(type);
	}
	
	public void FFunctionCall.markUsedFunctions(FFunctionDecl.UseType type) {
		myFFunctionDecl().markUsedFunctions(type);
		super.markUsedFunctions(type);
	}
	
	public void FFunctionDecl.markUsedFunctions(UseType type) {
		UseType oldType = functionUsed;
		functionUsed = functionUsed.combine(type);
		if (functionUsed != oldType) {
			if (functionUsed == UseType.DIRECT &&
			   (root().options.getBooleanOption("generate_block_jacobian") ||
			    root().options.getBooleanOption("generate_dae_jacobian") ||
			    root().options.getBooleanOption("generate_ode_jacobian"))) {
				if (requiresDerivative() && !canDifferentiate()) {
					error("Unable to determine derivative function for function '" + name() + "'");
				} else if (hasFDerivativeFunction()) {
					getFDerivativeFunction().myFFunctionDecl().markUsedFunctions(UseType.ANNOTATION_DERIVATIVE);
				}
			}
			super.markUsedFunctions(functionUsed);
		}
	}

}

aspect StateInitialEquations {

    public class FClass {
        public class addStateInitialEquationsIfSet extends Transformation {
            public addStateInitialEquationsIfSet() {
                super("state_initial_equations");
            }
            
            public void perform() {
                addStateInitialEquations();
            }
        }
    }
	
	public void FClass.addStateInitialEquations() {
		setFInitialEquationList(new List());
		
		for (FRealVariable fv : differentiatedRealVariables()) {
			FQName nameToAdd = fv.getFQName().copyAndAddPrefix("_start_");
			FRealVariable fvToAdd = new FRealVariable(new FPublicVisibilityType(), new FParameter(), nameToAdd);
			if (fv.startAttributeSet())
			    fvToAdd.setBindingExp(fv.startAttributeExp().fullCopy());
			else
			    fvToAdd.setBindingExp(fv.type().zeroLiteral());
			addFVariable(fvToAdd);
			FEquation eqnToAdd = new FEquation(fv.createUseExp(), fvToAdd.createUseExp());
			addFInitialEquation(eqnToAdd);
			flushAllRecursive();
		}
	}
	
}

aspect RuntimeOptions {
	

    public class FClass {
        /**
         * Add parameters for all defined runtime options.
         */
        public class addRuntimeOptionParameters extends Transformation {
            public boolean active() {
                OptionRegistry opt = root().options;
                return opt.getBooleanOption("generate_runtime_option_parameters") && opt.getBooleanOption("generate_ode");
            }
            
            public void perform() {
                OptionRegistry opt = root().options;
                for (String key : opt.getRuntimeOptionKeys()) {
                    FVariable v = null;
                    String name = "_" + key;
                    if (opt.isBooleanOption(key))
                        v = createBooleanRuntimeOptionParameter(name, opt.getBooleanOption(key));
                    else if (opt.isStringOption(key))
                        v = createStringRuntimeOptionParameter(name, opt.getStringOption(key));
                    else if (opt.isIntegerOption(key))
                        v = createIntegerRuntimeOptionParameter(name, opt.getIntegerOption(key));
                    else if (opt.isRealOption(key))
                        v = createRealRuntimeOptionParameter(name, opt.getRealOption(key));
                    addFVariable(v);
                }
            }
        }
    }
	
	/**
	 * Create a parameter for a boolean runtime option. 
	 */
	public FVariable FClass.createBooleanRuntimeOptionParameter(String name, boolean val) {
		return commonCreateRuntimeOptionParameter(new FBooleanVariable(), name, FBooleanLitExp.create(val));
	}
	
	/**
	 * Create a parameter for a string runtime option. 
	 */
	public FVariable FClass.createStringRuntimeOptionParameter(String name, String val) {
		return commonCreateRuntimeOptionParameter(new FStringVariable(), name, new FStringLitExp(val));
	}
	
	/**
	 * Create a parameter for a integer runtime option. 
	 */
	public FVariable FClass.createIntegerRuntimeOptionParameter(String name, int val) {
		return commonCreateRuntimeOptionParameter(new FIntegerVariable(), name, new FIntegerLitExp(val));
	}
	
	/**
	 * Create a parameter for a real runtime option. 
	 */
	public FVariable FClass.createRealRuntimeOptionParameter(String name, double val) {
		return commonCreateRuntimeOptionParameter(new FRealVariable(), name, new FRealLitExp(val));
	}
	
	/**
	 * Set the children of a runtime option parameter.
	 * 
	 * @param v     the variable to set fields on
	 * @param name  the name of the variable
	 * @param bExp  the burrent value of the option
	 * @return  <code>v</code>, for convenience
	 */
	public FVariable FClass.commonCreateRuntimeOptionParameter(FVariable v, String name, FExp bExp) {
		v.setFVisibilityType(new FRuntimeOptionVisibilityType());
		v.setFTypePrefixVariability(new FParameter());
		v.setBindingExp(bExp);
		v.setFQName(new FQNameString(name));
		return v;
	}
	
	syn int FClass.numRuntimeOptionParameters() = runtimeOptionParameters().size();
	syn lazy ArrayList<FVariable> FClass.runtimeOptionParameters() {
		ArrayList<FVariable> res = new ArrayList<FVariable>();
		for (FVariable fv : independentParameters())  // They are always independent
			if (fv.isRuntimeOption())
				res.add(fv);
		return res;
	}
	
	syn boolean FVariable.isRuntimeOption() = getFVisibilityType().isRuntimeOptionVisibility();
	
	syn boolean FVisibilityType.isRuntimeOptionVisibility()     = false;
	eq FRuntimeOptionVisibilityType.isRuntimeOptionVisibility() = true;
	
}



aspect EventGeneratingExps {

    public class FClass {
        /**
         * Extracts event generating expressions into if expressions
         * and replaces the exp with a temp var.
         */
        public class extractEventGeneratingExps extends Transformation {
            public void perform() {
                HashSet<FAlgorithm> algs = new HashSet<FAlgorithm>();
                ArrayList<FEventGenExp> eventExps = eventGenExps();
                Collections.reverse(eventExps);
                
                // Equations
                for (FEventGenExp exp: eventExps) {
                	FVariable fv = exp.type().createFVariable(new FPublicVisibilityType(), 
							new FQNameFull(exp.tempVarName()), exp.variability());
					addFVariable(fv);
					addFInitialEquation(new FEquation(exp.tempPreExp(), fv.createStartAttributeExp()));
                	if (exp.inAlgorithm()) {
                		algs.add((FAlgorithm) exp.myFEquation());
                		continue;
                	}
                    exp.replaceMe(exp.tempUseExp());
                    addFEquation(new FEquation(exp.tempUseExp(), exp.asIfExp(exp.tempPreExp())));
                }
                
                // Algorithms
                AlgorithmTransformer.visit(algs, new EventAlgoTransformer());
                
                root().flushAllRecursive();
            }
        }
    }
		
	/**
	 * Collects all event generating expressions
	 */
	coll ArrayList<FEventGenExp> FClass.eventGenExps() 
		[new ArrayList<FEventGenExp>()] with add root FClass;
	FEventGenExp contributes this
		when inEquationSection() && generatesEvent()
		to FClass.eventGenExps()
		for myFClass();
	
	/**
	 * Collects event generating expressions in this statements
	 */
	coll ArrayList<FEventGenExp> FStatement.eventGenExps() 
		[new ArrayList<FEventGenExp>()] with add root FAlgorithm;
	FEventGenExp contributes this
		when inEquationSection() && generatesEvent()
		to FStatement.eventGenExps()
		for myFStatement();
		
	/**
	 * Extracts event generating expressions into if-expressions
	 */
	public class EventAlgoTransformer extends AlgorithmTransformer {
		public void transform(FStatement stmt) {
			ArrayList<FEventGenExp> eventExps = stmt.eventGenExps();
			Collections.reverse(eventExps);
			for (FEventGenExp exp : eventExps) {
				exp.replaceMe(exp.tempUseExp());
				add(new FAssignStmt(exp.tempUseExp(), exp.asIfExp(exp.tempPreExp())));
			}
			add(stmt);
		}
	}
	
	/**
	 * Creates an if-expression to replace this expression
	 */
	syn FIfExp FEventGenExp.asIfExp(FExp preExp) {
		FExp guards = new FOrExp(createGuardExp(preExp), new FInitialExp());
		FIfExp e = new FIfExp();
		e.setIfExp(guards);
		e.setThenExp(fullCopy());
		e.setElseExp(preExp.unboundCopy());
		return e;
	}
	
	/**
	 * Creates a guard expression for an event generating expression
	 * extracted to a when equation. (Integer inherits from floor.)
	 */
	syn FExp FEventGenExp.createGuardExp(FExp preExp);
	eq FFloorFuncExp.createGuardExp(FExp preExp) {
		FOrExp guards = new FOrExp(
			new FLtExp(getX().fullCopy(), preExp.fullCopy()),
			new FGeqExp(getX().fullCopy(), new FAddExp(preExp.fullCopy(), new FIntegerLitExp(1)))
		);
		return guards;
	}
	eq FCeilFuncExp.createGuardExp(FExp preExp) {
		FOrExp guards = new FOrExp(
			new FLeqExp(getX().fullCopy(), new FSubExp(preExp.fullCopy(), new FIntegerLitExp(1))),
			new FGtExp(getX().fullCopy(), preExp.fullCopy())
		);
		return guards;
	}
	eq FDivFuncExp.createGuardExp(FExp preExp) {
		FOrExp guards = new FOrExp(
			new FLtExp(new FDivFuncExp(getX().fullCopy(), getY().fullCopy()), preExp.fullCopy()),
			new FGeqExp(new FDivFuncExp(getX().fullCopy(), getY().fullCopy()), new FAddExp(preExp.fullCopy(), new FIntegerLitExp(1)))
		);
		return guards;
	} 
	
	// These two are rewritten to floor and div containing expressions during flattening.
	eq FModFuncExp.createGuardExp(FExp preExp) {
		throw new UnsupportedOperationException();
	}
	eq FRemFuncExp.createGuardExp(FExp preExp) {
		throw new UnsupportedOperationException();
	}
}

aspect SemiLinear {

    public class FClass {
        public class enableSemiLinearRewrite extends Transformation {
            public void perform() {
                setFAbstractEquationList(transform(getFAbstractEquations()));
                setFInitialEquationList(transform(getFInitialEquations()));
                setFParameterEquationList(transform(getFParameterEquations()));
                
                // Change all remaining semiLinear exps to if exps. 
                for (FSemiLinearExp exp: collectSemiLinearExps())
                    exp.replaceMe(exp.asIfExp());
            }
            
            /**
             * Applies zero flow transformations to a list of equations.
             */
            private List<FAbstractEquation> transform(List<FAbstractEquation> equations) {
                Map<String,ArrayList<FEquation>> rule1 = new HashMap<String,ArrayList<FEquation>>();
                ArrayList<FEquation> rule2 = new ArrayList<FEquation>();
                List<FAbstractEquation> newEquations = new List<FAbstractEquation>();
                
                // Find zero flow equations
                for (FAbstractEquation equation : equations) {
                    if (equation.isConstantZeroFlow()) {
                        rule2.add((FEquation) equation);
                    } else if (equation.isZeroFlowForm()) {
                        FEquation e = (FEquation) equation;
                        String key = e.zeroFlowGetKey();
                        if (rule1.get(key) == null)
                            rule1.put(key, new ArrayList<FEquation>());
                        rule1.get(key).add(e);
                    }
                }
                
                // Chained zero flow transformations (Rule 1)
                for (ArrayList<FEquation> l : rule1.values()) {
                    if (l.size() > 1)
                        transformChain(newEquations, buildChain(l));
                }
                
                // Constant zero flow transformations (Rule 2)
                for (FEquation equation : rule2) {
                    equation.setLeft(equation.zeroFlowGetPos());
                    equation.setRight(equation.zeroFlowGetNeg());
                }
                
                List<FAbstractEquation> res = removeMarkedEqns(equations);
                res.addAll(newEquations);
                return res;
            }
            
            /**
             * Order the equations in <code>l</code> by matching the slopes in
             * the semiLinear expressions. If any equation cannot be ordered an
             * error is given.
             */
            private ArrayList<FEquation> buildChain(ArrayList<FEquation> l) {
                ArrayList<FEquation> chain = new ArrayList<FEquation>();
                FEquation eq1 = l.remove(0);
                chain.add(eq1);
                
                boolean change = true;
                while (change) {
                    change = false;
                    Iterator<FEquation> it = l.iterator();
                    while (it.hasNext()) {
                        FEquation eq2 = it.next();
                        if (addToChain(chain, eq2)) {
                            change = true;
                            it.remove();
                        }
                    }
                }
                
                if (l.size() > 0) {
                    StringBuilder sb = new StringBuilder();
                    sb.append("Could not construct zero flow chain for a set of semilinear equations."
                            + " This leads to an undetermined system. Involved equations:\n");
                    
                    for (FEquation e : chain) {
                        sb.append(e.prettyPrint(""));
                        sb.append("\n");
                    }
                    for (FEquation e : l) {
                        sb.append(e.prettyPrint(""));
                        sb.append("\n");
                    }
                    
                    l.get(0).error(sb.toString());
                }
                return chain;
            }
            
            /**
             * Add an equation to the chain if the slopes match
             */
            private boolean addToChain(ArrayList<FEquation> chain, FEquation equation) {
                FExp pos = equation.zeroFlowGetPos();
                FExp neg = equation.zeroFlowGetNeg();
                FExp chainNeg = chain.get(chain.size()-1).zeroFlowGetNeg();
                FExp chainPos = chain.get(0).zeroFlowGetPos();
                
                if (chainNeg.prettyPrint("").equals(pos.prettyPrint(""))) {
                    chain.add(equation);
                    return true;
                } else if (chainPos.prettyPrint("").equals(neg.prettyPrint(""))) {
                    chain.add(0, equation);
                    return true;
                }
                return false;
            }
            
            /**
             * Build new equations to represent the chain of semiLinears
             */
            private void transformChain(List<FAbstractEquation> newEquations, ArrayList<FEquation> chain) {
                for (FEquation e : chain)
                    e.markedForRemoval = true;
                
                FEquation first = chain.get(0);
                FEquation last  = chain.remove(chain.size()-1);
                FExp chainPos   = first.zeroFlowGetPos();
                FExp chainNeg   = last.zeroFlowGetNeg();
                FExp chainX     = chain.get(0).zeroFlowGetX();
                
                // S(1) = if X >= 0 SA else SB
                newEquations.add(new FEquation(
                        first.zeroFlowGetNeg().fullCopy(), 
                        new FIfExp(new FGeqExp(chainX.fullCopy(), new FIntegerLitExp(0)),
                                chainPos.fullCopy(),
                                chainNeg.fullCopy()
                                )));
                
                // S(n+1) = S(n)
                FEquation pre_e = null;
                for (FEquation e : chain) {
                    if (pre_e != null)
                        newEquations.add(new FEquation(e.zeroFlowGetNeg().fullCopy(), pre_e.zeroFlowGetNeg().fullCopy()));
                    pre_e = e;
                }
                
                // Y = semiLinear(X,SA,SB)
                FExp slExp = new FSemiLinearExp(chainX.fullCopy(), chainPos.fullCopy(), chainNeg.fullCopy());
                newEquations.add(new FEquation(
                        first.zeroFlowGetLeft().fullCopy(),
                        slExp.negated(first.zeroFlowNegated())
                        ));
            }
        }
    }
    
    syn boolean FAbstractEquation.isZeroFlowForm() = false;
    eq FEquation.isZeroFlowForm() { 
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return l.isZeroFlowForm(r) || r.isZeroFlowForm(l);
    }
    
    syn boolean FExp.isZeroFlowForm(FExp other) = false;
    eq FIdUseExp.isZeroFlowForm(FExp other) = other.isSemiLinear(); 
    
    syn boolean FAbstractEquation.isConstantZeroFlow() = false;
    eq FEquation.isConstantZeroFlow() { 
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        
        if (l.isZeroLiteral() && r.isSemiLinear()) {
            return ((FSemiLinearExp) r).getX().isZeroLiteral();
        }
        if (r.isZeroLiteral() && l.isSemiLinear()) {
            return ((FSemiLinearExp) l).getX().isZeroLiteral();
        }
        
        return false;
    }
    
    syn FIdUseExp FEquation.zeroFlowGetLeft() {
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return (FIdUseExp) (l.isSemiLinear() ? r : l);
    } 
    
    syn FSemiLinearExp FEquation.zeroFlowGetRight() {
        FExp l = getLeft().stripNegations();
        FExp r = getRight().stripNegations();
        return (FSemiLinearExp) (l.isSemiLinear() ? l : r);
    } 
    syn FExp FEquation.zeroFlowGetX()     = zeroFlowGetRight().getX().stripNegations();
    syn FExp FEquation.zeroFlowGetPos()   = zeroFlowGetRight().getX().isNegated() ? zeroFlowGetRight().getNegSlope() : zeroFlowGetRight().getPosSlope();
    syn FExp FEquation.zeroFlowGetNeg()   = zeroFlowGetRight().getX().isNegated() ? zeroFlowGetRight().getPosSlope() : zeroFlowGetRight().getNegSlope();
    
    syn boolean FEquation.zeroFlowNegated() = isNegated() ^ zeroFlowGetRight().getX().isNegated();
    
    syn String FEquation.zeroFlowGetKey() {
        StringBuilder sb = new StringBuilder();
        if (zeroFlowNegated())
            sb.append("-");
        sb.append(zeroFlowGetLeft().prettyPrint(""));
        sb.append("$");
        sb.append(zeroFlowGetX().prettyPrint(""));
        return sb.toString();
    }
    
	
	syn boolean FExp.isSemiLinear() = false;
	eq FSemiLinearExp.isSemiLinear() = true;
	
	syn FExp FSemiLinearExp.asIfExp() {
		FIfExp exp = new FIfExp(new FGeqExp(getX().fullCopy(), new FRealLitExp(0)),
			new FMulExp(getX().fullCopy(), getPosSlope().fullCopy()),
			new FMulExp(getX().fullCopy(), getNegSlope().fullCopy()));
		return exp;
	}
	
	/**
	 * Collects semiLinear expressions.
	 */
	coll HashSet<FSemiLinearExp> FClass.collectSemiLinearExps() 
		[new HashSet<FSemiLinearExp>()] with add root FClass;
	FSemiLinearExp contributes this
		to FClass.collectSemiLinearExps()
		for myFClass();
}

aspect ArrayAccessRewrite {
    public class FClass {
        public class enableArrayAccessRewrite extends Transformation {
            public void perform() {
                enableArrayAccessRewrite();
            }
        }
    }

    public void ASTNode.enableArrayAccessRewrite() {
        for (ASTNode n : this)
            n.enableArrayAccessRewrite();
    }
    
    public void FIdUseExp.enableArrayAccessRewrite() {
        super.enableArrayAccessRewrite();
        rewriteContinuousArrayAccess = true;
        is$Final = false;
    }
    
    private boolean FIdUseExp.rewriteContinuousArrayAccess = false;
    
    rewrite FIdUseExp {
        when (rewriteContinuousArrayAccess) to FExp {
            rewriteContinuousArrayAccess = false;
            FQName fqName = getFIdUse().getFQName();
            if (getFIdUse().indexVariability().parameterOrLess() || inFunction())
                return this;
            FQNameFull arrayArg = new FQNameFull();
            List<FExp> args = new List<FExp>();
            List<FFunctionVariable> funcVars = new List<FFunctionVariable>();
            Size inputSize = Size.SCALAR;
            Size outputSize = Size.SCALAR;
            FQNameFull arrayUse = new FQNameFull("x");
            Enumerator funcVarEnumerator = new Enumerator();
            for (FQNamePart orgPart : fqName.asFQNameFull().getFQNameParts()) {
                FQNamePart newPart = new FQNamePart(orgPart.name());
                if (orgPart.hasFArraySubscripts()) {
                    for (FSubscript sub : orgPart.getFArraySubscripts().getFSubscripts()) {
                        if (!sub.variability().parameterOrLess()) {
                            args.add(sub.asExpSubscript().getFExp().fullCopy());
                            String varName = "i_" + funcVarEnumerator.next();
                            funcVars.add(new FFunctionVariable(FIntegerType.SCALAR, varName, new FInput()));
                            arrayUse.addSubscript(new FExpSubscript(new FIdUseExp(varName)));
                            newPart = newPart.addSubscript(new FColonSubscript());
                            inputSize = inputSize.expandRight(Size.UNKNOWN);
                        } else if (sub.size() == Size.SCALAR) {
                            newPart = newPart.addSubscript(sub.fullCopy());
                        } else if(sub.size().ndims() == 1) {
                            newPart = newPart.addSubscript(sub.fullCopy());
                            inputSize = inputSize.expandRight(size().last());
                            outputSize = outputSize.expandRight(size().last());
                            arrayUse.addSubscript(new FColonSubscript());
                        } else {
                            throw new UnsupportedOperationException();
                        }
                    }
                }
                arrayArg.addFQNamePart(newPart);
            }
            args.add(new FIdUseExp(arrayArg));
            String funcName = myFClass().nextTempFuncName();
            FFunctionCall call = new FFunctionCall(new FIdUse(funcName), args, new Size[]{size()});
            funcVars.add(inputSize.createFunctionVariable("x", type(), new FInput()));
            funcVars.add(outputSize.createFunctionVariable("y", type(), new FOutput()));
            FFunctionDecl funcDecl = new FFunctionDecl(funcName, funcVars, new FAssignStmt(new FIdUseExp("y"), new FIdUseExp(arrayUse)), new FReturnStmt());
            funcDecl.setInlineAnnotation(FFunctionDecl.InlineAnnotation.NONE);
            myFClass().addFFunctionDecl(funcDecl);
            return call;
        }
    }
}


aspect ReinitStates {
    
    public class FClass {
        /**
         * Transformation for marking up variables that have reinit() applied on them as states
         * (by setting stateSelect=always).
         */
        public class MakeReinitedVarsStates extends Transformation {
            public void perform() {
                for (FAbstractEquation eqn : getFAbstractEquations())
                    eqn.makeReinitedVarsStates();
            }
        }
    }
    
    /**
     * Mark all variables reinited in this equation as states.
     */
    public void FAbstractEquation.makeReinitedVarsStates() {}
    
    public void FIfWhenElseEquation.makeReinitedVarsStates() {
        for (FAbstractEquation e : getFAbstractEquations())
            e.makeReinitedVarsStates();
    }
    
    public void FIfWhenEquation.makeReinitedVarsStates() {
        if (hasElse())
            getElse().makeReinitedVarsStates();
    }
    
    public void FFunctionCallEquation.makeReinitedVarsStates() {
        getCall().makeReinitedVarsStates();
    }
    
    /**
     * It this is a reinit(), mark reinited variable as state.
     */
    public void FAbstractFunctionCall.makeReinitedVarsStates() {}

    /**
     * Mark reinited variable as state.
     */
    public void FReinit.makeReinitedVarsStates() {
        getVar().markReferencedVarAsState();
    }
    
    /**
     * Mark referenced variable as state.
     * 
     * Only valid for variable accesses, default implementation throws exception.
     */
    public void FExp.markReferencedVarAsState() {
        throw new UnsupportedOperationException();
    }
    
    /**
     * Mark referenced variable as state.
     */
    public void FIdUseExp.markReferencedVarAsState() {
        myFV().markAsState();
    }
    
    /**
     * Mark this variable as a state, by setting stateSelect=always.
     */
    public void FAbstractVariable.markAsState() {
        throw new UnsupportedOperationException();
    }
    
    public void FVariable.markAsState() {
        FAttribute newA = new FInternalAttribute(FAttribute.STATE_SELECT, new FEnumLitExp(FAttribute.STATE_SELECT_TYPE, "always"));
        FAttribute oldA = findAttributeLocal(FAttribute.STATE_SELECT);
        if (oldA != null) {
            oldA.replaceMe(newA);
            addFAttribute(oldA);
        } else {
            addFAttribute(newA);
        }
    }
    
}

aspect EliminateEqualSwitches{
    public class FClass {
        /**
         * Reduce the number of event indicators by eliminating relative
         * operators that are equal. This is done by traversing the normal
         * equation system and the initial equation system and storing all
         * relative operations in a map that translate toString() to a list
         * of relative operators that are equal.
         * Operatorns are then eliminating by setting the originalFRelExp
         * field in the redundant operators.
         * The normal operator should be used if equal operators exists in
         * both the normal and initial blocks. This is achived by inserting all
         * normal equations into the map before the initial equations and then
         * selecting the first in the list as the original operator.
         */
        public class eliminateEqualSwitches extends Transformation {
            public void perform() {
                Map<String, Collection<FRelExp>> candidates = new HashMap<String, Collection<FRelExp>>();
                for (FRelExp exp : relExpInEquations())
                    exp.collectEqualSwitches(candidates);
                for (FRelExp exp : relExpInInitialEquations())
                    exp.collectEqualSwitches(candidates);
                for (Map.Entry<String, Collection<FRelExp>> entry : candidates.entrySet()) {
                    if (entry.getValue().size() < 2)
                        continue;
                    log.info("Eliminated %d equal switches: %s", entry.getValue().size() - 1, entry.getKey());
                    FRelExp original = null;
                    for (FRelExp exp : entry.getValue()) {
                        if (original == null)
                            original = exp;
                        else
                            exp.originalFRelExp = original;
                    }
                }
                root().flushAllRecursive();
            }
        }
    }
    
    public void FRelExp.collectEqualSwitches(Map<String, Collection<FRelExp>> candidates) {
        String key = toString();
        Collection<FRelExp> list = candidates.get(key);
        if (list == null) {
            list = new ArrayList<FRelExp>();
            candidates.put(key, list);
        }
        list.add(this);
    }
}