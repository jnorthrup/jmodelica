/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect FlatTypeAnalysis {

	syn lazy FPrimitiveType AbstractFVariable.type();
	eq FRealVariable.type() = fRealType();
	eq FIntegerVariable.type() = fIntegerType();
	eq FBooleanVariable.type() = fBooleanType();
	eq FStringVariable.type() = fStringType();
	eq FDerivativeVariable.type() = fRealType();
	eq UnknownFVariable.type() = fUnknownType();

	syn FPrimitiveType InstPrimitive.type() {
		if (isReal()) {
			return fRealType();
		} else if (isInteger()) {
			return fIntegerType();
		} else if (isBoolean()) {
			return fBooleanType();
		} else if (isString()) {
			return fStringType();
		} else {
			return fUnknownType();
		}
	}
	
	syn lazy FPrimitiveType FExp.type() = fUnknownType();
	
	eq FUnaryExp.type() = getFExp().type();
	eq FArtmBinExp.type() = getLeft().type().
	  binaryNumericPromotion(getRight().type());
	
	eq FLogBinExp.type() = fBooleanType();
	
	
	eq FRealLitExp.type() = fRealType();
	eq FIntegerLitExp.type() = fIntegerType();
	eq FBooleanLitExp.type() = fBooleanType();
	eq FStringLitExp.type() = fStringType();
	eq FTimeExp.type() = fRealType();
	eq FDer.type() = fRealType();
	
	eq FIdUseExp.type() = myFV().type();
	eq FInstAccessExp.type() = getInstAccess().myInstComponentDecl().isPrimitive()?
			((InstPrimitive)getInstAccess().myInstComponentDecl()).type() : fUnknownType();
	
}

aspect FNumericPromotion {
	
	syn FPrimitiveType FPrimitiveType.
	    binaryNumericPromotion(FPrimitiveType type) = fUnknownType();
	eq FNumericType.binaryNumericPromotion(FPrimitiveType type) {
		if (!type.isNumeric()) {
			return fUnknownType();
		} else {
			return isReal()? this : type; 
		}
	}
	
}

aspect FTypeCompatibility {
	syn boolean FPrimitiveType.typeCompatible(FPrimitiveType type) = false;
	eq FRealType.typeCompatible(FPrimitiveType type) = type.isReal() || type.isInteger();
	eq FIntegerType.typeCompatible(FPrimitiveType type) = type.isInteger();
	eq FBooleanType.typeCompatible(FPrimitiveType type) = type.isBoolean();
	eq FStringType.typeCompatible(FPrimitiveType type) = type.isString();
}

 aspect FTypeEquivalent {
	syn boolean FPrimitiveType.equivalentTo(FPrimitiveType type) = false;
	eq FRealType.equivalentTo(FPrimitiveType type) = type.isReal() || type.isInteger();
	eq FIntegerType.equivalentTo(FPrimitiveType type) = type.isInteger() || type.isReal();
	eq FBooleanType.equivalentTo(FPrimitiveType type) = type.isBoolean();
	eq FStringType.equivalentTo(FPrimitiveType type) = type.isString();
}


 aspect BuiltInFlatTypes {

 	syn nta FRealType Root.getFRealType() = new FRealType();
 	syn nta FIntegerType Root.getFIntegerType() = new FIntegerType();
 	syn nta FBooleanType Root.getFBooleanType() = new FBooleanType();
 	syn nta FStringType Root.getFStringType() = new FStringType();
 	syn nta FUnknownType Root.getFUnknownType() = new FUnknownType();

 	syn boolean InstPrimitive.isReal() = 
 		myInstClass().finalClass().primitiveName().equals("Real");
 	syn boolean InstPrimitive.isInteger() = 
 		myInstClass().finalClass().primitiveName().equals("Integer");
 	syn boolean InstPrimitive.isBoolean() = 
 		myInstClass().finalClass().primitiveName().equals("Boolean");
 	syn boolean InstPrimitive.isString() = 
 		myInstClass().finalClass().primitiveName().equals("String");

 	syn boolean FPrimitiveType.isReal() = false;
 	eq FRealType.isReal() = true;
 	syn boolean FPrimitiveType.isInteger() = false;
 	eq FIntegerType.isInteger() = true;
 	syn boolean FPrimitiveType.isBoolean() = false;
 	eq FBooleanType.isBoolean() = true;
 	syn boolean FPrimitiveType.isString() = false;
 	eq FStringType.isString() = true;
 	
 	syn boolean FPrimitiveType.isNumeric() = false;
 	eq FNumericType.isNumeric() = true;

 	syn boolean FPrimitiveType.isUnknown() = false;
 	eq FUnknownType.isUnknown() = true;

 	syn FPrimitiveType ASTNode.fRealType() = root().getFRealType();
 	syn FPrimitiveType ASTNode.fIntegerType() = root().getFIntegerType();
 	syn FPrimitiveType ASTNode.fBooleanType() = root().getFBooleanType();
 	syn FPrimitiveType ASTNode.fStringType() = root().getFStringType();
 	syn FPrimitiveType ASTNode.fUnknownType() = root().getFUnknownType();
 	
 }

 
/*
aspect ExpressionType {
	
	syn lazy AbstractFlatType FExp.type();	
	eq FUnsupportedExp.type() = new BrokenType();
	eq FInstAccessExp.type() = new BrokenType();
	
	syn lazy AbstractFlatType FVariable.type();	
	syn lazy AbstractFlatType FAbstractEquation.type() = new BrokenType();
	
	// TODO: fix this expression for arrays
	eq FVariable.type() {
		FPrimitiveType primitiveType = getType();
		if (hasBindingExp()) {
			FExp bindingExp = getBindingExp();
			AbstractFlatType bindingType = bindingExp.type();
			if (bindingType instanceof FlatType) {
				FlatType fBindingType = (FlatType) bindingType;
				if (!fBindingType.getFPrimitiveType().equals(primitiveType)) {
					error("The variable type and binding expression type do not match for variable " + this);
				}
			}
		}
		return(new FlatType(primitiveType, 0));
	}

	// TODO: FForIndex's are never type checked
	
	// TODO: does this equation need type checking?
	eq FForClauseE.type() {
		for (int j = 0; j < getNumForEqns();j++) {
			getForEqns(j).type();
		}
		return(emptyType());
	}
	
	eq FEquation.type() {
		return(getLeft().type().combine(getRight().type(),getLeft(),getRight()));
	}

	eq FLogBinExp.type() = checkLogicalTyping();
	eq FArtmBinExp.type() = checkArithmeticTyping();
	
	eq FAddExp.type() {
		AbstractFlatType tryValue = tryArithmeticTyping();
		if (tryValue.equals(emptyType())) {
			FPrimitiveType leftPrimitive = getLeftPrimitive();
			FPrimitiveType rightPrimitive = getRightPrimitive();
			if (leftPrimitive.equals(fStringType()) &&
				   rightPrimitive.equals(fStringType())) {
				return new FlatType(fStringType(), 0);
			} else {
				error("The types " + getLeft() + " and " + getRight() +
						"cannot be used on the operator " + this);
				return brokenType();
			}
		} else {
			return tryValue;
		}
	}	
	
	eq FAndExp.type() = checkBooleanLogicalTyping();
	eq FOrExp.type() = checkBooleanLogicalTyping();
	
	eq FUnaryExp.type() = getFExp().type();

	eq FRealLitExp.type() {
		String stringValue = getUNSIGNED_NUMBER();
		try {
			Integer.parseInt(stringValue);
			return new FlatType(fIntegerType(), 0);			
		} catch(NumberFormatException formatException) {}
		try {
			Double.parseDouble(stringValue);
			return new FlatType(fRealType(), 0);			
		} catch(NumberFormatException formatException) {}
		error(stringValue + " is not an integer value or a real value.");
		return brokenType();
	}
	
	eq FStringLitExp.type() = new FlatType(fStringType(), 0);
	eq FBooleanLitExpTrue.type() = new FlatType(fBooleanType(), 0);
	eq FBooleanLitExpFalse.type() = new FlatType(fBooleanType(), 0);

	eq FTimeExp.type() = new FlatType(fRealType(), 0);

	// TODO: Some error checking should be done here
	// The expression must be a subtype of real
	eq FDer.type() {
		warning("Type checking not implemented on der expressions.");
		return(getFIdUseExp().type());
	}

	eq FIfExp.type() {
		AbstractFlatType total = getThenExp().type();
		for (int i=0; i<getNumFElseIfExp(); i++) {
			total = total.combine(getFElseIfExp(i).type(),getThenExp(),getFElseIfExp(i));
		}
		total = total.combine(getElseExp().type(),getThenExp(),getElseExp());
		return total;
	}
	
	eq FElseIfExp.type() = getThenExp().type();	
	
	// TODO: implement function call types
	eq FFunctionCall.type() {
		warning("Error on function call: " + this + ". The type system has not been implemented for function calls.");		
		return brokenType();
	}

	// TODO: Array access expressions have a different type 
	// than the original array declaration.
	eq FIdUseExp.type() {
		AbstractFVariable variable = this.myFV();
		if (variable instanceof FVariable) {
			FVariable fVariable = (FVariable) variable;
			return(fVariable.type());			
		} else {
			error("Could not find declaration for variable " + this);
			return brokenType();
		}
	}	

	eq FExpList.type() {
		if (getNumFExp() > 0) {
			AbstractFlatType total = getFExp(0).type();			
			for (int i = 1; i < getNumFExp(); i++) {
				total = total.combine(getFExp(i).type(),getFExp(0),getFExp(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;				
				return new FlatType(flatTotal.getFPrimitiveType(), 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}
	}
	
	eq FMatrix.type() {
		if (getNumFExpList() > 0) {
			AbstractFlatType total = getFExpList(0).type();			
			for (int i = 1; i < getNumFExpList(); i++) {
				total = total.combine(getFExpList(i).type(),getFExpList(0),getFExpList(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;
				return new FlatType(flatTotal.getFPrimitiveType(), flatTotal.getNumberDimensions() + 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}
	}	
	
	eq FNoExp.type() {
		return emptyType();
	}
	
	eq FSumRedExp.type() {
		return getFExp().type();
	}

	// TODO: type checking on this expression
	eq FSizeExp.type() {
		return new FlatType(fIntegerType(), 0);
	}
	
	eq FArrayConstructor.type() {
		if (getNumFExp() > 0) {
			AbstractFlatType total = getFExp(0).type();			
			for (int i = 1; i < getNumFExp(); i++) {
				total = total.combine(getFExp(i).type(),getFExp(0),getFExp(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;				
				return new FlatType(flatTotal.getFPrimitiveType(), flatTotal.getNumberDimensions() + 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}		
	}

	// TODO: type checking on range expressions
	// See 3.4.4.5 of Modelica 2.2 Specification
	eq FRangeExp.type() {
		if (getNumFExp() > 0) {
			AbstractFlatType total = getFExp(0).type();			
			for (int i = 1; i < getNumFExp(); i++) {
				total = total.combine(getFExp(i).type(),getFExp(0),getFExp(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;			
				return new FlatType(flatTotal.getFPrimitiveType(), 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}		
	}

	FPrimitiveType FBinExp.getLeftPrimitive() {
		AbstractFlatType leftType = getLeft().type();		
		FlatType fLeftType = (FlatType) leftType;
		FPrimitiveType leftPrimitive = fLeftType.getFPrimitiveType();
		return leftPrimitive;
	}

	FPrimitiveType FBinExp.getRightPrimitive() {
		AbstractFlatType rightType = getRight().type();
		FlatType fRightType = (FlatType) rightType;
		FPrimitiveType rightPrimitive = fRightType.getFPrimitiveType();
		return rightPrimitive;		
	}	
	
	AbstractFlatType FLogBinExp.checkBooleanLogicalTyping() {
		if (!(getLeft().type() instanceof FlatType) ||
			!(getRight().type() instanceof FlatType)) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		}			
		boolean valid = false;
		FPrimitiveType leftPrimitive = getLeftPrimitive();
		FPrimitiveType rightPrimitive = getRightPrimitive();		
		if (leftPrimitive.equals(rightPrimitive) &&
			leftPrimitive.equals(fBooleanType())) {
			valid = true;
		}
		if (valid) return new FlatType(fBooleanType(), 0);
		else {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();
		}	
	}
	
	AbstractFlatType FLogBinExp.checkLogicalTyping() {
		if (!(getLeft().type() instanceof FlatType) ||
			!(getRight().type() instanceof FlatType)) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		}
		boolean valid = false;		
		FPrimitiveType leftPrimitive = getLeftPrimitive();
		FPrimitiveType rightPrimitive = getRightPrimitive();		
		if (leftPrimitive.equals(rightPrimitive)) {
			valid = true;
		} else if (leftPrimitive.equals(fRealType()) ||
				   rightPrimitive.equals(fRealType())) {
			if ((leftPrimitive.equals(fIntegerType()) ||
				leftPrimitive.equals(fRealType())) &&
				(rightPrimitive.equals(fIntegerType()) ||
				rightPrimitive.equals(fRealType()))) {
					valid = true;
			}
		}
		if (valid) return new FlatType(fBooleanType(), 0);
		else {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();
		}
	}
	
	AbstractFlatType FArtmBinExp.checkArithmeticTyping() {
		AbstractFlatType tryValue = tryArithmeticTyping();	
		if (tryValue.equals(emptyType())) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		} else {
			return tryValue;
		}		
	}
	
	AbstractFlatType FArtmBinExp.tryArithmeticTyping() {
		if (!(getLeft().type() instanceof FlatType) ||
			!(getRight().type() instanceof FlatType)) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		}		
		FPrimitiveType leftPrimitive = getLeftPrimitive();
		FPrimitiveType rightPrimitive = getRightPrimitive();		
		if (leftPrimitive.equals(fIntegerType()) && 
			rightPrimitive.equals(fIntegerType())) {
				return new FlatType(fIntegerType(), 0);
		} else if (leftPrimitive.equals(fRealType()) ||
				   rightPrimitive.equals(fRealType())) {
				if ((leftPrimitive.equals(fIntegerType()) ||
					leftPrimitive.equals(fRealType())) &&
					(rightPrimitive.equals(fIntegerType()) ||
					rightPrimitive.equals(fRealType()))) {
					return new FlatType(fRealType(), 0);
				} else {
					error("The types " + getLeft() + " and " + getRight() +
							"cannot be used on the operator " + this);					
					return brokenType();				
				}
		}
		return emptyType();
	}	
	
	
   	public abstract AbstractFlatType AbstractFlatType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp);
	
	public AbstractFlatType BrokenType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp) {
		return this;
	}
	
	public AbstractFlatType EmptyType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp) {
		if (other instanceof EmptyType) {
			return this;
		} else if (other instanceof FlatType) {
			otherExp.error("The types " + thisExp + " and " + otherExp + " do not match.");		
			return brokenType();	
		} else {
			return brokenType();
		}
	}
   	
   	public AbstractFlatType FlatType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp) {
   		if (other instanceof FlatType) {
   			FlatType fOther = (FlatType) other;
   			if (!this.getFPrimitiveType().getClass().equals(fOther.getFPrimitiveType().getClass())) {
   				thisExp.error("The types " + thisExp + " and " + otherExp + " do not match.");
   				return (brokenType());
   			}
   			if (this.getNumberDimensions() != fOther.getNumberDimensions()) {
   				thisExp.error("The dimensions " + thisExp + " and " + otherExp + " do not match."); 
   				return (brokenType());   			
   			}
   			return this;
   		} else if (other instanceof EmptyType) {
				thisExp.error("The types " + thisExp + " and " + otherExp + " do not match.");
				return (brokenType());
   		} else {
			return (brokenType());
   		}
	}			
	
}
*/