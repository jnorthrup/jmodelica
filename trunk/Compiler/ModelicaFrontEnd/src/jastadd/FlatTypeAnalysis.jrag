/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Arrays;

aspect FlatTypeAnalysis {

	syn lazy FPrimitiveType AbstractFVariable.type();
	eq FRealVariable.type() {
		if (ndims()==0) {
			return fRealScalarType();				
		} else {
			return fRealArrayType(size());
		}
	}
	eq FIntegerVariable.type() {
		if (ndims()==0) {
			return fIntegerScalarType();				
		} else {
			return fIntegerArrayType(size());
		}
	}
	eq FBooleanVariable.type() {
		if (ndims()==0) {
			return fBooleanScalarType();				
		} else {
			return fBooleanArrayType(size());
		}
	}
	eq FStringVariable.type() {
		if (ndims()==0) {
			return fStringScalarType();				
		} else {
			return fStringArrayType(size());
		}
	}
	eq FDerivativeVariable.type() = fRealScalarType();
	eq FFunctionVariable.type() = getType();
	eq UnknownFVariable.type() = fUnknownType();

	syn FPrimitiveType InstComponentModification.type() {
		if (getName().myInstComponentDecl().isPrimitive()) {
			InstPrimitive ip = ((InstPrimitive)getName().myInstComponentDecl());
			return ip.type();
		} else {
			return fUnknownType();
		}
	}
	
	syn FPrimitiveType InstPrimitive.type() {
		FPrimitiveType scalar = fUnknownType();
		if (isReal()) 
			scalar = fRealScalarType();
		else if (isInteger()) 
			scalar = fIntegerScalarType();
		else if (isBoolean()) 
			scalar = fBooleanScalarType();
		else if (isString()) 
			scalar = fStringScalarType();
		return isArray() ? scalar.arrayType(size()) : scalar;
	}
	
	syn lazy FPrimitiveType FExp.type() = fUnknownType();
	
	eq FUnaryExp.type()   = getFExp().type();
	eq FArtmBinExp.type() = getLeft().type().looseNumericPromotion(getRight().type());
	eq FAddExp.type()     = getLeft().type().numericPromotion(getRight().type());
	eq FSubExp.type()     = getLeft().type().numericPromotion(getRight().type());
	eq FNegExp.type()     = getFExp().type().isNumeric() ? getFExp().type() : fUnknownType();
	
	eq FNoEventExp.type() = getFExp().type();
	
	eq FDivExp.type() {
		if (getRight().type().isScalar())
			return super.type();
		else
			return fUnknownType();
	}
	
	eq FMulExp.type() {
		if (ndims() < 0)
			return fUnknownType();
		if (isElementWise())
			return super.type();
		Size left = getLeft().size();
		Size right = getRight().size();
		if (left.last() != right.get(0) || left.ndims() > 2 || right.ndims() > 2)
			return fUnknownType();
		FPrimitiveType res = getLeft().type().scalarNumericPromotion(getRight().type());
		if (left.ndims() == 1 && right.ndims() == 1) 
			return res;
		else
			return res.arrayType(size());
	}
	
	eq FPowExp.type() {
		if (getRight().type().isUnknown() || getRight().ndims() != 0)
			return fUnknownType();
		if (getLeft().ndims() == 0)
			return super.type();
		// Left operand is not scalar, must be matrix exponentiation
		if (ndims() != 2 || size().get(0) != size().get(1))
			return fUnknownType();
		if (!getRight().type().isInteger() || !getRight().isConstantExp())
			return fUnknownType();
		if (getRight().ceval().intValue() < 0)
			return fUnknownType();
		return getLeft().type();
	}
	
	eq FTranspose.type() = 
		getFExp().ndims() < 2 ? 
			fUnknownType() : 
			getFExp().type().arrayType(size());
	
	eq FCross.type() = getX().type().numericPromotion(getY().type());
	
	eq FAbsExp.type() = getFExp().type();
	
	eq FSizeExp.type() {
		if (hasDim()) {
			if (!getDim().variability().lessOrEqual(fParameter()))
				return fUnknownType();
			if (!getDim().type().isScalar() || !getDim().type().isInteger())
				return fUnknownType();
			int dim = dimension();
			if (dim < 0 || dim > getFExp().ndims() - 1)
				return fUnknownType();
			return fIntegerScalarType();
		} else {
			return fIntegerArrayType(size());
		}
	}
	
	eq FMinMaxExp.type() = 
		hasY() ? 
			getX().type().scalarType().typePromotion(getY().type().scalarType()) : 
			getX().type().scalarType();
	
	eq FRangeExp.type() {
		FPrimitiveType tot = fIntegerScalarType();
		for (FExp e : getFExps()) {
			if (!e.type().isScalar() || !e.type().isNumeric())
				return fUnknownType();
			tot = tot.scalarNumericPromotion(e.type());
		}
		return tot.arrayType(size());
	}
	
	eq FRelExp.type() {
		FPrimitiveType left  = getLeft().type();
		if (left.equivalentTo(getRight().type()) && left.isScalar())
			return fBooleanScalarType();
		else
			return fUnknownType();
	}
	eq FLogBinExp.type() {
		FPrimitiveType left = getLeft().type();
		if (left.typeCompatible(getRight().type()) && left.isBoolean())
			return left;
		else
			return fUnknownType();
	}
	eq FNotExp.type() = getFExp().type().isBoolean() ? getFExp().type() : fUnknownType();
	
	eq FIfExp.type() {
		if (!getIfExp().type().isBoolean() || !getIfExp().type().isScalar())
			return fUnknownType();
		FPrimitiveType tot = getThenExp().type();
		for (FElseIfExp e : getFElseIfExps())
			tot = tot.typePromotion(e.type());
		return tot.typePromotion(getElseExp().type());
	}
	
	eq FElseIfExp.type() {
		if (!getIfExp().type().isBoolean() || !getIfExp().type().isScalar())
			return fUnknownType();
		return getThenExp().type();
	}

	eq FRealLitExp.type() = fRealScalarType();
	eq FIntegerLitExp.type() = fIntegerScalarType();
	eq FBooleanLitExp.type() = fBooleanScalarType();
	eq FStringLitExp.type() = fStringScalarType();
	eq FTimeExp.type() = fRealScalarType();
	eq FDerExp.type() = fRealScalarType();

	// TODO: expand to handle boolean end enum index
	eq FEndExp.type() = fIntegerScalarType();
	
	/**
	 * \brief Check if this FArray is on the form "{exp for i in exp}".
	 */
	syn boolean FArray.isIterArray() = getNumFExp() == 1 && getFExp(0).isIterExp();
	
	/**
	 * \brief Check if this FExp is on the form "exp for i in exp".
	 */
	syn boolean FExp.isIterExp() = false;
	eq FIterExp.isIterExp()      = true;
	
	/**
	 * \brief Returns the expression being iterated over in an FIterExp child. 
	 *        Only valid if {@link #isIterExp()} returns <code>true</code>.
	 */
	public FExp FSumExp.iterExp() { return ((FIterExp) getFExp()).getFExp(); }
	
	eq FArray.type() {
		if (isIterArray())
			return getFExp(0).type();
		
		// Check that the types of the elements are consistent
		FPrimitiveType t = getFExp(0).type();
		for (int i = 1; i < getNumFExp(); i++) {
			if (!t.equivalentTo(getFExp(i).type())) 
				return fUnknownType();
			if (t.isNumeric()) 
				t = t.numericPromotion(getFExp(i).type());
		}
		return t.arrayType(size());
	}
	
	eq FCatExp.type() {
		if (!dimensionIsOk())
			return fUnknownType();
		int dim = dimension();
		
		FPrimitiveType t = getFExp(0).type().scalarType();
		Size s = getFExp(0).size();
		boolean func = inFunction();
		for (int i = 1; i < getNumFExp(); i++) {
			// Check that the types of the elements are consistent
			FPrimitiveType t2 = getFExp(i).type().scalarType();
			if (!t.equivalentTo(t2)) 
				return fUnknownType();
			if (t.isNumeric()) 
				t = t.numericPromotion(t2);
			
			// Check that the sizes are consistent
			if (!s.equivalentExcept(getFExp(i).size(), func, dim))
				return fUnknownType();
		}
		return t.arrayType(size());
	}
	
	eq FSumExp.type() {
		if (getFExp().isIterExp())
			return iterExp().type();
		return getFExp().type().scalarType();
	}
	
	eq FIterExp.type() {
		if (size().numElements() == 0)
			return fUnknownType();
		return getFExp().type().arrayType(size());
	}

	// TODO: Assumes same general functionality as zeros and ones - may need change for new subclasses
	eq FInfArgsFunctionCall.type() = (size().ndims() > 0) ? fIntegerArrayType(size()) : fUnknownType();
	
	eq FIdUseExp.type() = getFIdUse().type();
	eq FInstAccessExp.type() = getInstAccess().type();
	
	syn lazy FPrimitiveType FIdUse.type() = myFV().type();
	eq FIdUseInstAccess.type() = getInstAccess().type();

	syn lazy FPrimitiveType InstAccess.type() {
		if (myInstComponentDecl().isPrimitive()) {
			InstPrimitive ip = (InstPrimitive) myInstComponentDecl();
			FPrimitiveType t = ip.type().scalarType();
			return isArray() ? t.arrayType(size()) : t.scalarType();
		} else {
			return fUnknownType();
		}
	}
	
	inh FPrimitiveType FFunctionCallLeft.type();
	eq FFunctionCallEquation.getLeft(int i).type() = getCall().typeOfOutput(i);
	eq FFunctionCallStmt.getLeft(int i).type()     = getCall().typeOfOutput(i);
	
	// TODO: Can't anything be inferred here?
	syn lazy FPrimitiveType InstComponentDecl.type() = fUnknownType();
	
	syn FPrimitiveType FAbstractFunctionCall.typeOfOutput(int i) = (i == 0) ? type() : fUnknownType();
	syn lazy FPrimitiveType InstFunctionCall.typeOfOutput(int i) = myOutputs().get(i).type().sizedType(sizeOfOutput(i));
	syn lazy FPrimitiveType FFunctionCall.typeOfOutput(int i)    = myOutputs().get(i).type().sizedType(sizeOfOutput(i));

	eq FFunctionCall.type()    = hasOutputs() ? typeOfOutput(0) : fUnknownType();
	eq InstFunctionCall.type() = hasOutputs() ? typeOfOutput(0) : fUnknownType();
	eq FMathematicalFunctionCall.type() = fRealScalarType();		
	
	
	// TODO: expand to handle boolean end enum index
	syn lazy FPrimitiveType FSubscript.type();
	eq FColonSubscript.type() = fIntegerArrayType(size());
	eq FExpSubscript.type()   = getFExp().type();
}

aspect InstBindingType {
	
	/**
	 * \brief Returns the type the binding expression should have.
	 */
	syn FPrimitiveType InstPrimitive.bindingType() {
		InstNode decl = myInstValueMod().myInstNode();
		if (myBindingExpHasEach() || decl == this) 
			return type();
		else
			return expandBindingType(type(), decl);
	}
		
	/**
	 * \brief Constructs the type a specific attribute to this instance tree node should 
	 *        have, given the scalar type of the attribute. 
	 *        
	 * Default is <code>null</code>, so override is necessary for all InstNode 
	 * subclasses that needs this check.
	 */
	syn FPrimitiveType InstNode.attributeType(InstComponentModification icm) = null;
		
	/**
	 * \brief Constructs the type a specific attribute to this primitive should 
	 *        have, given the scalar type of the attribute.
	 */
	eq InstPrimitive.attributeType(InstComponentModification icm) {
		// TODO: This is only used to get the size of the type - perhaps it should return Size instead
		FPrimitiveType res = icm.type();
		InstNode decl = icm.myInstNode();
		if (decl == this)
			return res.arrayType(size());  // TODO: Take care of scalars as well
		if (icm.getEach() || !enclosedBy(decl)) 
			return res;
		else
			return expandBindingType(res.arrayType(size()), decl);
	}
	
	/**
	 * \brief Add array dimensions for surrounding InstArrayComponentDecls to 
	 *        type for binding expression.
	 */
	inh FPrimitiveType InstPrimitive.expandBindingType(FPrimitiveType type, InstNode node);
	inh FPrimitiveType InstArrayComponentDecl.expandBindingType(FPrimitiveType type, InstNode node);
	inh FPrimitiveType InstComposite.expandBindingType(FPrimitiveType type, InstNode node);
	
	eq InstClassDecl.getChild().expandBindingType(FPrimitiveType type, InstNode node) = type;
	eq InstRoot.getChild().expandBindingType(FPrimitiveType type, InstNode node)      = type;
	eq FlatRoot.getChild().expandBindingType(FPrimitiveType type, InstNode node)      = type;
	eq InstArrayComponentDecl.getChild().expandBindingType(FPrimitiveType type, InstNode node) = 
		expandBindingType(type.enclosingArrayType(childFSubscript(0).numIndices()), node);
	eq InstComposite.getChild().expandBindingType(FPrimitiveType type, InstNode node) = 
		(node == this) ? type : expandBindingType(type, node);
	
	inh boolean InstPrimitive.inArrayComponent();
	eq InstClassDecl.getChild().inArrayComponent()          = false;
	eq InstRoot.getChild().inArrayComponent()               = false;
	eq FlatRoot.getChild().inArrayComponent()               = false;
	eq InstArrayComponentDecl.getChild().inArrayComponent() = true;
	
	/**
	 * \brief Add an enclosing dimension to type. 
	 * 
	 * Returns a FPrimitiveType that is a copy of this one, but with one 
	 * more dimension, added first. If this type is scalar, an array type is 
	 * created instead.
	 */
	syn FPrimitiveType FPrimitiveType.enclosingArrayType(int size);
	eq FUnknownType.enclosingArrayType(int size)         = this;
	eq FPrimitiveScalarType.enclosingArrayType(int size) = arrayType(new Size(size));
	eq FPrimitiveArrayType.enclosingArrayType(int size)  = arrayType(size().expand(size));
	
}

aspect TypePromotion {
	
	/**
	 * \brief Combine two types to the broadest common denominator.
	 * 
	 * If types are not compatible, the unknown type is returned.
	 * An integer type combined with a real type results in a real type.
	 */
	syn FPrimitiveType FPrimitiveType.typePromotion(FPrimitiveType type) {
		if (!equivalentTo(type))
			return fUnknownType();
		return isNumeric() ? numericPromotion(type) : this;
	}
	
	/**
	 * \brief Combine two types to the broadest common numeric denominator.
	 * 
	 * If either is non-numeric or if sizes doesn't match, 
	 * the unknown type is returned.
	 * An integer type combined with a real type results in a real type.
	 */
	syn FPrimitiveType FPrimitiveType.numericPromotion(FPrimitiveType type) = fUnknownType();
	
	/**
	 * \brief Combine two types to the broadest common numeric denominator.
	 * 
	 * If either is non-numeric or if both are array and sizes doesn't match, 
	 * the unknown type is returned. 
	 * An integer type combined with a real type results in a real type.
	 */
	syn FPrimitiveType FPrimitiveType.looseNumericPromotion(FPrimitiveType type) = fUnknownType();
	
	/**
	 * \brief Combine two types to the broadest common scalar numeric denominator.
	 * 
	 * If either is non-numeric, the unknown type is returned.
	 * An integer type combined with a real type results in a real type.
	 */
	syn FPrimitiveType FPrimitiveType.scalarNumericPromotion(FPrimitiveType type) = fUnknownType();
	
	eq FPrimitiveScalarNumericType.numericPromotion(FPrimitiveType type) {
		if (type.isScalar()) {
			return scalarNumericPromotion(type);
		} else {
			return fUnknownType(); 
		}
	}

	eq FPrimitiveArrayNumericType.numericPromotion(FPrimitiveType type) {
		if (dimensionCompatible(type)) {
			return scalarNumericPromotion(type).arrayType(size());
		} else {
			return fUnknownType();
		}
	}
	
	eq FPrimitiveScalarNumericType.looseNumericPromotion(FPrimitiveType type) {
		if (type.isScalar()) {
			return scalarNumericPromotion(type);
		} else {
			return scalarNumericPromotion(type).arrayType(type.size()); 
		}
	}

	eq FPrimitiveArrayNumericType.looseNumericPromotion(FPrimitiveType type) {
		if (type.isScalar() || dimensionCompatible(type)) {
			return scalarNumericPromotion(type).arrayType(size());
		} else {
			return fUnknownType();
		}
	}
	
	eq FPrimitiveScalarNumericType.scalarNumericPromotion(FPrimitiveType type) {
		if (type.isNumeric()) 
			return isReal() ? this : type.scalarType(); 
		else 
			return fUnknownType();
	}

	eq FPrimitiveArrayNumericType.scalarNumericPromotion(FPrimitiveType type) {
		if (type.isNumeric()) 
			return isReal() ? scalarType() : type.scalarType(); 
		else 
			return fUnknownType();
	}

}

aspect FTypeCompatibility {
	syn boolean FPrimitiveType.typeCompatible(FPrimitiveType type) = typeCompatible(type, false);
	
	syn boolean FPrimitiveType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = false;
	eq FRealScalarType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		(type.isReal() || type.isInteger()) && type.isScalar() ;
	eq FIntegerScalarType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		type.isInteger() && type.isScalar();
	eq FBooleanScalarType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		type.isBoolean() && type.isScalar();
	eq FStringScalarType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		type.isString() && type.isScalar();

	eq FRealArrayType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		(type.isReal() || type.isInteger()) && dimensionCompatible(type, allowUnknown);
	eq FIntegerArrayType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		type.isInteger() && dimensionCompatible(type, allowUnknown);
	eq FBooleanArrayType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		type.isBoolean() && dimensionCompatible(type, allowUnknown);
	eq FStringArrayType.typeCompatible(FPrimitiveType type, boolean allowUnknown) = 
		type.isString() && dimensionCompatible(type, allowUnknown);

	
	syn boolean FPrimitiveType.dimensionCompatible(FPrimitiveType type) = dimensionCompatible(type, false);
	syn boolean FPrimitiveType.dimensionCompatible(FPrimitiveType type, boolean allowUnknown) = false;
	eq FPrimitiveScalarType.dimensionCompatible(FPrimitiveType type, boolean allowUnknown)    = type.isScalar();
	eq FPrimitiveArrayType.dimensionCompatible(FPrimitiveType type, boolean allowUnknown)     = 
		size().equivalent(type.size(), allowUnknown);
	
}

 aspect FTypeEquivalent {
	 /* The function equivalentTo is used in equation type checking where equations
	  * like
	  * x=0
	  * where x is declared as Real is ok.
	  */
	 syn boolean FPrimitiveType.equivalentTo(FPrimitiveType type) = false;
	eq FRealScalarType.equivalentTo(FPrimitiveType type) = type.isReal() || type.isInteger();
	eq FIntegerScalarType.equivalentTo(FPrimitiveType type) = type.isInteger() || type.isReal();
	eq FBooleanScalarType.equivalentTo(FPrimitiveType type) = type.isBoolean();
	eq FStringScalarType.equivalentTo(FPrimitiveType type) = type.isString();

	eq FRealArrayType.equivalentTo(FPrimitiveType type) = 
		(type.isReal() || type.isInteger()) && dimensionCompatible(type);
	eq FIntegerArrayType.equivalentTo(FPrimitiveType type) = 
		(type.isInteger() || type.isReal()) && dimensionCompatible(type);
	eq FBooleanArrayType.equivalentTo(FPrimitiveType type) = 
		type.isBoolean() && dimensionCompatible(type);
	eq FStringArrayType.equivalentTo(FPrimitiveType type) = 
		type.isString() && dimensionCompatible(type);

 
 }

 aspect BuiltInFlatTypes {

 	syn nta FRealScalarType Root.getFRealScalarType() = new FRealScalarType();
 	syn nta FIntegerScalarType Root.getFIntegerScalarType() = new FIntegerScalarType();
 	syn nta FBooleanScalarType Root.getFBooleanScalarType() = new FBooleanScalarType();
 	syn nta FStringScalarType Root.getFStringScalarType() = new FStringScalarType();
 	syn nta FUnknownScalarType Root.getFUnknownScalarType() = new FUnknownScalarType();
 	syn nta FUnknownType Root.getFUnknownType() = new FUnknownType();

 	syn lazy List Root.getDynamicArrayTypeList() = new List();
 	eq Root.getDynamicArrayType().retrieveRoot() = this; 	
 	
 	syn boolean InstPrimitive.isReal() = 
 		myInstClass().finalClass().primitiveName().equals("Real");
 	syn boolean InstPrimitive.isInteger() = 
 		myInstClass().finalClass().primitiveName().equals("Integer");
 	syn boolean InstPrimitive.isBoolean() = 
 		myInstClass().finalClass().primitiveName().equals("Boolean");
 	syn boolean InstPrimitive.isString() = 
 		myInstClass().finalClass().primitiveName().equals("String");

 	syn boolean InstBuiltIn.isReal() = 
 		myInstClass().finalClass().primitiveName().equals("RealType");
 	syn boolean InstBuiltIn.isInteger() = 
 		myInstClass().finalClass().primitiveName().equals("IntegerType");
 	syn boolean InstBuiltIn.isBoolean() = 
 		myInstClass().finalClass().primitiveName().equals("BooleanType");
 	syn boolean InstBuiltIn.isString() = 
 		myInstClass().finalClass().primitiveName().equals("StringType");

 	
 	syn boolean FPrimitiveType.isReal() = false;
 	eq FRealScalarType.isReal() = true;
 	eq FRealArrayType.isReal() = true;
 	syn boolean FPrimitiveType.isInteger() = false;
 	eq FIntegerScalarType.isInteger() = true;
 	eq FIntegerArrayType.isInteger() = true;
 	syn boolean FPrimitiveType.isBoolean() = false;
 	eq FBooleanScalarType.isBoolean() = true;
 	eq FBooleanArrayType.isBoolean() = true;
 	syn boolean FPrimitiveType.isString() = false;
 	eq FStringScalarType.isString() = true;
 	eq FStringArrayType.isString() = true;
 	
 	syn boolean FPrimitiveType.isArray() = false;
 	eq FPrimitiveArrayType.isArray() = true;

 	syn boolean FPrimitiveType.isScalar() = false;
 	eq FPrimitiveScalarType.isScalar() = true;
 	
 	syn boolean FPrimitiveType.isNumeric() = false;
 	eq FPrimitiveScalarNumericType.isNumeric() = true;
 	eq FPrimitiveArrayNumericType.isNumeric() = true;

 	syn int FPrimitiveType.ndims() = 0;
 	eq FPrimitiveArrayType.ndims() = getSize().ndims();
 	
 	syn Size FPrimitiveType.size() = Size.SCALAR;
 	eq FPrimitiveArrayType.size() = getSize();
 	
 	syn FPrimitiveType FPrimitiveType.sizedType(Size s) = 
 		(s == Size.SCALAR) ? scalarType() : arrayType(s);
 	
 	syn FPrimitiveScalarType FPrimitiveType.scalarType() = fUnknownScalarType();
 	syn FPrimitiveScalarType FRealScalarType.scalarType() = this;
 	syn FPrimitiveScalarType FIntegerScalarType.scalarType() = this;
 	syn FPrimitiveScalarType FBooleanScalarType.scalarType() = this;
 	syn FPrimitiveScalarType FStringScalarType.scalarType() = this;

 	syn FPrimitiveScalarType FUnknownArrayType.scalarType() = fUnknownScalarType();
 	syn FPrimitiveScalarType FRealArrayType.scalarType() = fRealScalarType();
 	syn FPrimitiveScalarType FIntegerArrayType.scalarType() = fIntegerScalarType();
 	syn FPrimitiveScalarType FBooleanArrayType.scalarType() = fBooleanScalarType();
 	syn FPrimitiveScalarType FStringArrayType.scalarType() = fStringScalarType();
 	
 	
 	syn boolean FPrimitiveType.isUnknown() = false;
 	eq FUnknownScalarType.isUnknown() = true;
 	eq FUnknownArrayType.isUnknown() = true;
 	eq FUnknownType.isUnknown() = true;
 	
 	syn FPrimitiveScalarType ASTNode.fRealScalarType() = root().getFRealScalarType();
 	syn FPrimitiveScalarType ASTNode.fIntegerScalarType() = root().getFIntegerScalarType();
 	syn FPrimitiveScalarType ASTNode.fBooleanScalarType() = root().getFBooleanScalarType();
 	syn FPrimitiveScalarType ASTNode.fStringScalarType() = root().getFStringScalarType();
 	syn FPrimitiveScalarType ASTNode.fUnknownScalarType() = root().getFUnknownScalarType();
 	syn FPrimitiveType ASTNode.fUnknownType() = root().getFUnknownType();
 	
	/**
	 * \brief Dynamically places an array type in the tree under this Root.
	 * 
	 * @returns  the final version of the dynamically placed node.
	 */
	public FPrimitiveArrayType Root.dynamicArrayType(FPrimitiveArrayType type) {
		getDynamicArrayTypeList().add(type);
		return getDynamicArrayType(getNumDynamicArrayType() - 1);
	}
 	
 	syn FPrimitiveArrayType ASTNode.fRealArrayType(Size size) = 
 		root().dynamicArrayType(new FRealArrayType(size));
 	syn FPrimitiveArrayType ASTNode.fIntegerArrayType(Size size) =
 		root().dynamicArrayType(new FIntegerArrayType(size));
 	syn FPrimitiveArrayType ASTNode.fBooleanArrayType(Size size) =
 		root().dynamicArrayType(new FBooleanArrayType(size));
 	syn FPrimitiveArrayType ASTNode.fStringArrayType(Size size) =
 		root().dynamicArrayType(new FStringArrayType(size));
 	syn FPrimitiveArrayType ASTNode.fUnknownArrayType(Size size) =
 		root().dynamicArrayType(new FUnknownArrayType(size));
 	
 	syn FPrimitiveArrayType FPrimitiveType.arrayType(Size size);
 	eq FUnknownType.arrayType(Size size)        = fUnknownArrayType(size);
 	eq FPrimitiveArrayType.arrayType(Size size) = scalarType().arrayType(size);
 	eq FRealScalarType.arrayType(Size size)     = fRealArrayType(size);
 	eq FIntegerScalarType.arrayType(Size size)  = fIntegerArrayType(size);
 	eq FStringScalarType.arrayType(Size size)   = fStringArrayType(size);
 	eq FBooleanScalarType.arrayType(Size size)  = fBooleanArrayType(size);
 	eq FUnknownScalarType.arrayType(Size size)  = fUnknownArrayType(size);

 }
 
aspect InstClassRestriction {
	
	/**
	 * \brief Is this class a function?
	 */
	syn boolean InstClassDecl.isFunction() = false;
	eq InstBaseClassDecl.isFunction() = getInstRestriction().isFunction();
	eq UnknownInstClassDecl.isFunction() = false;
	
	/**
	 * \brief Is this restriction "function"?
	 */
	syn boolean InstRestriction.isFunction() = false;
	eq InstFunction.isFunction() = true;
	
}
