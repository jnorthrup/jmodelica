/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect FlatTypeAnalysis {

	syn lazy FPrimitiveType AbstractFVariable.type();
	eq FRealVariable.type() {
		if (ndims()==0) {
			return fRealScalarType();				
		} else {
			return fRealArrayType(size().clone());
		}
	}
	eq FIntegerVariable.type() {
		if (ndims()==0) {
			return fIntegerScalarType();				
		} else {
			return fIntegerArrayType(size().clone());
		}
	}
	eq FBooleanVariable.type() {
		if (ndims()==0) {
			return fBooleanScalarType();				
		} else {
			return fBooleanArrayType(size().clone());
		}
	}
	eq FStringVariable.type() {
		if (ndims()==0) {
			return fStringScalarType();				
		} else {
			return fStringArrayType(size().clone());
		}
	}
	eq FDerivativeVariable.type() = fRealScalarType();
	eq FFunctionVariable.type() = getType();
	eq UnknownFVariable.type() = fUnknownType();

	syn FPrimitiveType InstPrimitive.type() {
		if (isReal()) {
			if (ndims()==0) {
				return fRealScalarType();				
			} else {
				return fRealArrayType(size().clone());
			}
		} else if (isInteger()) {
			if (ndims()==0) {
				return fIntegerScalarType();				
			} else {
				return fIntegerArrayType(size().clone());
			}

		} else if (isBoolean()) {
			if (ndims()==0) {
				return fBooleanScalarType();				
			} else {
				return fBooleanArrayType(size().clone());
			}

		} else if (isString()) {
			if (ndims()==0) {
				return fStringScalarType();				
			} else {
				return fStringArrayType(size().clone());
			}

		} else {
			return fUnknownType();
		}
	}
	
	syn lazy FPrimitiveType FExp.type() = fUnknownType();
	
	eq FUnaryExp.type() = getFExp().type();
	eq FArtmBinExp.type() = getLeft().type().
	  binaryNumericPromotion(getRight().type());
	
	eq FLogBinExp.type() = fBooleanScalarType();

	eq FRealLitExp.type() = fRealScalarType();
	eq FIntegerLitExp.type() = fIntegerScalarType();
	eq FBooleanLitExp.type() = fBooleanScalarType();
	eq FStringLitExp.type() = fStringScalarType();
	eq FTimeExp.type() = fRealScalarType();
	eq FDerExp.type() = fRealScalarType();
	
	eq FArray.type() {
		int[] size = size().clone();
		// Check that the types of the elements are consistent
		//System.out.println("FArray.type() hej!");
		FPrimitiveType t = getFExp(0).type();
		for (int i=1;i<getNumFExp();i++) {
			if (!t.equivalentTo(getFExp(i).type())) {
				//System.out.println("FArray.type() hoj!");
				return fUnknownType();
			}
			if (t.isNumeric()) {
				//System.out.println("FArray.type() hopp!");
				t = t.binaryNumericPromotion(getFExp(i).type());
			}
		}
		if (t.isReal()) {
			return fRealArrayType(size);
		} else if (t.isInteger()) {
			return fIntegerArrayType(size);
		} if (t.isBoolean()) {
			return fBooleanArrayType(size);
		} if (t.isString()) {
			return fStringArrayType(size);
		} else {
			//System.out.println("FArray.type() oj!");
			return fUnknownType();
		}
		
	}
	
	eq FIdUseExp.type() = myFV().type();
	eq FInstAccessExp.type() {
		if (getInstAccess().myInstComponentDecl().isPrimitive()) {
			InstPrimitive ip = ((InstPrimitive)getInstAccess().myInstComponentDecl());
			if (ndims()==0) {
				return ip.type().scalarType();
			} else {
				int[] size = size().clone();
				return ip.type().scalarType().arrayType(size);
			}
		} else {
			return fUnknownType();
		}
	}	
	
	eq FMathematicalFunctionCall.type() = fRealScalarType();		
			
}

aspect FNumericPromotion {
	
	syn FPrimitiveType FPrimitiveType.
	    binaryNumericPromotion(FPrimitiveType type) = fUnknownType();
	eq FPrimitiveScalarNumericType.binaryNumericPromotion(FPrimitiveType type) {
		if (!type.isNumeric()) {
			return fUnknownType();
		} else {
			return isReal()? this : type; 
		}
	}

	eq FPrimitiveArrayNumericType.binaryNumericPromotion(FPrimitiveType type) {
		if (!type.isNumeric()) {
			return fUnknownType();
		} else {
			return isReal()? this : type; 
		}
	}

}

aspect FTypeCompatibility {
	syn boolean FPrimitiveType.typeCompatible(FPrimitiveType type) = false;
	eq FRealScalarType.typeCompatible(FPrimitiveType type) = 
		(type.isReal() || type.isInteger()) && type.isScalar() ;
	eq FIntegerScalarType.typeCompatible(FPrimitiveType type) = 
		type.isInteger() && type.isScalar();
	eq FBooleanScalarType.typeCompatible(FPrimitiveType type) = 
		type.isBoolean() && type.isScalar();
	eq FStringScalarType.typeCompatible(FPrimitiveType type) = 
		type.isString() && type.isScalar();

	eq FRealArrayType.typeCompatible(FPrimitiveType type) = 
		(type.isReal() || type.isInteger()) && dimensionCompatible(type);
	eq FIntegerArrayType.typeCompatible(FPrimitiveType type) = 
		type.isInteger() && dimensionCompatible(type);
	eq FBooleanArrayType.typeCompatible(FPrimitiveType type) = 
		type.isBoolean() && dimensionCompatible(type);
	eq FStringArrayType.typeCompatible(FPrimitiveType type) = 
		type.isString() && dimensionCompatible(type);
	
	syn boolean FPrimitiveType.dimensionCompatible(FPrimitiveType type) = false;
	eq FPrimitiveScalarType.dimensionCompatible(FPrimitiveType type) = type.isScalar();
	eq FPrimitiveArrayType.dimensionCompatible(FPrimitiveType type) {
		//System.out.println("hej: " + ndims()+" " + type.ndims());
		if (ndims() != type.ndims()) {
			return false;
		} else {
			int[] size_me = size();
			int[] size_type = type.size();
			/*
			System.out.println("size_me");
			for (int i=0;i<size_me.length;i++) {
				System.out.println(size_me[i]);
			}
			*/
			//System.out.println("size_type");
			//for (int i=0;i<size_type.length;i++) {
			//	System.out.println(size_type[i]);
			//}

			for (int i=0;i<ndims();i++) {
				if (size_me[i] != size_type[i]) {
					return false;
				}
			}
			return true;
		}
	}
	
}

 aspect FTypeEquivalent {
	 /* The function equivalentTo is used in equation type checking where equations
	  * like
	  * x=0
	  * where x is declared as Real is ok.
	  */
	 syn boolean FPrimitiveType.equivalentTo(FPrimitiveType type) = false;
	eq FRealScalarType.equivalentTo(FPrimitiveType type) = type.isReal() || type.isInteger();
	eq FIntegerScalarType.equivalentTo(FPrimitiveType type) = type.isInteger() || type.isReal();
	eq FBooleanScalarType.equivalentTo(FPrimitiveType type) = type.isBoolean();
	eq FStringScalarType.equivalentTo(FPrimitiveType type) = type.isString();

	eq FRealArrayType.equivalentTo(FPrimitiveType type) = 
		(type.isReal() || type.isInteger()) && dimensionCompatible(type);
	eq FIntegerArrayType.equivalentTo(FPrimitiveType type) = 
		(type.isInteger() || type.isReal()) && dimensionCompatible(type);
	eq FBooleanArrayType.equivalentTo(FPrimitiveType type) = 
		type.isBoolean() && dimensionCompatible(type);
	eq FStringArrayType.equivalentTo(FPrimitiveType type) = 
		type.isString() && dimensionCompatible(type);

 
 }

 aspect BuiltInFlatTypes {

 	syn nta FRealScalarType Root.getFRealScalarType() = new FRealScalarType();
 	syn nta FIntegerScalarType Root.getFIntegerScalarType() = new FIntegerScalarType();
 	syn nta FBooleanScalarType Root.getFBooleanScalarType() = new FBooleanScalarType();
 	syn nta FStringScalarType Root.getFStringScalarType() = new FStringScalarType();
 	syn nta FUnknownScalarType Root.getFUnknownScalarType() = new FUnknownScalarType();
 	syn nta FUnknownType Root.getFUnknownType() = new FUnknownType();

 	syn lazy List Root.getDynamicArrayTypeList() = new List();
 	eq Root.getDynamicArrayType().retrieveRoot() = this; 	
 	
 	syn boolean InstPrimitive.isReal() = 
 		myInstClass().finalClass().primitiveName().equals("Real");
 	syn boolean InstPrimitive.isInteger() = 
 		myInstClass().finalClass().primitiveName().equals("Integer");
 	syn boolean InstPrimitive.isBoolean() = 
 		myInstClass().finalClass().primitiveName().equals("Boolean");
 	syn boolean InstPrimitive.isString() = 
 		myInstClass().finalClass().primitiveName().equals("String");

 	syn boolean FPrimitiveType.isReal() = false;
 	eq FRealScalarType.isReal() = true;
 	eq FRealArrayType.isReal() = true;
 	syn boolean FPrimitiveType.isInteger() = false;
 	eq FIntegerScalarType.isInteger() = true;
 	eq FIntegerArrayType.isInteger() = true;
 	syn boolean FPrimitiveType.isBoolean() = false;
 	eq FBooleanScalarType.isBoolean() = true;
 	eq FBooleanArrayType.isBoolean() = true;
 	syn boolean FPrimitiveType.isString() = false;
 	eq FStringScalarType.isString() = true;
 	eq FStringArrayType.isString() = true;
 	
 	syn boolean FPrimitiveType.isArray() = false;
 	eq FPrimitiveArrayType.isArray() = true;

 	syn boolean FPrimitiveType.isScalar() = false;
 	eq FPrimitiveScalarType.isScalar() = true;
 	
 	syn boolean FPrimitiveType.isNumeric() = false;
 	eq FPrimitiveScalarNumericType.isNumeric() = true;
 	eq FPrimitiveArrayNumericType.isNumeric() = true;

 	syn int FPrimitiveType.ndims() = 0;
 	eq FPrimitiveArrayType.ndims() = getSize().length;
 	
 	syn lazy int[] FPrimitiveType.size() = new int[0];
 	eq FPrimitiveArrayType.size() = getSize().clone();
 	
 	syn FPrimitiveScalarType FPrimitiveType.scalarType() = fUnknownScalarType();
 	syn FPrimitiveScalarType FRealScalarType.scalarType() = this;
 	syn FPrimitiveScalarType FIntegerScalarType.scalarType() = this;
 	syn FPrimitiveScalarType FBooleanScalarType.scalarType() = this;
 	syn FPrimitiveScalarType FStringScalarType.scalarType() = this;

 	syn FPrimitiveScalarType FUnknownArrayType.scalarType() = fUnknownScalarType();
 	syn FPrimitiveScalarType FRealArrayType.scalarType() = fRealScalarType();
 	syn FPrimitiveScalarType FIntegerArrayType.scalarType() = fIntegerScalarType();
 	syn FPrimitiveScalarType FBooleanArrayType.scalarType() = fBooleanScalarType();
 	syn FPrimitiveScalarType FStringArrayType.scalarType() = fStringScalarType();
 	
 	
 	syn boolean FPrimitiveType.isUnknown() = false;
 	eq FUnknownScalarType.isUnknown() = true;
 	eq FUnknownArrayType.isUnknown() = true;
 	eq FUnknownType.isUnknown() = true;
 	
 	syn FPrimitiveScalarType ASTNode.fRealScalarType() = root().getFRealScalarType();
 	syn FPrimitiveScalarType ASTNode.fIntegerScalarType() = root().getFIntegerScalarType();
 	syn FPrimitiveScalarType ASTNode.fBooleanScalarType() = root().getFBooleanScalarType();
 	syn FPrimitiveScalarType ASTNode.fStringScalarType() = root().getFStringScalarType();
 	syn FPrimitiveScalarType ASTNode.fUnknownScalarType() = root().getFUnknownScalarType();
 	syn FPrimitiveType ASTNode.fUnknownType() = root().getFUnknownType();
 	
 	syn FPrimitiveArrayType ASTNode.fRealArrayType(int[] size) {
 		FPrimitiveType t = new FRealArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1);
 	}

 	syn FPrimitiveArrayType ASTNode.fIntegerArrayType(int[] size) {
 		FPrimitiveType t = new FIntegerArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1);
 	}

 	syn FPrimitiveArrayType ASTNode.fBooleanArrayType(int[] size) {
 		FPrimitiveType t = new FBooleanArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1);
 	}

 	syn FPrimitiveArrayType ASTNode.fStringArrayType(int[] size) {
 		FPrimitiveType t = new FStringArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1);
 	}

 	syn FPrimitiveArrayType ASTNode.fUnknownArrayType(int[] size) {
 		FPrimitiveType t = new FUnknownArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1);
 	}
 	
 	syn FPrimitiveArrayType FPrimitiveScalarType.arrayType(int[] size);
 	eq FRealScalarType.arrayType(int[] size) {
 		FPrimitiveType t = new FRealArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1); 		
 	}
 	eq FIntegerScalarType.arrayType(int[] size) {
 		FPrimitiveType t = new FIntegerArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1); 		
 	}
 	eq FBooleanScalarType.arrayType(int[] size) {
 		FPrimitiveType t = new FBooleanArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1); 		
 	}
 	eq FStringScalarType.arrayType(int[] size) {
 		FPrimitiveType t = new FStringArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1); 		
 	}
 	eq FUnknownScalarType.arrayType(int[] size) {
 		FPrimitiveType t = new FUnknownArrayType(size);
 		root().getDynamicArrayTypeList().add(t);
 		// Make sure the returned type is final
 		return (FPrimitiveArrayType)root().getDynamicArrayType(root().getNumDynamicArrayType()-1); 		
 	}

 	
 }

 
/*
aspect ExpressionType {
	
	syn lazy AbstractFlatType FExp.type();	
	eq FUnsupportedExp.type() = new BrokenType();
	eq FInstAccessExp.type() = new BrokenType();
	
	syn lazy AbstractFlatType FVariable.type();	
	syn lazy AbstractFlatType FAbstractEquation.type() = new BrokenType();
	
	// TODO: fix this expression for arrays
	eq FVariable.type() {
		FPrimitiveType primitiveType = getType();
		if (hasBindingExp()) {
			FExp bindingExp = getBindingExp();
			AbstractFlatType bindingType = bindingExp.type();
			if (bindingType instanceof FlatType) {
				FlatType fBindingType = (FlatType) bindingType;
				if (!fBindingType.getFPrimitiveType().equals(primitiveType)) {
					error("The variable type and binding expression type do not match for variable " + this);
				}
			}
		}
		return(new FlatType(primitiveType, 0));
	}

	// TODO: FForIndex's are never type checked
	
	// TODO: does this equation need type checking?
	eq FForClauseE.type() {
		for (int j = 0; j < getNumForEqns();j++) {
			getForEqns(j).type();
		}
		return(emptyType());
	}
	
	eq FEquation.type() {
		return(getLeft().type().combine(getRight().type(),getLeft(),getRight()));
	}

	eq FLogBinExp.type() = checkLogicalTyping();
	eq FArtmBinExp.type() = checkArithmeticTyping();
	
	eq FAddExp.type() {
		AbstractFlatType tryValue = tryArithmeticTyping();
		if (tryValue.equals(emptyType())) {
			FPrimitiveType leftPrimitive = getLeftPrimitive();
			FPrimitiveType rightPrimitive = getRightPrimitive();
			if (leftPrimitive.equals(fStringScalarType()) &&
				   rightPrimitive.equals(fStringScalarType())) {
				return new FlatType(fStringScalarType(), 0);
			} else {
				error("The types " + getLeft() + " and " + getRight() +
						"cannot be used on the operator " + this);
				return brokenType();
			}
		} else {
			return tryValue;
		}
	}	
	
	eq FAndExp.type() = checkBooleanLogicalTyping();
	eq FOrExp.type() = checkBooleanLogicalTyping();
	
	eq FUnaryExp.type() = getFExp().type();

	eq FRealLitExp.type() {
		String stringValue = getUNSIGNED_NUMBER();
		try {
			Integer.parseInt(stringValue);
			return new FlatType(fIntegerScalarType(), 0);			
		} catch(NumberFormatException formatException) {}
		try {
			Double.parseDouble(stringValue);
			return new FlatType(fRealScalarType(), 0);			
		} catch(NumberFormatException formatException) {}
		error(stringValue + " is not an integer value or a real value.");
		return brokenType();
	}
	
	eq FStringLitExp.type() = new FlatType(fStringScalarType(), 0);
	eq FBooleanLitExpTrue.type() = new FlatType(fBooleanScalarType(), 0);
	eq FBooleanLitExpFalse.type() = new FlatType(fBooleanScalarType(), 0);

	eq FTimeExp.type() = new FlatType(fRealScalarType(), 0);

	// TODO: Some error checking should be done here
	// The expression must be a subtype of real
	eq FDerExp.type() {
		warning("Type checking not implemented on der expressions.");
		return(getFIdUseExp().type());
	}

	eq FIfExp.type() {
		AbstractFlatType total = getThenExp().type();
		for (int i=0; i<getNumFElseIfExp(); i++) {
			total = total.combine(getFElseIfExp(i).type(),getThenExp(),getFElseIfExp(i));
		}
		total = total.combine(getElseExp().type(),getThenExp(),getElseExp());
		return total;
	}
	
	eq FElseIfExp.type() = getThenExp().type();	
	
	// TODO: implement function call types
	eq FFunctionCall.type() {
		warning("Error on function call: " + this + ". The type system has not been implemented for function calls.");		
		return brokenType();
	}

	// TODO: Array access expressions have a different type 
	// than the original array declaration.
	eq FIdUseExp.type() {
		AbstractFVariable variable = this.myFV();
		if (variable instanceof FVariable) {
			FVariable fVariable = (FVariable) variable;
			return(fVariable.type());			
		} else {
			error("Could not find declaration for variable " + this);
			return brokenType();
		}
	}	

	eq FExpList.type() {
		if (getNumFExp() > 0) {
			AbstractFlatType total = getFExp(0).type();			
			for (int i = 1; i < getNumFExp(); i++) {
				total = total.combine(getFExp(i).type(),getFExp(0),getFExp(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;				
				return new FlatType(flatTotal.getFPrimitiveType(), 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}
	}
	
	eq FMatrix.type() {
		if (getNumFExpList() > 0) {
			AbstractFlatType total = getFExpList(0).type();			
			for (int i = 1; i < getNumFExpList(); i++) {
				total = total.combine(getFExpList(i).type(),getFExpList(0),getFExpList(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;
				return new FlatType(flatTotal.getFPrimitiveType(), flatTotal.getNumberDimensions() + 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}
	}	
	
	eq FNoExp.type() {
		return emptyType();
	}
	
	eq FSumRedExp.type() {
		return getFExp().type();
	}

	// TODO: type checking on this expression
	eq FSizeExp.type() {
		return new FlatType(fIntegerScalarType(), 0);
	}
	
	eq FArrayConstructor.type() {
		if (getNumFExp() > 0) {
			AbstractFlatType total = getFExp(0).type();			
			for (int i = 1; i < getNumFExp(); i++) {
				total = total.combine(getFExp(i).type(),getFExp(0),getFExp(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;				
				return new FlatType(flatTotal.getFPrimitiveType(), flatTotal.getNumberDimensions() + 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}		
	}

	// TODO: type checking on range expressions
	// See 3.4.4.5 of Modelica 2.2 Specification
	eq FRangeExp.type() {
		if (getNumFExp() > 0) {
			AbstractFlatType total = getFExp(0).type();			
			for (int i = 1; i < getNumFExp(); i++) {
				total = total.combine(getFExp(i).type(),getFExp(0),getFExp(i));
			}
			if (total instanceof FlatType) {
				FlatType flatTotal = (FlatType) total;			
				return new FlatType(flatTotal.getFPrimitiveType(), 1);
			} else {
				return total;
			}
		} else {
			return emptyType();
		}		
	}

	FPrimitiveType FBinExp.getLeftPrimitive() {
		AbstractFlatType leftType = getLeft().type();		
		FlatType fLeftType = (FlatType) leftType;
		FPrimitiveType leftPrimitive = fLeftType.getFPrimitiveType();
		return leftPrimitive;
	}

	FPrimitiveType FBinExp.getRightPrimitive() {
		AbstractFlatType rightType = getRight().type();
		FlatType fRightType = (FlatType) rightType;
		FPrimitiveType rightPrimitive = fRightType.getFPrimitiveType();
		return rightPrimitive;		
	}	
	
	AbstractFlatType FLogBinExp.checkBooleanLogicalTyping() {
		if (!(getLeft().type() instanceof FlatType) ||
			!(getRight().type() instanceof FlatType)) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		}			
		boolean valid = false;
		FPrimitiveType leftPrimitive = getLeftPrimitive();
		FPrimitiveType rightPrimitive = getRightPrimitive();		
		if (leftPrimitive.equals(rightPrimitive) &&
			leftPrimitive.equals(fBooleanScalarType())) {
			valid = true;
		}
		if (valid) return new FlatType(fBooleanScalarType(), 0);
		else {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();
		}	
	}
	
	AbstractFlatType FLogBinExp.checkLogicalTyping() {
		if (!(getLeft().type() instanceof FlatType) ||
			!(getRight().type() instanceof FlatType)) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		}
		boolean valid = false;		
		FPrimitiveType leftPrimitive = getLeftPrimitive();
		FPrimitiveType rightPrimitive = getRightPrimitive();		
		if (leftPrimitive.equals(rightPrimitive)) {
			valid = true;
		} else if (leftPrimitive.equals(fRealScalarType()) ||
				   rightPrimitive.equals(fRealScalarType())) {
			if ((leftPrimitive.equals(fIntegerScalarType()) ||
				leftPrimitive.equals(fRealScalarType())) &&
				(rightPrimitive.equals(fIntegerScalarType()) ||
				rightPrimitive.equals(fRealScalarType()))) {
					valid = true;
			}
		}
		if (valid) return new FlatType(fBooleanScalarType(), 0);
		else {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();
		}
	}
	
	AbstractFlatType FArtmBinExp.checkArithmeticTyping() {
		AbstractFlatType tryValue = tryArithmeticTyping();	
		if (tryValue.equals(emptyType())) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		} else {
			return tryValue;
		}		
	}
	
	AbstractFlatType FArtmBinExp.tryArithmeticTyping() {
		if (!(getLeft().type() instanceof FlatType) ||
			!(getRight().type() instanceof FlatType)) {
			error("The types " + getLeft() + " and " + getRight() +
					"cannot be used on the operator " + this);			
			return brokenType();			
		}		
		FPrimitiveType leftPrimitive = getLeftPrimitive();
		FPrimitiveType rightPrimitive = getRightPrimitive();		
		if (leftPrimitive.equals(fIntegerScalarType()) && 
			rightPrimitive.equals(fIntegerScalarType())) {
				return new FlatType(fIntegerScalarType(), 0);
		} else if (leftPrimitive.equals(fRealScalarType()) ||
				   rightPrimitive.equals(fRealScalarType())) {
				if ((leftPrimitive.equals(fIntegerScalarType()) ||
					leftPrimitive.equals(fRealScalarType())) &&
					(rightPrimitive.equals(fIntegerScalarType()) ||
					rightPrimitive.equals(fRealScalarType()))) {
					return new FlatType(fRealScalarType(), 0);
				} else {
					error("The types " + getLeft() + " and " + getRight() +
							"cannot be used on the operator " + this);					
					return brokenType();				
				}
		}
		return emptyType();
	}	
	
	
   	public abstract AbstractFlatType AbstractFlatType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp);
	
	public AbstractFlatType BrokenType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp) {
		return this;
	}
	
	public AbstractFlatType EmptyType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp) {
		if (other instanceof EmptyType) {
			return this;
		} else if (other instanceof FlatType) {
			otherExp.error("The types " + thisExp + " and " + otherExp + " do not match.");		
			return brokenType();	
		} else {
			return brokenType();
		}
	}
   	
   	public AbstractFlatType FlatType.combine(AbstractFlatType other, FExp thisExp, FExp otherExp) {
   		if (other instanceof FlatType) {
   			FlatType fOther = (FlatType) other;
   			if (!this.getFPrimitiveType().getClass().equals(fOther.getFPrimitiveType().getClass())) {
   				thisExp.error("The types " + thisExp + " and " + otherExp + " do not match.");
   				return (brokenType());
   			}
   			if (this.getNumberDimensions() != fOther.getNumberDimensions()) {
   				thisExp.error("The dimensions " + thisExp + " and " + otherExp + " do not match."); 
   				return (brokenType());   			
   			}
   			return this;
   		} else if (other instanceof EmptyType) {
				thisExp.error("The types " + thisExp + " and " + otherExp + " do not match.");
				return (brokenType());
   		} else {
			return (brokenType());
   		}
	}			
	
}
*/