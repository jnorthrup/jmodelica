/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Collection;
import java.util.LinkedList;
import java.util.ArrayList;

import org.jmodelica.util.Problem;
import org.jmodelica.util.ErrorCheckType;


  
  /**
   * Interface for handling semantic errors.
   * $see Root#setErrorHandler(IErrorHandler)
   */
  public interface IErrorHandler {
	  /**
	   * \brief Called when a semantic error is found. 
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   * @see ASTNode#error(String)
	   */
	  public void error(String s, ASTNode n);
	  
	  /**
	   * \brief Called when a compiler compliance error is found.
	   * 
	   * These errors are generated when compiling code that is legal Modelica, 
	   * but uses features that aren't implemented. Compliance errors are ignored 
	   * by test cases (except ComplianceErrorTestCase).
	   *  
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   * @see ASTNode#compliance(String)
	   */
	  public void compliance(String s, ASTNode n);
	  
	  /**
	   * \brief Called when a warning is issued during semantic error checking.
	   * 
	   * @param s	warning message.
	   * @param n	the node the warning originated from.
	   * @see ASTNode#warning(String)
	   */
	  public void warning(String s, ASTNode n);
	  
	  /**
	   * Connect error handler to a Root.
	   * 
	   * Might return another equivalent error handler that is connected to the root instead.
	   * 
	   * @param root  the Root to connect to
	   * @return  an error handler connected to <code>root</code>
	   */
	  public IErrorHandler connectTo(Root root);
  }
  
  /**
   * \brief Default implementation of {@link IErrorHandler}.
   *  
   * Collects a list of {@link Problem} for all found errors.
   */
  public class DefaultErrorHandler implements IErrorHandler {
	  protected Root root;
	  
	  public DefaultErrorHandler(Root root) {
		  this.root = root;
	  }

	  /**
	   * \brief Creates a new {@link Problem} and adds it to root.errors, ignoring duplicates.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void error(String s, ASTNode n) {
		  problem(s, n, root.errors, Problem.Severity.ERROR, Problem.Kind.SEMANTIC);
	  }

	  /**
	   * \brief Creates a new {@link Problem} with kind COMPLIANCE 
	   *        and adds it to root.errors, ignoring duplicates.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void compliance(String s, ASTNode n) {
		  problem(s, n, root.errors, Problem.Severity.ERROR, Problem.Kind.COMPLIANCE);
	  }

	  /**
	   * \brief Creates a new {@link Problem} and adds it to root.warnings, ignoring duplicates.
	   * 
	   * @param s	warning message.
	   * @param n	the node the warning originated from.
	   */
	  public void warning(String s, ASTNode n) {
		  problem(s, n, root.warnings, Problem.Severity.WARNING, Problem.Kind.OTHER);
	  }
	  
	  protected void problem(String s, ASTNode n, ArrayList<Problem> list, Problem.Severity sev, Problem.Kind kind) {
		  Problem p = new Problem(n.fileName(), s, sev, kind, n.lineNumber(), n.columnNumber());
		  if (!list.contains(p))
			  list.add(p);
	  }
	  
	  public IErrorHandler connectTo(Root root) {
		  IErrorHandler eh = new DefaultErrorHandler(root);
		  root.setErrorHandler(eh);
		  return eh;
	  }
  }
  
  /**
   * \brief Error handler that generates warnings for compliance errors, 
   *        delegating to another error handler.
   */
  public class ComplianceWarnErrorHandler implements IErrorHandler {
  	
  	  private IErrorHandler delegate;

	  public ComplianceWarnErrorHandler(IErrorHandler delegate) {
	  	  if (delegate instanceof ComplianceWarnErrorHandler)
	  		  delegate = ((ComplianceWarnErrorHandler) delegate).delegate;
		  this.delegate = delegate;
	  }

	  /**
	   * \brief Delegates to wrapped error handler.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void error(String s, ASTNode n) {
		  delegate.error(s, n);
	  }

	  /**
	   * \brief Delegates to warning() in wrapped error handler.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void compliance(String s, ASTNode n) {
		  delegate.warning(s, n);
	  }

	  /**
	   * \brief Delegates to wrapped error handler.
	   * 
	   * @param s	warning message.
	   * @param n	the node the warning originated from.
	   */
	  public void warning(String s, ASTNode n) {
		  delegate.warning(s, n);
	  }
	  
	  public IErrorHandler connectTo(Root root) {
		  delegate = delegate.connectTo(root);
		  return this;
	  }
	  
  }
  

aspect ErrorCheck {
	
	public void FClass.breakOnErrors() throws CompilerException {
		root().breakOnErrors();
	}
	
	public void Root.breakOnErrors() throws CompilerException {
		if (!errors.isEmpty() || (options.getBooleanOption("halt_on_warning") && !warnings.isEmpty())) {
		    java.util.Collections.sort(errors);
		    java.util.Collections.sort(warnings);
		    
		    ArrayList<Problem> problems = new ArrayList<Problem>();
		    problems.addAll(warnings);
		    problems.addAll(errors);
		    
		    errors.clear();
		    warnings.clear();
		    
		    throw new CompilerException(problems);
		}
	}
	
	public ArrayList<Problem> FClass.collectWarnings() {
		return root().collectWarnings();
	}
	
	public ArrayList<Problem> Root.collectWarnings() {
		breakOnErrors();
	    java.util.Collections.sort(warnings);
	    ArrayList<Problem> problems = new ArrayList<Problem>(warnings);
	    warnings.clear();
	    return problems;
	}

  public ArrayList<Problem> Root.errors = new ArrayList<Problem>();
  public ArrayList<Problem> Root.warnings = new ArrayList<Problem>();

  private IErrorHandler Root.errorHandler = new DefaultErrorHandler(this);
  
  /**
   * Set the handler for semantic errors.
   * @see IErrorHandler 
   */
  public void Root.setErrorHandler(IErrorHandler handler) {
	  errorHandler = handler;
  }
  
  /**
   * Get the handler for semantic errors.
   * @see IErrorHandler 
   */
  public IErrorHandler Root.getErrorHandler() {
	  return errorHandler;
  }

  syn int ASTNode.lineNumber() = (start != 0 || getParent()==null)? beginLine() : getParent().lineNumber();
  syn int ASTNode.columnNumber() = (start != 0 || getParent()==null)? beginColumn() : getParent().columnNumber();
  
  /**
   * Register an error. Delegates to an {@link IErrorHandler}.
   * @param s	the error message.
   */
  void ASTNode.error(String s) {
	  root().getErrorHandler().error(s, this);
  }
  
  /**
   * Register an error. Delegates to an {@link IErrorHandler}.
   * 
   * Builds error message using <code>format</code> as format string.
   */
  void ASTNode.error(String format, Object... args) {
	  error(String.format(format, args));
  }

  /**
   * Register a compliance error. Delegates to an {@link IErrorHandler}.
   * @param s	the error message.
   */
  void ASTNode.compliance(String s) {
	  root().getErrorHandler().compliance(s, this);
  }
  
  /**
   * Register a compliance error. Delegates to an {@link IErrorHandler}.
   * 
   * Builds error message using <code>format</code> as format string.
   */
  void ASTNode.compliance(String format, Object... args) {
	  compliance(String.format(format, args));
  }

  /**
   * Register a warning. Delegates to an {@link IErrorHandler}.
   * @param s	the warning message.
   */
  void ASTNode.warning(String s) {
	  root().getErrorHandler().warning(s, this);
  }
  
  /**
   * Register a warning. Delegates to an {@link IErrorHandler}.
   * 
   * Builds warning message using <code>format</code> as format string.
   */
  void ASTNode.warning(String format, Object... args) {
	  warning(String.format(format, args));
  }
  
  /**
   * Lock the closest surrounding if-equation or if-expression that have only 
   * parameter-expression tests and evaluates to another branch. Returns true 
   * if any such if exists. 
   * 
   * Any parameters used in the test will be marked as structural.
   * 
   * NB: This has side-effects, dispite being an inherited attribute.
   */
  // TODO: find way to move side-effects out from inh attr
  inh boolean FExp.lockBranch();
  inh boolean FExpSubscript.lockBranch();
  inh boolean FIfEquation.lockBranch();
  eq FIfExp.getThenExp().lockBranch()                     = lockMyBranch(true);
  eq FIfExp.getElseExp().lockBranch()                     = lockMyBranch(false);
  eq FIfEquation.getFAbstractEquation().lockBranch()      = lockMyBranch(true);
  eq FIfEquation.getElse().lockBranch()                   = lockMyBranch(false);
  eq FConnectClause.getConnector1().lockBranch()          = getConnector2().isDisabled();
  eq FConnectClause.getConnector2().lockBranch()          = getConnector1().isDisabled();
  eq InstComponentDecl.getInstModification().lockBranch() = isDisabled();
  eq InstNode.getChild().lockBranch()                     = false;
  eq FClass.getChild().lockBranch()                       = false;
  
  /**
   * Lock this if-expression and return true if it only has only parameter-expression 
   * tests and evaluates to the branch not indicated by <code>then</code>. Otherwise 
   * delegates to {@link #lockBranch()}.
   * 
   * Any parameters used in the test will be marked as structural.
   * 
   * @param this  if true, we are trying to remove the then-branch, otherwise the else-branch
   */
  public boolean FIfExp.lockMyBranch(boolean then) {
	  if (getIfExp().variability().parameterOrLess() && getIfExp().ceval().booleanValue() != then) {
		  getIfExp().markAsStructuralParameter();
		  return true;
	  } else {
		  return lockBranch();
	  }
  }
  
  /**
   * Lock this if-expression and return true if it only has only parameter-expression 
   * tests and evaluates to the branch not indicated by <code>then</code>. Otherwise 
   * delegates to {@link #lockBranch()}.
   * 
   * Any parameters used in the test will be marked as structural.
   * 
   * @param this  if true, we are trying to remove the then-branch, otherwise the else-branch
   */
  public boolean FIfEquation.lockMyBranch(boolean then) {
	  if (getTest().variability().parameterOrLess() && getTest().ceval().booleanValue() != then) {
		  getTest().markAsStructuralParameter();
		  return true;
	  } else {
		  return lockBranch();
	  }
  }

  /**
   * \brief Call all *Check() methods for this node.
   * 
   * Helper method to make it easier to add new check methods 
   * for all nodes.
   */
  protected void ASTNode.allChecks(ErrorCheckType checkType) {
	  nameCheck(checkType);
	  typeCheck(checkType);
	  contentCheck(checkType);	  
	  complianceCheck(checkType);	  
  }
  
  public void ASTNode.collectErrors(ErrorCheckType checkType) {
	  allChecks(checkType);
	  for(int i = 0; i < getNumChild(); i++) {
		  getChild(i).collectErrors(checkType);
	  }
  }


	public void ASTNode.errorCheck(ErrorCheckType checkType) {
		collectErrors(checkType);
		root().breakOnErrors();
	}

/*
    syn lazy FullClassDecl ASTNode.retrieveFullClassDecl(String className) {
      for(int i = 0; i < getNumChild(); i++) {
		  FullClassDecl fcd = getChild(i).retrieveFullClassDecl(className);
	  	  if (fcd != null)
	  	  	return fcd;
	  }
	  return null;
    }   
  	
  	eq FullClassDecl.retrieveFullClassDecl(String className) {
	   	if (className.equals(qualifiedName())) {
	   		return this;
		} else
			return getClassDeclList().retrieveFullClassDecl(className);
	}
*/
   
}

aspect InstanceErrorCheck {

 // Error checking in instance tree

	// We don't want to error check an entire model, just the classes
	//   that are used. 
	public void InstProgramRoot.checkErrorsInInstClass(String className, ErrorCheckType checkType) throws ModelicaClassNotFoundException{
		InstClassDecl icd = lookupInstClassQualified(className);
		if (icd.isUnknown()) 
			throw new ModelicaClassNotFoundException(className);
		else
			icd.errorCheck(checkType);
	}

	protected boolean BaseNode.errorChecked = false;

	public void ASTNode.resetCollectErrors() {
		for (ASTNode n : noTransform())
			n.resetCollectErrors();
	}
	
	public static void ASTNode.resetCollectErrorsOn(ASTNode n) {
		if (n != null)
			n.resetCollectErrors();
	}
	
	public void BaseNode.resetCollectErrors() {
		errorChecked = false;
		super.resetCollectErrors();
	}
	
	public void InstNode.resetCollectErrors() {
		super.resetCollectErrors();
		resetCollectErrorsOn(getInstComponentDeclListNoTransform());
		resetCollectErrorsOn(getInstClassDeclListNoTransform());
		resetCollectErrorsOn(getInstExtendsListNoTransform());
		resetCollectErrorsOn(getInstImportListNoTransform());
		resetCollectErrorsOn(getRedeclaredInstClassDeclListNoTransform());
		resetCollectErrorsOn(getFAbstractEquationListNoTransform());
	}

  public void InstNode.collectErrors(ErrorCheckType checkType) {
    if (!errorChecked) {
      errorChecked = true;
	  allChecks(checkType);
	  for (InstNode n : getInstComponentDecls()) 
		  n.collectErrors(checkType);
	  for (InstNode n : getInstExtendss()) 
		  n.collectErrors(checkType);
	  for (FAbstractEquation e : getFAbstractEquations()) 
		  e.collectErrors(checkType);
	}
  }
    
    /**
     * \brief Check if this node is in an InstComponentDecl.
     */
    inh boolean InstExtends.inInstComponent();
    inh boolean InstClassRedeclare.inInstComponent();
    eq InstComponentDecl.getChild().inInstComponent() = true;
    eq InstClassDecl.getChild().inInstComponent()     = false;
    eq InstRoot.getChild().inInstComponent()          = false;
    eq FlatRoot.getChild().inInstComponent()          = false;

  	public void InstBaseClassDecl.collectErrors(ErrorCheckType checkType) {
    	if (!errorChecked) {
	        super.collectErrors(checkType);
	    	errorChecked = true;
 //       for (InstClassDecl icd : instClassDecls())
 //       	icd.collectErrors(checkType);
 /*
        for (InstComponentDecl icd : instComponentDecls())
        	icd.collectErrors(checkType);
        for (InstExtends ie : instExtends())
        	ie.collectErrors(checkType);	
*/        	
	        for (InstImport ii : getInstImports())
	        	ii.collectErrors(checkType);		
			if (hasInstConstraining())
				getInstConstraining().collectErrors(checkType);
//        for (FAbstractEquation e : getFAbstractEquations())
//        	e.collectErrors(checkType);
//    	getEquationList().collectErrors(checkType);
//    	getAlgorithmList().collectErrors(checkType);
//    	getSuperList().collectErrors(checkType);
//    	getImportList().collectErrors(checkType);
//    	getComponentDeclList().collectErrors(checkType);
			if (getBaseClassDecl() instanceof FullClassDecl) { 	
				FullClassDecl fcd = (FullClassDecl)getBaseClassDecl();
				//log.debug(fcd.getName().getID() +  " " + fcd.getEndName());
				if (!(fcd.getName().getID().equals(fcd.getEndDecl().getEndID()))) {
					error("The declaration and end names of a class should be the same");
				}
			}
  		}
  	}
  	
  	public void InstFullClassDecl.collectErrors(ErrorCheckType checkType) {
    	if (!errorChecked) {
            super.collectErrors(checkType);
    		errorChecked = true;
            getInstExternalOpt().collectErrors(checkType);
    	}
  	}
    
    public void InstSimpleShortClassDecl.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
        	errorChecked = true;
        	getTarget().collectErrors(checkType);
        	actualInstClass().collectErrors(checkType);
        }    	
    }

//  	public void InstEnumClassDecl.collectErrors(ErrorCheckType checkType) {  		
//  		// TODO: Error checking of enumeration declarations
//  	}
  	
    public void InstImport.collectErrors(ErrorCheckType checkType) {
    	if (!errorChecked) {
    		errorChecked = true;
			getPackageName().collectErrors(checkType);
		}
	}
	
	public void InstComponentDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	errorChecked = true;
	    	boolean checkInner = isOuter() && 
	    	        !(myInnerInstComponentDecl().isUnknown() && checkType.allowOuterWithoutInner);
	    	if (isRecursed()) {
	    		error("Recursive class structure");
	    	} else if (checkInner) {
	    		if (myInnerInstComponentDecl().isUnknown())
	    			error("Cannot find inner declaration for outer " + name());
	    		else
	    			myInnerInstComponentDecl().collectErrors(checkType);
	    	} else if (inOuter()) {
	    		surroundingOuterComponentDecl().collectErrors(checkType);
	    	} else {
  		  		errorChecked = false;
	    		super.collectErrors(checkType);
  		  		collectErrorsInClassName(checkType);
  		  		if (hasFArraySubscripts())
  		  		    getFArraySubscripts().collectErrors(checkType);
	    		if (hasConditionalAttribute()) 
	    			getConditionalAttribute().collectErrors(checkType);
	    		if (isActive() && hasInstModification())
	    			getInstModification().collectErrors(checkType);
	    		if (hasInstConstraining())
	    			getInstConstraining().collectErrors(checkType);
	    	}
		}
	}
	
	// TODO: move to better place (InstanceTree.jrag?)
	syn boolean InstComponentDecl.isActive() {
		try {
			return !hasConditionalAttribute() || getConditionalAttribute().ceval().booleanValue();
		} catch (ConstantEvaluationException e) {
			return false;
		}
	}
	
	public void InstComponentDecl.collectErrorsInClassName(ErrorCheckType checkType) {
		getClassName().collectErrors(checkType);
	}	
	
	public void InstArrayComponentDecl.collectErrorsInClassName(ErrorCheckType checkType) {
		// TODO: use correct class name instead of "ArrayDecl" so that name lookup suceeds instead?
		//       need that for other things as well, but is there problems with it?
	}	
	
	public void FExp.checkConstantExpression(String varKind, String varName) {
		String exp = "'" + prettyPrint("") + "'";
		boolean failed = false;
		try {
			if (isCircular()) {
				error("Could not evaluate binding expression for %s '%s' due to circularity: %s", 
						varKind, varName, exp);
			} else {
				CValue val = ceval();
				if (val.isUnknown()) {
					if (val.isUnsupported()) {
						compliance("Constant evaluation not supported for expression(s) directly or indirectly " + 
								"used by the binding expression for %s '%s': %s", varKind, varName, exp);
					} else {
						failed = true;
					}
				}
			}
		} catch (ConstantEvaluationNotReadyException e) {
			// Will be evaluatable later, ignore for now
		} catch (ConstantEvaluationException e) {
			failed = true;
		}
		if (failed)
			error("Could not evaluate binding expression for %s '%s': %s", varKind, varName, exp);
	}
	
	public void InstAssignable.collectErrors(ErrorCheckType checkType) {
		//log.debug(toString());
        if (!errorChecked) {
        	super.collectErrors(checkType);
    		errorChecked = true;
	
			// Check binding expression
    		FExp bexp = myBindingInstExp();
    		if (bexp != null) {
    			String type = isParameter() ? "parameter" : "constant";
	    		// TODO: Check structural parameters as well
				// Check if the binding expression of constants can be evaluated
				if (isConstant()) 
					bexp.checkConstantExpression("constant", qualifiedName());
				else if (isParameter() && bexp.isCircular())
					bexp.error("Circularity in binding expression of parameter: %s = %s", 
							qualifiedName(), bexp);
				bexp.collectErrors(checkType);
    		} else {
				// Warn if constant or parameter does not have a binding expression (start is used)
				if ((isConstant() || isParameter()) && !isForIndex()) {
					String type = isParameter() ? "parameter" : "constant";
					warning("The %s %s does not have a binding expression", type, qualifiedName());
				}
    		}
    		
    		// Mark parameters with Evaluate=true as structural
    		if (isParameter() && annotation().forPath("Evaluate").bool())
    		    if (canEvaluateAsStructural())
    		        markAsStructuralParameter();
    		    else
    		        warning("Evaluate annotation is ignored when fixed equals false");
			
			// Check array indices
			getClassName().collectErrors(checkType);
			getLocalFArraySubscriptsOpt().collectErrors(checkType);
			
			// Check attributes for primitive variables
			checkAttributes();
		}
	}
	
    syn boolean InstComponentDecl.canEvaluateAsStructural() = true;
	eq InstAssignable.canEvaluateAsStructural() {
	    if (!fixedAttributeCValue().reduceBooleanAnd())
	        return false;
	    if (hasBindingFExp() && !getBindingFExp().canEvaluateAsStructural())
	        return false;
	    return true;
	}
    syn boolean FExp.canEvaluateAsStructural() {
        for (FExp n : childFExps())
            if (n.canEvaluateAsStructural())
                return false;
        return true;
    }
    eq FInstAccessExp.canEvaluateAsStructural() = getInstAccess().myInstComponentDecl().canEvaluateAsStructural();
	
	public void InstAssignable.checkAttributes() {}
	
	public void InstPrimitive.checkAttributes() {
		// Check if the expressions of the attributes can be evaluated
		// Note that this check has to be done locally in the
		// context of an InstAssignable node in order to avoid
		// evaluation of all value modifications also for non
		// parameters.
		for (InstModification im : totalMergedEnvironment()) {
			// Only check attributes, value modifications are checked above
			if (im instanceof InstComponentModification) {
				InstComponentModification icm = (InstComponentModification)im;
				if (icm.hasInstModification() && icm.getInstModification().hasInstValueMod()) {
					FExp val_mod = icm.getInstModification().instValueMod();
					if (val_mod.variability().lessOrEqual(fConstant())) 
						val_mod.checkConstantExpression("attribute", icm.getName().name());
					else if (!val_mod.variability().lessOrEqual(fParameter())) 
						val_mod.error("Variability of binding expression for attribute '%s' is not less than or equal to parameter variability: %s", 
								icm.getName().name(), val_mod);
					if (val_mod.isCircular())
						error("Could not evaluate binding expression for attribute '%s' due to circularity: %s", 
								icm.getName().name(), val_mod);
				}
			}
		}
	}
	
	public void InstExtends.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	if (isRecursed()) {
	    		error("Recursive class structure");
	    		errorChecked = true;
	    	} else {
				super.collectErrors(checkType);
    			errorChecked = true;
				getClassName().collectErrors(checkType);
				if (hasInstClassModification() && shouldCheckModification())
					getInstClassModification().collectErrors(checkType);
			}
	    }
	}
	
	// Normally the class modifications in an InstExtendsShortClass
	// does not need to be checked, since they are checked in InstShortClassDecl.
	// This is not the case if the short class decl references
	// an primitive variable, however, and in this case the
	// class modification needs to be checked for errors.
	syn boolean InstExtends.shouldCheckModification()           = true;
	eq InstExtendsShortClass.shouldCheckModification()          = extendsPrimitive();
	eq InstReplacingExtendsShortClass.shouldCheckModification() = extendsPrimitive();
	
	public void InstShortClassDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
		  super.collectErrors(checkType);
    	  errorChecked = true;
		  // The localInstModifications should only be checked if
		  // the node is not a InstReplacingShortClassDecl. This
		  // is accomplished by the method collectInstModificationErrors.
		  collectInstModificationErrors(checkType);
		  if (hasInstConstraining())
				getInstConstraining().collectErrors(checkType);		  
		}
	}

	public void InstShortClassDecl.collectInstModificationErrors(ErrorCheckType checkType) {
		for (InstModification mod : localInstModifications())
			mod.collectErrors(checkType);
    }
    public void InstReplacingShortClassDecl.collectInstModificationErrors(ErrorCheckType checkType) { }

	public void InstReplacingShortClassDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
		  super.collectErrors(checkType);
    	  errorChecked = true;
		  getOriginalInstClass().collectErrors(checkType);
		}
		
	}

	public void InstReplacingFullClassDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
		  super.collectErrors(checkType);
    	  errorChecked = true;
		  getOriginalInstClass().collectErrors(checkType);
		}
		
	}

	public void InstBuiltIn.collectErrors(ErrorCheckType checkType) {}

	public void InstComponentRedeclare.collectErrors(ErrorCheckType checkType) {
		super.collectErrors(checkType);
		getInstComponentDecl().collectErrors(checkType);
	}

	public void InstClassRedeclare.collectErrors(ErrorCheckType checkType) {
		super.collectErrors(checkType);
		if (!inInstComponent())
			getInstClassDecl().collectErrors(checkType);	
	}

	public void InstValueModification.collectErrors(ErrorCheckType checkType) {
		getFExp().collectErrors(checkType);
	}

	public void InstDot.collectErrors(ErrorCheckType checkType) {
		for (InstAccess ia : getInstAccesss()) {
			ia.collectErrors(checkType);
			if (ia.isUnknown())
				break;
		}
		allChecks(checkType);
	}

	public void InstClassAccess.collectErrors(ErrorCheckType checkType) {
	    nameCheck(checkType);
	}

	public void InstComponentAccess.collectErrors(ErrorCheckType checkType) {
	    super.collectErrors(checkType);
	    if (!myInstComponentDecl().isUnknown() && !isModificationName())
	    	myInstComponentDecl().collectErrors(checkType);
	}
	
	public void InstComponentArrayAccess.collectErrors(ErrorCheckType checkType) {
	    super.collectErrors(checkType);
	    if (!myInstComponentDecl().isUnknown() && !isModificationName())
	    	myInstComponentDecl().collectErrors(checkType);
	}
	
	inh boolean InstAccess.isModificationName();
	eq InstNamedModification.getName().isModificationName() = true;
	eq BaseNode.getChild().isModificationName()             = false;

	inh boolean FArraySubscripts.myAccessExists();
	eq Root.getChild().myAccessExists()       = false;
	eq InstAccess.getChild().myAccessExists() = !myInstComponentDecl().isUnknown();
	
	public void FArraySubscripts.collectErrors(ErrorCheckType checkType) {
		// Should this check be in the access instead?
		int ndims = mySize().ndims();
		if (getNumFSubscript() > ndims && !isInstComponentSize() && myAccessExists()) {
			// TODO: shouldn't this check for to few as well? (no [] or all dimensions given)
			error("Too many array subscripts for access: " + getNumFSubscript() + 
					" subscripts given, component has " + mySize().ndims() + " dimensions");
			allChecks(checkType);
			for (int i = 0; i < ndims; i++)
				getFSubscript(i).collectErrors(checkType);
		} else {
    		super.collectErrors(checkType);
		}
	}
	
	/**
	 * \brief Check if class has exactly one algorithm section or external function declaration.
	 */
	public boolean InstClassDecl.isCompleteFunction() {
		return (numFAlgorithm() == 1) != (numInstExternal() == 1);
	}
	
	syn boolean InstClassDecl.hasInstExternal() = false;
	
	syn int InstClassDecl.numInstExternal() {
		int n = hasInstExternal() ? 1 : 0;
		for (InstExtends ie : getInstExtendss())
			n += ie.myInstClass().numInstExternal();
		return n;
	}
	eq InstSimpleShortClassDecl.numInstExternal() = actualInstClass().numInstExternal();
	
	syn int InstClassDecl.numFAlgorithm() {
		int n = 0;
		for (FAbstractEquation e : getFAbstractEquations())
			if (e instanceof FAlgorithm)
				n++;
		for (InstExtends ie : getInstExtendss())
			n += ie.myInstClass().numFAlgorithm();
		return n;
	}
	eq InstSimpleShortClassDecl.numFAlgorithm() = actualInstClass().numFAlgorithm();
	
	public void InstExternalObject.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
			super.collectErrors(checkType);
	    	errorChecked = true;
	    	if (!inFunction()) {
	    		getDestructorCall().collectErrors(checkType);
	    		myInstClass().collectErrors(checkType);
	    	}
	    }
	}
	  
	public void InstForClauseE.collectErrors(ErrorCheckType checkType) {
	    collectErrorsInFor(getFAbstractEquationList(), getInstForIndexList(), checkType);
	}
	
	public void InstForStmt.collectErrors(ErrorCheckType checkType) {
	    collectErrorsInFor(getForStmtList(), getInstForIndexList(), checkType);
	}
	
	public void FIterExp.collectErrors(ErrorCheckType checkType) {
	    collectErrorsInFor(getFExp(), getForIndexList(), checkType);
	}
	
	public void ASTNode.collectErrorsInFor(
	        ASTNode iterChild, List<? extends CommonForIndex> indices, ErrorCheckType checkType) {
	    // Do the checks on the for itself
	    allChecks(checkType);
	    
	    // Check everything except iterChild once
	    for (ASTNode ch : this)
	        if (ch != iterChild)
	            ch.collectErrors(checkType);
	    
	    // Check array bounds in iterChild for each index combination
	    try {
	        indices.getChild(0).collectErrorsForAllIndices(indices, 0, iterChild, checkType);
	    } catch (ConstantEvaluationException e) {
	        // This error is caught elsewhere
	    }
	}
    
    /**
     * Collect errors in iterated node for all combinations of for indices.
     * 
     * @param indices    the list of indices too loop for
     * @param i          next index to handle
     * @param child      the iterated node to check
     * @param checkType  type of check to perform
     */
    public void CommonForIndex.collectErrorsForAllIndices(
            List<? extends CommonForIndex> indices, int i, ASTNode child, ErrorCheckType checkType) {
        throw new UnsupportedOperationException();
    }
    
    public void InstForIndex.collectErrorsForAllIndices(
            List<? extends CommonForIndex> indices, int i, ASTNode child, ErrorCheckType checkType) {
        if (hasFExp()) {
            InstComponentDecl var = getInstPrimitive();
            CValue oldVal = var.evaluationValue;
            boolean last = i == indices.getNumChild() - 1;
            CommonForIndex next = last ? null : indices.getChild(i + 1);
            CValueArray ivals = getFExp().ceval().array();
            for (Index j : ivals.indices()) {
                var.setEvaluationValue(ivals.getCell(j));
                if (last) {
                    child.collectErrors(checkType);
                    child.flushAllRecursive();
                } else {
                    next.collectErrorsForAllIndices(indices, i + 1, child, checkType);
                }
            }
            var.setEvaluationValue(oldVal);
        }
    }
	
    
	public void InstFunctionCall.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	errorChecked = true;
	    	// Check that the function exists
	    	InstClassDecl func = getName().myInstClassDecl();
	    	if (!func.isCallable()) {
	    		// Report that function does not exist
		    	String name = getName().name();
		    	if (func.isExternalObject()) {
		    		name += ".constructor";
		    		func = func.myConstructor();
		    	}
		    	if (func.isUnknown()) 
	    			error("Cannot find function declaration for " + name + "()");
	    		else
	    			error("The class " + name + " is not a function");
	    	} else if (!func.isRecord() && !func.isCompleteFunction()) {
	    		// TODO: add check if function is partial?
	    		error("Calling function " + getName().name() + 
	    				"(): can only call functions that have one algorithm section or external function specification");
	    	} else {
	    		// Function exists, check everything
	    		super.collectErrors(checkType);
	    		
	    		// We need to check the function definition as well.
	    	    func.collectErrors(checkType);
	    	    
	    	    // Check if there were any unbindable args
			    boolean pos = true;
			    String desc = functionCallDecription();
			    for (InstFunctionArgument arg : unbindableArgs) 
			    	pos = arg.generateUnbindableError(desc, pos);
	    	}
	    }
	}
	
	public void FInfArgsFunctionCall.collectErrors(ErrorCheckType checkType) {
		super.collectErrors(checkType);
		if (unbindableArgs != null) {
		    boolean pos = true;
		    String desc = functionCallDecription();
		    for (InstFunctionArgument arg : unbindableArgs) 
		    	pos = arg.generateUnbindableError(desc, pos);
		}
	}
	
	syn String FAbstractFunctionCall.functionCallDecription() = "Calling function " + name() + "()";
	eq FRecordConstructor.functionCallDecription() = "Record constructor for " + name();
	eq InstFunctionCall.functionCallDecription()   = getName().myInstClassDecl().isRecord() ? 
			"Record constructor for " + name() : super.functionCallDecription();
	  
	public boolean InstFunctionArgument.generateUnbindableError(String desc, boolean genForPos) {
		return genForPos;
	}
	  
	public boolean InstPositionalArgument.generateUnbindableError(String desc, boolean genForPos) {
		if (genForPos)
			error(desc + ": too many positional arguments");
		return false;
	}
	  
	public boolean InstNamedArgument.generateUnbindableError(String desc, boolean genForPos) {
		error(desc + ": no input matching named argument " + getName().name() + " found");
		return genForPos;
	}
	
	public void FBuiltInFunctionCall.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	super.collectErrors(checkType);
	    	errorChecked = true;
	    	getOriginalArgs().collectErrors(checkType);
	    }
	}
	
	public void FUnsupportedBuiltIn.collectErrors(ErrorCheckType checkType) {
		// Don't check arguments
		allChecks(checkType);
	}
 
	public void InstNamedArgument.collectErrors(ErrorCheckType checkType) {
		// TODO: This way, the FExp for each argument to a built-in function is checked twice - fix that
	    if (!errorChecked) {
			allChecks(checkType);
			getFExp().collectErrors(checkType);
	    }
	}
	
	/**
	 * \brief Check if this node is in a recursive structure.
	 */
	syn boolean InstNode.isRecursed()      = false;
	eq InstComponentDecl.isRecursed()      = isWithin(myInstClass());
	eq InstExtends.isRecursed()            = isWithin(myInstClass());
	eq InstArrayComponentDecl.isRecursed() = instComponentDecl().isRecursed();
	
	// TODO: check if we realy need this in addition to isRecursed()
	/**
	 * \brief Check if extends tree is recursive.
	 */
	public boolean InstExtends.isRecursive() {
		if (recursiveCache == RECURSIVE_UNKNOWN)
			calcIsRecursive(new HashSet<InstNode>());
		return recursiveCache == RECURSIVE_YES;
	}
	
	/**
	 * \brief Check if extends tree is recursive.
	 */
	public boolean InstSimpleShortClassDecl.isRecursive() {
		if (recursiveCache == RECURSIVE_UNKNOWN)
			calcIsRecursive(new HashSet<InstNode>());
		return recursiveCache == RECURSIVE_YES;
	}
	
	/**
	 * \brief Examine extends tree to find recursive extends nodes.
	 */
	public void InstExtends.calcIsRecursive(HashSet<InstNode> visited) {
		recursiveCache = visited.contains(this) ? RECURSIVE_YES : RECURSIVE_NO;
		visited.add(this);
		if (recursiveCache == RECURSIVE_NO) 
			myInstClass().calcIsRecursive(visited);
	}
	
	/**
	 * \brief Examine extends tree to find recursive extends nodes.
	 */
	public void InstClassDecl.calcIsRecursive(HashSet<InstNode> visited) {
		for (InstExtends ie : getInstExtendss())
			ie.calcIsRecursive(visited);
	}
	
	public void InstSimpleShortClassDecl.calcIsRecursive(HashSet<InstNode> visited) {
		recursiveCache = visited.contains(this) ? RECURSIVE_YES : RECURSIVE_NO;
		visited.add(this);
		if (recursiveCache == RECURSIVE_NO) 
			getTarget().myInstClassDecl().calcIsRecursive(visited);
	}
	
	private byte InstExtends.recursiveCache              = RECURSIVE_UNKNOWN;
	private byte InstSimpleShortClassDecl.recursiveCache = RECURSIVE_UNKNOWN;
	protected static final byte InstNode.RECURSIVE_UNKNOWN = 0;
	protected static final byte InstNode.RECURSIVE_YES     = 1;
	protected static final byte InstNode.RECURSIVE_NO      = 2;
	
	/**
	 * \brief Check if <code>icd</code> is an ancestor of this node or any ancestor is an 
	 *        instance of <code>icd</code>.
	 */
	inh boolean InstComponentDecl.isWithin(InstClassDecl icd);
	inh boolean InstExtends.isWithin(InstClassDecl icd);
	eq InstNode.getChild().isWithin(InstClassDecl icd)          = isOfInstClassDecl(icd);
	eq InstComponentDecl.getChild().isWithin(InstClassDecl icd) = isOfInstClassDecl(icd) || isWithin(icd);
	eq InstExtends.getChild().isWithin(InstClassDecl icd)       = isOfInstClassDecl(icd) || isWithin(icd);
    eq Root.getChild().isWithin(InstClassDecl icd)              = false;
	
	/**
	 * \brief Check if this node is equal to or an instance of <code>icd</code>.
	 */
	syn boolean InstNode.isOfInstClassDecl(InstClassDecl icd) = false;
	eq InstClassDecl.isOfInstClassDecl(InstClassDecl icd)     = icd == this;
	eq InstComponentDecl.isOfInstClassDecl(InstClassDecl icd) = icd == myInstClass() && !icd.isUnknown();
	eq InstExtends.isOfInstClassDecl(InstClassDecl icd)       = icd == myInstClass() && !icd.isUnknown();
	
}

aspect AssertEval {

    public class FClass {
        /**
         * Evaluate asserts with constant tests, generate errors for failing ones, 
         * and eliminate all evaluated assets.
         */
        public class evaluateAsserts extends Transformation {
            public void perform() {
                for (FAbstractEquation eqn : getFEquationBlock(0).getFAbstractEquations())
                    eqn.evaluateAsserts();
                List<FAbstractEquation> l = new List<FAbstractEquation>();
                for (FAbstractEquation eqn : getFEquationBlock(0).getFAbstractEquations())
                    if (!eqn.markedForRemoval)
                        l.add(eqn);
                getFEquationBlock(0).setFAbstractEquationList(l);
            }
        }
    }
    
    /**
     * Try to evaluate asserts with constant tests in this equation.
     * 
     * If this equation should be removed, <code>markedForRemoval</code> is set.
     */
    public void FAbstractEquation.evaluateAsserts() {}
    
    public void FFunctionCallEquation.evaluateAsserts() {
        markedForRemoval = getCall().evaluateAsserts();
    }
    
    /**
     * If this call is an assert with constant test, try to evaluate it.
     * 
     * @return  <code>true</code> if this is an assert that should be removed
     */
    public boolean FAbstractFunctionCall.evaluateAsserts() {
        return false;
    }
    
    private static final String FAssert.LEVEL_ERROR = "error";
    
    public boolean FAssert.evaluateAsserts() {
        boolean remove = false;
        if (getTest().isConstantExp()) {
            try {
                boolean val = getTest().ceval().booleanValue();
                if (!val) {
                    String msg = "Assertion failed: " + getMsg().ceval().stringValue();
                    if (!hasLevel() || getLevel().ceval().stringValue().equals(LEVEL_ERROR))
                        error(msg);
                    else
                        warning(msg);
                }
                remove = true;
            } catch (ConstantEvaluationException e) {}
        }
        return remove;
    }
    
}
