import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;


/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect Arrays {

	/**
	 * \brief Get the array subscripts of a ComponentDecl.
	 * 
	 * @return If the ComponentDecl has subscripts, then return these, otherwise
	 * null.
	 */
	syn lazy ArraySubscripts ComponentDecl.arraySubscripts() =
		hasVarArraySubscripts()? getVarArraySubscripts():
			null;

	/**
	 * \brief Check if an identifier is inside array subscripts.
	 * 
	 * @return If the identifier is in an array subscripts sub-AST then true
	 * else false.
	 */
	inh boolean FIdUseExp.inArraySubscripts();
	eq FArraySubscripts.getChild().inArraySubscripts() = true;
	eq Root.getChild().inArraySubscripts() = false;
	
	/**
	 * \brief Check if an access is an array access.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean Access.isArrayAccess() = false;
	eq ArrayAccess.isArrayAccess() = hasArraySubscripts();
	
	/**
	 * \brief Get the array subscripts of an access, if any.
	 * 
	 * @return The array subscripts of the access, if any, otherwise null.
	 */
	syn ArraySubscripts Access.arraySubscripts() = null;
	eq ArrayAccess.arraySubscripts() = hasArraySubscripts()? getArraySubscripts(): null;

	/**
	 * \brief Check if an instance access has array subscripts.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean InstAccess.isInstArrayAccess() = false;
	eq InstArrayAccess.isInstArrayAccess() = hasFArraySubscripts();
	
	
	/**
	 * \brief Get the FArraySubscripts of an InstAccess, if any.
	 * 
	 * @return A reference to a FArraySubscripts object, or null.
	 */
	syn FArraySubscripts InstAccess.fArraySubscripts() = null;
	eq InstArrayAccess.fArraySubscripts() = hasFArraySubscripts()? getFArraySubscripts(): null;

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FAbstractEquation.ndims() = -1;
	eq FEquation.ndims() {
		if (getLeft().ndims() == getRight().ndims()) {
			return getLeft().ndims();
		}
		return -1;
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FArraySubscripts.ndims() { 
		return getNumFSubscript();
	}

	// Array dimensions
	/**
	 * \brief Get array dimensions of array subscripts when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FArraySubscripts.accessNdims() { 
		//System.out.println("FArraySubscripts.accessNdims()");
		// Need to check if each individual subscript increases 
		// dimension. (ndims(x[1])=0)
		int nd = 0;
		for (FSubscript fs : getFSubscripts()) {
			nd += fs.ndims();
		}
		return nd;
	}

	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FSubscript.ndims();
	eq FExpSubscript.ndims() = getFExp().ndims();
	eq FColonSubscript.ndims() = 1;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FExp.ndims() = 0;
	eq FInstAccessExp.ndims() = getInstAccess().ndims();
	eq FRangeExp.ndims() = 1;
	eq FArray.ndims() {
		if (getNumFExp()==0) { //Empty array
			return 1;
		} else { // We assume that the FArray is set up correctly and that
			     // all brances are equal.
			return getFExp(0).ndims() + 1;
		}
	}
	eq FIdentity.ndims() = 2;
	eq FOnes.ndims() = getNumFExp();
	eq FZeros.ndims() = getNumFExp();
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FIdUse.ndims() {
		// Notice here the use of accessNdims. Also, if the access has
		// no subscripts, it may still have dimension > 0 if its declaration
		// is an array declaration.
		return getFQName().hasFArraySubscripts()? 
				getFArraySubscripts().accessNdims(): myFV().ndims();
	}
	eq FIdUseExp.ndims() = getFIdUse().ndims();
		
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAccess.ndims() = 0;
	eq InstArrayAccess.ndims() {
		//.out.println("InstArrayAccess.ndims()");
		return hasFArraySubscripts()? 
			getFArraySubscripts().accessNdims(): 
				myInstComponentDecl().ndims();
	}
	
	eq InstDot.ndims() = getRight().ndims() + getLeft().ndims();
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstNode.ndims() = 0;
	
	eq InstComponentDecl.ndims() = hasFArraySubscripts()? 
			getFArraySubscripts().ndims(): 0;

	syn int AbstractFVariable.ndims() = -1;
	
	eq FVariable.ndims() = isScalarized()? 0 : getFQName().ndims();
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FQName.ndims() {
		// Only look at the array subscripts for the last FQNamePart,
		// all other array subscripts has been expanded in the instantiation.
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().ndims(); 
		} else {
			return 0;
		}
	}

	/**
	 * \brief Get array dimensions of an identifier when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */		
	syn int FQName.accessNdims() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().accessNdims(); 
		} else {
			return 0;
		}
	}

	
	// Array sizes
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FAbstractEquation.size() = new int[0];
	eq FEquation.size() {
		int[] leftSize = getLeft().size();
		int[] rightSize = getRight().size();
		if (leftSize.length!=rightSize.length) {
			return new int[0];
		}
		for (int i=0;i<leftSize.length;i++) {
			if (leftSize[i]!=rightSize[i]) {
				return new int[0];
			}
		}
		return leftSize;
	}

	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FArraySubscripts.size() {
		int s[] = new int[ndims()];
		int index = 0;
		for (FSubscript fs : getFSubscripts()) {
			s[index++] = fs.ceval().intValue();
		}
		return s;
	}

	/**
	 * \brief Get the array sizes when the array subscripts are used in an
	 * access. See also documentation of accessNdims(). 
	 * 
	 * @return An array of integers of length accessNdims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FArraySubscripts.accessSize() {
		int s[] = new int[accessNdims()];
		int index = 0;
		for (FSubscript fs : getFSubscripts()) {
			if (fs.ndims() == 1) {
				s[index++] = fs.size()[0];
			}
		}
		return s;
	}

	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FSubscript.size();

	eq FExpSubscript.size() = getFExp().size();
	
	eq FColonSubscript.size() = new int[0]; // TODO
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FExp.size() = new int[0];
	eq FInstAccessExp.size() = getInstAccess().size();

	
 	eq FRangeExp.size() {
		int[] si = new int[1];
		si[0] = 0;
		if (getNumFExp()==2) { // e.g. 1:10
			si[0] = (int)(getFExp(1).ceval().realValue() - 
				getFExp(0).ceval().realValue() + 1);
			if (si[0]<0) {
				si[0] = 0;
			}
		} else if (getNumFExp()==3) {
			double first = getFExp(0).ceval().realValue();
			double step = getFExp(1).ceval().realValue();
			double last = getFExp(2).ceval().realValue();
			
			if (step > 0.0) 
				for (double i = first; i <= last; i += step)
					si[0]++;
			else if (step < 0.0)
				for (double i = first; i >= last; i += step)
					si[0]++;
		}
		return si;
	}
	
	eq FArray.size() {
		int s[] = new int[ndims()];
		if (getNumFExp()==0) {
		} else {
			int ss[] = getFExp(0).size();
			s[0] = getNumFExp();
			for (int i=1;i<ndims();i++) {
				s[i] = ss[i-1];
			}
		}
		return s;
	}
	
	eq FIdentity.size() {
		int s[] = new int[2];
		s[0] = getFExp().ceval().intValue();
		s[1] = getFExp().ceval().intValue();
		return s;
	}
	eq FOnes.size() {
		int s[] = new int[ndims()];
		int index = 0;
		for (FExp fe : getFExps()) {
			s[index++] = fe.ceval().intValue();
		}
		return s;		
	}
	
	eq FZeros.size() {
		int s[] = new int[ndims()];
		int index = 0;
		for (FExp fe : getFExps()) {
			s[index++] = fe.ceval().intValue();
		}
		return s;
		
	}
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FIdUse.size() {
		return getFQName().hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): myFV().size();
	}
		
	eq FIdUseExp.size() = getFIdUse().size();
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] InstAccess.size() = new int[0];
	eq InstArrayAccess.size() = hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): 
				myInstComponentDecl().size();
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	eq InstDot.size() {
		int s[] = new int[ndims()];
		int sr[] = getRight().size();
		int sl[] = getLeft().size();
		for (int i=0;i<sl.length;i++) {
			s[i] = sl[i];
		}
		for (int i=0;i<sr.length;i++) {
			s[i+sl.length] = sr[i];
		}
		return s;
	}
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] InstNode.size() = new int[0];
	
	eq InstComponentDecl.size() = hasFArraySubscripts()? 
			getFArraySubscripts().size(): new int[0];

	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */	
	syn lazy int[] AbstractFVariable.size() = new int[0];
	eq FVariable.size() = isScalarized()? new int[0]: getFQName().size();
		
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FQName.size() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().size(); 
		} else {
			return new int[0];
		}
	}
		
	/**
	 * \brief check if an expression is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FExp.isArray() = ndims()>0;

	/**
	 * \brief check if a variable is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FVariable.isArray() = ndims()>0;
	
	/**
	 * \brief check if an instance node is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstNode.isArray() = ndims()>0;
	
	/**
	 * \brief Set the array subscripts of the last name part.
	 */
	public void FQName.setLastFArraySubscripts(FArraySubscripts fas) {
		getFQNamePart(getNumFQNamePart()-1).setFArraySubscripts(fas);
	}
	
	/**
	 * \brief Set the array subscripts of the last name part.
	 */
	public void InstAccess.setLastFArraySubscripts(FArraySubscripts fas) {
		((InstArrayAccess) getLastInstAccess()).setFArraySubscripts(fas);
	}
	
	/**
	 * \brief Computes an Array where all elements are scalar expressions.
	 * 
	 * This is used mainly to scalarize array expressions.
	 * 
	 * @return An Array with scalar expressions if this is an array expression, 
	 *          <code>null</code> otherwise.
	 */
	syn lazy Array FExp.array() = null;
	
	eq FArray.array() {
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			fillArray(arr, i, 0);
		return arr;
	}
	
	/**
	 * \brief Add a copy of this expression to arr at position i. 
	 */
	public void FExp.fillArray(Array arr, Index i, int level) {
		arr.set(i, (FExp) fullCopy());
	}
	
	/**
	 * \brief Add a copy of the expression at position i to arr. 
	 * 
	 * @param arr    the Array to add the expression to.
	 * @param i      the index to add at, denotes position in both Array and FArray.
	 * @param level  the level this FArray is at in a structure of nestled FArrays.
	 */
	public void FArray.fillArray(Array arr, Index i, int level) {
		getFExp(i.index()[level] - 1).fillArray(arr, i, level + 1);
	}
	
	eq FIdUseExp.array() {
		System.out.println("FIdUseExp.array() begin: " + isArray());
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			System.out.println("FIdUseExp.array(): " + size().length);
			
			Array array = new Array(indices());
			for (Index i : array.indices()) {
				FIdUseExp fid_tmp = (FIdUseExp) fullCopy();
				FQName fqn = fid_tmp.getFIdUse().getFQName();
				fqn.setLastFArraySubscripts(i.newFArraySubscripts());
				fqn.scalarized = true;
				array.set(i, fid_tmp);
			}
			return array;
			
		} else {
			return null;
		}
	}

	boolean InstAccess.scalarized = false;
	
	eq FInstAccessExp.array() {
		//System.out.println("FInstAccessExp.array() begin: " + isArray());
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			//System.out.println("FInstAccessExp.array(): " + size().length);
			Array array = new Array(indices());
			for (Index i : array.indices()) {
				FInstAccessExp ia_tmp = (FInstAccessExp)this.fullCopy();
				InstAccess ia = ia_tmp.getInstAccess();
				ia.setLastFArraySubscripts(i.newFArraySubscripts());
				ia.scalarized = true;
				array.set(i, ia_tmp);
			}
			return array;
		} else {
			return null;
		}
	}

	
	/**
	 * \brief Computes an Array where all elements are scalar expressions.
	 * 
	 * This is used mainly to scalarize array expressions.
	 * 
	 * @return An Array object with scalar objects.
	 */
	syn lazy Array FSubscript.array() = null;
	
	eq FExpSubscript.array() = getFExp().array();
	eq FRangeExp.array() {
		//System.out.println("FRangeExp.array(): size = " + size()[0]);	
		double i1 = getFExp(0).ceval().realValue();
		double i2 = 1.0;
		if (getNumFExp() > 2) 
			i2 = getFExp(1).ceval().realValue();
		Array array = new Array(indices());
		for (Index i : array.indices()) { 
			array.set(i, new FRealLitExp(i1));
			i1 += i2;
		}
		
		return array;
	}
	
	eq FZeros.array() = new Array(indices()).fill(new FIntegerLitExp(0));
	eq FOnes.array()  = new Array(indices()).fill(new FIntegerLitExp(1));
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FExp.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FIdUseExp.indices() = getFIdUse().indices();

	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FIdUse.indices() {
		return getFQName().hasFArraySubscripts()? 
				getFArraySubscripts().indices(): myFV().indices();
	}	

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FInstAccessExp.indices() = getInstAccess().indices();

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstAccess.indices() = myInstComponentDecl().indices();
	eq InstDot.indices()                  = getLastInstAccess().indices();
	eq InstArrayAccess.indices()          = 
		hasFArraySubscripts() ? getFArraySubscripts().indices() : myInstComponentDecl().indices();

	/**
	 * \brief Get the set of all array indices of an FVariable. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices AbstractFVariable.indices() = null;
	eq FVariable.indices() = isScalarized() ? null : Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an InstComponentDecl. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstComponentDecl.indices() = Indices.create(size());
		
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */	
//	syn Indices FQName.indices() {
//		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
//		if (last.hasFArraySubscripts()) {
//			return last.getFArraySubscripts().indices(); 
//		} else {
//			return myFV().indices();
//		}
//	}
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FEquation.indices() = getLeft().indices();
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FArraySubscripts.indices() = Indices.create(this);
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn int[] FSubscript.myIndices();
	
	eq FColonSubscript.myIndices() {
		// TODO: should return 1..n
		return new int[0];
	}
	
	eq FExpSubscript.myIndices() = getFExp().myIndices();
	
	syn int[] FExp.myIndices() {
		if (ndims() == 0) {
			return new int[] { ceval().intValue() };
		} else if (ndims() == 1) {
			int[] indices = new int[size()[0]];
			Array indExps = array();
			int j = 0;
			for (FExp exp : indExps) 
				indices[j++] = exp.ceval().intValue();
			return indices;
		} else {
			return new int[0];
		}
	}

}

aspect ArrayIndices {
	
	/**
	 * \brief Array describes the set of scalarized FExp nodes corresponding to an array expression.
	 */
	public class Array implements Iterable<FExp> {
		
		private FExp[]  expressions;
		private Indices indices;
		
		// TODO: add more constructors?
		
		/**
		 * \brief Create an Array spanning a given Indices.
		 */
		public Array(Indices indices) {
			this.indices = indices;
			expressions = new FExp[indices.numElements()];
		}
		
		/**
		 * \brief Create an Array with dimentions <code>size</code>.
		 */
//		public Array(int[] size) {
//			this(Indices.create(size));
//		}
		
		/**
		 * \brief Creates an iterator that iterates over all FExp nodes in this Array.
		 */
		public Iterator<FExp> iterator() {
			return new AIterator();
		}
		
		/**
		 * \brief Returns the FExp node referenced by <code>i</code> in this Array.
		 */
		public FExp get(Index i) {
			return expressions[i.internal(indices)];
		}
		
		/**
		 * \brief Sets the FExp node referenced by <code>i</code> in this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			expressions[i.internal(indices)] = exp;
		}
		
		/**
		 * \brief Returns the Indices associated with this Array.
		 */
		public Indices indices() {
			return indices;
		}
		
		/**
		 * \brief Set all expressions in Array to copies of <code>exp</code>.
		 * 
		 * @return <code>this</code> 
		 */
		public Array fill(FExp exp) {
			for (int i = 0; i < expressions.length; i++)
				expressions[i] = (FExp) exp.fullCopy();
			return this;
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Array.
		 */
		public int ndims() {
			return indices.ndims();
		}
		
		/**
		 * \brief Returns the size of this Array in each dimension.
		 */
		public int[] size() {
			return indices.size();
		}
		
		/**
		 * \brief Iterates over all FExp nodes in this Array.
		 */
		private class AIterator implements Iterator<FExp> {
			
			private int i = 0;
			
			public boolean hasNext() {
				return i < expressions.length;
			}
			
			public FExp next() {
				return expressions[i++];
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
	}
	
	/**
	 * \brief Represents the index/indices of a single cell in an (possibly 
	 *        multi-dimensional) array. 
	 */
	public class Index implements Cloneable {
		
		protected int[] index;
		
		/**
		 * \brief Construct an Index representing the indices given in <code>ind</code>.
		 */
		protected Index(int[] ind) {
			index = ind;
		}
		
		/**
		 * \brief Returns the indices that specify this cell.
		 */
		public int[] index() {
			return index;
		}
		
		/**
		 * \brief Create a new FArraySubscripts object describing this index.
		 */
		public FArraySubscripts newFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < index.length; i++) {
				fas.addFSubscript(new FExpSubscript(new FIntegerLitExp(index[i])));
			}
			return fas;
		}
		
		/**
		 * \brief Copies this Index. Always use clone() when saving an Index.
		 */
		public Index clone() {
			try {
				Index i = (Index) super.clone();
				i.index = index.clone();
				return i;
			} catch (CloneNotSupportedException e) {
				return null;
			}
		}
		
		/**
		 * \brief Return a String represetation of this Index.
		 */
		public String toString() {
			return Arrays.toString(index);
		}
		
		
		/**
		 * \brief Return the internal index in an Array of the cell this Index refers to.
		 *        Only for use from Array.
		 * 
		 * @param indices  the indices to resolve the internal index with
		 */
		public int internal(Indices ind) {
			return ind.internal(this);
		}
		
		/**
		 * \brief Construct an empty Index.
		 */
		protected Index() {
		}
		
		/**
		 * \brief Construct an Index of ndims dimensions, 
		 *        pointing at the spot before the first cell.
		 */
		protected Index(int ndims) {
			index = new int[ndims];
			for (int i = ndims - 2; i >= 0; i--)
				index[i] = 1;
			index[ndims - 1] = 0;
		}
		
	}
	
	/**
	 * \brief Indices represents the set of array indices in each dimension.
	 * 
	 * Only supports indices of the form (1..n1, 1..n2, ... , 1..nk). 
	 * See {@see NonConsecutiveIndices}. 
	 * 
	 * New Indices objects should be created with the create() methods. 
	 * The subclass used is selected automatically. 
	 * 
	 * The Indices class is typically used to iterate over all possible indices
	 * of an array access of declaration.
	 */
	public class Indices implements Iterable<Index> {
		protected int ndims;
		protected int size[];
		
		/**
		 * \brief Create an Indices object based on array sizes. 
		 */
		public static Indices create(int[] size) {
			return new Indices(size);
		}
		
		/**
		 * \brief Create an Indices object based on FArraySubcripts.
		 */
		public static Indices create(FArraySubscripts fas) {
			return NonConsecutiveIndices.create(fas);
		}
		
		/**
		 * \brief Create an Indices object based on a list of int arrays.
		 */
		public static Indices create(ArrayList<int[]> ind) {
			return NonConsecutiveIndices.create(ind);
		}
		
		/**
		 * \brief Check that i is valid for this Indices object.
		 */
		public boolean isValid(Index i) {
			int[] index = i.index();
			for (int j = 0; j < ndims; j++)
				if (index[j] > size[j])
					return false;
			return true;
		}
		
		/**
		 * \brief Returns an Iterator, that iterates over all indices spanned by this Indices object.
		 */
		public Iterator<Index> iterator() {
			return new IIterator();
		}
		
		/**
		 * \brief Returns the number of elements spanned by this Indices object.
		 */
		public int numElements() {
			int res = 1;
			for (int i = 0; i < ndims; i++)
				res *= size[i];
			return res;
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Indices object.
		 */
		public int ndims() {
			return ndims;
		}
		
		/**
		 * \brief Returns the size of this Indices object in each dimension.
		 */
		public int[] size() {
			return size;
		}
		
		
		/**
		 * \brief Internal constructor to create an Indices object with ndim dimensions. 
		 *        For use by subclasses.
		 */
		protected Indices(int ndims) {
			this.ndims = ndims;
			size = new int[ndims];
		}
		
		/**
		 * \brief Internal constructor to create an Indices object based on array sizes. 
		 */
		protected Indices(int[] size) {
			ndims = size.length;
			this.size = size.clone();
		}
		
		/**
		 * \brief Calculate the internal index in an Array that spans this Indices.
		 */
		protected int internal(Index i) {
			int[] index = i.index();
			int res = 0;
			for (int j = 0; j < ndims; j++)
				res = res * size[j] + index[j] - 1;
			return res;
		}
		
		/**
		 * \brief Iterates over all indices spanned by this Indices.
		 */
		protected class IIterator implements Iterator<Index> {
			
			protected IIndex index;
			protected int max;
			
			public IIterator() {
				index = new IIndex();
				max = numElements() - 1;
			}
			
			public boolean hasNext() {
				return index.internal < max;
			}
			
			public Index next() {
				index.internal++;
				int[] ind = index.index();
				int i;
				for (i = ndims - 1; i > 0 && ind[i] >= size[i]; i--)
					ind[i] = 1;
				ind[i]++;
				return index;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
		/**
		 * \brief Internal implementation of Index.
		 */
		protected class IIndex extends Index {
			
			public int internal;
			
			/**
			 * \brief Construct an Index over the number of dimensions of the enclosing Indices, 
			 *        pointing at the spot before the first cell.
			 */
			public IIndex() {
				super(ndims);
				internal = -1;
			}
			
			/**
			 * \brief Return the internal index in an Array of the cell this Index refers to.
			 *        Only for use from Array.
			 * 
			 * @param indices  the indices to resolve the internal index with
			 */
			public int internal(Indices ind) {
				if (ind == Indices.this) 
					return internal;
				else
					return ind.internal(this);
			}
			
		}
		
	}

	/**
	 * \brief NonConsecutiveIndices describes a set of array indices that isn't 
	 *        limited to 1..n.
	 * 
	 * For example, consider the declaration Real x[4,4,4] and the access
	 * x[:,1,1:2:4]. The array indices for the declaration is then
	 * {1,2,3,4}, {1,2,3,4}, and {1,2,3,4} respectively for the three dimensions.
	 * For the access, we have {1,2,3,4}, {1} and {1,3} respectively.
	 */			/**
	 * 
	 */
	public class NonConsecutiveIndices extends Indices {
		// The indices are stored as a list of integer arrays.
		protected ArrayList<int[]> indices; 
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on FArraySubcripts.
		 *        Use Indices.create(FArraySubscripts fas).
		 */
		public static NonConsecutiveIndices create(FArraySubscripts fas) {
			return new NonConsecutiveIndices(fas);
		}
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on a list of int arrays
		 *        Use Indices.create(ArrayList<int[]> ind).
		 */
		public static NonConsecutiveIndices create(ArrayList<int[]> ind) {
			return new NonConsecutiveIndices(ind);
		}
		
		/**
		 * \brief Check that i is valid for this Indices object.
		 */
		public boolean isValid(Index i) {
			int[] index = i.index();
			for (int j = 0; j < ndims; j++)
				if (Arrays.binarySearch(indices.get(j), index[j]) < 0)
					return false;
			return true;
		}
		
		/**
		 * \brief Returns an Iterator, that iterates over all indices spanned by this Indices object.
		 */
		public Iterator<Index> iterator() {
			return new NCIIterator();
		}

		
		/**
		 * \brief Internal constructor to create a NonConsecutiveIndices object based on FArraySubcripts.
		 */
		protected NonConsecutiveIndices(FArraySubscripts fas) {
			super(fas.size());
			indices = new ArrayList<int[]>();
			for (FSubscript fs : fas.getFSubscripts()) {
				indices.add(fs.myIndices());
			}
		}
		
		/**
		 * \brief Internal constructor to create a NonConsecutiveIndices object based on a list of int arrays
		 */
		protected NonConsecutiveIndices(ArrayList<int[]> ind) {
			super(ind.size());
			indices = new ArrayList<int[]>();
			int i = 0;
			for (int[] ii : ind) {
				size[i] = ii.length;
				indices.add(ii.clone());
				i++;
			}
		}
		
		/**
		 * \brief Calculate the internal index in an Array that spans this Indices.
		 */
		protected int internal(Index i) {
			int[] index = i.index();
			int res = 0;
			for (int j = 0; j < ndims; j++)
				res = res * size[j] + Arrays.binarySearch(indices.get(j), index[j]) - 1;
			return res;
		}
		
		/**
		 * \brief Iterates over all indices spanned by this Indices.
		 */
		protected class NCIIterator extends IIterator {
			
			public Index next() {
				index.internal++;
				for (int i = index.internal, j = ndims - 1; j >= 0; i /= size[j], j--)
					index.index[j] = indices.get(j)[i % size[j]];
				return index;
			}
			
		}
		
	}
	
}
