/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.HashSet;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

aspect Arrays {

	/**
	 * \brief Get the array subscripts of a ComponentDecl.
	 * 
	 * @return If the ComponentDecl has subscripts, then return these, otherwise
	 * null.
	 */
	syn lazy ArraySubscripts ComponentDecl.arraySubscripts() =
		hasVarArraySubscripts()? getVarArraySubscripts():
			null;

	/**
	 * \brief Check if an identifier is inside array subscripts.
	 * 
	 * @return If the identifier is in an array subscripts sub-AST then true
	 * else false.
	 */
	inh boolean FIdUseExp.inArraySubscripts();
	eq FArraySubscripts.getChild().inArraySubscripts() = true;
	eq Root.getChild().inArraySubscripts() = false;
	
	/**
	 * \brief Check if an access is an array access.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean Access.isArrayAccess() = false;
	eq ArrayAccess.isArrayAccess() = hasArraySubscripts();
	
	/**
	 * \brief Get the array subscripts of an access, if any.
	 * 
	 * @return The array subscripts of the access, if any, otherwise null.
	 */
	syn ArraySubscripts Access.arraySubscripts() = null;
	eq ArrayAccess.arraySubscripts() = hasArraySubscripts()? getArraySubscripts(): null;

	/**
	 * \brief Check if an instance access has array subscripts.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean InstAccess.isInstArrayAccess() = false;
	eq InstArrayAccess.isInstArrayAccess() = hasFArraySubscripts();
	
	
	/**
	 * \brief Get the FArraySubscripts of an InstAccess, if any.
	 * 
	 * @return A reference to a FArraySubscripts object, or null.
	 */
	syn FArraySubscripts InstAccess.fArraySubscripts() = null;
	eq InstArrayAccess.fArraySubscripts() = hasFArraySubscripts()? getFArraySubscripts(): null;
	
	/**
	 * \brief Return an Index with these array subscripts.
	 * 
	 * @throws UnsupportedOperationException  if the subscripts can't be evaluated to 
	 *                                         constant Integer values.
	 */
	syn lazy Index FArraySubscripts.asIndex() {
		int[] i = new int[getNumFSubscript()];
		int j = 0;
		for (FSubscript s : getFSubscripts()) 
			i[j++] = s.ceval().intValue();
		return new Index(i);
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FAbstractEquation.ndims() = -1;
	eq FEquation.ndims() {
		if (getLeft().ndims() == getRight().ndims()) {
			return getLeft().ndims();
		}
		return -1;
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FArraySubscripts.ndims() { 
		return getNumFSubscript();
	}

	// Array dimensions
	/**
	 * \brief Get array dimensions of array subscripts when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FArraySubscripts.accessNdims() { 
		//System.out.println("FArraySubscripts.accessNdims()");
		// Need to check if each individual subscript increases 
		// dimension. (ndims(x[1])=0)
		int nd = 0;
		for (FSubscript fs : getFSubscripts()) {
			nd += fs.ndims();
		}
		return nd;
	}

	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FSubscript.ndims();
	eq FExpSubscript.ndims() = getFExp().ndims();
	eq FColonSubscript.ndims() = 1;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FExp.ndims() = 0;
	eq FInstAccessExp.ndims() = getInstAccess().ndims();
	eq FRangeExp.ndims() = 1;
	eq FArray.ndims() {
		if (isIterArray())
			return getFExp(0).ndims();
		if (getNumFExp()==0)  //Empty array
			return 1;
		// We assume that the FArray is set up correctly and that
		// all brances are equal.
		return getFExp(0).ndims() + 1;
	}
	eq FAbstractCat.ndims() {
		int ndims = 2;
		for (FExp e : getFExps())
			if (e.ndims() > ndims)
				ndims = e.ndims();
		return ndims;
	}
	eq FCatExp.ndims()         = getFExp(0).ndims();
	eq FSumExp.ndims()         = getFExp().isIterExp() ? iterExp().ndims() : 0;
	eq FIterExp.ndims()        = getFExp().ndims() + getNumForIndex();
	eq FSubscriptedExp.ndims() = getFArraySubscripts().accessNdims();
	
	eq FTranspose.ndims() = getFExp().ndims();
	eq FCross.ndims() = 1;
	eq FIdentity.ndims() = 2;
	
	eq FSizeExp.ndims() = hasDim() ? 0 : 1;
	
	eq FInfArgsFunctionCall.ndims() = getNumFExp();
	eq FFunctionCall.ndims()        = hasOutputs() ? expOutput().ndims() : -1;
	eq InstFunctionCall.ndims()     = hasOutputs() ? expOutput().ndims() : -1;
	
	eq FBinExp.ndims() = getLeft().ndims();
	eq FUnaryExp.ndims() = getFExp().ndims();
	eq FArtmBinExp.ndims() = Math.max(getLeft().ndims(), getRight().ndims());
	
	eq FDivExp.ndims() = getLeft().ndims();
	eq FPowExp.ndims() = getLeft().ndims();
	
	eq FMulExp.ndims() {
		int left = getLeft().ndims();
		int right = getRight().ndims();
		if (isElementWise())
			return Math.max(left, right);
		if (left > 2 || right > 2)
			return -1;
		return left + right - 2;
	}
	
	/**
	 * \brief Check if multiplication is equivalent with an element-wise multiplication.
	 * 
	 * True if any operand is scalar.
	 */
	syn boolean FMulExp.isElementWise() = (getLeft().ndims() * getRight().ndims() == 0);
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FIdUse.ndims() {
		// Notice here the use of accessNdims. Also, if the access has
		// no subscripts, it may still have dimension > 0 if its declaration
		// is an array declaration. 
		// If the FQName is marked as scalarized, then dimension must 
		// be 0 and using myFV() might cause a NullPointerException.
		// This is because if scalarization is in progress, 
		// then this node will be hanging without a proper AST.
		if (getFQName().isScalarized())
			return 0;
		if (getFQName().hasFArraySubscripts())
			return getFArraySubscripts().accessNdims();
		return myFV().ndims();
	}
	eq FIdUseExp.ndims() = getFIdUse().ndims();
		
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAccess.ndims() = 0;
	eq InstArrayAccess.ndims() {
		//.out.println("InstArrayAccess.ndims()");
		return hasFArraySubscripts()? 
			getFArraySubscripts().accessNdims(): 
				myInstComponentDecl().ndims();
	}
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstPrimitive.ndims() = hasFArraySubscripts() ? getFArraySubscripts().ndims() : 0;
	
	eq InstDot.ndims() = getRight().ndims() + getLeft().ndims();
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstNode.ndims() = 0;
	
	eq InstComponentDecl.ndims() = hasFArraySubscripts()? 
			getFArraySubscripts().ndims(): 0;

	syn int AbstractFVariable.ndims() = -1;
	
	eq FVariable.ndims()         = isScalarized()? 0 : getFQName().ndims();
	eq FFunctionArray.ndims()    = getFQName().ndims();
	eq FFunctionVariable.ndims() = 0;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FQName.ndims() {
		// Only look at the array subscripts for the last FQNamePart,
		// all other array subscripts has been expanded in the instantiation.
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().ndims(); 
		} else {
			return 0;
		}
	}

	/**
	 * \brief Get array dimensions of an identifier when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */		
	syn int FQName.accessNdims() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().accessNdims(); 
		} else {
			return 0;
		}
	}

	
	// Array sizes
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FAbstractEquation.size() = Size.SCALAR;
	eq FEquation.size() {
		Size left = getLeft().size();
		Size right = getRight().size();
		return left.equals(right) ? left : Size.SCALAR;
	}

	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FArraySubscripts.size() {
		if (ndims() == 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		for (FSubscript fs : getFSubscripts())
			fs.addDeclarationSize(s);
		return s;
	}
	
	/**
	 * \brief Add the size of the dimension denoted by this subscript when used 
	 *        in a declaration to the given Size.
	 */
	public abstract void FSubscript.addDeclarationSize(MutableSize s);
	
	public void FExpSubscript.addDeclarationSize(MutableSize s) {
		s.append(getFExp());
	}
	
	public void FColonSubscript.addDeclarationSize(MutableSize s) {
		s.append(Size.UNKNOWN);
	}

	/**
	 * \brief Get the array sizes when the array subscripts are used in an
	 * access. See also documentation of accessNdims(). 
	 */
	syn lazy Size FArraySubscripts.accessSize() {
		if (ndims() == 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(accessNdims());
		for (FSubscript fs : getFSubscripts()) 
			if (fs.ndims() == 1)
				s.append(fs.size());
		return s;
	}

	
	/**
	 * \brief Get the array sizes. 
	 */
	syn Size FSubscript.size();

	eq FExpSubscript.size() = getFExp().size();
	
	eq FColonSubscript.size() = mySize();
	
	/**
	 * \brief Get the size this subscript(s) would have if all subscripts were colons.
	 */
	inh lazy Size FSubscript.mySize();
	inh lazy Size FArraySubscripts.mySize();
	eq FIdUse.getChild().mySize()                     = myFV().size();
	eq InstArrayAccess.getFArraySubscripts().mySize() = myInstComponentDecl().size();
	eq FSubscriptedExp.getFArraySubscripts().mySize() = getFExp().size();
	eq FlatRoot.getChild().mySize()                   = Size.SCALAR;
	eq InstRoot.getChild().mySize()                   = Size.SCALAR;
	
	eq FArraySubscripts.getFSubscript(int i).mySize() {
		MutableSize s = new MutableSize(1);
		if (mySize().has(i))
			s.set(0, mySize(), i);
		else 
			s.set(0, Size.UNKNOWN);
		return s;
	}
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FExp.size() = Size.SCALAR;
	eq FInstAccessExp.size() = getInstAccess().size();
	
	eq FBinExp.size() = getLeft().size();
	eq FUnaryExp.size() = getFExp().size();
	eq FArtmBinExp.size() = getLeft().isArray() ? getLeft().size() : getRight().size();

	eq FDivExp.size() = getLeft().size();
	eq FPowExp.size() = getLeft().size();
	
	eq FMulExp.size() {
		if (!getLeft().isArray())
			return getRight().size();
		if (!getRight().isArray())
			return getLeft().size();
		MutableSize s = new MutableSize(ndims());
		if (getLeft().ndims() == 2)
			s.append(getLeft().size(), 0);
		if (getRight().ndims() == 2)
			s.append(getRight().size(), 1);
		return s;
	}
	
 	eq FRangeExp.size() {
 		boolean hasStep = getNumFExp() > 2;
 		FExp startExp = getFExp(0);
 		FExp stopExp = getFExp(hasStep ? 2 : 1);
 		FExp stepExp = hasStep ? getFExp(1) : null;
 		
 		try {
			double start = startExp.ceval().realValue();
			double step = hasStep ? stepExp.ceval().realValue() : 1.0;
			double stop = stopExp.ceval().realValue();
			int si = (int) ((stop - start) / step + 1.0);
			return new Size((si < 0) ? 0 : si);
 		} catch (UnsupportedOperationException e) {
 			// TODO: Create a MutableSize with an expression describing the size.
 			// Needs integer() operator.
 			throw e;
 		}
	}
	
	eq FArray.size() {
		if (isIterArray())
			return getFExp(0).size();
		return getFExp(0).size().expand(getNumFExp());
	}
	
	syn lazy int FAbstractCat.dimension();
	eq FCatExp.dimension()    = getDim().ceval().intValue() - 1;
	eq FMatrix.dimension()    = 0;
	eq FMatrixRow.dimension() = 1;
	
	syn lazy int FSizeExp.dimension() = getDim().ceval().intValue() - 1;
	
	eq FAbstractCat.size() {
		int dim = dimension();
		MutableSize ms = getFExp(0).size().promote(ndims()).mutableClone();
		for (int i = 1; i < getNumFExp(); i++)
			ms.add(dim, getFExp(i).size().promote(ndims()), dim);
		return ms;
	}
	
	eq FSumExp.size() = getFExp().isIterExp() ? iterExp().size() : Size.SCALAR;
	
	eq FIterExp.size() {
		MutableSize s = new MutableSize(ndims());
		for (CommonForIndex fi : getForIndexList())
			if (fi.hasFExp() && fi.getFExp().ndims() == 1)
				s.append(fi.getFExp().size());
		s.append(getFExp().size());
		return s;
	}
	
	eq FSubscriptedExp.size() = getFArraySubscripts().accessSize();
	
	eq FTranspose.size() {
		Size size = getFExp().size();
		MutableSize s = new MutableSize(size.ndims());
		s.append(size, 1);
		s.append(size, 0);
		for (int i = 2; i < s.ndims(); i++)
			s.append(size, i);
		return s;
	}
	
	eq FCross.size() = new Size(3);
	
	eq FIdentity.size() {
		MutableSize s = new MutableSize(2);
		s.append(getFExp());
		s.append(getFExp());
		return s;
	}
	
	eq FSizeExp.size() = hasDim() ? Size.SCALAR : new Size(getFExp().ndims());
	
	eq FInfArgsFunctionCall.size() {
		MutableSize s = new MutableSize(ndims());
		for (FExp fe : getFExps()) 
			s.append(fe);
		return s;
	}
	
	inh Size FFunctionCallLeft.size();
	eq FFunctionCallEquation.getLeft(int i).size() = getCall().sizeOfOutput(i);
	eq FFunctionCallStmt.getLeft(int i).size()     = getCall().sizeOfOutput(i);
	
	syn Size FAbstractFunctionCall.sizeOfOutput(int i) = (i == 0) ? size() : Size.SCALAR;
	
	syn lazy Size InstFunctionCall.sizeOfOutput(int i) {
		Size s = myOutputs().get(i).size();
		if (!s.isUnknown())
			return s;
		
		HashMap<ASTNode, FExp> varMap = new HashMap<ASTNode, FExp>();
		for (int j = 0; j < getNumArg(); j++)
			varMap.put(myInputs().get(j), getArg(j).getFExp());
		
		try {
			MutableSize ms = new MutableSize(ndims());
			for (int j = 0; j < s.ndims(); j++) 
				ms.append(dynamicFExp(s.createSizeFExp(j, (HashMap) varMap.clone())));
			return ms;
		} catch (UnsupportedOperationException e) {
			return s;
		}
	}
	
	syn Size FFunctionCall.sizeOfOutput(int i) = getSizes()[i];
	
	eq FFunctionCall.size()    = hasOutputs() ? sizeOfOutput(0) : Size.SCALAR;
	eq InstFunctionCall.size() = hasOutputs() ? sizeOfOutput(0) : Size.SCALAR;
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FIdUse.size() {
		return getFQName().hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): myFV().size();
	}
		
	eq FIdUseExp.size() = getFIdUse().size();
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size InstAccess.size() = Size.SCALAR;
	eq InstArrayAccess.size() = hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): 
				myInstComponentDecl().size();
			
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size InstPrimitive.size() {
		Size s = declaredSize();
		if (hasBindingFExp() && s.isUnknown() && (!isInput() || !inFunction()))
			s = s.createKnown(getBindingFExp());
		return s;
	}
	
	/**
	 * \brief Get the array sizes as declared. May be unknown. 
	 */
	syn Size InstPrimitive.declaredSize() = 
		hasFArraySubscripts() ? getFArraySubscripts().size() : Size.SCALAR;
	
	/**
	 * \brief Get the array sizes. 
	 */
	eq InstDot.size() {
		return getRight().size().expand(getLeft().size());
	}
	
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size InstNode.size() = Size.SCALAR;
	
	eq InstComponentDecl.size() = hasFArraySubscripts()? 
			getFArraySubscripts().size(): Size.SCALAR;

	/**
	 * \brief Get the array sizes. 
	 */	
	syn lazy Size AbstractFVariable.size() = Size.SCALAR;
	eq FVariable.size()      = isScalarized()? Size.SCALAR: getFQName().size();
	eq FFunctionArray.size() = getFQName().size();
		
	/**
	 * \brief Get the array sizes. 
	 */
	syn lazy Size FQName.size() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().size(); 
		} else {
			return Size.SCALAR;
		}
	}
	
	/**
	 * \brief Create a copy of this FExp with variable uses replaced with expressions 
	 *        to allow calculations of unknown sizes.
	 *        
	 * For non-FExp nodes, this simply makes a full copy.
	 *        
	 * @param varMap  a map of variables to replace and expressions to replace them with.
	 *                Also contains uses that have been replaced, to detect circularities.
	 */
	public FExp FExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
		FExp exp = (FExp) copy();
		for (int i = 0; i < getNumChild(); i++) 
			exp.setChild(getChild(i).createSizeFExp(varMap), i);
		return exp;
	}
	
	public FExp FIdUseExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getFIdUse().createSizeFExp(varMap);
	}
	
	public FExp FInstAccessExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getInstAccess().createSizeFExp(varMap);
	}
	
	public FExp FIdUseInstAccess.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getInstAccess().createSizeFExp(varMap);
	}
	
	public FExp InstAccess.createSizeFExp(Map<ASTNode, FExp> varMap) {
		if (varMap.containsKey(this))
			throw new UnsupportedOperationException();
		varMap.put(this, null);
		InstComponentDecl var = myInstComponentDecl();
		FExp exp = varMap.get(var);
		return (exp != null) ? exp : var.size().createDummyFExp(varMap);
	}
	
	public FExp FIdUse.createSizeFExp(Map<ASTNode, FExp> varMap) {
		if (varMap.containsKey(this))
			throw new UnsupportedOperationException();
		varMap.put(this, null);
		AbstractFVariable var = myFV();
		FExp exp = varMap.get(var);
		return (exp != null) ? exp : var.size().createDummyFExp(varMap);
	}
	
	public FExp FFunctionCall.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return size().createDummyFExp(varMap);
	}
	
	public FExp InstFunctionCall.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return size().createDummyFExp(varMap);
	}
	
	/**
	 * \brief Create a copy of this FExp with variable uses replaced with expressions 
	 *        to allow calculations of unknown sizes.
	 *        
	 * For non-FExp nodes, this simply makes a full copy.
	 *        
	 * @param varMap  a map of variables to replace and expressions to replace them with.
	 *                Also contains uses that have been replaced, to detect circularities.
	 */
	public ASTNode ASTNode.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return fullCopy();
	}
	
	public List List.createSizeFExp(Map<ASTNode, FExp> varMap) {
		List node = new List();
		for (ASTNode ch : this)
			node.add(ch.createSizeFExp(varMap));
		return node;
	}
	
	public Opt Opt.createSizeFExp(Map<ASTNode, FExp> varMap) {
		return getNumChild() == 0 ? new Opt() : new Opt(getChild(0).createSizeFExp(varMap));
	}
		
	/**
	 * \brief check if an expression is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FExp.isArray() = ndims()>0;
	
	/**
	 * \brief check if an access is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstAccess.isArray() = ndims()>0;

	/**
	 * \brief check if a variable is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean AbstractFVariable.isArray() = ndims()>0;
	
	/**
	 * \brief check if an instance node is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstNode.isArray() = ndims()>0;
	
	public abstract int[]  CommonForIndex.myIndices();
	public abstract String CommonForIndex.name();
	
	/**
	 * \brief Expand for all values of for indices given in <code>indices</code>.
	 * 
	 * This is used to get the set of values for array indices while error checking 
	 * and to expand summation reduction expressions.
	 * 
	 * Size of new Array will be (n + m), where n = indices.size() and m = ndims().  
	 */
	public Array Array.createExpanded(Iterable<? extends CommonForIndex> forIndices) {
		if (!forIndices.iterator().hasNext())
			return (Array) fullCopy();
		Indices newIndices = Indices.create(forIndices);
		Array arr = new Array(Indices.create(expandedSize(newIndices.size())));
		HashMap<String,FExp> indexMap = new HashMap<String,FExp>();
		for (Index i : newIndices) {
			int j = 0;
			int[] ii = newIndices.translate(i).index();
			for (CommonForIndex fi : forIndices) {
				indexMap.put(fi.name(), new FIntegerLitExp(ii[j]));
				j++;
			}
			fillSubset(arr, i, indexMap);
		}
		return arr;
	}
	
	protected Size Array.expandedSize(Size size) {
		return size().expand(size);
	}
	
	protected void Array.fillSubset(Array arr, Index i, HashMap<String,FExp> indexMap) {
		for (Index i2 : indices())
			arr.set(i.expand(i2), get(i2).scalarize(indexMap));
	}
	protected void ScalarAsArray.fillSubset(Array arr, Index i, HashMap<String,FExp> indexMap) {
		arr.set(i, get(i).scalarize(indexMap));
	}
	
	/**
	 * \brief Expand index for all values of each for index used in expression.
	 */
	syn lazy Array FExpSubscript.getExpanded() = getFExp().getArray().createExpanded(collectForIndices());
	
	/**
	 * \brief Collect all ForIndexs used in the expression of this FExpSubscript.
	 */
	coll HashSet<CommonForIndex> FExpSubscript.collectForIndices() 
		[new HashSet<CommonForIndex>()] with add root FExpSubscript;
	FIdUse contributes myForIndex() when isForIndex()
		to FExpSubscript.collectForIndices() for surroundingFExpSubscript();
	FInstAccessExp contributes myForIndex() when isForIndex()
		to FExpSubscript.collectForIndices() for surroundingFExpSubscript();
	
	/**
	 * \brief Return the FForIndex or InstForIndex that this variable belongs to, if any.
	 */
	syn CommonForIndex FIdUse.myForIndex()            = myFV().myForIndex();
	syn CommonForIndex FIdUseInstAccess.myForIndex()  = getInstAccess().myInstComponentDecl().myForIndex();
	syn CommonForIndex FInstAccessExp.myForIndex()    = getInstAccess().myInstComponentDecl().myForIndex();
	inh CommonForIndex AbstractFVariable.myForIndex();
	inh CommonForIndex InstComponentDecl.myForIndex();
	eq FForIndex.getFVariable().myForIndex()        = this;
	eq InstForIndex.getInstPrimitive().myForIndex() = this;
	eq FClass.getChild().myForIndex()               = null;
	eq FFunctionDecl.getChild().myForIndex()        = null;
	eq InstNode.getChild().myForIndex()             = null;
	
	/**
	 * \brief Find the closest ancestor that is an FExpSubscript, if any.
	 */
	inh FExpSubscript FIdUse.surroundingFExpSubscript();
	inh FExpSubscript FInstAccessExp.surroundingFExpSubscript();
	eq FExpSubscript.getChild().surroundingFExpSubscript() = this;
	eq Root.getChild().surroundingFExpSubscript()          = null;

	/**
	 * \brief Computes an Array where all elements are scalar expressions.
	 * 
	 * This is used mainly to scalarize array expressions.
	 * 
	 * @return An Array with scalar expressions if this is an array expression, 
	 *          a ScalarAsArray containing <code>this</code> otherwise.
	 */
	syn lazy Array FExp.getArray() = new ScalarAsArray(this);
	
	/**
	 * \brief Allows for more efficient execution of {@link getArray()} in some cases.
	 * 
	 * When the Array of a parent node is the same as a childs, replace 
	 * getArray() with {@link createArray()} for the types the child can have, 
	 * let getArray() for those types delegate to copyArray() and use copyArray() 
	 * on the child in getArray() for the parent.
	 * 
	 * This ensures that the Array is created only once and that only as many copies 
	 * as neccesary are made.
	 */
	syn Array FExp.copyArray() = (Array) createArray().unboundCopy();
	
	/**
	 * \brief Allows for more efficient execution of {@link getArray()} in some cases.
	 * 
	 * See {@link copyArray()} for instructions. 
	 * When overriding createArray(), always declare it as lazy.
	 */
	syn Array FExp.createArray() = getArray();
	
	eq FBinExp.getArray() {
		if (isArray()) {
			/* Standard implementation covers many binary operators.
			 * Apply operator element-wise, if one operand is scalar, use it with 
			 * all elements in other operand. Used for operators that does not 
			 * allow a scalar and an array as well, since that is caught by the 
			 * error check.
			 */
			Array left  = getLeft().getArray();
			Array right = getRight().getArray();
			Array res   = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode((FExp) left.get(i).fullCopy(), (FExp) right.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FUnaryExp.getArray() {
		if (isArray()) {
			Array src = getFExp().getArray();
			Array res = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode((FExp) src.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FMulExp.getArray() {
		if (isElementWise())
			return super.getArray();
		
		if (!isArray())
			return new ScalarAsArray(composeScalarCellExp(Index.NULL));
		
		Array res = new Array(indices());
		for (Index i : res.indices()) 
			res.set(i, composeScalarCellExp(i));
		return res;
	}
	
	protected FExp FMulExp.composeScalarCellExp(Index i) {
		return vectorMultiplication(getLeft().getArray().leftMulIterator(i), 
		                            getRight().getArray().rightMulIterator(i));
	}
	
	protected static FExp FExp.vectorMultiplication(Iterator<FExp> left, Iterator<FExp> right) {
		FExp cur = new FMulExp((FExp) left.next().fullCopy(), (FExp) right.next().fullCopy());
		while (left.hasNext()) 
			cur = new FAddExp(cur, new FMulExp((FExp) left.next().fullCopy(), (FExp) right.next().fullCopy()));
		return cur;
	}
	
	eq FPowExp.getArray() {
		if (!isArray())
			return new ScalarAsArray(this);
		
		int e = getRight().ceval().intValue();
		if (e <= 0)
			return new FIdentity(new FIntegerLitExp(size().get(0))).getArray();
		
		Array base = getLeft().getArray();
		Array res = base;
		for (; e > 1; e--) {
			Array cur = new Array(indices());
			for (Index i : cur.indices()) {
				Iterator<FExp> left = res.leftMulIterator(i);
				Iterator<FExp> right = base.rightMulIterator(i);
				cur.set(i, vectorMultiplication(left, right));
			}
			res = cur;
		}
		return res;
	}
	
	eq FTranspose.getArray() {
		Array inner = getFExp().getArray();
		Array res = new Array(indices());
		int[] ind = new int[ndims()];
		Index ti = new Index(ind);
		for (Index i : res.indices()) {
			ind[0] = i.get(1);
			ind[1] = i.get(0);
			for (int j = 2; j < ind.length; j++)
				ind[j] = i.get(j);
			res.set(i, inner.get(ti));
		}
		return res;
	}
	
	eq FCross.getArray() {
		Array res = new Array(indices());
		Array x = getX().getArray();
		Array y = getY().getArray();
		Index j = new Index(new int[1]);
		Index k = new Index(new int[1]);
		for (Index i : res.indices()) {
			j.set(0, i.first() % 3 + 1);
			k.set(0, j.first() % 3 + 1);
			FExp m1 = new FMulExp((FExp) x.get(j).fullCopy(), (FExp) y.get(k).fullCopy());
			FExp m2 = new FMulExp((FExp) x.get(k).fullCopy(), (FExp) y.get(j).fullCopy());
			res.set(i, new FSubExp(m1, m2));
		}
		return res;
	}
	
	eq FIdentity.getArray() {
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, new FIntegerLitExp((i.get(0) == i.get(1)) ? 1 : 0));
		return arr;
	}
	
	eq FSizeExp.getArray() {
		if (hasDim()) 
			return super.getArray();
		
		Array arr = new Array(indices());
		Size size = getFExp().size();
		for (Index i : arr.indices())
			arr.set(i, size.createFExp(i.first() - 1));
		return arr;
	}
	
	eq FArray.getArray() {
		if (isIterArray())
			return getFExp(0).copyArray();
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			fillArray(arr, i, 0);
		return arr;
	}
	
	eq FAbstractCat.getArray() {
		Array arr = new Array(indices());
		int dim = dimension();
		int adj = 0;
		for (FExp exp : getFExps()) {
			Array expArr = exp.getArray();
			for (Index i : expArr.indices()) 
				arr.set(i.adjusted(dim, adj, ndims()), expArr.get(i));
			adj += (exp.ndims() > dim) ? exp.size().get(dim) : 1;
		}
		return arr;
	}
	
	eq FSumExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		FIterExp exp = (FIterExp) getFExp();
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, new FSumExp(exp.extract(i)));
		return arr;
	}
	
	public FExp FIterExp.extract(Index i) {
		FExp exp = (FExp) getFExp().getArray().get(i).fullCopy();
		List fil = (List) getForIndexList().fullCopy();
		return new FIterExp(exp, fil);
	}
	
	syn lazy Array FIterExp.createArray() = getFExp().getArray().createExpanded(getForIndexList());
	eq FIterExp.getArray() = copyArray();
	
	eq FSubscriptedExp.getArray() {
		Array arr = new Array(indices());
		Array old = getFExp().getArray();
		Indices ind = arr.indices();
		for (Index i : ind)
			arr.set(i, old.get(ind.translate(i)));
		return arr;
	}
	
	/**
	 * \brief Add a copy of this expression to arr at position i. 
	 */
	public void FExp.fillArray(Array arr, Index i, int level) {
		if (isArray())
			arr.set(i, (FExp) getArray().get(i.subIndex(level)).fullCopy());
		else
			arr.set(i, (FExp) fullCopy());
	}
	
	/**
	 * \brief Add a copy of the expression at position i to arr. 
	 * 
	 * @param arr    the Array to add the expression to.
	 * @param i      the index to add at, denotes position in both Array and FArray.
	 * @param level  the level this FArray is at in a structure of nestled FArrays.
	 */
	public void FArray.fillArray(Array arr, Index i, int level) {
		getFExp(i.get(level) - 1).fillArray(arr, i, level + 1);
	}
	
	eq FFunctionCall.getArray() {
		FClass fc = myFClass();
		if (!isArray() || fc == null)
			return super.getArray();
		
		boolean inFunc = inFunction();
		Array arr = new Array(indices());
		for (Index i : arr.indices()) {
			FQName n = new FQName(tempVarName());
			FArraySubscripts fas = inFunc ? i.newFArraySubscripts() : 
				FArraySubscripts.createLiteralSubscripts(fc.tempVarIndex());
			n.setLastFArraySubscripts(fas);
			arr.set(i, new FIdUseExp(new FIdUse(n)));
		}
		return arr;
	}
	
	eq FIdUseExp.getArray() {
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			boolean scalarize = !inFunction();
			Array array = new Array(indices());
			for (Index i : array.indices()) 
				array.set(i, createNode(getFIdUse().specify(i, scalarize)));
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}

	boolean InstAccess.scalarized = false;
	
	eq FInstAccessExp.getArray() {
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			boolean scalarize = !inFunction();
			Indices ind = indices();
			Array array = new Array(ind);
			for (Index i : ind) {
				FInstAccessExp exp = fullCopy();
				exp.getInstAccess().specify(ind.translate(i), scalarize);
				array.set(i, exp);
			}
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	/**
	 * \brief Returns a scalar FIdUseInstAccess, as specified by an index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the use should be marked as scalarized 
	 */
	public FIdUseInstAccess FIdUseInstAccess.specify(Index i, boolean scalarize) {
		FIdUseInstAccess res = fullCopy();
		res.getInstAccess().specify(indices().translate(i), scalarize);
		return res;
	}
	
	/**
	 * \brief Returns a scalar FIdUse, as specified by an index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the use should be marked as scalarized 
	 */
	public FIdUse FIdUse.specify(Index i, boolean scalarize) {
		FIdUse res = (FIdUse) fullCopy();
		res.getFQName().specify(indices().translate(i), scalarize);
		return res;
	}
	
	/**
	 * \brief Sets the last FArraySubscripts to the same as the Index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the FQName should be marked as scalarized 
	 */
	public void FQName.specify(Index i, boolean scalarize) {
		setLastFArraySubscripts(i.newFArraySubscripts());
		scalarized = scalarize;
	}
	
	/**
	 * \brief Sets the last FArraySubscripts to the same as the Index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the InstAccess should be marked as scalarized 
	 */
	public void InstAccess.specify(Index i, boolean scalarize) {
		setLastFArraySubscripts(i.newFArraySubscripts());
		scalarized = scalarize;
	}

	eq FRangeExp.getArray() {
		//System.out.println("FRangeExp.getArray(): size = " + size().get(0));	
		double i1 = getFExp(0).ceval().realValue();
		double i2 = 1.0;
		if (getNumFExp() > 2) 
			i2 = getFExp(1).ceval().realValue();
		Array array = new Array(indices());
		for (Index i : array.indices()) { 
			array.set(i, new FRealLitExp(i1));
			i1 += i2;
		}
		
		return array;
	}
	
	eq FZeros.getArray()   = new Array(indices()).fill(new FIntegerLitExp(0));
	eq FOnes.getArray()    = new Array(indices()).fill(new FIntegerLitExp(1));
	eq FFillExp.getArray() = new Array(indices()).fill(getFillExp());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FExp.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FArraySubscripts.indices() = Indices.create(this);
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FSubscript.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FExpSubscript.indices() = getFExp().indices();
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FIdUseExp.indices() = getFIdUse().indices();

	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FIdUse.indices() {
		return getFQName().hasFArraySubscripts()? 
				getFArraySubscripts().indices(): myFV().indices();
	}	

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FInstAccessExp.indices() = getInstAccess().indices();

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstAccess.indices() = myInstComponentDecl().indices();
	eq InstDot.indices()                  = getLastInstAccess().indices();
	eq InstArrayAccess.indices()          = 
		hasFArraySubscripts() ? getFArraySubscripts().indices() : myInstComponentDecl().indices();
		
	/**
	 * \brief Get the set of all array indices of an subscripted array expression. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FSubscriptedExp.indices() = getFArraySubscripts().indices();

	/**
	 * \brief Get the set of all array indices of an instance primitive component. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstPrimitive.indices() = Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an FVariable. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices AbstractFVariable.indices() = null;
	eq FVariable.indices()      = isScalarized() ? null : Indices.create(size());
	eq FFunctionArray.indices() = Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an InstComponentDecl. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstComponentDecl.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FEquation.indices() = getLeft().indices();
	
	/**
	 * \brief Get the set of all indices this array subscript spans.
	 * 
	 * @return an int array containing the indices spanned
	 */
	syn int[] FSubscript.myIndices();
	
	eq FColonSubscript.myIndices() {
		int n = size().get(0);
		int[] ind = new int[n];
		for (int i = 0; i < n; i++)
			ind[i] = i + 1;
		return ind;
	}
	
	eq FExpSubscript.myIndices() = getFExp().myIndices();
	
	syn int[] FExp.myIndices() {
		if (ndims() == 0) {
			return new int[] { ceval().intValue() };
		} else if (ndims() == 1) {
			int[] indices = new int[size().get(0)];
			int j = 0;
			for (FExp exp : getArray().getFExps()) 
				indices[j++] = exp.ceval().intValue();
			return indices;
		} else {
			return new int[0];
		}
	}
	
	/**
	 * \brief Get the set of all values this for index spans.
	 * 
	 * @return an int array containing the values spanned
	 */
	syn int[] FForIndex.myIndices() {
		if (hasFExp())
			return getFExp().myIndices();
		else
			return new int[0]; // TODO: return 1..n, where n is given by use.
	}
	
	/**
	 * \brief Get the set of all values this for index spans.
	 * 
	 * @return an int array containing the values spanned
	 */
	syn int[] InstForIndex.myIndices() {
		if (hasFExp())
			return getFExp().myIndices();
		else
			return new int[0]; // TODO: return 1..n, where n is given by use.
	}

}

aspect ArrayIndices {
	
	/**
	 * \brief An array size. Can be multi-dimensional.
	 */
	public class Size {
		
		/**
		 * \brief Used for unknown lengths.
		 */
		public static final int UNKNOWN = -1;
		
		/**
		 * \brief Used to represent the size of scalar expressions.
		 */
		public static final Size SCALAR = new Size(new int[0]);
		
		protected int[] size;
		
		/**
		 * \brief Constructs a Size with the given lengths.
		 */
		public Size(int[] size) {
			this.size = size;
		}
		
		/**
		 * \brief Convenience constructor to create a on-dimensional size with the given length.
		 */
		public Size(int s) {
			size = new int[] { s };
		}
		
		/**
		 * \brief Get the number of dimensions.
		 */
		public int ndims() {
			return size.length;
		}
		
		/**
		 * \brief Get length in the <code>i</code>th dimension.
		 */
		public int get(int i) {
			return size[i];
		}
		
		/**
		 * \brief Get length in the last dimension.
		 */
		public int last() {
			return size[size.length - 1];
		}
		
		/**
		 * \brief Check if this size has an <code>i</code>th dimension.
		 */
		public boolean has(int i) {
			return size.length > i;
		}
		
		/**
		 * \brief Returns the number of elements spanned by this Size.
		 */
		public int numElements() {
			int res = 1;
			for (int i = 0; i < size.length && res > 0; i++)
				res *= size[i];
			return res < 0 ? 0 : res;
		}
		
		/**
		 * \brief Create a new flattened FArraySubscripts object describing this size.
		 */
		public FArraySubscripts flattenFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < size.length; i++)
				fas.addFSubscript(flattenFSubscript(i));
			return fas;
		}
		
		/**
		 * \brief Create a new flattened FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript flattenFSubscript(int i) {
			return size[i] == UNKNOWN ? new FColonSubscript() : new FExpSubscript(size[i]);
		}
		
		/**
		 * \brief Check if any lengths are unknown.
		 */
		public boolean isUnknown() {
			for (int s : size)
				if (s == UNKNOWN)
					return true;
			return false;
		}
		
		/**
		 * \brief Check if all lengths have a value (fix length or integer).
		 */
		public boolean isComplete() {
			for (int i = 0; i < size.length; i++)
				if (!hasValue(i))
					return false;
			return true;
		}
		
		/**
		 * \brief Check if the lengths in the given dimension has a value (fix length or integer).
		 */
		protected boolean hasValue(int dim) {
			return size[dim] != UNKNOWN;
		}
		
		/**
		 * \brief Create a copy of this size.
		 */
		protected Size clone() {
			return new Size(size.clone());
		}
		
		/**
		 * \brief Create a copy of this size as a MutableSize.
		 */
		public MutableSize mutableClone() {
			MutableSize ms = new MutableSize(size.length);
			System.arraycopy(size, 0, ms.size, 0, size.length);
			return ms;
		}
		
		/**
		 * \brief Create a copy of this with <code>dim</code> dimensions, if necessary 
		 *        adding dimensions of length 1 to the right side.
		 */
		public Size promote(int dim) {
			if (dim <= size.length) 
				return this;
			Size ns = new Size(Arrays.copyOf(size, dim));
			Arrays.fill(ns.size, size.length, dim, 1);
			return ns;
		}
		
		/**
		 * \brief Return a Size that have the same lengths as this size where they are known, 
		 *        and any that are unknown copied from the size of <code>exp</code>. 
		 * 
		 * If the size of <code>exp</code> have more dimensions, the last part is assumed to match this size.
		 */
		public Size createKnown(FExp exp) {
			Size known;
			if (!exp.size().isUnknown() || this instanceof MutableSize) { 
				known = clone();
			} else {
				known = new MutableSize(size.length);
				System.arraycopy(size, 0, known.size, 0, size.length);
			}
			known.fillUnknownFrom(exp);
			return known;
		}
		
		/**
		 * \brief For each unknown length, copy the equivalent length from size of <code>exp</code>. 
		 * 
		 * If the size of <code>exp</code> have more dimensions, the last part is assumed to match this size.
		 */
		protected void fillUnknownFrom(FExp exp) {
			Size other = exp.size();
			if (other.size.length >= size.length)
				for (int i = 0, j = other.size.length - size.length; i < size.length; i++, j++) 
					if (size[i] == UNKNOWN)
						copyFrom(i, exp, i);
		}
		
		/**
		 * \brief Copy value of dimension <code>d2</code> in <code>other</code> to dimension 
		 *        <code>d1</code> in <code>this</code>.
		 */
		protected void copyFrom(int d1, FExp exp, int d2) {
			size[d1] = exp.size().size[d2];
		}
		
		/**
		 * \brief Check if another object is equal to this one.
		 */
		public boolean equals(Object s) {
			return s instanceof Size && equivalent((Size) s, false);
		}
		
		/**
		 * \brief Check if another size is equivalent to this one.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length, 
		 *                      otherwise consider unknown lengths to differ from all lengths, including
		 *                      other unknown lengths
		 */
		public boolean equivalent(Size s, boolean allowUnknown) {
			return equivalentExcept(s, allowUnknown, -1);
		}
		
		/**
		 * \brief Check if another size is equivalent to this one, except in a given dimension.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length, 
		 *                      otherwise consider unknown lengths to differ from all lengths, including
		 *                      other unknown lengths
		 * @param dim			dimension not to check
		 */
		public boolean equivalentExcept(Size s, boolean allowUnknown, int dim) {
			if (size.length != s.size.length)
				return false;
			for (int i = 0; i < size.length; i++) {
				if (i != dim) {
					boolean unknown = size[i] == UNKNOWN || s.size[i] == UNKNOWN;
					boolean differ = size[i] != s.size[i];
					if (allowUnknown ? (differ && !unknown) : (differ || unknown)) 
						return false;
				}
			}
			return true;
		}
		
		private static final String SEP = ", ";
		
		/**
		 * \brief Returns a string representation on the form "[l1, l2, l3]".
		 */
		public String toString() {
			StringBuilder buf = new StringBuilder("[");
			String prefix = "";
			for (int i = 0; i < size.length; i++) {
				buf.append(prefix);
				buf.append(toString(i));
				prefix = SEP;
			}
			buf.append("]");
			return buf.toString();
		}
		
		/**
		 * \brief Returns a string representation of a single length.
		 */
		protected String toString(int i) {
			return (size[i] == UNKNOWN) ? ":" : Integer.toString(size[i]);
		}
		
		/**
		 * \brief Returns a string representation on the form "l1, l2, l3".
		 */
		public String toUnclosedString() {
			String tmp = toString();
			return tmp.substring(1, tmp.length() - 1);
		}
		
		/**
		 * \brief Creates a new Size that is a copy of this one, but with one more dimension.
		 * 
		 * @param s  the length of the new dimension
		 */
		public Size expand(int s) {
			int[] ns = new int[size.length + 1];
			ns[0] = s;
			System.arraycopy(size, 0, ns, 1, size.length);
			return new Size(ns);
		}
		
		/**
		 * \brief Creates a new Size that is a concatenation of <code>s</code> and this size.
		 */
		public Size expand(Size s) {
			int[] ns = new int[size.length + s.size.length];
			System.arraycopy(s.size, 0, ns, 0, s.size.length);
			System.arraycopy(size, 0, ns, s.size.length, size.length);
			return new Size(ns);
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>, 
		 *        given the supplied variable values.
		 *        
		 * @param varMap  a map of variables to replace and expressions to replace them with
		 */
		public FExp createSizeFExp(int d, Map<ASTNode, FExp> varMap) {
			return createFExp(d);
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>.
		 * 
		 * the resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp(int d) {
			return new FIntegerLitExp(size[d]);
		}
		
		/**
		 * \brief Ceate a dummy expression that has the size described by this Size.
		 */
		public FExp createDummyFExp(Map<ASTNode, FExp> varMap) {
			FZeros z = new FZeros();
			for (int i = 0; i < size.length; i++)
				z.addFExp(createSizeFExp(i, varMap));
			return z;
		}
		
	}
	
	/**
	 * A mutable Size that can handle FExp sizes, possibly with unknown ceval().
	 */
	public class MutableSize extends Size {
		
		private int i;
		private FExp[] exps;
		
		/**
		 * \brief Constructs a new mutable Size of <code>ndims</code> dimensions.
		 */
		public MutableSize(int ndims) {
			super(new int[ndims]);
			Arrays.fill(size, UNKNOWN);
			exps = new FExp[ndims];
			i = 0;
		}
		
		/**
		 * \brief Sets the next length to <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(int s) {
			set(i++, s);
		}
		
		/**
		 * \brief Sets the next length to the value of <code>e</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(FExp e) {
			set(i++, e);
		}
		
		/**
		 * \brief Sets the next length to the length of dimension <code>d</code> 
		 *        of <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(Size s, int d) {
			set(i++, s, d);
		}
		
		/**
		 * \brief Sets the next <code>s.ndims()</code> lengths from <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(Size s) {
			if (s instanceof MutableSize) {
				MutableSize ms = (MutableSize) s;
				for (int j = 0; j < ms.size.length; j++, i++) {
					exps[i] = ms.exps[j];
					size[i] = ms.size[j];
				}
			} else {
				for (int si : s.size) {
					exps[i] = null;
					size[i++] = si;
				}
			}
		}
		
		/**
		 * \brief Sets length <code>i</code> to <code>s</code>.
		 */
		public void set(int i, int s) {
			size[i] = s;
			exps[i] = null;
		}
		
		/**
		 * \brief Sets length <code>d</code> to the value of <code>e</code>.
		 */
		public void set(int d, FExp e) {
			try {
				size[d] = e.ceval().intValue();
				exps[d] = null;
			} catch (UnsupportedOperationException uoe) {
				size[d] = UNKNOWN;
				exps[d] = e;
			}
		}
		
		/**
		 * \brief Sets length <code>d1</code> to the length of dimension <code>d2</code> 
		 *        of <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void set(int d1, Size s, int d2) {
			size[d1] = s.size[d2];
			exps[d1] = (s instanceof MutableSize) ? ((MutableSize) s).exps[d2] : null;
		}
		
		/**
		 * \brief Adds <code>s</code> to length <code>d</code>.
		 */
		public void add(int d, int s) {
			if (s == UNKNOWN) {
				size[d] = UNKNOWN;
				exps[d] = null;
			} else if (size[d] != UNKNOWN) {
				size[d] += s;
			} else if (exps[d] != null) {
				exps[d] = new FAddExp((FExp) exps[d].unboundCopy(), new FIntegerLitExp(s));
			}
		}
		
		/**
		 * \brief Adds the value of <code>e</code> to length <code>d</code>.
		 */
		public void add(int d, FExp e) {
			try {
				add(d, e.ceval().intValue());
			} catch (UnsupportedOperationException uoe) {
				exps[d] = new FAddExp(createFExp(d), e);
				size[d] = UNKNOWN;
			}
		}
		
		/**
		 * \brief Adds the length of dimension <code>d2</code> of <code>s</code> 
		 *        to length <code>d1</code> of this size.
		 */
		public void add(int d1, Size s, int d2) {
			FExp e = (s instanceof MutableSize) ? ((MutableSize) s).exps[d2] : null;
			if (e != null) 
				add(d1, e);
			else
				add(d1, s.size[d2]);
		}
		
		/**
		 * \brief Check if the lengths in the given dimension has a value (fix length or integer).
		 */
		protected boolean hasValue(int dim) {
			return size[dim] != UNKNOWN || exps[dim] != null;
		}
		
		/**
		 * \brief Copy value of dimension <code>d2</code> in <code>other</code> to dimension 
		 *        <code>d1</code> in <code>this</code>.
		 */
		protected void copyFrom(int d1, FExp exp, int d2) {
			set(d1, exp.size(), d2);
			if (size[d1] == UNKNOWN && exps[d1] == null) {
				FExp copyExp = (FExp) exp.fullCopy();
				Opt dimExp = new Opt(new FIntegerLitExp(d2 + 1));
				FSizeExp sizeExp  = new FSizeExp(copyExp, dimExp);
				exps[d1] = exp.dynamicFExp(sizeExp);
			}
		}
		
		/**
		 * \brief Creates a new Size that is a copy of this one, but with one more dimension.
		 * 
		 * @param s  the length of the new dimension
		 */
		public Size expand(int s) {
			MutableSize ns = new MutableSize(size.length + 1);
			ns.size[0] = s;
			ns.exps[0] = null;
			System.arraycopy(size, 0, ns.size, 1, size.length);
			System.arraycopy(exps, 0, ns.exps, 1, size.length);
			return ns;
		}
		
		/**
		 * \brief Creates a new Size that is a concatenation of <code>s</code> and this size.
		 */
		public Size expand(Size s) {
			MutableSize ns = new MutableSize(size.length + s.size.length);
			System.arraycopy(s.size, 0, ns.size, 0, s.size.length);
			System.arraycopy(size, 0, ns.size, s.size.length, size.length);
			if (s instanceof MutableSize) 
				System.arraycopy(((MutableSize) s).exps, 0, ns.exps, 0, s.size.length);
			System.arraycopy(exps, 0, ns.exps, s.size.length, size.length);
			return ns;
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>, 
		 *        given the supplied variable values.
		 *        
		 * @param varMap  a map of variables to replace and expressions to replace them with
		 */
		public FExp createSizeFExp(int d, Map<ASTNode, FExp> varMap) {
			return (exps[d] == null) ? 
					super.createSizeFExp(d, varMap) : 
					exps[d].createSizeFExp(varMap);
		}
		
		/**
		 * \brief Create an FExp that describes the length of dimension <code>d</code>.
		 * 
		 * the resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp(int d) {
			return (exps[d] == null) ? 
					super.createFExp(d) : 
					(FExp) exps[d].unboundCopy();
		}
		
		/**
		 * \brief For each unknown length, copy the equivalent length from <code>other</code>. 
		 * 
		 * If <code>other</code> have more dimensions, the last part is assumed to match this size.
		 */
		public void makeKnown(FExp exp) {
			fillUnknownFrom(exp);
		}
		
		/**
		 * \brief Create a new flattened FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript flattenFSubscript(int i) {
			return exps[i] == null ? super.flattenFSubscript(i) : 
				new FExpSubscript(exps[i].flatten(new FQName()));
		}
		
		/**
		 * \brief Returns a string representation of a single length.
		 */
		protected String toString(int i) {
			return exps[i] == null ? super.toString(i) : exps[i].prettyPrint("");
		}
		
		/**
		 * \brief Create a copy of this size.
		 */
		protected MutableSize clone() {
			MutableSize ms = new MutableSize(size.length);
			System.arraycopy(size, 0, ms.size, 0, size.length);
			System.arraycopy(exps, 0, ms.exps, 0, exps.length);
			return ms;
		}
		
		/**
		 * \brief Create a copy of this size as a MutableSize.
		 */
		public MutableSize mutableClone() {
			return clone();
		}
		
		/**
		 * \brief Create a copy of this with <code>dim</code> dimensions, if necessary 
		 *        adding dimensions of length 1 to the right side.
		 */
		public MutableSize promote(int dim) {
			if (dim <= size.length) 
				return this;
			MutableSize ns = new MutableSize(dim);
			System.arraycopy(size, 0, ns.size, 0, size.length);
			System.arraycopy(exps, 0, ns.exps, 0, exps.length);
			Arrays.fill(ns.size, size.length, dim, 1);
			return ns;
		}
		
	}
	
	public class Array {
		
		protected Indices indices;
		protected int length;
		
		/**
		 * \brief Create an Array spanning a given Indices.
		 */
		public Array(Indices indices) {
			this.indices = indices;
			setChild(new List<FExp>(), 0);
			length = indices.numElements();
			if (length > 0)
				setFExp(null, length - 1);
		}
		
		/**
		 * \brief Creates an iterator that iterates over all FExp nodes in this Array.
		 */
		public Iterator<FExp> iteratorFExp() {
			return getFExps().iterator();
		}
		
		/**
		 * \brief Returns an Iterable<FExp> containing all expressions in Array.
		 */
		public Iterable<FExp> iterable() {
			return getFExps();
		}
		
		/**
		 * \brief Creates a left-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * left side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the row 
		 * specified by i is returned.
		 */
		public Iterator<FExp> leftMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return new AIterator(i.first(), size().get(1));
		}
		
		/**
		 * \brief Creates a right-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * right side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the column 
		 * specified by i is returned.
		 */
		public Iterator<FExp> rightMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return new AIterator(i.last(), size().get(1), size().get(0));
		}
		
		/**
		 * \brief Returns the element referenced by <code>i</code> in this Array.
		 */
		public FExp get(Index i) {
			return getFExp(i.internal(indices));
		}
		
		/**
		 * \brief Sets the element referenced by <code>i</code> in this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp((FExp) exp.unboundCopy(), i.internal(indices));
		}
		
		/**
		 * \brief Returns the Indices associated with this Array.
		 */
		public Indices indices() {
			return indices;
		}
		
		/**
		 * \brief Set all expressions in Array to copies of <code>exp</code>.
		 * 
		 * @return <code>this</code> 
		 */
		public Array fill(FExp exp) {
			for (int i = 0; i < length; i++)
				setFExp((FExp) exp.fullCopy(), i);
			return this;
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Array.
		 */
		public int ndims() {
			return indices.ndims();
		}
		
		/**
		 * \brief Returns the size of this Array in each dimension.
		 */
		public Size size() {
			return indices.size();
		}
		
	    /**
	     * \brief Recursive method for building an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *  
	     * @param it       the iterator returned by a call to {@link #iteratorFExp()}
	     * @param builder  helper object that processes each subexpression
	     * @param dim      the dimension to process, always use 1
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.HashMap<String,FExp>)
	     */
	    protected FExp buildFArray(Iterator<FExp> it, ElementBuilder builder, int dim) {
	    	FArray arr = new FArray(new List<FExp>());
	    	int n = size().get(dim - 1);
	    	if (dim < ndims()) {
	    		for (int i = 0; i < n; i++)
	    			arr.addFExp(buildFArray(it, builder, dim + 1));
	    	} else {
	    		for (int i = 0; i < n; i++) 
	    			arr.addFExp((FExp) builder.build(it.next()).unboundCopy());
	    	}
	    	return arr;
	    }
		
	    /**
	     * \brief Discribes the helper object for {@link #buildFArray(Iterator<FExp>,ElementBuilder,int)}. 
	     */
	    protected interface ElementBuilder {
	    	public FExp build(FExp e);
	    }
		
	    
		/**
		 * \brief Iterates over FExp nodes in this Array.
		 */
		private class AIterator implements Iterator<FExp> {
			
			private int i = 0;
			private int s;
			private int l;
			private int n;
			
			/**
			 * Create an iterator that iterates over all elements in the Array. 
			 */
			public AIterator() {
				s = 0;
				l = 1;
				n = length;
			}
			
			/**
			 * Create an iterator that iterates over a row. Assumes the Array is a matrix.
			 */
			public AIterator(int row, int width) {
				s = (row - 1) * width;
				l = 1;
				n = width;
			}
			
			/**
			 * Create an iterator that iterates over a column. Assumes the Array is a matrix.
			 */
			public AIterator(int col, int width, int height) {
				s = col - 1;
				l = width;
				n = height;
			}
			
			public boolean hasNext() {
				return i < n;
			}
			
			public FExp next() {
				if (i >= n)
					throw new NoSuchElementException();
				return getFExp(s + l * i++);
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
	}

	public class ScalarAsArray {

		/**
		 * \brief Constructs a ScalarAsArray containing <code>exp</code>.
		 */
		public ScalarAsArray(FExp exp) {
			this(exp, Indices.create(Size.SCALAR));
		}
		
		/**
		 * \brief Constructs a ScalarAsArray containing <code>exp</code>, 
		 *        pretending to have <code>ind</code> indices.
		 * 
		 * This makes indices().iterator() meaningful.
		 */
		public ScalarAsArray(FExp exp, Indices ind) {
			this(new List().add(exp.unboundCopy()));
			indices = ind;
			length = 1;
		}
		
	    /**
	     * \brief Recursive method for building an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *        
	     * This implementation only applies builder to the single expression of this 
	     * ScalarAsArray.
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.HashMap<String,FExp>)
	     */
	    protected FExp buildFArray(Iterator<FExp> it, ElementBuilder builder, int dim) {
	    	return (FExp) builder.build(it.next()).unboundCopy();
	    }
	    
		/**
		 * \brief Returns the single element wrapped by this Array. 
		 */
		public FExp get(Index i) {
			return getFExp(0);
		}
		
		/**
		 * \brief Sets the single element wrapped by this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp(exp, 0);
		}
		
	}

	
	/**
	 * \brief Represents the index/indices of a single cell in an (possibly 
	 *        multi-dimensional) array.
	 *        
	 * Index objects are reused to a high degree. Always use clone() when retaining 
	 * an Index object.
	 */
	public class Index implements Cloneable {
		
		public static final Index NULL = new Index(0);
		public static Index expanded = NULL;
		
		protected int[] index;
		
		/**
		 * \brief Construct an Index representing the indices given in <code>ind</code>.
		 */
		public Index(int[] ind) {
			index = ind;
		}
		
		/**
		 * \brief Returns the indices that specify this cell.
		 */
		public int[] index() {
			return index;
		}
		
		/**
		 * \brief Returns the number of dimensions of this Index.
		 */
		public int ndims() {
			return index.length;
		}
		
		/**
		 * \brief Returns the index for the first dimension.
		 */
		public int first() {
			return index.length > 0 ? index[0] : -1;
		}
		
		/**
		 * \brief Returns the index for the last dimension.
		 */
		public int last() {
			return index.length > 0 ? index[index.length - 1] : -1;
		}
		
		/**
		 * \brief Returns the index for the <code>i</code>th dimension (zero-based).
		 */
		public int get(int i) {
			return index[i];
		}
		
		/**
		 * \brief Sets the index for the <code>i</code>th dimension (zero-based).
		 */
		public void set(int i, int index) {
			this.index[i] = index;
		}
		
		/**
		 * \brief Creates a new Index that describes the last <code>ndims() - level</code>
		 *        dimensions of this Index.
		 * 
		 * @param level  the first index to copy. Must be between 0 and ndims(), inclusive.
		 */
		public Index subIndex(int level) {
			Index copy = new Index(index.length - level);
			System.arraycopy(index, level, copy.index, 0, copy.index.length);
			return copy;
		}
		
		/**
		 * \brief Creates a new Index that is a copy of this Index, but with <code>adj</code>
		 *        added to dimension <code>dim</code> and promoted to <code>ndims</code> 
		 *        dimensions by adding ones to the end.
		 * 
		 * The new Index will not be bound to any Indices object.
		 */
		public Index adjusted(int dim, int adj, int ndims) {
			Index copy = new Index(Arrays.copyOf(index, ndims));
			Arrays.fill(copy.index, index.length, ndims, 1);
			copy.index[dim] += adj;
			return copy;
		}
		
		/**
		 * \brief Create a new FArraySubscripts object describing this index.
		 */
		public FArraySubscripts newFArraySubscripts() {
			return FArraySubscripts.createLiteralSubscripts(index);
		}
		
		/**
		 * \brief Copies this Index. Always use clone() when saving an Index.
		 */
		public Index clone() {
			try {
				Index i = (Index) super.clone();
				i.index = index.clone();
				return i;
			} catch (CloneNotSupportedException e) {
				return null;
			}
		}
		
		/**
		 * \brief Return an Index that is the result of appending <code>i</code>
		 *        to this Index.
		 * 
		 * @param i  the Index to append.
		 */
		public Index expand(Index i) {
			if (index.length + i.index.length != expanded.index.length) 
				expanded = new Index(index.length + i.index.length);
			System.arraycopy(index, 0, expanded.index, 0, index.length);
			System.arraycopy(i.index, 0, expanded.index, index.length, i.index.length);
			return expanded;
		}
		
		/**
		 * \brief Return a string representation on the form "[i1, i2, i3]".
		 */
		public String toString() {
			return Arrays.toString(index);
		}
		
		/**
		 * \brief Return a string representation on the form "i1, i2, i3".
		 */
		public String toUnclosedString() {
			String tmp = toString();
			return tmp.substring(1, tmp.length() - 1);
		}
		
		
		/**
		 * \brief Return the internal index in an Array of the cell this Index refers to.
		 *        Only for use from Array.
		 * 
		 * @param indices  the indices to resolve the internal index with
		 */
		public int internal(Indices ind) {
			return ind.internal(this);
		}
		
		/**
		 * \brief Construct an empty Index.
		 */
		protected Index() {
		}
		
		/**
		 * \brief Construct an Index of ndims dimensions, 
		 *        pointing at the spot before the first cell.
		 */
		protected Index(int ndims) {
			index = new int[ndims];
			for (int i = ndims - 2; i >= 0; i--)
				index[i] = 1;
			if (ndims > 0)
				index[ndims - 1] = 0;
		}
		
	}
	
	/**
	 * \brief Indices represents the set of array indices in each dimension.
	 * 
	 * Only supports indices of the form (1..n1, 1..n2, ... , 1..nk). 
	 * See {@link NonConsecutiveIndices}. 
	 * 
	 * New Indices objects should be created with the create() methods. 
	 * The subclass used is selected automatically. 
	 * 
	 * The Indices class is typically used to iterate over all possible indices
	 * of an array access of declaration.
	 */
	public class Indices implements Iterable<Index> {
		protected int ndims;
		protected Size size;
		
		/**
		 * \brief A perfect hash for all Indices that have consecutive indicies, 
		 *        ndims <= 3 and size[i] <= 1023 for 0 <= i < ndims. -1 for other 
		 *        Indices.
		 */
		protected int hash;
		
		/**
		 * \brief Create an Indices object based on array sizes. 
		 */
		public static Indices create(Size size) {
			return new Indices(size);
		}
		
		/**
		 * \brief Create an Indices object based on FArraySubcripts.
		 */
		public static Indices create(FArraySubscripts fas) {
			return NonConsecutiveIndices.create(fas);
		}
		
		/**
		 * \brief Create an Indices object based on a list of int arrays.
		 */
		public static Indices create(ArrayList<int[]> ind) {
			return NonConsecutiveIndices.create(ind, true);
		}
		
		/**
		 * \brief Create an Indices object based on a list of CommonForIndexes.
		 */
		public static Indices create(Iterable<? extends CommonForIndex> forIndices) {
			ArrayList<int[]> ind = new ArrayList<int[]>();
			for (CommonForIndex fi : forIndices) 
				ind.add(fi.myIndices());
			return NonConsecutiveIndices.create(ind, false);
		}
		
		/**
		 * \brief Check that i is valid for this Indices object.
		 */
		public boolean isValid(Index i) {
			if (i.ndims() != ndims)
				return false;
			int[] index = i.index();
			for (int j = 0; j < ndims; j++)
				if (index[j] > size.get(j))
					return false;
			return true;
		}
		
		/**
		 * \brief Returns an Iterator, that iterates over all indices spanned by this Indices object.
		 */
		public Iterator<Index> iterator() {
			return new IIterator();
		}
		
		/**
		 * \brief Returns the number of elements spanned by this Indices object.
		 */
		public int numElements() {
			return size.numElements();
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Indices object.
		 */
		public int ndims() {
			return ndims;
		}
		
		/**
		 * \brief Returns the size of this Indices object in each dimension.
		 */
		public Size size() {
			return size;
		}
		
		/**
		 * \brief Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 * 
		 * Default implementation always returns <code>i</code>.
		 */
		public Index translate(Index i) {
			return i;
		}
				
		
		/**
		 * \brief Internal constructor to create an Indices object based on array sizes. 
		 */
		protected Indices(Size size) {
			ndims = size.ndims();
			this.size = size;
			hash = -1;
			if (ndims < 4) {
				int h = 0;
				for (int i = 0; i < ndims; i++) {
					if (size.get(i) > 1023) 
						return;
					h = (h << 10) & size.get(i);
				}
				hash = h;
			}
		}
				
		/**
		 * \brief Calculate the internal index in an Array that spans this Indices.
		 */
		protected int internal(Index i) {
			if (i.ndims() != ndims)
				throw new UnsupportedOperationException("Index dimensions does not match.");
			int[] index = i.index();
			int res = 0;
			for (int j = 0; j < ndims; j++)
				res = res * size.get(j) + index[j] - 1;
			return res;
		}
		
		/**
		 * \brief Iterates over all indices spanned by this Indices.
		 */
		protected class IIterator implements Iterator<Index> {
			
			protected IIndex index;
			protected int max;
			
			public IIterator() {
				index = new IIndex();
				max = numElements() - 1;
			}
			
			public boolean hasNext() {
				return index.internal < max;
			}
			
			public Index next() {
				if (index.internal >= max)
					throw new NoSuchElementException();
				index.internal++;
				if (ndims == 0)
					return index;
				int[] ind = index.index();
				int i;
				for (i = ndims - 1; i > 0 && ind[i] >= size.get(i); i--)
					ind[i] = 1;
				ind[i]++;
				return index;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
		/**
		 * \brief Internal implementation of Index.
		 */
		protected class IIndex extends Index {
			
			public int internal;
			
			/**
			 * \brief Construct an Index over the number of dimensions of the enclosing Indices, 
			 *        pointing at the spot before the first cell.
			 */
			public IIndex() {
				super(ndims);
				internal = -1;
			}
			
			/**
			 * \brief Return the internal index in an Array of the cell this Index refers to.
			 *        Only for use from Array.
			 * 
			 * @param indices  the indices to resolve the internal index with
			 */
			public int internal(Indices ind) {
				if (Indices.this == ind || (hash != -1 && hash == ind.hash)) 
					return internal;
				else
					return ind.internal(this);
			}
			
		}
		
	}

	/**
	 * \brief NonConsecutiveIndices describes a set of array indices that isn't 
	 *        limited to 1..n.
	 * 
	 * For example, consider the declaration Real x[4,4,4] and the access
	 * x[:,1,1:2:4]. The array indices for the declaration is then
	 * {1,2,3,4}, {1,2,3,4}, and {1,2,3,4} respectively for the three dimensions.
	 * For the access, we have {1,2,3,4}, {1} and {1,3} respectively. The access 
	 * will have size [4,2], and this class will handle the necessary translations 
	 * between indices.
	 */
	public class NonConsecutiveIndices extends Indices {
		// The indices are stored as a list of integer arrays.
		protected ArrayList<int[]> indices; 
		protected Index trans;
		protected boolean trim;
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on FArraySubcripts.
		 *        Use Indices.create(FArraySubscripts fas).
		 */
		public static NonConsecutiveIndices create(FArraySubscripts fas) {
			ArrayList<int[]> ind = new ArrayList<int[]>();
			for (FSubscript fs : fas.getFSubscripts()) 
				ind.add(fs.myIndices());
			return new NonConsecutiveIndices(ind, true);
		}
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on a list of int arrays
		 *        Use Indices.create(ArrayList<int[]> ind).
		 */
		public static NonConsecutiveIndices create(ArrayList<int[]> ind, boolean trim) {
			return new NonConsecutiveIndices(ind, trim);
		}
		
		/**
		 * \brief Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 */
		public Index translate(Index i) {
			int[] ii = i.index();
			int[] ti = trans.index();
			for (int ji = 0, jt = 0; ji < ndims; ji++, jt++) {
				while (indices.get(jt).length == 1 && trim) 
					jt++;
				ti[jt] = indices.get(jt)[ii[ji] - 1];
			}
			return trans;
		}

		
		/**
		 * \brief Internal constructor to create a NonConsecutiveIndices object based on a 
		 *        list of int arrays containing the used indexes on the underlying array.
		 */
		protected NonConsecutiveIndices(ArrayList<int[]> ind, boolean trim) {
			super(getSize(ind, trim));
			this.trim = trim;
			indices = ind;
			trans = new Index(ind.size());
			for (int i = 0; i < ind.size(); i++)
				trans.index()[i] = indices.get(i)[0];
		}
		
		/**
		 * \brief Calculate size for this indices from a list of int arrays containing the 
		 *        used indexes on the underlying array
		 */
		protected static Size getSize(ArrayList<int[]> ind, boolean trim) {
			int n = 0;
			for (int[] i : ind)
				if (i.length > 1 || !trim)
					n++;
			MutableSize size = new MutableSize(n);
			for (int[] i : ind)
				if (i.length > 1 || !trim)
					size.append(i.length);
			return size;
		}
		
	}
	
}
