/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

aspect Arrays {

	/**
	 * \brief Get the array subscripts of a ComponentDecl.
	 * 
	 * @return If the ComponentDecl has subscripts, then return these, otherwise
	 * null.
	 */
	syn lazy ArraySubscripts ComponentDecl.arraySubscripts() =
		hasVarArraySubscripts()? getVarArraySubscripts():
			null;

	/**
	 * \brief Check if an identifier is inside array subscripts.
	 * 
	 * @return If the identifier is in an array subscripts sub-AST then true
	 * else false.
	 */
	inh boolean FIdUseExp.inArraySubscripts();
	eq FArraySubscripts.getChild().inArraySubscripts() = true;
	eq Root.getChild().inArraySubscripts() = false;
	
	/**
	 * \brief Check if an access is an array access.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean Access.isArrayAccess() = false;
	eq ArrayAccess.isArrayAccess() = hasArraySubscripts();
	
	/**
	 * \brief Get the array subscripts of an access, if any.
	 * 
	 * @return The array subscripts of the access, if any, otherwise null.
	 */
	syn ArraySubscripts Access.arraySubscripts() = null;
	eq ArrayAccess.arraySubscripts() = hasArraySubscripts()? getArraySubscripts(): null;

	/**
	 * \brief Check if an instance access has array subscripts.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean InstAccess.isInstArrayAccess() = false;
	eq InstArrayAccess.isInstArrayAccess() = hasFArraySubscripts();
	
	
	/**
	 * \brief Get the FArraySubscripts of an InstAccess, if any.
	 * 
	 * @return A reference to a FArraySubscripts object, or null.
	 */
	syn FArraySubscripts InstAccess.fArraySubscripts() = null;
	eq InstArrayAccess.fArraySubscripts() = hasFArraySubscripts()? getFArraySubscripts(): null;
	
	/**
	 * \brief Return an Index with these array subscripts.
	 * 
	 * @throws UnsupportedOperationException  if the subscripts can't be evaluated to 
	 *                                         constant Integer values.
	 */
	syn lazy Index FArraySubscripts.asIndex() {
		int[] i = new int[getNumFSubscript()];
		int j = 0;
		for (FSubscript s : getFSubscripts()) 
			i[j++] = s.ceval().intValue();
		return new Index(i);
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FAbstractEquation.ndims() = -1;
	eq FEquation.ndims() {
		if (getLeft().ndims() == getRight().ndims()) {
			return getLeft().ndims();
		}
		return -1;
	}

	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FArraySubscripts.ndims() { 
		return getNumFSubscript();
	}

	// Array dimensions
	/**
	 * \brief Get array dimensions of array subscripts when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FArraySubscripts.accessNdims() { 
		//System.out.println("FArraySubscripts.accessNdims()");
		// Need to check if each individual subscript increases 
		// dimension. (ndims(x[1])=0)
		int nd = 0;
		for (FSubscript fs : getFSubscripts()) {
			nd += fs.ndims();
		}
		return nd;
	}

	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FSubscript.ndims();
	eq FExpSubscript.ndims() = getFExp().ndims();
	eq FColonSubscript.ndims() = 1;
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FExp.ndims() = 0;
	eq FInstAccessExp.ndims() = getInstAccess().ndims();
	eq FRangeExp.ndims() = 1;
	eq FArray.ndims() {
		if (getNumFExp()==0) { //Empty array
			return 1;
		} else { // We assume that the FArray is set up correctly and that
			     // all brances are equal.
			return getFExp(0).ndims() + 1;
		}
	}
	eq FSubscriptedExp.ndims() = getFArraySubscripts().accessNdims();
	eq FIdentity.ndims() = 2;
	eq FInfArgsFunctionCall.ndims() = getNumFExp();
	
	eq FBinExp.ndims() = getLeft().ndims();
	eq FArtmBinExp.ndims() = Math.max(getLeft().ndims(), getRight().ndims());
	
	eq FDivExp.ndims() = getLeft().ndims();
	eq FPowExp.ndims() = getLeft().ndims();
	
	eq FMulExp.ndims() {
		int left = getLeft().ndims();
		int right = getRight().ndims();
		if (isElementWise())
			return Math.max(left, right);
		if (left > 2 || right > 2)
			return -1;
		return left + right - 2;
	}
	
	/**
	 * \brief Check if multiplication is equivalent with an element-wise multiplication.
	 * 
	 * True if any operand is scalar.
	 */
	syn boolean FMulExp.isElementWise() = (getLeft().ndims() * getRight().ndims() == 0);
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FIdUse.ndims() {
		// Notice here the use of accessNdims. Also, if the access has
		// no subscripts, it may still have dimension > 0 if its declaration
		// is an array declaration. 
		// If the FQName is marked as scalarized, then dimension must 
		// be 0 and using myFV() might cause a NullPointerException.
		// This is because if scalarization is in progress, 
		// then this node will be hanging without a proper AST.
		if (getFQName().isScalarized())
			return 0;
		if (getFQName().hasFArraySubscripts())
			return getFArraySubscripts().accessNdims();
		return myFV().ndims();
	}
	eq FIdUseExp.ndims() = getFIdUse().ndims();
		
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAccess.ndims() = 0;
	eq InstArrayAccess.ndims() {
		//.out.println("InstArrayAccess.ndims()");
		return hasFArraySubscripts()? 
			getFArraySubscripts().accessNdims(): 
				myInstComponentDecl().ndims();
	}
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstPrimitive.ndims() = hasFArraySubscripts() ? getFArraySubscripts().ndims() : 0;
	
	eq InstDot.ndims() = getRight().ndims() + getLeft().ndims();
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstNode.ndims() = 0;
	
	eq InstComponentDecl.ndims() = hasFArraySubscripts()? 
			getFArraySubscripts().ndims(): 0;

	syn int AbstractFVariable.ndims() = -1;
	
	eq FVariable.ndims() = isScalarized()? 0 : getFQName().ndims();
	
	/**
	 * \brief Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FQName.ndims() {
		// Only look at the array subscripts for the last FQNamePart,
		// all other array subscripts has been expanded in the instantiation.
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().ndims(); 
		} else {
			return 0;
		}
	}

	/**
	 * \brief Get array dimensions of an identifier when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */		
	syn int FQName.accessNdims() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().accessNdims(); 
		} else {
			return 0;
		}
	}

	
	// Array sizes
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FAbstractEquation.size() = new int[0];
	eq FEquation.size() {
		int[] leftSize = getLeft().size();
		int[] rightSize = getRight().size();
		if (leftSize.length!=rightSize.length) {
			return new int[0];
		}
		for (int i=0;i<leftSize.length;i++) {
			if (leftSize[i]!=rightSize[i]) {
				return new int[0];
			}
		}
		return leftSize;
	}

	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FArraySubscripts.size() {
		int s[] = new int[ndims()];
		int index = 0;
		for (FSubscript fs : getFSubscripts()) {
			s[index++] = fs.ceval().intValue();
		}
		return s;
	}

	/**
	 * \brief Get the array sizes when the array subscripts are used in an
	 * access. See also documentation of accessNdims(). 
	 * 
	 * @return An array of integers of length accessNdims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FArraySubscripts.accessSize() {
		int s[] = new int[accessNdims()];
		int index = 0;
		for (FSubscript fs : getFSubscripts()) {
			if (fs.ndims() == 1) {
				s[index++] = fs.size()[0];
			}
		}
		return s;
	}

	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FSubscript.size();

	eq FExpSubscript.size() = getFExp().size();
	
	eq FColonSubscript.size() = mySize();
	
	/**
	 * \brief Get the size this subscript(s) would have if all subscripts were colons.
	 */
	inh int[] FColonSubscript.mySize();
	inh lazy int[] FArraySubscripts.mySize();
	eq FArraySubscripts.getFSubscript(int i).mySize() = new int[] { mySize()[i] };
	eq FIdUse.getChild().mySize()                     = myFV().size();
	eq InstArrayAccess.getFArraySubscripts().mySize() = myInstComponentDecl().size();
	eq FSubscriptedExp.getFArraySubscripts().mySize() = getFExp().size();
	eq FlatRoot.getChild().mySize()                   = new int[0];
	eq InstRoot.getChild().mySize()                   = new int[0];
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FExp.size() = new int[0];
	eq FInstAccessExp.size() = getInstAccess().size();
	
	eq FBinExp.size() = getLeft().size();
	eq FArtmBinExp.size() = getLeft().isArray() ? getLeft().size() : getRight().size();

	eq FDivExp.size() = getLeft().size();
	eq FPowExp.size() = getLeft().size();
	
	eq FMulExp.size() {
		if (!getLeft().isArray())
			return getRight().size();
		if (!getRight().isArray())
			return getLeft().size();
		int[] si = new int[ndims()];
		if (getLeft().ndims() == 2)
			si[0] = getLeft().size()[0];
		if (getRight().ndims() == 2)
			si[si.length - 1] = getRight().size()[1];
		return si;
	}
	
 	eq FRangeExp.size() {
		double start = getFExp(0).ceval().realValue();
		double step = 1.0;
		double stop = getFExp(1).ceval().realValue();
		if (getNumFExp() > 2) {
			step = stop;
			stop = getFExp(2).ceval().realValue();
		}
		int si = (int) ((stop - start) / step + 1.0);
		return new int[] { (si < 0) ? 0 : si };
	}
	
	eq FArray.size() {
		int s[] = new int[ndims()];
		if (getNumFExp()==0) {
		} else {
			int ss[] = getFExp(0).size();
			s[0] = getNumFExp();
			for (int i=1;i<ndims();i++) {
				s[i] = ss[i-1];
			}
		}
		return s;
	}
	
	eq FSubscriptedExp.size() = getFArraySubscripts().accessSize();
	
	eq FIdentity.size() {
		int s[] = new int[2];
		s[0] = getFExp().ceval().intValue();
		s[1] = s[0];
		return s;
	}
	
	eq FInfArgsFunctionCall.size() {
		try {
			int s[] = new int[ndims()];
			int index = 0;
			for (FExp fe : getFExps()) 
				s[index++] = fe.ceval().intValue();
			return s;
		} catch (UnsupportedOperationException e) {
			return new int[0];
		}
	}
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FIdUse.size() {
		return getFQName().hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): myFV().size();
	}
		
	eq FIdUseExp.size() = getFIdUse().size();
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] InstAccess.size() = new int[0];
	eq InstArrayAccess.size() = hasFArraySubscripts()? 
			getFArraySubscripts().accessSize(): 
				myInstComponentDecl().size();
			
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] InstPrimitive.size() = hasFArraySubscripts() ? 
			getFArraySubscripts().size() : new int[0];
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	eq InstDot.size() {
		int s[] = new int[ndims()];
		int sr[] = getRight().size();
		int sl[] = getLeft().size();
		for (int i=0;i<sl.length;i++) {
			s[i] = sl[i];
		}
		for (int i=0;i<sr.length;i++) {
			s[i+sl.length] = sr[i];
		}
		return s;
	}
	
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] InstNode.size() = new int[0];
	
	eq InstComponentDecl.size() = hasFArraySubscripts()? 
			getFArraySubscripts().size(): new int[0];

	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */	
	syn lazy int[] AbstractFVariable.size() = new int[0];
	eq FVariable.size() = isScalarized()? new int[0]: getFQName().size();
		
	/**
	 * \brief Get the array sizes. 
	 * 
	 * @return An array of integers of length ndims(). Each entry holds the
	 * corresponding array dimension size.
	 * 
	 */
	syn lazy int[] FQName.size() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().size(); 
		} else {
			return new int[0];
		}
	}
		
	/**
	 * \brief check if an expression is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FExp.isArray() = ndims()>0;

	/**
	 * \brief check if a variable is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FVariable.isArray() = ndims()>0;
	
	/**
	 * \brief check if an instance node is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstNode.isArray() = ndims()>0;
	
	/**
	 * \brief Set the array subscripts of the last name part.
	 */
	public void FQName.setLastFArraySubscripts(FArraySubscripts fas) {
		getFQNamePart(getNumFQNamePart()-1).setFArraySubscripts(fas);
	}
	
	/**
	 * \brief Set the array subscripts of the last name part.
	 */
	public void InstAccess.setLastFArraySubscripts(FArraySubscripts fas) {
		((InstArrayAccess) getLastInstAccess()).setFArraySubscripts(fas);
	}
	
	/**
	 * \brief Computes an Array where all elements are scalar expressions.
	 * 
	 * This is used mainly to scalarize array expressions.
	 * 
	 * @return An Array with scalar expressions if this is an array expression, 
	 *          <code>null</code> otherwise.
	 */
	syn lazy Array FExp.getArray() = new ScalarAsArray(this);
	
	eq FBinExp.getArray() {
		if (isArray()) {
			/* Standard implementation covers many binary operators.
			 * Apply operator element-wise, if one operand is scalar, use it with 
			 * all elements in other operand. Used for operators that does not 
			 * allow a scalar and an array as well, since that is caught by the 
			 * error check.
			 */
			Array left  = getLeft().getArray();
			Array right = getRight().getArray();
			Array res   = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode((FExp) left.get(i).fullCopy(), (FExp) right.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FMulExp.getArray() {
		if (isElementWise())
			return super.getArray();
		
		if (!isArray())
			return new ScalarAsArray(composeScalarCellExp(Index.NULL));
		
		Array res = new Array(indices());
		for (Index i : res.indices()) 
			res.set(i, composeScalarCellExp(i));
		return res;
	}
	
	protected FExp FMulExp.composeScalarCellExp(Index i) {
		return vectorMultiplication(getLeft().getArray().leftMulIterator(i), 
		                            getRight().getArray().rightMulIterator(i));
	}
	
	protected static FExp FExp.vectorMultiplication(Iterator<FExp> left, Iterator<FExp> right) {
		FExp cur = new FMulExp((FExp) left.next().fullCopy(), (FExp) right.next().fullCopy());
		while (left.hasNext()) 
			cur = new FAddExp(cur, new FMulExp((FExp) left.next().fullCopy(), (FExp) right.next().fullCopy()));
		return cur;
	}
	
	eq FPowExp.getArray() {
		if (!isArray())
			return new ScalarAsArray(this);
		
		int e = getRight().ceval().intValue();
		if (e <= 0)
			return new FIdentity(new FIntegerLitExp(size()[0])).getArray();
		
		Array base = getLeft().getArray();
		Array res = base;
		for (; e > 1; e--) {
			Array cur = new Array(indices());
			for (Index i : cur.indices()) {
				Iterator<FExp> left = res.leftMulIterator(i);
				Iterator<FExp> right = base.rightMulIterator(i);
				cur.set(i, vectorMultiplication(left, right));
			}
			res = cur;
		}
		return res;
	}
	
	eq FIdentity.getArray() {
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, new FIntegerLitExp((i.index()[0] == i.index()[1]) ? 1 : 0));
		return arr;
	}
	
	eq FArray.getArray() {
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			fillArray(arr, i, 0);
		return arr;
	}
	
	eq FSubscriptedExp.getArray() {
		Array arr = new Array(indices());
		Array old = getFExp().getArray();
		Indices ind = arr.indices();
		for (Index i : ind)
			arr.set(i, old.get(ind.translate(i)));
		return arr;
	}
	
	/**
	 * \brief Add a copy of this expression to arr at position i. 
	 */
	public void FExp.fillArray(Array arr, Index i, int level) {
		arr.set(i, (FExp) fullCopy());
	}
	
	/**
	 * \brief Add a copy of the expression at position i to arr. 
	 * 
	 * @param arr    the Array to add the expression to.
	 * @param i      the index to add at, denotes position in both Array and FArray.
	 * @param level  the level this FArray is at in a structure of nestled FArrays.
	 */
	public void FArray.fillArray(Array arr, Index i, int level) {
		getFExp(i.index()[level] - 1).fillArray(arr, i, level + 1);
	}
	
	eq FIdUseExp.getArray() {
		System.out.println("FIdUseExp.getArray() begin: " + isArray());
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			System.out.println("FIdUseExp.getArray(): " + size().length);
			
			Array array = new Array(indices());
			Indices ind = array.indices();
			for (Index i : ind) {
				FIdUseExp fid_tmp = (FIdUseExp) fullCopy();
				FQName fqn = fid_tmp.getFIdUse().getFQName();
				fqn.setLastFArraySubscripts(ind.translate(i).newFArraySubscripts());
				fqn.scalarized = true;
				array.set(i, fid_tmp);
			}
			return array;
			
		} else {
			return new ScalarAsArray(this);
		}
	}

	boolean InstAccess.scalarized = false;
	
	eq FInstAccessExp.getArray() {
		//System.out.println("FInstAccessExp.getArray() begin: " + isArray());
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			//System.out.println("FInstAccessExp.getArray(): " + size().length);
			Array array = new Array(indices());
			Indices ind = array.indices();
			for (Index i : ind) {
				FInstAccessExp ia_tmp = (FInstAccessExp)this.fullCopy();
				InstAccess ia = ia_tmp.getInstAccess();
				ia.setLastFArraySubscripts(ind.translate(i).newFArraySubscripts());
				ia.scalarized = true;
				array.set(i, ia_tmp);
			}
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}

	eq FRangeExp.getArray() {
		//System.out.println("FRangeExp.getArray(): size = " + size()[0]);	
		double i1 = getFExp(0).ceval().realValue();
		double i2 = 1.0;
		if (getNumFExp() > 2) 
			i2 = getFExp(1).ceval().realValue();
		Array array = new Array(indices());
		for (Index i : array.indices()) { 
			array.set(i, new FRealLitExp(i1));
			i1 += i2;
		}
		
		return array;
	}
	
	eq FZeros.getArray() = new Array(indices()).fill(new FIntegerLitExp(0));
	eq FOnes.getArray()  = new Array(indices()).fill(new FIntegerLitExp(1));
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FExp.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FArraySubscripts.indices() = Indices.create(this);
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FSubscript.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FExpSubscript.indices() = getFExp().indices();
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FIdUseExp.indices() = getFIdUse().indices();

	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FIdUse.indices() {
		return getFQName().hasFArraySubscripts()? 
				getFArraySubscripts().indices(): myFV().indices();
	}	

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FInstAccessExp.indices() = getInstAccess().indices();

	/**
	 * \brief Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstAccess.indices() = myInstComponentDecl().indices();
	eq InstDot.indices()                  = getLastInstAccess().indices();
	eq InstArrayAccess.indices()          = 
		hasFArraySubscripts() ? getFArraySubscripts().indices() : myInstComponentDecl().indices();
		
	/**
	 * \brief Get the set of all array indices of an subscripted array expression. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FSubscriptedExp.indices() = getFArraySubscripts().indices();

	/**
	 * \brief Get the set of all array indices of an instance primitive component. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstPrimitive.indices() = Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an FVariable. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices AbstractFVariable.indices() = null;
	eq FVariable.indices() = isScalarized() ? null : Indices.create(size());

	/**
	 * \brief Get the set of all array indices of an InstComponentDecl. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstComponentDecl.indices() = Indices.create(size());
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FEquation.indices() = getLeft().indices();
	
	/**
	 * \brief Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn int[] FSubscript.myIndices();
	
	eq FColonSubscript.myIndices() {
		int n = size()[0];
		int[] ind = new int[n];
		for (int i = 0; i < n; i++)
			ind[i] = i + 1;
		return ind;
	}
	
	eq FExpSubscript.myIndices() = getFExp().myIndices();
	
	syn int[] FExp.myIndices() {
		if (ndims() == 0) {
			return new int[] { ceval().intValue() };
		} else if (ndims() == 1) {
			int[] indices = new int[size()[0]];
			int j = 0;
			for (FExp exp : getArray().getFExps()) 
				indices[j++] = exp.ceval().intValue();
			return indices;
		} else {
			return new int[0];
		}
	}

}

aspect ArrayIndices {
	
	public class Array {
		
		protected Indices indices;
		protected int length;
		
		/**
		 * \brief Create an Array spanning a given Indices.
		 */
		public Array(Indices indices) {
			this.indices = indices;
			setChild(new List<FExp>(), 0);
			length = indices.numElements();
			setFExp(null, length - 1);
		}
		
		/**
		 * \brief Creates an iterator that iterates over all FExp nodes in this Array.
		 */
		public Iterator<ASTNode> iterator() {
			return children[0].iterator();
		}
		
		/**
		 * \brief Creates an iterator that iterates over all FExp nodes in this Array.
		 */
		public Iterator<FExp> iteratorFExp() {
			return getFExps().iterator();
		}
		
		/**
		 * \brief Returns an Iterable<FExp> containing all expressions in Array.
		 */
		public Iterable<FExp> iterable() {
			return getFExps();
		}
		
		/**
		 * \brief Creates a left-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * left side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the row 
		 * specified by i is returned.
		 */
		public Iterator<FExp> leftMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return new AIterator(i.first(), size()[1]);
		}
		
		/**
		 * \brief Creates a right-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * right side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the column 
		 * specified by i is returned.
		 */
		public Iterator<FExp> rightMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return new AIterator(i.last(), size()[1], size()[0]);
		}
		
		/**
		 * \brief Returns the element referenced by <code>i</code> in this Array.
		 */
		public FExp get(Index i) {
			return getFExp(i.internal(indices));
		}
		
		/**
		 * \brief Sets the element referenced by <code>i</code> in this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp(exp, i.internal(indices));
		}
		
		/**
		 * \brief Returns the Indices associated with this Array.
		 */
		public Indices indices() {
			return indices;
		}
		
		/**
		 * \brief Set all expressions in Array to copies of <code>exp</code>.
		 * 
		 * @return <code>this</code> 
		 */
		public Array fill(FExp exp) {
			for (int i = 0; i < length; i++)
				setFExp((FExp) exp.fullCopy(), i);
			return this;
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Array.
		 */
		public int ndims() {
			return indices.ndims();
		}
		
		/**
		 * \brief Returns the size of this Array in each dimension.
		 */
		public int[] size() {
			return indices.size();
		}
		
		
		/**
		 * \brief Iterates over FExp nodes in this Array.
		 */
		private class AIterator implements Iterator<FExp> {
			
			private int i = 0;
			private int s;
			private int l;
			private int n;
			
			/**
			 * Create an iterator that iterates over all elements in the Array. 
			 */
			public AIterator() {
				s = 0;
				l = 1;
				n = length;
			}
			
			/**
			 * Create an iterator that iterates over a row. Assumes the Array is a matrix.
			 */
			public AIterator(int row, int width) {
				s = (row - 1) * width;
				l = 1;
				n = width;
			}
			
			/**
			 * Create an iterator that iterates over a column. Assumes the Array is a matrix.
			 */
			public AIterator(int col, int width, int height) {
				s = col - 1;
				l = width;
				n = height;
			}
			
			public boolean hasNext() {
				return i < n;
			}
			
			public FExp next() {
				if (i >= n)
					throw new NoSuchElementException();
				return getFExp(s + l * i++);
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
	}

	public class ScalarAsArray {

		/**
		 * \brief Constructs a ScalarAsArray containing <code>exp</code>.
		 */
		public ScalarAsArray(FExp exp) {
			this(exp, Indices.create(new int[] { }));
		}
		
		/**
		 * \brief Constructs a ScalarAsArray containing <code>exp</code>, 
		 *        pretending to have <code>ind</code> indices.
		 * 
		 * This makes indices().iterator() meaningful.
		 */
		public ScalarAsArray(FExp exp, Indices ind) {
			this(new List().add(exp.unboundCopy()));
			indices = ind;
			length = 1;
		}
		
		/**
		 * \brief Returns the single element wrapped by this Array. 
		 */
		public FExp get(Index i) {
			return getFExp(0);
		}
		
		/**
		 * \brief Sets the single element wrapped by this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp(exp, 0);
		}
		
	}

	
	/**
	 * \brief Represents the index/indices of a single cell in an (possibly 
	 *        multi-dimensional) array.
	 *        
	 * Index objects are reused to a high degree. Always use clone() when retaining 
	 * an Index object.
	 */
	public class Index implements Cloneable {
		
		public static final Index NULL = new Index(0);
		
		protected int[] index;
		
		/**
		 * \brief Construct an Index representing the indices given in <code>ind</code>.
		 */
		protected Index(int[] ind) {
			index = ind;
		}
		
		/**
		 * \brief Returns the indices that specify this cell.
		 */
		public int[] index() {
			return index;
		}
		
		/**
		 * \brief Returns the number of dimensions of this Index.
		 */
		public int ndims() {
			return index.length;
		}
		
		/**
		 * \brief Returns the index for the first dimension.
		 */
		public int first() {
			return index.length > 0 ? index[0] : -1;
		}
		
		/**
		 * \brief Returns the index for the last dimension.
		 */
		public int last() {
			return index.length > 0 ? index[index.length - 1] : -1;
		}
		
		/**
		 * \brief Create a new FArraySubscripts object describing this index.
		 */
		public FArraySubscripts newFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < index.length; i++) {
				fas.addFSubscript(new FExpSubscript(new FIntegerLitExp(index[i])));
			}
			return fas;
		}
		
		/**
		 * \brief Copies this Index. Always use clone() when saving an Index.
		 */
		public Index clone() {
			try {
				Index i = (Index) super.clone();
				i.index = index.clone();
				return i;
			} catch (CloneNotSupportedException e) {
				return null;
			}
		}
		
		/**
		 * \brief Return a String represetation of this Index.
		 */
		public String toString() {
			return Arrays.toString(index);
		}
		
		
		/**
		 * \brief Return the internal index in an Array of the cell this Index refers to.
		 *        Only for use from Array.
		 * 
		 * @param indices  the indices to resolve the internal index with
		 */
		public int internal(Indices ind) {
			return ind.internal(this);
		}
		
		/**
		 * \brief Construct an empty Index.
		 */
		protected Index() {
		}
		
		/**
		 * \brief Construct an Index of ndims dimensions, 
		 *        pointing at the spot before the first cell.
		 */
		protected Index(int ndims) {
			index = new int[ndims];
			for (int i = ndims - 2; i >= 0; i--)
				index[i] = 1;
			if (ndims > 0)
				index[ndims - 1] = 0;
		}
		
	}
	
	/**
	 * \brief Indices represents the set of array indices in each dimension.
	 * 
	 * Only supports indices of the form (1..n1, 1..n2, ... , 1..nk). 
	 * See {@see NonConsecutiveIndices}. 
	 * 
	 * New Indices objects should be created with the create() methods. 
	 * The subclass used is selected automatically. 
	 * 
	 * The Indices class is typically used to iterate over all possible indices
	 * of an array access of declaration.
	 */
	public class Indices implements Iterable<Index> {
		protected int ndims;
		protected int size[];
		
		/**
		 * \brief A perfect hash for all Indices that have consecutive indicies, 
		 *        ndims <= 3 and size[i] <= 1023 for 0 <= i < ndims. -1 for other 
		 *        Indices.
		 */
		protected int hash;
		
		/**
		 * \brief Create an Indices object based on array sizes. 
		 */
		public static Indices create(int[] size) {
			return new Indices(size);
		}
		
		/**
		 * \brief Create an Indices object based on FArraySubcripts.
		 */
		public static Indices create(FArraySubscripts fas) {
			return NonConsecutiveIndices.create(fas);
		}
		
		/**
		 * \brief Create an Indices object based on a list of int arrays.
		 */
		public static Indices create(ArrayList<int[]> ind) {
			return NonConsecutiveIndices.create(ind);
		}
		
		/**
		 * \brief Check that i is valid for this Indices object.
		 */
		public boolean isValid(Index i) {
			if (i.ndims() != ndims)
				return false;
			int[] index = i.index();
			for (int j = 0; j < ndims; j++)
				if (index[j] > size[j])
					return false;
			return true;
		}
		
		/**
		 * \brief Returns an Iterator, that iterates over all indices spanned by this Indices object.
		 */
		public Iterator<Index> iterator() {
			return new IIterator();
		}
		
		/**
		 * \brief Returns the number of elements spanned by this Indices object.
		 */
		public int numElements() {
			int res = 1;
			for (int i = 0; i < ndims; i++)
				res *= size[i];
			return res;
		}
		
		/**
		 * \brief Returns the number of dimensions spanned by this Indices object.
		 */
		public int ndims() {
			return ndims;
		}
		
		/**
		 * \brief Returns the size of this Indices object in each dimension.
		 */
		public int[] size() {
			return size;
		}
		
		/**
		 * \brief Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 * 
		 * Default implementation always returns <code>i</code>.
		 */
		public Index translate(Index i) {
			return i;
		}
				
		
		/**
		 * \brief Internal constructor to create an Indices object with ndim dimensions. 
		 *        For use by subclasses.
		 */
		protected Indices(int ndims) {
			this.ndims = ndims;
			size = new int[ndims];
			hash = -1;
		}
		
		/**
		 * \brief Internal constructor to create an Indices object based on array sizes. 
		 */
		protected Indices(int[] size) {
			ndims = size.length;
			this.size = size.clone();
			hash = -1;
			if (ndims < 4) {
				int h = 0;
				for (int i = 0; i < size.length; i++) {
					if (size[i] > 1023) 
						return;
					h = (h << 10) & size[i];
				}
				hash = h;
			}
		}
				
		/**
		 * \brief Calculate the internal index in an Array that spans this Indices.
		 */
		protected int internal(Index i) {
			int[] index = i.index();
			int res = 0;
			for (int j = 0; j < ndims; j++)
				res = res * size[j] + index[j] - 1;
			return res;
		}
		
		/**
		 * \brief Iterates over all indices spanned by this Indices.
		 */
		protected class IIterator implements Iterator<Index> {
			
			protected IIndex index;
			protected int max;
			
			public IIterator() {
				index = new IIndex();
				max = numElements() - 1;
			}
			
			public boolean hasNext() {
				return index.internal < max;
			}
			
			public Index next() {
				if (index.internal >= max)
					throw new NoSuchElementException();
				index.internal++;
				int[] ind = index.index();
				int i;
				for (i = ndims - 1; i > 0 && ind[i] >= size[i]; i--)
					ind[i] = 1;
				ind[i]++;
				return index;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
		/**
		 * \brief Internal implementation of Index.
		 */
		protected class IIndex extends Index {
			
			public int internal;
			
			/**
			 * \brief Construct an Index over the number of dimensions of the enclosing Indices, 
			 *        pointing at the spot before the first cell.
			 */
			public IIndex() {
				super(ndims);
				internal = -1;
			}
			
			/**
			 * \brief Return the internal index in an Array of the cell this Index refers to.
			 *        Only for use from Array.
			 * 
			 * @param indices  the indices to resolve the internal index with
			 */
			public int internal(Indices ind) {
				if (Indices.this == ind || (hash != -1 && hash == ind.hash)) 
					return internal;
				else
					return ind.internal(this);
			}
			
		}
		
	}

	/**
	 * \brief NonConsecutiveIndices describes a set of array indices that isn't 
	 *        limited to 1..n.
	 * 
	 * For example, consider the declaration Real x[4,4,4] and the access
	 * x[:,1,1:2:4]. The array indices for the declaration is then
	 * {1,2,3,4}, {1,2,3,4}, and {1,2,3,4} respectively for the three dimensions.
	 * For the access, we have {1,2,3,4}, {1} and {1,3} respectively. The access 
	 * will have size [4,2], and this class will handle the necessary translations 
	 * between indices.
	 */
	public class NonConsecutiveIndices extends Indices {
		// The indices are stored as a list of integer arrays.
		protected ArrayList<int[]> indices; 
		protected Index trans; 
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on FArraySubcripts.
		 *        Use Indices.create(FArraySubscripts fas).
		 */
		public static NonConsecutiveIndices create(FArraySubscripts fas) {
			ArrayList<int[]> ind = new ArrayList<int[]>();
			for (FSubscript fs : fas.getFSubscripts()) 
				ind.add(fs.myIndices());
			return new NonConsecutiveIndices(ind);
		}
		
		/**
		 * \brief Create a NonConsecutiveIndices object based on a list of int arrays
		 *        Use Indices.create(ArrayList<int[]> ind).
		 */
		public static NonConsecutiveIndices create(ArrayList<int[]> ind) {
			return new NonConsecutiveIndices(ind);
		}
		
		/**
		 * \brief Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 */
		public Index translate(Index i) {
			int[] ii = i.index();
			int[] ti = trans.index();
			for (int ji = 0, jt = 0; ji < ndims; ji++, jt++) {
				while (indices.get(jt).length == 1) 
					jt++;
				ti[jt] = indices.get(jt)[ii[ji] - 1];
			}
			return trans;
		}

		
		/**
		 * \brief Internal constructor to create a NonConsecutiveIndices object based on a 
		 *        list of int arrays containing the used indexes on the underlying array.
		 */
		protected NonConsecutiveIndices(ArrayList<int[]> ind) {
			super(getSize(ind));
			indices = ind;
			trans = new Index(ind.size());
			for (int i = 0; i < ind.size(); i++)
				trans.index()[i] = indices.get(i)[0];
		}
		
		/**
		 * \brief Calculate size for this indices from a list of int arrays containing the 
		 *        used indexes on the underlying array
		 */
		protected static int[] getSize(ArrayList<int[]> ind) {
			int n = 0;
			for (int i = 0; i < ind.size(); i++)
				if (ind.get(i).length > 1)
					n++;
			int[] size = new int[n];
			for (int i = 0, j = 0; i < ind.size(); i++)
				if (ind.get(i).length > 1)
					size[j++] = ind.get(i).length;
			return size;
		}
		
	}
	
}
