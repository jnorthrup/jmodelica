/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.LinkedHashSet;

/**
 * Computation of alias sets.
 */
aspect AliasVariables {
	
	/**
	 * \brief Check if an FVariable is an alias.
	 * 
	 * Returns true if alias, else false.
	 * 
	 * @return True if alias, else false.
	 */
	syn lazy boolean FAbstractVariable.isAlias() = false; 
	eq FVariable.isAlias() = aliasVariable() != null; 
	
	/**
	 * \brief Get the alias variable of an FVariable. 
	 * 
	 * If the FVariable is not an alias, null is returned.
	 * 
	 * @return An AliasVariable object if the variable is an alias, otherwise
	 * null.
	 */
	syn lazy AliasVariable FVariable.aliasVariable() {
		AliasManager aliasManager = myFClass().getAliasManager();
		LinkedHashSet<AliasVariable> aliasSet = aliasManager.getAliasSet(this);
		if (aliasSet == null || inRecord()) {
			return null;
		}
		AliasVariable av = aliasManager.getIterationVariable(aliasSet);
		return av.getFVariable()==this? null : av;
	}
	
	/**
	 * \brief Get the iteration variable corresponding to the alias.
	 * 
	 * If the FVariable is an alias, the alias() return corresponding iteration
	 * FVariable, else null.
	 * 
	 * @return The corresponding iteration variable if alias, otherwise null.
	 */
	syn FVariable FAbstractVariable.alias() = null;
	
	eq FVariable.alias() {
		if (aliasVariable() == null) {
			return null;
		} else {
			return aliasVariable().getFVariable();			
		}
	}

	/**
	 * \brief Returns true if the alias is negated otherwise false.
	 * 
	 * @return True if negated alias, otherwise false.
	 */
	syn boolean FAbstractVariable.isNegated() = false;
	
	eq FVariable.isNegated(){
		AliasManager aliasManager = myFClass().getAliasManager();
		AliasVariable av = aliasManager.getAliasVariable(this);
		LinkedHashSet<AliasVariable> aliasSet = aliasManager.getAliasSet(av);
		if (av == null) {
			return false;
		} else {
			AliasVariable iav = aliasManager.getIterationVariable(aliasSet);
			return (av.isNegated() != iav.isNegated());
		}
	}
		
	/**
	 * \brief An FClass has an alias manager.
	 */
	private AliasManager FClass.aliasManager = new AliasManager();

	/**
	 * \brief Get the alias manager.
	 * 
	 * @return the alias manager.
	 */
	public AliasManager FClass.getAliasManager() {
		return aliasManager;
	}
	
	/**
	 * \brief AliasManager contains the connection sets of an FClass.
	 * 
	 * The alias sets are build by adding pairs of FVariables, in addition
	 * to information about whether the alias pair is negated.
	 */
	public class AliasManager {
	
		// Alias error message.
		private String aliasErrorMessage = "";

		// Indicate alias error
		private boolean aliasErrorFlag = false;
		
		// A set of alias sets
		private LinkedHashSet<LinkedHashSet<AliasVariable>> aliasSets = new LinkedHashSet<LinkedHashSet<AliasVariable>>();
		
		// A map that maps FVariable to its alias set.
		private HashMap<FVariable, LinkedHashSet<AliasVariable>> variableMap = new HashMap<FVariable, LinkedHashSet<AliasVariable>>();
		
		/**
		 * \brief Getter for alias error message.
		 * 
		 * @return The error message.
		 */
		public String getAliasErrorMessage() {
			return aliasErrorMessage;
		}
		
		/**
		 * \brief Check if there was an alias error.
		 * 
		 * The error message can be retreived by calling the method
		 * getAliasManagerError.
		 * 
		 * @return True if there was an alias error, otherwise false.
		 */
		public boolean aliasError() {
			return aliasErrorFlag;
		}
		
		/**
		 * \brief Get the set of alias sets.
		 * 
		 * @return A set containing the alias sets.
		 */
		public LinkedHashSet<LinkedHashSet<AliasVariable>> getAliasSets() {
			return aliasSets;
		}
		
		/**
		 * \brief Get the iteration variable of an alias set.
		 * 
		 * @param aliasSet An alias set.
		 * @return The iteration variable of the alias set.
		 */
		public AliasVariable getIterationVariable(LinkedHashSet<AliasVariable> aliasSet) {
			// Find the variable with highest heuristic score
			AliasVariable best = null;
			int max = 0;
			for (AliasVariable av : aliasSet) {
				int score = av.getFVariable().aliasHeuristicScore();
				if (score > max) {
					max = score;
					best = av;
				}
			}
			return best;
		}

		/**
		 * \brief Get the AliasVariable object corresponding to an FVariable
		 * 
		 * @param fv An FVariable object
		 * @return An AliasVariable object if the FVariable is in an alias
		 * set, otherwise null.
		 */
		public AliasVariable getAliasVariable(FVariable fv) {
			LinkedHashSet<AliasVariable> aliasSet = getAliasSet(fv);
			for (AliasVariable av : aliasSet) {
				if (av.getFVariable().equals(fv)) {
					return av;
				}
			}
			return null;
		}
		
		/**
		 * \brief Retrieve the alias set corresponding to an alias variable.
		 * 
		 * Returns null if alias variable not present in an alias set.
		 * 
		 * @param alias An alias variable.
		 * @return The alias set corresponding to the alias variable.
		 */
		public LinkedHashSet<AliasVariable> getAliasSet(AliasVariable alias) {
			LinkedHashSet<AliasVariable> aliasSet = getAliasSet(alias.getFVariable());
			if (aliasSet == null)
				return null;
			if (aliasSet.contains(alias))
				return aliasSet;
			return null;
		}

		/**
		 * \brief Retrieve the alias set corresponding to an FVariable.
		 * 
		 * Returns null if the FVariable is not present in an alias set.
		 * 
		 * @param alias An FVariable.
		 * @return The alias set corresponding to the alias variable.
		 */
		public LinkedHashSet<AliasVariable> getAliasSet(FVariable alias) {
			return variableMap.get(alias);
		}

		/**
		 * \brief Add a pair of alias variables to the alias manager.
		 * 
		 * @param fv1 An FVariable.
		 * @param fv2 Another FVariable.
		 * @param neg True if the alias pair is negated, otherwise false.
		 * 
		 */
		public void addAliasVariables(FVariable fv1, FVariable fv2, boolean neg) {
			
			// Create alias variables with negated  = false
			AliasVariable alias1 = new AliasVariable(fv1,false);
			AliasVariable alias2 = new AliasVariable(fv2,false);

			// Create alias variables with negated = true
			AliasVariable alias1n = new AliasVariable(fv1,true);
			AliasVariable alias2n = new AliasVariable(fv2,true);
			
			/*
			 * Rules for alias sets:
			 * 
			 *  1. An alias variable can only occur in one alias set
			 *  2. An alias variable can occur either negated or
			 *     non-negated in an alias set, not both.
			 *  
			 *  These rules are enforced by the algorithm below: if a
			 *  rule is about to be broken an error message is generated.
			 *  			
			 *  Notice that LinkedHashSets are expected to be persistent, 
			 *  therfore alias sets need to be temporarily removed from the
			 *  set, then modified, then reinserted.
			 */
			
			/*
			 * The algorithm has two stages, a detection phase and a 
			 * update phase.
			 * In the detection phase the algorithm detects what should
			 * be done, the possibillities are:
			 *   - Merge two alias sets if both variables had previously
			 *     known aliases.
			 *   - Addition of one variable if the other variables had
			 *     previously known aliases.
			 *   - Creation of new alias set if none of the variables
			 *     had previously known aliases.
			 * The result of the detection phase is stored in the
			 * temporary variables resultAS, mergeAS, mergeAlias and
			 * negMergeAS.
			 * 
			 * In the update phase the correct action is taken depening
			 * on what variables are set:
			 *   - If resultAS and mergeAS is set, then all aliases in
			 *     mergeAS is added into resultAS, if negMergeAS is set
			 *     then the aliases are negated before they are added
			 *     to resultAS.
			 *   - If resultAS and mergeAlias is set, then mergeAlias
			 *     is added to resultAS.
			 *   - If only resultAS is set, the two variables are added
			 *     to the new alias set.
			 */
			
			// Create all combinations of alias variables, negated and 
			// non-negated
			LinkedHashSet<AliasVariable> as1 = getAliasSet(alias1);
			LinkedHashSet<AliasVariable> as2 = getAliasSet(alias2);
			LinkedHashSet<AliasVariable> as1n = getAliasSet(alias1n);
			LinkedHashSet<AliasVariable> as2n = getAliasSet(alias2n);
			
			LinkedHashSet<AliasVariable> resultAS;
			LinkedHashSet<AliasVariable> mergeAS = null;
			AliasVariable mergeAlias = null;
			boolean negMergeAS = false;
			
			// Go through all the cases
			if (as1!=null && as2!=null) { // -> as1n==null & as2n==null
				resultAS = as1;
				mergeAS = as2;
				negMergeAS = neg;
			} else if (as1!=null && as2n!=null) { // -> as1n==null & as2==null
				resultAS = as1;
				mergeAS = as2n;
				negMergeAS = !neg;
			} else if (as1n!=null && as2!=null) { // -> as1==null & as2n==null
				resultAS = as1n;
				mergeAS = as2;
				negMergeAS = !neg;
			} else if (as1n!=null && as2n!=null) { // -> as1==null & as2==null
				resultAS = as1n;
				mergeAS = as2n;
				negMergeAS = neg;
			} else if (as1==null && as1n==null && as2!=null) { // -> as2n==null
				resultAS = as2;
				mergeAlias = neg ? alias1n : alias1;
			} else if (as1==null && as1n==null && as2n!=null) { // -> as2==null
				resultAS = as2n;
				mergeAlias = neg ? alias1 : alias1n;
			} else if (as2==null && as2n==null && as1!=null) { // -> as1n==null
				resultAS = as1;
				mergeAlias = neg ? alias2n : alias2;
			} else if (as2==null && as2n==null && as1n!=null) { // -> as1==null
				resultAS = as1n;
				mergeAlias = neg ? alias2 : alias2n;
			} else {
				resultAS = new LinkedHashSet<AliasVariable>();
			}
			
			// Update part begins here
			
			if (mergeAS != null) { // Merge
				if (resultAS == mergeAS && negMergeAS) {
					aliasErrorFlag = true;
					if (neg)
						aliasErrorMessage = "Alias error: trying to add the " +
								"negated alias pair (" + fv1.name() + ",-" + 
								fv2.name() + ") to the alias set " + 
								printAliasSet(resultAS);
					else
						aliasErrorMessage = "Alias error: trying to add the " +
								(neg ? "negated " : "") +
								"alias pair (" + fv1.name() + "," + 
								fv2.name() + ") to the alias set " + 
								printAliasSet(resultAS);
					return;
				}
				aliasSets.remove(mergeAS);
				aliasSets.remove(resultAS);
				for (AliasVariable a : mergeAS) {
					resultAS.add(new AliasVariable(a.getFVariable(), negMergeAS ? !a.isNegated() : a.isNegated()));
					variableMap.put(a.getFVariable(), resultAS);
				}
				aliasSets.add(resultAS);
			} else if (mergeAlias != null) { // Add alias to set
				aliasSets.remove(resultAS);
				resultAS.add(mergeAlias);
				variableMap.put(mergeAlias.getFVariable(), resultAS);
				aliasSets.add(resultAS);
			} else { // New alias set
				if (neg) {
					resultAS.add(alias1);
					variableMap.put(alias1.getFVariable(), resultAS);
					resultAS.add(alias2n);
					variableMap.put(alias2n.getFVariable(), resultAS);
				} else {
					resultAS.add(alias1);
					variableMap.put(alias1.getFVariable(), resultAS);
					variableMap.put(alias2.getFVariable(), resultAS);
					resultAS.add(alias2);
				}
				aliasSets.add(resultAS);
			}
			
			checkManualTearing(resultAS);
		}
		
		public void checkManualTearing(Set<AliasVariable> aliasSet) {
			boolean allManual = true;
			boolean anyManual = false;
			for (AliasVariable var : aliasSet) {
				if (var.getFVariable().getManualTearingVariable())
					anyManual = true;
				else
					allManual = false;
			}
			if (anyManual && !allManual) {
				for (AliasVariable var : aliasSet) {
					var.getFVariable().setManualTearingVariable(true);
				}
			}
		}

		public String printAliasSet(LinkedHashSet<AliasVariable> aliasSet) {
			StringBuilder str = new StringBuilder();
			//str.append(getIterationVariable(aliasSet).getFVariable().name());
			//str.append("(" + getIterationVariable(aliasSet).getFVariable().varKind() + ")");
			//str.append(":");
			str.append("{");
			int i=0;
			for (AliasVariable alias : aliasSet) {
				if (alias.isNegated()) {
					str.append("-");
				}
				str.append(alias.getFVariable().name());
				//str.append("(" + alias.getFVariable().varKind() + ")");
				if ((i<(aliasSet.size())-1)) {
					str.append(",");
				}
				i++;
			}
			str.append("}");
			return str.toString();
		}
		
		public String printAliasSetVerbose(LinkedHashSet<AliasVariable> aliasSet) {
			StringBuilder str = new StringBuilder();
			//str.append(getIterationVariable(aliasSet).getFVariable().name());
			//str.append("(" + getIterationVariable(aliasSet).getFVariable().varKind() + ")");
			//str.append(":");
			str.append("Alias set: (" + getIterationVariable(aliasSet).getFVariable().name() + ")\n");
			for (AliasVariable alias : aliasSet) {
				if (alias.isNegated()) {
					str.append("-");
				}
				str.append(alias.getFVariable().name());
				str.append(" " + alias.getFVariable().aliasHeuristicScore() + " ");
				str.append(" " + alias.getFVariable().varKind() + "\n");
			}
			return str.toString();
		}
		
		/**
		 * \brief Print the alias sets.
		 * 
		 * @return A string containing the alias sets.
		 */
		public String printAliasSets() {
			StringBuilder str = new StringBuilder();
			for (LinkedHashSet<AliasVariable> aliasSet : aliasSets) {
				str.append(printAliasSet(aliasSet)+"\n");
			}
			return str.toString();		
		}
	}	
	
	/**
	 * \brief AliasVariable is used to encapsulate an FVariable and whether
	 * the alias is negated. 
	 * 
	 * AliasVariable implements the Comparable interface and objects of the 
	 * class are used in the alias sets.
	 */
	public class AliasVariable implements Comparable{
		
		// The FVariable
		private FVariable fv;
		// Negated attribute
		private boolean negated = false;
		
		/**
		 * \brief Constructor.
		 * 
		 * @param fv An FVariable.
		 * @param negated True if the alias is negated, otherwise false.
		 */
		public AliasVariable(FVariable fv,boolean negated) {
			this.fv = fv;
			this.negated = negated;
		}
	
		/**
		 * \brief Returns true if the alias is negated.
		 * 
		 * @return True if the alias is negated, otherwise false.
		 */
		public boolean isNegated() {
			return negated;
		}
	
		/**
		 * \brief Getter for the FVariable.
		 * 
		 * @return The FVariable.
		 */
		public FVariable getFVariable() {
			return fv;
		}	
		
		/**
		 * \brief Compute the hash code of the alias variable. 
		 * 
		 * Both the name of the variable and the negated attribute is used
		 * to compute the hash code.
		 * 
		 * @return The hash code.
		 */
		public int hashCode() {
			String tr = "true";
			String fa = "false";
			return fv.name().intern().hashCode() + 
				(negated? tr.intern().hashCode() : fa.intern().hashCode());
		}
		
		/**
		 * \brief Implementation of the equals method in the Comparable 
		 * interface.
		 * 
		 * @param o An object to compare.
		 * @return True if o is equal to the alias, otherwise false.
		 */
		public boolean equals(Object o) {
			if (!(o instanceof AliasVariable))
				return false;
			AliasVariable alias = (AliasVariable)o;
			return (getFVariable().name().equals(alias.getFVariable().name())) &
			       (isNegated()==alias.isNegated());
		}

		/**
		 * \brief Implementation of the compareTo method in the Comparable
		 * interface.
		 * 
		 * @param o An object to compare with.
		 * @return Result of comparison.
		 */
		public int compareTo(Object o) {
		
			AliasVariable alias = (AliasVariable)o;
			return getFVariable().name().compareTo(alias.getFVariable().name());
		
		}
	
	}
	
	/**
	 * \brief Get the heuristic score for keeping this variable in an alias set.
	 * 
	 * The variable with the highest score should be kept. Score is always > 0.
	 */
	syn int FVariable.aliasHeuristicScore() {
		int score = 1000;
		
		// Temporary variables added during transformations should get lower priority
		if (isTemporary())
			score -= 100;
		
		// 0. Derivatives
		if (isDerivativeVariable())
			return score;
		score--;
		
		// 1. Input
		if (isInput())
			return score;
		score--;
		
		// 2. parameter
		if (isParameter())
			return score;
		score--;
		
		// 3. non-parameter with fixed attribute set to true
		if (!isParameter() && fixedAttributeSet() && fixedAttributeExp().ceval().booleanValue())
			return score;
		score--;
				
		// 4. Variables with StateSelect-information
		if (isReal() && ((FRealVariable)this).stateSelectAttributeSet()) 
			return score;
		score--;		
				
		// 5. start attribute set
		if (startAttributeSet())
			return score;
		score--;
		
		return score;
	}

}