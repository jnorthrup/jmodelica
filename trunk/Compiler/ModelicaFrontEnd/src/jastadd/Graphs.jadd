/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package org.jmodelica.util;
import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Random;
import java.util.Stack;

aspect Graphs {

public class BiPGraph {

	public static int DERIVATIVE_VARIABLES = 1;
	public static int DIFFERENTIATED_VARIABLES = 2;
	public static int ALGEBRAIC_VARIABLES = 4;
	public static int DISCRETE_PRE_VARIABLES = 8;

	private String name;
	private String description;
	
	protected ArrayList<Eq> equations = new ArrayList<Eq>();
	protected LinkedHashMap<String,Var> variableMap = new LinkedHashMap<String,Var>();
	protected LinkedHashMap<String,Eq> equationMap = new LinkedHashMap<String,Eq>();
	protected LinkedHashMap<FAbstractEquation,ArrayList<Eq>> equationIndexMap = new LinkedHashMap<FAbstractEquation,ArrayList<Eq>>();
	
	public BiPGraph(String name, String description) {
		this.name = name;
		this.description = description;
	}

	public Eq getEquation(String name) {
		return equationMap.get(name);
	}
	

	public ArrayList<Eq> getEquations(FAbstractEquation eqn) {
		return equationIndexMap.get(eqn);
	}

	public Eq addEquation(String name, String description,
		                      FAbstractEquation eqn) {
		Eq e = equationMap.get(name);
		if (e==null) {
			e = new Eq(name,description,eqn);
			equations.add(e);
			equationMap.put(name,e);
			insertIntoEquationIndexMap(eqn,e);
		}
		return e;
	}
	
	public Var addVariable(String name, String description, FVariable var) {
		Var v = variableMap.get(name);
		if (v==null) {
			v = new Var(name,description,var);
			variableMap.put(name,v);
		}	
		return v;
	}
	
	public Eq replaceEquation(String name, String description, FAbstractEquation eqn) {
		Eq e = equationMap.get(name);
		if (e==null) {
			e = new Eq(name,description,eqn);
			equations.add(e);
			equationMap.put(name,e);
			insertIntoEquationIndexMap(eqn,e);
		} else {
			// Remove the old equation
			for (Var v : e.getVariables()) {
				if (v.getMatching() == e) {
					v.setMatching(null);
				}
			}
			e.setMatching(null);
			e.getVariables().clear();
			// Insert the new equation
			Eq ee = new Eq(name,description,eqn);
			equations.set(equations.indexOf(e),ee);
			equationMap.put(e.getName(),ee);
			removeFromEquationIndexMap(e.getEquation(),e);
			insertIntoEquationIndexMap(eqn,ee);
			e = ee;
		}
		return e;
	}

	public void removeEquation(Eq e) {
		for (Var v : e.getVariables()) {
			if (v.getMatching() == e) {
				v.setMatching(null);
			}
		}
		e.setMatching(null);
		e.getVariables().clear();
		equations.remove(e);
		equationMap.remove(e.getName());
		removeFromEquationIndexMap(e.getEquation(),e);
	}
	
	public Var addVariable(String name, String description) {
		Var v = variableMap.get(name);
		if (v==null) {
			v = new Var(name,description);
			variableMap.put(name,v);
		}	
		return v;
	}

	public void removeVariable(Var v) {
		for (Eq e : getEquations()) {
			if (e.getMatching() == v) {
				e.setMatching(null);
			}
			e.getVariables().remove(v);
		}
		v.setMatching(null);
		variableMap.remove(v.getName());
	}
	
	public Var getVariable(String name) {
		return variableMap.get(name);
	}
	
	public boolean addEdge(String equationName, String variableName) {
		Eq e = equationMap.get(equationName);
		Var v = variableMap.get(variableName);
		if (v==null || e==null) {
			return false;
		}
		if (e.getVariables().contains(v)) {
			return false;
		}
		e.addVariable(v);
		return true;
	}

	public boolean addEdge(Eq e, Var v) {
		return addEdge(e.getName(),v.getName());
	}
		
		
	public void addVariables(FClass fclass, int variableMask) {
	
		if ((variableMask & DERIVATIVE_VARIABLES) != 0) {
			for (FVariable fv : fclass.derivativeVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		}

		if ((variableMask & DIFFERENTIATED_VARIABLES) != 0) {
			for (FVariable fv : fclass.differentiatedRealVariables()) {
				addVariable(fv.name(),"",fv);     
			}	
		}
		
		if ((variableMask & ALGEBRAIC_VARIABLES) != 0) {
			for (FVariable fv : fclass.algebraicRealVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		
			for (FVariable fv : fclass.discreteRealVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteIntegerVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteBooleanVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteStringVariables()) {
				addVariable(fv.name(),"",fv);     
			}
			for (FVariable fv : fclass.discreteEnumVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		}
	
		if ((variableMask & DISCRETE_PRE_VARIABLES) != 0) {
			for (FVariable fv : fclass.discretePreVariables()) {
				addVariable(fv.name(),"",fv);     
			}
		}
	
	}	
		
	public void addEquations(ArrayList<FAbstractEquation> eqns, int variableMask, String eqNamePrefix, int startIndex) {	
    	int k = startIndex;
    	Eq eqn = null;
    	Var v = null;
		for (FAbstractEquation e : eqns) {

			int n_eq = e.numScalarEquations();
			for (int i=0;i<n_eq;i++) {
				eqn = addEquation("eq_"+k,e.prettyPrint(""),e);
				k++;

				if ((variableMask & DERIVATIVE_VARIABLES) != 0) {
					for (FDerivativeVariable dx : e.derivativeVariables()) { 
						v = getVariable(dx.name());     
						addEdge(eqn,v); 
					} 
				}

				if ((variableMask & DIFFERENTIATED_VARIABLES) != 0) {
					for (FVariable x : e.differentiatedVariables()) { 
						v = getVariable(x.name());     
						addEdge(eqn,v); 
					} 			
				}

				if ((variableMask & ALGEBRAIC_VARIABLES) != 0) {
					for (FVariable y : e.algebraicVariables()) { 
						v = getVariable(y.name()); 
						addEdge(eqn,v); 
					} 
				}
				
				if ((variableMask & DISCRETE_PRE_VARIABLES) != 0) {
					for (FVariable x : e.discretePreVariables()) { 
						v = getVariable(x.name());     
						addEdge(eqn,v);
					} 			
				}			
			}
		}			
	}
	
	public void greedyMatching() {
		for (Eq e : getEquations()) {
			for (Var v : e.getVariables()) {
				if (v.getMatching()==null) {
					v.setMatching(e);
					e.setMatching(v);
					break;
				}
			}
		}
	}
	
	public ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> bfs(LinkedHashSet<Eq> startingNodes) {
		ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> Lv = new ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>>();
		LinkedHashSet<Eq> Le_current = new LinkedHashSet<Eq>();
		LinkedHashSet<Eq> Le_next = new LinkedHashSet<Eq>();
		
		Le_current.addAll(startingNodes);
		// Reset nodes
		lightReset();
		
		int layer = 0;
		boolean freeVarNodeFound = false;
		//System.out.println("************** BFS ************* starting nodes: " + startingNodes);
		
		while (Le_current.size()>0 && !freeVarNodeFound) {
			//System.out.println("*** layer: " + layer);
			//System.out.println(Lv);
			//System.out.println(Le_current);
			Lv.add(new LinkedHashMap<Var,LinkedHashSet<Eq>>());
			
			for (Eq s : Le_current) {
				//System.out.println(" eq: " + s.getName());
				for (Var t : s.getVariables()) {
					//System.out.println("  " + t.getName() + " layer: " + t.getLayer());
					if (t.getLayer() >= layer) {
						//System.out.println("    adding " + t.getName());
						t.setLayer(layer);
						LinkedHashSet<Eq> h = Lv.get(layer).get(t);
						if (h==null) {
							h = new LinkedHashSet<Eq>();
							Lv.get(layer).put(t,h);
						}
						h.add(s);
						Eq u = t.getMatching();
						if (u!=null) {
							//System.out.println("     " + t.getName() + "'s matching is " + u.getName());
							u.setLayer(layer);
							Le_next.add(u);
						} else {
							//System.out.println("     " + t.getName() + "has no matching");
							freeVarNodeFound = true;
					
						}
					}
				}
			}
			layer++;
			Le_current = Le_next;
			Le_next = new LinkedHashSet<Eq>();
		}
		
		ArrayList<Var> delQueue = new ArrayList<Var>();
		for (Var v : Lv.get(Lv.size()-1).keySet()) {
			if (v.getMatching()!=null) {
				delQueue.add(v);
			}
		}
		for (Var v : delQueue) {
			Lv.get(Lv.size()-1).remove(v);
		}
		//System.out.println(Lv);
		//System.out.println("************** BFS ends *************");
		return Lv;
	}

	public ArrayList<ArrayList<Edge>> dfs(ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> Lv) {
		lightReset();
		ArrayList<ArrayList<Edge>> P = new ArrayList<ArrayList<Edge>>();
	
		boolean found_path = true;
		for (Var v : Lv.get(Lv.size()-1).keySet()) {
			ArrayList<Edge> P_tmp = new ArrayList<Edge>();
			
			ListIterator<LinkedHashMap<Var,LinkedHashSet<Eq>>> iter = 
				Lv.listIterator(Lv.size());
			while (iter.hasPrevious()) {
				LinkedHashMap<Var,LinkedHashSet<Eq>> l = iter.previous();
				v.setVisited(true);
				if (!found_path) {
					break;
				}
				found_path = false;
				for (Eq e : l.get(v)) {
					if (!e.isVisited()) {
						e.setVisited(true);
						P_tmp.add(new Edge(e,v));
						v = e.getMatching();
						found_path = true;
						break;
					}
				}
			}
			if (P_tmp.size() == Lv.size()) {
				P.add(P_tmp);
			}
		}
		//System.out.println(P);
		return P;
	}
		
	public void reassign(ArrayList<ArrayList<Edge>> P) {
		for (ArrayList<Edge> l : P) {
			for (Edge ed : l) {
				ed.getEquation().setMatching(ed.getVariable());
				ed.getVariable().setMatching(ed.getEquation());
			}
		}
	}
	
	public void maximumMatching(boolean resetMatching) {
		if (resetMatching) {
			reset();
			greedyMatching();
		}
		//System.out.println(printMatching());
		
		// Initialize set of free equations
		LinkedHashSet<Eq> startingNodes = new LinkedHashSet<Eq>();
		for (Eq e : getEquations()) {
			if (e.getMatching()==null) {
				startingNodes.add(e);
			}
		}
	
		LinkedHashSet<Eq> unmatchedEquations = new LinkedHashSet<Eq>();
		for (Eq e : equations) {
			if (e.getMatching()==null) {
				unmatchedEquations.add(e);
			}
		}
		
		ArrayList<LinkedHashMap<Var,LinkedHashSet<Eq>>> Lv = null;
		ArrayList<ArrayList<Edge>> P = null;
		
		while (unmatchedEquations.size()>0) {
		
			Lv = bfs(unmatchedEquations);
			P = dfs(Lv);

			if (Lv.get(Lv.size()-1).size()==0) {
				break;
			}
			
			reassign(P);
		
			//System.out.println(printMatching());

			for (ArrayList<Edge> l : P) {
				unmatchedEquations.remove(l.get(l.size()-1).getEquation());
			}
			
			/*
			unmatchedEquations = new LinkedHashSet<Eq>();
			for (Eq e : equations) {
				if (e.getMatching()==null) {
					unmatchedEquations.add(e);
				}
			}
*/
			
		}
	}
	
	public ArrayList<MatchingPair> getMatching() {
			
		ArrayList<MatchingPair> l = new ArrayList<MatchingPair>();
		Var v = null;
		
		for (Eq e : getEquations()) {				
			int n_eq = e.getEquation().numScalarEquations();
			
			for (int i=0;i<n_eq;i++) {
				v = e.getMatching();
				if (v!=null) {
					l.add(new MatchingPair(e.getEquation(),v.getVariable()));
				}
			}
		}		
		return l;
	}
	
	public boolean augmentPath(Eq e, ArrayList<Eq> visitedEquations,
	                                 ArrayList<Var> visitedVariables) {
		e.setVisited(true);
		visitedEquations.add(e);
		for (Var v : e.getVariables()) {
			if (v.getMatching()==null) {
				v.setMatching(e);
				e.setMatching(v);
				return true;
			} else if (!v.isVisited()) {
				v.setVisited(true);
				visitedVariables.add(v);
				if (augmentPath(v.getMatching(),visitedEquations,visitedVariables)) {
					v.setMatching(e);
					e.setMatching(v);
					return true;	
				}
			}
		}
		return false;
	}	

	public IndexReductionResult reduceIndex(boolean resetMatching) {
		if (resetMatching) {
			reset();
			//greedyMatching();
		}
			
		//_maximumMatching(resetMatching);	
		IndexReductionResult result = new IndexReductionResult();		
				
		ArrayList<Eq> visitedEquations;
		ArrayList<Var> visitedVariables;		
				
		LinkedHashSet<Eq> es = new LinkedHashSet<Eq>();
		es.addAll(getEquations());
		
		Eq eqToMatch;
		boolean pathFound = false;		
				
		// Algoritm step numbering from the original Pantelides paper		
		// Loop over all equations (step 3)
		for (Eq e : es) {
			// If the equation is not matched
			if (e.getMatching()==null) {
				eqToMatch = e; // Step 3a
				pathFound = false; // Step
				while (!pathFound) { // Step 3b
					// Since the states are not added to the graph,
					// Step 3b-1 is skipped and is done at the end of 
					// the iteration 
					visitedEquations = new ArrayList<Eq>();
					visitedVariables = new ArrayList<Var>();	
					lightReset(); // Step 3b-2
					pathFound = false; // Step 3b-3
					// Find an augmenting path, step 3b-4
					pathFound = augmentPath(eqToMatch, visitedEquations, visitedVariables); 
					System.out.println("*************");
					System.out.println("Looking for augmented path starting in equation: " + eqToMatch.toString());
					if (pathFound) {
						System.out.println("Path found!");
					} else {	
					 	System.out.println("Path not found!");
					}
					System.out.println("Visisted equations:");
					for (Eq ee : visitedEquations) {
						System.out.println("  " + ee.getDescription());
					}
					System.out.println("Visisted variables:");
					for (Var vv : visitedVariables) {
						System.out.println("  " + vv.toString());
					}
					
					if (!pathFound) { // Step 3b-5
						for (Var vv : visitedVariables) { // Loop over all visited variables, Step 3b-5i
						    // Create a new differentiated variable
							FVariable newVar = vv.getVariable().myFClass().addFDerivativeVariable(vv.getVariable());
							// Add the differentiated variable to the graph 
							Var vvv = addVariable(newVar.name(),"",newVar);
							// Set the "A vector" in the paper: 
							// a reference from the visited variable to its 
							// differentiated counterpart
							vv.setMeDifferentiated(vvv); 
							vvv.setMeIntegrated(vv);
						}
						for (Eq ee : visitedEquations) { // Step 3b-5ii
							FAbstractEquation eee = ee.getEquation();
							// Create a new differentiated equation
							FAbstractEquation deee = eee.diff("time");
							result.addEquation(deee);
							System.out.println("About to add equation: " + deee);
							// Add the differentiated equation						
							Eq eqn = addEquation("eq_" + (getEquations().size() + 1), 
							             deee.prettyPrint(""), deee);
							
							// Add edges
							for (FVariable fv : deee.variables()) {
								Var vvv = variableMap.get(fv.name());
								System.out.println("*** " + fv.name());
								if (vvv!=null) {
									addEdge(eqn,vvv);
								}
							}
							// Set a reference from the visited equation to
							// its differentiated counterpart
							ee.setMeDifferentiated(eqn);
							eqn.setMeIntegrated(ee);
						}
						for (Var vv : visitedVariables) {
							// Set matchings, Step 3b-5iii
							Eq ee = vv.getMatching();
							vv.getMeDifferentiated().setMatching(ee.getMeDifferentiated());
							ee.getMeDifferentiated().setMatching(vv.getMeDifferentiated());
							// Remove variables that have been differentiated, Step 3b-1
							removeVariable(vv);
						}
						
						// Set the next equation to start matching from, 
						// Step 3b-5iv
						eqToMatch = eqToMatch.getMeDifferentiated();
						
						System.out.println("Graph after addition of equations and variables:");
						System.out.println(toString());
					}	

					System.out.println("Matching:");
					System.out.println(printMatching());
					System.out.println("*************");
				
				}	
			}
		}

		// Remove equations that are not connected
		ArrayList<Eq> eqToRemove = new ArrayList<Eq>();
		for (Eq e : getEquations()) {
			if (e.getVariables().size()==0) {
				eqToRemove.add(e);
			}
		}
		for (Eq e : eqToRemove) {
			removeEquation(e);
		}
		System.out.println("Index reduction done!");
		System.out.println("Matching:");
		System.out.println(printMatching());
		
		// Selection of dummy derivatives
		BLT blt = computeBLT();
	
		System.out.println(blt.toString());

		ArrayList<ArrayList<FAbstractEquation>> g = 
		   new ArrayList<ArrayList<FAbstractEquation>>();
		
		ArrayList<ArrayList<FAbstractEquation>> h = 
		   new ArrayList<ArrayList<FAbstractEquation>>();

		ArrayList<ArrayList<FVariable>> z = 
		   new ArrayList<ArrayList<FVariable>>();

		ArrayList<ArrayList<FVariable>> zHat = 
		   new ArrayList<ArrayList<FVariable>>();
		
		for (EquationBlock eb : blt) {

			ArrayList<FAbstractEquation> diffedEqns = eb.differentiatedEquations();
			if (diffedEqns.size()>0) {
				System.out.println(" ********* Found block containing diffed equations ***********");
				System.out.println(eb.toString());

				// Step 1: Initialize
				ArrayList<FAbstractEquation> gg = new ArrayList<FAbstractEquation>();
				gg.addAll(eb.equations());
				g.add(gg);
				
				ArrayList<FVariable> zz = new ArrayList<FVariable>();
				for (FVariable fv : eb.activeVariables()) {
					if (fv.isDerivativeVariable()) {
						//FRealVariable frv = (FRealVariable)((FDerivativeVariable)fv).lookupFV(fv.getFQName());
						FRealVariable frv = (FRealVariable)fv.getMeIntegrated();
						if (frv!=null && frv.stateSelectAttribute()!=FRealVariable.StateSelect.ALWAYS) {
							zz.add(fv);
						}
					} else {
						zz.add(fv);
					}
				}
				z.add(zz);				

				boolean remainingDifferentiatedEquations = false;
				for (FAbstractEquation fe : gg) {
					if (fe.getMeIntegrated()!=null) {
						remainingDifferentiatedEquations = true;
					}
				}

				while (remainingDifferentiatedEquations) {
				    System.out.println("----------------");
					// Step 3: Extract differentiated equations from block
					ArrayList<FAbstractEquation> hh = new ArrayList<FAbstractEquation>();
					for (FAbstractEquation fe : gg) {
						if (fe.getMeIntegrated()!=null) {
							hh.add(fe);
						}
					}
					h.add(hh);
									
					// Step 4: Select independent columns: simple matching in this case
					BiPGraph gd = new BiPGraph("","");
					
					for (FVariable fv : zz) {
						gd.addVariable(fv.name(),"",fv);     
					}
				
					int k = 1;
					Eq eqn = null;
					Var v = null;
					for (FAbstractEquation e : hh) {
			
						int n_eq = e.numScalarEquations();
				
						for (int i=0;i<n_eq;i++) {
							System.out.println("*** " + e.prettyPrint(""));
							eqn = gd.addEquation("eq_"+k,e.prettyPrint(""),e);
							k++;
				
							for (FVariable y : e.variables()) { 
								System.out.println(" ** " + y.prettyPrint("") + " " + zz.contains(y));
								if (zz.contains(y)) {
									v = gd.getVariable(y.name()); 
									gd.addEdge(eqn,v);
								} 
							} 
						}
					}
					
					System.out.println(gd.toString());
					gd.maximumMatching(true);	
					System.out.println(gd.printMatching());
					
					ArrayList<FVariable> zzHat = new ArrayList<FVariable>();
					for (Var vv : gd.getMatchedVariables()) {
						zzHat.add(vv.getVariable());
					}
					zHat.add(zzHat);
					
					// Step 5: prepare for next iteration
									// Step 1: Initialize
					gg = new ArrayList<FAbstractEquation>();
					for (FAbstractEquation ee : hh) {
						gg.add(ee.getMeIntegrated());
					}
					g.add(gg);		
							
					zz = new ArrayList<FVariable>();
					for (FVariable fv : zzHat) {
						FVariable zz_test = fv.getMeIntegrated();
						if (zz_test.isDerivativeVariable()) {
							FRealVariable frv = (FRealVariable)zz_test.getMeIntegrated();
							if (frv!=null && frv.stateSelectAttribute()!=FRealVariable.StateSelect.ALWAYS) {
								zz.add(zz_test);
							}
						} else {
							zz.add(zz_test);
						}
					}
					z.add(zz);
								
					remainingDifferentiatedEquations = false;
					for (FAbstractEquation fe : gg) {
						if (fe.getMeIntegrated()!=null) {
							remainingDifferentiatedEquations = true;
						}
					}
					
				}
		
				System.out.println(" --- Reduced System --- ");
				System.out.println(" Equations: ");
				for (ArrayList<FAbstractEquation> l : g) {
					for (FAbstractEquation fe : l) {
						System.out.println(fe.prettyPrint("   "));
					}
					System.out.println("");
				}

				System.out.println(" Dummy derivatives: ");
				for (ArrayList<FVariable> l : zHat) {
					for (FVariable fv : l) {
						result.addDummyDerivative(fv);
						System.out.println(fv.prettyPrint("   "));
					}
					System.out.println("");
				}


				System.out.println(" --- *** --- ");

			}
				
		}
		return result;
	}
	
	public ArrayList<Eq> getUnmatchedEquations() {
		ArrayList<Eq> l = new ArrayList<Eq>();
		for (Eq e : equations) {
			if (e.getMatching()==null) {
				l.add(e);
			}
		}
		return l;
	}

	public ArrayList<Var> getUnmatchedVariables() {
		ArrayList<Var> l = new ArrayList<Var>();
		for (Var v : variableMap.values()) {
			if (v.getMatching()==null) {
				l.add(v);
			}
		}
		return l;
	}

	public ArrayList<Eq> getMatchedEquations() {
		ArrayList<Eq> l = new ArrayList<Eq>();
		for (Eq e : equations) {
			if (e.getMatching()!=null) {
				l.add(e);
			}
		}
		return l;
	}

	public ArrayList<Var> getMatchedVariables() {
		ArrayList<Var> l = new ArrayList<Var>();
		for (Var v : variableMap.values()) {
			if (v.getMatching()!=null) {
				l.add(v);
			}
		}
		return l;
	}
	
	private int index = 0;
    private Stack<Eq> S;
    private LinkedList<Stack<Eq>> components;
		
    /* This is an implementation of the recursive Tarjan's algorithm.
     * Possibly it is less efficient than the non-recursive version, but
     * it seems to work fine.
     */
	public BLT computeBLT() {
		
		index = 0;
        S = new Stack<Eq>();
        components = new LinkedList<Stack<Eq>>();
        tarjanReset();
        
        for (Eq e : getEquations()) {
        	if (!e.isVisited()) {
        		tarjan(e);
        	}
        }
				
        BLT blt = new BLT();
        
        Var v = null;
		for (Stack<Eq> bl : components) {
			EquationBlock b = new EquationBlock();
			blt.add(b);
			// TODO: handle the case of multiple scalar equations in
			// one block
			for (Eq bl_eqn : bl) {
				v = bl_eqn.getMatching();
				MatchingPair mp = new MatchingPair(bl_eqn.getEquation(),v.getVariable());
				b.addMatchingPair(mp);
			}
		}
		return blt;
	}
	
	public LinkedList<Stack<Eq>> computeRawBLT() {
		index = 0;
        S = new Stack<Eq>();
        components = new LinkedList<Stack<Eq>>();
        tarjanReset();
        
        for (Eq e : getEquations()) {
        	if (!e.isVisited()) {
        		tarjan(e);
        	}
        }
        
        return components;	
	}
	
	public void tarjan(Eq e) {
		S.add(e);
		e.setTarjanNbr(index);
		e.setTarjanLowLink(index);
		e.setVisited(true);
		index++;
		for (Var v : e.getVariables()) {
			Eq ee = v.getMatching();
			if (!(e==ee)) {
				if (!ee.isVisited()) {
					tarjan(ee);
					e.setTarjanLowLink(Math.min(
							e.getTarjanLowLink(),ee.getTarjanLowLink()));
				} else if (S.contains(ee)) {
					e.setTarjanLowLink(Math.min(
							e.getTarjanLowLink(),ee.getTarjanNbr()));
				}
			}
 		}
		if (e.getTarjanNbr()==e.getTarjanLowLink()) {
			Stack<Eq> component = new Stack<Eq>();
			boolean done = false;
			while (!done) {
				Eq ee = S.pop();
				component.add(ee);
				if (ee==e) {
					done = true;
				}
			}
			components.add(component);
		}
	}
	
    public LinkedList<Stack<Eq>> _computeBLT() {

        int nbr = 0;
        Stack<Eq> stack = new Stack<Eq>();
        Stack<Eq> eStack = new Stack<Eq>();

        LinkedList<Stack<Eq>> components = new LinkedList<Stack<Eq>>();

        for (Eq eqn : getEquations()) {
//        while (!activeEqns.empty()) {
 //           Equation eq = activeEqns.pop();

            System.out.println("-------- tarjan start: " + eqn);

            if (eqn.getTarjanNbr() == 0) {
                eqn.setTarjanNbr(++nbr);
                eqn.setTarjanLowLink(nbr);

//                System.out.println("push: " + eqn);
                stack.push(eqn);
                eStack.push(eqn);

                while (!stack.empty()) {
                    eqn = stack.peek();
                    Var var = eqn.getNextVariable();
                    
                    if (var != null) {
//                        System.out.println("top: " + eqn + " - " + var);
                        Eq eqn2 = var.getMatching();
                        
                        if (/*eqn!=eqn2 &&*/ eqn2.getTarjanNbr() == 0) {
                        	System.out.println("***** tarjan start 2: " + eqn2);
                        	eqn2.setTarjanNbr(++nbr);
                            eqn2.setTarjanLowLink(nbr);
                            
//                            System.out.println("push: " + eqn2);

                            stack.push(eqn2); // recurse
                            eStack.push(eqn2);
                        } else if (eqn2.getTarjanNbr() < eqn.getTarjanNbr()) {
                            if (eStack.contains(eqn2)) {
                                eqn.setTarjanLowLink(Math.min(eqn.getTarjanLowLink(), 
                                                          	eqn2.getTarjanNbr()));
                            }
                        }
                    } else {
                    	  System.out.println("tarjan stack: " + eqn);
                    	  for (Eq ee : eStack) {
                    		  System.out.println(ee + ".index: " + ee.getTarjanNbr() + " " + ee + ".lowlink: " + ee.getTarjanLowLink());
                    	  }
//                        System.out.println("top: " + eqn + 
//                            " - exhausted variables (estack = " + eStack.size() + ")");

                        if (eqn.getTarjanLowLink() == eqn.getTarjanNbr()) {
                        	System.out.println("Heppp---------------");
                            // 'eq' is the root of a strong component
                            if (!eStack.empty()) {
                                // new strong component
                                System.out.println("Strong component:");
                                Eq eqn2 = eStack.peek();

								/*
                                System.out.println("this: " + eq + " (" + 
                                                   eq.getTarjanNbr() + ", " + 
                                                   eq.getTarjanLink() + ")");
                                System.out.println("that: " + eq2 + " (" + 
                                                   eq2.getTarjanNbr() + ", " + 
                                                   eq2.getTarjanLink() + ")");
                               
                                System.out.print(" ");
								*/
                                Stack<Eq> comp = new Stack<Eq>();
                                while (eqn2.getTarjanNbr() >= eqn.getTarjanNbr()) {
                                    eqn2 = eStack.pop();

                                    comp.push(eqn2);
									
                                    System.out.println("In COMPONENT: (" + eqn2 + 
                                                     ", " + eqn2.getMatching() + ")");
													 

                                    if (eStack.empty()) {
                                        break;
                                    } else {
                                        eqn2 = eStack.peek();
										/*
                                        System.out.println("that: " + eqn2 + " (" + 
                                                   eqn2.getTarjanNbr() + ", " + 
                                                   eqn2.getTarjanLink() + ")");
										*/
                                    }
                                }

                                if (!comp.empty()) {
                                    components.addLast(comp);
                                }
                            }
                        }

                        Eq eqn2 = stack.pop();
                        System.out.println("pop: " + eqn2);
                        if (!stack.empty()) {
                            eqn.setTarjanLowLink(Math.min(eqn.getTarjanLowLink(), 
                                                      eqn2.getTarjanLowLink()));
                        }
                    }
                }
            }
        }

		return components;

    }
	
	/*
	public void randomTest(int n_eq, int n_var, int n_ed) {
		
		BiPGraph g = new BiPGraph("Random Graph","");
		
		for (int i=0;i<n_eq;i++) {
			g.addEquation("e_"+(i+1), "");
		}

		for (int i=0;i<n_var;i++) {
			g.addVariable("v_"+(i+1), "");
		}

		Random r = new Random();
		for (int i=0;i<n_ed;i++) {
			boolean added=false;
			while (!added) {
				int e_ind = r.nextInt(n_eq) + 1;
				int v_ind = r.nextInt(n_var) + 1;
				if (g.addEdge("e_"+e_ind,"v_"+v_ind)) {
					added = true;
				}
			}
		}
		
		//System.out.println(g);
		long before = System.currentTimeMillis();
		g.maximumMatching(true);
		long after = System.currentTimeMillis();
		System.out.println("Matching n_equations="+n_eq+" n_variables="+n_var+" n_edges="+n_ed+" --- " + (((double)(after-before))/1000.));
		
		//System.out.println(g.printMatching());
		
	}
	*/
	
	public void reset() {
		for (Eq e : getEquations()) {
			e.reset();
		}		
		for (Var v : variableMap.values()) {
			v.reset();
		}		
	}

	public void lightReset() {
		for (Eq e : getEquations()) {
			e.lightReset();
		}		
		for (Var v : variableMap.values()) {
			v.lightReset();
		}		
	}

	public void tarjanReset() {
		for (Eq e : getEquations()) {
			e.tarjanReset();
		}		
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public ArrayList<Eq> getEquations() {
		return equations;
	}

	public void insertIntoEquationIndexMap(FAbstractEquation eqn, Eq e) {
		ArrayList<Eq> l = equationIndexMap.get(eqn);
		if (l==null) {
			l = new ArrayList<Eq>();
			equationIndexMap.put(eqn, l);
		}
		l.add(e);
	}

	public void removeFromEquationIndexMap(FAbstractEquation eqn, Eq e) {
		ArrayList<Eq> l = equationIndexMap.get(eqn);
		if (l!=null) {
			l.remove(e);
		}
	}
	
	public String printMatching() {
		StringBuffer str = new StringBuffer();
		str.append("----------------------------------------\n");
		str.append("BiPGraph " + getName() + " matching:\n");
		for (Eq e : getEquations()) {
			if (e.getMatching()!=null) {
				str.append(e.getName());
//				str.append(e.getName() + "(" + e.getDescription() + ")");
				str.append(" : ");
				str.append(e.getMatching().getName());
				str.append("\n");
			}
		}		
		str.append("Unmatched equations: {");
		for (Eq e : getUnmatchedEquations()) {
			str.append(e.getName() + " ");
		}
		str.append("}\n");

		str.append("Unmatched variables: {");
		for (Var v : getUnmatchedVariables()) {
			str.append(v.getName() + " ");
		}
		str.append("}\n");

		str.append("----------------------------------------\n");
		return str.toString();
	}
	
	public String toString() {
		StringBuffer str = new StringBuffer();
		str.append("BiPGraph " + getName() + "\n");
		if (!getDescription().equals("")) {
			str.append(" (");
			str.append(getDescription());
			str.append(")\n");
		}
		str.append("Variables: {");
		for (String vName : variableMap.keySet()) {
			Var v = variableMap.get(vName);
			str.append(v.getName());
			str.append(" ");
		}
		str.append("}\n");
		for (Eq e : getEquations()) {
			str.append(e.getName());
			str.append(" : ");
			for (Var v : e.getVariables()) {
				str.append(v.getName() + " ");
			}
			str.append("\n");
		}
		return str.toString();
	}
	
    class Edge {
    	private Var variable;
    	private Eq equation;
    	
    	public Edge(Eq e, Var v) {
    		this.equation = e;
    		this.variable = v;
    	}

		public Var getVariable() {
			return variable;
		}

		public void setVariable(Var variable) {
			this.variable = variable;
		}

		public Eq getEquation() {
			return equation;
		}

		public void setEquation(Eq equation) {
			this.equation = equation;
		}
    	
		public String toString() {
			return "(" + equation.getName() + "," + variable.getName() + ")";
		}
    	
    }
}

public class Eq {

	private String name;
	private ArrayList<Var> variables = new ArrayList<Var>();
	private Iterator<Var> varIterator;
	private Var matching = null;
    private boolean visited = false;
    private int layer = 1000000;
    private String description;
    private FAbstractEquation eqn;
	private Eq meDifferentiated = null;
	private Eq meIntegrated = null;

	private int tarjanNbr = 0;
    private int tarjanLowLink = 0;

	public Eq(String name,String description) {
		this.name = name;
		this.description = description;
	}
	
	public Eq(String name,String description,FAbstractEquation eqn) {
		this(name,description);
		this.eqn = eqn;
	}
			
	public void addVariable(Var v) {
		variables.add(v);
	}

	public void reset() {
		setMatching(null);
		setVisited(false);
		setLayer(1000000);
	}

	public void lightReset() {
		setVisited(false);
		setLayer(1000000);
	}
	
	public void tarjanReset() {
		setTarjanLowLink(0);
		setTarjanNbr(0);
		resetVariableIterator();
		setVisited(false);
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public ArrayList<Var> getVariables() {
		return variables;
	}

	public Var getMatching() {
		return matching;
	}

	public void setMatching(Var matching) {
		this.matching = matching;
	}

	public boolean isVisited() {
		return visited;
	}

	public void setVisited(boolean visited) {
		this.visited = visited;
	}

	public int getLayer() {
		return layer;
	}

	public void setLayer(int layer) {
		this.layer = layer;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}	
	 
	public int getTarjanNbr() {
		return tarjanNbr;
	}

	public void setTarjanNbr(int tarjanNbr) {
		this.tarjanNbr = tarjanNbr;
	}

	public int getTarjanLowLink() {
		return tarjanLowLink;
	}

	public void setTarjanLowLink(int tarjanLowLink) {
		this.tarjanLowLink = tarjanLowLink;
	}

	public void setMeDifferentiated(Eq e) {
		this.meDifferentiated = e;
		this.getEquation().setMeDifferentiated(e.getEquation());
	}
	
	public Eq getMeDifferentiated() {
		return this.meDifferentiated;
	}

	public void setMeIntegrated(Eq e) {
		this.meIntegrated = e;
		this.getEquation().setMeIntegrated(e.getEquation());
	}
	
	public Eq getMeIntegrated() {
		return this.meIntegrated;
	}
	
    public void resetVariableIterator() {
        varIterator = variables.iterator();
    }

    public Var getNextVariable() {
        if (varIterator == null) {
            resetVariableIterator();
        }

        if (!varIterator.hasNext()) {
            return null;
        }

        return varIterator.next();
    }
	    
	public String toString() {
		return getName();
	}

	public FAbstractEquation getEquation() {
		return eqn;
	}
		
	public void setEquation(FAbstractEquation eqn) {
		this.eqn = eqn;
	}


}

public class Var {

	private String name;
	private String description;
	private Eq matching = null;
	private boolean visited = false;
	private int layer = 1000000;
	private FVariable v;
	private Var meDifferentiated = null; // A reference to this variable differentiated once
	private Var meIntegrated = null;
	
	public Var(String name, String description) {
		this.name = name;
		this.description = description;
	}

	public Var(String name, String description, FVariable v) {
		this(name,description);
		this.v = v;
	}
		
	public void reset() {
		setMatching(null);
		setVisited(false);
		setLayer(1000000);
	}

	public void lightReset() {
		setVisited(false);
		setLayer(1000000);
	}
	
	public String getName() {
		return name;
	}

	public void setName(String name) {
		this.name = name;
	}

	public String getDescription() {
		return description;
	}

	public void setDescription(String description) {
		this.description = description;
	}

	public Eq getMatching() {
		return matching;
	}

	public void setMatching(Eq matching) {
		this.matching = matching;
	}

	public boolean isVisited() {
		return visited;
	}

	public void setVisited(boolean visited) {
		this.visited = visited;
	}

	public int getLayer() {
		return layer;
	}

	public void setLayer(int layer) {
		this.layer = layer;
	}
	
	public FVariable getVariable() {
		return v;
	}
		
	public void setVariable(FVariable v) {
		this.v = v;
	}
	
	public void setMeDifferentiated(Var var) {
		this.meDifferentiated = var;
		this.getVariable().setMeDifferentiated(var.getVariable());
	}
	
	public Var getMeDifferentiated() {
		return this.meDifferentiated;
	}

	public void setMeIntegrated(Var var) {
		this.meIntegrated = var;
		this.getVariable().setMeIntegrated(var.getVariable());
	}
	
	public Var getMeIntegrated() {
		return this.meIntegrated;
	}
	
	public String toString() {
		return getName();
	}
	
}

public class IndexReductionResult {

	private ArrayList<FAbstractEquation> addedEquations;
	private ArrayList<FVariable> dummyDerivatives;

	public IndexReductionResult() {
		addedEquations = new ArrayList<FAbstractEquation>();
		dummyDerivatives = new ArrayList<FVariable>();
	}
	
	public void addEquation(FAbstractEquation fe) {
		addedEquations.add(fe);	
	}

	public void addDummyDerivative(FVariable fv) {
		dummyDerivatives.add(fv);	
	}

	public ArrayList<FAbstractEquation> getEquations() {
		return addedEquations;
	}

	public ArrayList<FVariable> getDummyDerivatives() {
		return dummyDerivatives;
	}

}

}