/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.HashSet;

aspect InstLookupComponents {

	inh lazy HashSet InstAccess.lookupInstComponent(String name);	
	inh lazy HashSet InstNode.lookupInstComponent(String name);	
	eq InstBaseClassDecl.getChild().lookupInstComponent(String name) = genericLookupInstComponent(name); 	
	eq InstNode.getChild().lookupInstComponent(String name) = genericLookupInstComponent(name); 
	
	eq InstComponentDecl.getInstModification().lookupInstComponent(String name) = lookupInstComponent(name);
	eq InstReplacingComposite.getOriginalInstComponent().lookupInstComponent(String name) = lookupInstComponent(name);
	eq InstReplacingPrimitive.getOriginalInstComponent().lookupInstComponent(String name) = lookupInstComponent(name);
	eq InstExtends.getInstClassModification().lookupInstComponent(String name) = lookupInstComponent(name);
	
	eq InstValueModification.getFExp().lookupInstComponent(String name) = myInstNode().lookupInstComponent(name);
	
	eq InstShortClassDecl.getChild().lookupInstComponent(String name) = lookupInstComponent(name);

	eq InstComponentDecl.getFArraySubscripts().lookupInstComponent(String name) = lookupInstComponent(name);
	
	eq InstPrimitive.getChild().lookupInstComponent(String name) = myInstClass().memberInstComponent(name); 
	eq InstPrimitive.getInstModification().lookupInstComponent(String name) = lookupInstComponent(name);
	eq InstPrimitive.getFArraySubscripts().lookupInstComponent(String name) = lookupInstComponent(name);
	eq InstPrimitive.getBindingFExp().lookupInstComponent(String name) = lookupInstComponent(name);
	eq InstPrimitive.getDynamicFExp().lookupInstComponent(String name) = lookupInstComponent(name);
	
	eq InstRoot.getChild().lookupInstComponent(String name) = emptyHashSet();
	
	eq InstDot.getRight().lookupInstComponent(String name) = getLeft().qualifiedLookupInstComponent(name);
	eq InstArrayAccess.getFArraySubscripts().lookupInstComponent(String name) = getTopAccess().lookupInstComponent(name);
		
	syn lazy HashSet InstAccess.qualifiedLookupInstComponent(String name) = emptyHashSet();
	eq InstComponentAccess.qualifiedLookupInstComponent(String name) = myInstComponentDecl().memberInstComponent(name);	
	eq InstClassAccess.qualifiedLookupInstComponent(String name) = myInstClassDecl().memberInstComponent(name);

	eq SourceRoot.getChild().lookupInstComponent(String name) = emptyHashSet();
	// This equation is necessary since InstAccesses may be present in FExps.	
	eq FlatRoot.getChild().lookupInstComponent(String name) = emptyHashSet();

	inh lazy HashSet InstForClauseE.lookupInstComponent(String name);
	eq InstForClauseE.getChild().lookupInstComponent(String name) {
		HashSet set = new HashSet(4);
		for (InstForIndex ifi : getInstForIndexs()) {
			if (ifi.getInstPrimitive().name().equals(name)) {
				set.add(ifi.getInstPrimitive());
			}
		}
		return (set.size() > 0) ? set : lookupInstComponent(name);
	}
	
	inh lazy HashSet InstForStmt.lookupInstComponent(String name);
	eq InstForStmt.getChild().lookupInstComponent(String name) {
		HashSet set = new HashSet(4);
		for (InstForIndex ifi : getInstForIndexs()) {
			if (ifi.getInstPrimitive().name().equals(name)) {
				set.add(ifi.getInstPrimitive());
			}
		}
		return (set.size() > 0) ? set : lookupInstComponent(name);
	}
	
	inh lazy HashSet FIterExp.lookupInstComponent(String name);
	eq FIterExp.getChild().lookupInstComponent(String name) {
		HashSet set = new HashSet(4);
		for (CommonForIndex fi : getForIndexs()) {
			if (fi instanceof InstForIndex) {
				InstForIndex ifi = (InstForIndex) fi;
				if (ifi.getInstPrimitive().name().equals(name)) 
					set.add(ifi.getInstPrimitive());
			}
		}
		return (set.size() > 0) ? set : lookupInstComponent(name);
	}

	
	syn lazy HashSet InstNode.genericLookupInstComponent(String name) {
		HashSet set = new HashSet(4);
		set.addAll(memberInstComponent(name));
		for (InstImport ii : instImports()) 
			set.addAll(ii.lookupInstConstantInImport(name));		
		if (set.isEmpty())
			set.addAll(lookupInstConstant(name));
		return set.isEmpty() ? emptyHashSet() : set;
	 }
	
	syn lazy HashSet InstNode.memberInstComponent(String name)  {

		if (isArray()) {
			int ndims = ndims();
			InstNode n = getInstComponentDecl(0);
			for (int i=0;i<ndims-1;i++) {
				n = n.getInstComponentDecl(0);
			}
			return n.memberInstComponent(name);
			
		} else {	
			HashSet set = new HashSet(4);
		 	
			for (InstComponentDecl ic : constrainingInstComponentDecls()) {
				if (ic.matchInstComponentDecl(name))
					set.add(ic);
			}

			for (InstExtends ie : constrainingInstExtends()) {
				set.addAll(ie.memberInstComponent(name));
			}
		
			return (set.size() > 0) ? set : emptyHashSet();
		}
	}
	
	inh lazy HashSet InstNode.lookupInstConstant(String name);
	eq Root.getChild().lookupInstConstant(String name) = emptyHashSet();
	eq InstNode.getChild().lookupInstConstant(String name) {
		HashSet set = new HashSet(4);
		set.addAll(memberInstConstant(name));
		if (set.isEmpty())
			set.addAll(lookupInstConstant(name));
		return set.isEmpty() ? emptyHashSet() : set;
	}
	
	syn lazy HashSet InstNode.memberInstConstant(String name) {
		HashSet set = new HashSet(4);
		for (InstComponentDecl ic : constrainingInstComponentDecls()) {
			if (ic.getComponentDecl().isConstant() && ic.matchInstComponentDecl(name))
				set.add(ic);
		}
		return set.isEmpty() ? emptyHashSet() : set;
	}

	syn HashSet InstImport.lookupInstConstantInImport(String name) {
		// Assume import points to a single (constant) component
	    if (name.equals(name())) {
	    	String className = getPackageName().enclosingName();
	    	if (!className.equals("")) {
		    	InstClassDecl icd = ((SourceRoot)root()).getProgram().getInstProgramRoot().
		           simpleLookupInstClassDecl(className);
		    	return icd.memberInstConstant(getPackageName().getLastInstAccess().name());
	    	}
		}
		return emptyHashSet();
	}
	
	eq InstImportUnqualified.lookupInstConstantInImport(String name)  {
        return getImportedClass().memberInstConstant(name);
	}

	// This is needed since the member components of InstPrimitive:s (which are attributes)
	// are not instantiated
	eq InstPrimitive.memberInstComponent(String name) = myInstClass().memberInstComponent(name);
	eq InstExtends.memberInstComponent(String name) = extendsPrimitive()? myInstClass().memberInstComponent(name) : super.memberInstComponent(name);

	/**
	 * Simple matching of component names.
	 */
	syn boolean InstComponentDecl.matchInstComponentDecl(String name) = name().equals(name);
	
	syn lazy InstComponentDecl InstAccess.myInstComponentDecl() = unknownInstComponentDecl();
	eq InstComponentAccess.myInstComponentDecl() {
		HashSet set = lookupInstComponent(name());
		if (set.size() > 0) {
			return (InstComponentDecl)set.iterator().next();
		} else
			return unknownInstComponentDecl();
	}
	
	eq InstDot.myInstComponentDecl() {
		return getRight().myInstComponentDecl();
	}
	
	/*
	inh HashSet ForClauseE.lookupComponent(String name);	
	eq ForClauseE.getForEqns().lookupComponent(String name) {
		HashSet set = new HashSet(4);
		for (int i=0;i<getNumForIndex();i++) {
			if (getForIndex(i).getForIndexDecl().matchComponentDecl(name)) {
				set.add(getForIndex(i).getForIndexDecl());	
				return set;
			}
		}
		return lookupComponent(name);
	}

	
}

aspect LookupInstComponentSlices {
	
	syn lazy InstComponentDecl[] InstAccess.slice() = new InstComponentDecl[0];
	
	eq InstComponentAccess.slice() {
		
		// Access refers to scalar declaration or, access has no array 
		// subscripts but refers to array declaration
		if (!hasFArraySubscripts()) {
			ArrayList<InstComponentDecl> slice = 
				new ArrayList<InstComponentDecl>();
			InstComponentDecl[] decls = myInstComponentDecls();
			for (int i=0;i<decls.length;i++) {
				InstComponentDecl[] slice_tmp = 
					decls[i].slice(); 
				for (int j=0;j<slice_tmp.length;j++) {
					slice.add(slice_tmp[j]);
				}
			}
			InstComponentDecl[] slice_array = new InstComponentDecl[slice.size()];
			slice.toArray(slice_array);
			return slice_array;
		} else { // Access has array subscripts
			ArrayList<InstComponentDecl> slice = 
				new ArrayList<InstComponentDecl>();
			InstComponentDecl[] decls = myInstComponentDecls();
			for (int i=0;i<decls.length;i++) {
				InstComponentDecl[] slice_tmp = 
					decls[i].slice(getFArraySubscripts()); 
				for (int j=0;j<slice_tmp.length;j++) {
					slice.add(slice_tmp[j]);
				}
			}
			InstComponentDecl[] slice_array = new InstComponentDecl[slice.size()];
			slice.toArray(slice_array);
			return slice_array;
		}
	}

	syn lazy InstComponentDecl[] InstComponentDecl.slice() {
		if (!hasFArraySubscripts()) { // Scalar variable
			InstComponentDecl s[] = new InstComponentDecl[1];
			s[0] = this;
			return s;
		} else { // Array declaration: return all "leaf" InstArrayComponentDecls
			int size[] = size();
			int n_s = 1;
			// Compute the number of InstComponentDecls to return
			for (int i=0;i<size.length;i++) {
				n_s = n_s*size[i];
			}
			// Create vector of InstComponentDecls
			InstComponentDecl icds[] = new InstComponentDecl[n_s];
			// The current InstComponentDecl has n_s children of type
			// InstArrayComponentDecl. Each sub-AST consists of a chain of
			// size.length InstArrayComponentDecls where each such node has 
			// exactly one child, exept the last ones. The slice operation collects all 
			// InstArrayComponentDecls that are at the end of each sub-AST
			// chain.
			for (int i=0;i<n_s;i++) {
				icds[i] = getInstComponentDecl(i);
				for (int j=0;j<size.length-1;j++) {
					icds[i] = icds[i].getInstComponentDecl(0);
				}
			}
			return icds;			
		}
	}

	syn lazy InstComponentDecl[] InstComponentDecl.slice(FArraySubscripts fas) {
		int ndims = ndims(); // Number of dimensions of decl
		// Create an ArrayList first, then convert to array
		ArrayList<InstComponentDecl> decls = new ArrayList<InstComponentDecl>();
		// Loop over all dimensions
		decls.add(this);
		for (int i=0;i<ndims;i++) {
			ArrayList<InstComponentDecl> decls_tmp = 
				new ArrayList<InstComponentDecl>();
			// Get the array of indices
			int[] indices = fas.getFSubscript(i).myIndices();
			// Loop over all declarations
			for (InstComponentDecl decl : decls) {
				// Loop over all indices
				for (int index : indices) {
					// TODO: check that value is inside of the bounds
					decls_tmp.add(decl.getInstComponentDecl(index-1));
				}
			}	
			decls = decls_tmp;
		}
		return decls.toArray(new InstComponentDecl[decls.size()]);
	}
	
	inh lazy InstComponentDecl[] InstAccess.predSlice();
	eq InstDot.getRight().predSlice() = getLeft().slice();
	eq Root.getChild().predSlice() = null;
	
	syn String InstAccess.printSlice() = "{}";
	eq InstComponentAccess.printSlice() {
		InstComponentDecl[] slice = slice();
		StringBuffer str = new StringBuffer();
		str.append("{");
		for (int i=0;i<slice.length;i++) {
			str.append(slice[i].name() + ", ");
		}
		str.append("}");
		return str.toString();
	}
}

aspect LookupInstComponents {

	syn lazy InstComponentDecl[] InstAccess.myInstComponentDecls() = 
		new InstComponentDecl[0];
	
	eq InstComponentAccess.myInstComponentDecls() {
		InstComponentDecl[] predSlice = predSlice();
		if (!myInstComponentDecl().isArray() || predSlice==null) { // Scalar variable
			InstComponentDecl[] decls = new InstComponentDecl[1];
			decls[0] = myInstComponentDecl();
			return decls;
		} else {
			InstComponentDecl[] decls = new InstComponentDecl[predSlice.length];
			for (int i=0;i<predSlice.length;i++) {
				HashSet<InstComponentDecl> set = 
					predSlice[i].memberInstComponent(name());
				if (set.size() != 1) {
					InstComponentDecl[] decls2 = new InstComponentDecl[1];
					decls2[0] = unknownInstComponentDecl();
					return decls2;
				} else {
					decls[i] = set.iterator().next();
				}
			}
			return decls;
		}
	}
		
}

aspect LookupInstComponentsInModifications {
      
    /**
     * The inherited attribute lookupInstComponentInInstElement defines 
     * the lookup mechanism for left hand component references in modifications.
     * InstComponents are looked up in InstComponentDecl:s sometimes and in InstClassDecl:s
     * sometimes. TODO: this should probably be fixed.
     * 
     */
	inh HashSet InstElementModification.lookupInstComponentInInstElement(String name);
	inh HashSet InstNamedModification.lookupInstComponentInInstElement(String name);
	
	eq InstElementModification.getName().lookupInstComponent(String name) = lookupInstComponentInInstElement(name);
	
	eq InstNamedModification.getName().lookupInstComponent(String name) = lookupInstComponentInInstElement(name);
	
	eq InstConstrainingClass.getInstClassModification().lookupInstComponentInInstElement(String name) = getClassName().myInstClassDecl().memberInstComponent(name);
	eq InstConstrainingComponent.getInstClassModification().lookupInstComponentInInstElement(String name) = getClassName().myInstClassDecl().memberInstComponent(name);
	     
	eq InstComponentDecl.getInstModification().lookupInstComponentInInstElement(String name) = getClassName().myInstClassDecl().memberInstComponent(name); 
	
	eq InstPrimitive.getInstModification().lookupInstComponentInInstElement(String name) = getClassName().myInstClassDecl().memberInstComponent(name); 
	
	eq InstElementModification.getInstModification().lookupInstComponentInInstElement(String name) = getName().myInstComponentDecl().memberInstComponent(name);
    
	eq InstExtends.getInstClassModification().lookupInstComponentInInstElement(String name) = getClassName().myInstClassDecl().memberInstComponent(name);
	
//	eq InstShortClassDecl.getInstClassModification().lookupInstComponentInInstElement(String name) = getClassName().myInstClassDecl().memberInstComponent(name);
	
	inh HashSet InstComponentRedeclare.lookupInstComponentInInstElement(String name);
	eq InstComponentRedeclare.getName().lookupInstComponent(String name) = lookupInstComponentInInstElement(name);
	
	eq InstRoot.getChild().lookupInstComponentInInstElement(String name) {return emptyHashSet();}
	eq FlatRoot.getChild().lookupInstComponentInInstElement(String name) {return emptyHashSet();}
	  
}

  