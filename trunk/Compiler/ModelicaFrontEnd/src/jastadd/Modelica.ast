/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * \mainpage API documentation of the JModelica.org Modelica Front-end
 *
 * The API documentation of the Modelica %compiler front-end is yet rudimentary. 
 * Also, the APIs for the Java classes contains several methods that are 
 * part of the internal JastAdd run-time system - these methods are not intended
 * to be used by the user.
 * 
 * We are currently working togehter with the JastAdd team to develop a 
 * documentation system where internal methods are hidden and where the user
 * API is exposed.
 *
 * The Modelica %compiler is organized into a number of different packages:
 * <ul>
 *   <li> org.jmodelica.modelica.parser containing parsers for Modelica
 *   and Flat Modelica code.</li>
 *   <li> org.jmodelica.modelica.compiler contains the actual %compiler, including
 *   the classes used to construct the Abstract Syntax Trees (ASTs) and the
 *   %compiler driver class ModelicaCompiler.</li>
 *   <li> org.jmodelica.util contains some helper classes which are independent
 *   of the AST classes.</li>
 * </ul>
 * 
 * Notice that the Java classes are not intended to be edited manually (with
 * the exception of the classes in org.jmodelica.util), but are rather 
 * automatically generated by the JastAdd tool. In order to extend or 
 * modify the functionality of the %compiler, edit the .%ast, .jrag and .jadd
 * files.
 *
 */


// Modelica abstract grammar



/**
 * \defgroup aspect_Flattening Aspect: Flattening
 */


/**
 * \package org.jmodelica.ast Package containing all AST classes.
 */

abstract Root ::= /DynamicArrayType:FPrimitiveType*/;

ParserHandler;

/**
 * A class representing the root node of a source AST.
 */
SourceRoot : Root ::= Program ;

Program ::= UnstructuredEntity:StoredDefinition* 
            /UnknownClassDecl/
            /UnknownComponentDecl/
            /PredefinedType:BaseClassDecl*/ 
            /BuiltInType:ClassDecl*/   
            /BuiltInFunction:BaseClassDecl*/
            /LibNode*/
            /InstProgramRoot/;

StoredDefinition ::= [Within] Element*;

Within ::= [PackageName:ParseAccess];

abstract ClassDecl : Element ::=;
abstract BaseClassDecl : ClassDecl::=VisibilityType 
									  [Encapsulated] 
	                                  [Partial] 
	                                  Restriction 
	                                  Name:IdDecl  
                                      [Redeclare]
	                                  [Final]
	                                  [Inner]
	                                  [Outer]
	                                  [Replaceable]
	                                  [ConstrainingClause]
                                      [ConstrainingClauseComment:Comment];

UnknownClassDecl : FullClassDecl::=;

PN_FullClassDecl : BaseClassDecl ::= [StringComment] 
                                       Composition 
                                       <EndName:String>;
	                      
FullClassDecl : BaseClassDecl ::= [StringComment]  
                                Equation:AbstractEquation* 
                                Algorithm*
                                Super:ExtendsClause*  
                                Import:ImportClause* 
                                ClassDecl* 
                                ComponentDecl*
                                Annotation* 
                                [ExternalClause] 
                                <EndName:String>;

LibClassDecl : FullClassDecl ::= LibNode*;
LibNode ::= <FileName:String> <Name:String> <Structured:boolean> <Version:String> /StoredDefinition/;

// TODO: Why does ShortClassDecl have type_prefix:es?
PN_ShortClassDecl : BaseClassDecl ::= [TypePrefixFlow] 
                                [TypePrefixVariability]
                                [TypePrefixInputOutput] 
                                ClassName:Access  
                                [ArraySubscripts] 
                                [ClassModification] 
                                Comment; 

ShortClassDecl : BaseClassDecl ::= ExtendsClauseShortClass;

ExtendsClauseShortClass : ExtendsClause ::= [TypePrefixFlow] 
                                [TypePrefixVariability]
                                [TypePrefixInputOutput] 
                                [ArraySubscripts] 
                                Comment; 
                            
ExtendClassDecl : BaseClassDecl ::= [ClassModification] [StringComment] Composition  <EndName:String>;
                                   
PrimitiveClassDecl : FullClassDecl::=;
RealClassDecl : PrimitiveClassDecl::=;
IntegerClassDecl : PrimitiveClassDecl::=;
BooleanClassDecl : PrimitiveClassDecl::=;
StringClassDecl : PrimitiveClassDecl::=;

BuiltInClassDecl : ClassDecl ::= Name:IdDecl;
//RealType : BuiltInClassDecl ::=;
//IntegerType : BuiltInClassDecl ::=;
//StringType : BuiltInClassDecl ::=;
//BooleanType : BuiltInClassDecl ::=;

ConstrainingClause ::= Access [ClassModification];

abstract Restriction;
Model : Restriction::=;
Block : Restriction::=;
MClass : Restriction::=;
Connector : Restriction::=;
ExpandableConnector : Connector::=;
MType : Restriction::=;
MPackage : Restriction::=;
Function : Restriction::=;
Record : Restriction::=;

Replaceable::=;
Redeclare::=;
Encapsulated::=;
Partial::=;
Inner::=;
Outer::=;

abstract VisibilityType::=;
PublicVisibilityType : VisibilityType ::=;
ProtectedVisibilityType : VisibilityType ::=;
UnknownVisibilityType : VisibilityType ::=;

Composition ::= Clause* [AbstractExternalClause];

abstract AbstractExternalClause::=;

ExternalClause : AbstractExternalClause ::= [Language:StringWrapper] 
                                            [ReturnVar:Access] 
                                            [FunctionName:IdDecl]
                                            Args:Exp* 
                                            [Annotation1:Annotation] 
                                            [Annotation2:Annotation];

PN_ExternalClause : AbstractExternalClause ::= [Language:StringWrapper] 
                                               [PN_ExternalFunctionCall]
                                               [Annotation1:Annotation] 
                                               [Annotation2:Annotation];
                   
PN_ExternalFunctionCall ::= [ReturnVar:Access] FunctionName:IdDecl Args:Exp* ;

StringWrapper ::= <STRING>;

abstract Clause;

abstract ElementList : Clause ::= Element*;
PublicElementList : ElementList ::=;
ProtectedElementList : ElementList ::=;
EquationClause : Clause::= AbstractEquation*;
Algorithm : Clause ::= [Initial] Statement*;

abstract Element : Clause;
ElementAnnotation : Element ::= Annotation;
PN_ExtendsClause : Element ::= Super:Access [ClassModification] [Annotation];
ExtendsClause : Element ::= VisibilityType Super:Access [ClassModification] [Annotation];
abstract ImportClause : Element ::= PackageName:Access Comment;
ImportClauseQualified : ImportClause;
//ImportClauseSingleDefinition : ImportClause;
ImportClauseUnqualified : ImportClause;
ImportClauseRename : ImportClause ::= IdDecl;

abstract AbstractComponentDecl : Element;
UnknownComponentDecl : ComponentDecl;
abstract BaseComponentDecl : AbstractComponentDecl ::= [Redeclare] 
                                         [Final] 
                                         [Inner] 
                                         [Outer] 
                                         [Replaceable] 
                                         [TypePrefixFlow] 
                                         [TypePrefixVariability] 
                                         [TypePrefixInputOutput] 
                                         ClassName:Access 
                                         [TypeArraySubscripts:ArraySubscripts];

ComponentClause : BaseComponentDecl ::=  VisibilityType 
                                         Name:PN_ComponentDecl* 
                                         [ConstrainingClause] 
                                         Comment;

ComponentDecl : BaseComponentDecl ::= VisibilityType 
                                      Name:IdDecl 
                                      [VarArraySubscripts:ArraySubscripts] 
                                      [Modification] 
                                      [ConditionalAttribute]
                                      Comment 
                                      [ConstrainingClause] 
                                      CCComment:Comment;

PN_ComponentClause : BaseComponentDecl ::=  Name:PN_ComponentDecl* 
                                            [ConstrainingClause] 
                                            Comment;
                                            
PN_ComponentDecl ::= Name:IdDecl 
                     [VarArraySubscripts:ArraySubscripts] 
                     [Modification] 
                     [ConditionalAttribute]
                     Comment;

abstract TypePrefix;
abstract TypePrefixFlow : TypePrefix;
Flow : TypePrefixFlow::=;
abstract TypePrefixVariability : TypePrefix;
Continuous : TypePrefixVariability::=;
Discrete : TypePrefixVariability::=;
Parameter : TypePrefixVariability::=;
Constant : TypePrefixVariability::=;
abstract TypePrefixInputOutput : TypePrefix;
Input : TypePrefixInputOutput::=;
Output : TypePrefixInputOutput::=;

Comment::= [StringComment] [Annotation];
StringComment ::= <Comment:String>;

// Annotations and modifications
Each ::=;
Final ::=;

ConditionalAttribute ::= Exp;

abstract Modification::=;
CompleteModification : Modification ::= ClassModification [ValueModification];
ValueModification : Modification ::= Exp;
//AssignModification : Modification ::= Exp;

ClassModification : Modification ::= Argument*;
abstract Argument : Modification ::= [Each] [Final];

abstract NamedModification : Argument ::= Name:Access;
abstract ElementModification : NamedModification ::= [Modification] [StringComment];
// ClassModification : ElementModification; // is a(M.x=3) valid if M is a class?
ComponentModification : ElementModification; 
abstract ElementRedeclare : NamedModification ;
ClassRedeclare : ElementRedeclare ::= BaseClassDecl;
PN_ComponentRedeclare : ElementRedeclare ::= BaseComponentDecl;
ComponentRedeclare : ElementRedeclare ::= ComponentDecl;

abstract Annotation;

ParseAnnotation : Annotation  ::= ClassModification;

abstract AbstractExp;
abstract Exp : AbstractExp;

abstract AbstractEquationModifier;
abstract AbstractEquation ::= [AbstractEquationModifier] Comment;
Initial : AbstractEquationModifier ::=;
Equation : AbstractEquation ::= Left:Exp Right:Exp;
EquationAnnotation : AbstractEquation ::= Annotation;
ConnectClause : AbstractEquation ::= Comment Connector1:Access Connector2:Access;
ConditionalEquationE : AbstractEquation ::= IfExp:Exp IfEqns:AbstractEquation*
                                          ElseIfClauseE*
                                          ElseEqns:AbstractEquation*;
ElseIfClauseE ::= IfExp:Exp IfEqns:AbstractEquation*;
ForClauseE : AbstractEquation ::= ForIndex* AbstractEquation*;
ForIndex ::= ForIndexDecl [Exp];
// ForIndexDecl is introduced basically to make the name-analysis simpler:
// lookupDecl is supposed to return a ComponentDecls.
ForIndexDecl : ComponentDecl; // Is this really ok: FIXME! 
WhenClauseE : AbstractEquation ::= WhenExp:Exp WhenEqns:AbstractEquation*
                                   ElseWhenClauseE*;
ElseWhenClauseE ::= WhenExp:Exp WhenEqns:AbstractEquation*;         
FunctionCallEquation : AbstractEquation ::= Left:FunctionCallLeft* Call:FunctionCall;
FunctionCallLeft ::= [Access];
         
abstract Statement ::= Comment;
AssignStmt : Statement ::= Left:Access Right:Exp;
FunctionCallStmt : Statement ::= Left:FunctionCallLeft* FunctionCall;
BreakStmt : Statement;
ReturnStmt : Statement;
abstract IfWhenStmt : Statement ::= IfWhenClause*;
IfStmt : IfWhenStmt ::= ElseStmt:Statement*;
WhenStmt : IfWhenStmt;
abstract IfWhenClause ::= Test:Exp Statement*;
IfClause : IfWhenClause;
WhenClause : IfWhenClause;
ForStmt : Statement ::= ForIndex* ForStmt:Statement*;
WhileStmt : Statement ::= Test:Exp WhileStmt:Statement*;
AlgorithmAnnotation : Statement ::= Annotation;

IfExp : Exp ::= IfExp:Exp ThenExp:Exp ElseIfExp* ElseExp:Exp;
ElseIfExp : Exp ::= IfExp:Exp ThenExp:Exp;

abstract BinExp : Exp::= Left:Exp Right:Exp;

abstract ArtmBinExp : BinExp::=;
DotAddExp : ArtmBinExp::=;
DotSubExp : ArtmBinExp::=;
DotMulExp : ArtmBinExp::=;
DotDivExp : ArtmBinExp::=;
DotPowExp : ArtmBinExp::=; // Easy to make parser take care of this: should be a Primary
AddExp : DotAddExp::=;
SubExp : DotSubExp::=;
MulExp : DotMulExp::=;
DivExp : DotDivExp::=;
PowExp : DotPowExp::=; // Easy to make parser take care of this: should be a Primary
NegExp : Exp::= Exp;

RealLitExp : Exp ::= <UNSIGNED_NUMBER>;
IntegerLitExp : Exp ::= <UNSIGNED_INTEGER>;
StringLitExp : Exp ::= <STRING>;
//BooleanLitExp : Exp ::= <Value:boolean>;
FunctionCall : Exp ::= Name:Access [FunctionArguments];

FunctionArguments ::= Exp* ForIndex* NamedArgument*;
NamedArgument ::= Name:Access Exp;

SumRedExp : Exp ::= Exp ForIndex;

RangeExp : Exp ::= Exp*;

abstract LogBinExp : BinExp;
LtExp : LogBinExp;
LeqExp : LogBinExp;
GtExp : LogBinExp;
GeqExp : LogBinExp;
EqExp : LogBinExp;
NeqExp : LogBinExp;
NotExp : Exp ::= Exp;
OrExp : LogBinExp;
AndExp : LogBinExp;

abstract BooleanLitExp : Exp ::=;
BooleanLitExpTrue : BooleanLitExp;
BooleanLitExpFalse : BooleanLitExp;

IdDecl ::=<ID>;

DerExp : Exp ::= Exp;

AccessExp : Exp ::= Access;

abstract Access ::= <ID>;
Dot : Access ::= Left:Access Right:Access;

ArrayAccess : Access ::= [ArraySubscripts];

ParseAccess : ArrayAccess;
ClassAccess : Access;
AmbiguousAccess : ArrayAccess;

ComponentAccess : ArrayAccess;

ArrayConstructor : Exp ::= FunctionArguments;
Matrix : Exp ::= ExpList*;
ExpList : Exp ::= Exp*;

ArraySubscripts ::= Subscript*;
abstract Subscript;
ColonSubscript : Subscript::=;
ExpSubscript : Subscript ::= Exp;

TimeExp : Exp;
EndExp : Exp;

// Dummy node used in the compilation
PN_DummyClause : Clause ::=;

QName ::= QNamePart*;
QNamePart ::= <Name> QNameSubscript*;
QNameSubscript ::= <Value:Integer>;

