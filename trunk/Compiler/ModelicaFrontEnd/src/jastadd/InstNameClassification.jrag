/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect InstNameClassification {

	/**
	 * \brief Helper class for definition of kinds.
	 */
    abstract public class Kind {
    	static Kind CLASS_ACCESS          = new ClassAccess();
    	static Kind COMPONENT_ACCESS      = new ComponentAccess();
    	static Kind AMBIGUOUS_ACCESS      = new AmbigousAccess();
    	static Kind LAST_AMBIGUOUS_ACCESS = new LastAmbigousAccess();
    	
    	public boolean isClassAccess()     { return false; }
    	public boolean isComponentAccess() { return false; }
    	public boolean isAmbigousAccess()  { return false; }
    	
    	public abstract Kind predKind();
    	
    	static protected class ClassAccess extends Kind {
    		public Kind    predKind()      { return CLASS_ACCESS; }
    		public boolean isClassAccess() { return true; }
    	}
    	
    	static protected class ComponentAccess extends Kind {
    		public Kind    predKind()          { return AMBIGUOUS_ACCESS; }
    		public boolean isComponentAccess() { return true; }
    	}
    	
    	static protected class AmbigousAccess extends Kind {
    		public Kind    predKind()         { return AMBIGUOUS_ACCESS; }
    		public boolean isAmbigousAccess() { return true; }
    	}
    	
    	static protected class LastAmbigousAccess extends AmbigousAccess {
    		public Kind predKind() { return CLASS_ACCESS; }
    	}
    }
	
	
	rewrite InstParseAccess {
		to InstAccess {
			if (kind().isComponentAccess()) {
				//System.out.println("rewrite InstParseAccess " + name() + " component");
				    InstComponentAccess a = new InstComponentAccess(getID(),getFArraySubscriptsOpt());
					a.setStart(getStart());
					a.setEnd(getEnd());
					return a;
			} else if (kind().isClassAccess()) {
				//System.out.println("rewrite InstParseAccess " + name() + " class");
					InstClassAccess a =  new InstClassAccess(getID());
					a.setStart(getStart());
					a.setEnd(getEnd());
					return a;
			} else {
				//System.out.println("rewrite InstParseAccess " + name() + " ambiguous");
					InstAmbiguousAccess a = new InstAmbiguousAccess(getID(),getFArraySubscriptsOpt());
					a.setStart(getStart());
					a.setEnd(getEnd());
					return a;
			}
  		}
	}

	
	// TODO: Check this section so that all inh calls are caught at the right level
	/**
	 * Here a few cases are classified based on their context.
	 */
	inh Kind InstAccess.kind();
	eq InstRoot.getChild().kind() = Kind.AMBIGUOUS_ACCESS;
	eq FlatRoot.getChild().kind() = Kind.AMBIGUOUS_ACCESS;

	eq InstDot.getLeft().kind() {
	 	return getRightNoTransform().predKind();
	}

	eq InstExtends.getClassName().kind() = Kind.CLASS_ACCESS;
//	eq FunctionCall.getName().kind() = Kind.AMBIGUOUS_ACCESS;
	eq InstImport.getPackageName().kind() = Kind.LAST_AMBIGUOUS_ACCESS;
//	eq InstShortClassDecl.getClassName().kind() = Kind.CLASS_ACCESS;
	eq InstComponentDecl.getClassName().kind() = Kind.CLASS_ACCESS;	
	eq InstComponentModification.getName().kind() = Kind.COMPONENT_ACCESS;
	eq InstClassRedeclare.getName().kind() = Kind.CLASS_ACCESS;
	eq InstComponentRedeclare.getName().kind() = Kind.COMPONENT_ACCESS;
	eq InstFunctionCall.getName().kind() = Kind.CLASS_ACCESS;
	
	eq InstConstraining.getClassName().kind() = Kind.CLASS_ACCESS;
	eq InstNode.getDynamicComponentName().kind() = Kind.COMPONENT_ACCESS;
	eq InstNode.getDynamicClassName().kind() = Kind.CLASS_ACCESS;
    eq InstComponentRedeclare.getDynamicClassName().kind() = Kind.CLASS_ACCESS;
	eq InstConstrainingComponent.getDynamicClassName().kind() = Kind.CLASS_ACCESS;
	
	eq InstBaseClassDecl.getFAbstractEquation().kind() = Kind.AMBIGUOUS_ACCESS;	
		
	//eq InstFunctionCall.getName().kind() = Kind.CLASS_ACCESS;

	/**
	 * The attribute predKind defines the kind for the previous part of a 
	 * qualified name.
	 */
	syn Kind InstAccess.predKind() {
		return kind().predKind();
	}
	eq InstDot.predKind() {
		return getLeftNoTransform().predKind();
	}

}
aspect InstResolveAmbiguousNames {
	/**
	 * This rewrite determines whether an InstAmbiguousAccess is a InstTypeAcces or a
	 * InstComponentAccess by attempting type and component lookups respectively.
	 */
	boolean InstAmbiguousAccess.rewritten = false;
	rewrite InstAmbiguousAccess {
	    when(!rewritten) 
	    to InstAccess {
	    	//System.out.println("rewrite InstAmbiguousAccess begin " + name());
	  		if (!lookupInstComponent(name()).isEmpty()) {
		    	//System.out.println("rewrite InstAmbiguousAccess " + name() + " component");
     		    InstComponentAccess c = new InstComponentAccess(name(),getFArraySubscriptsOpt());
  	 			c.setStart(getStart());
  	 			c.setEnd(getEnd());
  	 			return c;
  		} else 
            if(!lookupInstClass(name()).isEmpty()) {		
    	    	//System.out.println("rewrite InstAmbiguousAccess " + name() + " class");
            	InstClassAccess t = new InstClassAccess(name()); 
    			t.setStart(getStart());
    			t.setEnd(getEnd());
  	 			return t;
  			}
  			rewritten = true;
	    	//System.out.println("rewrite InstAmbiguousAccess end " + name());
  			return this;
  		}
  	}
}


