/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.HashMap;

aspect Options {
	
	public OptionRegistry Root.options = new OptionRegistry();
		
	class Option {
		protected String key;
		protected String description;
			
		public Option(String key, String description) {
			this.key = key;
			this.description = description;
		}
	
		public String getKey() {
			return key;
		}

		public String getDescription() {
			return description;
		}
	
		public String toString() {
			return "\'"+key+"\': " + description; 
		}
		
	}
	
	class IntegerOption extends Option {
		protected int value;
		
		public IntegerOption(String key, String description, int value) {
			super(key, description);
			this.value = value;
		}
		
		public void setValue(int value) {
			this.value = value;
		}
		
		public int getValue() {
			return value;
		}
	}

	class StringOption extends Option {
		protected String value;
		
		public StringOption(String key, String description, String value) {
			super(key,description);
			this.value = value;
		}
		
		public void setValue(String value) {
			this.value = value;
		}
		
		public String getValue() {
			return value;
		}
	}

	class RealOption extends Option {
		protected double value;
		
		public RealOption(String key, String description, double value) {
			super(key, description);
			this.value = value;
		}
		
		public void setValue(double value) {
			this.value = value;
		}
		
		public double getValue() {
			return value;
		}
	}

	class BooleanOption extends Option {
		protected boolean value;
		
		public BooleanOption(String key, String description, boolean value) {
			super(key, description);
			this.value = value;
		}
		
		public void setValue(boolean value) {
			this.value = value;
		}
		
		public boolean getValue() {
			return value;
		}
	}

	class ModelicaLibraryOption extends Option {
		
		class LibrarySpec {
			String name;
			String version;
			String path;
			
			public LibrarySpec(String name, String version, String path) {
				this.name = name;
				this.version = version;
				this.path = path;
			}
		}
	
		protected ArrayList<LibrarySpec> libraries;
		
		public ModelicaLibraryOption() {
			super("modelica_path","Modelica libraries locations.");
			libraries = new ArrayList<LibrarySpec>();
		}
		
		public void addLibrary(String name, String version, String path) {
			libraries.add(new LibrarySpec(name,version,path));
		}
		
		public String getLibraryPath(String name, String version) {
			for (LibrarySpec ls : libraries) {
				if (ls.name.equals(name) && ls.version.equals(version))
					return ls.path;
			}
			return null;
		}
	}
	
	/**
	 * OptionRegistry contains all options for the compiler. Options
	 * can be created and retreived based on type: String, Integer etc.
	 * OptionRegistry also provides methods for handling paths
	 * to Modelica libraries.
	 */
	class OptionRegistry {
		
		HashMap<String,Option> optionsMap;
		
		public OptionRegistry() {
			optionsMap = new HashMap<String,Option>();
		
			// Options are created here. May want to read options from
			// file as well.
			createModelicaLibraryOption();
			createStringOption("default_msl_version","Default version of" +
					"the Modelica standard library.","3.0.1");
		}
		
		protected void createModelicaLibraryOption() {
			optionsMap.put("modelica_path", new ModelicaLibraryOption());
		}
		
		public void addModelicaLibrary(String name, String version, String path) {
			Option o = optionsMap.get("modelica_path");
			if (o == null) {
				createModelicaLibraryOption();
			}
			o = optionsMap.get("modelica_path");
			((ModelicaLibraryOption)o).addLibrary(name,version,path);
			
		}

		public String getModelicaLibraryPath(String name, String version) {
			Option o = optionsMap.get("modelica_path");
			if (o == null) {
				throw new UnknownOptionException("Unknown option modelica_path");
			} else if (o instanceof ModelicaLibraryOption) {
				return ((ModelicaLibraryOption)o).getLibraryPath(name,version);
			} else {
				throw new UnknownOptionException("Option: modelica_path is not of " +
						"of the expected type");
			}
		}
		
		protected void createIntegerOption(String key, String description,
				int defaultValue) {
			optionsMap.put(key,new IntegerOption(key, description,
					defaultValue));			
		}
		
		public void setIntegerOption(String key, int value) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof IntegerOption) {
				((IntegerOption)o).setValue(value);
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"integer type");
			}			
		}

		public int getIntegerOption(String key) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof IntegerOption) {
				return ((IntegerOption)o).getValue();
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"integer type");
			}
		}

		protected void createStringOption(String key, String description,
				String defaultValue) {
			optionsMap.put(key,new StringOption(key, description,
					defaultValue));			
		}
		
		public void setStringOption(String key, String value) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof StringOption) {
				((StringOption)o).setValue(value);
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"string type");
			}			
		}

		public String getStringOption(String key) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof StringOption) {
				return ((StringOption)o).getValue();
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"string type");
			}
		}
		
		protected void createRealOption(String key, String description,
				double defaultValue) {
			optionsMap.put(key,new RealOption(key, description,
					defaultValue));			
		}
		
		public void setRealOption(String key, double value) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof RealOption) {
				((RealOption)o).setValue(value);
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"real type");
			}			
		}

		public double getRealOption(String key) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof RealOption) {
				return ((RealOption)o).getValue();
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"real type");
			}
		}
		
		protected void createBooleanOption(String key, String description,
				boolean defaultValue) {
			optionsMap.put(key,new BooleanOption(key, description,
					defaultValue));			
		}
		
		public void setBooleanOption(String key, boolean value) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof BooleanOption) {
				((BooleanOption)o).setValue(value);
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"boolean type");
			}			
		}

		public boolean getBooleanOption(String key) {
			Option o = optionsMap.get(key);
			if (o == null) {
				throw new UnknownOptionException("Unknown option: "+key);
			} else if (o instanceof BooleanOption) {
				return ((BooleanOption)o).getValue();
			} else {
				throw new UnknownOptionException("Option: "+key +" is not of " +
						"boolean type");
			}
		}
	}
	
	class UnknownOptionException extends RuntimeException { 
		
		public UnknownOptionException(String message) {
			super(message);
		}
		
	}
	
	
}