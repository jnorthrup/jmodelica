/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect Constructors {

	/*
	public InstComposite.InstComposite(InstAccess a,
			                                   ComponentDecl cd,
			                                   Opt<InstModification> inst_mod_opt,
			                                   Opt<InstConstraining> inst_constr_opt) {
		this(a,new Opt<FArraySubscripts>(),cd,inst_mod_opt,inst_constr_opt);
	}
	*/
	
	/**
	 * \brief Constructs an equation that is not initial.
	 */
	public FEquation.FEquation(FExp left, FExp right) {
		this(new FNormalEquation(), left, right);
	}
	
	/**
	 * \brief Constructs a function call equation that is not initial.
	 */
	public FFunctionCallEquation.FFunctionCallEquation(List<FFunctionCallLeft> left, FAbstractFunctionCall call) {
		this(new FNormalEquation(), left, call);
	}
	
	/**
	 * \brief Constructs a connection clause that is not initial.
	 */
	public FConnectClause.FConnectClause(Opt<FStringComment> comment, FIdUseInstAccess left, FIdUseInstAccess right) {
		this(new FNormalEquation(), comment, left, right);
	}
	
	/**
	 * \brief Constructs a for clause equation that is not initial.
	 */
	public FForClauseE.FForClauseE(List<FForIndex> indices, List<FAbstractEquation> eqns) {
		this(new FNormalEquation(), indices, eqns);
	}
	
	/**
	 * \brief Constructs a for clause equation that is not initial.
	 */
	public InstForClauseE.InstForClauseE(List<InstForIndex> indices, List<FAbstractEquation> eqns) {
		this(new FNormalEquation(), indices, eqns);
	}
	
	/**
	 * \brief Constructs an algorithm block that is not initial.
	 */
	public FAlgorithmBlock.FAlgorithmBlock(List<FStatement> stmts) {
		this(new FNormalEquation(), stmts);
	}
	
	/**
	 * Constructs a real literal expression from a double.
	 */
	public FRealLitExp.FRealLitExp(double val) {
		this(String.valueOf(val));
	}
	
	/**
	 * Constructs an integer literal expression from an integer.
	 */
	public FIntegerLitExp.FIntegerLitExp(int val) {
		this(String.valueOf(val));
	}
	
	/**
	 * Constructs a boolean literal expression from a boolean.
	 */
	public static FBooleanLitExp FBooleanLitExp.createFBooleanLitExp(boolean val) {
		if (val)
			return new FBooleanLitExpTrue();
		else
			return new FBooleanLitExpFalse();
	}
	
	public ComponentDecl.ComponentDecl(boolean isParameter,
	                                   String type,
	                                   String name,
	                                   String bexp) {

		this(new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
	                             isParameter? new Opt(new Parameter()): new Opt(),      
                                 new Opt(),
                                 new ClassAccess(type),
                                 new Opt(),
                                 new PublicVisibilityType(),
                                 new IdDecl(name),
                                 new Opt(),
                        		 new Opt(),        
                                 new Opt(),
                                 new Comment(new Opt(),new Opt()),
                                 new Opt(),
                                 new Comment(new Opt(),new Opt()));
		
		Exp bexp_ast=null;
		
		if (!bexp.equals("")) {
		    //ModelicaParser mp = new ModelicaParser();
			//bexp_ast = mp.parseExpString(bexp);
			ParserHandler ph = new ParserHandler();
			try {
				bexp_ast = ph.parseExpString(bexp);
			} catch (Exception e) {	
				System.out.println("Error when parsing string");	
			}
			//debugPrint("ComponentDecl.ComponentDecl");
			//bexp_ast.dumpTreeBasic("");	
		    this.setModification(new ValueModification(bexp_ast));
        }                     	
	
	}
	
}

/*
 * Some algorithms are the same for many node types, but require a new node 
 * to be created of the same type as the node being processed. These methods allow 
 * those algorithms to be generalized.
 */
aspect InheritedFactoryMethods {
	
	/**
	 * \brief Create a new empty node.
	 * 
	 * Base implementation returns null - override for subclasses.
	 * Should be replaced with abstract method once all subclasses are added.
	 * Base implementation or abstract needed for abstract node classes with 
	 * declared (i.e. not inherited) children.
	 */
	public FExp    FExp.createEmptyNode()    { return null; }
	public FBinExp FBinExp.createEmptyNode() { return null; }

	public FAddExp FAddExp.createEmptyNode() { return new FAddExp(); }
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 *        
	 * If this throws NullPointerException, createEmptyNode() needs to be 
	 * implemented for specific class.
	 */
	public FBinExp FBinExp.createNode(FExp left, FExp right) {
		FBinExp node = createEmptyNode();
		node.setLeft(left);
		node.setRight(right);
		return node;
	}
	
}