/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Collection;

aspect Constructors {

	/*
	public InstComposite.InstComposite(InstAccess a,
			                                   ComponentDecl cd,
			                                   Opt<InstModification> inst_mod_opt,
			                                   Opt<InstConstraining> inst_constr_opt) {
		this(a,new Opt<FArraySubscripts>(),cd,inst_mod_opt,inst_constr_opt);
	}
	*/
	
	/**
	 * \brief Construct a List containing the same nodes as the given Collection.
	 */
	public List.List(Collection<T> nodes) {
		if (!nodes.isEmpty())
			setChild(null, nodes.size() - 1); // Ensure we won't need to increase size later
		int i = 0;
		for (T n : nodes)
			setChild(n, i++);
	}
	
	/**
	 * \brief Constructs a real literal expression from a double.
	 */
	public RealLitExp.RealLitExp(double val) {
		this(String.valueOf(val));
	}
	
	/**
	 * \brief Constructs an integer literal expression from an integer.
	 */
	public IntegerLitExp.IntegerLitExp(int val) {
		this(String.valueOf(val));
	}
	
	/**
	 * \brief Constructs a parse access from a String.
	 */
	public ParseAccess.ParseAccess(String name) {
		this();
		setID(name);
	}
	
	/**
	 * \brief Constructs a component modification from an access and modification.
	 */
	public ComponentModification.ComponentModification(Access name, Modification mod) {
		this();
		setName(name);
		setModification(mod);
	}
	
	/**
	 * \brief Constructs a complete modification from a class modification.
	 */
	public CompleteModification.CompleteModification(ClassModification cm) {
		this();
		setClassModification(cm);
	}
	
	/**
	 * \brief Construcs a connect clause without any residues.
	 */
	public FConnectClause.FConnectClause(FEquationType type, Opt<FStringComment> comment, ConnectClause connectClause, FIdUseInstAccess left, FIdUseInstAccess right) {
		this(type, new Opt<FResidues>(), comment, connectClause, left, right);
	}
	
	/**
	 * \brief Construcs a else equation without any residues.
	 */
	public FElseEquation.FElseEquation(FEquationType type, List<FAbstractEquation> eqns) {
		this(type, new Opt<FResidues>(), eqns);
	}
	
	/**
	 * \brief Constructs an equation that is not initial and is not marked as
	 * residue and have no residue variables.
	 */
	public FEquation.FEquation(FExp left, FExp right) {
		this(new FNormalEquation(), new Opt<FResidues>(), left, right);
	}
	
	/**
	 * \brief Constructs an equation that is not marked as residue and have no
	 * residue variables.
	 */
	public FEquation.FEquation(FEquationType type, FExp left, FExp right) {
		this(type, new Opt<FResidues>(), left, right);
	}
	
	/**
	 * \brief Constructs an equation that is not initial
	 */
	public FEquation.FEquation(FResidues residues, FExp left, FExp right) {
		this(new FNormalEquation(), residues, left, right);
	}
	
	/**
	 * \brief Constructs an equation
	 */
	public FEquation.FEquation(FEquationType type, FResidues residues, FExp left, FExp right) {
		this(type, new Opt<FResidues>(), left, right);
		if (residues != null)
			setResidues(residues);
	}
	
	/**
	 * \brief Constructs a function call equation that is not initial.
	 */
	public FFunctionCallEquation.FFunctionCallEquation(List<FFunctionCallLeft> left, FAbstractFunctionCall call) {
		this(new FNormalEquation(), new Opt<FResidues>(), left, call);
	}
	
	/**
	 * \brief Constructs a function call equation.
	 */
	public FFunctionCallEquation.FFunctionCallEquation(FEquationType type, List<FFunctionCallLeft> left, FAbstractFunctionCall call) {
		this(type, new Opt<FResidues>(), left, call);
	}
	
	/**
	 * \brief Constructs a connection clause that is not initial.
	 */
//	public FConnectClause.FConnectClause(Opt<FStringComment> comment, FIdUseInstAccess left, FIdUseInstAccess right) {
//		this(new FNormalEquation(), comment, left, right);
//	}
	
	/**
	 * \brief Constructs a for clause equation that is not initial.
	 */
	public FForClauseE.FForClauseE(List<FForIndex> indices, List<FAbstractEquation> eqns) {
		this(new FNormalEquation(), new Opt<FResidues>(), indices, eqns);
	}
	
	/**
	 * \brief Constructs a for clause equation that is not initial.
	 */
	public InstForClauseE.InstForClauseE(List<InstForIndex> indices, List<FAbstractEquation> eqns) {
		this(new FNormalEquation(), new Opt<FResidues>(), indices, eqns);
	}
	
	/**
	 * \brief Constructs a for clause equation.
	 */
	public InstForClauseE.InstForClauseE(FEquationType type, List<InstForIndex> indices, List<FAbstractEquation> eqns) {
		this(type, new Opt<FResidues>(), indices, eqns);
	}
	
	/**
	 * \brief Construcs a inst parse access.
	 */
	public InstParseAccess.InstParseAccess(String id) {
		this(id, new Opt<FArraySubscripts>());
	}
	
	/**
	 * \brief Constructs an algorithm block that is not initial.
	 */
	public FAlgorithmBlock.FAlgorithmBlock(List<FStatement> stmts) {
		this(new FNormalEquation(), new Opt<FResidues>(), stmts);
	}
	
	/**
	 * \brief Constructs an algorithm block.
	 */
	public FAlgorithmBlock.FAlgorithmBlock(FEquationType type, List<FStatement> stmts) {
		this(type, new Opt<FResidues>(), stmts);
	}
	
	/**
	 * \brief Constructs a boolean literal expression from a boolean.
	 */
	public static FBooleanLitExp FBooleanLitExp.create(boolean val) {
		return val ? new FBooleanLitExpTrue() : new FBooleanLitExpFalse();
	}
	
	/**
	 * \brief Constructs a enumeration literal expression from a type and an ordinal.
	 */
	public FEnumLitExp.FEnumLitExp(FEnumType type, int val) {
		this(type.getName(), type.getFEnumLiteralType(val - 1).getName(), type);
	}
	
	/**
	 * \brief Constructs a enumeration literal expression from a type and a literal name.
	 */
	public FEnumLitExp.FEnumLitExp(FEnumType type, String val) {
		this(type.getName(), val, type);
	}
	
	/**
	 * \brief Constructs a enumeration literal expression from an enum name and a value name.
	 */
	public FEnumLitExp.FEnumLitExp(String name, String val) {
		this(name, val, null);
	}
	
	/**
	 * \brief Constructs an FIdUse that refers to the variable with the given name.
	 */
	public FIdUse.FIdUse(String name) {
		this(new FQName(name));
	}
	
	/**
	 * \brief Constructs an FIdUse that refers to a cell of the variable with the given name.
	 *
	 * @param fas  the array subscripts to set for the last name part
	 */
	public FIdUse.FIdUse(String name, FArraySubscripts fas) {
		this(new FQName(name, fas));
	}
	
	/**
	 * \brief Constructs an if equation.
	 */
	public FIfEquation.FIfEquation(FEquationType type, List<FAbstractEquation> eqns, FExp guard, Opt<FIfWhenElseEquation> elseClause) {
		this(type, new Opt<FResidues>(), eqns, guard, elseClause);
	}
    
	/**
	 * \brief Constructs an FQName by splitting the given name into name parts.
	 * 
	 * Does <em>not</em> parse array subscripts.
	 */
    public FQName.FQName(String name) {
        this(new List());
        for (String part : name.split("\\."))
            addFQNamePart(part);
    }
    
    /**
     * \brief Creates and adds a new FQNamePart without array subscripts.
     */
    public void FQName.addFQNamePart(String name) {
    	addFQNamePart(new FQNamePart(name, new Opt()));
    }
	
	/**
	 * \brief Constructs an FQName by splitting the given name into name parts and adding array subscripts.
	 * 
	 * Does <em>not</em> parse array subscripts.
	 *
	 * @param fas  the array subscripts to set for the last name part
	 */
	public FQName.FQName(String name, FArraySubscripts fas) {
		this(name);
		setLastFArraySubscripts(fas);
	}
    
	/**
	 * \brief Constructs an FQName that is a copy of another FQName.
	 */
    public FQName.FQName(FQName fqname) {
        this((List)fqname.getFQNamePartList().fullCopy());
    }
	
	/**
	 * \brief Constructs a flat FIdUseExp that refers to the variable with the given name.
	 */
	public FIdUseExp.FIdUseExp(String name) {
		this(new FIdUse(name));
	}
	
	/**
	 * \brief Constructs an FIdUseExp that refers to the variable with the given name.
	 */
	public FIdUseExp.FIdUseExp(FQName name) {
		this(new FIdUse(name));
	}
	
	/**
	 * \brief Constructs an FIdUseExp that refers to a cell of the variable with the given name.
	 *
	 * @param fas  the array subscripts to set for the last name part
	 */
	public FIdUseExp.FIdUseExp(String name, FArraySubscripts fas) {
		this(new FIdUse(name, fas));
	}
	
	/**
	 * Constructs an FIdUseInstAccess with an empty FQName.
	 * 
	 * Note: the FQName of an FIdUseInstAccess should always be empty.
	 */
	public FIdUseInstAccess.FIdUseInstAccess(InstAccess ia) {
		this(new FQName(), ia);
	}
	
	/**
	 * \brief Constructs an unsuported equation.
	 */
	public FUnsupportedEquation.FUnsupportedEquation(FEquationType type) {
		this(type, new Opt<FResidues>());
	}
	
	/**
	 * \brief Constructs a when equation.
	 */
	public FWhenEquation.FWhenEquation(FEquationType type, List<FAbstractEquation> eqns, FExp guard, Opt<FIfWhenElseEquation> elseClause) {
		this(type, new Opt<FResidues>(), eqns, guard, elseClause);
	}
	
	/**
	 * \brief Constructs an InstDot with an empty ID.
	 */
	public InstDot.InstDot(InstAccess left, InstAccess right) {
		this("", left, right);
	}
	
	/**
	 * \brief Constructs a Dot with an empty ID.
	 */
	public Dot.Dot(Access left, Access right) {
		this("", left, right);
	}
	
	/**
	 * \brief Constructs an InstGlobalAccess with an empty ID.
	 */
	public InstGlobalAccess.InstGlobalAccess(InstAccess access) {
		this("", access);
	}
	
	/**
	 * \brief Constructs a GlobalAccess with an empty ID.
	 */
	public GlobalAccess.GlobalAccess(Access access) {
		this("", access);
	}
	
	/**
	 * Create an access from a class name.
	 */
	public static Access Access.fromClassName(String name) {
		String[] parts = name.split("\\.", 2);
		if (parts.length == 1)
			return new ClassAccess(parts[0]);
		else
			return new Dot(new ClassAccess(parts[0]), fromClassName(parts[1]));
	}
	
	/**
	 * \brief Constructs an FForIndex with a temporary index variable and a 
	 *        range expression starting at 1 as the in expression.
	 * 
	 * @param name  the name of the index
	 * @param end   the upper limit for the range expression
	 */
	public FForIndex.FForIndex(String name, FExp end) {
		this();
		setFExp(new FRangeExp(new FIntegerLitExp(1), end));
		setFVariable(new FIntegerVariable(new FTemporaryVisibilityType(), 
				fParameter(), new FQName(name)));
	}
	
	/**
	 * \brief Constructs an FForIndex with a temporary index variable and loops 
	 *        over the given variable.        
	 * 
	 * @param name  the name of the index
	 * @param var   the name of the variable to loop over
	 * @param dim   the dimension to loop over
	 */
	public FForIndex.FForIndex(String name, FQName var, int dim) {
		this(name, new FSizeExp(var, dim));
	}
	
	/**
	 * \brief Constructs an FSizeExp giving the size in the given dimension for the given variable.
	 */
	public FSizeExp.FSizeExp(FQName var, int dim) {
		this(new FIdUseExp(var), dim);
	}
	
	/**
	 * \brief Constructs an FSizeExp giving the size in the given dimension for the given expression.
	 */
	public FSizeExp.FSizeExp(FExp exp, int dim) {
		this(exp, new Opt(new FIntegerLitExp(dim + 1)));
	}
	
	/**
	 * \brief Constructs an FRangeExp with the given start and stop expressions.
	 */
	public FRangeExp.FRangeExp(FExp start, FExp stop) {
		this(new List().add(start).add(stop));
	}
	
	/**
	 * \brief Constructs an FRangeExp with the given start and stop literal values.
	 */
	public FRangeExp.FRangeExp(int start, int stop) {
		this(new FIntegerLitExp(start), new FIntegerLitExp(stop));
	}
	
	/**
	 * \brief Constructs an FRangeExp with the given start, step and and stop expressions.
	 */
	public FRangeExp.FRangeExp(FExp start, FExp step, FExp stop) {
		this(new List().add(start).add(step).add(stop));
	}
	
	/**
	 * \brief Constructs an FRecordConstructor for a record with the given name and no arguments.
	 */
	public FRecordConstructor.FRecordConstructor(String name) {
		this(new FIdUse(name), new List());
	}
	
	public EnumLiteralDecl.EnumLiteralDecl(IdDecl name, Comment comment) {

		this(new Opt(),
                new Opt(),
                new Opt(),
                new Opt(),
                new Opt(),
                new Opt(),
                new Opt(new Constant()),      
                new Opt(),
                new ClassAccess("EnumType"),
                new Opt(),
                new PublicVisibilityType(),
                new IdDecl(name.getID()),
                new Opt(),
                new Opt(),        
                new Opt(),
                (Comment)comment.fullCopy(),
                new Opt(),
                new Comment(new Opt(),new Opt()));
		this.setLocation(name);
		
	}
	
	public ComponentDecl.ComponentDecl(boolean isParameter,
	                                   String type,
	                                   String name,
	                                   String bexp) {

		this(new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
		                         new Opt(),
	                             isParameter? new Opt(new Parameter()): new Opt(),      
                                 new Opt(),
                                 new ClassAccess(type),
                                 new Opt(),
                                 new PublicVisibilityType(),
                                 new IdDecl(name),
                                 new Opt(),
                        		 new Opt(),        
                                 new Opt(),
                                 new Comment(new Opt(),new Opt()),
                                 new Opt(),
                                 new Comment(new Opt(),new Opt()));
		
		Exp bexp_ast=null;
		
		if (!bexp.equals("")) {
		    //ModelicaParser mp = new ModelicaParser();
			//bexp_ast = mp.parseExpString(bexp);
			ParserHandler ph = new ParserHandler();
			try {
				bexp_ast = ph.parseExpString(bexp);
			} catch (Exception e) {	
				log.error("Error when parsing string");	
			}
			//log.debug("ComponentDecl.ComponentDecl");
			//bexp_ast.dumpTreeBasic("");	
		    this.setModification(new ValueModification(bexp_ast));
        }                     	
	}
	
	/**
	 * Create a real variable with only the required children.
	 */
	public FRealVariable.FRealVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FDerivativeVariable.FDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FDummyDerivativeVariable.FDummyDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FHDerivativeVariable.FHDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, int order) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, order);
	}
	
	/**
	 * Create a derivative variable with only the required children.
	 */
	public FHDummyDerivativeVariable.FHDummyDerivativeVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, int order) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, order);
	}
	
	/**
	 * Create a pre variable for a discrete real variable.
	 */
	public FPreRealVariable.FPreRealVariable(FRealVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy());
	}
	
	/**
	 * Create a integer variable with only the required children.
	 */
	public FIntegerVariable.FIntegerVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name);
	}
	
	/**
	 * Create a pre variable for an integer variable.
	 */
	public FPreIntegerVariable.FPreIntegerVariable(FIntegerVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy());
	}
	
	/**
	 * Create a enum variable with only the required children.
	 */
	public FEnumVariable.FEnumVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, FQName enumName) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, enumName);
	}
	
	/**
	 * Create a pre variable for a enum variable.
	 */
	public FPreEnumVariable.FPreEnumVariable(FEnumVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy(), fv.getEnum().fullCopy());
	}
	
	/**
	 * Create a boolean variable with only the required children.
	 */
	public FBooleanVariable.FBooleanVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name);
	}
	
	/**
	 * Create a pre variable for a boolean variable.
	 */
	public FPreBooleanVariable.FPreBooleanVariable(FBooleanVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy());
	}
	
	/**
	 * Create a string variable with only the required children.
	 */
	public FStringVariable.FStringVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name);
	}
	
	/**
	 * Create a pre variable for a string variable.
	 */
	public FPreStringVariable.FPreStringVariable(FStringVariable fv) {
		this(fv.getFVisibilityType().fullCopy(), fv.getFTypePrefixVariability().fullCopy(),
				new Opt(), (List) fv.getFAttributeList().fullCopy(), fv.getDerivedType(), 
				new Opt(), new Opt(), fv.getFQName().fullCopy());
	}
	
	/**
	 * Create a record variable with only the required children.
	 */
	public FRecordVariable.FRecordVariable(FVisibilityType fvt, 
			FTypePrefixVariability variability, FQName name, FQName record) {
		this(fvt, variability, new Opt(), new List(), (String) null, new Opt(), new Opt(), name, record);
	}

	
	/**
	 * \brief Create an FInternalAttribute with only the children that are 
	 *        valid for them.
	 */
	public FInternalAttribute.FInternalAttribute(String name, FExp value) {
		this(new FIdUse(new FQName()), new FIdDecl(new FQName(name)), new Opt(value), 
				true, new Opt(), new Opt(), new List());
	}
	
	/**
	 * \brief Create an attribute with only the required children.
	 */
	public FAttribute.FAttribute(FIdUse typeName, FIdDecl name, boolean isSet) {
		this(typeName, name, new Opt(), isSet, new Opt(), new Opt(), new List());
	}
	
	/**
	 * \brief Create an FFunctionArray with the given name and type. 
	 *        Extracts array subscripts from type.
	 */
	public FFunctionArray.FFunctionArray(FType type, String name) {
		this(new Opt(), type, new Opt(), new FQName(name));
		getFQName().setLastFArraySubscripts(type.size().flattenFArraySubscripts(new FQName()));
	}
	
	/**
	 * \brief Create an FFunctionVariable with the given name and type. 
	 */
	public FFunctionVariable.FFunctionVariable(FType type, String name) {
		this(new Opt(), type, new Opt(), new FQName(name));
	}
	
	/**
	 * \brief Create a new FSubscriptedExp with a new FArraySubscripts, containing the 
	 *        proper number of FSubscripts (according to <code>exp</code>).
	 * 
	 * All FSubscripts except the first will be FColonSubscripts.
	 * 
	 * @param exp    the expression this FSubscriptedExp should wrap
	 * @param index  the index to use for the first FSubscript
	 * @param ndims  the number of dimensions of exp (calling ndims() might cause name lookup)
	 */
	public FSubscriptedExp.FSubscriptedExp(FExp exp, int index, int ndims) {
		this(exp, FArraySubscripts.createFColonSubscripts(ndims));
		getFArraySubscripts().specifyNext(index);
	}
	
	/**
	 * \brief Create a new FExpSubscript with an integer literal as expression.
	 */
	public FExpSubscript.FExpSubscript(int i) {
		this(new FIntegerLitExp(i));
	}
	
	/**
	 * \brief Create a new FArraySubscripts <code>n</code> literal subscripts from 
	 *        <code>i</code>, starting at <code>j</code>.
	 */
	public FArraySubscripts.FArraySubscripts(Index i, int j, int n) {
		this();
		for (int k = j; k < n+j; k++)
			addFSubscript(i.get(k));
	}
	
	/**
	 * Add a new FExpSubscript with an integer literal as expression to the list of FSubscripts.
	 */
	public void FArraySubscripts.addFSubscript(int i) {
		addFSubscript(new FExpSubscript(i));
	}
	
	/**
	 * \brief Create a new FArraySubscripts containing <code>n</code> {@link FColonSubscript}s.
	 */
	public static FArraySubscripts FArraySubscripts.createFColonSubscripts(int n) {
		List<FSubscript> l = new List<FSubscript>();
		for (int i = 0; i < n; i++)
			l.add(new FColonSubscript());
		return new FArraySubscripts(l);
	}
	
	/**
	 * \brief Create a new FArraySubscripts containing an integer literal.
	 */
	public static FArraySubscripts FArraySubscripts.createLiteralSubscripts(int i) {
		List<FSubscript> l = new List<FSubscript>();
		l.add(new FExpSubscript(i));
		return new FArraySubscripts(l);
	}
	
	/**
	 * \brief Create a new FArraySubscripts containing integer literals.
	 */
	public static FArraySubscripts FArraySubscripts.createLiteralSubscripts(int[] index) {
		List<FSubscript> l = new List<FSubscript>();
		for (int i : index)
			l.add(new FExpSubscript(i));
		return new FArraySubscripts(l);
	}
	
}

/*
 * Some algorithms are the same for many node types, but require a new node 
 * to be created of the same type as the node being processed. These methods allow 
 * those algorithms to be generalized.
 */
aspect InheritedFactoryMethods {
	
	/**
	 * \brief Create a new empty node.
	 * 
	 * Abstract method needed for abstract node classes with declared 
	 * (i.e. not inherited) children.
	 */
	public abstract FExp                      FExp.createEmptyNode();
	public abstract FBinExp                   FBinExp.createEmptyNode();
	public abstract FUnaryExp                 FUnaryExp.createEmptyNode();
	public abstract FBooleanLitExp            FBooleanLitExp.createEmptyNode();   // No children, but can be useful
	public abstract FBuiltInFunctionCall      FBuiltInFunctionCall.createEmptyNode();  // Used in BuiltInTranslator 
	public abstract FUnaryBuiltIn             FUnaryBuiltIn.createEmptyNode();
	public abstract FMathematicalFunctionCall FMathematicalFunctionCall.createEmptyNode();
	public abstract FInfArgsFunctionCall      FInfArgsFunctionCall.createEmptyNode();
	public abstract FMinMaxExp      		  FMinMaxExp.createEmptyNode();

	// Unsupported expressions
	public FUnsupportedExp     FUnsupportedExp.createEmptyNode()     { return new FUnsupportedExp();     }
	public FUnsupportedBuiltIn FUnsupportedBuiltIn.createEmptyNode() { return new FUnsupportedBuiltIn(); }
	public FIgnoredBuiltIn     FIgnoredBuiltIn.createEmptyNode()     { return new FIgnoredBuiltIn(); }
	
	// Arithmetic oprerators
	public FAddExp    FAddExp.createEmptyNode()    { return new FAddExp();    }
	public FSubExp    FSubExp.createEmptyNode()    { return new FSubExp();    }
	public FMulExp    FMulExp.createEmptyNode()    { return new FMulExp();    }
	public FDivExp    FDivExp.createEmptyNode()    { return new FDivExp();    }
	public FPowExp    FPowExp.createEmptyNode()    { return new FPowExp();    }
	public FDotAddExp FDotAddExp.createEmptyNode() { return new FDotAddExp(); }
	public FDotSubExp FDotSubExp.createEmptyNode() { return new FDotSubExp(); }
	public FDotMulExp FDotMulExp.createEmptyNode() { return new FDotMulExp(); }
	public FDotDivExp FDotDivExp.createEmptyNode() { return new FDotDivExp(); }
	public FDotPowExp FDotPowExp.createEmptyNode() { return new FDotPowExp(); }
	public FNegExp    FNegExp.createEmptyNode()    { return new FNegExp();    }
	
	// Logical operators
	public FLtExp  FLtExp.createEmptyNode()  { return new FLtExp();  }
	public FLeqExp FLeqExp.createEmptyNode() { return new FLeqExp(); }
	public FGtExp  FGtExp.createEmptyNode()  { return new FGtExp();  }
	public FGeqExp FGeqExp.createEmptyNode() { return new FGeqExp(); }
	public FEqExp  FEqExp.createEmptyNode()  { return new FEqExp();  }
	public FNeqExp FNeqExp.createEmptyNode() { return new FNeqExp(); }
	public FNotExp FNotExp.createEmptyNode() { return new FNotExp(); }
	public FOrExp  FOrExp.createEmptyNode()  { return new FOrExp();  }
	public FAndExp FAndExp.createEmptyNode() { return new FAndExp(); }
	
	// Literal expressions (all have different children, so mostly here for completeness)
	public FRealLitExp         FRealLitExp.createEmptyNode()         { return new FRealLitExp();         }
	public FIntegerLitExp      FIntegerLitExp.createEmptyNode()      { return new FIntegerLitExp();      }
	public FBooleanLitExpTrue  FBooleanLitExpTrue.createEmptyNode()  { return new FBooleanLitExpTrue();  }
	public FBooleanLitExpFalse FBooleanLitExpFalse.createEmptyNode() { return new FBooleanLitExpFalse(); }
	public FStringLitExp       FStringLitExp.createEmptyNode()       { return new FStringLitExp();       }
	public FEnumLitExp         FEnumLitExp.createEmptyNode()         { return new FEnumLitExp();         }
	
	// Misc expressions
	public FIfExp          FIfExp.createEmptyNode()          { return new FIfExp();          }
	public FTimeExp        FTimeExp.createEmptyNode()        { return new FTimeExp();        }
	public FNoEventExp     FNoEventExp.createEmptyNode()     { return new FNoEventExp();     }
	public FSmoothExp      FSmoothExp.createEmptyNode()      { return new FSmoothExp();      }
	public FPreExp         FPreExp.createEmptyNode()         { return new FPreExp();         }
	public FSampleExp      FSampleExp.createEmptyNode()      { return new FSampleExp();      }
	public FInitialExp     FInitialExp.createEmptyNode()     { return new FInitialExp();     }
	public FNoExp          FNoExp.createEmptyNode()          { return new FNoExp();          }
	public FUnknownSizeExp FUnknownSizeExp.createEmptyNode() { return new FUnknownSizeExp(); }
	
	// Identifier expressions
	public FIdUseExp      FIdUseExp.createEmptyNode()      { return new FIdUseExp();      }
	public InstDerExp     InstDerExp.createEmptyNode()     { return new InstDerExp();     }
	public FDerExp        FDerExp.createEmptyNode()        { return new FDerExp();        }
	public InstHDerExp    InstHDerExp.createEmptyNode()    { return new InstHDerExp();    }
	public FHDerExp       FHDerExp.createEmptyNode()       { return new FHDerExp();       }
	public FInstAccessExp FInstAccessExp.createEmptyNode() { return new FInstAccessExp(); }
	
	// Array expressions
	public FArray          FArray.createEmptyNode()          { return new FArray();          }
	public FLongArray      FLongArray.createEmptyNode()      { return new FLongArray();      }
	public FParseArray     FParseArray.createEmptyNode()     { return new FParseArray();     }
	public FCatExp         FCatExp.createEmptyNode()         { return new FCatExp();         }
	public FMatrix         FMatrix.createEmptyNode()         { return new FMatrix();         }
	public FMatrixRow      FMatrixRow.createEmptyNode()      { return new FMatrixRow();      }
	public FSubscriptedExp FSubscriptedExp.createEmptyNode() { return new FSubscriptedExp(); }
	public FRangeExp       FRangeExp.createEmptyNode()       { return new FRangeExp();       }
	public FLinspace       FLinspace.createEmptyNode()       { return new FLinspace();       }
	public FEndExp         FEndExp.createEmptyNode()         { return new FEndExp();         }
	public FIterExp        FIterExp.createEmptyNode()        { return new FIterExp();        }
	
	// Function calls
	public FFunctionCall      FFunctionCall.createEmptyNode()      { return new FFunctionCall();      }
	public InstFunctionCall   InstFunctionCall.createEmptyNode()   { return new InstFunctionCall();   }
	public FRecordConstructor FRecordConstructor.createEmptyNode() { return new FRecordConstructor(); }
	
	// Calls to built-in mathematical functions
	public FSinExp   FSinExp.createEmptyNode()   { return new FSinExp();   }
	public FCosExp   FCosExp.createEmptyNode()   { return new FCosExp();   }
	public FTanExp   FTanExp.createEmptyNode()   { return new FTanExp();   }
	public FAsinExp  FAsinExp.createEmptyNode()  { return new FAsinExp();  }
	public FAcosExp  FAcosExp.createEmptyNode()  { return new FAcosExp();  }
	public FAtanExp  FAtanExp.createEmptyNode()  { return new FAtanExp();  }
	public FAtan2Exp FAtan2Exp.createEmptyNode() { return new FAtan2Exp(); }
	public FSinhExp  FSinhExp.createEmptyNode()  { return new FSinhExp();  }
	public FCoshExp  FCoshExp.createEmptyNode()  { return new FCoshExp();  }
	public FTanhExp  FTanhExp.createEmptyNode()  { return new FTanhExp();  }
	public FExpExp   FExpExp.createEmptyNode()   { return new FExpExp();   }
	public FLogExp   FLogExp.createEmptyNode()   { return new FLogExp();   }
	public FLog10Exp FLog10Exp.createEmptyNode() { return new FLog10Exp(); }
	public FSqrtExp  FSqrtExp.createEmptyNode()  { return new FSqrtExp();  }
	
	// Built-in function calls and function call-like operators
	public FNdimsExp       FNdimsExp.createEmptyNode()       { return new FNdimsExp();       }
	public FSizeExp        FSizeExp.createEmptyNode()        { return new FSizeExp();        }
	public FIntegerExp     FIntegerExp.createEmptyNode()     { return new FIntegerExp();     }
	public FEnumIntegerExp FEnumIntegerExp.createEmptyNode() { return new FEnumIntegerExp(); }
	public FStringExp      FStringExp.createEmptyNode()      { return new FStringExp(); }
	public FScalar         FScalar.createEmptyNode()         { return new FScalar();         }
	public FTranspose      FTranspose.createEmptyNode()      { return new FTranspose();      }
	public FCross          FCross.createEmptyNode()          { return new FCross();          }
	public FIdentity       FIdentity.createEmptyNode()       { return new FIdentity();       }
	public FOnes           FOnes.createEmptyNode()           { return new FOnes();           }
	public FZeros          FZeros.createEmptyNode()          { return new FZeros();          }
	public FFillExp        FFillExp.createEmptyNode()        { return new FFillExp();        }
	public FMinExp         FMinExp.createEmptyNode()         { return new FMinExp();         }
	public FMaxExp         FMaxExp.createEmptyNode()         { return new FMaxExp();         }
	public FSumExp         FSumExp.createEmptyNode()         { return new FSumExp();         }
	public FAbsExp         FAbsExp.createEmptyNode()         { return new FAbsExp();         }
	public FInStream       FInStream.createEmptyNode()       { return new FInStream();       }
	public FActualStream   FActualStream.createEmptyNode()   { return new FActualStream();   }
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FBinExp FBinExp.createNode(FExp left, FExp right) {
		FBinExp node = createEmptyNode();
		node.setLeft(left);
		node.setRight(right);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FUnaryExp FUnaryExp.createNode(FExp exp) {
		FUnaryExp node = createEmptyNode();
		node.setFExp(exp);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FIdUseExp FIdUseExp.createNode(FIdUse use) {
		FIdUseExp node = createEmptyNode();
		node.setFIdUse(use);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FMathematicalFunctionCall FMathematicalFunctionCall.createNode(FExp exp) {
		FMathematicalFunctionCall node = createEmptyNode();
		node.setFExp(exp);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FUnaryBuiltIn FUnaryBuiltIn.createNode(FExp exp) {
		FUnaryBuiltIn node = createEmptyNode();
		node.setFExp(exp);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children. For missing y, use null.
	 */
	public FMinMaxExp FMinMaxExp.createNode(FExp x, FExp y) {
		FMinMaxExp node = createEmptyNode();
		node.setX(x);
		if (y != null)
			node.setY(y);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FInfArgsFunctionCall FInfArgsFunctionCall.createNode(List<FExp> exps) {
		FInfArgsFunctionCall node = createEmptyNode();
		node.setFExpList(exps);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FInfArgsFunctionCall FInfArgsFunctionCall.createNode(ArrayList<FExp> exps) {
		FInfArgsFunctionCall node = createEmptyNode();
		for (FExp e : exps)
			node.addFExp(e);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FArray FArray.createNode(List<FExp> exps) {
		FArray node = createEmptyNode();
		node.setFExpList(exps);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FArray FArray.createNode(ArrayList<FExp> exps) {
		FArray node = createEmptyNode();
		for (FExp e : exps)
			node.addFExp(e);
		return node;
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children. Used to allow common algorithms to handle unrelated types.
	 */
	public FExp FExp.createNodeBinary(FExp a, FExp b) {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        child. Used to allow common algorithms to handle unrelated types.
	 */
	public FExp FExp.createNodeUnary(FExp a) {
		throw new UnsupportedOperationException();
	}
	
	// Add support to new types as needed.
	public FExp FBinExp.createNodeBinary(FExp a, FExp b)    { return createNode(a, b); }
	public FExp FMinMaxExp.createNodeBinary(FExp a, FExp b) { return createNode(a, b); }
	public FExp FUnaryExp.createNodeUnary(FExp a)           { return createNode(a); }

	
	// The createNode() structure applied to various other nodes that requre common handling
	public abstract FIfWhenClause FIfWhenClause.createEmptyNode();
	public FIfClause   FIfClause.createEmptyNode()   { return new FIfClause(); }
	public FWhenClause FWhenClause.createEmptyNode() { return new FWhenClause(); }
	
	public abstract FIfWhenElseEquation FIfWhenElseEquation.createEmptyNode();
	public FIfEquation   FIfEquation.createEmptyNode()   { return new FIfEquation(); }
	public FWhenEquation FWhenEquation.createEmptyNode() { return new FWhenEquation(); }
	public FElseEquation FElseEquation.createEmptyNode() { return new FElseEquation(); }
	
	public abstract FIfWhenStmt FIfWhenStmt.createEmptyNode();
	public FIfStmt   FIfStmt.createEmptyNode()   { return new FIfStmt(); }
	public FWhenStmt FWhenStmt.createEmptyNode() { return new FWhenStmt(); }
	
	public abstract FVariable FVariable.createEmptyNode();
	public FRealVariable    FRealVariable.createEmptyNode()    { return new FRealVariable(); }
	public FIntegerVariable FIntegerVariable.createEmptyNode() { return new FIntegerVariable(); }
	public FBooleanVariable FBooleanVariable.createEmptyNode() { return new FBooleanVariable(); }
	public FStringVariable  FStringVariable.createEmptyNode()  { return new FStringVariable(); }
	public FEnumVariable    FEnumVariable.createEmptyNode()    { return new FEnumVariable(); }
	public FRecordVariable  FRecordVariable.createEmptyNode()  { return new FRecordVariable(); }

	public FAttribute         FAttribute.createEmptyNode()         { return new FAttribute(); }
	public FInternalAttribute FInternalAttribute.createEmptyNode() { return new FInternalAttribute(); }

	/**
	 * \brief Create new node of same class as this, with the specified 
	 *        children.
	 */
	public FIfWhenClause FIfWhenClause.createNode(FExp test, List<FStatement> stmts) {
		FIfWhenClause node = createEmptyNode();
		node.setTest(test);
		node.setFStatementList(stmts);
		return node;
	}
		
}