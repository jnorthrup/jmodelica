/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * \brief Provides methods to evaluate flat constant 
 * expressions. 
 * 
 * Evaluation of constants and parameters is needed in several locations in the
 * compiler. 
 * 
 *  - Array sizes need to be evaluated during flattening and type checking.
 *  - Expressions need to be evaluated in function calls.
 *  - Attribute values for primitive variables need to be evaluated in the code 
 *    generation.
 *
 * The evaluation framework relies on the class CValue, which in turn is 
 * subclassed to CValueReal, CValueInteger, etc. Introducing explicit classes
 * corresponding to constant values enables convenient type casts and also 
 * provides means to represent more complex types such as arrays.  
 * 
 */
aspect ConstantEvaluation {
  
	/**
	 * \brief CValue represents a constant value and serves as the super class 
	 * for constant value classes of the primitive types.
	 */
	public abstract class CValue {

		/** 
		 * \brief Default constructor.
		 */
	    protected CValue() {
	    }

	    /**
	     * \brief Convert to int, default implementation.
	     * 
	     * @return Value converted to int.
	     */
	    public int intValue() { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to double, default implementation.
	     * 
	     * @return Value converted to double.
	     */
	    public double realValue() { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to boolean, default implementation.
	     * 
	     * @return Value converted to boolean.
	     */
	    public boolean booleanValue() { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to string, default implementation.
	     * 
	     * @return Value converted to string.	     
	     */
	    public String stringValue() { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Create a literal AST node from constant, default 
	     *  implementation.
	     *  
	     *  @return Literal expression AST node.
	     */
	    public FExp buildLiteral() { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to CValueInteger, default implementation.
	     */
	    public CValueInteger convertInteger() {
	    	return new CValueInteger(intValue());
	    }
	    
	    /**
	     * \brief Convert to CValueReal, default implementation.
	     */
	    public CValueReal convertReal() {
	    	return new CValueReal(realValue());
	    }
	    
	    /**
	     * \brief Convert to CValueBoolean, default implementation.
	     */
	    public CValueBoolean convertBoolean() {
	    	return new CValueBoolean(booleanValue());
	    }
	    
	    /**
	     * \brief Convert to CValueString, default implementation.
	     */
	    public CValueString convertString() {
	    	return new CValueString(stringValue());
	    }

	    /**
	     * \brief Convert to int, default implementation.
	     * 
	     * @return Value converted to int.
	     */
	    public int intValue(int[] index) { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to daouble, default implementation.
	     * 
	     * @return Value converted to double.
	     */
	    public double realValue(int[] index) { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to boolean, default implementation.
	     * 
	     * @return Value converted to boolean.
	     */
	    public boolean booleanValue(int[] index) { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    /**
	     * \brief Convert to string, default implementation.
	     * 
	     * @return Value converted to string.	     
	     */
	    public String stringValue(int[] index) { 
	    	throw new UnsupportedOperationException(); 
	    }
	    
	    public abstract int ndims();
	    
	    public abstract int[] size();
	    
	    public boolean isArray() {
	    	return ndims()>0;
	    }
	    
	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return True if the constant is a numerical value.
	     */
	    public abstract boolean isNumeric();
	    
	    /**
	     * \brief Check if there was an error in the evaluation.
	     *
	     * @return true if there was an error, otherwise true. 
	     */
	    public boolean isUnknown() {
      		return false;
      	}
        
        /**
         * Overloading of the toString() method.
         * 
         * @return The string.
         */
        public String toString() { 
        	return stringValue(); 
        }
	   
	}
  
	public abstract class CValueScalar extends CValue {
	    
	    public int ndims() {
	    	return 0;
	    }
	    
	    public int[] size() {
	    	return new int[0];
	    }
	  	  
	}
	
	/**
	 * \brief Constant integer value.
	 */
    public class CValueInteger extends CValueScalar {
        private int value;
        
        /** 
         * \brief Constructor.
         * 
  	     * @param i Integer value.
         */
        public CValueInteger(int i) { 
        	this.value = i; 
        }

        /**
	     * \brief Convert to int.
	     * 
	     * @return Value converted to int.
	     */
        public int intValue() { 
        	return value; 
        }

        /**
	     * \brief Convert to double.
	     * 
	     *  @return Value converted to double.
	     */
        public double realValue() { 
        	return value; 
        }
	    
	    /**
	     * \brief Convert to CValueInteger.
	     */
	    public CValueInteger convertInteger() {
	    	return this;
	    }
        
        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */
        public String stringValue() { 
        	return new Integer(value).toString(); 
        }
        
        /**
         * Create a new integer literal AST node.
         * 
         * @return AST node of type FLitExp.
         */
        public FLitExp buildLiteral() { 
        	return new FIntegerLitExp(stringValue()); 
        }

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return True.
	     */
	    public boolean isNumeric() {
	    	return true;
	    }

    }
    
	/**
	 * \brief Constant real value.
	 */      
    public class CValueReal extends CValueScalar {
        private double value;
        
        /**
         * Constructor.
         * 
         * @param d Double value.
         */
        public CValueReal(double d) { 
        	this.value = d; 
        }

        /**
	     * \brief Convert to int.
	     * 
	     * @return Value converted to int.
	     */
        public int intValue() { 
        	return (int)value; 
        }
        
        /**
	     * \brief Convert to double.
	     * 
	     * @return Value converted to double.
	     */
        public double realValue() { 
        	return value; 
        }
	    
	    /**
	     * \brief Convert to CValueReal.
	     */
	    public CValueReal convertReal() {
	    	return this;
	    }

        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */
        public String stringValue() { 
        	return new Double(value).toString(); 
        }
        
        /**
         * \brief Create a new literal expression AST node.
         * 
         * @return FRealLitExp AST node.
         */
        public FLitExp buildLiteral() { 
        	return new FRealLitExp(value); 
        }

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return True.
	     */
	    public boolean isNumeric() {
	    	return true;
	    }
        
      }
    
	/**
	 * \brief Constant boolean value.
	 */
    public class CValueBoolean extends CValueScalar {
        private boolean value;

        /**
         * Constructor.
         * 
         * @param b Boolean value.
         */
        public CValueBoolean(boolean b) { 
        	this.value = b; 
        }

        /**
	     * \brief Convert to boolean.
	     * 
	     * @return Value converted to boolean.
	     */
        public boolean booleanValue() { 
        	return value; 
        }
	    
	    /**
	     * \brief Convert to CValueBoolean.
	     */
	    public CValueBoolean convertBoolean() {
	    	return this;
	    }
       
        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */
        public String stringValue() { 
        	return new Boolean(value).toString(); 
        }
        
        /**
         * \brief Create a new literal expression AST node.
         * 
         * @return FBooleanLitExp AST node.
         */
        public FLitExp buildLiteral() { 
      	  return FBooleanLitExp.create(value); 
      	  }
        
	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return False.
	     */
	    public boolean isNumeric() {
	    	return false;
	    }

      }
      
	/**
	 * \brief Constant string value.
	 */
    public class CValueString extends CValueScalar {
        private String value;
        
        /**
         * Constructor.
         * 
         * @param s String value.
         */        
        public CValueString(String s) { this.value = s; }
        
        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */        
        public String stringValue() { return value; }
	    
	    /**
	     * \brief Convert to CValueString.
	     */
	    public CValueString convertString() {
	    	return this;
	    }

        /**
         * \brief Create a new literal expression AST node.
         * 
         * @return FStringLitExp AST node.
         */
        public FLitExp buildLiteral() { 
        	return new FStringLitExp(value); 
        }

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return False.
	     */
        public boolean isNumeric() {
	    	return false;
	    }
                
      }
    
	/**
	 * \brief Constant unknown value. This class is used to represent 
	 * non-constant values and values resulting from expressions with
	 * type errors.
	 */
    public class CValueUnknown extends CValueScalar {

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return False.
	     */
    	public boolean isNumeric() {
	    	return false;
	    }
    	
        /**
         * Convert to string.
         * 
         * @return The string. 
         */
    	public String toString() { 
      		return "CValueUnknown"; 
      	}
      	
      	public boolean isUnknown() {
      		return true;
      	}
      	
      }
	
  public abstract class CValueArray extends CValue {
	    
	    public int ndims() {
	    	return 0;
	    }
	    
	    public int[] size() {
	    	return new int[0];
	    }
	  	  
  }
	
	/**
	 * \brief Constant integer value.
	 */
    public class CValueIntegerArray extends CValueArray {
        private int value;
        
        /** 
         * \brief Constructor.
         * 
  	     * @param i Integer value.
         */
        public CValueIntegerArray(int i) { 
        	this.value = i; 
        }

        /**
	     * \brief Convert to int.
	     * 
	     * @return Value converted to int.
	     */
        public int intValue() { 
        	return value; 
        }

        /**
	     * \brief Convert to double.
	     * 
	     *  @return Value converted to double.
	     */
        public double realValue() { 
        	return value; 
        }
        
        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */
        public String stringValue() { 
        	return new Integer(value).toString(); 
        }
        
        /**
         * Create a new integer literal AST node.
         * 
         * @return AST node of type FLitExp.
         */
        public FLitExp buildLiteral() { 
        	return new FIntegerLitExp(stringValue()); 
        }

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return True.
	     */
	    public boolean isNumeric() {
	    	return true;
	    }
        
        /**
         * Overloading of the toString() method.
         * 
         * @return The string.
         */
        public String toString() { 
        	return value+""; 
        }
      }
    
	/**
	 * \brief Constant real value.
	 */      
    public class CValueRealArray extends CValueArray {
        private double value;
        
        /**
         * Constructor.
         * 
         * @param d Double value.
         */
        public CValueRealArray(double d) { 
        	this.value = d; 
        }

        /**
	     * \brief Convert to int.
	     * 
	     * @return Value converted to int.
	     */
        public int intValue() { 
        	return (int)value; 
        }
        
        /**
	     * \brief Convert to double.
	     * 
	     * @return Value converted to double.
	     */
        public double realValue() { 
        	return value; 
        }

        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */
        public String stringValue() { 
        	return new Double(value).toString(); 
        }
        
        /**
         * \brief Create a new literal expression AST node.
         * 
         * @return FRealLitExp AST node.
         */
        public FLitExp buildLiteral() { 
        	return new FRealLitExp(stringValue()); 
        }

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return True.
	     */
	    public boolean isNumeric() {
	    	return true;
	    }
        
        /**
         * Convert to string.
         * 
         * @return The string. 
         */
        public String toString() { 
        	return value+""; 
        }
        
      }
    
	/**
	 * \brief Constant boolean value.
	 */
    public class CValueBooleanArray extends CValueArray {
        private boolean value;

        /**
         * Constructor.
         * 
         * @param b Boolean value.
         */
        public CValueBooleanArray(boolean b) { 
        	this.value = b; 
        }

        /**
	     * \brief Convert to boolean.
	     * 
	     * @return Value converted to boolean.
	     */
        public boolean booleanValue() { 
        	return value; 
        }
        
        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */
        public String stringValue() { 
        	return new Boolean(value).toString(); 
        }
        
        /**
         * \brief Create a new literal expression AST node.
         * 
         * @return FBooleanLitExp AST node.
         */
        public FLitExp buildLiteral() { 
      	  return value? new FBooleanLitExpTrue() :
      		  new FBooleanLitExpFalse(); 
      	  }
        
	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return False.
	     */
	    public boolean isNumeric() {
	    	return false;
	    }
        
        /**
         * Convert to string.
         * 
         * @return The string. 
         */
        public String toString() { 
        	return value+""; 
        }
      }
      
	/**
	 * \brief Constant string value.
	 */
    public class CValueStringArray extends CValueArray {
        private String value;
        
        /**
         * Constructor.
         * 
         * @param s String value.
         */        
        public CValueStringArray(String s) { this.value = s; }
        
        /**
	     * \brief Convert to string.
	     * 
	     * @return Value converted to string.
	     */        
        public String stringValue() { return value; }

        /**
         * \brief Create a new literal expression AST node.
         * 
         * @return FStringLitExp AST node.
         */
        public FLitExp buildLiteral() { 
        	return new FStringLitExp(stringValue()); 
        }

	    /**
	     * \brief Returns true if the constant value is of numeric type.
	     * 
	     * @return False.
	     */
        public boolean isNumeric() {
	    	return false;
	    }
                
        /**
         * Convert to string.
         * 
         * @return The string. 
         */
        public String toString() { 
        	return value+""; 
        }
      }

    
    /** 
     * \build Creates an FExp with literals from this Array.
     * 
     * Creates a (possibly nested) FArray containing FLitExp nodes.
     * 
     * @param toReal  if <code>true</code>, convert all values to real.
     * 
     * @throws UnsupportedOperationException  if the expressions aren't constant.
     */
    public FExp Array.buildLiteral(boolean toReal) {
    	return buildLiteralHelper(iteratorFExp(), toReal, 1);
    }
    
    /**
     * \brief Recursive helper method for {@see #buildLiteral(boolean)}.
     */
    protected FExp Array.buildLiteralHelper(Iterator<FExp> it, boolean toReal, int dim) {
    	FArray arr = new FArray(new List<FExp>());
    	int n = size()[dim - 1];
    	if (dim < ndims()) {
    		for (int i = 0; i < n; i++)
    			arr.addFExp(buildLiteralHelper(it, toReal, dim + 1));
    	} else {
    		if (toReal) {
	    		for (int i = 0; i < n; i++) 
	    			arr.addFExp(it.next().ceval().convertReal().buildLiteral());
        	} else {
	    		for (int i = 0; i < n; i++) 
	    			arr.addFExp(it.next().ceval().buildLiteral());
        	}
    	}
    	return arr;
    }
    
    /**
     * \brief Recursive helper method for {@see #buildLiteral(boolean)}.
     */
    protected FExp ScalarAsArray.buildLiteralHelper(Iterator<FExp> it, boolean toReal, int dim) {
    	CValue c = it.next().ceval();
    	if (toReal)
    		c = c.convertReal();
    	return c.buildLiteral();
    }
    
  /**
   * \brief Returns the constant value of a flat expression. 
   * 
   * If the expression is not constant, or if it contains type errors, a 
   * CValueUnknown object is returned.
   * 
   * The actual evaluation of concrete FExp nodes is performed by dispatching
   * with respect to the primitive type of the expression. For example, when an
   * FAddExp node is evaluated, the computation proceeds in the following steps:
   * 
   *  - The primitive type of the expression is retreived using the type()
   *    attribute.
   *  - The method add() defined for FPrimitiveType is invoked.
   *  - The resulting CValue is returned. 
   *  
   *  Using this strategy, a particular FExp node need not know the details of
   *  how to evaluate itself in the case of operands of different types. Rather,
   *  these computations are delegated to the respective types. In particular,
   *  this design simplifies the task of extending the evaluation framework
   *  to composite types such as arrays and complex numbers. In addition
   *  the type dispatch makes implementation of support for operator overloading
   *  simpler.
   * 
   * @return The constant value of the expression.
   */
  syn CValue FExp.ceval() = new CValueUnknown();
  
  eq FDotAddExp.ceval() = type().add(getLeft().ceval(), getRight().ceval());
  eq FDotSubExp.ceval() = type().sub(getLeft().ceval(), getRight().ceval());
  eq FDotMulExp.ceval() = type().mul(getLeft().ceval(), getRight().ceval());
  eq FDotDivExp.ceval() = type().div(getLeft().ceval(), getRight().ceval());
  eq FDotPowExp.ceval() = type().pow(getLeft().ceval(), getRight().ceval());
  
  eq FNegExp.ceval() = type().neg(getFExp().ceval());
  
  eq FAndExp.ceval() = type().and(getLeft().ceval(), getRight().ceval());
  eq FOrExp.ceval()  = type().or(getLeft().ceval(), getRight().ceval());
  eq FNotExp.ceval() = type().not(getFExp().ceval());
  
  // TODO: expand to handle boolean end enum index
  eq FEndExp.ceval() = new CValueInteger(retrieveEnd());
  
  eq FSizeExp.ceval() {
	  if (!hasDim())
		  return new CValueUnknown();
	  int dim = getDim().ceval().intValue() - 1;
	  int[] size = getFExp().size();
	  return new CValueInteger(size[dim]);
  }
  
  eq FMinMaxExp.ceval() {
	  if (hasY()) {
		  CValue x = getX().ceval();
		  CValue y = getY().ceval();
		  boolean selectX = type().lt(x, y).booleanValue() ^ !selectLesser();
		  return selectX ? x : y;
	  } else {
		  Iterator<FExp> it = getX().getArray().iteratorFExp();
		  boolean less = selectLesser();
		  CValue sel = it.next().ceval();
		  while (it.hasNext()) {
			  CValue val = it.next().ceval();
			  if (type().lt(val, sel).booleanValue() ^ !less)
				  sel = val;
		  }
		  return sel;
	  }
  }
  
  syn boolean FMinMaxExp.selectLesser();
  eq FMinExp.selectLesser() = true;
  eq FMaxExp.selectLesser() = false;
  
  inh int FEndExp.retrieveEnd();
  eq FExpSubscript.getChild().retrieveEnd() = mySize()[0];
  eq Root.getChild().retrieveEnd()          = 0;

  eq FRealLitExp.ceval() = new CValueReal(Double.parseDouble(getUNSIGNED_NUMBER()));
  eq FIntegerLitExp.ceval() = new CValueInteger(Integer.parseInt(getUNSIGNED_INTEGER()));
  eq FBooleanLitExpTrue.ceval() = new CValueBoolean(true);
  eq FBooleanLitExpFalse.ceval() = new CValueBoolean(false);
  eq FStringLitExp.ceval() = new CValueString(getString());
  
  eq FIdUseExp.ceval() {
   	if (myFV()!=null && !myFV().isUnknown()) {
   		return myFV().ceval();
   	} else {
   		return new CValueUnknown();
   	}
  }
  eq FInstAccessExp.ceval() = getInstAccess().ceval();
  
  syn CValue InstAccess.ceval() = new CValueUnknown();
  eq InstDot.ceval()            = getRight().ceval();
  eq InstComponentAccess.ceval() {
	  if (myInstComponentDecl().isPrimitive()) {
		  InstPrimitive prim = (InstPrimitive) myInstComponentDecl();
		  return prim.ceval(hasFArraySubscripts() ? getFArraySubscripts().asIndex() : Index.NULL);
	  }
	  return new CValueUnknown();
  }

  eq FSinExp.ceval() = new CValueReal(java.lang.Math.sin(getFExp().ceval().realValue()));
  eq FCosExp.ceval() = new CValueReal(java.lang.Math.cos(getFExp().ceval().realValue()));
  eq FTanExp.ceval() = new CValueReal(java.lang.Math.tan(getFExp().ceval().realValue()));	  
  eq FAsinExp.ceval() = new CValueReal(java.lang.Math.asin(getFExp().ceval().realValue()));
  eq FAcosExp.ceval() = new CValueReal(java.lang.Math.acos(getFExp().ceval().realValue()));
  eq FAtanExp.ceval() = new CValueReal(java.lang.Math.atan(getFExp().ceval().realValue()));	  
  eq FAtan2Exp.ceval() = new CValueReal(java.lang.Math.atan2(getFExp().ceval().realValue(),
		                                                     getY().ceval().realValue()));	  
  eq FSinhExp.ceval() = new CValueReal(java.lang.Math.sinh(getFExp().ceval().realValue()));
  eq FCoshExp.ceval() = new CValueReal(java.lang.Math.cosh(getFExp().ceval().realValue()));
  eq FTanhExp.ceval() = new CValueReal(java.lang.Math.tanh(getFExp().ceval().realValue()));	  
  eq FExpExp.ceval() = new CValueReal(java.lang.Math.exp(getFExp().ceval().realValue()));
  eq FLogExp.ceval() = new CValueReal(java.lang.Math.log(getFExp().ceval().realValue()));
  eq FLog10Exp.ceval() = new CValueReal(java.lang.Math.log10(getFExp().ceval().realValue()));	  
  eq FSqrtExp.ceval() = new CValueReal(java.lang.Math.sqrt(getFExp().ceval().realValue()));	  

	/**
	 * \brief Evaluation of a primitive instance node located in the instance
	 * AST.
	 * 
	 * In some situations, expressions are evaluated in the instance AST. 
	 * Such expressions are then instantiated, but not yet flattened. As a
	 * consequence, identifiers in expressions refers to InstPrimitive nodes,
	 * and accordingly, it it necessary to compute the constant value 
	 * corresponding to an InstPrimitive node. If the primitive is a
	 * constant or a parameters, and if it has a binding expressions, then
	 * a corresponding CValue object is returned, otherwise, CValueUnknown
	 * is returned.
	 * 
	 * @return The constant value.
	 */
	syn CValue InstPrimitive.ceval() {
		return ceval(Index.NULL);
	}
	

	/**
	 * \brief Evaluation of a primitive instance node located in the instance
	 * AST. Evaluates a specific cell if this primitive is an array.
	 * 
	 * If primitive is not an array, <code>i</code> should be Index.NULL.
	 *  
	 * In some situations, expressions are evaluated in the instance AST. 
	 * Such expressions are then instantiated, but not yet flattened. As a
	 * consequence, identifiers in expressions refers to InstPrimitive nodes,
	 * and accordingly, it it necessary to compute the constant value 
	 * corresponding to an InstPrimitive node. If the primitive is a
	 * constant or a parameters, and if it has a binding expressions, then
	 * a corresponding CValue object is returned, otherwise, CValueUnknown
	 * is returned.
	 * 
	 * @return The constant value.
	 */
	syn CValue InstPrimitive.ceval(Index i) {
	    if ((isConstant() || isParameter()) && 
	    		myBindingInstExp() != null &&
	    		!myBindingInstExp().type().isUnknown() && 
	    		indices().isValid(i)) {
	    	CValue val = myBindingInstExp().getArray().get(i).ceval();
	    	// Reals can be have a binding exp that is Integer - convert
			if (isReal())
				val = new CValueReal(val.realValue());
			return val;
		} else { 
			return new CValueUnknown();
		}
	}

  /**
   * \brief Constant evaluation of FVariable binding expressions.
   * 
   * If an expression is evaluated in an FClass, then identifiers are 
   * referencing FVariables. The constant value of an FVariable is computed
   * by evaluating the binding expression of the variable, if any. If the
   * FVariable is not a constant or a parameters, or if it has no binding
   * expressions, then a CValueUnknown object is returned.
   * 
   *  @return The constant value.
   */
  syn CValue AbstractFVariable.ceval();
  eq UnknownFVariable.ceval() = new CValueUnknown();
  eq FDerivativeVariable.ceval() = new CValueUnknown();
  eq FFunctionVariable.ceval() = new CValueUnknown(); // TODO: Can they be constant? maybe parameters? 
  eq FRealVariable.ceval() {
	  if ((!isConstant() && !isParameter()) || !hasBindingExp()) {
		  return new CValueUnknown();
	  } else {
			CValue val = getBindingExp().ceval();
			if (val.isNumeric()) {
				return new CValueReal(val.realValue());
			} else {
				return new CValueUnknown();
			}
	  }
  }

  eq FIntegerVariable.ceval() {
	  if ((!isConstant() && !isParameter()) || !hasBindingExp()) {
		  return new CValueUnknown();
	  } else {
			CValue val = getBindingExp().ceval();
			if (val.isNumeric()) {
				return new CValueInteger(val.intValue());
			} else {
				return new CValueUnknown();
			}
	  }
  }

  eq FBooleanVariable.ceval() {
	  if ((!isConstant() && !isParameter()) || !hasBindingExp()) {
		  return new CValueUnknown();
	  } else {
		  return getBindingExp().ceval();
	  }
  }

  eq FStringVariable.ceval() {
	  if ((!isConstant() && !isParameter()) || !hasBindingExp()) {
		  return new CValueUnknown();
	  } else {
		  return getBindingExp().ceval();
	  }
  }
  
  /**
   * \brief Addition of constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.add(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FRealScalarType.add(CValue v1, CValue v2) = 
	  new CValueReal(v1.realValue() + v2.realValue());
  eq FIntegerScalarType.add(CValue v1, CValue v2) = 
	  new CValueInteger(v1.intValue() + v2.intValue());

  /**
   * \brief Subtraction of constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.sub(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FRealScalarType.sub(CValue v1, CValue v2) = 
	  new CValueReal(v1.realValue() - v2.realValue());
  eq FIntegerScalarType.sub(CValue v1, CValue v2) = 
	  new CValueInteger(v1.intValue() - v2.intValue());

  /**
   * \brief Multiplication of constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.mul(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FRealScalarType.mul(CValue v1, CValue v2) = 
	  new CValueReal(v1.realValue()*v2.realValue());
  eq FIntegerScalarType.mul(CValue v1, CValue v2) = 
	  new CValueInteger(v1.intValue()*v2.intValue());

  /**
   * \brief Division of constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.div(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FRealScalarType.div(CValue v1, CValue v2) = 
	  new CValueReal(v1.realValue()/v2.realValue());
  eq FIntegerScalarType.div(CValue v1, CValue v2) = 
	  new CValueReal(v1.realValue()/v2.realValue());

  /**
   * \brief Power expression for constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.pow(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FRealScalarType.pow(CValue v1, CValue v2) =
	  new CValueReal(java.lang.Math.pow(v1.realValue(),v2.realValue()));
  
  eq FIntegerScalarType.pow(CValue v1, CValue v2) = 
	  new CValueReal(java.lang.Math.pow(v1.realValue(),v2.realValue()));

  /**
   * \brief Negation of a constant value.
   * 
   * @param v Constant value of operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.neg(CValue v) = 
	  new CValueUnknown();
  eq FRealScalarType.neg(CValue v) = new CValueReal(-v.realValue());
  eq FIntegerScalarType.neg(CValue v) = new CValueInteger(-v.intValue());

	syn CValue FSubscript.ceval() = new CValueUnknown();
	eq FExpSubscript.ceval() = getFExp().ceval();

  /**
   * \brief And expression for constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.and(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FBooleanScalarType.and(CValue v1, CValue v2) = 
	  new CValueBoolean(v1.booleanValue() && v2.booleanValue());

  /**
   * \brief Or expression for constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.or(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FBooleanScalarType.or(CValue v1, CValue v2) = 
	  new CValueBoolean(v1.booleanValue() || v2.booleanValue());

  /**
   * \brief Not expression for constant values.
   * 
   * @param v Constant value of operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.not(CValue v) = 
	  new CValueUnknown();
  eq FBooleanScalarType.not(CValue v) = 
	  new CValueBoolean(!v.booleanValue());
  
  /**
   * \brief Less than comparison for constant values.
   * 
   * @param v1 Constant value of left operand.
   * @param v2 Constant value of right operand.
   * @return Resulting constant value.
   */
  syn CValue FPrimitiveType.lt(CValue v1, CValue v2) = 
	  new CValueUnknown();
  eq FBooleanScalarType.lt(CValue v1, CValue v2) = 
	  new CValueBoolean(!v1.booleanValue() && v2.booleanValue());
  eq FRealScalarType.lt(CValue v1, CValue v2) = 
	  new CValueBoolean(v1.realValue() < v2.realValue());
  eq FIntegerScalarType.lt(CValue v1, CValue v2) = 
	  new CValueBoolean(v1.intValue() < v2.intValue());
  eq FStringScalarType.lt(CValue v1, CValue v2) = 
	  new CValueBoolean(v1.stringValue().compareTo(v2.stringValue()) < 0);
	  
}

aspect ArrayConstantEvaluation {
	
	/**
	 * \brief Returns the set of array indices spanned by a component declared with this subscript.
	 */
	syn int[] FSubscript.arrayIndices() = new int[0];
	eq FExpSubscript.arrayIndices() {
		int s = numIndices();
		int ind[] = new int[s];
		for (int i = 0; i < s; i++) 
			ind[i] = i + 1;
		return ind;
	}

	
	/**
	 * \brief Get the number of array indices spanned by a component declared with this subscript.
	 */
	syn int FSubscript.numIndices() = 0;
	eq FExpSubscript.numIndices() = getFExp().ceval().intValue();

}

aspect CircularExpressions {

	syn lazy boolean FExp.isCircular() circular [true] = false;
	
	eq FBinExp.isCircular() = getLeft().isCircular() | getRight().isCircular();
	eq FUnaryExp.isCircular() = getFExp().isCircular();
	
	eq FIdUseExp.isCircular() = myFV().isCircular();
	eq FInstAccessExp.isCircular() = getInstAccess().myInstComponentDecl().isCircular();	
	eq FFunctionCall.isCircular() {
		for (FExp e : getArgs()) {
			if (e.isCircular()) {
				return true;
			}
		}
		return false;
	}
	eq FSumRedExp.isCircular() = getFExp().isCircular() | getFForIndex().isCircular();
	syn lazy boolean FForIndex.isCircular() circular [true] = hasFExp()? getFExp().isCircular(): false;
	eq FIfExp.isCircular() {
		if (getIfExp().isCircular() | getThenExp().isCircular() | getElseExp().isCircular()) {
			return true;
		} else {
			for (FElseIfExp ee : getFElseIfExps()) {
				if (ee.isCircular()) {
					return true;
				}
			}
		} 
		return false;
	}
	eq FElseIfExp.isCircular() = getIfExp().isCircular() | getThenExp().isCircular();
	eq FArray.isCircular() {
		for (FExp e : getFExps()) {
			if (e.isCircular()) {
				return true;
			}
		}
		return false;
	}
	
	// TODO: Add FMatrix

	eq FRangeExp.isCircular() {
		for (FExp e : getFExps()) {
			if (e.isCircular()) {
				return true;
			}
		}
		return false;
	}
	
	eq FMathematicalFunctionCall.isCircular() = getFExp().isCircular();
	eq FAtan2Exp.isCircular() = getFExp().isCircular() || getY().isCircular();
	eq FSizeExp.isCircular() = getFExp().isCircular() || (hasDim() && getDim().isCircular());
	eq FMinMaxExp.isCircular() = getX().isCircular() || (hasY() && getY().isCircular());
	eq FOnes.isCircular() {
		for (FExp e : getFExps()) {
			if (e.isCircular()) {
				return true;
			}
		}
		return false;
	}
	eq FZeros.isCircular() {
		for (FExp e : getFExps()) {
			if (e.isCircular()) {
				return true;
			}
		}
		return false;
	}
	
	
	

	syn lazy boolean AbstractFVariable.isCircular() circular [true] = false;
	eq FVariable.isCircular() {
		if (hasBindingExp()) {
		 	return getBindingExp().isCircular();
		} else {
		    return false;
		}
	}
	
	syn lazy boolean InstComponentDecl.isCircular() circular [true] = false;
	eq InstPrimitive.isCircular() {
		if (myBindingInstExp()!=null) {
		 	return myBindingInstExp().isCircular();
		} else {
		    return false;
		}	
	}	
	

}