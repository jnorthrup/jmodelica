/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.HashSet;
import java.util.Map;
import java.util.ArrayList;
import java.util.LinkedHashSet;

aspect RootAccess {
	
	inh lazy Root ASTNode.retrieveRoot();
	eq SourceRoot.getChild().retrieveRoot() = this;
	eq FlatRoot.getFClass().retrieveRoot() = this;
	syn lazy Root ASTNode.root() = retrieveRoot();
	eq Root.root() = this;
	
	syn lazy List ASTNode.emptyList() = root().emptyList();
	eq Root.emptyList() = getEmptyList();
	syn lazy List Root.getEmptyList() = new List();
	
	syn lazy HashSet ASTNode.emptyHashSet() = root().emptyHashSet();
	eq Root.emptyHashSet() = getEmptyHashSet();
	syn lazy HashSet Root.getEmptyHashSet() = new HashSet(4);
	
	syn lazy ArrayList ASTNode.emptyArrayList() = root().emptyArrayList();
	eq Root.emptyArrayList() = getEmptyArrayList();
	syn lazy ArrayList Root.getEmptyArrayList() = new ArrayList();
		
	/*
	 * The Parser methods are introduced here so that they can be refined in
	 * extensions where other parsers are used.
	 */
	
	public SourceRoot ParserHandler.parseFile(String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		return parseModelicaFile(fileName);
	}
	
	public SourceRoot ParserHandler.parseString(String str, String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		return parseModelicaString(str,fileName);
	}
	
	public Exp ParserHandler.parseExpString(String str)
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		return parseModelicaExpString(str);
	}
	
	public SourceRoot ParserHandler.parseModelicaFile(String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		SourceRoot sr = null;
		Reader reader = new FileReader(fileName);
		org.jmodelica.modelica.parser.ModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.ModelicaScanner(new BufferedReader(reader));
		org.jmodelica.modelica.parser.ModelicaParser parser = new org.jmodelica.modelica.parser.ModelicaParser();
		parser.setLineBreakMap(scanner.getLineBreakMap());
		sr = (SourceRoot)parser.parse(scanner);
		sr.setFileName(fileName);
		return sr;
	}
	
	public SourceRoot ParserHandler.parseModelicaString(String str, String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		SourceRoot sr = null;
		org.jmodelica.modelica.parser.ModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.ModelicaScanner(new StringReader(str));
		org.jmodelica.modelica.parser.ModelicaParser parser = 
			new org.jmodelica.modelica.parser.ModelicaParser();
		parser.setLineBreakMap(scanner.getLineBreakMap());
		sr = (SourceRoot)parser.parse(scanner);
		sr.setFileName(fileName);
		return sr;
	}
	
	public Exp ParserHandler.parseModelicaExpString(String str)
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		Exp exp = null;
		org.jmodelica.modelica.parser.ModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.ModelicaScanner(new StringReader(str));
		org.jmodelica.modelica.parser.ModelicaParser parser = 
			new org.jmodelica.modelica.parser.ModelicaParser();
		exp = (Exp)parser.parse(scanner,org.jmodelica.modelica.parser.ModelicaParser.AltGoals.exp);
		//System.out.println("ModelicaParser.parseExpString: "+str);
		//exp.dumpTreeBasic("");
		return exp;
	}

	public FlatRoot ParserHandler.parseFlatModelicaFile(String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		FlatRoot fr = null;
		Reader reader = new FileReader(fileName);
		org.jmodelica.modelica.parser.FlatModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.FlatModelicaScanner(new BufferedReader(reader));
		org.jmodelica.modelica.parser.FlatModelicaParser parser = 
			new org.jmodelica.modelica.parser.FlatModelicaParser();
		fr = (FlatRoot)parser.parse(scanner);
		fr.setFileName(fileName);
		return fr;
	}
	
	public FlatRoot ParserHandler.parseFlatModelicaString(String str, String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		FlatRoot fr = null;
		org.jmodelica.modelica.parser.FlatModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.FlatModelicaScanner(new StringReader(str));
		org.jmodelica.modelica.parser.FlatModelicaParser parser = 
			new org.jmodelica.modelica.parser.FlatModelicaParser();
		fr = (FlatRoot)parser.parse(scanner);
		fr.setFileName(fileName);
		return fr;
	}
	
	public FExp ParserHandler.parseFlatModelicaExpString(String str)
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		FExp fexp = null;
		org.jmodelica.modelica.parser.FlatModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.FlatModelicaScanner(new StringReader(str));
		org.jmodelica.modelica.parser.FlatModelicaParser parser = 
			new org.jmodelica.modelica.parser.FlatModelicaParser();
		fexp = (FExp)parser.parse(scanner,org.jmodelica.modelica.parser.FlatModelicaParser.AltGoals.fexp);
		return fexp;
	}
	
}

aspect DebugPrint {

	public int ASTNode.printLevel = 0;
	public void ASTNode.debugPrint(Object msg) {
		if (printLevel>0)
			System.out.println(msg);
	}
	
}

aspect NodeMethods {

  public void ASTNode.setStart(int start) {
    this.start = start;  
  } 

  public void ASTNode.setEnd(int end) {
    this.end = end;  
  } 
 
  public int ASTNode.beginLine() { return getLine(getStart()); }
  public int ASTNode.beginColumn() { return getColumn(getStart()); }

	public String ASTNode.getNodeName() {
		return dump();
	}
	
	public String IdDecl.getNodeName() {
		return dump() + ": '" + getID() + "'";
	}

	public String Access.getNodeName() {
		return dump() + ": '" + getID() + "'";
	}
	
	public String RealLitExp.getNodeName() {
		return dump() + ": " + getUNSIGNED_NUMBER();
	}
	
	public String InstComponentDecl.getNodeName() {
		return dump() + ": '" + getComponentDecl().getClassName().qualifiedName() + " " + getComponentDecl().getName().getID() + "'";
	}

}

aspect FileNames {

	syn lazy String ASTNode.fileName() = retrieveFileName();
	eq StoredDefinition.fileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	
	eq Root.fileName() = getFileName();
	
	inh lazy String ASTNode.retrieveFileName();
	eq SourceRoot.getProgram().retrieveFileName() = getFileName();
	eq FlatRoot.getFClass().retrieveFileName() = getFileName();
	
	eq StoredDefinition.getChild().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getChild().retrieveFileName() =  retrieveFileName();
	eq InstNode.getInstClassDecl(int i).retrieveFileName() = getInstClassDecl(i).getClassDecl().fileName(); 
	eq InstFullClassDecl.getChild().retrieveFileName() = getClassDecl().fileName();
	eq InstComponentDecl.getChild().retrieveFileName() = getComponentDecl().fileName();
	eq InstExtends.getChild().retrieveFileName() = getExtendsClause().fileName();
	eq InstImport.getChild().retrieveFileName() = getImportClause().fileName();
	eq InstModification.getChild().retrieveFileName() = getModification().fileName();
	
	private String Root.fName = "";
	public void Root.setFileName(String fName) { this.fName = fName; }
	public String Root.getFileName() {return fName; }

	private String StoredDefinition.fName = "";
	public void StoredDefinition.setFileName(String fName) { this.fName = fName; }
	public String StoredDefinition.getFileName() {return fName; }
}
	
aspect Names {
  // simple names
  syn String Access.name() = getID();
  syn String ParseAccess.name() = getID();
  syn String ClassAccess.name() = getID();
  syn String AmbiguousAccess.name() = getID();
  syn String ComponentAccess.name() = getID();
  syn String IdDecl.name() = getID();
  syn String Dot.name() = getLeft().name() + "." + getRight().name();
  
   // simple names of InstAccess:es
  syn String InstAccess.name() = getID();
  syn String InstParseAccess.name() = getID();
  syn String InstClassAccess.name() = getID();
  syn String InstAmbiguousAccess.name() = getID();
  syn String InstComponentAccess.name() = getID();
  syn String InstDot.name() = getLeft().name() + "." + getRight().name(); 
  
  syn lazy String Access.qualifiedName() = getID();
  eq Dot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn lazy String InstAccess.qualifiedName() = getID();
  eq InstDot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn String ClassDecl.name();
  eq BaseClassDecl.name() = getName().getID();
  eq BuiltInClassDecl.name() = getName().getID();
  //eq LibNode.name() = getName();
  
  syn String ComponentDecl.name() = getName().getID();
  
  syn String ClassDecl.qualifiedName();
  eq BaseClassDecl.qualifiedName() = classNamePrefix().equals("")? 
                                                  name(): classNamePrefix() + "." + name();
  inh String BaseClassDecl.classNamePrefix();
  eq FullClassDecl.getClassDecl().classNamePrefix() = classNamePrefix().equals("")?
                                                      name(): classNamePrefix() + "." + name();
  eq BuiltInClassDecl.qualifiedName() = getName().getID();
  
  eq SourceRoot.getProgram().classNamePrefix() = "";
  
  syn String InstClassDecl.qualifiedName();
  eq InstBaseClassDecl.qualifiedName() = instClassNamePrefix().equals("")? 
                                                  name(): instClassNamePrefix() + "." + name();
  inh String InstBaseClassDecl.instClassNamePrefix();
  eq InstFullClassDecl.getInstClassDecl().instClassNamePrefix() = instClassNamePrefix().equals("")?
                                                      name(): instClassNamePrefix() + "." + name();

  eq InstBuiltInClassDecl.qualifiedName() = name();
  
  eq SourceRoot.getChild().instClassNamePrefix() = "";
  eq InstRoot.getChild().instClassNamePrefix() = "";
  
  syn String FunctionCall.name() = getName().name();
  
  syn String InstClassDecl.primitiveName();
  eq InstBaseClassDecl.primitiveName() = name();
  eq InstBuiltInClassDecl.primitiveName() = name();
  
  eq InstFullClassDecl.primitiveName() {
  	if (extendsPrimitive())
  		return getInstExtends(0).getClassName().myInstClassDecl().finalClass().primitiveName();
  	else 
  		return name();
  }
  
  inh InstClassDecl ASTNode.enclosingInstClassDecl();
  eq SourceRoot.getProgram().enclosingInstClassDecl() = null;
  eq FlatRoot.getChild().enclosingInstClassDecl() = null;
  eq InstBaseClassDecl.getChild().enclosingInstClassDecl() = this;
  eq InstComponentDecl.getChild().enclosingInstClassDecl() = myInstClass();
  
  inh BaseClassDecl ASTNode.enclosingClassDecl();
  eq SourceRoot.getProgram().enclosingClassDecl() = null;

  eq FullClassDecl.getEquation().enclosingClassDecl() = this; 
  eq FullClassDecl.getAlgorithm().enclosingClassDecl() = this; 
  eq FullClassDecl.getSuper().enclosingClassDecl() = this;  
  eq FullClassDecl.getImport().enclosingClassDecl() = this; 
  eq FullClassDecl.getClassDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getComponentDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getAnnotation().enclosingClassDecl() = this; 
  eq FullClassDecl.getExternalClause().enclosingClassDecl() = this; 	

  eq ShortClassDecl.getExtendsClauseShortClass().enclosingClassDecl() = this;
  
  eq ExtendClassDecl.getClassModification().enclosingClassDecl() = this;
  eq ExtendClassDecl.getComposition().enclosingClassDecl() = this;
  
  
   	/**
	 * Access method for the last Access of a qualified or
	 * unqualified name.
	 */ 
	syn Access Access.getLastAccess() = this;
    eq Dot.getLastAccess() = getRight().getLastAccess();
    
    syn InstAccess InstAccess.getLastInstAccess() = this;
    eq InstDot.getLastInstAccess() = getRight().getLastInstAccess();
    
    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn Access Access.getFirstAccess() = this;
    eq Dot.getFirstAccess() = getLeft().getFirstAccess();
   
   	inh Access Access.getNextAccess();
   	eq Dot.getLeft().getNextAccess() = getRight().getFirstAccess();
   	eq SourceRoot.getProgram().getNextAccess() = null;

    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn InstAccess InstAccess.getFirstInstAccess() = this;
    eq InstDot.getFirstInstAccess() = getLeft().getFirstInstAccess();
   
   	inh InstAccess InstAccess.getNextInstAccess();
   	eq InstDot.getLeft().getNextInstAccess() = getRight().getFirstInstAccess();
   	eq SourceRoot.getProgram().getNextInstAccess() = null;
    eq FlatRoot.getChild().getNextInstAccess() = null;

   	
   	/**
   	 * stripFirstAccess removes the first access in a qualified
   	 * name. If the name is not qualified, null is returned. 
   	 */
   	public Access Access.stripFirstAccess() {
   		return null;
   	}
   	
   	public Access Dot.stripFirstAccess() {
		// A right skewed Dot three is stipped by
		//getRight().myDecl();
		return (Access)getRight().fullCopy();
	}
   	
	syn boolean Access.isQualified() = false;
	eq Dot.isQualified() = true;
}

aspect FlatNames {
	
	public FQName.FQName(String name) {
		this(new List().add(new FQNamePart(name,new Opt())));
	}

	public FQName.FQName(FQName fqname) {
		this((List)fqname.getFQNamePartList().fullCopy());
	}

	public FQName FQName.append(InstAccess access,FQName prefix) {
		InstAccess fa = access.getFirstInstAccess();
		Opt as = null;
		if (fa.isInstArrayAccess()) {
			as = new Opt(fa.fArraySubscripts().flatten(prefix));
		} else {
			as = new Opt();
		}
		addFQNamePart(new FQNamePart(fa.name(),as));
		while (fa.getNextInstAccess()!=null) {
			fa = fa.getNextInstAccess();
			if (fa.isInstArrayAccess()) {
				as = new Opt(fa.fArraySubscripts().flatten(prefix));
			} else {
				as = new Opt();
			}
			addFQNamePart(new FQNamePart(fa.name(),as));
		}
		return this;
	}

	public FQName FQName.append(String name) {
		addFQNamePart(new FQNamePart(name, new Opt()));
		return this;
	}

	public FQName FQName.append(FQName fqname) {
		for (int i=0;i<fqname.getNumFQNamePart();i++)
			addFQNamePart((FQNamePart)fqname.getFQNamePart(i).fullCopy());
		return this;
	}

	syn boolean FQName.hasFArraySubscripts() = 
		getFQNamePart(getNumFQNamePart()-1).hasFArraySubscripts();
	syn FArraySubscripts FQName.getFArraySubscripts() = 
		getFQNamePart(getNumFQNamePart()-1).getFArraySubscripts();

	syn boolean FIdUse.hasFArraySubscripts() = 
		getFQName().hasFArraySubscripts();
	syn FArraySubscripts FIdUse.getFArraySubscripts() = 
		getFQName().getFArraySubscripts();

	syn boolean FIdUseExp.hasFArraySubscripts() = 
		getFIdUse().hasFArraySubscripts();
	syn FArraySubscripts FIdUseExp.getFArraySubscripts() = 
		getFIdUse().getFArraySubscripts();

	
	syn lazy FQName InstNode.getFQNamePrefix() {
		FQName prefix = retrieveFQName();
		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
		return myName;	
	}
	
	syn lazy FQName InstNode.getFQName() = getFQNamePrefix();
	
	eq InstComponentDecl.getFQName() {
		
		FQName prefix = retrieveFQName();
		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
	
		Opt array_subscr = new Opt();
		if (isPrimitive() && isArrayDecl() ) {
			array_subscr.setChild((FArraySubscripts)getFArraySubscripts().flatten(myName),0);
		}
		
		myName.addFQNamePart(new FQNamePart(name(),array_subscr));
		return myName;
	}
	
	eq InstArrayComponentDecl.getFQName() {
		FQName prefix = retrieveFQName();

		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
		
		FArraySubscripts fas = new FArraySubscripts(
				new List().add(new FExpSubscript(new FIntegerLitExp(getIndex()+""))));

		if (myName.getFQNamePart(myName.getNumFQNamePart()-1).hasFArraySubscripts()) {
			myName.getFQNamePart(myName.getNumFQNamePart()-1).getFArraySubscripts().addFSubscript(fas.getFSubscript(0));
		} else {
			myName.getFQNamePart(myName.getNumFQNamePart()-1).setFArraySubscripts(fas);
		}
		return myName;
	}	

	eq InstClassDecl.getFQName() = new FQName();
	inh lazy FQName InstNode.retrieveFQName();
	eq InstComponentDecl.getChild().retrieveFQName() = getFQName();
	eq InstComponentDecl.getInstModification().retrieveFQName() = retrieveFQName();
	eq InstReplacingShortClassDecl.getChild().retrieveFQName() = retrieveFQName();
	eq InstClassDecl.getChild().retrieveFQName() = null; //getFQName();
	
	eq InstRoot.getChild().retrieveFQName() = null;
	eq SourceRoot.getProgram().retrieveFQName() = null;

	syn lazy String FQName.name() {
		StringBuffer str = new StringBuffer();
		for (int i=0;i<getNumFQNamePart();i++) {
			str.append(getFQNamePart(i).getName());
			if (i<getNumFQNamePart()-1) {
				if (getFQNamePart(i).hasFArraySubscripts()) {
					str.append(getFQNamePart(i).getFArraySubscripts().prettyPrint(""));
				}
				str.append(".");
			}
		}
		return str.toString();
	}
	
	syn String FQNamePart.name() = getName();

	syn String FIdUse.name() = getFQName().name();
	syn String FIdUseExp.name() = getFIdUse().name();
	eq FDer.name() = derName();
	syn String FInstAccessExp.name() = getInstAccess().name();
    syn String FIdUseInstAccess.name() = getInstAccess().name();
	
	syn String FIdDecl.name() = getFQName().name();

	syn String FClass.name() = getFQName().name();
	syn String FVariable.name() = getFQName().name();

//	syn lazy String FQName.derName() = "der(" + name() + ")";
	
	eq FDerivativeVariable.name() = getFQName().derName();
	syn String FIdUse.derName() = getFQName().derName();
	syn String FIdUseExp.derName() = getFIdUse().derName();

	syn lazy String FQName.derName() {
		StringBuffer str = new StringBuffer();
		for (int i=0;i<getNumFQNamePart();i++) {
			if (i==getNumFQNamePart()-1) {
				str.append("der(");
			}			
			str.append(getFQNamePart(i).getName());
			if (i<getNumFQNamePart()-1) {
				str.append(".");
			} 
		}
		str.append(")");
		return str.toString();
	}
	
	
	//syn String FIdUse.derName2() = getFQName().derName2();
	//syn String FIdUseExp.derName2() = getFIdUse().derName2();
	
	syn lazy String FQName.nameUnderscore() {
		StringBuffer str = new StringBuffer();
		for (int i=0;i<getNumFQNamePart();i++) {
			str.append(getFQNamePart(i).getName());
			if (i<getNumFQNamePart()-1)
				str.append("_");
		}
		return str.toString();
	}
	syn String FQNamePart.nameUnderscore() = getName();

	syn String FIdUse.nameUnderscore() = getFQName().nameUnderscore();
	syn String FIdUseExp.nameUnderscore() = getFIdUse().nameUnderscore();
	eq FDer.nameUnderscore() = "der_" + getFIdUse().nameUnderscore();
	//syn String FInstAccessExp.nameUnderscore() = getInstAccess().nameUnderscore();
    //syn String FIdUseInstAccess.nameUnderscore() = getInstAccess().nameUnderscore();
	
	syn String FIdDecl.nameUnderscore() = getFQName().nameUnderscore();

	syn String FClass.nameUnderscore() = getFQName().nameUnderscore();
	syn String FVariable.nameUnderscore() = getFQName().nameUnderscore();
	syn String FDerivativeVariable.nameUnderscore() = "der_" + getFQName().nameUnderscore();
}

aspect Visibility {
	
	syn boolean BaseClassDecl.isPublic() = getVisibilityType().isPublic();
	syn boolean ComponentDecl.isPublic() = getVisibilityType().isPublic();

	syn boolean BaseClassDecl.isProtected() = getVisibilityType().isProtected();
	syn boolean ComponentDecl.isProtected() = getVisibilityType().isProtected();

	syn boolean VisibilityType.isPublic() = false;
	eq PublicVisibilityType.isPublic() = true;

	syn boolean VisibilityType.isProtected() = false;
	eq ProtectedVisibilityType.isProtected() = true;

	syn boolean FVisibilityType.isPublic() = false;
	eq FPublicVisibilityType.isPublic() = true;

	syn boolean FVisibilityType.isProtected() = false;
	eq FProtectedVisibilityType.isProtected() = true;

	syn boolean FVariable.isPublic() = getFVisibilityType().isPublic();
	syn boolean FVariable.isProtected() = getFVisibilityType().isProtected();
	
}

aspect ComponentDeclMethods {
   	/**
   	 * Check if a ComponentDecl is declared flow.
   	 */
   	syn boolean ComponentDecl.isFlow() {
   	
   		if (hasTypePrefixFlow())
   			return true;
   	
   		return false;
   	}

   	/**
   	 * Check if a ComponentDecl is declared parameter.
   	 */
   	syn boolean ComponentDecl.isParameter() {
   	
   		if (hasTypePrefixVariability())
   			if (getTypePrefixVariability() instanceof Parameter)
   				return true;
   	
   		return false;
   	}
   	  
   	/**
   	 * Check if a ComponentDecl is declared inner.
   	 */
   	syn boolean ComponentDecl.isInner() {
		return hasInner();
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared outer.
   	 */
   	syn boolean ComponentDecl.isOuter() {
		return hasOuter();
   	}
   	
   	
   	 /**
   	 * Check if a ComponentDecl is declared constant.
   	 */
   	syn boolean ComponentDecl.isConstant() {
   	
   		if (hasTypePrefixVariability())
   			if (getTypePrefixVariability() instanceof Constant)
   				return true;
   	
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isDiscrete() {
   	
   		if (hasTypePrefixVariability())
   			if (getTypePrefixVariability() instanceof Discrete)
   				return true;
   	
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isInput() {
   	
   		if (hasTypePrefixInputOutput())
   			if (getTypePrefixInputOutput() instanceof Input)
   				return true;
   		if (myClass().isInput())
   			return true;
   		
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isOutput() {
   	
   		if (hasTypePrefixInputOutput())
   			if (getTypePrefixInputOutput() instanceof Output)
   				return true;
	    if (myClass().isOutput())
   			return true;
	    
   	
   		return false;
   	}

	syn boolean AbstractEquation.isInitial() {
		if (hasAbstractEquationModifier())
			if (getAbstractEquationModifier() instanceof Initial)
				return true;
		return false;
	
	}

	

}

aspect ShortClassUtil {
    // TODO: rename this attribute to finalAliasClass
	syn ClassDecl ClassDecl.finalClass() = this;
	eq ShortClassDecl.finalClass() = getExtendsClauseShortClass().getSuper().myClassDecl().finalClass();

	syn InstClassDecl InstClassDecl.finalClass() = this;
	eq InstShortClassDecl.finalClass() = getInstExtends(0).getClassName().myInstClassDecl().finalClass();

	syn BaseClassDecl BaseClassDecl.nextAliasClass() = null;
	eq ShortClassDecl.nextAliasClass() = (BaseClassDecl)getExtendsClauseShortClass().getSuper().myClassDecl();

	syn boolean BaseClassDecl.isAliasClass() = false;
	eq ShortClassDecl.isAliasClass() = true;

	syn boolean ClassDecl.isInput() = false;
	eq ShortClassDecl.isInput() {
		if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
   			if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Input)
   				return true;
		return getExtendsClauseShortClass().getSuper().myClassDecl().isInput();
	}
	
	syn boolean ClassDecl.isOutput() = false;
	eq ShortClassDecl.isOutput() {
		if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
   			if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Output)
   				return true;
		return getExtendsClauseShortClass().getSuper().myClassDecl().isOutput();
		
	}

/*
   syn boolean BaseClassDecl.hasModification() = false;
   eq ShortClassDecl.hasModification() = hasClassModification();
   
   syn Modification BaseClassDecl.getModification() = null;
   eq ShortClassDecl.getModification() = getClassModification();
*/
}

aspect AllElements {

	syn lazy HashSet ClassDecl.allLocalClassDecl() = emptyHashSet();
	eq ShortClassDecl.allLocalClassDecl() = finalClass().allLocalClassDecl();
	eq FullClassDecl.allLocalClassDecl() {
		LinkedHashSet set = new LinkedHashSet(); // This is to get the same order every time
		for (int i=0;i<numLocalClassDecl();i++) 
			set.add(localClassDecl(i));
		for (int i=0;i<getNumSuper();i++)
			set.addAll(getSuper(i).getSuper().myClassDecl().allLocalClassDecl());
		return set;
	}
	
    syn lazy HashSet ClassDecl.allLocalComponentDecl() = emptyHashSet();
	eq ShortClassDecl.allLocalComponentDecl() = finalClass().allLocalComponentDecl();
	eq FullClassDecl.allLocalComponentDecl() {
		debugPrint("<<<FullClassDecl.allLocalComponentDecl(): ");
		LinkedHashSet set = new LinkedHashSet();
		for (int i=0;i<getNumComponentDecl();i++) 
			set.add(getComponentDecl(i));
		for (int i=0;i<getNumSuper();i++)
			set.addAll(getSuper(i).getSuper().myClassDecl().allLocalComponentDecl());
		return set;
	}
	
}

aspect Math {
/*
	public boolean FFunctionCall.rewrittenToExp = false;
	rewrite FFunctionCall {
		when (getName().name().equals("Modelica.Math.sin") && 
		      !rewrittenToExp)
		      to FFunctionCall {
		      	rewrittenToExp = true;
		      	return new FFunctionCall(new FIdUse("sin"),new List().add(getArgs(0)));
		      }
	}
*/
}

aspect Streams {

        // Is this really not in the Standard library???
        class StringOutputStream extends OutputStream {
                StringBuffer str = new StringBuffer();
               
                public void write(int c) {
                        str.append((char)c);
                }

                public String toString() {
                        return str.toString();
                }
        }
}

aspect LineOffsets {
	private Map<Integer, Integer> StoredDefinition.lineBreakMap;
	
	public void StoredDefinition.setLineBreakMap(Map<Integer, Integer> map) {
		lineBreakMap = map;
	}
}

aspect ParserHelpers {

	/**
	 * An exception for parser errors.
	 */
	public class ParserException extends java.lang.RuntimeException {
		private Problem p;
		
		/**
		 * Default constructor.
		 */
		public ParserException(Problem p) {
			this.p = p;
		}
		
		/**
		 * Getter for problem.
		 */
		 public Problem getProblem() {
		 	return p;
		 }
		
	}
	
}
