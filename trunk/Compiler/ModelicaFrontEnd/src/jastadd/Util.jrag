/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.HashSet;
import java.util.Map;
import java.util.ArrayList;
import java.util.LinkedHashSet;

aspect RootAccess {
	
	syn String SourceRoot.language() = "Modelica";
	
	inh lazy Root ASTNode.retrieveRoot();
	eq SourceRoot.getChild().retrieveRoot() = this;
	eq FlatRoot.getChild().retrieveRoot()   = this;
	syn lazy Root ASTNode.root() = retrieveRoot();
	eq Root.root() = this;
	
	syn lazy List ASTNode.emptyList() = root().emptyList();
	eq Root.emptyList() = getEmptyList();
	syn lazy List Root.getEmptyList() = new List();
	
	syn lazy HashSet ASTNode.emptyHashSet() = root().emptyHashSet();
	eq Root.emptyHashSet() = getEmptyHashSet();
	syn lazy HashSet Root.getEmptyHashSet() = new HashSet(4);
	
	syn lazy ArrayList ASTNode.emptyArrayList() = root().emptyArrayList();
	eq Root.emptyArrayList() = getEmptyArrayList();
	syn lazy ArrayList Root.getEmptyArrayList() = new ArrayList();
	
	public boolean ASTNode.hasRoot() { return (getParent() == null) ? false : getParent().hasRoot(); }
	public boolean Root.hasRoot()    { return true; }
	
	public FClass ParserHandler.newFClass() {
		return new FClass();
	}
	
	/*
	 * The Parser methods are introduced here so that they can be refined in
	 * extensions where other parsers are used.
	 */
	
	public SourceRoot ParserHandler.parseFile(String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		return parseModelicaFile(fileName);
	}
	
	public SourceRoot ParserHandler.parseString(String str, String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		return parseModelicaString(str,fileName);
	}
	
	public Exp ParserHandler.parseExpString(String str)
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		return parseModelicaExpString(str);
	}
	
	public SourceRoot ParserHandler.parseModelicaFile(String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		SourceRoot sr = null;
		Reader reader = new FileReader(fileName);
		org.jmodelica.modelica.parser.ModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.ModelicaScanner(new BufferedReader(reader));
		org.jmodelica.modelica.parser.ModelicaParser parser = new org.jmodelica.modelica.parser.ModelicaParser();
		parser.setLineBreakMap(scanner.getLineBreakMap());
		sr = (SourceRoot)parser.parse(scanner);
		sr.setFileName(fileName);
		return sr;
	}
	
	public SourceRoot ParserHandler.parseModelicaString(String str, String fileName) 
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		SourceRoot sr = null;
		org.jmodelica.modelica.parser.ModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.ModelicaScanner(new StringReader(str));
		org.jmodelica.modelica.parser.ModelicaParser parser = 
			new org.jmodelica.modelica.parser.ModelicaParser();
		parser.setLineBreakMap(scanner.getLineBreakMap());
		sr = (SourceRoot)parser.parse(scanner);
		sr.setFileName(fileName);
		return sr;
	}
	
	public Exp ParserHandler.parseModelicaExpString(String str)
	   throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
		Exp exp = null;
		org.jmodelica.modelica.parser.ModelicaScanner scanner = 
			new org.jmodelica.modelica.parser.ModelicaScanner(new StringReader(str));
		org.jmodelica.modelica.parser.ModelicaParser parser = 
			new org.jmodelica.modelica.parser.ModelicaParser();
		exp = (Exp)parser.parse(scanner,org.jmodelica.modelica.parser.ModelicaParser.AltGoals.exp);
		//System.out.println("ModelicaParser.parseExpString: "+str);
		//exp.dumpTreeBasic("");
		return exp;
	}
	
}

aspect DebugPrint {

	public static final int ASTNode.printLevel = 0;
	public void ASTNode.debugPrint(Object msg) {
		if (printLevel>0)
			System.out.println(msg);
	}
	
}

aspect NodeMethods {

  public void ASTNode.setStart(int start) {
    this.start = start;
  } 

  public void ASTNode.setEnd(int end) {
    this.end = end;
  }
  
  public class ASTNode{
	  /**
	   * \brief Copies the <code>start</code> and <code>end</code> members to 
	   *        another node.
	   *        
	   * @param n  the node to copy the location to.
	   * @return  the node given as <code>n</code>.
	   */
	  public <N extends ASTNode> N copyLocationTo(N n) {
		  n.start = this.start;
		  n.end = this.end;
		  return n;
	  }
  }
  
  /**
   * \brief Sets the <code>start</code> and <code>end</code> members of the node.
   */
  public void ASTNode.setLocation(int start, int end) {
	this.start = start;
	this.end = end;
  }
  
  /**
   * \brief Sets the <code>start</code> and <code>end</code> members of the node
   * to values copied from two other nodes.
   * 
   * @param start  the node to copy the <code>start</code> member from.
   * @param end    the node to copy the <code>end</code> member from.
   */
  public void ASTNode.setLocation(ASTNode start, ASTNode end) {
	this.start = start.start;
	this.end = end.end;
  }
  
  /**
   * \brief Sets the <code>start</code> and <code>end</code> members of the node
   * to values copied another node.
   */
  public void ASTNode.setLocation(ASTNode node) {
	start = node.start;
	end = node.end;
  }
 
  public int ASTNode.beginLine() { return getLine(getStart()); }
  public int ASTNode.beginColumn() { return getColumn(getStart()); }

	public String ASTNode.getNodeName() {
		return dump();
	}
	
	public String IdDecl.getNodeName() {
		return dump() + ": '" + getID() + "'";
	}

	public String Access.getNodeName() {
		return dump() + ": '" + getID() + "'";
	}
	
	public String RealLitExp.getNodeName() {
		return dump() + ": " + getUNSIGNED_NUMBER();
	}
	
	public String InstComponentDecl.getNodeName() {
		return dump() + ": '" + getComponentDecl().getClassName().qualifiedName() + " " + getComponentDecl().getName().getID() + "'";
	}
	
	/**
	 * \brief Creates a new ArrayList containing all the elements in this list, in the same order.
	 */
	public ArrayList<T> List.toArrayList() {
		ArrayList<T> l = new ArrayList<T>();
		for (T e : this)
			l.add(e);
		return l;
	}
	
	/**
	 * \brief Replace <code>from</code> with <code>to</code>.
	 * 
	 * Search through children after <code>from</code>. If it is found, 
	 * replace it with <code>to</code> and return <code>true</code>.
	 * Comparisons are done with ==, not with equals().
	 */
	public boolean List.replaceChild(T oldNode, T newNode) {
		for (int i = 0; i < getNumChild(); i++) {
			if (getChild(i) == oldNode) {
				setChild(newNode, i);
				return true;
			}
		}
		return false;
	}
	
	/**
	 * \brief Return a copy of node that is not in any tree.
	 * 
	 * Returns <code>this</code> if node has no parent, <code>fullCopy()</code> otherwise.
	 */
	public ASTNode ASTNode.unboundCopy() {
		return (parent == null) ? this : fullCopy();
	}

}

aspect FileNames {

	syn lazy String ASTNode.fileName() = retrieveFileName();
	eq StoredDefinition.fileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	
	eq Root.fileName() = getFileName();
	
	inh lazy String ASTNode.retrieveFileName();
	eq SourceRoot.getProgram().retrieveFileName() = getFileName();
	eq FlatRoot.getFClass().retrieveFileName() = getFileName();
	
	eq StoredDefinition.getChild().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getChild().retrieveFileName() =  retrieveFileName();
	eq InstNode.getInstClassDecl(int i).retrieveFileName() = getInstClassDecl(i).getClassDecl().fileName(); 
	eq InstFullClassDecl.getChild().retrieveFileName() = getClassDecl().fileName();
	eq InstComponentDecl.getChild().retrieveFileName() = getComponentDecl().fileName();
	eq InstExtends.getChild().retrieveFileName() = getExtendsClause().fileName();
	eq InstImport.getChild().retrieveFileName() = getImportClause().fileName();
	eq InstModification.getChild().retrieveFileName() = getModification().fileName();
	
	private String Root.fName = "";
	public void Root.setFileName(String fName) { this.fName = fName; }
	public String Root.getFileName() {return fName; }

	private String StoredDefinition.fName = "";
	public void StoredDefinition.setFileName(String fName) { this.fName = fName; }
	public String StoredDefinition.getFileName() {return fName; }
}
	
aspect Names {
  // simple names
  syn String Access.name() = getID();
  syn String ParseAccess.name() = getID();
  syn String ClassAccess.name() = getID();
  syn String AmbiguousAccess.name() = getID();
  syn String ComponentAccess.name() = getID();
  syn String IdDecl.name() = getID();
  syn String Dot.name() = getLeft().name() + "." + getRight().name();
  
   // simple names of InstAccess:es
  syn String InstAccess.name() = getID();
  syn String InstParseAccess.name() = getID();
  syn String InstClassAccess.name() = getID();
  syn String InstAmbiguousAccess.name() = getID();
  syn String InstComponentAccess.name() = getID();
  syn String InstDot.name() = getLeftNoTransform().name() + "." + getRightNoTransform().name(); 
  
  syn String InstNamedModification.name() = getName().name();
  
  syn lazy String Access.qualifiedName() = getID();
  eq Dot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn lazy String InstAccess.qualifiedName() = getID();
  eq InstDot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn String ClassDecl.name();
  eq BaseClassDecl.name() = getName().getID();
  eq BuiltInClassDecl.name() = getName().getID();
  //eq LibNode.name() = getName();
  
  syn String ComponentDecl.name() = getName().getID();
  
  syn String FunctionCall.name() = getName().name();
  
  syn String InstImport.name();
  eq InstImportQualified.name()   = getPackageName().getLastInstAccess().name();
  eq InstImportRename.name()      = ((ImportClauseRename) getImportClause()).getIdDecl().getID();
  eq InstImportUnqualified.name() = "*";    // To avoid returning null
  
  
  syn String ClassDecl.qualifiedName();
  eq BaseClassDecl.qualifiedName() = classNamePrefix().equals("")? 
                                                  name(): classNamePrefix() + "." + name();
  inh String BaseClassDecl.classNamePrefix();
  eq FullClassDecl.getClassDecl().classNamePrefix() = classNamePrefix().equals("")?
                                                      name(): classNamePrefix() + "." + name();
  eq BuiltInClassDecl.qualifiedName() = getName().getID();
  
  eq SourceRoot.getProgram().classNamePrefix() = "";
  eq Root.getChild().classNamePrefix() = "";
    
  syn String InstClassDecl.qualifiedName();
  eq InstBaseClassDecl.qualifiedName() = instClassNamePrefix().equals("")? 
                                                  name(): instClassNamePrefix() + "." + name();
  inh String InstBaseClassDecl.instClassNamePrefix();
  eq InstFullClassDecl.getInstClassDecl().instClassNamePrefix() = instClassNamePrefix().equals("")?
                                                      name(): instClassNamePrefix() + "." + name();

  eq InstBuiltInClassDecl.qualifiedName() = name();
  
  eq SourceRoot.getChild().instClassNamePrefix() = "";
  eq FlatRoot.getChild().instClassNamePrefix() = "";
  eq InstRoot.getChild().instClassNamePrefix() = "";
  
  syn String InstClassDecl.primitiveName();
  eq InstBaseClassDecl.primitiveName() = name();
  eq InstBuiltInClassDecl.primitiveName() = name();
  
  eq InstFullClassDecl.primitiveName() {
  	if (extendsPrimitive())
  		return getInstExtends(0).getClassName().myInstClassDecl().finalClass().primitiveName();
  	else 
  		return name();
  }
  
  syn String InstForIndex.name() = getInstPrimitive().name();
  syn String FForIndex.name()    = getFVariable().name();
 
  
  
  syn String InstAccess.enclosingName() = "";
  eq InstDot.enclosingName() = name().substring(0, name().lastIndexOf('.'));
  
  
  inh InstClassDecl ASTNode.enclosingInstClassDecl();
  eq SourceRoot.getProgram().enclosingInstClassDecl() = null;
  eq FlatRoot.getChild().enclosingInstClassDecl() = null;
  eq InstBaseClassDecl.getChild().enclosingInstClassDecl() = this;
  eq InstComponentDecl.getChild().enclosingInstClassDecl() = myInstClass();
  
  inh BaseClassDecl ASTNode.enclosingClassDecl();
  eq SourceRoot.getProgram().enclosingClassDecl() = null;

  eq FullClassDecl.getEquation().enclosingClassDecl() = this; 
  eq FullClassDecl.getAlgorithm().enclosingClassDecl() = this; 
  eq FullClassDecl.getSuper().enclosingClassDecl() = this;  
  eq FullClassDecl.getImport().enclosingClassDecl() = this; 
  eq FullClassDecl.getClassDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getComponentDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getAnnotation().enclosingClassDecl() = this; 
  eq FullClassDecl.getExternalClause().enclosingClassDecl() = this; 	

  eq ShortClassDecl.getExtendsClauseShortClass().enclosingClassDecl() = this;
  
  eq ExtendClassDecl.getClassModification().enclosingClassDecl() = this;
  eq ExtendClassDecl.getComposition().enclosingClassDecl() = this;
  
  
   	/**
	 * Access method for the last Access of a qualified or
	 * unqualified name.
	 */ 
	syn Access Access.getLastAccess() = this;
    eq Dot.getLastAccess() = getRight().getLastAccess();
    
    syn InstAccess InstAccess.getLastInstAccess() = this;
    eq InstDot.getLastInstAccess() = getRight().getLastInstAccess();
    
    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn Access Access.getFirstAccess() = this;
    eq Dot.getFirstAccess() = getLeft().getFirstAccess();
   
   	inh Access Access.getNextAccess();
   	eq Dot.getLeft().getNextAccess() = getRight().getFirstAccess();
   	eq SourceRoot.getProgram().getNextAccess() = null;
   	eq Root.getChild().getNextAccess() = null;

    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn InstAccess InstAccess.getFirstInstAccess() = this;
    eq InstDot.getFirstInstAccess() = getLeft().getFirstInstAccess();
   
   	inh InstAccess InstAccess.getNextInstAccess();
   	eq InstDot.getLeft().getNextInstAccess() = getRight().getFirstInstAccess();
   	eq SourceRoot.getProgram().getNextInstAccess() = null;
    eq FlatRoot.getChild().getNextInstAccess() = null;

   	
   	/**
   	 * stripFirstAccess removes the first access in a qualified
   	 * name. If the name is not qualified, null is returned. 
   	 */
   	public Access Access.stripFirstAccess() {
   		return null;
   	}
   	
   	public Access Dot.stripFirstAccess() {
		// A right skewed Dot three is stipped by
		//getRight().myDecl();
		return (Access)getRight().fullCopy();
	}
   	
	syn boolean Access.isQualified() = false;
	eq Dot.isQualified() = true;
	
	/**
	 * \brief Get the top node in an access (possibly qualified).
	 */
	syn Access Access.getTopAccess() {
		// This can be done with inherited attributes, but is much simpler with getParent()
		if (getParent() instanceof Dot)
			return ((Dot) getParent()).getTopAccess();
		return this;
	}
	
	/**
	 * \brief Get the top node in an access (possibly qualified).
	 */
	syn InstAccess InstAccess.getTopAccess() {
		// This can be done with inherited attributes, but is much simpler with getParent()
		if (getParent() instanceof InstDot)
			return ((InstDot) getParent()).getTopAccess();
		return this;
	}
	
	/**
	 * \brief Get the array subscripts of the last name part.
	 */
	syn FArraySubscripts InstAccess.getLastFArraySubscripts() = 
		getLastInstAccess().getFArraySubscripts();
	
	syn FArraySubscripts InstAccess.getFArraySubscripts() = null;

	syn boolean InstAccess.hasFArraySubscripts() = false;
	
	/**
	 * \brief Set the array subscripts of the last name part.
	 */
	public void InstAccess.setLastFArraySubscripts(FArraySubscripts fas) {
		((InstArrayAccess) getLastInstAccess()).setFArraySubscripts(fas);
	}
	
}

aspect FlatNames {
	
	syn String FVariable.varKind() {
		if (isIndependentConstant()) {
			return "ci";
		} else if (isDependentConstant()) {
			return "cd";
		} else if (isIndependentParameter()) {
			return "pi";
		} else if (isDependentParameter()) {
			return "pd";
		} else if (isDifferentiatedVariable()) {
			return "x";
		} else if (isDerivativeVariable()) {
			return "dx";
		} else if (isAlgebraicVariable()) {
			return "w";
		} else if (isInput()) {
			return "u";
		} else {
			return "unknown";
		}
	}
	
	public FQName.FQName(String name) {
		this(new List());
   		for (String part : name.split("\\."))
   			addFQNamePart(new FQNamePart(part, new Opt()));
	}

	public FQName.FQName(FQName fqname) {
		this((List)fqname.getFQNamePartList().fullCopy());
	}

	public FQName FQName.append(InstAccess access,FQName prefix) {
		InstAccess fa = access.getFirstInstAccess();
		Opt as = null;
		if (fa.isInstArrayAccess()) {
			as = new Opt(fa.fArraySubscripts().flatten(prefix));
		} else {
			as = new Opt();
		}
		addFQNamePart(new FQNamePart(fa.name(),as));
		while (fa.getNextInstAccess()!=null) {
			fa = fa.getNextInstAccess();
			if (fa.isInstArrayAccess()) {
				as = new Opt(fa.fArraySubscripts().flatten(prefix));
			} else {
				as = new Opt();
			}
			addFQNamePart(new FQNamePart(fa.name(),as));
		}
		return this;
	}

	public FQName FQName.append(String name) {
		addFQNamePart(new FQNamePart(name, new Opt()));
		return this;
	}

	public FQName FQName.append(FQName fqname) {
		for (int i=0;i<fqname.getNumFQNamePart();i++)
			addFQNamePart((FQNamePart)fqname.getFQNamePart(i).fullCopy());
		return this;
	}
	
	syn FQNamePart FQName.lastFQNamePart() = getFQNamePart(getNumFQNamePart()-1);

	syn boolean FQName.hasFArraySubscripts() = isScalarized()? false:
		lastFQNamePart().hasFArraySubscripts();
	syn FArraySubscripts FQName.getFArraySubscripts() = isScalarized()? null:
		lastFQNamePart().getFArraySubscripts();

	syn boolean FIdUse.hasFArraySubscripts() = 
		getFQName().hasFArraySubscripts();
	syn FArraySubscripts FIdUse.getFArraySubscripts() = 
		getFQName().getFArraySubscripts();

	syn boolean FIdUseInstAccess.hasFArraySubscripts() = 
		getInstAccess().hasFArraySubscripts();
	syn FArraySubscripts FIdUseInstAccess.getFArraySubscripts() = 
		getInstAccess().getFArraySubscripts();

	syn boolean FIdUseExp.hasFArraySubscripts() = 
		getFIdUse().hasFArraySubscripts();
	syn FArraySubscripts FIdUseExp.getFArraySubscripts() = 
		getFIdUse().getFArraySubscripts();
	
	
	/**
	 * \brief Get the array subscripts of the last name part.
	 */
	syn FArraySubscripts FQName.getLastFArraySubscripts() =
		hasFArraySubscripts() ? lastFQNamePart().getFArraySubscripts() : null;
	
	/**
	 * \brief Set the array subscripts of the last name part.
	 */
	public void FQName.setLastFArraySubscripts(FArraySubscripts fas) {
		lastFQNamePart().setFArraySubscripts(fas);
	}
	
	syn lazy FQName InstNode.getFQNamePrefix() {
		FQName prefix = retrieveFQName();
		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
		return myName;	
	}
	
	syn lazy FQName InstNode.getFQName() = getFQNamePrefix();
	
	eq InstComponentDecl.getFQName() {
		
		FQName prefix = retrieveFQName();
		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
	
		Opt array_subscr = new Opt();
		if (isPrimitive() && isArrayDecl() ) {
			array_subscr.setChild((FArraySubscripts)getFArraySubscripts().flatten(myName),0);
		}
		
		myName.addFQNamePart(new FQNamePart(name(),array_subscr));
		return myName;
	}
	
	eq InstArrayComponentDecl.getFQName() {
		FQName prefix = retrieveFQName();

		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
		
		FArraySubscripts fas = new FArraySubscripts(
				new List().add(new FExpSubscript(new FIntegerLitExp(getIndex()+""))));

		if (myName.hasFArraySubscripts()) {
			myName.getFArraySubscripts().addFSubscript(fas.getFSubscript(0));
		} else {
			myName.lastFQNamePart().setFArraySubscripts(fas);
		}
		return myName;
	}	

	eq InstClassDecl.getFQName() = new FQName();
	inh lazy FQName InstNode.retrieveFQName();
	eq InstComponentDecl.getChild().retrieveFQName() = getFQName();
	eq InstComponentDecl.getInstModification().retrieveFQName() = retrieveFQName();
	eq InstReplacingComposite.getOriginalInstComponent().retrieveFQName() = retrieveFQName();
	eq InstReplacingPrimitive.getOriginalInstComponent().retrieveFQName() = retrieveFQName();
	eq InstReplacingShortClassDecl.getChild().retrieveFQName() = retrieveFQName();
	eq InstClassDecl.getChild().retrieveFQName() = null; //getFQName();
	eq InstForIndex.getChild().retrieveFQName() = null;
	
	eq InstRoot.getChild().retrieveFQName() = null;
	eq SourceRoot.getProgram().retrieveFQName() = null;

	syn lazy String FQName.name() {
		StringBuffer str = new StringBuffer();
		for (Iterator<FQNamePart> it = getFQNameParts().iterator(); it.hasNext(); ) {
			FQNamePart part = it.next();
			str.append(part.getName());
			if (it.hasNext() || isScalarized()) {
				if (part.hasFArraySubscripts()) 
					str.append(part.getFArraySubscripts());
				if (it.hasNext()) 
					str.append(".");
			}
		}
		return str.toString();
	}
	
	syn String FQNamePart.name() = getName();

	syn String FIdUse.name() = getFQName().name();
	syn String FIdUseExp.name() = getFIdUse().name();
	eq FDerExp.name() = derName();
	syn String FInstAccessExp.name() = getInstAccess().name();
    syn String FIdUseInstAccess.name() = getInstAccess().name();
	
	syn String FIdDecl.name() = getFQName().name();

	syn String FClass.name() = getFQName().name();
	syn String FFunctionDecl.name() = getFQName().name();
	syn String FVariable.name() = getFQName().name();
	syn String FFunctionVariable.name() = getFQName().name();

//	syn lazy String FQName.derName() = "der(" + name() + ")";
	
	eq FDerivativeVariable.name() = getFQName().derName();
	syn String FIdUse.derName() = getFQName().derName();
	syn String FIdUseExp.derName() = getFIdUse().derName();

	syn lazy String FQName.derName() {
		StringBuffer str = new StringBuffer();
		for (int i=0;i<getNumFQNamePart();i++) {
			if (i==getNumFQNamePart()-1) {
				str.append("der(");
			}			
			str.append(getFQNamePart(i).getName());
			//if (i<getNumFQNamePart()-1 || isScalarized()) {
				if (getFQNamePart(i).hasFArraySubscripts()) {
					str.append(getFQNamePart(i).getFArraySubscripts().prettyPrint(""));
				}
				if (i<getNumFQNamePart()-1) {
					str.append(".");
				}
			//}
		}
		str.append(")");
		return str.toString();
	}
	
	//syn String FIdUse.derName2() = getFQName().derName2();
	//syn String FIdUseExp.derName2() = getFIdUse().derName2();
	
	syn lazy String FQName.nameUnderscore() {
		StringBuffer str = new StringBuffer();
		for (int i=0;i<getNumFQNamePart();i++) {
			str.append(getFQNamePart(i).getName());
			if (i<getNumFQNamePart()-1 || isScalarized()) {
				if (getFQNamePart(i).hasFArraySubscripts()) {
					for (FSubscript fs : 
						getFQNamePart(i).getFArraySubscripts().getFSubscripts()) {
						str.append("_");
						str.append(fs.prettyPrint(""));
					}
				}
				if (i<getNumFQNamePart()-1) {
					str.append("_");
				}
			}
		}
		return str.toString();
	}

	syn String FQNamePart.nameUnderscore() = getName();

	syn String FIdUse.nameUnderscore() = getFQName().nameUnderscore();
	syn String FIdUseExp.nameUnderscore() = getFIdUse().nameUnderscore();
	eq FDerExp.nameUnderscore() = "der_" + getFIdUse().nameUnderscore();
	//syn String FInstAccessExp.nameUnderscore() = getInstAccess().nameUnderscore();
    //syn String FIdUseInstAccess.nameUnderscore() = getInstAccess().nameUnderscore();
	
	syn String FIdDecl.nameUnderscore() = getFQName().nameUnderscore();

	syn String FClass.nameUnderscore() = getFQName().nameUnderscore();
	
	syn String AbstractFVariable.nameUnderscore() = null;
	eq FVariable.nameUnderscore()           = getFQName().nameUnderscore();
	eq FDerivativeVariable.nameUnderscore() = "der_" + getFQName().nameUnderscore();
	eq FFunctionVariable.nameUnderscore()   = getFQName().nameUnderscore();
	
	syn String FQName.funcNameUnderscore(String suffix) = "func_" + nameUnderscore() + "_" + suffix;
	syn String FIdUse.funcNameUnderscore(String suffix) = getFQName().funcNameUnderscore(suffix);

	inh int FVariable.variableIndex();
	eq FClass.getFVariable(int i).variableIndex()     = i;
	eq FClass.getAliasVariable(int i).variableIndex() = getNumFVariable() + i;
	eq FForIndex.getFVariable().variableIndex()       = -1;
	
	/**
	 * \brief Copy this FQName, append a String to the copy and return the copy.
	 */
	public FQName FQName.copyAndAppend(String name) {
		return ((FQName)fullCopy()).append(name);
	}
	
	/**
	 * \brief Create an FIdUseExp using a copy of this name.
	 */
	public FIdUseExp FQName.createFIdUseExp() {
		return new FIdUseExp(createFIdUse()); 
	}
	
	/**
	 * \brief Create an FIdUse using a copy of this name.
	 */
	public FIdUse FQName.createFIdUse() {
		return new FIdUse(fullCopy()); 
	}
	
}

aspect DebugHelpers {
	
	/**
	 * \brief Convert to string. Primarily useful for debugging.
	 * 
	 * Default implementation uses prettyPrint().
	 */
	public String ASTNode.toString() {
		return prettyPrint("");
	}
	
}

aspect FlatFunctionUtils {
	 
	 syn boolean FFunctionVariable.isInput()  = hasFTypePrefixInputOutput() && getFTypePrefixInputOutput().inputCausality();
	 syn boolean FFunctionVariable.isOutput() = hasFTypePrefixInputOutput() && getFTypePrefixInputOutput().outputCausality();
	 
	 /**
	  * \brief Returns a list of all InstComponentDecls declared as "input".
	  */
	 syn lazy ArrayList<InstComponentDecl> InstClassDecl.myInputs() {
		 ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
		 for (InstComponentDecl icd : getInstComponentDecls())
			 if (icd.isInput())
				 l.add(icd);
		 return l;
	 }
	 
	 /**
	  * \brief Returns a list of all InstComponentDecls declared as "output".
	  */
	 syn lazy ArrayList<InstComponentDecl> InstClassDecl.myOutputs() {
		 ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
		 for (InstComponentDecl icd : getInstComponentDecls())
			 if (icd.isOutput())
				 l.add(icd);
		 return l;
	 }
	 
	 /**
	  * \brief Returns a list of all FFunctionVariables declared as "input".
	  */
	 syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myInputs() {
		 ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
		 for (FFunctionVariable var : getFFunctionVariables())
			 if (var.isInput())
				 l.add(var);
		 return l;
	 }
	 
	 /**
	  * \brief Returns a list of all FFunctionVariables not declared as "input".
	  */
	 syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myNonInputs() {
		 ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
		 for (FFunctionVariable var : getFFunctionVariables())
			 if (!var.isInput())
				 l.add(var);
		 return l;
	 }
	 
	 /**
	  * \brief Returns a list of all FFunctionVariables declared as "output".
	  */
	 syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myOutputs() {
		 ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
		 for (FFunctionVariable var : getFFunctionVariables())
			 if (var.isOutput())
				 l.add(var);
		 return l;
	 }
	 
	 syn ArrayList<InstComponentDecl> InstFunctionCall.myInputs()  = getName().myInstClassDecl().myInputs();
	 syn ArrayList<InstComponentDecl> InstFunctionCall.myOutputs() = getName().myInstClassDecl().myOutputs();
	 syn ArrayList<FFunctionVariable> FFunctionCall.myInputs()     = myFFunctionDecl().myInputs();
	 syn ArrayList<FFunctionVariable> FFunctionCall.myOutputs()    = myFFunctionDecl().myOutputs();
	 
	 syn boolean InstFunctionCall.hasOutputs() = !myOutputs().isEmpty();
	 syn boolean FFunctionDecl.hasOutputs()    = !myOutputs().isEmpty();
	 syn boolean FFunctionCall.hasOutputs()    = myFFunctionDecl().hasOutputs();
	 
	 syn InstComponentDecl InstFunctionCall.expOutput() = myOutputs().get(0);
	 syn FFunctionVariable FFunctionDecl.expOutput()    = myOutputs().get(0);
	 syn FFunctionVariable FFunctionCall.expOutput()    = myFFunctionDecl().expOutput();
	
	 syn lazy FunctionReturnDefinition FFunctionDecl.returnDefinition() = new FunctionReturnDefinition(this);
	 inh FunctionReturnDefinition FReturnStmt.returnDefinition();
	 eq FFunctionDecl.getFAlgorithmBlock().returnDefinition() = returnDefinition();
	 eq InstProgramRoot.getChild().returnDefinition()         = null;
	 eq FClass.getChild().returnDefinition()                  = null;
	 
	 /**
	  * \brief Check if this function returns an array when used as an expression.
	  */
	 syn boolean FFunctionDecl.isArray() = hasOutputs() ? expOutput().isArray() : false;
	 
	 /**
	  * \brief Check is this node is in a function.
	  */
	 inh boolean FQName.inFunction();
	 inh boolean InstPrimitive.inFunction();
	 inh boolean FExp.inFunction();
	 inh boolean FIdUse.inFunction();
	 inh boolean FStatement.inFunction();
	 inh boolean FAlgorithmBlock.inFunction();
	 inh boolean FSubscript.inFunction();
	 inh boolean FFunctionCallLeft.inFunction();
	 inh boolean FPrimitiveType.inFunction();
	 eq InstBaseClassDecl.getChild().inFunction() = isFunction();
	 eq FFunctionDecl.getChild().inFunction()     = true;
	 eq Root.getChild().inFunction()              = false;
	 
	 /**
	  * \brief Check is this node is in a non-function algorithm.
	  */
	 inh boolean FSubscript.inAlgorithm();
	 eq FAlgorithmBlock.getChild().inAlgorithm()   = !inFunction();
	 eq InstNode.getChild().inAlgorithm()          = false;
	 eq FAbstractEquation.getChild().inAlgorithm() = false;
	 eq FClass.getChild().inAlgorithm()            = false;
	 
	 /**
	  * \brief Check is this node is in an algorithm or a function.
	  */
	 syn boolean FSubscript.inAlgorithmOrFunction() = inFunction() || inAlgorithm();
	 
	 /**
	  * \brief Check if this function call is the call of a function call equation 
	  *        or function call statement.
	  */
	 inh boolean FFunctionCall.isFunctionCallClause();
	 inh boolean InstFunctionCall.isFunctionCallClause();
	 eq ASTNode.getChild().isFunctionCallClause()              = false;
	 eq FFunctionCallEquation.getCall().isFunctionCallClause() = true;
	 eq FFunctionCallStmt.getCall().isFunctionCallClause()     = true;
	 
	 inh boolean FWhenStmt.insideBlockStmt();
	 eq FAlgorithmBlock.getChild().insideBlockStmt() = false;
	 eq FIfWhenStmt.getChild().insideBlockStmt()     = true;
	 eq FWhileStmt.getChild().insideBlockStmt()      = true;
	 eq FForStmt.getChild().insideBlockStmt()        = true;
	 eq InstForStmt.getChild().insideBlockStmt()     = true;
	 
	 /**
	  * \brief Return the index of the variable assigned by this FFunctionCallLeft among 
	  *        all those assigned by the same FFUnctionCallEquation/Stmt
	  */
	 syn lazy int FFunctionCallLeft.myIndex() = prevIndex() + (hasFExp() ? 1 : 0);
	 inh int FFunctionCallLeft.prevIndex();
	 eq FFunctionCallEquation.getLeft(int i).prevIndex() = (i == 0) ? -1 : getLeft(i - 1).myLastIndex();
	 eq FFunctionCallStmt.getLeft(int i).prevIndex()     = (i == 0) ? -1 : getLeft(i - 1).myLastIndex();
	 
	 syn int FFunctionCallLeft.myLastIndex() = myIndex() + (hasFExp() ? numScalarVars() - 1 : 0);
	 
	 /**
	  * \brief Get the number of scalar variables assigned by this FFunctionCallLeft.
	  */
	 syn int FFunctionCallLeft.numScalarVars() = (hasFExp() ? getFExp().size().numElements() : 0);
	 
	 inh lazy InstComponentDecl FFunctionCallLeft.myOutput();
	 eq FFunctionCallEquation.getLeft(int i).myOutput() = getCall().findOutput(i);
	 eq FFunctionCallStmt.getLeft(int i).myOutput()     = getCall().findOutput(i);
	 syn InstComponentDecl FAbstractFunctionCall.findOutput(int i) = unknownInstComponentDecl();
	 eq InstFunctionCall.findOutput(int i)                         = 
		 (i >= myOutputs().size()) ? unknownInstComponentDecl() : myOutputs().get(i);
	 
	 inh boolean FAbstractFunctionCall.functionCallIsExp();
	 eq FExp.getChild().functionCallIsExp()                 = true;
	 eq FClass.getChild().functionCallIsExp()               = true;
	 eq InstNode.getChild().functionCallIsExp()             = true;
	 eq FFunctionCallEquation.getCall().functionCallIsExp() = false;
	 eq FFunctionCallStmt.getCall().functionCallIsExp()     = false;
	 
	 inh lazy ArrayList<FFunctionCallLeft> FAbstractFunctionCall.myLefts();
	 eq FExp.getChild().myLefts()                 = new ArrayList<FFunctionCallLeft>();
	 eq FClass.getChild().myLefts()               = new ArrayList<FFunctionCallLeft>();
	 eq InstNode.getChild().myLefts()             = new ArrayList<FFunctionCallLeft>();
	 eq FFunctionCallEquation.getCall().myLefts() = getLefts().toArrayList();
	 eq FFunctionCallStmt.getCall().myLefts()     = getLefts().toArrayList();

	 syn lazy String FClass.tempVarName() {
		 String name = "temp";
		 HashMap<String,FVariable> vars = fullyQualifiedVariablesMap();
		 for (int n = 1; vars.get(name) != null; n++)
			 name = "temp_" + n;
		 return name;
	 }
	 
	 inh lazy String FFunctionCall.tempVarName();
	 eq InstNode.getChild().tempVarName()      = null;
	 eq FFunctionCall.getArray().tempVarName() = tempVarName();
	 eq FClass.getChild().tempVarName()        = tempVarName();
	 eq FFunctionDecl.getChild().tempVarName() {
		 HashMap<String,FFunctionVariable> vars = fullyQualifiedVariablesMap();
		 String name;
		 do {
			 name = "temp_" + nextTempVarIndex++;
		 } while (vars.get(name) != null);
		 return name;
	 }
	 
	 private int FFunctionDecl.nextTempVarIndex = 1;
	 private int FClass.nextTempVarIndex = 1;
	 public int FClass.tempVarIndex() { return nextTempVarIndex++; }
}

aspect Visibility {
	
	syn boolean BaseClassDecl.isPublic() = getVisibilityType().isPublic();
	syn boolean ComponentDecl.isPublic() = getVisibilityType().isPublic();

	syn boolean BaseClassDecl.isProtected() = getVisibilityType().isProtected();
	syn boolean ComponentDecl.isProtected() = getVisibilityType().isProtected();

	syn boolean VisibilityType.isPublic() = false;
	eq PublicVisibilityType.isPublic() = true;

	syn boolean VisibilityType.isProtected() = false;
	eq ProtectedVisibilityType.isProtected() = true;

	syn boolean FVisibilityType.isPublic() = false;
	eq FPublicVisibilityType.isPublic() = true;

	syn boolean FVisibilityType.isProtected() = false;
	eq FProtectedVisibilityType.isProtected() = true;

	syn boolean FVariable.isPublic() = getFVisibilityType().isPublic();
	syn boolean FVariable.isProtected() = getFVisibilityType().isProtected();
	
}

aspect ComponentDeclMethods {
   	/**
   	 * Check if a ComponentDecl is declared flow.
   	 */
   	syn boolean ComponentDecl.isFlow() {
   	
   		if (hasTypePrefixFlow())
   			return true;
   	
   		return false;
   	}

   	/**
   	 * Check if a ComponentDecl is declared parameter.
   	 */
   	syn boolean ComponentDecl.isParameter() {
   	
   		if (hasTypePrefixVariability())
   			if (getTypePrefixVariability() instanceof Parameter)
   				return true;
   	
   		return false;
   	}
   	  
   	/**
   	 * Check if a ComponentDecl is declared inner.
   	 */
   	syn boolean ComponentDecl.isInner() {
		return hasInner();
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared outer.
   	 */
   	syn boolean ComponentDecl.isOuter() {
		return hasOuter();
   	}
   	
   	
   	 /**
   	 * Check if a ComponentDecl is declared constant.
   	 */
   	syn boolean ComponentDecl.isConstant() {
   	
   		if (hasTypePrefixVariability())
   			if (getTypePrefixVariability() instanceof Constant)
   				return true;
   	
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isDiscrete() {
   	
   		if (hasTypePrefixVariability())
   			if (getTypePrefixVariability() instanceof Discrete)
   				return true;
   	
   		return false;
   	}
   	
   	syn boolean InstComponentDecl.isInput() {
   	   	
   		if (getComponentDecl().hasTypePrefixInputOutput())
   			if (getComponentDecl().getTypePrefixInputOutput() instanceof Input)
   				return true;
   		if (myInstClass().isInput())
   			return true;
   		
   		return false;
   	}
   	
   	
 
   	syn boolean InstComponentDecl.isOutput() {
   	   	
   		if (getComponentDecl().hasTypePrefixInputOutput())
   			if (getComponentDecl().getTypePrefixInputOutput() instanceof Output)
   				return true;
   		if (myInstClass().isOutput())
   			return true;
   		
   		return false;
   	}
   	
	syn boolean AbstractEquation.isInitial() {
		if (hasAbstractEquationModifier())
			if (getAbstractEquationModifier() instanceof Initial)
				return true;
		return false;
	
	}

   	/**
   	 * Check if a InstComponentDecl is declared flow.
   	 */
   	syn boolean InstComponentDecl.isFlow() {
   	
   		if (getComponentDecl().hasTypePrefixFlow())
   			return true;
   	
   		return false;
   	}
	
}

aspect ShortClassUtil {

	syn InstClassDecl InstClassDecl.finalClass() = this;
	eq InstShortClassDecl.finalClass() = getInstExtends(0).getClassName().myInstClassDecl().finalClass();


	syn boolean ClassDecl.isInput() = false;
	eq ShortClassDecl.isInput() {
		if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
   			if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Input)
   				return true;
		return false;
	}
	
	syn boolean ClassDecl.isOutput() = false;
	eq ShortClassDecl.isOutput() {
		if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
   			if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Output)
   				return true;
		return false;	
	}

	syn boolean InstClassDecl.isInput() = false;
	eq InstShortClassDecl.isInput() {
		if (getClassDecl().isInput()) {
			return true;
		}
		return getInstExtends(0).getClassName().myInstClassDecl().isInput();
	}

	syn boolean InstClassDecl.isOutput() = false;
	eq InstShortClassDecl.isOutput() {
		if (getClassDecl().isOutput()) {
			return true;
		}
		return getInstExtends(0).getClassName().myInstClassDecl().isOutput();
	}
	
}

aspect Math {
/*
	public boolean FFunctionCall.rewrittenToExp = false;
	rewrite FFunctionCall {
		when (getName().name().equals("Modelica.Math.sin") && 
		      !rewrittenToExp)
		      to FFunctionCall {
		      	rewrittenToExp = true;
		      	return new FFunctionCall(new FIdUse("sin"),new List().add(getArgs(0)));
		      }
	}
*/
}

aspect FlatExpressions {
	
	inh lazy boolean FExp.inEquationSection();
	eq FClass.getFEquationBlock().inEquationSection() = true;
	eq Root.getChild().inEquationSection() = false;
	inh lazy boolean FExp.inInitialEquationSection();
	eq FClass.getFInitialEquation().inInitialEquationSection() = true;
	eq Root.getChild().inInitialEquationSection() = false;

	inh boolean FExp.inNoEventExp();
	eq FNoEventExp.getChild().inNoEventExp() = true;
	eq FAlgorithmBlock.getChild().inNoEventExp() = true;
	eq FAbstractEquation.getChild().inNoEventExp() = false;
	eq SourceRoot.getChild().inNoEventExp() = false;
	eq FlatRoot.getChild().inNoEventExp() = false;
	
	inh boolean FExp.inIfCondition();
	eq FIfExp.getChild().inIfCondition() = true;
	eq FElseIfExp.getChild().inIfCondition() = true;
	eq FAbstractEquation.getChild().inIfCondition() = false;
	eq SourceRoot.getChild().inIfCondition() = false;
	eq FlatRoot.getChild().inIfCondition() = false;
	
}

aspect LineOffsets {
	private Map<Integer, Integer> StoredDefinition.lineBreakMap;
	
	public void StoredDefinition.setLineBreakMap(Map<Integer, Integer> map) {
		lineBreakMap = map;
	}
}

aspect ParserHelpers {

	/**
	 * An exception for parser errors.
	 */
	public class ParserException extends java.lang.RuntimeException {
		private Problem p;
		
		/**
		 * Default constructor.
		 */
		public ParserException(Problem p) {
			this.p = p;
		}
		
		/**
		 * Getter for problem.
		 */
		 public Problem getProblem() {
		 	return p;
		 }
		
	}
	
}

aspect NodeSearch {
	
	/**
	 * \brief Does node match <code>string</code>? Override for node types that 
	 * need to be searched for.
	 * 
	 * Base implementation always returns <code>false</code.
	 * Generally, this is implemented with something like 
	 * <code>str.equals(name())</code>.
	 * 
	 * @param str  the string to match
	 * @return     <code>true</code if <code>str</code> matches this node, 
	 *             <code>false</code> otherwise
	 */
	syn boolean ASTNode.matches(String str) = false;
	
	public class ASTNode {
		
		/**
		 * \brief Searches <code>set</code> for a node that returns <code>true</code> for 
		 * <code>node.matches(str)</code>.
		 * 
		 * @param set  the container to search for a matching node
		 * @param str  the string to match nodes to
		 * @return     a matching node if one is found, <code>null</code> otherwise
		 */
		public static <T extends ASTNode> T findMatching(Iterable<T> set, String str) {
		    for (T node : set) 
		        if (node.matches(str)) 
		            return node;
		    return null;
		}
		
	}
	
}
