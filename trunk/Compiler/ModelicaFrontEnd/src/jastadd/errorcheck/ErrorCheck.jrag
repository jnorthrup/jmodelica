/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Collection;
import java.util.LinkedList;
import java.util.ArrayList;

import org.jmodelica.util.Problem;
import org.jmodelica.util.ErrorCheckType;


  
  /**
   * Interface for handling semantic errors.
   * $see Root#setErrorHandler(IErrorHandler)
   */
  public interface IErrorHandler {
	  /**
	   * Called when a semantic error is found. 
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   * @see ASTNode#error(String)
	   */
	  public void error(String s, ASTNode n);
	  
	  /**
	   * Called when a compiler compliance error is found.
	   * 
	   * These errors are generated when compiling code that is legal Modelica, 
	   * but uses features that aren't implemented. Compliance errors are ignored 
	   * by test cases (except ComplianceErrorTestCase).
	   *  
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   * @see ASTNode#compliance(String)
	   */
	  public void compliance(String s, ASTNode n);
	  
	  /**
	   * Called when a warning is issued during semantic error checking.
	   * 
	   * @param s	warning message.
	   * @param n	the node the warning originated from.
	   * @see ASTNode#warning(String)
	   */
	  public void warning(String s, ASTNode n);
      
      /**
       * Called when a problem is generated though other means than the other methods in this interface, 
       * typically during parsing of library files.
       * 
       * @param p   the problem
       * @see ASTNode#problem(Problem)
       */
      public void problem(Problem p);
	  
	  /**
	   * Connect error handler to a Root.
	   * 
	   * Might return another equivalent error handler that is connected to the root instead.
	   * 
	   * @param root  the Root to connect to
	   * @return  an error handler connected to <code>root</code>
	   */
	  public IErrorHandler connectTo(Root root);
  }
  
  /**
   * Default implementation of {@link IErrorHandler}.
   *  
   * Collects a list of {@link Problem} for all found errors.
   */
  public class DefaultErrorHandler implements IErrorHandler {
	  protected Root root;
	  
	  public DefaultErrorHandler(Root root) {
		  this.root = root;
	  }

	  /**
	   * Creates a new {@link Problem} and adds it to root.errors, ignoring duplicates.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void error(String s, ASTNode n) {
		  problem(s, n, root.errors, Problem.Severity.ERROR, Problem.Kind.SEMANTIC);
	  }

	  /**
	   * Creates a new {@link Problem} with kind COMPLIANCE 
	   *        and adds it to root.errors, ignoring duplicates.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void compliance(String s, ASTNode n) {
		  problem(s, n, root.errors, Problem.Severity.ERROR, Problem.Kind.COMPLIANCE);
	  }

	  /**
	   * Creates a new {@link Problem} and adds it to root.warnings, ignoring duplicates.
	   * 
	   * @param s	warning message.
	   * @param n	the node the warning originated from.
	   */
	  public void warning(String s, ASTNode n) {
		  problem(s, n, root.warnings, Problem.Severity.WARNING, Problem.Kind.OTHER);
	  }

      /**
       * Called when a problem is generated though other means than the other methods in this class, 
       * typically during parsing of library files.
       * 
       * @param p   the problem
       * @see ASTNode#problem(Problem)
       */
      public void problem(Problem p) {
          ArrayList<Problem> list = (p.severity() == Problem.Severity.WARNING) ? root.warnings : root.errors;
          int pos = list.indexOf(p);
          if (pos == -1)
              list.add(p);
          else
              list.get(pos).merge(p);
      }

      protected void problem(String s, ASTNode n, ArrayList<Problem> list, Problem.Severity sev, Problem.Kind kind) {
          Problem p = new Problem(n.fileName(), s, sev, kind, n.lineNumber(), n.columnNumber());
          if (n.root().options.getBooleanOption("component_names_in_errors"))
              p.addComponent(n.errorComponentName());
          int pos = list.indexOf(p);
          if (pos == -1)
              list.add(p);
          else
              list.get(pos).merge(p);
      }

	  public IErrorHandler connectTo(Root root) {
		  IErrorHandler eh = new DefaultErrorHandler(root);
		  root.setErrorHandler(eh);
		  return eh;
	  }
  }
  
  /**
   * Error handler that generates warnings for compliance errors, 
   *        delegating to another error handler.
   */
  public class ComplianceWarnErrorHandler implements IErrorHandler {
  	
  	  private IErrorHandler delegate;

	  public ComplianceWarnErrorHandler(IErrorHandler delegate) {
	  	  if (delegate instanceof ComplianceWarnErrorHandler)
	  		  delegate = ((ComplianceWarnErrorHandler) delegate).delegate;
		  this.delegate = delegate;
	  }

	  /**
	   * Delegates to wrapped error handler.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void error(String s, ASTNode n) {
		  delegate.error(s, n);
	  }

	  /**
	   * Delegates to warning() in wrapped error handler.
	   * 
	   * @param s	error message.
	   * @param n	the node the error originated from.
	   */
	  public void compliance(String s, ASTNode n) {
		  delegate.warning(s, n);
	  }

	  /**
	   * Delegates to wrapped error handler.
	   * 
	   * @param s	warning message.
	   * @param n	the node the warning originated from.
	   */
	  public void warning(String s, ASTNode n) {
		  delegate.warning(s, n);
	  }

      /**
       * Called when a problem is generated though other means than the other methods in this class, 
       * typically during parsing of library files.
       * 
       * @param p   the problem
       * @see ASTNode#problem(Problem)
       */
      public void problem(Problem p) {
          delegate.problem(p);
      }
	  
	  public IErrorHandler connectTo(Root root) {
		  delegate = delegate.connectTo(root);
		  return this;
	  }
	  
  }
  

aspect ErrorCheck {
	
	public void FClass.breakOnErrors() throws CompilerException {
		root().breakOnErrors();
	}
	
	public void Root.breakOnErrors() throws CompilerException {
		if (!errors.isEmpty() || (options.getBooleanOption("halt_on_warning") && !warnings.isEmpty())) {
		    java.util.Collections.sort(errors);
		    java.util.Collections.sort(warnings);
		    
		    ArrayList<Problem> problems = new ArrayList<Problem>();
		    problems.addAll(warnings);
		    problems.addAll(errors);
		    
		    errors.clear();
		    warnings.clear();
		    
		    throw new CompilerException(problems);
		}
	}
	
	public ArrayList<Problem> FClass.collectWarnings() {
		return root().collectWarnings();
	}
	
	public ArrayList<Problem> Root.collectWarnings() {
		breakOnErrors();
	    java.util.Collections.sort(warnings);
	    ArrayList<Problem> problems = new ArrayList<Problem>(warnings);
	    warnings.clear();
	    return problems;
	}

  public ArrayList<Problem> Root.errors = new ArrayList<Problem>();
  public ArrayList<Problem> Root.warnings = new ArrayList<Problem>();

  private IErrorHandler Root.errorHandler = new DefaultErrorHandler(this);
  
  /**
   * Set the handler for semantic errors.
   * @see IErrorHandler 
   */
  public void Root.setErrorHandler(IErrorHandler handler) {
	  errorHandler = handler;
  }
  
  /**
   * Get the handler for semantic errors.
   * @see IErrorHandler 
   */
  public IErrorHandler Root.getErrorHandler() {
	  return errorHandler;
  }

  syn int ASTNode.lineNumber() = (start != 0 || getParent()==null)? beginLine() : getParent().lineNumber();
  syn int ASTNode.columnNumber() = (start != 0 || getParent()==null)? beginColumn() : getParent().columnNumber();
  
  /**
   * Register an error. Delegates to an {@link IErrorHandler}.
   * @param s	the error message.
   */
  public void ASTNode.error(String s) {
	  root().getErrorHandler().error(s, this);
  }
  
  /**
   * Register an error. Delegates to an {@link IErrorHandler}.
   * 
   * Builds error message using <code>format</code> as format string.
   */
  public void ASTNode.error(String format, Object... args) {
	  error(String.format(format, args));
  }

  /**
   * Register a compliance error. Delegates to an {@link IErrorHandler}.
   * @param s	the error message.
   */
  public void ASTNode.compliance(String s) {
	  root().getErrorHandler().compliance(s, this);
  }
  
  /**
   * Register a compliance error. Delegates to an {@link IErrorHandler}.
   * 
   * Builds error message using <code>format</code> as format string.
   */
  public void ASTNode.compliance(String format, Object... args) {
	  compliance(String.format(format, args));
  }

  /**
   * Register a warning. Delegates to an {@link IErrorHandler}.
   * @param s	the warning message.
   */
  public void ASTNode.warning(String s) {
	  root().getErrorHandler().warning(s, this);
  }
  
  /**
   * Register a warning. Delegates to an {@link IErrorHandler}.
   * 
   * Builds warning message using <code>format</code> as format string.
   */
  public void ASTNode.warning(String format, Object... args) {
	  warning(String.format(format, args));
  }

  /**
   * Register a problem. Delegates to an {@link IErrorHandler}.
   * @param p   the problem.
   */
  public void ASTNode.problem(Problem p) {
      root().getErrorHandler().problem(p);
  }
  
  /**
   * Lock the closest surrounding if-equation or if-expression that have only 
   * parameter-expression tests and evaluates to another branch. Returns true 
   * if any such if exists. 
   * 
   * Any parameters used in the test will be marked as structural.
   * 
   * NB: This has side-effects, dispite being an inherited attribute.
   * 
   * @param checkType  the type of error checks to use when marking structural parameters
   */
  // TODO: find way to move side-effects out from inh attr
  inh boolean FExp.lockBranch(ErrorCheckType checkType);
  inh boolean FExpSubscript.lockBranch(ErrorCheckType checkType);
  inh boolean FAbstractEquation.lockBranch(ErrorCheckType checkType);
  inh boolean FFunctionCallLeft.lockBranch(ErrorCheckType checkType);
  eq FIfExp.getThenExp().lockBranch(ErrorCheckType checkType)                     = lockMyBranch(checkType, true);
  eq FIfExp.getElseExp().lockBranch(ErrorCheckType checkType)                     = lockMyBranch(checkType, false);
  eq FIfEquation.getFAbstractEquation().lockBranch(ErrorCheckType checkType)      = lockMyBranch(checkType, true);
  eq FIfEquation.getElse().lockBranch(ErrorCheckType checkType)                   = lockMyBranch(checkType, false);
  eq FConnectClause.getConnector1().lockBranch(ErrorCheckType checkType)          = getConnector2().isDisabled() || lockBranch(checkType);
  eq FConnectClause.getConnector2().lockBranch(ErrorCheckType checkType)          = getConnector1().isDisabled() || lockBranch(checkType);
  eq InstComponentDecl.getInstModification().lockBranch(ErrorCheckType checkType) = isDisabled();
  eq InstNode.getChild().lockBranch(ErrorCheckType checkType)                     = false;
  eq FClass.getChild().lockBranch(ErrorCheckType checkType)                       = false;
  
  /**
   * Lock this if-expression and return true if it only has only parameter-expression 
   * tests and evaluates to the branch not indicated by <code>then</code>. Otherwise 
   * delegates to {@link #lockBranch(ErrorCheckType)}.
   * 
   * Any parameters used in the test will be marked as structural.
   * 
   * @param checkType  the type of error checks to use when marking structural parameters
   * @param then       if true, we are trying to remove the then-branch, otherwise the else-branch
   */
  public boolean FIfExp.lockMyBranch(ErrorCheckType checkType, boolean then) {
	  if (getIfExp().variability().parameterOrLess() && getIfExp().ceval().booleanValue() != then) {
		  getIfExp().markAsStructuralParameter(checkType);
		  return true;
	  } else {
		  return lockBranch(checkType);
	  }
  }
  
  /**
   * Lock this if-expression and return true if it only has only parameter-expression 
   * tests and evaluates to the branch not indicated by <code>then</code>. Otherwise 
   * delegates to {@link #lockBranch(ErrorCheckType)}.
   * 
   * Any parameters used in the test will be marked as structural.
   * 
   * @param checkType  the type of error checks to use when marking structural parameters
   * @param then       if true, we are trying to remove the then-branch, otherwise the else-branch
   */
  public boolean FIfEquation.lockMyBranch(ErrorCheckType checkType, boolean then) {
	  if (getTest().variability().parameterOrLess() && getTest().ceval().booleanValue() != then) {
		  getTest().markAsStructuralParameter(checkType);
		  return true;
	  } else {
		  return lockBranch(checkType);
	  }
  }

  
    /**
     * Class used by the error check to delegate to different error checks.
     * This class is subtyped for each error check with different
     * implementations of check() that delegate to corresponding check.
     */
    public abstract class ErrorChecker {
        private final String name;

        public ErrorChecker(String name) {
            this.name = name;
        }

        /**
         * Do check on ASTNode node with the ErrorCheckType check type.
         */
        public abstract void check(ASTNode node, ErrorCheckType checkType);

        @Override
        public String toString() {
            return name;
        }
    }

    /**
     * A list that contains all error checkers. New error checkers are added
     * dynamically during static evaluation by calling addErrorChecker().
     * 
     * @see ASTNode.addErrorChecker(ErrorChecker)
     */
    private static Collection<ErrorChecker> ASTNode.ERROR_CHECKERS;

    /**
     * Add ErrorChecker checker to the list of error checkers. This method
     * should only be called from ASTnode in order to ensure that the checker
     * is added corretly during static evaluation, hence the private
     * visibility.
     */
    private static ErrorChecker ASTNode.addErrorChecker(ErrorChecker checker) {
        if (ERROR_CHECKERS == null)
            ERROR_CHECKERS = new ArrayList<ErrorChecker>();
        ERROR_CHECKERS.add(checker);
        return checker;
    }

    /**
     * A helper method that calls all registered error checkers.
     * 
     * @see ASTNode#addErrorChecker(ErrorChecker)
     */
    protected void ASTNode.allChecks(ErrorCheckType checkType) {
        for (ErrorChecker checker : ERROR_CHECKERS)
            checker.check(this, checkType);
    }
  
  public void ASTNode.collectErrors(ErrorCheckType checkType) {
	  allChecks(checkType);
	  for(int i = 0; i < getNumChild(); i++) {
		  getChild(i).collectErrors(checkType);
	  }
  }


	public void ASTNode.errorCheck(ErrorCheckType checkType) {
		collectErrors(checkType);
		root().breakOnErrors();
	}

    inh InstComponentDecl ASTNode.errorEnclosingComponent();
    eq InstNode.getChild().errorEnclosingComponent() = containingInstComponent();
    eq FlatRoot.getChild().errorEnclosingComponent() = null;
    eq InstRoot.getChild().errorEnclosingComponent() = null;
    eq SourceRoot.getChild().errorEnclosingComponent() = null;

    syn String ASTNode.errorComponentName() {
        InstComponentDecl parent = errorEnclosingComponent();
        return parent == null ? null : parent.qualifiedName();
    }

}

aspect InstanceErrorCheck {

 // Error checking in instance tree

    // We don't want to error check an entire model, just the classes
    //   that are used. 
    public void InstProgramRoot.checkErrorsInInstClass(String className, ErrorCheckType checkType) throws ModelicaClassNotFoundException {
        InstClassDecl icd = lookupInstClassQualified(className);
        if (icd.isUnknown()) 
            throw new ModelicaClassNotFoundException(className);
        else
            icd.errorCheck(checkType);
    }

    public void InstClassDecl.checkErrorsInModelInstance(String className, ErrorCheckType checkType) throws ModelicaClassNotFoundException {
        errorCheck(checkType);
    }

    public void UnknownInstClassDecl.checkErrorsInModelInstance(String className, ErrorCheckType checkType) throws ModelicaClassNotFoundException {
        throw new ModelicaClassNotFoundException(className);
    }

	protected boolean BaseNode.errorChecked = false;

	public void ASTNode.resetCollectErrors() {
		for (ASTNode n : noTransform())
			n.resetCollectErrors();
	}
	
	public static void ASTNode.resetCollectErrorsOn(ASTNode n) {
		if (n != null)
			n.resetCollectErrors();
	}
	
	public void BaseNode.resetCollectErrors() {
		errorChecked = false;
		super.resetCollectErrors();
	}
	
	public void InstNode.resetCollectErrors() {
		super.resetCollectErrors();
		resetCollectErrorsOn(getInstComponentDeclListNoTransform());
		resetCollectErrorsOn(getInstClassDeclListNoTransform());
		resetCollectErrorsOn(getInstExtendsListNoTransform());
		resetCollectErrorsOn(getInstImportListNoTransform());
		resetCollectErrorsOn(getRedeclaredInstClassDeclListNoTransform());
		resetCollectErrorsOn(getFAbstractEquationListNoTransform());
	}

  public void InstNode.collectErrors(ErrorCheckType checkType) {
    if (!errorChecked) {
      errorChecked = true;
	  allChecks(checkType);
	  for (InstNode n : getInstComponentDecls()) 
		  n.collectErrors(checkType);
	  for (InstNode n : getInstExtendss()) 
		  n.collectErrors(checkType);
	  for (FAbstractEquation e : getFAbstractEquations()) 
		  e.collectErrors(checkType);
	}
  }
    
    /**
     * Check if this node is in an InstComponentDecl.
     */
    inh boolean InstExtends.inInstComponent();
    inh boolean InstClassRedeclare.inInstComponent();
    eq InstComponentDecl.getChild().inInstComponent() = true;
    eq InstClassDecl.getChild().inInstComponent()     = false;
    eq InstRoot.getChild().inInstComponent()          = false;
    eq FlatRoot.getChild().inInstComponent()          = false;
    
    
    public void FExp.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
            errorChecked = true;
            super.collectErrors(checkType);
        }
    }

    public void InstBaseClassDecl.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
            super.collectErrors(checkType);
            errorChecked = true;
            for (InstImport ii : getInstImports())
                ii.collectErrors(checkType);
            if (hasInstConstraining())
                getInstConstraining().collectErrors(checkType);
            getInstRestriction().collectErrors(checkType);
            if (getBaseClassDecl() instanceof FullClassDecl) {  
                FullClassDecl fcd = (FullClassDecl)getBaseClassDecl();
                if (!(fcd.getName().getID().equals(fcd.getEndDecl().getEndID()))) {
                    error("The declaration and end names of a class should be the same");
                }
            }
        }
    }

    public void InstFullClassDecl.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
            super.collectErrors(checkType);
            errorChecked = true;
            getInstExternalOpt().collectErrors(checkType);
        }
    }

    public void InstSimpleShortClassDecl.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
            errorChecked = true;
            getTarget().collectErrors(checkType);
            actualInstClass().collectErrors(checkType);
        }
    }

    public void InstImport.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
            errorChecked = true;
            getPackageName().collectErrors(checkType);
        }
    }

    public void InstComponentDecl.collectErrors(ErrorCheckType checkType) {
        if (!errorChecked) {
            errorChecked = true;
            boolean checkInner = isOuter() && 
                    !(myInnerInstComponentDecl().isUnknown() && checkType.allowOuterWithoutInner());
            if (isRecursed()) {
                error("Recursive class structure");
            } else if (checkInner) {
                if (myInnerInstComponentDecl().isUnknown())
                    error("Cannot find inner declaration for outer " + name());
                else
                    myInnerInstComponentDecl().collectErrors(checkType);
            } else if (inOuter()) {
                surroundingOuterComponentDecl().collectErrors(checkType);
            } else {
                collectErrorsInClassName(checkType);
                myInstClass().checkRestriction(checkType);
                if (hasFArraySubscripts())
                    getFArraySubscripts().collectErrors(checkType);
                if (hasConditionalAttribute()) 
                    getConditionalAttribute().collectErrors(checkType);
                if (isActive() && hasInstModification())
                    getInstModification().collectErrors(checkType);
                for (InstModification im : getMergedEnvironment())
                    im.checkModificationNames(checkType);
                
                if (shouldCheckInto(checkType)) {
                    errorChecked = false;
                    super.collectErrors(checkType);
                    if (hasInstConstraining())
                        getInstConstraining().collectErrors(checkType);
                }
            }
        }
    }

    /**
     * Check that the restriction of this class is fulfilled.
     */
    public void InstClassDecl.checkRestriction(ErrorCheckType checkType) {}
    public void InstBaseClassDecl.checkRestriction(ErrorCheckType checkType) {
        if (!errorChecked)
            getInstRestriction().collectErrors(checkType);
    }

    public void InstModification.checkModificationNames(ErrorCheckType checkType) {}
    
    public void InstElementModification.checkModificationNames(ErrorCheckType checkType) {
        getName().allChecks(checkType);
    }
	
	syn boolean InstComponentDecl.shouldCheckInto(ErrorCheckType checkType) =
	        !isDisabled() || checkType.checkInactiveComponents() || root().options.getBooleanOption("check_inactive_contitionals");
	
	// TODO: move to better place (InstanceTree.jrag?)
	syn boolean InstComponentDecl.isActive() {
		try {
			return !hasConditionalAttribute() || getConditionalAttribute().ceval().booleanValue();
		} catch (ConstantEvaluationException e) {
			return false;
		}
	}
	
	public void InstComponentDecl.collectErrorsInClassName(ErrorCheckType checkType) {
		getClassName().collectErrors(checkType);
	}	
	
	public void InstArrayComponentDecl.collectErrorsInClassName(ErrorCheckType checkType) {
		// TODO: use correct class name instead of "ArrayDecl" so that name lookup suceeds instead?
		//       need that for other things as well, but is there problems with it?
	}	
	
	public void FExp.checkConstantExpression(ErrorCheckType checkType, String varKind, String varName) {
		String exp = "'" + prettyPrint("") + "'";
		boolean failed = false;
		try {
			if (isCircular()) {
			    if (!checkType.allowConstantNoValue())
    				error("Could not evaluate binding expression for %s '%s' due to circularity: %s", 
    						varKind, varName, exp);
			} else {
				CValue val = ceval();
				if (val.isPartlyUnknown()) {
					if (val.isUnsupported()) {
						compliance("Constant evaluation not supported for expression(s) directly or indirectly " + 
								"used by the binding expression for %s '%s': %s", varKind, varName, exp);
					} else {
						failed = true;
					}
				}
			}
		} catch (ConstantEvaluationNotReadyException e) {
			// Will be evaluatable later, ignore for now
		} catch (ConstantEvaluationException e) {
			failed = true;
		}
		if (failed && !checkType.allowConstantNoValue())
			error("Could not evaluate binding expression for %s '%s': %s", varKind, varName, exp);
	}

    public void InstAssignable.collectErrors(ErrorCheckType checkType) {
        //log.debug(toString());
        if (!errorChecked) {
            super.collectErrors(checkType);
            errorChecked = true;

            // Check binding expression
            FExp bexp = myBindingInstExp();
            if (bexp != null) {
                String type = isParameter() ? "parameter" : "constant";
                // TODO: Check structural parameters as well
                bexp.collectErrors(checkType);
                // Check if the binding expression of constants can be evaluated
                if (isConstant()) 
                    bexp.checkConstantExpression(checkType, "constant", qualifiedName());
                else if (isParameter() && bexp.isCircular())
                    bexp.error("Circularity in binding expression of parameter: %s = %s", 
                            qualifiedName(), bexp);
            } else {
                // Warn if constant or parameter does not have a binding expression (start is used)
                if ((isConstant() || isParameter()) && !isForIndex() && !isRecord() && 
                        !hasParentRecordWithBindingExp() && !inFunction()) {
                    String type = isParameter() ? "parameter" : "constant";
                    warning("The %s %s does not have a binding expression", type, qualifiedName());
                }
            }
            
            // Mark parameters with Evaluate=true as structural
            if (isParameter() && annotation().forPath("Evaluate").bool()) {
                if (canEvaluateAsStructural())
                    markAsStructuralParameter(checkType);
                else
                    warning("Evaluate annotation is ignored when fixed equals false");
            } else if (variability().structParameterVariability() && hasBindingFExp() && getBindingFExp().canCeval()) {
                markAsStructuralParameter(checkType);
            }
            
            // Check array indices
            getClassName().collectErrors(checkType);
            getLocalFArraySubscriptsOpt().collectErrors(checkType);
            
            // Check attributes for primitive variables
            checkAttributes(checkType);
        }
    }

    syn boolean InstComponentDecl.canEvaluateAsStructural() = true;
    eq InstAssignable.canEvaluateAsStructural() {
        // TODO: hierarchical check for records?
        if (isPrimitive() && !fixedAttributeCValue().reduceBooleanAnd())
            return false;
        if (hasBindingFExp() && !getBindingFExp().canEvaluateAsStructural())
            return false;
        return true;
    }
    syn boolean FExp.canEvaluateAsStructural() {
        for (FExp n : childFExps())
            if (!n.canEvaluateAsStructural())
                return false;
        return true;
    }
    eq FInstAccessExp.canEvaluateAsStructural() = getInstAccess().myInstComponentDecl().canEvaluateAsStructural();
	
	public void InstAssignable.checkAttributes(ErrorCheckType checkType) {}
	
	public void InstPrimitive.checkAttributes(ErrorCheckType checkType) {
		// Check if the expressions of the attributes can be evaluated
		// Note that this check has to be done locally in the
		// context of an InstAssignable node in order to avoid
		// evaluation of all value modifications also for non
		// parameters.
		for (InstModification im : totalMergedEnvironment()) {
			// Only check attributes, value modifications are checked above
			if (im instanceof InstComponentModification) {
				InstComponentModification icm = (InstComponentModification)im;
				if (icm.hasInstModification() && icm.getInstModification().hasInstValueMod()) {
					FExp val_mod = icm.getInstModification().instValueMod();
					if (val_mod.variability().lessOrEqual(fConstant())) 
						val_mod.checkConstantExpression(checkType, "attribute", icm.getName().name());
					else if (!val_mod.variability().lessOrEqual(fParameter())) 
						val_mod.error("Variability of binding expression for attribute '%s' is not less than or equal to parameter variability: %s", 
								icm.getName().name(), val_mod);
					if (val_mod.isCircular() && !checkType.allowConstantNoValue())
						error("Could not evaluate binding expression for attribute '%s' due to circularity: %s", 
								icm.getName().name(), val_mod);
				}
			}
		}
	}
	
	public void InstExtends.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	if (isRecursed()) {
	    		error("Recursive class structure");
	    		errorChecked = true;
	    	} else {
				super.collectErrors(checkType);
    			errorChecked = true;
				getClassName().collectErrors(checkType);
				if (hasInstClassModification() && shouldCheckModification())
					getInstClassModification().collectErrors(checkType);
			}
	    }
	}
	
	// Normally the class modifications in an InstExtendsShortClass
	// does not need to be checked, since they are checked in InstShortClassDecl.
	// This is not the case if the short class decl references
	// an primitive variable, however, and in this case the
	// class modification needs to be checked for errors.
	syn boolean InstExtends.shouldCheckModification()           = true;
	eq InstExtendsShortClass.shouldCheckModification()          = extendsPrimitive();
	eq InstReplacingExtendsShortClass.shouldCheckModification() = extendsPrimitive();
	
	public void InstShortClassDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
		  super.collectErrors(checkType);
    	  errorChecked = true;
		  // The localInstModifications should only be checked if
		  // the node is not a InstReplacingShortClassDecl. This
		  // is accomplished by the method collectInstModificationErrors.
		  collectInstModificationErrors(checkType);
		  if (hasInstConstraining())
				getInstConstraining().collectErrors(checkType);		  
		}
	}

	public void InstShortClassDecl.collectInstModificationErrors(ErrorCheckType checkType) {
		for (InstModification mod : localInstModifications())
			mod.collectErrors(checkType);
    }
    public void InstReplacingShortClassDecl.collectInstModificationErrors(ErrorCheckType checkType) { }

	public void InstReplacingShortClassDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
		  super.collectErrors(checkType);
    	  errorChecked = true;
		  getOriginalInstClass().collectErrors(checkType);
		}
		
	}

	public void InstReplacingFullClassDecl.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
		  super.collectErrors(checkType);
    	  errorChecked = true;
		  getOriginalInstClass().collectErrors(checkType);
		}
	}

	public void InstBuiltIn.collectErrors(ErrorCheckType checkType) {}

	public void InstComponentRedeclare.collectErrors(ErrorCheckType checkType) {
		if (!errorChecked) {
		    super.collectErrors(checkType);
		    errorChecked = true;
		}
	}
	
	public void InstNode.checkRedeclares(ErrorCheckType checkType) {
	    if (!errorChecked) {
	        for (InstNode n : getInstComponentDecls()) 
	            n.checkRedeclares(checkType);
	        for (InstNode n : getInstExtendss()) 
	            n.checkRedeclares(checkType);
	      }
	}

    public void InstReplacingRecord.checkRedeclares(ErrorCheckType checkType) {
        super.checkRedeclares(checkType);
        if (shouldCheckInto(checkType))
            typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingComposite.checkRedeclares(ErrorCheckType checkType) {
        super.checkRedeclares(checkType);
        if (shouldCheckInto(checkType))
            typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingPrimitive.checkRedeclares(ErrorCheckType checkType) {
        super.checkRedeclares(checkType);
        if (shouldCheckInto(checkType))
            typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingExpandableConnectorDecl.checkRedeclares(ErrorCheckType checkType) {
        super.checkRedeclares(checkType);
        if (shouldCheckInto(checkType))
            typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstComponentDecl.checkRedeclares(ErrorCheckType checkType) {
        if (isActive() && hasInstModification())
            getInstModification().collectErrors(checkType);
        if (shouldCheckInto(checkType)) {
            if (hasInstConstraining())
                getInstConstraining().collectErrors(checkType);
            super.checkRedeclares(checkType);
        }
    }

	public void InstClassRedeclare.collectErrors(ErrorCheckType checkType) {
		super.collectErrors(checkType);
//		if (!inInstComponent())
//			getInstClassDecl().collectErrors(checkType);	
	}

	public void InstValueModification.collectErrors(ErrorCheckType checkType) {
		getFExp().collectErrors(checkType);
	}

    public void InstDot.collectErrors(ErrorCheckType checkType) {
        for (InstAccess ia : getInstAccesss()) {
            ia.collectErrors(checkType);
            if (ia.isUnknown() || !ia.myInstComponentDecl().shouldCheckInto(checkType))
                break;
        }
        allChecks(checkType);
    }

	public void InstClassAccess.collectErrors(ErrorCheckType checkType) {
	    nameCheck(checkType);
	}

	public void InstComponentAccess.collectErrors(ErrorCheckType checkType) {
	    super.collectErrors(checkType);
	    if (!myInstComponentDecl().isUnknown() && !isModificationName())
	    	myInstComponentDecl().collectErrors(checkType);
	}
	
	public void InstComponentArrayAccess.collectErrors(ErrorCheckType checkType) {
	    super.collectErrors(checkType);
	    if (!myInstComponentDecl().isUnknown() && !isModificationName())
	    	myInstComponentDecl().collectErrors(checkType);
	}
	
	inh boolean InstAccess.isModificationName();
	eq InstNamedModification.getName().isModificationName() = true;
	eq BaseNode.getChild().isModificationName()             = false;

	inh boolean FArraySubscripts.myAccessExists();
	eq Root.getChild().myAccessExists()       = false;
	eq InstAccess.getChild().myAccessExists() = !myInstComponentDecl().isUnknown();
	
	public void FArraySubscripts.collectErrors(ErrorCheckType checkType) {
		// Should this check be in the access instead?
		int ndims = mySize().ndims();
		if (getNumFSubscript() > ndims && !isInstComponentSize() && myAccessExists()) {
			// TODO: shouldn't this check for to few as well? (no [] or all dimensions given)
			error("Too many array subscripts for access: " + getNumFSubscript() + 
					" subscripts given, component has " + mySize().ndims() + " dimensions");
			allChecks(checkType);
			for (int i = 0; i < ndims; i++)
				getFSubscript(i).collectErrors(checkType);
		} else {
    		super.collectErrors(checkType);
		}
	}

    public void FBreakStmt.collectErrors(ErrorCheckType checkType) {
        if (enclosingLoop() == null)
            error("Break statement must be inside while- or for-statement");
    }

	/**
	 * Check if class has exactly one algorithm section or external function declaration.
	 */
    public boolean InstClassDecl.isCompleteFunction() {
        return (numFAlgorithm() == 1);
    }
    syn boolean InstPartialFunction.isCompleteFunction() = true;
    
	syn boolean InstClassDecl.hasInstExternal() = false;
	
	syn int InstClassDecl.numInstExternal() {
		int n = hasInstExternal() ? 1 : 0;
		for (InstExtends ie : getInstExtendss())
			n += ie.myInstClass().numInstExternal();
		return n;
	}
	eq InstSimpleShortClassDecl.numInstExternal() = actualInstClass().numInstExternal();
	
	syn int InstClassDecl.numFAlgorithm() {
		int n = 0;
		for (FAbstractEquation e : getFAbstractEquations())
			if (e instanceof FAlgorithm)
				n++;
		for (InstExtends ie : getInstExtendss())
			n += ie.myInstClass().numFAlgorithm();
		return n;
	}
	eq InstSimpleShortClassDecl.numFAlgorithm() = actualInstClass().numFAlgorithm();
	
	public void InstExternalObject.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
			super.collectErrors(checkType);
	    	errorChecked = true;
	    	if (!inFunction()) {
	    		getDestructorCall().collectErrors(checkType);
	    		myInstClass().collectErrors(checkType);
	    	}
	    }
	}
	  
	public void InstForClauseE.collectErrors(ErrorCheckType checkType) {
	    collectErrorsInFor(getFAbstractEquationList(), getInstForIndexList(), checkType);
	}
	
	public void InstForStmt.collectErrors(ErrorCheckType checkType) {
	    collectErrorsInFor(getForStmtList(), getInstForIndexList(), checkType);
	}
	
	public void FIterExp.collectErrors(ErrorCheckType checkType) {
	    collectErrorsInFor(getFExp(), getForIndexList(), checkType);
	}
	
	public void ASTNode.collectErrorsInFor(
	        ASTNode iterChild, List<? extends CommonForIndex> indices, ErrorCheckType checkType) {
	    // Do the checks on the for itself
	    allChecks(checkType);
	    
	    // Check everything except iterChild once
	    for (ASTNode ch : this)
	        if (ch != iterChild)
	            ch.collectErrors(checkType);
	    
	    // Check array bounds in iterChild for each index combination
	    try {
	        indices.getChild(0).collectErrorsForAllIndices(indices, 0, iterChild, checkType);
	    } catch (ConstantEvaluationException e) {
	        // This error is caught elsewhere
	    }
	}
    
    /**
     * Collect errors in iterated node for all combinations of for indices.
     * 
     * @param indices    the list of indices too loop for
     * @param i          next index to handle
     * @param child      the iterated node to check
     * @param checkType  type of check to perform
     */
    public void CommonForIndex.collectErrorsForAllIndices(
            List<? extends CommonForIndex> indices, int i, ASTNode child, ErrorCheckType checkType) {
        throw new UnsupportedOperationException();
    }
    
    public void InstForIndex.collectErrorsForAllIndices(
            List<? extends CommonForIndex> indices, int i, ASTNode child, ErrorCheckType checkType) {
        if (hasFExp()) {
            InstComponentDecl var = getInstPrimitive();
            CValue oldVal = var.evaluationValue;
            boolean last = i == indices.getNumChild() - 1;
            CommonForIndex next = last ? null : indices.getChild(i + 1);
            CValueArray ivals = getFExp().ceval().array();
            for (Index j : ivals.indices()) {
                var.setEvaluationValue(ivals.getCell(j));
                if (last) {
                    child.resetCollectErrors();
                    child.collectErrors(checkType);
                    child.flushAllRecursive();
                } else {
                    next.collectErrorsForAllIndices(indices, i + 1, child, checkType);
                }
            }
            var.setEvaluationValue(oldVal);
        }
    }
	
    
	public void InstFunctionCall.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	errorChecked = true;
	    	// Check that the function exists
            InstFunctionDecl func = getName().myInstFunctionDecl();
	    	if (!func.isCallable()) {
	    		// Report that function does not exist
		    	String name = getName().name();
		    	if (func.isExternalObject()) {
		    		name += ".constructor";
		    		func = func.asInstClassDecl().myConstructor();
		    	}
		    	if (func.isUnknown()) 
	    			error("Cannot find function declaration for " + name + "()");
	    		else
	    			error("The class " + name + " is not a function");
	    	} else if (!func.isRecord() && !func.isCompleteFunction()) {
	    		// TODO: add check if function is partial?
	    	    if (!checkType.allowIncompleteReplaceableFunc() || !canBeReplacedForMe(func.asInstNode()))
	    	        error("Calling function " + getName().name() + 
	    	                "(): can only call functions that have one algorithm section or external function specification");
	    	} else {
	    		// Function exists, check everything
	            errorChecked = false; // super also uses errorChecked
	    		super.collectErrors(checkType);
	    		
	    		// We need to check the function definition as well.
	    	    func.collectErrors(checkType);
	    	    
	    	    // Check if there were any unbindable args
			    boolean pos = true;
			    String desc = functionCallDecription();
			    for (InstFunctionArgument arg : unbindableArgs) 
			    	pos = arg.generateUnbindableError(desc, pos);
	    	}
	    }
	}
    
    /**
     * Can <code>node</code> be replaced as seen from here?
     */
    inh boolean ASTNode.canBeReplacedForMe(InstNode node);
    eq InstNode.getChild().canBeReplacedForMe(InstNode node) = node.canBeReplacedFor(this);
    eq Root.getChild().canBeReplacedForMe(InstNode node)     = false;
	
	/**
	 * Is this node or any node before the closest common ancestor with <code>source</code> replaceable?
	 */
	syn boolean InstNode.canBeReplacedFor(InstNode source) = canBeReplacedIn(commonAncestor(source));
	
    /**
     * Is this class or any class before <code>ancestor</code> replaceable?
     */
	syn boolean InstNode.canBeReplacedIn(InstNode ancestor) = isReplaceable() || canBeReplacedInHelper(ancestor);

    /**
     * Helper method for {@link #canBeReplacedIn(InstNode)} - use it instead.
     */
    inh boolean InstNode.canBeReplacedInHelper(InstNode ancestor);
    eq InstNode.getChild().canBeReplacedInHelper(InstNode ancestor) = (ancestor != this) && canBeReplacedIn(ancestor);
    eq Root.getChild().canBeReplacedInHelper(InstNode ancestor)     = false;

	public void FInfArgsFunctionCall.collectErrors(ErrorCheckType checkType) {
		super.collectErrors(checkType);
		if (unbindableArgs != null) {
		    boolean pos = true;
		    String desc = functionCallDecription();
		    for (InstFunctionArgument arg : unbindableArgs) 
		    	pos = arg.generateUnbindableError(desc, pos);
		}
	}
	
	syn String FAbstractFunctionCall.functionCallDecription() = "Calling function " + name() + "()";
	eq FRecordConstructor.functionCallDecription()    = "Record constructor for " + name();
    eq InstRecordConstructor.functionCallDecription() = "Record constructor for " + name();
	eq InstFunctionCall.functionCallDecription()      = getName().myInstClassDecl().isRecord() ? 
			"Record constructor for " + name() : super.functionCallDecription();
    eq InstPartialFunctionCall.functionCallDecription() = "Creating functional input argument " + name() + "()";
	  
	public boolean InstFunctionArgument.generateUnbindableError(String desc, boolean genForPos) {
		return genForPos;
	}
	  
	public boolean InstPositionalArgument.generateUnbindableError(String desc, boolean genForPos) {
		if (genForPos)
			error(desc + ": too many positional arguments");
		return false;
	}
	  
	public boolean InstNamedArgument.generateUnbindableError(String desc, boolean genForPos) {
		error(desc + ": no input matching named argument " + getName().name() + " found");
		return genForPos;
	}
	
	public void FBuiltInFunctionCall.collectErrors(ErrorCheckType checkType) {
	    if (!errorChecked) {
	    	super.collectErrors(checkType);
	    	errorChecked = true;
	    	getOriginalArgs().collectErrors(checkType);
	    }
	}
	
	public void FUnsupportedBuiltIn.collectErrors(ErrorCheckType checkType) {
		// Don't check arguments
		allChecks(checkType);
	}
 
	public void InstNamedArgument.collectErrors(ErrorCheckType checkType) {
		// TODO: This way, the FExp for each argument to a built-in function is checked twice - fix that
	    if (!errorChecked) {
			allChecks(checkType);
			getFExp().collectErrors(checkType);
	    }
	}
	
	/**
	 * Check if this node is in a recursive structure.
	 */
	syn boolean InstNode.isRecursed()      = false;
	eq InstComponentDecl.isRecursed()      = isWithin(myInstClass());
	eq InstExtends.isRecursed()            = isWithin(myInstClass());
	eq InstArrayComponentDecl.isRecursed() = instComponentDecl().isRecursed();
	
	// TODO: check if we realy need this in addition to isRecursed()
	/**
	 * Check if extends tree is recursive.
	 */
	public boolean InstExtends.isRecursive() {
		if (recursiveCache == RECURSIVE_UNKNOWN)
			calcIsRecursive(new HashSet<InstNode>());
		return recursiveCache == RECURSIVE_YES;
	}
	
	/**
	 * Check if extends tree is recursive.
	 */
	public boolean InstSimpleShortClassDecl.isRecursive() {
		if (recursiveCache == RECURSIVE_UNKNOWN)
			calcIsRecursive(new HashSet<InstNode>());
		return recursiveCache == RECURSIVE_YES;
	}
	
	/**
	 * Examine extends tree to find recursive extends nodes.
	 */
	public void InstExtends.calcIsRecursive(HashSet<InstNode> visited) {
		recursiveCache = visited.contains(this) ? RECURSIVE_YES : RECURSIVE_NO;
		visited.add(this);
		if (recursiveCache == RECURSIVE_NO) 
			myInstClass().calcIsRecursive(visited);
	}
	
	/**
	 * Examine extends tree to find recursive extends nodes.
	 */
	public void InstClassDecl.calcIsRecursive(HashSet<InstNode> visited) {
		for (InstExtends ie : getInstExtendss())
			ie.calcIsRecursive(visited);
	}
	
	public void InstSimpleShortClassDecl.calcIsRecursive(HashSet<InstNode> visited) {
		recursiveCache = visited.contains(this) ? RECURSIVE_YES : RECURSIVE_NO;
		visited.add(this);
		if (recursiveCache == RECURSIVE_NO) 
			getTarget().myInstClassDecl().calcIsRecursive(visited);
	}
	
	private byte InstExtends.recursiveCache              = RECURSIVE_UNKNOWN;
	private byte InstSimpleShortClassDecl.recursiveCache = RECURSIVE_UNKNOWN;
	protected static final byte InstNode.RECURSIVE_UNKNOWN = 0;
	protected static final byte InstNode.RECURSIVE_YES     = 1;
	protected static final byte InstNode.RECURSIVE_NO      = 2;
	
	/**
	 * Check if <code>icd</code> is an ancestor of this node or any ancestor is an 
	 *        instance of <code>icd</code>.
	 */
	inh boolean InstComponentDecl.isWithin(InstClassDecl icd);
	inh boolean InstExtends.isWithin(InstClassDecl icd);
	eq InstNode.getChild().isWithin(InstClassDecl icd)          = isOfInstClassDecl(icd);
	eq InstComponentDecl.getChild().isWithin(InstClassDecl icd) = isOfInstClassDecl(icd) || isWithin(icd);
	eq InstExtends.getChild().isWithin(InstClassDecl icd)       = isOfInstClassDecl(icd) || isWithin(icd);
    eq Root.getChild().isWithin(InstClassDecl icd)              = false;
	
	/**
	 * Check if this node is equal to or an instance of <code>icd</code>.
	 */
	syn boolean InstNode.isOfInstClassDecl(InstClassDecl icd) = false;
	eq InstClassDecl.isOfInstClassDecl(InstClassDecl icd)     = icd == this;
	eq InstComponentDecl.isOfInstClassDecl(InstClassDecl icd) = icd == myInstClass() && !icd.isUnknown();
	eq InstExtends.isOfInstClassDecl(InstClassDecl icd)       = icd == myInstClass() && !icd.isUnknown();
	
}

aspect AssertEval {

    public class FClass {
        /**
         * Evaluate asserts with constant tests, generate errors for failing ones, 
         * and eliminate all evaluated assets.
         */
        public class evaluateAsserts extends Transformation {
            public void perform() {
                for (FAbstractEquation eqn : getFAbstractEquations())
                    eqn.evaluateAsserts();
                List<FAbstractEquation> l = new List<FAbstractEquation>();
                for (FAbstractEquation eqn : getFAbstractEquations())
                    if (!eqn.markedForRemoval)
                        l.add(eqn);
                setFAbstractEquationList(l);
            }
        }
    }
    
    /**
     * Try to evaluate asserts with constant tests in this equation.
     * 
     * If this equation should be removed, <code>markedForRemoval</code> is set.
     */
    public void FAbstractEquation.evaluateAsserts() {}
    
    public void FFunctionCallEquation.evaluateAsserts() {
        markedForRemoval = getCall().evaluateAsserts();
    }
    
    /**
     * If this call is an assert with constant test, try to evaluate it.
     * 
     * @return  <code>true</code> if this is an assert that should be removed
     */
    public boolean FAbstractFunctionCall.evaluateAsserts() {
        return false;
    }
    
    private static final String FAssert.LEVEL_ERROR = "error";
    
    public boolean FAssert.evaluateAsserts() {
        boolean remove = false;
        if (getTest().isConstantExp()) {
            try {
                boolean val = getTest().ceval().booleanValue();
                if (!val) {
                    String msg = "Assertion failed: " + getMsg().ceval().stringValue();
                    if (!hasLevel() || getLevel().ceval().stringValue().equals(LEVEL_ERROR))
                        error(msg);
                    else
                        warning(msg);
                }
                remove = true;
            } catch (ConstantEvaluationException e) {}
        }
        return remove;
    }
    
}

aspect ScalarizationErrorCheck {
    
    /**
     * Check errors that can only be detected after scalarization.
     */
    public void FClass.scalarizationErrorCheck() {
        checkMultipleReinit();
        breakOnErrors();
    }
    
    /**
     * Check for variables with multiple reinits.
     */
    public void FClass.checkMultipleReinit() {
        Map<FAbstractVariable, Set<FReinit>> reinitMap = collectReinits();
        for (FAbstractVariable fv : reinitMap.keySet()) {
            if (!fv.isUnknown()) {
                Set<FWhenEquation> whens = new HashSet<FWhenEquation>();
                Set<FReinit> reinits = reinitMap.get(fv);
                for (FReinit r : reinits) {
                    FWhenEquation w = r.myWhen();
                    if (!whens.contains(w))
                        whens.add(w);
                }
                if (whens.size() > 1) {
                    StringBuilder buf = new StringBuilder();
                    buf.append("The variable ");
                    buf.append(fv.name());
                    buf.append(" is assigned in reinit() clauses in more than one when clause:\n");
                    for (FReinit r : reinits) {
                        buf.append("    ");
                        buf.append(r);
                        buf.append(";\n");
                    }
                    fv.error(buf.toString());
                }
            }
        }
    }
    
    /**
     * Find all reinits and map them to the assigned variable.
     */
    syn boolean FVariable.isReinit() = myFClass().collectReinits().keySet().contains(this);
    
    syn lazy Map<FAbstractVariable,Set<FReinit>> FClass.collectReinits() {
        Map<FAbstractVariable,Set<FReinit>> reinitMap = new HashMap<FAbstractVariable,Set<FReinit>>();
        for (FAbstractEquation e : getFAbstractEquations())
            e.collectReinits(reinitMap);
        return reinitMap;
    }
    
    public void FAbstractEquation.collectReinits(Map<FAbstractVariable,Set<FReinit>> map) {}
    
    public void FIfWhenEquation.collectReinits(Map<FAbstractVariable,Set<FReinit>> map) {
    	if (isWhen()) {
	        super.collectReinits(map);
	        if (hasElse())
	            getElse().collectReinits(map);
    	}
    }
    
    public void FIfWhenElseEquation.collectReinits(Map<FAbstractVariable,Set<FReinit>> map) {
        for (FAbstractEquation e : getFAbstractEquations())
            e.collectReinits(map);
    }
    
    public void FFunctionCallEquation.collectReinits(Map<FAbstractVariable,Set<FReinit>> map) {
        getCall().collectReinits(map);
    }
    
    public void FExp.collectReinits(Map<FAbstractVariable,Set<FReinit>> map) {}
    
    public void FReinit.collectReinits(Map<FAbstractVariable,Set<FReinit>> map) {
        Set<FReinit> set = map.get(myFV());
        if (set == null) {
            set = new LinkedHashSet<FReinit>();
            map.put(myFV(), set);
        }
        set.add(this);
    }
    
    /**
     * Get the when-equation that this reinit() belongs to.
     * 
     * Gets the top when in a when-elsewhen-else.
     * Not valid after when-equations have been converted to if-equations.
     */
    inh FWhenEquation FReinit.myWhen();
    eq FWhenEquation.getChild().myWhen() = findTopWhen(this);
    eq FClass.getChild().myWhen()        = null;
    eq InstNode.getChild().myWhen()      = null;
    
    /**
     * Find the top when-equation in a when-elsewhen-else equation.
     * 
     * @param last  will be returned if parent is not a when equation
     */
    inh FWhenEquation FWhenEquation.findTopWhen(FWhenEquation last);
    eq FWhenEquation.getChild().findTopWhen(FWhenEquation last) = findTopWhen(this);
    eq FClass.getChild().findTopWhen(FWhenEquation last)        = last;
    eq InstNode.getChild().findTopWhen(FWhenEquation last)      = last;
    
}
