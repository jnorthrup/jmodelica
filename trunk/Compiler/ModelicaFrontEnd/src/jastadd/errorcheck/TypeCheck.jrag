/*
    Copyright (C) 2009-2013 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Arrays;
import java.util.Collections;
import org.jmodelica.util.Criteria;
import org.jmodelica.util.ErrorCheckType;
import org.jmodelica.util.problemHandling.ErrorProducerUnlessDisabled;
import org.jmodelica.util.problemHandling.AbstractErrorProducerUnlessDisabled;

aspect FlatTypeCheck {

    public void ASTNode.typeCheck(ErrorCheckType checkType) {}

    public abstract class ErrorChecker {
        public static class TypeChecker extends ErrorChecker {
            public TypeChecker() {
                super("TypeCheck");
            }

            @Override
            public void check(ASTNode node, ErrorCheckType checkType) {
                node.typeCheck(checkType);
            }
        }
    }

    private static ErrorChecker ASTNode.TYPE_CHECKER = addErrorChecker(new ErrorChecker.TypeChecker());

    public static final SimpleProblemProducer ASTNode.CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS =
            new SimpleErrorProducer("CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS", ProblemKind.SEMANTIC,
                    "In the declaration '%s', the declared class is not a subtype of the constraining class");
    public static final SimpleProblemProducer ASTNode.REPLACING_CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS =
            new SimpleErrorProducer("REPLACING_CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS", ProblemKind.SEMANTIC,
                    "In the declaration '%s', the replacing class is not a subtype of the constraining class from the declaration '%s'");

    public void InstComposite.typeCheck(ErrorCheckType checkType) {
        super.typeCheck(checkType);
        // Note that modifiers (including redeclarations) in a constraining clause
        // are applied to the declaration itself and is therefore also type checked.
        if (hasInstConstrainingComponent()) {
              InstNode superType = getInstConstrainingComponent().getInstNode();
              InstComponentDecl declaredType = this; 
              if (!declaredType.subType(superType))
                  CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS.invoke(declaredType.getComponentDecl(), declaredType.getComponentDecl());
        }
    }

    public void InstReplacingRecord.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingComposite.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingPrimitive.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstReplacingExpandableConnectorDecl.typeCheck(ErrorCheckType checkType) {
        typeCheckReplacingComponent(getOriginalInstComponent(), checkType);
    }

    public void InstComponentDecl.typeCheckReplacingComponent(InstComponentDecl declaredType, ErrorCheckType checkType) {
        super.typeCheck(checkType);
        
        // Type check the original component
        InstComponentDecl superType = declaredType.constrainingInstComponentDecl();
        if (declaredType.hasInstConstrainingComponent() && !declaredType.subType(superType))
            CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS.invoke(superType.getComponentDecl(), declaredType.getComponentDecl());

        // The environment should be traversed backwards in order to perform correct
        // subtype tests in redeclaration chains.       
        for (int i = myEnvironment().size() - 1; i >= 0; i--) {
            InstModification im = myEnvironment().get(i);
            InstComponentRedeclare redeclare = im.matchInstComponentRedeclare(name());
            if (redeclare != null) { 
                InstComponentDecl declaredSubType = redeclare.getInstComponentDecl();
                InstComponentDecl constrainingSubType = declaredSubType.constrainingInstComponentDecl();
                    
                // Check consistency of the redeclaring component
                if (declaredSubType.hasInstConstrainingComponent() && !declaredSubType.subType(constrainingSubType))
                    CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS.invoke(declaredSubType.getComponentDecl(), declaredSubType.getComponentDecl());

                // It is ok to check against the constrainingSubType, since the declaredSubType is a subtype
                // of the constrainingSubType. Then if constrainingSubType is a subtype of superType, then it
                // follows that declaredSubType is a subtype of superType by transitivity.
                if (!constrainingSubType.subType(superType))
                    REPLACING_CLASS_NOT_SUBTYPE_OF_CONSTRAINING_CLASS.invoke(constrainingSubType.getComponentDecl(), 
                            constrainingSubType.getComponentDecl(), superType.getComponentDecl());
            
                // If the redeclaring declaration has a constraining clause, the constraining
                // type of the redeclaring declaration of should be used in following subtype-test 
                // instead of the constraining type of the orignal declaration.
                if (declaredSubType.hasInstConstrainingComponent()) 
                    superType = constrainingSubType;
            }
        }
    }
    
    public static final SimpleProblemProducer ASTNode.CANNOT_INFER_ARRAY_SIZE_OF_VARIABLE =
            new SimpleErrorProducer("CANNOT_INFER_ARRAY_SIZE_OF_VARIABLE", ProblemKind.SEMANTIC,
                    "Can not infer array size of the variable %s");
    public static final SimpleProblemProducer ASTNode.BINDING_EXPRESSION_TYPE_MISMATCH =
            new SimpleErrorProducer("BINDING_EXPRESSION_TYPE_MISMATCH", ProblemKind.SEMANTIC,
                    "The binding expression of the variable %s does not match the declared type of the variable");
    public static final SimpleProblemProducer ASTNode.ASSUMING_EACH =
            new SimpleWarningProducer("ASSUMING_EACH", ProblemKind.SEMANTIC, "Assuming 'each' for the modification '%s'");
    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_DECLARATION =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_DECLARATION", ProblemKind.SEMANTIC,
                    "Array size mismatch in declaration of %s, size of declaration is %s and size of binding expression is %s");
    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_MODIFICATION =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_MODIFICATION", ProblemKind.SEMANTIC,
                    "Array size mismatch in modification of %s, expected size is %s and size of binding expression is %s");
    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_MODIFICATION_DUE_TO_EACH =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_MODIFICATION_DUE_TO_EACH", ProblemKind.SEMANTIC,
                    "Array size mismatch in modification of %s, expected size is (due to 'each') %s and size of binding expression is %s");
    public static final SimpleProblemProducer ASTNode.NON_SCALAR_CONDITIONAL_GUARD =
            new SimpleErrorProducer("NON_SCALAR_CONDITIONAL_GUARD", ProblemKind.SEMANTIC,
                    "The guard expression of a conditional component should be a scalar expression");
    public static final SimpleProblemProducer ASTNode.NON_BOOLEAN_CONDITIONAL_GUARD =
            new SimpleErrorProducer("NON_BOOLEAN_CONDITIONAL_GUARD", ProblemKind.SEMANTIC,
                    "The guard expression of a conditional component should be a boolean expression");
    public static final SimpleProblemProducer ASTNode.NON_FIXED_CONDITIONAL_GUARD =
            new SimpleErrorProducer("NON_FIXED_CONDITIONAL_GUARD", ProblemKind.SEMANTIC,
                    "The guard expression of a conditional component should have parameter or constant variability");

    public void InstAssignable.typeCheck(ErrorCheckType checkType) {
        FExp bexp = myBindingInstExp();
        boolean func = inFunction();
        Size componentSize = size();
        if (!componentSize.isComplete() && !func && !inRecordDecl() && !checkType.allowIncompleteSizes()) 
            CANNOT_INFER_ARRAY_SIZE_OF_VARIABLE.invoke(this, name());
        if (bexp != null && !inRecordWithBindingExp() && !bexp.type().isUnknown()) {
            InstValueModification ivm = myInstValueMod();
            FType expectedBT = bindingType();
            FType actualBT = bexp.type();
            if (!expectedBT.typeCompatible(actualBT, func) && !expectedBT.isUnknown()) {
                InstModification needsEach = ivm.findModificationLackingEach(actualBT.size());
                if (needsEach != null) {
                    ASSUMING_EACH.invoke(needsEach, needsEach);
                } else if (!expectedBT.scalarType().typeCompatible(actualBT.scalarType())) {
                    BINDING_EXPRESSION_TYPE_MISMATCH.invoke(bexp, name());
                } else {
                    ErrorProducerUnlessDisabled reporter;
                    if (ivm.myInstNode() == this) {
                        reporter = ARRAY_SIZE_MISMATCH_IN_DECLARATION;
                    } else if (ivm.hasEach()) {
                        reporter = ARRAY_SIZE_MISMATCH_IN_MODIFICATION_DUE_TO_EACH;
                    } else {
                        reporter = ARRAY_SIZE_MISMATCH_IN_MODIFICATION;
                    }
                    reporter.invokeWithCondition(bexp, expectedBT.ndims() == actualBT.ndims(), name(), expectedBT.size(), actualBT.size());
                }
            }
        }
        
        if (hasConditionalAttribute()) {
            FExp cond = getConditionalAttribute();
            if (!cond.type().isUnknown()) {
                if (!cond.type().isScalar()) 
                    NON_SCALAR_CONDITIONAL_GUARD.invoke(this);
                if (!cond.type().isBoolean()) 
                    NON_BOOLEAN_CONDITIONAL_GUARD.invoke(this);
                if (!cond.variability().parameterOrLess()) 
                    NON_FIXED_CONDITIONAL_GUARD.invoke(this);
            }
        }
        
        typeCheckAttributes();
        super.typeCheck(checkType);
    }

    inh boolean InstComponentDecl.inRecordWithBindingExp();
    eq InstRecord.getChild().inRecordWithBindingExp()             = myBindingInstExp() != null;
    eq InstArrayComponentDecl.getChild().inRecordWithBindingExp() = inRecordWithBindingExp();
    eq InstComponentDecl.getChild().inRecordWithBindingExp()      = false;
    eq InstClassDecl.getChild().inRecordWithBindingExp()          = false;
    eq Root.getChild().inRecordWithBindingExp()                   = false;
    
    public void InstAssignable.typeCheckAttributes() {}
    
    public void InstPrimitive.typeCheckAttributes() {
	    for (InstModification im : totalMergedEnvironment()) 
	    	im.typeCheckAttribute(this);
     }

    public void InstModification.typeCheckAttribute(InstNode owner) {}

    public static final SimpleProblemProducer ASTNode.TYPE_MISMATCH_IN_ATTRIBUTE_MODIFICATION =
            new SimpleErrorProducer("TYPE_MISMATCH_IN_ATTRIBUTE_MODIFICATION", ProblemKind.SEMANTIC,
                    "The type of the binding expression of the attribute %s for the %s %s does not match the declared type of the variable");
    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_ATTRIBUTE_MODIFICATION =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_ATTRIBUTE_MODIFICATION", ProblemKind.SEMANTIC,
                    "Array size mismatch in modification of the attribute %s for the %s %s, expected size is %s and size of %s expression is %s");
    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_ATTRIBUTE_MODIFICATION_DUE_TO_EACH =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_ATTRIBUTE_MODIFICATION_DUE_TO_EACH", ProblemKind.SEMANTIC,
                    "Array size mismatch in modification of the attribute %s for the %s %s, expected size is (due to 'each') %s and size of %s expression is %s");

    public void InstComponentModification.typeCheckAttribute(InstNode owner) {
        if (hasInstModification() && getInstModification().hasInstValueMod()) {
            FExp valMod = getInstModification().instValueMod();
            if (!type().isUnknown() && !valMod.type().isUnknown()) {
                Size attrSize = expectedSize();
                if (!type().typeCompatible(valMod.type().scalarType())) {
                    TYPE_MISMATCH_IN_ATTRIBUTE_MODIFICATION.invoke(this, name(), owner.kindDescription(), owner.name());
                } else if (!attrSize.equivalent(valMod.size(), true)) {
                    InstModification im = findModificationLackingEach(valMod.size());
                    if (im != null) {
                        ASSUMING_EACH.invoke(im, im);
                    } else {
                        ErrorProducerUnlessDisabled producer;
                        if (hasEach()) {
                            producer = ARRAY_SIZE_MISMATCH_IN_ATTRIBUTE_MODIFICATION_DUE_TO_EACH;
                        } else {
                            producer = ARRAY_SIZE_MISMATCH_IN_ATTRIBUTE_MODIFICATION;
                        }
                        producer.invokeWithCondition(this, attrSize.ndims() != valMod.ndims(), name(),
                                owner.kindDescription(), owner.name(), attrSize, name(), valMod.size());
                    }
                } else {
                    if (name().equals("nominal")) {
                        checkNominalAttribute(owner, valMod);
                    }
                }
            }
        }
    }

    public static final SimpleProblemProducer ASTNode.NOMINAL_EQUAL_TO_ZERO =
            new SimpleErrorProducer("NOMINAL_EQUAL_TO_ZERO", ProblemKind.SEMANTIC,
                    "The attribute nominal for the %s %s is set to %s, evaluating to 0.0. A nominal value of zero is not meaningful. Please set the nominal value to the expected magnitude of the variable.");
    public static final SimpleProblemProducer ASTNode.NOMINAL_ELEMENT_EQUAL_TO_ZERO =
            new SimpleErrorProducer("NOMINAL_ELEMENT_EQUAL_TO_ZERO", ProblemKind.SEMANTIC,
                    "The attribute nominal for the %s %s is set to %s, where element %s evaluates to 0.0. A nominal value of zero is not meaningful. Please set the nominal value to the expected magnitude of the variable.");

    public void InstComponentModification.checkNominalAttribute(InstNode owner, FExp valMod) {
        try {
            CValue val = valMod.ceval();
            if (val.isArray()) {
                CValueArray arr = (CValueArray) val;
                for (Index i : arr.indices()) {
                    if (arr.getCell(i).realValue() == 0.0) {
                        NOMINAL_ELEMENT_EQUAL_TO_ZERO.invoke(this, owner.kindDescription(), owner.name(), valMod, i);
                        break;
                    }
                }
            } else {
                if (val.realValue() == 0.0) {
                    NOMINAL_EQUAL_TO_ZERO.invoke(this, owner.kindDescription(), owner.name(), valMod);
                }
            }
        } catch (ConstantEvaluationException e) {}
    }

    syn String InstNode.kindDescription() {
        throw new UnsupportedOperationException();
    }
    eq InstComponentDecl.kindDescription() = myInstClass().kindDescription() + " instance";
    eq InstPrimitive.kindDescription()     = "variable";
    eq InstBaseClassDecl.kindDescription() = getInstRestriction().toString();

    public static final SimpleProblemProducer ASTNode.EACH_APPLIED_ON_SCALAR =
            new SimpleWarningProducer("EACH_APPLIED_ON_SCALAR", ProblemKind.SEMANTIC,
                    "The 'each' keyword should not be applied to a modification of a scalar component: %s");

    public void InstArgument.typeCheck(ErrorCheckType checkType) {
        if (getEach() && expectedSizeFromParent() == Size.SCALAR) 
            EACH_APPLIED_ON_SCALAR.invoke(this, this);
    }

    inh boolean InstNode.isInRedeclareMod();
    eq InstElementRedeclare.getChild().isInRedeclareMod() = true;
    eq InstClassDecl.getChild().isInRedeclareMod()        = false;
    eq InstRoot.getChild().isInRedeclareMod()             = false;
    eq Root.getChild().isInRedeclareMod()                 = false;

    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_EQUATION =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_EQUATION", ProblemKind.SEMANTIC,
                    "The array sizes of right and left hand side of equation are not compatible, size of left-hand side is %s, and size of right-hand side is %s");
    public static final SimpleProblemProducer ASTNode.TYPE_MISMATCH_IN_EQUATION =
            new SimpleErrorProducer("TYPE_MISMATCH_IN_EQUATION", ProblemKind.SEMANTIC,
                    "The right and left expression types of equation are not compatible, type of left-hand side is %s, and type of right-hand side is %s");

    public void FEquation.typeCheck(ErrorCheckType checkType) {
        typeCheckLocalIteration(checkType);
        FType left = getLeft().type();
        FType right = getRight().type();
        if (!left.isUnknown() && !right.isUnknown()) {
            if (!left.equivalentTo(right)) {
                if (left.equivalentExceptLengths(right)) {
                    if (!lockBranch(checkType))
                        ARRAY_SIZE_MISMATCH_IN_EQUATION.invoke(this, left.size(), right.size());
                } else {
                    TYPE_MISMATCH_IN_EQUATION.invoke(this, left, right);
                }
            }
        }
    }

    public static final SimpleProblemProducer ASTNode.CONNECT_WITH_INVALID_TYPE =
            new SimpleErrorProducer("CONNECT_WITH_INVALID_TYPE", ProblemKind.SEMANTIC,
                    "Connecting to an instance of a non-connector type is not allowed");
    public static final SimpleProblemProducer ASTNode.CONNECT_EXPANDABLE_AND_NON_EXPANDABLE_TYPE =
            new SimpleErrorProducer("CONNECT_EXPANDABLE_AND_NON_EXPANDABLE_TYPE", ProblemKind.SEMANTIC,
                    "Connecting an expandable connector to a non-expandable connector is not allowed");
    public static final SimpleProblemProducer ASTNode.TYPE_MISMATCH_IN_CONNECT =
            new SimpleErrorProducer("TYPE_MISMATCH_IN_CONNECT", ProblemKind.SEMANTIC,
                    "Types of connected components do not match");
    public static final ErrorProducerUnlessDisabled ASTNode.ARRAY_SIZE_MISMATCH_IN_CONNECT =
            new ErrorProducerUnlessDisabled("ARRAY_SIZE_MISMATCH_IN_CONNECT", ProblemKind.SEMANTIC,
                    "Sizes do not match in connection, size of '%s' is %s and size of '%s' is %s");

    public void FConnectClause.typeCheck(ErrorCheckType checkType) {
        InstAccess left  = getConnector1().getInstAccess();
        InstAccess right = getConnector2().getInstAccess();
        boolean checkTypes = !isDisabled();
        boolean expandableSame = true;
        for (InstAccess access = left; access != null; access = (access == left) ? right : null) {
            if (!access.isExpandableConnectorPart() && !access.isUnknown() && !access.myInstComponentDecl().myInstClass().isUnknown()) {
                if (!access.myInstComponentDecl().isConnector())
                    CONNECT_WITH_INVALID_TYPE.invoke(access);
            } else {
                checkTypes = false;
            }
            if (access.myInstComponentDecl().isExpandableConnector())
                expandableSame = !expandableSame;
        }
        if (!expandableSame && !left.isUnknown() && !right.isUnknown())
            CONNECT_EXPANDABLE_AND_NON_EXPANDABLE_TYPE.invoke(this);
        if (checkTypes) { 
            InstComponentDecl leftComp  = left.lookupEvaluatingIndices();
            InstComponentDecl rightComp = right.lookupEvaluatingIndices();
            if (!leftComp.connectableTo(rightComp)) {
                TYPE_MISMATCH_IN_CONNECT.invoke(this);
            } else if (!left.size().equivalent(right.size(), false)) {
                ARRAY_SIZE_MISMATCH_IN_CONNECT.invokeWithCondition(this, left.ndims() == right.ndims(), 
                        left, left.size(), right, right.size());
            }
        }
    }

  // Generic typeCheck(checkType) that calls typeError() if type is unknown and no FExp child has unknown type
  public void FExp.typeCheck(ErrorCheckType checkType) {
	  if (type().isUnknown()) {
		  for (FExp exp : childFExps())
			  if (exp.type().isUnknown())
				  return;
		  typeError(checkType);
	  }
  }
  
  protected static boolean FExp.isUnknownFExp(ASTNode n) {
	  return n instanceof FExp && ((FExp) n).type().isUnknown();
  }

  
    public class FExp {
        public static class ExpTypeErrorProducer extends AbstractErrorProducerUnlessDisabled<ReporterNode> {
            private final String message;
            
            public ExpTypeErrorProducer(String identifier, String message) {
                super(identifier, ProblemKind.SEMANTIC);
                this.message = message;
            }

            public void invoke(FExp node) {
                StringBuilder buf = new StringBuilder(message);
                buf.append(": ");
                buf.append(node);
                for (FExp exp : node.childFExps()) {
                    buf.append("\n    type of '");
                    buf.append(exp);
                    buf.append("' is ");
                    buf.append(exp.type());
                }
                super.invokeWithCondition(node, node.typeErrorOnlyLengths(), buf.toString());
            }

            @Override
            public String description() {
                return message;
            }
            
        }
    }
    
    public static final FExp.ExpTypeErrorProducer ASTNode.TYPE_MISMATCH_IN_EXPRESSION =
            new FExp.ExpTypeErrorProducer("TYPE_MISMATCH_IN_EXPRESSION", "Type error in expression");

    public void FExp.typeError(ErrorCheckType checkType) {
        TYPE_MISMATCH_IN_EXPRESSION.invoke(this);
    }

    public void FIdUse.typeError(ErrorCheckType checkType, FIdUseExp use) {
        use.typeError(checkType);
    }

    public void FIdUseInstAccess.typeError(ErrorCheckType checkType, FIdUseExp use) {
        getInstAccess().typeError();
    }

    /**
     * Check if type error is only in array lengths.
     */
    syn boolean FExp.typeErrorOnlyLengths() = typeErrorOnlyLengths(childFExps());
    eq FAbstractCat.typeErrorOnlyLengths()  = typeErrorOnlyLengths(getFExps());

    /**
     * Check if type error is only in array lengths.
     */
    syn boolean FExp.typeErrorOnlyLengths(Iterable<FExp> exps) {
        FType first = null;
        for (FExp exp : exps) {
            FType cur = exp.type();
            if (first == null) {
                first = cur;
            } else if (!first.equivalentExceptLengths(cur)) {
                return false;
            }
        }
        return true;
    }

    /**
     * The message to use in default type error.
     */
    public static final FExp.ExpTypeErrorProducer ASTNode.EQUALITY_COMPARISON_OF_REAL =
            new FExp.ExpTypeErrorProducer("EQUALITY_COMPARISON_OF_REALS", "Equality comparisons do not allow real operands");

    @Override
    public void FEqRelExp.typeError(ErrorCheckType checkType) {
        if ((getLeft().type().isRealScalar() || getRight().type().isRealScalar()) && !inFunction()) {
            EQUALITY_COMPARISON_OF_REAL.invoke(this);
        } else {
            super.typeError(checkType);
        }
    }
    
    public void FLinspace.typeCheck(ErrorCheckType checkType) {
        getN().markAsStructuralParameter(checkType);
        super.typeCheck(checkType);
    }

    public void FLinspace.typeError(ErrorCheckType checkType) {
        boolean badVar = !getN().variability().parameterOrLess();
        boolean canCeval = getN().canCeval();
        boolean badVal = canCeval && getN().ceval().intValue() < 2;
        if (badVar || !canCeval || badVal) {
            String msg = "Third argument of linspace() must be a scalar parameter Integer expression that is greater than 1";
            if (badVar)
                error("%s\n    '%s' is of %s variability", msg, getN(), getN().variability().toStringLiteral());
            else if (canCeval && !lockBranch(checkType))
                errorUnlessDisabled("%s\n    '%s' evaluates to %d", msg, getN(), getN().ceval().intValue());
        } else {
            super.typeError(checkType);
        }
    }

    public void FIdentity.typeCheck(ErrorCheckType checkType) {
        getFExp().markAsStructuralParameter(checkType);
        super.typeCheck(checkType);
    }

    public void FIdentity.typeError(ErrorCheckType checkType) {
        if (!getFExp().variability().parameterOrLess()) 
            error("Argument of identity() must be a scalar parameter Integer expression\n    '%s' is of %s variability", 
                    getFExp(), getFExp().variability().toStringLiteral());
        else 
            super.typeError(checkType);
    }

    public void FSizeExp.typeCheck(ErrorCheckType checkType) {
        if (hasDim())
            getDim().markAsStructuralParameter(checkType);
        super.typeCheck(checkType);
    }

    public void FSizeExp.typeError(ErrorCheckType checkType) {
        if (hasDim()) {
            if (!getDim().type().isIntegerScalar())
                return;  // Error is reported for argument in this case
            boolean badVar = !getDim().variability().parameterOrLess();
            boolean canCeval = getDim().canCeval();
            int dimVal = canCeval ? getDim().ceval().intValue() : 1;
            int ndims = getFExp().ndims();
            if (badVar || !canCeval || dimVal < 1 || dimVal > ndims) {
                String msg = "Second argument of size() must be a scalar parameter Integer expression that evaluates to a valid dimension of the first argument";
                if (badVar)
                    error("%s\n    '%s' is of %s variability", msg, getDim(), getDim().variability().toStringLiteral());
                else if (canCeval)
                    error("%s\n    '%s' evaluates to %d, and '%s' has %d dimensions", msg, getDim(), dimVal, getFExp(), ndims);
                return;
            }
        }
        super.typeError(checkType);
    }

  public void InstAccess.typeError() {
	  typeError(this);
  }
  
  protected void InstAccess.typeError(InstAccess top) {}
  
  protected void InstDot.typeError(InstAccess top) {
	  getLastInstAccess().typeError(top);
  }
  
  protected void InstGlobalAccess.typeError(InstAccess top) {
	  getInstAccess().typeError(top);
  }
  
  protected void InstComponentAccess.typeError(InstAccess top) {
	  InstComponentDecl icd = myInstComponentDecl();
	  if (!icd.isUnknown() && !icd.myInstClass().isUnknown() && !inCardinality()) {
		  if (icd.isOrExtendsPrimitive() || icd.isRecord())
			  top.error("Could not calculate type of " + top.name());
		  else
			  top.error("Accesses to composite components other than records are not allowed: " + top.name());
	  }
  }
  
  protected void InstComponentArrayAccess.typeError(InstAccess top) {
	  InstComponentDecl icd = myInstComponentDecl();
      if (!icd.isUnknown() && !icd.myInstClass().isUnknown() && !inCardinality()) {
          if (icd.isOrExtendsPrimitive() || icd.isRecord())
			  top.error("Could not calculate type of " + top.name());
		  else
			  top.error("Accesses to composite components other than records are not allowed: " + top.name());
	  }
  }
  
  inh boolean InstAccess.inCardinality();
  eq FCardinality.getChild().inCardinality() = true;
  eq InstNode.getChild().inCardinality()     = false;
  eq Root.getChild().inCardinality()         = false;
  
  protected void InstClassAccess.typeError(InstAccess top) {
	  if (!isComponentSizeClass() || !isInstComponentSize())
		  top.error("Illegal access to class in expression: " + top.name());
  }
  
  public void FIfExp.typeError(ErrorCheckType checkType) {
		FType thenType = getThenExp().type();
		FType elseType = getElseExp().type();
		FType scalar = thenType.scalarType();
		scalar = scalar.typePromotion(elseType.scalarType());
		
		if (!getIfExp().isOKTestExp() || thenType.ndims() != elseType.ndims()) {
			getIfExp().error("Test expression of if expression must be scalar boolean");
		} else if (scalar.isUnknown()) { 
			error("Branches of if expression has incompatible types");
		} else {
			if (isParameterIf())
				error("Failed to evaluate test expression in if expression with branches that have different array sizes");
			else
				error("If expression with branches that have different array sizes must have parameter test expression");
		}
  }
  
  public void FIdUseExp.typeCheck(ErrorCheckType checkType) {
	  if (!getFIdUse().isUnknown() && type().isUnknown() && !accessToModelOK())
            getFIdUse().typeError(checkType, this);
  }
  
	public void FIdUse.typeCheck(ErrorCheckType checkType) {
        if (inAlgorithm() && useIsAssignment()) {
            if (variability().constantVariability()) {
                error("Assignments to constants is not allowed in algorithms");
            } else if (variability().parameterVariability()) {
                if (isForIndex()) {
                    error("Can not assign a value to a for loop index");
                } else if (!(myFAlgorithm().getType() instanceof FInitialEquation)) {
                    error("Assignments to parameters in algorithms is only allowed in initial algorithms");
                }
            }
        }
	}

  inh boolean FIdUseExp.accessToModelOK();
  inh boolean InstFunctionArgument.accessToModelOK();
  eq BaseNode.getChild().accessToModelOK()             = false;
  eq InstFunctionArgument.getChild().accessToModelOK() = accessToModelOK();
  eq FSizeExp.getFExp().accessToModelOK()              = true;
  eq FSizeExp.getOriginalArg(int i).accessToModelOK()  = i == 0;
  
  
  /**
   * Check if the FExp of this FIterExp must be scalar.
   */
  inh boolean FIterExp.iterExpMustBeScalar();
  eq FExp.getChild().iterExpMustBeScalar()       = false;
  eq Root.getChild().iterExpMustBeScalar()       = false;
  eq InstNode.getChild().iterExpMustBeScalar()   = false;
  eq FMinMaxExp.getChild().iterExpMustBeScalar() = true;
  // TODO: Add product() when it is implemented

    public void FMulExp.typeCheck(ErrorCheckType checkType) {
        if (type().isOperatorRecord() && !isElementWise()) {
            int left = getLeft().size().get(1);
            int inner = (left == Size.UNKNOWN) ? getRight().size().get(0) : left;
            if ((inner == 0 || inner == Size.UNKNOWN) && type().matchOverloadedZero() == null) 
                error("Matrix multiplication of operator records with an inner dimension of 0 or : requires that an '0' operator is defined");
        }
        getLeft().size().forceVariability(checkType, fStructParameter());
        getRight().size().forceVariability(checkType, fStructParameter());
        super.typeCheck(checkType);
    }

  public void FIterExp.typeCheck(ErrorCheckType checkType) {
	  super.typeCheck(checkType);
	  if (iterExpMustBeScalar() && !getFExp().type().isUnknown() && getFExp().ndims() != 0)
		  error("The expression of a reduction-expression must be scalar, except for sum(): " +
				  getFExp() + " has " + getFExp().ndims() + " dimension(s)");
  }
  
  public void FStreamBuiltIn.typeCheck(ErrorCheckType checkType) {
	  if (!getFExp().isAccessToStream()) 
		  error("Argument of " + builtInName() + "() must be a stream variable");
  }
  
  syn boolean FExp.isAccess()  = false;
  eq FIdUseExp.isAccess()      = true;
  syn FIdUse FExp.asFIdUse() {
	  throw new UnsupportedOperationException("asFIdUse() is not supported for class type " + getClass().getSimpleName());
  }
  eq FIdUseExp.asFIdUse() = getFIdUse();
  
  syn FIdUseExp FExp.asFIdUseExp() {
      throw new UnsupportedOperationException("asFIdUseExp() is not supported for class type " + getClass().getSimpleName());
  }
  eq FIdUseExp.asFIdUseExp() = this;
  
    syn boolean FIdUse.isInstAccess()  = false;
    eq FIdUseInstAccess.isInstAccess() = true;
    
	syn InstAccess FExp.asInstAccess() {
		throw new UnsupportedOperationException();
	}
    eq FIdUseExp.asInstAccess() = getFIdUse().asInstAccess();
    
    syn InstAccess FIdUse.asInstAccess() {
        throw new UnsupportedOperationException();
    }
    eq FIdUseInstAccess.asInstAccess() = getInstAccess();
    
  syn boolean FExp.isAccessToStream()  = false;
  eq FIdUseExp.isAccessToStream()      = getFIdUse().isAccessToStream();
  
  syn boolean FIdUse.isAccessToStream()  = false;
  eq FIdUseInstAccess.isAccessToStream() = getInstAccess().isAccessToStream();
  
  syn boolean InstAccess.isAccessToStream() = myInstComponentDecl().isStream();
  
  
  
  public void InstForIndex.typeCheck(ErrorCheckType checkType) {
	  if (hasFExp() && !getFExp().type().isUnknown() && getFExp().ndims() != 1)
		  error("The expression of for index " + name() + " must be a vector expression: " + 
				  getFExp() + " has " + getFExp().ndims() + " dimension(s)");
  }
  
  public void FExpSubscript.typeCheckAsSize(ErrorCheckType checkType) {
	  if (ndims() > 0) { 
		  error("Array size must be scalar expression: " + getFExp());
      } else if (!type().isUnknown() && !getFExp().canBeComponentSize()) {
          error("Array size must be Integer expression, Boolean type or enumeration type: " + getFExp());
	  } else if (!inFunction()) { 
		  if (!getFExp().variability().parameterOrLess()) {
			  error("Array size must be constant or parameter: " + getFExp());
		  } else if (!checkType.allowIncompleteSizes()) {
			  try {
				  getFExp().ceval().intValue();
			  } catch (ConstantEvaluationException e) {
				  error("Could not evaluate array size expression: " + getFExp());
			  }
		  }
	  }
  }

    public void FExpSubscript.typeCheckAsIndex(ErrorCheckType checkType) {
        if (ndims() > 1) { 
            error("Array index must be scalar or vector expression: " + getFExp());
        } else if (!type().isUnknown() && !type().canBeIndex()) {
            error("Array index must be Integer, Boolean, or enumeration expression: " + getFExp());
        } else if (!type().isUnknown() && !myIndexType().isUnknown() && !type().scalarType().typeCompatible(myIndexType())) {
            error("Expected array index of type '%s' found '%s'", myIndexType().name(), type().scalarType().name());
        } else if (!inFunction()) { 
              if (!getFExp().variability().fixedParameterOrLess()) {
                warning("Variable array index in equation can result in slow simulation time");
            } else if (!reportedOutOfBound && !inUnknownAccess()) {
                // Check array bounds
                // TODO: Perform bounds check in functions if index has parameter variability or lower?
                try {
                    int max = mySize().get(0);
                    for (FExp e : getFExp().getArray().iterable()) {
                        int i = e.ceval().intValue();
                        if (i < 1 || i > max) {
                            if (!lockBranch(checkType))
                                errorUnlessDisabled("Array index out of bounds: " + i + ", index expression: " + getFExp());
                            reportedOutOfBound = true;
                            return;
                        }
                    }
                } catch (ConstantEvaluationException e) {
                }
            }
        }
    }

  syn FType FExpSubscript.myIndexType() = myIndexType(myDim());
  inh FType FExpSubscript.myIndexType(int i);
  eq Root.getChild().myIndexType(int i)                                = fUnknownType();
  eq InstArrayAccess.getFArraySubscripts().myIndexType(int i)          = fUnknownType();
  eq InstComponentArrayAccess.getFArraySubscripts().myIndexType(int i) = myInstComponentDecl().myIndexType(i);
  
  syn FType InstComponentDecl.myIndexType(int dim) {
    FArraySubscripts fas = getFArraySubscripts();
    if (fas != null && fas.getNumFSubscript() > dim)
        return fas.getFSubscript(dim).type().scalarType();
    else
        return fUnknownType();
  }
  
  private boolean FExpSubscript.reportedOutOfBound = false;
  
  
  public void FExpSubscript.typeCheck(ErrorCheckType checkType) {
	  if (isInstComponentSize()) 
		  typeCheckAsSize(checkType);
	  else 
		  typeCheckAsIndex(checkType);
  }
  
  inh boolean FSubscript.inUnknownAccess();
  eq FIdUse.getChild().inUnknownAccess()                  = myFV().isUnknown();
  eq InstScalarAccess.getChild().inUnknownAccess()        = myInstComponentDecl().isUnknown();
  eq InstArrayAccess.getChild().inUnknownAccess()         = myInstComponentDecl().isUnknown();
  eq FlatRoot.getChild().inUnknownAccess()                = false;
  eq InstRoot.getChild().inUnknownAccess()                = false;
  
  syn boolean FExp.canBeComponentSize()  = type().isInteger();
  eq FIdUseExp.canBeComponentSize()      = type().isInteger() || getFIdUse().isComponentSizeClass();
  
  syn boolean InstAccess.isComponentSizeClass() = myInstClassDecl().isComponentSizeClass();
  syn boolean FIdUse.isComponentSizeClass()     = false;
  eq FIdUseInstAccess.isComponentSizeClass()    = getInstAccess().isComponentSizeClass();
  
  syn boolean InstClassDecl.isComponentSizeClass() = isBoolean();
  eq InstEnumClassDecl.isComponentSizeClass()      = true;
  
  inh boolean InstClassAccess.isInstComponentSize();
    inh boolean FIdUseExp.isInstComponentSize();
  inh boolean FExpSubscript.isInstComponentSize();
  inh boolean FArraySubscripts.isInstComponentSize();
  eq InstComponentDecl.getLocalFArraySubscripts().isInstComponentSize() = true;
  eq InstComponentDecl.getFArraySubscripts().isInstComponentSize()      = true;
  eq InstShortClassDecl.getFArraySubscripts().isInstComponentSize()     = true;
  eq InstAccess.getChild().isInstComponentSize()                        = false;
  eq FQNamePart.getChild().isInstComponentSize()                        = false;
  eq FIdUse.getChild().isInstComponentSize()                            = false;
  eq FExp.getChild().isInstComponentSize()                              = false;
    eq FIdUseExp.getChild().isInstComponentSize()                         = isInstComponentSize();
  eq FAbstractVariable.getChild().isInstComponentSize()                 = false;
  eq FAbstractEquation.getChild().isInstComponentSize()                 = false;
  eq InstNode.getChild().isInstComponentSize()                          = false;
  eq FlatRoot.getChild().isInstComponentSize()                          = false;
	
  syn boolean FArraySubscripts.isFullSize() {
      for (FSubscript fs : getFSubscripts())
          if (!fs.isColon())
              return false;
      return true;
  }
  
  
  public void InstComponentAccess.typeCheck(ErrorCheckType checkType) {
	//  log.debug("InstComponentAccess.typeCheck: " + printSlice());
  }
  

  public void FAssignStmt.typeCheck(ErrorCheckType checkType) {
      FType left = getLeft().type();
      FType right = getRight().type();
      if (!left.isUnknown() && !right.isUnknown()) {
          if (!left.typeCompatible(right, true)) {
              if (left.typeCompatibleExceptLengths(right)) {
                  // TODO: should use lockBranch() here as well, but no support yet
                  errorUnlessDisabled("The array sizes of right and left hand side of assignment are not compatible, " + 
                          "size of left-hand side is %s, and size of right-hand side is %s", left.size(), right.size());
              } else {
                  error("The right and left expression types of assignment are not compatible, " + 
                          "type of left-hand side is %s, and type of right-hand side is %s", left, right);
              }
          }
      }
  }

  public void FWhileStmt.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of while statement is not Boolean");
  }
  
  public void FIfClause.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if statement is not Boolean");
  }
  
  public void FWhenClause.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when statement isn't Boolean scalar or vector expression");
	  }
  }
  
  public void FIfEquation.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown() && !fBooleanScalarType().typeCompatible(getTest().type())) 
		  error("Type of test expression of if equation is not Boolean");
  }
  
  public void FWhenEquation.typeCheck(ErrorCheckType checkType) {
	  if (!getTest().type().isUnknown()) {
		  if (!getTest().type().isBoolean() || getTest().type().ndims() > 1) 
			  error("Test expression of when equation isn't Boolean scalar or vector expression");
	  }
  }


    public void FInfArgsFunctionCall.typeCheck(ErrorCheckType checkType) {
        super.typeCheck(checkType);
        if (numArgs() < minNumArgs()) 
            error("Too few arguments to " + builtInName() + "(), must have at least " + minNumArgs());
        else 
            typeCheckFExps();
    }

  public void FInfArgsFunctionCall.typeCheckFExps() {
      for (FExp exp : getFExps()) {
          if (!exp.type().isUnknown() && !typeOfArgIsOK(exp)) {
              exp.error("Argument of " + builtInName() + "() is not " + 
            		  getOKArgTypeString() + ": " + exp);
          } else if (!variabilityOfArgIsOK(exp)) {
        	  exp.error("Argument of " + builtInName() + "() does not have " + 
        			  getOKArgVariabilityString() + " variability: " + exp);
          }
      }
  }
  
  public void FCatExp.typeCheckFExps() {
	  if (!getDim().type().isUnknown() && !fIntegerScalarType().typeCompatible(getDim().type()))
		  error("Dimension argument of cat() is not compatible with Integer: " + getDim());
	  else if (!getDim().type().isUnknown() && !getDim().variability().parameterOrLess())
		  error("Dimension argument of cat() does not have constant variability: " + getDim());
  }

    public void FAbstractCat.typeCheckFExps() {}

    public void FAbstractCat.typeError(ErrorCheckType checkType) {
        errorUnlessDisabledAnd(typeErrorOnlyLengths(), "Types do not match in array concatenation");
    }

    syn int FInfArgsFunctionCall.minNumArgs() = 1;
    eq FFillExp.minNumArgs()                  = 2;
    eq FCatExp.minNumArgs()                   = 2;
    eq FAbstractCat.minNumArgs()              = 0;

    syn int FInfArgsFunctionCall.numArgs() = getNumFExp();
    eq FFillExp.numArgs()                  = getNumFExp() + 1;

  syn boolean FInfArgsFunctionCall.typeOfArgIsOK(FExp exp)        = 
		  fIntegerScalarType().typeCompatible(exp.type());
  syn boolean FInfArgsFunctionCall.variabilityOfArgIsOK(FExp exp) = 
		  exp.variability().parameterOrLess() || inFunction();
  syn String FInfArgsFunctionCall.getOKArgTypeString()            = 
		  "compatible with Integer";
  syn String FInfArgsFunctionCall.getOKArgVariabilityString()     = 
		  "constant or parameter";
   
  public void FBuiltInFunctionCall.typeCheck(ErrorCheckType checkType) {
	  if (checkTypeAsExpression())
		  super.typeCheck(checkType);
	  int n = builtInNumOutput();
	  if (myLefts().size() > n)
		  error("Too many components assigned from function call: " + builtInName() + 
				  "() has " + n + " output(s)");
	  else if (!isFunctionCallClause() && n == 0)
		  error("Function " + builtInName() + "() has no outputs, but is used in expression");
  }

    public void FSemiLinearExp.typeCheck(ErrorCheckType checkType) {
        checkVectorizedSizes(checkType);
        super.typeCheck(checkType);
    }

    public void FBuiltInFunctionCall.checkVectorizedSizes(ErrorCheckType checkType) {
        if (isArray()) {
            boolean error = false;
            boolean onlyLengths = true;
            Size s = size();
            for (FExp arg : myArgs()) {
                if (arg.isArray() && !arg.size().equivalent(s, false)) {
                    error = true;
                    if (arg.ndims() != s.ndims()) {
                        onlyLengths = false;
                        break;
                    }
                }
            }
            if (error) {
                errorUnlessDisabledAnd(onlyLengths, 
                        "Mismatching sizes in %s. All non-scalar arguments need matching sizes", builtInName());
            }
        }
    }

  public void FEnumIntegerExp.typeCheck(ErrorCheckType checkType) {
	  super.typeCheck(checkType);
	  // We can't define the function Integer in PredefinedTypes.jrag - conflict with the type Integer
	  int n = getNumOriginalArg();
	  if (n != 1)
		  error("Calling function Integer(): too " + (n > 1 ? "many" : "few") + " arguments");
  }
  
  public void InstPreExp.typeCheck(ErrorCheckType checkType) {
  	if (!getFExp().isAccess()) {
  		error("Calling function pre(): argument must be variable access");
  		return;
  	}
  }
 
  public void FAssert.typeCheck(ErrorCheckType checkType) {
	  if (hasLevel()) {
		  if (getLevel().isParameterExp())
			  getLevel().markAsStructuralParameter(checkType);
		  else if (!getLevel().isConstantExp())
			  error("Level of assert() must be constant or parameter");
	  }
  }
  
  public void FReinit.typeCheck(ErrorCheckType checkType) {
      if (!getVar().isAccess() || !getVar().type().isReal())
          error("First argument to reinit() must be an access to a Real variable");
      else if (!getVar().type().typeCompatible(getFExp().type()))
          error("Arguments to reinit() must be of compatible types");
  }

    public void FEdgeExp.typeCheck(ErrorCheckType checkType) {
        if (!getFExp().isAccess() || !getFExp().type().isBoolean()) 
            error("Calling function edge(): argument must be a boolean variable access");
    }

    public void FChangeExp.typeCheck(ErrorCheckType checkType) {
        if (!getFExp().isAccess()) 
            error("Calling function change(): argument must be a variable access");
    }

    public void FDelayExp.typeCheck(ErrorCheckType checkType) {
        if (!(hasMax() ? getMax() : getDelay()).variability().parameterOrLess())
            error("Calling function delay(): last argument supplied must be of parameter variability");
    }
    
    public void FSpatialDistExp.typeCheck(ErrorCheckType checkType) {
        super.typeCheck(checkType);
        if (!getIn0().size().equivalent(getIn1().size(), true)) {
            errorUnlessDisabledAnd(getIn0().ndims() == getIn1().ndims(), 
                    "Calling function spatialDistribution(): first and second arguments 'in0' and 'in1' needs equivalent sizes");
        }
        if (isArray()) {
            if (getX().isArray()) {
                error("Calling function spatialDistribution(): third argument 'x' cannot be vectorized");
            }
            if (getPositiveVelocity().isArray()) {
                error("Calling function spatialDistribution(): fourth argument 'positiveVelocity' cannot be vectorized");
            }
        }
    }

	public void FStringExp.typeCheck(ErrorCheckType checkType) {
		FType valueType = getValue().type();
		if (hasSignificantDigits() && !valueType.isReal())
			error("Calling function String(): named argument significantDigits can only be used when first argument is real");
		if (hasFormat() && (hasMinimumLength() || hasLeftJustified() || hasSignificantDigits()))
			error("Calling function String(): named argument format can not be used together with minimumLength, leftJustified or significantDigits");
	}

    public void FHomotopyExp.typeCheck(ErrorCheckType checkType) {
        checkVectorizedSizes(checkType);
        super.typeCheck(checkType);
    }
  
    public void InstDerExp.typeCheck(ErrorCheckType checkType) {
        FType type = getFExp().type();
        if (!(type.isReal() && (type.isScalar() || type.isArray())))
            error("Only real typed expressions are allowed in der() operator");
    }
  
  syn int FBuiltInFunctionCall.builtInNumOutput() = 1;
  eq FIgnoredBuiltIn.builtInNumOutput() = 0;
  eq FConnectionsOp.builtInNumOutput()  = 0;
  eq FConnBoolOp.builtInNumOutput()     = 1;
  eq FSpatialDistExp.builtInNumOutput() = 2;
  
  syn boolean FBuiltInFunctionCall.checkTypeAsExpression() = false;
  eq FSizeExp.checkTypeAsExpression()     = true;
  eq FMinMaxExp.checkTypeAsExpression()   = true;
  eq FIdentity.checkTypeAsExpression()    = true;
  eq FLinspace.checkTypeAsExpression()    = true;
  eq FAbstractCat.checkTypeAsExpression() = dimensionIsOk();
  
  syn boolean FAbstractCat.dimensionIsOk(); 
  eq FCatExp.dimensionIsOk()    = getDim().isConstantExp() && 
  								  getDim().type().isInteger() && getDim().type().isScalar();
  eq FMatrix.dimensionIsOk()    = true;
  eq FMatrixRow.dimensionIsOk() = true;
    public static final SimpleProblemProducer ASTNode.CANNOT_INFER_ARRAY_SIZE_OF_OUTPUT =
            new SimpleErrorProducer("CANNOT_INFER_ARRAY_SIZE_OF_OUTPUT", ProblemKind.SEMANTIC,
                    "Could not evaluate array size of output %s");

  public void InstFunctionCall.typeCheck(ErrorCheckType checkType) {
	  if (!isFunctionCallClause() && !getName().myInstClassDecl().isRecord() && !hasOutputs() && !isPartialFunctionCall())
		  error("Function " + getName().name() + "() has no outputs, but is used in expression");
	  else if (!isFunctionCallClause() && !inFunction() && size().isUnknown())
	      CANNOT_INFER_ARRAY_SIZE_OF_OUTPUT.invoke(this, expOutput().name());
        if (myCallOutputs().size() < myLefts().size())
		  error("Too many components assigned from function call: " + getName().name() + 
                "() has " + myCallOutputs().size() + " output(s)");
  }
  
  syn boolean InstFunctionCall.isPartialFunctionCall() = false;
  eq InstPartialFunctionCall.isPartialFunctionCall()   = true;

    public void FFunctionCallLeft.typeCheck(ErrorCheckType checkType) {
        if (hasFExp() && !myOutput().isUnknown() && !type().isUnknown()) { // Avoid duplicate error
            if (getFExp() instanceof FIdUseExp) {  // Should never be false - add check? 
                FIdUse use = getFExp().asFIdUse();
                FType useType = use.type();
                FType outType = type();
                if (use.isForIndex()) {
                    error("Can not assign a value to a for loop index");
                } else if (outType.size().isUnknown() && !inFunction()) {
                    error(functionCallDecription() + ": could not evaluate array size of output " + 
                            myOutput().name());
                } else if (!useType.typeCompatible(outType, true)) {
                    if (useType.typeCompatibleExceptLengths(outType)) {
                        if (!lockBranch(checkType))
                            errorUnlessDisabled("%s: component %s is of size %s and output %s is of size %s - they are not compatible", 
                                    functionCallDecription(), use.name(), useType.size(), myOutput().name(), outType.size());
                    } else {
                        error("%s: component %s is of type %s and output %s is of type %s - they are not compatible", 
                                functionCallDecription(), use.name(), useType, myOutput().name(), outType);
                    }
                }
            }
        }
    }

  inh String InstFunctionArgument.functionCallDecription();
  inh String FFunctionCallLeft.functionCallDecription();
  eq FAbstractFunctionCall.getChild().functionCallDecription() = functionCallDecription();
  eq FFunctionCallEquation.getChild().functionCallDecription() = getCall().functionCallDecription();
  eq FFunctionCallStmt.getChild().functionCallDecription()     = getCall().functionCallDecription();

    public void InstFunctionArgument.typeCheck(ErrorCheckType checkType) {
        boolean typeOk = true;
        FType type = getFExp().type();
        if (!type.isUnknown()) {
            if (argumentDefinedTypeValid()) {
                FType boundType = getBoundInput().type();
                if (!boundType.isUnknown()) {
                    if (isVectorized()) 
                        boundType = boundType.sizedType(boundType.size().expand(vectorizedSize()));
                    else if (isDestructorArgument())
                        boundType = boundType.sizedType(type.size());
                    typeOk = boundType.typeCompatible(type, true);
                }
            } else {
                typeOk = argumentTypeValid(type);
            }
        }
        if (!typeOk) {
            if (getBoundInput() == null) {
                error(nonBoundArgumentTypeError());
            } else {
                String msg = argumentTypeError();
                if (msg != null)
                    error(msg);
                else
                    error("%s: types of %s and input %s are not compatible\n" + 
                          "    type of '%s' is %s\n" + 
                          "    expected type is %s", 
                          functionCallDecription(), argumentDesc(), getBoundInput().name(), 
                          getFExp(), getFExp().type(),
                          argumentDefinedTypeValid() ? getBoundInput().type().toString() : expectedArgumentType());
            }
        }
    }

  public void InstMissingArgument.typeCheck(ErrorCheckType checkType) {
	  if (!isDestructorArgument())
		  error(functionCallDecription() + ": missing argument for required input " + getBoundInput().name());
  }
  
  public void InstMultipleBoundArgument.typeCheck(ErrorCheckType checkType) {
	  error(functionCallDecription() + ": multiple arguments matches input " + getBoundInput().name());
  }
  
  inh boolean InstFunctionArgument.isDestructorArgument();
  eq InstFunctionCall.getArg().isDestructorArgument() = isDestructorCall();
  eq BaseNode.getChild().isDestructorArgument()       = false;
  
  inh boolean InstClassDecl.inExternalObject();
  eq InstNode.getChild().inExternalObject() = isExternalObject();
  
  public void InstDefaultArgument.typeCheck(ErrorCheckType checkType) {}
  
    inh String InstFunctionArgument.nonBoundArgumentTypeError();
    eq FExp.getChild().nonBoundArgumentTypeError() {
        throw new UnsupportedOperationException("Method nonBoundArgumentTypeError() not implemented for type " + getClass().getSimpleName());
    }
    eq FArrayDimAsArgsExp.getOriginalArg(int i).nonBoundArgumentTypeError() = 
        functionCallDecription() + ": type of positional argument " + i + " is not compatible with Integer";
  
  inh String InstFunctionArgument.argumentTypeError();
  eq FExp.getChild().argumentTypeError()         = null;
  eq FCardinality.getChild().argumentTypeError() = "The argument of cardinality() must be a scalar reference to a connector";
  
  protected String InstFunctionArgument.argumentDesc() { return null; }
  
  protected String InstPositionalArgument.argumentDesc() {
	  return "positional argument " + (getPos() + 1);
  }
  
  protected String InstNamedArgument.argumentDesc() {
	  return "named argument " + getName().prettyPrint("");
  }
  
  public void InstAccess.typeCheck(ErrorCheckType checkType) {
//	  if (getTopInstAccess() == this && !type().isUnknown()) {
		  // TODO: if this is a slice, check that all branches are of equal size
//	  }
  }
  
  public void InstDot.typeCheck(ErrorCheckType checkType) {
	  // Check for accesses to non-constant component in class
	  int n = getNumInstAccess();
	  for (int i = 0; i < n - 1; i++)
		  getInstAccess(i).checkAccessCompInClassLeft(getInstAccess(i + 1), checkType);
	  super.typeCheck(checkType);
  }
  
  public void InstAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {}
  
  public void InstClassAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {
	  right.checkAccessCompInClassRight(myInstClassDecl(), checkType);
  }
  
  public void InstComponentAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {
	  if (myInstComponentDecl().isPrimitive()) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access attribute of primitive with dot notation: " + top.name());
	  }
  }
  
  public void InstComponentArrayAccess.checkAccessCompInClassLeft(InstAccess right, ErrorCheckType checkType) {
	  if (myInstComponentDecl().isPrimitive()) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access attribute of primitive with dot notation: " + top.name());
	  }
  }
  
  public void InstAccess.checkAccessCompInClassRight(InstClassDecl icd, ErrorCheckType checkType) {}
  
  public void InstComponentAccess.checkAccessCompInClassRight(InstClassDecl icd, ErrorCheckType checkType) {
	  String type = null;
	  if (icd.extendsEnum()) {
		  if (!myInstComponentDecl().isEnumLiteral())
			  type = "attribute of primitive with dot notation";
	  } else if (icd.isPackage()) {
		  icd.checkRestriction(checkType);
	  } else if (!icd.isOkPackage()) {
		  type = "component in non-package class";
	  }
	  if (type != null) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access " + type + ": " + top.name());
	  }
  }
  
  public void InstComponentArrayAccess.checkAccessCompInClassRight(InstClassDecl icd, ErrorCheckType checkType) {
	  String type = null;
	  if (icd.extendsEnum()) {
		  if (!myInstComponentDecl().isEnumLiteral())
			  type = "attribute of primitive with dot notation";
	  } else if (icd.isPackage()) {
		  icd.checkRestriction(checkType);
	  } else if (!icd.isOkPackage()) {
		  type = "component in non-package class";
	  }
	  if (type != null) {
		  InstAccess top = getTopInstAccess();
		  top.error("Can not access " + type + ": " + top.name());
	  }
  }

    /**
     * Check if the type defined for this argument in the built-in function list 
     * is valid.
     */
    inh boolean InstFunctionArgument.argumentDefinedTypeValid();
    eq FAbstractFunctionCall.getChild().argumentDefinedTypeValid()           = true;
    eq FTranspose.getOriginalArg().argumentDefinedTypeValid()                = false;
    eq FSymmetric.getOriginalArg().argumentDefinedTypeValid()                = false;
    eq FMinMaxExp.getOriginalArg().argumentDefinedTypeValid()                = false;
    eq FReductionExp.getOriginalArg().argumentDefinedTypeValid()             = false;
    eq FHomotopyExp.getOriginalArg().argumentDefinedTypeValid()              = false;
    eq FSemiLinearExp.getOriginalArg().argumentDefinedTypeValid()            = false;
    eq FNdimsExp.getOriginalArg().argumentDefinedTypeValid()                 = false;
    eq FInfArgsFunctionCall.getOriginalArg().argumentDefinedTypeValid()      = false;
    eq FEnumIntegerExp.getOriginalArg().argumentDefinedTypeValid()           = false;
    eq FVectUnaryBuiltIn.getOriginalArg().argumentDefinedTypeValid()         = false;
    eq FDimensionConvert.getOriginalArg().argumentDefinedTypeValid()         = false;
    eq FEventGenExp.getOriginalArg().argumentDefinedTypeValid()              = false;
    eq FCardinality.getOriginalArg().argumentDefinedTypeValid()              = false;
    eq FMathematicalFunctionCall.getOriginalArg().argumentDefinedTypeValid() = false;
    eq FConnectionsOp.getOriginalArg().argumentDefinedTypeValid()            = false;
    eq FStringExp.getOriginalArg(int i).argumentDefinedTypeValid()           = i > 0;
    eq FConnPotentialRoot.getOriginalArg(int i).argumentDefinedTypeValid()   = i == 1;
    eq FSizeExp.getOriginalArg(int i).argumentDefinedTypeValid()             = i != 0;
    eq FSmoothExp.getOriginalArg(int i).argumentDefinedTypeValid()           = i == 0;
    eq InstPreExp.getOriginalArg().argumentDefinedTypeValid()                = false;
    eq FEdgeExp.getOriginalArg().argumentDefinedTypeValid()                  = false;
    eq FChangeExp.getOriginalArg().argumentDefinedTypeValid()                = false;
    eq FReinit.getOriginalArg().argumentDefinedTypeValid()                   = false;

    /**
     * Check if the type supplied is valid for this argument.
     * 
     * Only used if argumentDefinedTypeValid() returns <code>false</code>.
     */
    inh boolean InstFunctionArgument.argumentTypeValid(FType type);
    eq FAbstractFunctionCall.getChild().argumentTypeValid(FType type)     = type.isPrimitive();
    eq FTranspose.getChild().argumentTypeValid(FType type)                = type.ndims() >= 2 && type.isPrimitive();
    eq FSymmetric.getChild().argumentTypeValid(FType type)                = 
        type.ndims() == 2 && type.size().get(0) == type.size().get(1);
    eq FReductionExp.getChild().argumentTypeValid(FType type)             = type.ndims() > 0 && type.hasAdd();
    eq FSemiLinearExp.getChild().argumentTypeValid(FType type)            = type.isNumeric();
    eq FAbsExp.getChild().argumentTypeValid(FType type)                   = type.isNumeric();
    eq FSignExp.getChild().argumentTypeValid(FType type)                  = type.isNumeric();
    eq FEnumIntegerExp.getChild().argumentTypeValid(FType type)           = type.isEnum();
    eq FEventGenExp.getChild().argumentTypeValid(FType type)              = type.isNumeric();
    eq FMathematicalFunctionCall.getChild().argumentTypeValid(FType type) = type.isNumeric();
    eq FMinMaxExp.getOriginalArg(int i).argumentTypeValid(FType type)     = 
        hasY() != getOriginalArg(i).getFExp().isArray() && type.isPrimitive();
    eq FSmoothExp.getChild().argumentTypeValid(FType type)                = type.onlyContainsReal();
    eq FDimensionConvert.getChild().argumentTypeValid(FType type)         = argumentSizeValid(type.size());
    eq FCardinality.getChild().argumentTypeValid(FType type)              = 
        type.isScalar() && getFExp().isComponentReference(ALLOWED_COMPONENTS);
    eq FConnectionsOp.getOriginalArg(int i).argumentTypeValid(FType type) = 
        getOriginalArg(i).getFExp().isComponentReference(ALLOWED_COMPONENTS);
    eq FStringExp.getChild().argumentTypeValid(FType type)                = 
        type.isScalar() && (type.isReal() || type.isInteger() || type.isBoolean() || type.isEnum());
    eq FInfArgsFunctionCall.getChild().argumentTypeValid(FType type)      = true;  // Type checked in FInfArgsFunctionCall.typeCheck()
    eq FReinit.getChild().argumentTypeValid(FType type)                   = true;  // Type checked in Reinit.typeCheck()
    eq FHomotopyExp.getChild().argumentTypeValid(FType type)              = type.isNumeric();
    // All types allowed for these:
    eq FNoEventExp.getChild().argumentTypeValid(FType type)               = true;
    eq FSizeExp.getChild().argumentTypeValid(FType type)                  = true;

    /**
     * Description of expexted type of argument.
     * 
     * Should be defined for cases where argumentDefinedTypeValid() returns and 
     * argumentTypeValid() both return false.
     */
    inh String InstFunctionArgument.expectedArgumentType();
    eq FAbstractFunctionCall.getChild().expectedArgumentType()     = 
        "Real, Integer, Boolean, String or enumeration";
    eq FTranspose.getChild().expectedArgumentType()                = 
        "matrix of Real, Integer, Boolean, String or enumeration";
    eq FSymmetric.getChild().expectedArgumentType()                = "square matrix";
    eq FReductionExp.getChild().expectedArgumentType()             = "Real array";
    eq FEnumIntegerExp.getChild().expectedArgumentType()           = "enumeration";
    eq FSemiLinearExp.getChild().expectedArgumentType()            = "Real";
    eq FAbsExp.getChild().expectedArgumentType()                   = "Real";
    eq FSignExp.getChild().expectedArgumentType()                  = "Real";
    eq FEventGenExp.getChild().expectedArgumentType()              = "Real";
    eq FMathematicalFunctionCall.getChild().expectedArgumentType() = "Real";
    eq FSmoothExp.getChild().expectedArgumentType()                = "Real";
    eq FHomotopyExp.getChild().expectedArgumentType()              = "Real";
    eq FMinMaxExp.getOriginalArg(int i).expectedArgumentType()     = 
        (hasY() ? "scalar" : "array of") + " Real, Integer, Boolean, String or enumeration";
    eq FScalarExp.getChild().expectedArgumentType()                = "array with exactly 1 element";
    eq FVectorExp.getChild().expectedArgumentType()                = "scalar or vector-shaped array";
    eq FMatrixExp.getChild().expectedArgumentType()                = "scalar, vector or matrix-shaped array";
    eq FCardinality.getChild().expectedArgumentType()              = "scalar connector";
    eq FConnectionsOp.getChild().expectedArgumentType()            = "connector";
    eq FStringExp.getChild().expectedArgumentType()                = "scalar Real, Integer, Boolean or enumeration";

  protected static final Criteria<InstComponentDecl> FCardinality.ALLOWED_COMPONENTS = new Criteria<InstComponentDecl>() {
      public boolean test(InstComponentDecl elem) { return elem.isConnector() || elem.isPrimitive(); }
  };

  protected static final Criteria<InstComponentDecl> FConnectionsOp.ALLOWED_COMPONENTS = new Criteria<InstComponentDecl>() {
      public boolean test(InstComponentDecl elem) { return elem.isOverconstrainedType(); }
  };

  /**
   * Check if this expression is a reference to a component matching specified criteria.
   * 
   * Only valid in instance tree.
   */
  syn boolean FExp.isComponentReference(Criteria<InstComponentDecl> criteria)  = false;
    eq FIdUseExp.isComponentReference(Criteria<InstComponentDecl> criteria) = getFIdUse().isComponentReference(criteria);
    
    syn boolean FIdUse.isComponentReference(Criteria<InstComponentDecl> criteria) = false;
    eq FIdUseInstAccess.isComponentReference(Criteria<InstComponentDecl> criteria) = 
            criteria.test(getInstAccess().myInstComponentDecl());

  /**
   * Check if the given Size is valid for the argument of the operator.
   */
  syn boolean FDimensionConvert.argumentSizeValid(Size s) {
      if (s.isUnknown())
          return true;
      
	  boolean[] useDim = new boolean[s.ndims()];
	  for (int d : dimensionsToKeep())
		  if (d < useDim.length)
			  useDim[d] = true;
	  for (int i = 0; i < s.ndims(); i++)
		  if (!useDim[i] && s.get(i) != 1)
			  return false;
	  return true;
  }

    protected static void ASTNode.typeCheckEnabled(ErrorCheckType checkType, FExp enabledExp, FType parentType, boolean eachSet) {
        enabledExp.collectErrors(checkType);
        if (!enabledExp.type().isBoolean() && !enabledExp.type().isUnknown()) {
            enabledExp.error("The type of the enabled expression is not boolean");
        } else if (!eachSet && !parentType.dimensionCompatible(enabledExp.type())) { 
            if (enabledExp.ndims() == 0) {
                enabledExp.warning("Assuming 'each' for enabled expression");
            } else {
                enabledExp.errorUnlessDisabledAnd(parentType.ndims() == enabledExp.ndims(), 
                        "Array size mismatch for the enabled attribute, " + 
                        "size of component declaration is %s and size of expression is %s", 
                        parentType.size(), enabledExp.size());
            }
        } else if (eachSet) { 
            if (parentType.ndims() == 0) {
                enabledExp.warning("The 'each' keyword should not be applied to attributes of scalar components");
            } else if (enabledExp.ndims() > 0) {
                enabledExp.error("The enabled attribute is declared 'each' and the expression is not scalar");
            }
        }
    }

}

aspect VariabilityCheck {
    
    private FExp FPreExp.instanceTreeSource = null;
    private FExp FReinit.instanceTreeSource = null;
    
    public void FExp.setInstanceTreeSource(FExp source) {}
    
    public void FPreExp.setInstanceTreeSource(FExp source) {
        instanceTreeSource = source;
    }
    
    public void FReinit.setInstanceTreeSource(FExp source) {
        instanceTreeSource = source;
    }
    
    /**
     * Surrounds the FExp <code>exp</code> with pre if it is an non literal exp, else return exp.
     * 
     * Also sets the <code>instanceTreeSource</code> field of the FPreExp (if any) 
     * to <code>source</code>.
     */
    public static FExp FPreExp.create(FExp exp, FExp source) {
        exp = create(exp);
        exp.setInstanceTreeSource(source);
        return exp;
    }
    
    /**
     * Check operations that are allowed on discrete expressions or variables, 
     * but not on continuous ones or vice-versa.
     * 
     * Also breaks connections back to instance tree that was added during flattening 
     * to be able to report these errors in the correct place.
     */
    public void ASTNode.checkDiscreteOperations() {
        for (ASTNode n : this)
            n.checkDiscreteOperations();
    }
    
    public void FPreExp.checkDiscreteOperations() {
        if (instanceTreeSource != null && getFIdUse().myFV().isContinuous() && !inWhen() && !inInitialEquationSection()) 
            instanceTreeSource.discreteArgError();
        instanceTreeSource = null;
    }
    
    public void FReinit.checkDiscreteOperations() {
        if (instanceTreeSource != null && !myFV().isContinuous()) 
            instanceTreeSource.discreteArgError();
        instanceTreeSource = null;
    }
    
    /**
     * Generate error for operator that got wrong variability of argument
     */
    public void FExp.discreteArgError() {
        throw new UnsupportedOperationException();
    }
    
    public void InstPreExp.discreteArgError() {
        error("Calling built-in operator pre() with a continuous variable access as argument can only be done in when clauses and initial equations");
    }
    
    public void FChangeExp.discreteArgError() {
        error("Calling built-in operator change() with a continuous variable access as argument can only be done in when clauses and initial equations");
    }
    
    public void FReinit.discreteArgError() {
        error("Built-in operator reinit() must have a continuous variable access as its first argument");
    }
    
}