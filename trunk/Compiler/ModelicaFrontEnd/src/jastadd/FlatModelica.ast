/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

FlatRoot : Root ::= FClass;
FClass ::= FQName 
           FVariable* 
           FInitialEquation:FAbstractEquation*
           FEquationBlock*
           /UnknownFVariable/; 

FEquationBlock ::= FAbstractEquation*;

abstract AbstractFVariable;
UnknownFVariable : AbstractFVariable;

abstract FVariable : AbstractFVariable ::= FTypePrefixOther
              [FTypePrefixInputOutput]
              FAttribute*
              [BindingExp:FExp]
              [FStringComment]
              FQName;

FRealVariable : FVariable;
FIntegerVariable : FVariable;
FBooleanVariable : FVariable;
FStringVariable : FVariable;

abstract FPrimitiveType;
FRealType : FPrimitiveType ::=;
FIntegerType : FPrimitiveType ::=; 
FStringType : FPrimitiveType ::=;
FBooleanType : FPrimitiveType ::=;

FQName ::= FQNamePart*;
FQNamePart ::= <Name:String> [FArraySubscripts];

FAttribute ::= Type:FIdUse
               Name:FIdDecl 			   
               [Value:FExp]
               <AttributeSet:boolean>
               [FEach]
               [FFinal]
               FAttribute*;

FEach ::=;
FFinal ::=;

abstract FTypePrefix;
//abstract FTypePrefixFlow : FTypePrefix;
//FFlow : FTypePrefixFlow::=;
abstract FTypePrefixOther : FTypePrefix;
// Continuous is not a valid prefix.  We will use it to identify 
// expressions that are not parameters, constants, or discrete.
FContinuous : FTypePrefixOther::=;
FDiscrete : FTypePrefixOther::=;
FParameter : FTypePrefixOther::=;
FConstant : FTypePrefixOther::=;
abstract FTypePrefixInputOutput : FTypePrefix;
FInput : FTypePrefixInputOutput::=;
FOutput : FTypePrefixInputOutput::=;

FStringComment ::= <Comment:String>;

FArraySubscripts ::= FSubscript*;
abstract FSubscript;
FColonSubscript : FSubscript::=;
FExpSubscript : FSubscript ::= FExp;

abstract FExp;
FUnsupportedExp : FExp;
abstract FAbstractEquation;
FUnsupportedEquation : FAbstractEquation;
FEquation : FAbstractEquation ::= Left:FExp Right:FExp;
FInitialEquation : FEquation;
FConnectClause : FAbstractEquation ::= [FStringComment] Connector1:FIdUseInstAccess Connector2:FIdUseInstAccess;

abstract FBinExp : FExp ::= Left:FExp Right:FExp;
abstract FUnaryExp : FExp ::= FExp;

abstract FArtmBinExp : FBinExp;
FAddExp : FArtmBinExp::=;
FSubExp : FArtmBinExp::=;
FMulExp : FArtmBinExp::=;
FMulExpMM : FMulExp::=;
FMulExpVM : FMulExp::=;
FMulExpMV : FMulExp::=;
FMulExpVV : FMulExp::=;
FDivExp : FArtmBinExp::=;
FPowExp : FArtmBinExp::=;
FNegExp : FUnaryExp ::=;

abstract FLogBinExp : FBinExp;
FLtExp : FLogBinExp;
FLeqExp : FLogBinExp;
FGtExp : FLogBinExp;
FGeqExp : FLogBinExp;
FEqExp : FLogBinExp;
FNeqExp : FLogBinExp;
FNotExp : FUnaryExp ::=;
FOrExp : FLogBinExp;
FAndExp : FLogBinExp;

FRealLitExp : FExp ::= <UNSIGNED_NUMBER>;

FFunctionCall : FExp ::= Name:FIdUse Args:FExp*;

FSumRedExp : FExp ::= FExp FForIndex;
FForIndex ::= FIdDecl [FExp];

FDer : FExp ::= FIdUseExp;

FScalar : FUnaryExp ::=;
FTranspose : FUnaryExp ::=;
FIdentity : FFunctionCall;
FOnes : FFunctionCall;
FZeros : FFunctionCall;

FSumExp : FUnaryExp ::=;

FForClauseE : FAbstractEquation ::= FForIndex* ForEqns:FAbstractEquation*;

FIfExp : FExp ::= IfExp:FExp ThenExp:FExp FElseIfExp* ElseExp:FExp;
FElseIfExp : FExp ::= IfExp:FExp ThenExp:FExp;

FIdUseExp : FExp ::= FIdUse;

FInstAccessExp : FExp ::= InstAccess;

FIdDecl ::= FQName;
FIdUse ::= <ID>;

FIdUseInstAccess : FIdUse ::= InstAccess;

FTypeAccess : FIdUse; // New type access

FIdUseQualified : FIdUse ::= FQName;
// The flat model does not contain qualified names, but is modeled
// as such in order to keep track of name parts and array indices, 
// which in turn enables different output on different formats.
//FDot : FIdUse ::= Left:FIdUse Right:FIdUse; 
FStringLitExp : FExp ::= <String>;
//FBooleanLitExp : FExp ::= <Val:boolean>;
abstract FBooleanLitExp : FExp ::=;
FBooleanLitExpTrue : FBooleanLitExp;
FBooleanLitExpFalse : FBooleanLitExp;

FArrayConstructor : FExp ::= FExp*;
FMatrix : FExp ::= FExpList*;
FExpList : FExp ::= FExp*;

FRangeExp : FExp ::= FExp*;

FNoExp : FExp::=;

FTimeExp : FExp;

// Built in functions
FSizeExp : FExp ::= FIdUseExp Dim:FExp;
