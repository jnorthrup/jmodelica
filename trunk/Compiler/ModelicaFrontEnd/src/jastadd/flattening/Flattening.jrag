/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.HashMap;
import java.util.Map;
import java.util.Arrays;
import java.util.Collections;
import java.util.Set;
import java.util.HashSet;
import java.util.Stack;

aspect FlatTree {

    /**
     * Create a correctly set up FClass.
     * 
     * Also creates a FlatRoot and sets its fields.
     * 
     * @param icl   the class being flattened
     * @param file  the path to the file to report errors on
     */
    public static FClass FClass.create(InstClassDecl icl, String flatName) {
        FlatRoot flatRoot = new FlatRoot(icl.createFClass());
        //flatRoot.setFileName(file);
        FClass fc = flatRoot.getFClass(); // make FClass final
        fc.userDefinedName = flatName;
        fc.root().transferRoot(icl.root());
        fc.setDynamicStateManager(new DynamicStateManager());
        return fc;
    }

    /**
     * Set the name of the FClass.
     * 
     * If a user-defined name has been set, use it, otherwise use the given name.
     */
    public void FClass.setName(String name) {
        if (userDefinedName != null) 
            name = userDefinedName;
        setFQName(new FQNameString(name));
    }

    /**
     * User-defined name for the flat class.
     */
    private String FClass.userDefinedName = null;

    /**
     * Create a new FClass object.
     * 
     * Override for subclasses needing a subclass of FClass.
     */
    public FClass InstClassDecl.createFClass() {
        return new FClass();
    }

}

aspect Flattening {

    /**
     * Generic traversal method used to find a particular class instance
     * in the instance tree, and if so, flatten it.
     */
    public InstNode InstProgramRoot.findFlattenInst(String className,FClass fc) throws ModelicaClassNotFoundException {
        
        InstLookupResult<InstClassDecl> icd = lookupInstClassQualified(className);
        if (icd.successful()) {
            icd.target().flattenInstClassDecl(fc);
        } else {
            throw new ModelicaClassNotFoundException(className);
        }
        
        return icd.target();
    }

    public void InstClassDecl.flattenInstClassDecl(FClass fc) {
        int level = 1;
        HashMap<InstNode,Integer> oldLevels = setModificationLevel(level);
        beginStep("flattenInstClassDecl()");
        fc.setName(qualifiedName());
        buildConnectionSets(fc);
        breakOnErrors();
        beginStep("flattenComponents()");
        flatten(fc, FlattenBindingExp.ALL, level);
        getInstGeneratedInners().flatten(fc, FlattenBindingExp.ALL, level);
        flattenUsedFuncsAndEnums(fc);
        flattenInstClassDeclExtra(fc);
        endStep("flattenComponents()");
        fc.updateVariabilityForVariablesInWhen();
        fc.genConnectionEquations();
        fc.createExperiment(annotation("experiment"));
        breakOnErrors();
        endStep("flattenInstClassDecl()");
        fc.transformationStepDebug();
        clearModificationLevel(oldLevels);
    }


    public void InstSimpleShortClassDecl.flattenInstClassDecl(FClass fc) {
        actualInstClass().flattenInstClassDecl(fc);
        fc.setFQName(new FQNameString(qualifiedName()));
    }

    public void InstLibNode.flattenInstClassDecl(FClass fc) {
        actualInstClass().flattenInstClassDecl(fc);
    }

    /**
     * Delegate for adding extra flattening code to top-level model.
     */
    
    class InstClassDecl {
        private static final ArrayList<ExtraFlattener> extraFlatteners = new ArrayList<ExtraFlattener>();
        
        public static ExtraFlattener addExtraFlattener(ExtraFlattener ef) {
            extraFlatteners.add(ef);
            return ef;
        }
        
        public static abstract class ExtraFlattener {
            public abstract void flattenExtra(InstClassDecl icd, FClass fc);
        }
    }
    
    protected void InstClassDecl.flattenInstClassDeclExtra(FClass fc) {
        for (ExtraFlattener ef : extraFlatteners) {
            ef.flattenExtra(this, fc);
        }
    }

    /**
     * Find functions, record and enumeration declarations that need to be flattened.
     */
    public void ASTNode.flattenUsedFuncsAndEnums(FClass fc) {
        for (ASTNode n : this) 
            n.flattenUsedFuncsAndEnums(fc);
    }

    public void InstNode.flattenUsedFuncsAndEnums(FClass fc) {
        getInstComponentDeclList().flattenUsedFuncsAndEnums(fc);
        getFAbstractEquationList().flattenUsedFuncsAndEnums(fc);
        getInstExtendsList().flattenUsedFuncsAndEnums(fc);
        for (InstModification im : totalMergedEnvironment()) 
            im.flattenUsedFuncsAndEnums(fc);
        super.flattenUsedFuncsAndEnums(fc);
    }

    public void InstComponentDecl.flattenUsedFuncsAndEnums(FClass fc) {
        if (useInFlattening()) {
            super.flattenUsedFuncsAndEnums(fc);
            if (isOperatorRecord() && isFlow())
                type().matchOverloadedZero().flattenFunction(fc);
        }
    }

    @Override
    public void InstClassDecl.flattenUsedFuncsAndEnums(FClass fc) {
        super.flattenUsedFuncsAndEnums(fc);
        getInstGeneratedInners().flattenUsedFuncsAndEnums(fc);
    }

    public void InstSimpleShortClassDecl.flattenUsedFuncsAndEnums(FClass fc) {
        actualInstClass().flattenUsedFuncsAndEnums(fc);
    }

    public void InstLibNode.flattenUsedFuncsAndEnums(FClass fc) {
        actualInstClass().flattenUsedFuncsAndEnums(fc);
    }

    public void FConnectClause.flattenUsedFuncsAndEnums(FClass fc) {
        super.flattenUsedFuncsAndEnums(fc);
        getConnector1().getInstAccess().myInstComponentDecl().flattenOverloadedOperatorsForFlow(fc);
        getConnector2().getInstAccess().myInstComponentDecl().flattenOverloadedOperatorsForFlow(fc);
    }
    
    public void InstNode.flattenOverloadedOperatorsForFlow(FClass fc) {
        for (InstComponentDecl icd : getInstComponentDecls())
            icd.flattenOverloadedOperatorsForFlow(fc);
        for (InstExtends ie : getInstExtendss())
            ie.flattenOverloadedOperatorsForFlow(fc);
    }

    public void InstComponentDecl.flattenOverloadedOperatorsForFlow(FClass fc) {
        if (useInFlattening()) {
            if (isOperatorRecord() && isFlow())
                type().flattenOverloadedOperatorsForFlow(fc);
            else
                super.flattenOverloadedOperatorsForFlow(fc);
        }
    }

    public void FType.flattenOverloadedOperatorsForFlow(FClass fc) {}

    public void FOperatorRecordType.flattenOverloadedOperatorsForFlow(FClass fc) {
        matchOverloadedOperator(null, FExp.OP_NEG).flattenFunction(fc);
        matchOverloadedOperator(this, FExp.OP_SUB).flattenFunction(fc);
        matchOverloadedOperator(this, FExp.OP_ADD).flattenFunction(fc);
    }

    public void InstValueModification.flattenUsedFuncsAndEnums(FClass fc) {
        if (isFlattened(this)) {
            getFExp().flattenUsedFuncsAndEnums(fc);
        }
    }
    
    inh boolean InstValueModification.isFlattened(InstValueModification ivm);
    eq InstModification.getChild().isFlattened(InstValueModification ivm)      = true;
    eq InstAssignable.getChild().isFlattened(InstValueModification ivm)        = !inRecordDecl() && myInstValueMod() == ivm;
    eq InstForIndex.getChild().isFlattened(InstValueModification ivm)          = true;
    eq InstRecordConstructor.getChild().isFlattened(InstValueModification ivm) = true;
    eq Root.getChild().isFlattened(InstValueModification ivm)                  = true;


    public void InstFunctionCall.flattenUsedFuncsAndEnums(FClass fc) {
        InstCallable target = myInstCallable();
        target.flattenFunction(fc);
        getArgs().flattenUsedFuncsAndEnums(fc);
    }
    
    public void FBuiltInFunctionCall.flattenUsedFuncsAndEnums(FClass fc) {
        for (ASTNode n : this) {
            if (n != getOriginalArgs()) {
                n.flattenUsedFuncsAndEnums(fc);
            }
        }
    }
    
    public void InstExternalObject.flattenUsedFuncsAndEnums(FClass fc) {
        myDestructor().flattenFunction(fc);
        super.flattenUsedFuncsAndEnums(fc);
    }
    
    public void InstRecordConstructor.flattenUsedFuncsAndEnums(FClass fc) {
        getRecord().flattenMyRecord(fc);
        getArgs().flattenUsedFuncsAndEnums(fc);
    }
    
    public void InstDefaultArgument.flattenUsedFuncsAndEnums(FClass fc) {
        getFExp().flattenUsedFuncsAndEnums(fc);
    }

    public void FIdUseInstAccess.flattenUsedFuncsAndEnums(FClass fc) {
        super.flattenUsedFuncsAndEnums(fc);
        InstAccess ia = getInstAccess();
        if (ia.myInstComponentDecl().isRecord() && ia.myInstComponentDecl().isConstant() && !ia.hasUnknownIndices()) 
            ((InstAssignable) ia.myInstComponentDecl()).flattenMyType(fc);
    }

    public void FExp.flattenUsedFuncsAndEnums(FClass fc) {
        super.flattenUsedFuncsAndEnums(fc);
        InstClassDecl oper = overloadedOperator(true);
        boolean scalar = oper == null;
        if (scalar)
            oper = overloadedOperator(false);
        if (oper != null) {
            oper.flattenFunction(fc);
            int i = 0;
            for (FExp arg : childFExps()) {
                FType inType = oper.myInputs().get(i).type();
                FType argType = arg.type();
                if (scalar) 
                    argType = argType.scalarType();
                if (!inType.typeCompatible(argType, true))
                    inType.matchOverloadedConstructor(argType).flattenFunction(fc);
                i++;
            }
        }
    }

    public void InstClassAccess.flattenUsedFuncsAndEnums(FClass fc) {
        if (myInstClassDecl().extendsEnum())
            myInstClassDecl().flattenEnum(fc);
    }

    public void FReinit.flattenUsedFuncsAndEnums(FClass fc) {
        containingInstNode().flattenStateSelect(fc);
        getFExp().flattenUsedFuncsAndEnums(fc);
    }

    public void InstNode.flattenStateSelect(FClass fc) {
        lookupInstClass("StateSelect").target().flattenEnum(fc);
    }

    public void InstAccess.flattenMyRecord(FClass fc) {
        myInstClassDecl().flattenRecord(fc);
    }
    
    // Flatten function if not already done
    public void InstPartialFunction.flattenFunction(FClass fc) {
        myInstClass().flattenFunction(fc);
    }
    
    public void InstClassDecl.flattenFunction(FClass fc) {}
    
    public void InstBaseClassDecl.flattenFunction(FClass fc) {
        getInstRestriction().flattenFunction(fc, this);
    }
    
    public void InstSimpleShortClassDecl.flattenFunction(FClass fc) {
        actualInstClass().flattenFunction(fc);
    }
    
    public void InstLibNode.flattenFunction(FClass fc) {
        actualInstClass().flattenFunction(fc);
    }
    
    public void InstRestriction.flattenFunction(FClass fc, InstBaseClassDecl icd) {}
    
    public void InstFunction.flattenFunction(FClass fc, InstBaseClassDecl icd) {
        icd.flattenThisFunction(fc);
    }

    public void InstBaseClassDecl.flattenThisFunction(FClass fc) {
        if (fc.lookupFunc(qualifiedName()) == null) {
            FFunctionDecl ffd = createFFunction(fc, findFunctionExternal());
            copyDerivativeAnnotations(fc, ffd.annotation());
            ffd.copyInlineAnnotation(findInlineAnnotationRoot());
            ffd.smoothOrder(smoothOrder());
            
            addLocalFunctionConstants(ffd, fc);
            flattenUsedFuncsAndEnums(fc);
            ffd.updateRecordArraySizes();
            
            contribute(ffd);
        }
    }

    private FFunctionDecl InstBaseClassDecl.createFFunctionDecl() {
        FFunctionDecl res;
        if (isConstructor()) {
            res = new FConstructorDecl();
        } else if (isDestructor()) {
            res = new FDestructorDecl();
        } else {
            res = new FFunctionDecl();
        }
        
        res.setFAlgorithm(new FAlgorithm(new List<FStatement>()));
        return res;
    }
    
    protected FFunctionDecl InstBaseClassDecl.createFFunction(FClass fc, InstExternal ie) {
        FFunctionDecl ffd = createFFunctionDecl();
        ffd.setFQName(new FQNameString(qualifiedName()));
        fc.addFFunctionDecl(ffd);
        
        List<FFunctionVariable> vars = new List<FFunctionVariable>();
        List<FStatement> stmts = new List<FStatement>();
        
        
        flattenComponentsInFunction(vars, stmts, fc, new HashSet<String>(), FUNC_AND_REC_MOD_LEVEL);
        
        if (ie != null) {
            flattenExternal(stmts, fc, ie);
        } else {
            FStatement.flattenFStatementList(findFunctionAlgorithm().getFStatements(),
                stmts, fc, new FQNameEmpty());
        }

        int num = stmts.getNumChild();
        if (num == 0 || !(stmts.getChild(num - 1) instanceof FReturnStmt)) 
            stmts.addChild(new FReturnStmt());

        ffd.setFFunctionVariableList(vars);
        ffd.setFAlgorithm(new FAlgorithm(stmts));
        return ffd;
    }

    public static final int InstNode.FUNC_AND_REC_MOD_LEVEL = 1000;

    protected void InstBaseClassDecl.flattenExternal(List<FStatement> stmts, FClass fc, InstExternal ie) {
        List<FStatement> stmts2 = new List<FStatement>();
        ie.flatten(stmts2, fc, new FQNameEmpty());
        for (FStatement stmt : stmts2) {
            stmts.addChild(stmt);
        }
    }
    
    private void InstBaseClassDecl.copyDerivativeAnnotations(FClass fc, AnnotationNode dest) {
        copyDerivativeAnnotations(fc, findDerivativeAnnotationRoot(), dest);
    }

    /**
     * Utility method for finding an annotation tree that contains one of the
     * provided subpaths. It will optionaly look in the external and the
     * annotation of extending classes.
     */
    protected AnnotationNode InstClassDecl.findAnnotationRoot(boolean lookInExternal, boolean lookInExtends, String ... subPaths) {
        return AnnotationNode.NO_ANNOTATION;
    }

    @Override
    protected AnnotationNode InstBaseClassDecl.findAnnotationRoot(boolean lookInExternal, boolean lookInExtends, String ... subPaths) {
        for (String subPath : subPaths) {
            AnnotationNode node = annotation(subPath);
            if (node.exists()) {
                return annotation();
            }
        }
        if (lookInExternal) {
            InstExternal ie = findFunctionExternal();
            if (ie != null) {
                for (String subPath : subPaths) {
                    AnnotationNode node = ie.annotation(subPath);
                    if (node.exists()) {
                        return ie.annotation();
                    }
                }
            }
        }
        if (lookInExtends) {
            for (InstExtends instExtends : getInstExtendss()) {
                AnnotationNode node = instExtends.myInstClass().findAnnotationRoot(lookInExternal, lookInExtends, subPaths);
                if (node.exists()) {
                    return node;
                }
            }
        }
        return super.findAnnotationRoot(lookInExternal, lookInExtends, subPaths);
    }

    @Override
    protected AnnotationNode InstSimpleShortClassDecl.findAnnotationRoot(boolean lookInExternal, boolean lookInExtends, String ... subPaths) {
        return actualInstClass().findAnnotationRoot(lookInExternal, lookInExtends, subPaths);
    }

    @Override
    protected AnnotationNode InstLibNode.findAnnotationRoot(boolean lookInExternal, boolean lookInExtends, String ... subPaths) {
        return actualInstClass().findAnnotationRoot(lookInExternal, lookInExtends, subPaths);
    }

    protected AnnotationNode InstClassDecl.findDerivativeAnnotationRoot() {
        return findAnnotationRoot(true, true, "derivative");
    }

    protected AnnotationNode InstClassDecl.findInlineAnnotationRoot() {
        return findAnnotationRoot(true, true, "Inline", "LateInline", "InlineAfterIndexReduction");
    }

    protected AnnotationNode InstClassDecl.findSmoothOrderAnnotationRoot() {
        return findAnnotationRoot(true, true, "smoothOrder");
    }

    private void InstBaseClassDecl.copyDerivativeAnnotations(FClass fc, AnnotationNode src, AnnotationNode dest) {
        for (AnnotationNode derSrcNode : src.allFor("derivative")) {
            String derName = derSrcNode.string();
            InstClassDecl fd_decl = lookupDerivativeFunction(derName).target();
            AnnotationNode derDestNode = dest.addNode("derivative");
            fd_decl.flattenFunction(fc);
            FExp derNameExp = new FIdUseExp(new FQNameString(fd_decl.qualifiedName()));
            derDestNode.setValue(derNameExp);
            for (AnnotationNode attrSrcNode : derSrcNode) {
                if ("noDerivative".equals(attrSrcNode.name()) && attrSrcNode.isStringValue()) {
                    AnnotationNode noDer = derDestNode.addNode("noDerivative");
                    noDer.setValue(new FIdUseExp(attrSrcNode.string()));
                } else if ("zeroDerivative".equals(attrSrcNode.name()) && attrSrcNode.isStringValue()) {
                    AnnotationNode zeroDer = derDestNode.addNode("zeroDerivative");
                    zeroDer.setValue(new FIdUseExp(attrSrcNode.string()));
                } else if ("order".equals(attrSrcNode.name()) && attrSrcNode.isIntegerValue()) {
                    AnnotationNode order = derDestNode.addNode("order");
                    order.setValue(new FIntegerLitExp(attrSrcNode.integer()));
                }
            }
        }
    }

    private void InstBaseClassDecl.addLocalFunctionConstants(FFunctionDecl ffd, FClass fc) {
        Set<InstAssignable> added = new HashSet<InstAssignable>();
        Set<InstAssignable> all = localFunctionConstantList();
        List<FFunctionVariable> ffvs = new List<FFunctionVariable>();
        List<FStatement> stmts = new List<FStatement>();
        int n = 0;
        while (n < all.size()) {
            n = all.size();
            // We need a copy of all since it can be modified during iteration
            for (InstAssignable cons : all.toArray(new InstAssignable[n])) {
                if (added.add(cons)) {
                    cons.flattenInFunction(ffvs, stmts, fc, true, this);
                    cons.flattenUsedFuncsAndEnums(fc);
                    all.remove(cons);
                }
            }
        }
        ffvs.addAll(ffd.getFFunctionVariableListNoTransform());
        stmts.addAll(ffd.getFAlgorithmNoTransform().getFStatementListNoTransform());
        ffd.setFFunctionVariableList(ffvs);
        ffd.getFAlgorithmNoTransform().setFStatementList(stmts);
    }

    public void FFunctionDecl.updateRecordArraySizes() {
        for (FFunctionVariable ffv : getFFunctionVariables())
            ffv.updateRecordArraySizes();
    }
    
    public void FFunctionVariable.updateRecordArraySizes() {
        // TODO: this should probably be in attributes as well
        // TODO: if exp is access to input with unknown array sizes, handle that
        if (hasBindingExp() && isRecord())
            getType().updateRecordArraySizes(getBindingExp().type());
    }
    
    public void FType.updateRecordArraySizes(FType from) {
        setSize(from.getSize());
    }
    
    public void FRecordType.updateRecordArraySizes(FType from) {
        super.updateRecordArraySizes(from);
        FRecordType rfrom = (FRecordType) from;
        for (FRecordComponentType comp : getComponents())
            comp.getFType().updateRecordArraySizes(componentType(comp.getName(), rfrom.getComponents()));
    }
    
    public void FFunctionType.updateRecordArraySizes(FType from) {
        super.updateRecordArraySizes(from);
        FFunctionType rfrom = (FFunctionType) from;
        for (FRecordComponentType comp : getInputs())
            comp.getFType().updateRecordArraySizes(componentType(comp.getName(), rfrom.getInputs()));
        for (FRecordComponentType comp : getOutputs())
            comp.getFType().updateRecordArraySizes(componentType(comp.getName(), rfrom.getOutputs()));
    }

    public void InstNode.flattenComponentsInFunction(List<FFunctionVariable> vars, List<FStatement> stmts,
            FClass fc, Set<String> added, int level) {
        HashMap<InstNode,Integer> oldLevels = setModificationLevel(level);
        for (InstExtends ie : getInstExtendss()) {
            ie.flattenComponentsInFunction(vars, stmts, fc, added, level + 1);
        }
        for (InstComponentDecl icd : getInstComponentDecls()) {
            if (added.add(icd.name())) {
                HashMap<InstNode,Integer> oldLevels2 = icd.setModificationLevel(level + 1);
                icd.flattenInFunction(vars, stmts, fc, false, null);
                icd.flattenUsedFuncsAndEnums(fc);
                icd.clearModificationLevel(oldLevels2);
            }
        }
        clearModificationLevel(oldLevels);
    }

    syn FAlgorithm InstNode.findFunctionAlgorithm() {
        if (getNumFAbstractEquation() > 0) {
            FAbstractEquation equ = getFAbstractEquation(0);
            if (equ instanceof FAlgorithm)
                return (FAlgorithm) equ;
        } else {
            for (InstExtends ie : getInstExtendss()) {
                FAlgorithm tmp = ie.findFunctionAlgorithm();
                if (tmp != null) 
                    return tmp;
            }
            return new FAlgorithm(new List());
        }
        return null;
    }
    
    syn InstExternal InstClassDecl.findFunctionExternal() {
        for (InstExtends ie : getInstExtendss()) {
            InstExternal tmp = ie.myInstClass().findFunctionExternal();
            if (tmp != null) 
                return tmp;
        }
        return null;
    }
    eq InstFullClassDecl.findFunctionExternal()        = 
        hasInstExternal() ? getInstExternal() : super.findFunctionExternal();
    eq InstSimpleShortClassDecl.findFunctionExternal() = actualInstClass().findFunctionExternal();
    eq InstLibNode.findFunctionExternal()              = actualInstClass().findFunctionExternal();
    
    // Flatten record if not already done
    public void InstClassDecl.flattenRecord(FClass fc) {}
    
    public void InstBaseClassDecl.flattenRecord(FClass fc) {
        getInstRestriction().flattenRecord(fc, this);
    }
    
    public void InstRestriction.flattenRecord(FClass fc, InstBaseClassDecl icd) {}
    
    public void InstConnector.flattenRecord(FClass fc, InstBaseClassDecl icd) {
        if (inheritedRestriction() != null)
            inheritedRestriction().flattenRecord(fc, icd);
    }

    public void InstMRecord.flattenRecord(FClass fc, InstBaseClassDecl icd) {
        icd.flattenThisRecord(fc);
    }

    public void InstNode.flattenThisRecord(FClass fc) {
        String name = qualifiedTypeName();
        if (fc.lookupFRec(name) == null) {
            FRecordDecl frd = new FRecordDecl();
            frd.setFQName(new FQNameString(name));
            
            Set<String> names = new HashSet<String>();
            flattenComponentsInRecord(frd, fc, names, FUNC_AND_REC_MOD_LEVEL);
            
            fc.addFRecordDecl(frd);
            
            flattenUsedFuncsAndEnums(fc);
        }
    }

    public void InstNode.flattenComponentsInRecord(FRecordDecl frd, FClass fc, Set<String> names, int level) {
        HashMap<InstNode,Integer> oldLevels = setModificationLevel(level);
        for (InstExtends ie : getInstExtendss())
            ie.flattenComponentsInRecord(frd, fc, names, level + 1);
        for (InstComponentDecl icd : getInstComponentDecls()) {
            HashMap<InstNode,Integer> oldLevels2 = icd.setModificationLevel(level + 1);
            icd.flattenInRecord(frd, fc, names);
            icd.clearModificationLevel(oldLevels2);
        }
        clearModificationLevel(oldLevels);
    }

    public void InstSimpleShortClassDecl.flattenComponentsInRecord(FRecordDecl frd, FClass fc, Set<String> names, int level) {
        actualInstClass().flattenComponentsInRecord(frd, fc, names, level);
    }

    public void InstLibNode.flattenComponentsInRecord(FRecordDecl frd, FClass fc, Set<String> names, int level) {
        actualInstClass().flattenComponentsInRecord(frd, fc, names, level);
    }

    public void InstExternal.flatten(List<FStatement> sl, FClass fc, FQName prefix) {
        getFAlgorithm().getFStatement(0).flatten(sl, fc, prefix);
    }
    
    syn nta FAlgorithm InstExternal.getFAlgorithm() {
        FAlgorithm fab = new FAlgorithm(new List());
        fab.addFStatement(createStmt());
        return fab;
    }
    
    public FExternalStmt InstExternal.createStmt() {
        InstClassDecl func = surroundingInstClass();
        FExternalStmt stmt = new FExternalStmt();
        stmt.setFExternalLanguage(hasFExternalLanguage() ? 
                (FExternalLanguage) getFExternalLanguage().fullCopy() : 
                new FCExternalLanguage());
        stmt.extractLibrary(this);
        if (hasInstExternalCall()) {
            InstExternalCall call = getInstExternalCall();
            if (call.hasReturnVar()) {
                stmt.setReturnVar(new FIdUseExp(new FIdUseInstAccess(call.getReturnVar().fullCopy())));
            }
            stmt.setName(call.getName());
            for (FExp arg : call.getArgs()) {
                stmt.addArg(arg.treeCopy());
            }
        } else {
            boolean hasReturn = func.myOutputs().size() == 1 && 
                    func.myOutputs().get(0).canBeExternalReturn(stmt.getFExternalLanguage());
            if (hasReturn) {
                stmt.setReturnVar(new FIdUseExp(new FIdUseInstAccess(new InstComponentAccess(func.myOutputs().get(0).name()))));
            }
            stmt.setName(func.name());
            for (InstComponentDecl arg : func.allInstComponentDecls()) {
                if (!hasReturn || !arg.isOutput()) {
                    arg.addExternalArg(stmt);
                }
            }
        }
        return stmt;
    }
    
    public void InstComponentDecl.addExternalArg(FExternalStmt stmt) {}
    public void InstAssignable.addExternalArg(FExternalStmt stmt) {
        FIdUseExp use = new FIdUseExp(new FIdUseInstAccess(new InstComponentAccess(name())));
        stmt.addArg(use);
        for (int i = 0; i < ndims(); i++) {
            stmt.addArg(new FSizeExp(use.treeCopy(), new Opt(new FIntegerLitExp(i + 1))));
        }
    }
    
    syn boolean InstComponentDecl.canBeExternalReturn(FExternalLanguage lang) = false;
    eq InstAssignable.canBeExternalReturn(FExternalLanguage lang) = 
        !isArray() && lang.canBeReturn(type());
    
    syn boolean FExternalLanguage.canBeReturn(FType type) = !type.isArray();
    eq FFortran77ExternalLanguage.canBeReturn(FType type) = !type.isComposite() && !type.isString();
    
    public boolean FExternalStmt.flatten(List<FStatement> sl, FClass fc, FQName prefix) {
        List<FExp> args = new List<FExp>();
        for (FExp arg : getArgs()) {
            args.add(arg.flatten(prefix));
        }
        Opt<FIdUseExp> ret = hasReturnVar() ? 
                new Opt<FIdUseExp>((FIdUseExp)getReturnVar().flatten(prefix)) : 
                new Opt<FIdUseExp>();
                
        FExternalStmt stmt = new FExternalStmt(getFExternalLanguage().treeCopy(), ret, getName(), args);
        stmt.extractLibrary(this);
        sl.add(stmt);
        return false;
    }
    
    public void InstComponentDecl.flattenInFunction(
            List<FFunctionVariable> vars, List<FStatement> stmts, FClass fc, boolean useConstant, InstClassDecl func) {}
    
    @Override
    public void InstAssignable.flattenInFunction(
            List<FFunctionVariable> vars, List<FStatement> stmts, FClass fc, boolean useConstant, InstClassDecl func) {
        if (useConstant || !flattenAsFunctionConstant()) {
            InstClassDecl old = temporarilyInFunction;
            temporarilyInFunction = func;
            if (hasInstValueMod())
                getBindingFExp().flattenUsedFuncsAndEnums(fc);
            Opt eo = new Opt();
            FQName fqn = createFQNameForFuncVar(func);
            fqn.removeFArraySubscripts();
            FFunctionVariable ffv = createFFunctionVariable(eo, fqn);
            if (isInput())
                ffv.setFTypePrefixInputOutput(new FInput());
            if (isOutput())
                ffv.setFTypePrefixInputOutput(new FOutput());
            vars.addChild(ffv);
            if (isComposite()) {
                addFInitArrayStmt(stmts, isInput(), expandedFQNameCalc(), new ForNames());
            }
            if (!isInput()) {
                addBindingAssignments(stmts);
            }
            myInstClass().flattenRecord(fc);
            temporarilyInFunction = old;
        }
    }
    
    public void InstComponentDecl.addFInitArrayStmt(List<FStatement> l, boolean input, FQName fqn, ForNames names) {
        
    }
    
    public void InstAssignable.addFInitArrayStmt(List<FStatement> l, boolean input, FQName fqn, ForNames names) {
        if (isArray()) {
            if (input) {
                size().addSizeCheck(l, this, fqn);
            } else {
                FInitArrayStmt stmt = new FInitArrayStmt(new FIdUseExp(fqn));
                stmt.shouldBeSorted = true;
                l.add(stmt);
            }
        }
    }
    
    public void InstRecord.addFInitArrayStmt(List<FStatement> l, boolean input, FQName fqn, ForNames names) {
        super.addFInitArrayStmt(l, input, fqn, names);
        if (input) {
            if (isArray()) {
                InstComponentDecl rec = scalar();
                if (rec == null) {
                    return;
                }
                names.addLayer(ndims());
                names.fillLayer(null);
                List<FStatement> ll = new List<FStatement>();
                rec.addFInitArrayStmtCell(ll, input, fqn.copyAndAddFas(names.createFArraySubscripts()), names);
                names.createForLoops(l, ll, fqn);
                names.removeLayer();
            } else {
                addFInitArrayStmtCell(l, input, fqn, names);
            }
        }
    }
    
    public void InstComponentDecl.addFInitArrayStmtCell(List<FStatement> l, boolean input, FQName fqn, ForNames names) {
        for (InstComponentDecl icd : allInstComponentDecls()) {
            icd.addFInitArrayStmt(l, input, fqn.copyAndAppend(icd.name()), names);
        }
    }
    
    public void Size.addSizeCheck(List<FStatement> l, InstAssignable n, FQName fqn) {
        for (int i = 0; i < ndims(); i++) {
            if (needSizeCheck(i)) {
                String msg = "Mismatching sizes in function '" + n.surroundingInstClass().qualifiedName() +
                        "', component '" + fqn.toString() + "', dimension '" + (i+1) + "'";
                FAssert call = new FAssert(new FEqExp(flattenFExp(i), new FUnknownSizeExp(new FIdUseExp(fqn.treeCopy()), i)), new FStringLitExp(msg), new Opt<FExp>());
                FFunctionCallStmt stmt = new FFunctionCallStmt(new List<FFunctionCallLeft>(), call);
                stmt.shouldBeSorted = true;
                l.add(stmt);
            }
        }
    }
    
    public boolean Size.needSizeCheck(int i) { return size[i] != UNKNOWN; }
    public boolean MutableSize.needSizeCheck(int i) { return (exps[i] != null && !(exps[i] instanceof FColonSizeExp)) || super.needSizeCheck(i); }
    
    public void InstComponentDecl.addBindingAssignments(List<FStatement> l) {
        for (InstComponentDecl icd : allInstComponentDecls()) {
            icd.addBindingAssignments(l);
        }
    }
    
    public void InstAssignable.addBindingAssignments(List<FStatement> l) {
        if (hasBindingFExp()) {
            FStatement stmt = new FAssignStmt(setLocationOf(new FIdUseExp(expandedFQNameCalc())), getBindingFExp().flatten(new FQNameEmpty()));
            stmt.shouldBeSorted = true;
            l.add(stmt);
        } else {
            super.addBindingAssignments(l);
        }
    }
    
    syn FQName InstAssignable.expandedFQNameCalc() {
        if (temporarilyInFunction != null) {
            return createFQNameForFuncUse(temporarilyInFunction);
        } else {
            return expandedFQName().append(name());
        }
    }

    inh FQName InstComponentDecl.expandedFQName();
    eq InstClassDecl.getChild().expandedFQName()          = new FQNameFull();
    eq InstRecordConstructor.getChild().expandedFQName()  = new FQNameFull();
    eq InstComponentDecl.getChild().expandedFQName()      = expandedFQName();
    eq InstArrayComponentDecl.getChild().expandedFQName() = appendMyName(expandedFQName());
    eq InstAssignable.getChild().expandedFQName() {
        if (temporarilyInFunction != null) {
            return createFQNameForFuncUse(temporarilyInFunction);
        }
        if (size().isUnknown()) {
            return expandedFQName().append(name(), size().flattenSubscript());
        } else {
            return expandedFQName().append(name());
        }
    }

    /**
     * Get the list of constants that need to be added to the surrounding function.
     */
    inh Set<InstAssignable> InstAccess.functionConstantList();
    inh Set<InstAssignable> InstAssignable.functionConstantList();
    eq InstClassDecl.getChild().functionConstantList()  = localFunctionConstantList();
    eq InstAssignable.getChild().functionConstantList() = 
        (temporarilyInFunction != null) ? 
                temporarilyInFunction.localFunctionConstantList() : 
                functionConstantList();
    eq Root.getChild().functionConstantList()           = null;
    
    /**
     * The list of constants that need to be added to this function.
     * 
     * The list will be populated when expressions in the function are flattened.
     */
    syn lazy Set<InstAssignable> InstClassDecl.localFunctionConstantList() = 
        new LinkedHashSet<InstAssignable>();
    
    
    public class InstLookupResult<T extends InstNode> {
        /**
         * Check if lookup found a target that is not the same as the given one.
         */
        public boolean foundOther(T t) {
            return successful() && target() != t;
        }
    }

    public FQName InstComponentDecl.createFQNameForFuncVar(InstClassDecl func) {
        FQName name = getFQName();
        if (func != null) {
            if (name.numParts() > 1 || func.memberInstComponent(name.name()).foundOther(this))
                return new FQNameString(func.localTempVarName(this));
        }
        return name.fullCopy();
    }
    
    public FQName InstAssignable.createFQNameForFuncUse(InstClassDecl func) {
        return createFQNameForFuncVar(func).asFQNameFull().addFArraySubscripts(null);
    }
    
    public FFunctionVariable InstAssignable.createFFunctionVariable(Opt eo, FQName fqn) {
        // TODO: if we need separate variable class for records, override this
        FType type = type().flatten(new FQNameEmpty(), this, !isInput());
        FFunctionVariable ffv;
        if (isArray())
            ffv = new FFunctionArray(new Opt(), type, eo, fqn);
        else
            ffv = new FFunctionVariable(new Opt(), type, eo, fqn);
        return ffv;
    }
    
    public FType FType.flatten(FQName prefix, InstAssignable ia, boolean keepSizeExpressions) {
        FType res = fullCopy();
        res.setSize(getSize().flatten(prefix, res, keepSizeExpressions));
        return res;
    }
    
    public FRecordComponentType FRecordComponentType.flatten(FQName prefix, InstAssignable ia, boolean keepSizeExpressions) {
        return new FRecordComponentType(getName(), getFType().flatten(prefix, ia, keepSizeExpressions));
    }
    
    @Override
    public FType FRecordType.flatten(FQName prefix, InstAssignable ia, boolean keepSizeExpressions) {
        List<FRecordComponentType> comps = new List<FRecordComponentType>();
        for (FRecordComponentType frct : getComponents()) {
            comps.add(frct.flatten(prefix, ia, keepSizeExpressions));
        }
        FRecordType res = new FRecordType(getSize(), getName(), comps, getFClass());
        res.setSize(getSize().flatten(prefix, res, keepSizeExpressions));
        res.flattened = true;
        return res;
    }
    
    @Override
    public FType FFunctionType.flatten(FQName prefix, InstAssignable ia, boolean keepSizeExpressions) {
        List<FRecordComponentType> inputs = new List<FRecordComponentType>();
        for (FRecordComponentType frct : getInputs()) {
            inputs.add(frct.flatten(prefix, ia, keepSizeExpressions));
        }
        List<FRecordComponentType> outputs = new List<FRecordComponentType>();
        for (FRecordComponentType frct : getOutputs()) {
            outputs.add(frct.flatten(prefix, ia, keepSizeExpressions));
        }
        FFunctionType res = new FFunctionType(getSize(), getName(), inputs, outputs, getFClass());
        res.setSize(getSize().flatten(prefix, res, keepSizeExpressions));
        res.flattened = true;
        return res;
    }
    
    @Override
    public FType FExternalObjectType.flatten(FQName prefix, InstAssignable ia, boolean keepSizeExpressions) {
        FType res = new FExternalObjectType(getSize(), getName(), getConstructor().flatten(prefix), getDestructor().flatten(prefix));
        res.setSize(getSize().flatten(prefix, res, keepSizeExpressions));
        return res;
    }
    
    private boolean FRecordType.flattened = false;
    rewrite FRecordType {
        when (flattened) to FRecordType {
            setFClass(myFClass());
            flattened = false;
            return this;
        }
    }
    
    private boolean FFunctionType.flattened = false;
    rewrite FFunctionType {
        when (flattened) to FFunctionType {
            setFClass(myFClass());
            flattened = false;
            return this;
        }
    }
    
    public Size Size.flatten(FQName prefix, ASTNode context, boolean keepSizeExpressions) {
        return this;
    }
    
    public MutableSize MutableSize.flatten(FQName prefix, ASTNode context, boolean keepSizeExpressions) {
        MutableSize res = new MutableSize(size.length);
        System.arraycopy(size, 0, res.size, 0, size.length);
        if (keepSizeExpressions) {
            for (int i = 0; i < exps.length; i++) {
                if (exps[i] != null && !(exps[i] instanceof FColonSizeExp) && 
                        (size[i] == Size.UNKNOWN || !exps[i].inFunction())) {
                    res.exps[i] = context.affixExpression(exps[i].flatten(prefix));
                }
            }
        }
        return res;
    }
    
    /**
     * Affix the given expression to the tree.
     * 
     * Where supported, adds it to dynamicFExp(), otherwise throws UnsupportedOperationException.
     * 
     * @return the expression, possibly rewritten
     */
    public FExp ASTNode.affixExpression(FExp exp) {
        throw new UnsupportedOperationException("Method affixExpression(FExp) not supported by class " + getClass().getSimpleName());
    }
    
    public FExp FExp.affixExpression(FExp exp) {
        return dynamicFExp(exp);
    }
    
    public FExp FFunctionCall.affixExpression(FExp exp) {
        // can't use dynamicExp(), since this node might not be in tree (InstFunctionCall.flatten())
        // TODO: if InstFunctionCall.flatten() is changed so that the size is flattened in a 
        //       rewrite on FFunctionCall instead, then dynamicExp() can be used here
        exp.parent = this;
        return exp;
    }
    
    public FExp FType.affixExpression(FExp exp) {
        // TODO: need better way of including exp in tree
        exp.parent = this;
        return exp;
    }

    public enum FlattenBindingExp {
        ALL, PARAMETER, NONE;
        
        public boolean shouldFlattenExp(InstAssignable var) {
            return (this == ALL) || (this == PARAMETER && var.variability().parameterOrLess());
        }
    }

    // Generic method for flattening
    public void ASTNode.flatten(FClass fc, FlattenBindingExp binding, int level) {
        for (ASTNode n : this) {
            n.flatten(fc, binding, level);
        }
    }

    public void InstNode.flatten(FClass fc, FlattenBindingExp binding, int level) {
        HashMap<InstNode,Integer> oldLevels = setModificationLevel(level);
        flattenEquations(getFQName(), fc);
        getInstComponentDeclList().flatten(fc, binding, level + 1);
        getInstExtendsList().flatten(fc, binding, level + 1);
        contribute(fc);
        clearModificationLevel(oldLevels);
    }

    public void InstNode.flattenEquations(FQName name, FClass fc) {
        for (FAbstractEquation ae : getFAbstractEquations()) 
            ae.flatten(name, fc);
    }

    /**
     * Check if this component is present in the model (i.e. not a disabled conditional 
     * and not a non-selected duplicate).
     */
    syn boolean InstComponentDecl.isPresent() = !isDisabled() && !isDuplicate();
    eq InstArrayComponentDecl.isPresent()     = getIndex() > 0 && super.isPresent();

    /**
     * Check if this component should be considered during flattening.
     */
    syn boolean InstComponentDecl.useInFlattening()    = isPresent() && !(isOuter() && !isInner());

    public void InstComponentDecl.flatten(FClass fc, FlattenBindingExp binding, int level) {
        if (useInFlattening()) {
            super.flatten(fc, binding, level);
            if (!isPrimitive() && !hasFArraySubscripts() && !isConnector()) {
                fc.countComponent();
            }
        }
    }

    public void InstExpandableConnectorDecl.flatten(FClass fc, FlattenBindingExp binding, int level) {
        super.flatten(fc, FlattenBindingExp.PARAMETER, level);
    }

    public void InstClassDecl.buildConnectionSets(FClass fc) {
        beginStep("buildConnectionSets()");
        ConnectionSetManager csm = fc.getConnectionSetManager();
        buildConnectionSets(new FQNameEmpty(), csm, true);
        csm.buildOverconstrainedConnectionTrees();
        csm.elaborateExpandableConnectors();
        endStep("buildConnectionSets()");
    }
    
    public void InstComponentDecl.flattenInRecord(FRecordDecl frd, FClass fc, Set<String> names) {}
    
    public boolean FVariable.modifiableInRecord = true;
    public void InstAssignable.flattenInRecord(FRecordDecl frd, FClass fc, Set<String> names) {
        if (names.add(name())) {
            FQName fqn;
            if (isArray()) {
                List<FQNamePart> l = new List<FQNamePart>();
                l.add(new FQNamePartArray(name(), size().flattenFArraySubscripts()));
                fqn = new FQNameFull(l);
            } else {
                fqn = new FQNameString(name());
            }
            FVariable fv = createFVariable(fqn, FlattenBindingExp.NONE);
            fv.modifiableInRecord = isModifiable();
            frd.addFVariableNoTransform(fv);
            flattenMyType(fc);
        }
    }
    
    public FArraySubscripts Size.flattenFArraySubscripts() {
        if (ndims() > 0) {
            List<FSubscript> l = new List<FSubscript>();
            for (int i = 0; i < ndims(); i++) {
                l.add(flattenFSubscript(i));
            }
            return new FArraySubscripts(l);
        }
        return null;
    }
    
    public FSubscript Size.flattenFSubscript(int i) {
        int s = get(i);
        return s == Size.UNKNOWN ? new FColonSubscript() : new FIntegerSubscript(s);
    }
    
    public FSubscript MutableSize.flattenFSubscript(int i) {
        if (exps[i] == null || exps[i] instanceof FColonSizeExp ||
                exps[i].variability().knownParameterOrLess()) {
            return super.flattenFSubscript(i);
        }
        return new FExpSubscript(exps[i].flatten(exps[i].sizeFlatteningPrefix()));
    }

    public void InstAssignable.flatten(FClass fc, FlattenBindingExp binding, int level) {
        if (useInFlattening()) {
            if (hasBindingFExp()) {
                getBindingFExp().flattenAssertExternal(fc, myInstValueMod().myInstNode().retrieveFQName());
            }
            HashMap<InstNode,Integer> oldLevels = setModificationLevel(level);
            fc.addFVariableNoTransform(createFVariable(getFQName().copyAndAddFas(size().flattenFArraySubscripts()), binding));
            flattenMyType(fc);
            clearModificationLevel(oldLevels);
        }
    }
    
    public void ASTNode.flattenAssertExternal(FClass fc, FQName prefix) {
        for (ASTNode n : this) {
            n.flattenAssertExternal(fc, prefix);
        }
    }
    
    public void InstFunctionCall.flattenAssertExternal(FClass fc, FQName prefix) {
        if (variability().knownParameterOrLess() && myInstCallable().isExternalFunction()) {
            try {
                String msg = runtimeErrorString("Structural parameter external function call '"
                        + name() + "' did not evaluate to same result as during compilation");
                CValue cval = ceval();
                if (cval.hasBuildLiteral()) {
                    fc.addFParameterEquation(new FFunctionCallEquation(new List<FFunctionCallLeft>(), 
                            new FAssert(new FEqExp(cval.buildLiteral(), flatten(prefix)),
                                    new FStringLitExp(msg), new Opt<FExp>())));
                }
            } catch (ConstantEvaluationException e) {}
        }
    }
    
    public String ASTNode.runtimeErrorString(String msg) {
        StringBuilder sb = new StringBuilder();
        sb.append("Error at line ");
        sb.append(lineNumber());
        sb.append(", column ");
        sb.append(columnNumber());
        sb.append(", in file '");
        sb.append(fileName().replace("\\", "\\\\"));
        sb.append("': ");
        sb.append(msg);
        return sb.toString();
    }
    
    syn boolean ASTNode.externalDependency() {
        for (ASTNode n : this) {
            if (n.externalDependency()) {
                return true;
            }
        }
        return false;
    }
    eq InstFunctionCall.externalDependency() =  ((InstNode)myInstCallable()).externalDependency();
    
    syn lazy boolean InstFullClassDecl.externalDependency() = hasInstExternal() || super.externalDependency();
    
    
    public abstract void InstAssignable.flattenMyType(FClass fc);

    public void InstPrimitive.flattenMyType(FClass fc) {
        myInstClass().addFDerivedType(fc);
        flattenUsedFuncsAndEnums(fc);
    }

    
    syn InstComponentDecl InstComponentDecl.scalar() {
        InstComponentDecl rec = this;
        for (int i = 0; i < ndims(); i++) {
            if (rec.getNumInstComponentDecl() == 0) {
                return null;
            } else {
                rec = rec.getInstComponentDecl(0);
            }
        }
        return rec;
    }
    
    public void InstRecord.flattenMyType(FClass fc) {
        if (flattenRedeclaredType()) {
            InstComponentDecl rec = scalar();
            if (rec != null) {
                rec.flattenThisRecord(fc);
            }
        } else {
            myInstClass().flattenRecord(fc);
        }
    }
    
    syn String InstNode.qualifiedTypeName() = qualifiedName();
    eq InstComponentDecl.qualifiedTypeName() {
        if (flattenRedeclaredType()) {
            return surroundingInstClass().qualifiedName() + ":" + qualifiedName();
        } else {
            return myInstClass().qualifiedName();
        }
    }
    
    syn boolean InstComponentDecl.flattenRedeclaredType() = InstNode.containsRedeclared(this);
    
    syn boolean InstNode.containsRedeclared() = InstNode.containsRedeclared(this);
    public static boolean InstNode.containsRedeclared(InstNode in) {
        for (InstComponentDecl icd : in.getInstComponentDecls()) {
            if (icd.containsRedeclared()) {
                return true;
            }
        }
        for (InstClassDecl icd : in.getInstClassDecls()) {
            if (icd.containsRedeclared()) {
                return true;
            }
        }
        return false;
    }
    
    eq InstReplacingComposite.containsRedeclared() = true;
    eq InstReplacingRecord.containsRedeclared() = true;
    eq InstReplacingPrimitive.containsRedeclared() = true;
    
    eq InstClassDecl.containsRedeclared() = false;
    eq InstReplacingFullClassDecl.containsRedeclared() = true;
    eq InstReplacingShortClassDecl.containsRedeclared() = true;
    eq InstReplacingSimpleShortClassDecl.containsRedeclared() = true;
    
    
    public void InstEnum.flattenMyType(FClass fc) {
        myInstClass().flattenEnum(fc);
        flattenUsedFuncsAndEnums(fc);
    }

    public void InstPartialFunction.flattenMyType(FClass fc) {
        throw new UnsupportedOperationException("Partial function component only allowed in functions");
    }

    /*
     * Flattening of string comments.
     */

    private static final char[][] StringComment.ESCAPE_CHARS = {
        {'b', '\b'}, {'\"', '\"'}, {'f', '\f'}, {'n', '\n'}, {'r', '\r'}, {'t', '\t'}, { '\'', '\''}
    };
    private static final Map<Character, Character> StringComment.ESCAPE_MAP = initializeEscapeMap();
    private static final char StringComment.BACKSLASH = '\\';

    /**
     * Creates a {@link Map} instance mapping all the pairs in {@code ESCAPE_CHARS}.
     * <p>
     * The first character in each pair of {@code ESCAPE_CHARS} is a key to the value,
     * i.e. the second character in the pair.
     */ 
    private static final Map<Character, Character> StringComment.initializeEscapeMap() {
        Map<Character, Character> map = new HashMap<Character, Character>();
        for (char[] pair : ESCAPE_CHARS) {
            map.put(pair[0], pair[1]);
        }
        return Collections.<Character, Character> unmodifiableMap(map);
    }

    /**
     * Flattens this comment, removing all escape sequences and replacing them with the corresponding character.
     * <p>
     * Note that this method also removes stray backslashes, or double backslashes.
     * 
     * @return
     *          a {@link FStringComment} instance (a comment node in the flat tree).
     */
    public FStringComment StringComment.flatten() {
        String comment = getComment();
        StringBuilder escapedComment = new StringBuilder();
        int length = comment.length();

        for (int i = 0; i < length; ++i) {
            char c = comment.charAt(i);

            if (c == BACKSLASH) {
                if (++i < length) {
                    char c2 = comment.charAt(i);
                    if (ESCAPE_MAP.containsKey(c2)) {
                        c2 = ESCAPE_MAP.get(c2);
                    } else if (c2 == BACKSLASH) {
                        continue;
                    }
                    escapedComment.append(c2);
                }
            } else {
                escapedComment.append(c);
            }
        }
        return new FStringComment(escapedComment.toString().replaceAll("\\\\", ""));
    }

    public FEnumLiteral InstEnumLiteral.createFEnumLiteral() {
        FEnumLiteral e = new FEnumLiteral(new FIdUse(name()),new Opt());
        if (getComponentDecl().getComment().hasStringComment())
            e.setFStringComment(getComponentDecl().getComment().getStringComment().flatten());
        return e;
    }

    private FClass InstClassDecl.flatEnumClassDeclAddedTo = null;
    
    public void InstClassDecl.flattenEnum(FClass fc) {      
        if (flatEnumClassDeclAddedTo != fc) {
            flatEnumClassDeclAddedTo = fc;
            // Flatten all InstEnums corresponding to FEnumLiterals
            FEnumLiteralList l = new FEnumLiteralList();
            for (InstEnumLiteral ie : enumLiterals()) 
                l.addFEnumLiteral(ie.createFEnumLiteral());
            FIdDecl id = new FIdDecl(new FQNameString(qualifiedName()));
            ClassDecl classDecl = getClassDecl();
            Opt comment = null;
            if (classDecl.hasStringComment()) 
                comment = new Opt(classDecl.getStringComment().flatten());
            else 
                comment = new Opt();
            fc.addFEnumDecl(new FEnumDecl(id, l, comment)); 
            addFDerivedType(fc);
        }
    }
    
    public void InstSimpleShortClassDecl.flattenEnum(FClass fc) {
        actualInstClass().flattenEnum(fc);
    }
    
    public void InstLibNode.flattenEnum(FClass fc) {
        actualInstClass().flattenEnum(fc);
    }
    
    public abstract FVariable InstAssignable.createEmptyFVariable();
    
    public FVariable InstPrimitive.createEmptyFVariable() {
        if (isReal()) 
            return new FRealVariable();
        if (isInteger()) 
            return new FIntegerVariable();
        if (isBoolean()) 
            return new FBooleanVariable();
        if (isString()) 
            return new FStringVariable();
        throw new UnsupportedOperationException("InstPrimitive without type");
    }   

    public FEnumVariable InstEnum.createEmptyFVariable() {
        FEnumVariable fv = new FEnumVariable();
        fv.setEnum(new FQNameString(myInstClass().actualInstClass().qualifiedName()));
        return fv;
    }   
    
    public FVariable InstRecord.createEmptyFVariable() {
        FRecordVariable rec = new FRecordVariable();
        rec.setRecord(new FQNameString(qualifiedTypeName()));
        return rec;
    }
    
    public FVariable InstPartialFunction.createEmptyFVariable() {
        throw new UnsupportedOperationException("Partial function component only allowed in functions");
    }
    
    public FVariable InstExternalObject.createEmptyFVariable() {
        FExternalObjectVariable exo = new FExternalObjectVariable();
        exo.setConstructor(new FIdUse(myConstructor().qualifiedName()));
        return exo;
    }
    
    public void InstNode.addAttributes(List<FAttribute> attr, Environment env) {
        addAttributes(attr, env, AttributeExpRetriever.DEFAULT, true);
    }
    
    public void InstNode.addAttributes(
            List<FAttribute> attr, Environment env, AttributeExpRetriever aer, boolean cls) {
        for (InstModification im : env) 
            im.collectAttributes(attr, im.myInstNode().getFQNamePrefix(), aer, cls);
    }
    
    public void InstComponentDecl.addAttributesToFV(List<FAttribute> attr, Stack<Integer> indexStack,
            FlattenBindingExp binding, boolean isBound) {
        if (isArray()) {
            int i = 0;
            for (InstComponentDecl icd : allInstComponentDecls()) {
                indexStack.push(i++);
                icd.addAttributesToFV(attr, indexStack, binding, isBound);
                indexStack.pop();
            }
        } else {
            for (InstComponentDecl icd : allInstComponentDecls()) {
                if (icd.useInFlattening()) {
                    icd.generateAdditionalAttributes(attr, indexStack, binding, isBound);
                }
            }
        }
    }
    
    @Override
    public void InstAssignable.addAttributesToFV(List<FAttribute> attr, Stack<Integer> indexStack,
            FlattenBindingExp binding, boolean isBound) {
        if (!variability().knownParameterOrLess()) {
            AttributeExpRetriever mut = new AttributeExpRetriever() {
                public FExp retrieve(InstValueModification im, boolean isEach) {
                    FExp exp = super.retrieve(im, isEach);
                    InstNode decl = im.myInstNode();
                    InstNode ancestor = InstAssignable.this.matchingAncestor(decl);
                    return (isEach || decl == InstAssignable.this || !exp.isArray()) ? 
                            exp : exp.dynamicFExp(splitBindingFExp(exp, ancestor, ndims()));
                }
            };
            addAttributes(attr, totalMergedEnvironment(), mut, false);
        }
        super.addAttributesToFV(attr, indexStack, binding, isBound);
    }
    
    public void InstComponentDecl.generateAdditionalAttributes(List<FAttribute> attr, Stack<Integer> indexStack,
            FlattenBindingExp binding, boolean isBound) {
        
    }
    
    @Override
    public void InstAssignable.generateAdditionalAttributes(List<FAttribute> attr, Stack<Integer> indexStack,
            FlattenBindingExp binding, boolean isBound) {
        FAttribute a = findMatching(attr, name());
        boolean canBind = hasBindingFExp() || variability().knownParameterOrLess();
        List<FAttribute> list = new List<FAttribute>();
        if (a != null) {
            list.addAll(a.getFAttributes());
        }
        boolean flattenBinding = binding.shouldFlattenExp(this);
        if (flattenBinding && declaredSizeCalc().isUnknownNoEval()) {
            FInternalAttribute ia = (FInternalAttribute)findMatching(list, "size()");
            if (ia == null) {
                ia = new FInternalAttribute(FAttribute.SIZE, new FArray(new List<FExp>()));
                list.add(ia);
            }
            ia.setValue(size().createFExp().addInDim(indexStack, 0, (FArray)ia.getValue()));
        }
        if (flattenBinding) {
            HashMap<InstNode,Integer> m = setModificationLevel(FUNC_AND_REC_MOD_LEVEL+1);
            addAttributesToFV(list, indexStack, binding, isBound || canBind);
            clearModificationLevel(m);
        }
        if (a == null && (list.getNumChild() > 0 || (!isBound && canBind))) {
            a = new FAttribute(new FIdUse(getClassName().flatten()), 
                    new FIdDecl(new FQNameString(name())), 
                    new Opt(), true, 0, new Opt(), new Opt(), list);
            attr.add(a);
        } else if (a != null) {
            a.setFAttributeList(list);
        }
        
        if (!isBound && canBind) {
            a.setValue(flattenBindingFExp().addInDim(indexStack, 0, (FArray)a.getValue()));
        }
    }
    
    public FExp FExp.addInDim(Stack<Integer> s, int d, FArray arr) {
        if (d == s.size()) {
            return this;
        } else {
            if (arr == null) {
                arr = new FArray();
            }
            int i = s.get(d);
            List<FExp> l = arr.getFExpListNoTransform();
            if (i < l.getNumChildNoTransform()) {
                l.setChild(addInDim(s, d+1, (FArray)l.getChildNoTransform(i)), i);
            } else {
                arr.addFExpNoTransform(addInDim(s, d+1, null));
            }
            return arr;
        }
    }
    
    private boolean InstClassDecl.derivedTypeAdded;
    
    public void InstClassDecl.addFDerivedType(FClass fc) {
        if (!derivedTypeAdded && extendsPrimitive()) {
            derivedTypeAdded = true;
            List<FAttribute> attr = new List<FAttribute>();
            addAttributes(attr, totalMergedEnvironment());
            FType baseType = primitiveScalarType().fullCopy();
            fc.addFDerivedType(new FDerivedType(qualifiedName(), baseType, attr));
        }
    }
    
    public void InstSimpleShortClassDecl.addFDerivedType(FClass fc) {
        actualInstClass().addFDerivedType(fc);
    }
    
    public void InstLibNode.addFDerivedType(FClass fc) {
        actualInstClass().addFDerivedType(fc);
    }

    public FVariable InstAssignable.createFVariable() {
        return createFVariable(getFQName(), FlattenBindingExp.ALL);
    }

    public FVariable InstAssignable.createFVariable(FQName name, FlattenBindingExp binding) {
        FVariable fv = createEmptyFVariable();
        fv.setFVisibilityType(createFVisibilityType());
        fv.setFTypePrefixVariability(variability().fullCopy());
        
        // Only set input/output prefix for top level inputs and outputs
        if (isTopLevelInputOutput()) 
            fv.setFTypePrefixInputOutput(isInput() ? new FInput() : new FOutput());
        
        if (myInstClass().extendsPrimitive())
            fv.setDerivedType(myInstClass().actualInstClass().qualifiedName());
        
        boolean flattenBinding = binding.shouldFlattenExp(this);
        List<FAttribute> attrs = new List<FAttribute>();
        attrs.addAll(fv.getFAttributes());
        addAttributesToFV(attrs, new Stack<Integer>(), binding,
                !flattenBinding || hasBindingFExp() || variability().knownParameterOrLess());
        fv.setFAttributeList(attrs);
        if (flattenBinding) {
            FExp e = flattenBindingFExp();
            if (e != null)
                fv.setBindingExp(e);
        }
        
        if (getComponentDecl().getComment().hasStringComment())
            fv.setFStringComment(getComponentDecl().getComment().getStringComment().flatten());
        
        fv.setFQName(name);
        fv.setLocation(this);
        
        contribute(fv);
        
        return fv;
    }

    public FVisibilityType InstAssignable.createFVisibilityType() {
        if (inExpandableConnector()) {
            return new FExpandableVisibilityType();
        } else if (isPublicVar()) {
            return new FPublicVisibilityType();
        } else {
            return new FProtectedVisibilityType();
        }
    }

    /**
     * Retrieve the binding expression of an InstAssignable node.
     * 
     * Always null for components that are not assignable.
     */
    syn FExp InstComponentDecl.myBindingInstExp() = null;
    eq InstAssignable.myBindingInstExp()          = hasInstValueMod() ? myInstValueMod().getFExp() : null;

    /**
     * Check if this component has a binding expression.
     * 
     * Always false for components that are not assignable.
     */
    syn boolean InstComponentDecl.hasBindingFExp() = false;
    eq InstAssignable.hasBindingFExp()             = getBindingFExp() != null;

    /**
     * Retrieve the part of the binding expression that applies to this InstAssignable.
     */
    syn FExp InstComponentDecl.getBindingFExp() = null;
    syn lazy FExp InstAssignable.getBindingFExp() {
        //log.debug("In file: " + fileName() + " at line: " + beginLine() + ": " + prettyPrint(""));
        FExp exp = parentBindingFExp();
        if (exp != null) {
            exp = exp.component(name());
        } else if (hasInstValueMod()) {
            InstValueModification im = myInstValueMod();
            exp = im.getFExp();
            if (ndims() < exp.ndims()) {
                InstNode decl = im.myInstNode();
                decl = matchingAncestor(decl);
                exp = exp.dynamicFExp(splitBindingFExp(exp, decl, ndims()));
            }
        }
        return exp;
    }
    
    inh FExp InstComponentDecl.parentBindingFExp();
    eq Root.getChild().parentBindingFExp()                   = null;
    eq InstClassDecl.getChild().parentBindingFExp()          = null;
    eq FExp.getChild().parentBindingFExp()                   = null;
    eq InstComponentDecl.getChild().parentBindingFExp()      = null;
    eq InstAssignable.getChild().parentBindingFExp()         = getBindingFExp();
    eq InstArrayComponentDecl.getChild().parentBindingFExp() {
        FExp exp = parentBindingFExp();
        return exp != null && getIndex() > 0 ? exp.dynamicFExp(exp.splitArrayExp(getIndex())) : exp;
    }
    
    public FExp InstAssignable.flattenBindingFExp() {
        try {
            if (variability().knownParameterOrLess()) {
                CValue cval = ceval();
                if (cval.hasBuildLiteral()) {
                    return cval.buildLiteral();
                }
            }
        } catch (ConstantEvaluationException e) {}
        if (hasInstValueMod()) {
            InstValueModification im = myInstValueMod();
            return getBindingFExp().flatten(im.myInstNode().getFQNamePrefix());
        }
        return null;
    }
        
    
    /**
     * Extract the part of a binding array expression that refers to this primitive or record.
     * 
     * Will not create new nodes unless necessary.
     * 
     * @param fe    the expression to split
     * @param node  the node where the binding expression was declared 
     * @param dims  the expected number of dimensions of the resulting expression
     */
    inh FExp InstNode.splitBindingFExp(FExp fe, InstNode node, int dims);
    eq InstClassDecl.getChild().splitBindingFExp(FExp fe, InstNode node, int dims) = fe;
    eq InstRoot.getChild().splitBindingFExp(FExp fe, InstNode node, int dims)      = fe;
    eq Root.getChild().splitBindingFExp(FExp fe, InstNode node, int dims)          = fe;
    eq InstNode.getChild().splitBindingFExp(FExp fe, InstNode node, int dims)      =
        (node == this) ? fe : splitBindingFExp(fe, node, dims);
    eq InstArrayComponentDecl.getChild().splitBindingFExp(FExp fe, InstNode node, int dims) =
        (node == this || fe.ndims() <= dims) ? fe : 
            fe.dynamicFExp(splitBindingFExp(fe, node, dims + 1)).splitArrayExp(getIndex());
    eq InstShortClassDecl.getChild().splitBindingFExp(FExp fe, InstNode node, int dims) {
        if (fe.ndims() <= dims) {
            return fe;
        } else {
            FExp nfe = (node == this) ? fe : splitBindingFExp(fe, node, dims + nTypeDims());
            for (int i = 0; i < nTypeDims(); i++) {
                nfe = fe.dynamicFExp(nfe).splitArrayExp(size().get(i));
            }
            return nfe;
        }
    }
    
    /**
     * \Return the expression corresponding to the given index in this array expression. 
     * 
     * Will not create new nodes unless necessary.
     */
    syn FExp FExp.splitArrayExp(Index index) {
        FExp res = this;
        for (int i : index.index())
            res = res.splitArrayExp(i);
        return res;
    }
    
    /**
     * Return the expression corresponding to the given index in this array expression. 
     * 
     * Will not create new nodes unless necessary.
     */
    syn FExp FExp.splitArrayExp(int index)     = new FSubscriptedExp(unboundCopy(), index, ndims());
    eq FArray.splitArrayExp(int index)         = isIterArray() ? getFExp(0).splitArrayExp(index) : getFExp(index - 1);
    eq FIdUseExp.splitArrayExp(int index)      = createNode(getFIdUse().splitArrayAccess(index));
    eq InstDerExp.splitArrayExp(int index)     = new InstDerExp(getFExp().splitArrayExp(index));
    eq FArrayDimAsArgsExp.splitArrayExp(int index) {
        if (getNumFExp() == 1)
            return fillExp();
        List<FExp> args = new List<FExp>();
        for (int i = 1, n = getNumFExp(); i < n; i++)
            args.add(getFExp(i).fullCopy());
        return createNode(args);
    }
    eq FFillExp.splitArrayExp(int index) {
        FExp res = super.splitArrayExp(index);
        if (getNumFExp() > 1)
            ((FFillExp) res).setFillExp(getFillExp().fullCopy());
        return res;
    }
    eq FSubscriptedExp.splitArrayExp(int index) {
        FSubscriptedExp exp = (FSubscriptedExp) unboundCopy();
        exp.getFArraySubscripts().specifyNext(index);
        return exp;
    }
    eq FIterExp.splitArrayExp(int index) {
        Map<String,FExp> repl = new HashMap<String,FExp>();
        getForIndex(0).addReplacementEntry(repl, index);
        FExp res = dynamicFExp(getFExp().treeCopy()).replaceIndices(repl);
        if (getNumForIndex() > 1) {
            List<CommonForIndex> indices = new List<CommonForIndex>();
            for (int i = 1, n = getNumForIndex(); i < n; i++)
                indices.add(getForIndex(i).fullCopy());
            res = new FArray(new List(new FIterExp(res, indices)));
        }
        return res;
    }
    // TODO: consider if expressions

    /**
     * Add an entry to an index replacement map for this for index, for the i:th element 
     * in the resulting array.
     */
    public void CommonForIndex.addReplacementEntry(Map<String,FExp> repl, int i) {
        repl.put(name(), getFExp().getArray().get(i).treeCopy());
    }

    /**
     * Return a new access that has index instead of the first array subscript with ndims() > 1.
     * 
     * If access has no subscripts, a set of subscripts with all colons is first created.
     * 
     * Note: Current implementation assumes that only last name part needs to be considered.
     */
    syn FIdUse FIdUse.splitArrayAccess(int index) = new FIdUse(getFQName().splitArrayAccess(index));
    eq FIdUseInstAccess.splitArrayAccess(int index) = new FIdUseInstAccess(getInstAccess().splitArrayAccess(index));
    
    /**
     * Return a new name that has index instead of the first array subscript with ndims() > 1.
     * 
     * If name has no subscripts, a set of subscripts with all colons is first created.
     */
    syn FQName FQName.splitArrayAccess(int index); 
    eq FQNameEmpty.splitArrayAccess(int index) = new FQNameEmpty();
    eq FQNameString.splitArrayAccess(int index) {
        FQNameFull res = new FQNameFull(getName());
        int i = res.getNumFQNamePart();
        res.setFQNamePart(res.getFQNamePart(i - 1).splitArrayAccess(index, ndims()), i - 1);
        return res;
    }
    eq FQNameFull.splitArrayAccess(int index) {
        FQNameFull res = fullCopy();
        int i = getNumFQNamePart();
        res.setFQNamePart(getFQNamePart(i - 1).splitArrayAccess(index, ndims()), i - 1);
        return res;
    }
    
    /**
     * Return a new name part that has index instead of the first array subscript with ndims() > 1.
     * 
     * If name part has no subscripts, a set of subscripts with all colons and ndims subscripts 
     * is first added to the new part.
     */
    syn FQNamePart FQNamePart.splitArrayAccess(int index, int ndims) {
        FArraySubscripts fas = FArraySubscripts.createFColonSubscripts(ndims);
        fas.specifyNext(index);
        return new FQNamePartArray(getName(), fas);
    }
    eq FQNamePartArray.splitArrayAccess(int index, int ndims) {
        FQNamePartArray res = fullCopy();
        res.parent = parent; // Hack to allow lookups of uses from specifyNext()
        res.getFArraySubscripts().specifyNext(index);
        res.parent = null;
        return res;
    }
    
    syn InstAccess InstAccess.splitArrayAccess(int index) = this;
    
    eq InstDot.splitArrayAccess(int index) {
        List<InstAccess> l = new List<InstAccess>();
        boolean split = false;
        for (InstAccess ia : getInstAccesss()) {
            if (!split && ia.isArray()) {
                l.add(ia.splitArrayAccess(index));
                split = true;
            } else {
                l.add(ia.treeCopy());
            }
        }
        return new InstDot(l);
    }
    
    eq InstScalarAccess.splitArrayAccess(int index) {
        FArraySubscripts fas = FArraySubscripts.createFColonSubscripts(ndims());
        fas.specifyNext(index);
        return getArrayCopy(fas);
    }

    eq InstArrayAccess.splitArrayAccess(int index) {
        InstArrayAccess access = fullCopy();
        access.setParent(getTopInstAccess());
        access.getFArraySubscripts().specifyNext(index);
        return access;
    }

    eq InstGlobalAccess.splitArrayAccess(int index) = 
        new InstGlobalAccess(getInstAccess().splitArrayAccess(index));
    
    public void FArraySubscripts.specifyNext(int index) {
        for (int i = 0; i < getNumFSubscript(); i++) {
            if (getFSubscript(i).ndims() > 0) {
                setFSubscript(getFSubscript(i).specify(index), i);
                return;
            }
        }
    }
    
    syn FSubscript FSubscript.specify(int index);
    eq FExpSubscript.specify(int index)     = 
        new FExpSubscript(getFExp().getArray().getFExp(index - 1).fullCopy());
    eq FIntegerSubscript.specify(int index) = this;
    eq FColonSubscript.specify(int index)   = new FIntegerSubscript(index);

    // TODO: The names here needs to be clearer. (Down to and including getInstValueMod().)
    /**
     * Check if this InstComponentDecl is an assignable has an InstModification setting 
     * its binding expression.
     */
    syn boolean InstComponentDecl.hasInstValueMod() = (myInstValueMod() != null);

    /**
     * Check if this InstComponentDecl is an assignable with a value modifier
     */
    syn boolean InstComponentDecl.hasBindingExp() = false;
    eq InstAssignable.hasBindingExp()             = hasInstValueMod();

    /**
     * Retrieve the InstModification setting the binding expression of 
     * this component. 
     * 
     * If the component is not an assignable, or is an assignable that does 
     * not have a binding expression, return <code>null</code>.
     */
    syn InstValueModification InstComponentDecl.myInstValueMod() = null;
    syn lazy InstValueModification InstAssignable.myInstValueMod() = myInstValueModCalc();
    syn InstValueModification InstArrayComponentDecl.myInstValueMod() = myInstValueModCalc();
    
    syn InstValueModification InstComponentDecl.myInstValueModCalc() {
        InstValueModification ivm = parentInstValueMod();
        if (ivm != null) {
            return ivm;
        }
        for (InstModification im : totalMergedEnvironment()) {
            if (im.hasInstValueMod()) {
                return im.getInstValueMod();
            }
        }
        return null;
    }

    /**
     * Retrieve the InstModification setting the binding expression of 
     * the parent component. 
     * 
     * If the parent component is not an assignable, or is an assignable that does 
     * not have a binding expression, return <code>null</code>.
     */
    inh InstValueModification InstComponentDecl.parentInstValueMod();
    eq Root.getChild().parentInstValueMod()              = null;
    eq FExp.getChild().parentInstValueMod()              = null;
    eq InstClassDecl.getChild().parentInstValueMod()     = null;
    eq InstComponentDecl.getChild().parentInstValueMod() = myInstValueMod();
    
    /**
     * Check if this InstValueModification is part of a modification 
     * that is declared "each".
     */
    syn boolean InstModification.hasEach() = inModWithEach();
    eq InstArgument.hasEach()              = getEach() || inModWithEach();

    /**
     * Check if this modification is in another modification that is declared "each".
     */
    inh boolean InstModification.inModWithEach();
    eq InstArgument.getChild().inModWithEach()          = hasEach();
    eq InstNode.getChild().inModWithEach()              = false;
    eq InstRecordConstructor.getChild().inModWithEach() = false;
    eq InstArrayModification.getChild().inModWithEach() = true;
    syn boolean InstArrayModification.inModWithEach()   = true;

    /**
     * \ingroup aspect_Flattening
     * 
     * Check if a modification has a value modification.
     */
    syn boolean InstModification.hasInstValueMod() = false;

    /**
     * \ingroup aspect_Flattening
     * 
     * Check if a modification has a value modification. True for
     * InstValueModification.
     */
    eq InstValueModification.hasInstValueMod() = true;
    
    /**
     * \ingroup aspect_Flattening
     * 
     * Check if a modification has a value modification. Delegate computation
     * to son.
     */
    eq InstCompleteModification.hasInstValueMod() = hasInstValueModification();
    
    syn FExp InstModification.instValueMod()   = null;
    eq InstValueModification.instValueMod()    = getFExp();
    eq InstCompleteModification.instValueMod() = getInstValueModification().getFExp();
    
    syn InstValueModification InstModification.getInstValueMod() = null;
    eq InstValueModification.getInstValueMod()    = this;
    eq InstCompleteModification.getInstValueMod() = getInstValueModification();
    
    /**
     * Delegate object that retrieves the FExp of an InstValueModification, and 
     *        possibly alters it.
     * 
     * Default implementation only retrieves the expression.
     */
    public class AttributeExpRetriever {
        public FExp retrieve(InstValueModification im, boolean isEach) { return im.instValueMod(); }
        public static final AttributeExpRetriever DEFAULT = new AttributeExpRetriever();
    }

    public void ASTNode.collectAttributes(
            List<FAttribute> attrs, FQName prefix, AttributeExpRetriever aer, boolean cls) {
        for (int i = 0; i < getNumChild(); i++)
            getChild(i).collectAttributes(attrs, prefix, aer, cls);
    }

    // This is just to avoid collecting ComponentModification:s that resides inside
    // ClassRedeclares.
    public void InstClassRedeclare.collectAttributes(
            List<FAttribute> attrs, FQName prefix, AttributeExpRetriever aer, boolean cls) {}

    syn boolean InstComponentDecl.isBuiltIn() = false;
    eq InstBuiltIn.isBuiltIn()                = true;

    public void InstComponentModification.collectAttributes(
            List<FAttribute> attrs, FQName prefix, AttributeExpRetriever aer, boolean cls) {
        if (hasInstModification()) {
            InstModification im = getInstModification();
            boolean attr_set = findMatching(attrs, getName().name()) != null;
            // If attribute is not set, add to list
            if (!attr_set && (cls || !im.isOnPrimitiveTypeDecl())) {
                FIdUse typeName = new FIdUse(getName().myInstComponentDecl().myInstClass().name());
                FIdDecl name = new FIdDecl(new FQNameString(getName().name()));
                FAttribute a = new FAttribute(typeName, name, true, modificationLevel());
                if (im.hasInstValueMod() && getName().myInstComponentDecl().isBuiltIn()) {
                    InstValueModification ivm = im.getInstValueMod();
                    a.setValue(aer.retrieve(ivm, ivm.hasEach()).flatten(prefix));
                }
                if (getComponentModification().hasEach())
                    a.setFEach(new FEach());
                if (getComponentModification().hasFinal())
                    a.setFFinal(new FFinal());
                List<FAttribute> l = new List<FAttribute>();
                l.addAll(a.getFAttributes());
                im.collectAttributes(l, prefix, aer, cls);
                a.setFAttributeList(l);
                if (a.hasValue() || a.getNumFAttributeNoTransform() > 0) {
                    attrs.add(a);
                }
            }
        }
    }

    inh boolean InstModification.isOnPrimitiveTypeDecl();
    eq InstExtends.getChild().isOnPrimitiveTypeDecl()           = extendsPrimitive();
    eq InstNode.getChild().isOnPrimitiveTypeDecl()              = false;
    eq InstRecordConstructor.getChild().isOnPrimitiveTypeDecl() = false;


    /**
     * Get the modification level that is set for containing InstNode.
     * 
     * @throws UnsupportedOperationException  if setModificationLevel() has not been called on surrounding InstNode
     */
    inh int InstModification.modificationLevel();
    eq Root.getChild().modificationLevel()     = 0;
    eq InstNode.getChild().modificationLevel() = myModificationLevel;

    /**
     * Set the modification level for contained modifications.
     * 
     * @throws IllegalArgumentException  if level is negative
     */
    public HashMap<InstNode,Integer> InstNode.setModificationLevel(int level) {
        HashMap<InstNode,Integer> old = new HashMap<InstNode,Integer>();
        setModificationLevelHelper(old, level);
        return old;
    }

    public void InstNode.setModificationLevelHelper(HashMap<InstNode,Integer> old, int level) {
        myModificationLevel = level;
        old.put(this, myModificationLevel);
        for (InstNode extra : extraNodesToSetModLevelFor()) {
            if (extra != null && !old.containsKey(extra)) {
                extra.setModificationLevelHelper(old, extra.nextModLevelForExtraNode(level));
            }
        }
    }

    public void InstNode.clearModificationLevel(HashMap<InstNode,Integer> old) {
        for (InstNode n : old.keySet()) {
            n.myModificationLevel = old.get(n);
        }
    }

    syn int InstNode.nextModLevelForExtraNode(int level)                  = level + 1;
    eq InstExtendsShortClass.nextModLevelForExtraNode(int level)          = level;
    eq InstReplacingExtendsShortClass.nextModLevelForExtraNode(int level) = level;
    eq InstInlineExtends.nextModLevelForExtraNode(int level)              = level;

    inh InstNode InstNode.parentNodeToSetModLevelFor();
    eq InstClassDecl.getChild().parentNodeToSetModLevelFor()    = hasModificationLevel() ? null : this;
    eq InstExtends.getChild().parentNodeToSetModLevelFor()      = hasModificationLevel() ? null : this;
    eq InstRoot.getChild().parentNodeToSetModLevelFor()         = null;
    eq Root.getChild().parentNodeToSetModLevelFor()             = null;

    syn InstNode[] InstNode.extraNodesToSetModLevelFor()        = listExtraNodesToSetModLevelFor(false);
    eq InstComponentDecl.extraNodesToSetModLevelFor()           = listExtraNodesToSetModLevelFor(true, myInstClass());
    eq InstExtends.extraNodesToSetModLevelFor()                 = listExtraNodesToSetModLevelFor(true, myInstClass());
    eq InstClassDecl.extraNodesToSetModLevelFor()               = listExtraNodesToSetModLevelFor(true);
    eq InstSimpleShortClassDecl.extraNodesToSetModLevelFor()    = listExtraNodesToSetModLevelFor(false, actualInstClass());
    eq InstLibNode.extraNodesToSetModLevelFor()                 = listExtraNodesToSetModLevelFor(false, actualInstClass());
    eq InstReplacingComposite.extraNodesToSetModLevelFor()      = 
        listExtraNodesToSetModLevelFor(true, getInstComponentRedeclare().getInstComponentDecl(), myInstClass());
    eq InstReplacingRecord.extraNodesToSetModLevelFor()         = 
        listExtraNodesToSetModLevelFor(true, getInstComponentRedeclare().getInstComponentDecl(), myInstClass());
    eq InstReplacingPrimitive.extraNodesToSetModLevelFor()      = 
        listExtraNodesToSetModLevelFor(true, getInstComponentRedeclare().getInstComponentDecl(), myInstClass());
    eq InstReplacingFullClassDecl.extraNodesToSetModLevelFor()  = 
        listExtraNodesToSetModLevelFor(true, getInstClassRedeclare().redeclaringInstClassDecl());
    eq InstReplacingShortClassDecl.extraNodesToSetModLevelFor() = 
        listExtraNodesToSetModLevelFor(true, getInstClassRedeclare().redeclaringInstClassDecl());
    eq InstReplacingSimpleShortClassDecl.extraNodesToSetModLevelFor() = 
        listExtraNodesToSetModLevelFor(false, getInstClassRedeclare().redeclaringInstClassDecl(), actualInstClass());

    protected InstNode[] InstNode.listExtraNodesToSetModLevelFor(boolean ext, InstNode... nodes) {
        InstNode[] res = new InstNode[nodes.length + (ext ? getNumInstExtends() : 0) + 1];
        System.arraycopy(nodes, 0, res, 0, nodes.length);
        for (int i = nodes.length; i < res.length - 1; i++) {
            res[i] = getInstExtends(i - nodes.length);
        }
        res[res.length - 1] = parentNodeToSetModLevelFor();
        return res;
    }

    private int InstNode.myModificationLevel = Integer.MAX_VALUE;

    syn boolean InstNode.hasModificationLevel() = myModificationLevel != Integer.MAX_VALUE;

}

aspect FlatteningDebug {
    coll HashSet<InstAccess> FClass.collectInstAccesses() [new HashSet<InstAccess>()] with add root FClass;
    InstAccess contributes
        this 
    to FClass.collectInstAccesses() for myFClass();
    inh FClass InstAccess.myFClass();

}


aspect InstNodeInterface {

    syn ArraySubscripts InstComponentDecl.arraySubscripts() = 
        getComponentDecl().arraySubscripts()!=null?
            getComponentDecl().arraySubscripts(): null;

}


aspect FlatExpressions {
    
    public FAttribute FAttribute.flatten(FQName prefix) {
        FAttribute flat = createEmptyNode();
        flat.setType(getType().fullCopy());
        flat.setName(getName().fullCopy());
        if (hasValue())
            flat.setValue(getValue().flatten(prefix));
        flat.setLevel(getLevel());
        if (hasFEach())
            flat.setFEach(getFEach().fullCopy());
        if (hasFFinal())
            flat.setFFinal(getFFinal().fullCopy());
        List<FAttribute> flatAttrs = new List<FAttribute>();
        for (FAttribute attr : getFAttributes())
            flatAttrs.add(attr.flatten(prefix));
        flat.setFAttributeList(flatAttrs);
        return flat;
    }

    public FArraySubscripts FArraySubscripts.flatten(FQName prefix) {
        List l = new List();
        for (FSubscript fs : getFSubscripts())
            l.add(fs.flatten(prefix));
        return new FArraySubscripts(l);
    }

    abstract public FSubscript FSubscript.flatten(FQName prefix);

    public FSubscript FColonSubscript.flatten(FQName prefix) {
        if (expandSize()) {
            return size().flattenSubscript(0);
        } else {
            return new FColonSubscript();
        }
    }
    
    inh boolean FSubscript.expandSize();
    inh boolean FEndExp.expandSize();
    eq Root.getChild().expandSize()             = true;
    eq InstNode.getChild().expandSize()         = true;
    eq FIdUse.getChild().expandSize()           = true;
    eq InstDot.getInstAccess(int i).expandSize() {
        for (int j = 0; j < i; j++) {
            if (!getInstAccess(j).indexVariability().indexParameterOrLess()) {
                return false;
            }
        }
        return true;
    }
    
    public FSubscript Size.flattenSubscript(int i) {
        return new FExpSubscript(new FRangeExp(new FIntegerLitExp(1),new FIntegerLitExp(get(i))));
    }
    
    public FSubscript MutableSize.flattenSubscript(int i) {
        if (isUnknown()) {
            return new FColonSubscript();
        } else {
            return super.flattenSubscript(i);
        }
    }
    
    public FArraySubscripts Size.flattenSubscript() {
        if (ndims() == 0) {
            return null;
        }
        FArraySubscripts fas = new FArraySubscripts();
        for (int i = 0; i < ndims(); i++) {
            fas.addFSubscript(flattenSubscript(i));
        }
        return fas;
    }
    
    public FSubscript FIntegerSubscript.flatten(FQName prefix) { 
        return new FIntegerSubscript(getValue());
    }

    public FSubscript FExpSubscript.flatten(FQName name) {
        return new FExpSubscript(getFExp().flatten(name));
    }

    public FExp FExp.flatten(FQName prefix) {
        throw new UnsupportedOperationException();
    }

    public FIgnoredBuiltIn FIgnoredBuiltIn.flatten(FQName prefix) {
        return new FIgnoredBuiltIn();
    }

    @Override
    public FExp FDeferExp.flatten(FQName prefix) {
        return getFExp().flatten(getFExp().retrieveFQName());
    }

    /**
     * Separate method for extensibility.
     */
    private FIdUseExp InstComponentDecl.createFIdUseExp(FQName name, int order) {
        if (order > 0) {
            return new FDerExp(name, order);
        } else {
            return new FIdUseExp(name);
        }
    }

    /**
     * Create a constant FSubscript.
     */
    public FSubscript CValue.createFSubscript() {
        return new FExpSubscript(buildLiteral());
    }
    
    public FSubscript CValueInteger.createFSubscript() {
        return new FIntegerSubscript(intValue());
    }

    public FExp FArray.flatten(FQName prefix) {
        if (isIterArray() && !size().isUnknown()) {
            return ((FIterExp)getFExp(0)).flattenArray(prefix);
        }
        List l = new List();
        for (FExp exp : getFExps()) {
            l.add(exp.flatten(prefix));
        }
        return createNode(l);
    }
    
    public FArray FIterExp.flattenArray(FQName prefix) {
        Iterable<CommonForIndex> forIndices = getForIndexs();
        Indices ind = Indices.create(forIndices);
        FArray res = flattenArray(prefix, forIndices, ind, ind.iterator(), ind.size(), 0);
        for (CommonForIndex fi : forIndices) {
            fi.clearEvaluationValue();
        }
        return res;
    }
    
    public FArray FIterExp.flattenArray(FQName prefix, Iterable<CommonForIndex> forIndices, Indices ind, Iterator<Index> indIt, Size s, int dim) {
        List<FExp> l = new List<FExp>();
        if (dim == s.ndims() - 1) {
            for (int i = 0; i < s.get(dim); i++) {
                ind.translate(indIt.next()).setValues(forIndices);
                getFExp().flushAllRecursive();
                l.add(getFExp().flatten(prefix));
            }
        } else {
            for (int i = 0; i < s.get(dim); i++) {
                l.add(flattenArray(prefix, forIndices, ind, indIt, s, dim+1));
            }
        }
        return new FArray(l);
    }
    
    public void Index.setValues(Iterable<? extends CommonForIndex> forIndices) {
        int i = 0;
        for (CommonForIndex fi : forIndices) {
            fi.setEvaluationValue(new CValueInteger(index[i++]));
        }
    }
    
    public FExp FReductionExp.flatten(FQName prefix) {
        if (isArray() && !size().isUnknown()) {
            return getArray().buildFlattened(prefix, this);
        }
        return (FReductionExp) createNode(getFExp().flatten(prefix));
    }
    
    public FExp FIterExp.flatten(FQName prefix) {
        if (!size().isUnknown()) {
            return getArray().buildFlattened(prefix, this);
        }
        List<CommonForIndex> fil = new List<CommonForIndex>();
        for (CommonForIndex fi : getForIndexList())
            fil.add(fi.flatten(prefix));
        return new FIterExp(getFExp().flatten(prefix), fil);
    }

    public FExp FSubscriptedExp.flatten(FQName prefix) {
        return new FSubscriptedExp(getFExp().flatten(prefix), getFArraySubscripts().flatten(prefix));
    }

    public FIdDecl FIdDecl.flatten(FQName prefix) {
        return (FIdDecl)fullCopy();
    }

    public FExp FRangeExp.flatten(FQName prefix) {
        List l = new List();
        for (FExp e : getFExps())
            l.add(e.flatten(prefix));
        return new FRangeExp(l);
    }

    public FLinspace FLinspace.flatten(FQName prefix) {
        return new FLinspace(getStartExp().flatten(prefix), 
                             getStopExp().flatten(prefix), 
                             getN().flatten(prefix));
    }

    public FExp FIfExp.flatten(FQName prefix) {
        if (getIfExpNoTransform().variability().knownParameterOrLess()) {
            try {
                CValue cval = getIfExpNoTransform().ceval();
                if (cval.hasBooleanValue()) {
                    return cval.booleanValue() ? 
                            getThenExp().flatten(prefix) : 
                            getElseExp().flatten(prefix);
                }
            } catch (ConstantEvaluationException e) {}
        }
        return new FIfExp(getIfExp().flatten(prefix),
                          getThenExp().flatten(prefix),
                          getElseExp().flatten(prefix));
    }

    public FExp FBinExp.flatten(FQName prefix) {
        InstClassDecl oper = overloadedOperator();
        if (oper == null)
            return createNode(getLeft().flatten(prefix), getRight().flatten(prefix));
        else if (oper.myInputs().get(0).ndims() != getLeft().ndims() || oper.myInputs().get(1).ndims() != getRight().ndims())
            return getArray().buildFlattened(prefix, this);
        else
            return oper.flattenOverloadedFunctionCall(prefix, getLeft(), getRight());
    }

    public FExp FUnaryExp.flatten(FQName prefix)   {
        InstClassDecl oper = overloadedOperator();
        if (oper == null)
            return createNode(getFExp().flatten(prefix));
        else if (oper.myInputs().get(0).ndims() != getFExp().ndims())
            return getArray().buildFlattened(prefix, this);
        else
            return oper.flattenOverloadedFunctionCall(prefix, getFExp());
    }

    /**
     * Create an FArray containing flattened subexpressions.
     */
    public FExp Array.buildFlattened(FQName prefix, FExp context) {
        return buildFArray(new FlattenedBuilder(prefix, context, 0));
    }

    public FExp Array.buildFlattened(FQName prefix, FExp context, int order) {
        return buildFArray(new FlattenedBuilder(prefix, context, order));
    }

    public class Array {
        /**
         * Helper object for {@link #buildFlattened(FQName, FExp)}.
         */
        protected static class FlattenedBuilder implements ElementBuilder {
            private FQName prefix;
            private FExp context;
            private int order;
            
            public FlattenedBuilder(FQName prefix, FExp context, int order) {
                this.prefix = prefix;
                this.context = context;
                this.order = order;
            }
            
            public FExp build(FExp e) {
                if (order > 0) {
                    return context.dynamicFExp(new InstHDerExp(e, order)).flatten(prefix);
                } else {
                    return context.dynamicFExp(e).flatten(prefix);
                }
            }
        }
    }

    public FExp FLitExp.flatten(FQName prefix)     { return fullCopy(); }
    public FExp FEnumLitExp.flatten(FQName prefix) { return new FEnumLitExp(getEnum(), getValue(), null); }
    
    public FExp FModFuncExp.flatten(FQName prefix) {
        FExp toRound = new FDivExp(getX().flatten(prefix), getY().flatten(prefix));
        FExp rounded = type().isInteger() ? new FIntegerFuncExp(toRound) : new FFloorFuncExp(toRound);
        return new FSubExp(getX().flatten(prefix), new FMulExp(rounded, getY().flatten(prefix)));
    }
        
    public FExp FEventGenExp.flatten(FQName prefix)    { return createNode(getX().flatten(prefix)); }
    public FExp FBinEventGenExp.flatten(FQName prefix) { return createNode(getX().flatten(prefix), getY().flatten(prefix)); }
    public FExp FRemFuncExp.flatten(FQName prefix)     { return new FSubExp(getX().flatten(prefix), new FMulExp(new FDivFuncExp(getX().flatten(prefix), getY().flatten(prefix)), getY().flatten(prefix)));}
    public FExp FUnaryBuiltIn.flatten(FQName prefix)   { return createNode(getFExp().flatten(prefix)); }
    public FExp FEdgeExp.flatten(FQName prefix)        { return new FAndExp(getFExp().flatten(prefix), new FNotExp(getFExp().flatten(prefix).createFPreExp())); }
    
    public FExp FLoadResource.flatten(FQName prefix)   {
        try {
            CValue cval = ceval();
            if (cval.hasStringValue()) {
                return createNode(new FStringLitExp(cval.stringValue()));
            }
        } catch (ConstantEvaluationException e) {}
        return createNode(getFExp().flatten(prefix));
    }
    
    // These operators save reference to source node in instance tree until end of flattening - used for error checking them
    public FExp FChangeExp.flatten(FQName prefix)      { return new FNeqExp(getFExp().flatten(prefix), FPreExp.create(getFExp().flatten(prefix), this)); }
    public FExp InstPreExp.flatten(FQName prefix)      {
        if (getFExp().variability().parameterOrLess()) {
            return getFExp().flatten(prefix);
        }
        return FPreExp.create(getFExp().flatten(prefix), this);
    }
    
    public FExp FExp.createFPreExp() {
        throw new UnsupportedOperationException("createFPreExp() is not supported for class type " + getClass().getSimpleName());
    }
    public FExp FIdUseExp.createFPreExp() {
        return new FPreExp(getFIdUseNoTransform());
    }
    public FExp FLitExp.createFPreExp() {
        return this;
    }
    public FExp FSubscriptedExp.createFPreExp() {
        return new FSubscriptedExp(getFExpNoTransform().createFPreExp(), 
                getFArraySubscriptsNoTransform());
    }
    public FExp FArray.createFPreExp() {
        return this; // Assume literal;
    }
    public FExp FRecordConstructor.createFPreExp() {
        return this; // Assume literal;
    }
    
    public FExp FNoArgBuiltIn.flatten(FQName prefix)             { return createEmptyNode(); }
    public FExp FMathematicalFunctionCall.flatten(FQName prefix) { return createNode(getFExp().flatten(prefix)); }
    public FExp FAtan2Exp.flatten(FQName prefix)                 { return createNode(getFExp().flatten(prefix), getY().flatten(prefix)); }
    public FExp FHomotopyExp.flatten(FQName prefix)              {
        if (myOptions().getStringOption("homotopy_type") == OptionRegistry.Homotopy.ACTUAL) {
            return getActual().flatten(prefix);
        }
        if (myOptions().getStringOption("homotopy_type") == OptionRegistry.Homotopy.SIMPLIFIED) {
            return getSimplified().flatten(prefix);
        }
        return createNode(getActual().flatten(prefix), getSimplified().flatten(prefix)); 
    }
    public FExp FSemiLinearExp.flatten(FQName prefix)   { return new FSemiLinearExp(getX().flatten(prefix), getPosSlope().flatten(prefix), getNegSlope().flatten(prefix)); }
    public FExp FDelayExp.flatten(FQName prefix)        { return createNode(getFExp().flatten(prefix), getDelay().flatten(prefix), hasMax() ? new Opt(getMax().flatten(prefix)) : new Opt()); }
    public FExp FGetInstanceName.flatten(FQName prefix) { return new FStringLitExp(calcInstanceName()); }
    public FExp FSpatialDistExp.flatten(FQName prefix)     {
        return new FSpatialDistExp(
            getIn0().flatten(prefix), getIn1().flatten(prefix), 
            getX().flatten(prefix), getPositiveVelocity().flatten(prefix),
            getInitialPoints().flatten(prefix), getInitialValues().flatten(prefix)
        );
    }

    public FUnsupportedBuiltIn FUnsupportedBuiltIn.flatten(FQName prefix) { throw new UnsupportedOperationException(); }
    
    public FCross        FCross.flatten(FQName prefix)        { return new FCross(getX().flatten(prefix), getY().flatten(prefix)); }
    public FOuterProduct FOuterProduct.flatten(FQName prefix) { return new FOuterProduct(getX().flatten(prefix), getY().flatten(prefix)); }
    public FSampleExp    FSampleExp.flatten(FQName prefix)    { return new FSampleExp(getOffset().flatten(prefix), getInterval().flatten(prefix)); }
    public FSmoothExp    FSmoothExp.flatten(FQName prefix)    { return new FSmoothExp(getOrder().flatten(prefix), getFExp().flatten(prefix)); }
    
    public FReinit FReinit.flatten(FQName prefix) {
        FReinit res = new FReinit(getVar().flatten(prefix), getFExp().flatten(prefix));
        res.setInstanceTreeSource(this);
        return res;
    }
    
    
    public FAssert FAssert.flatten(FQName prefix) {
        Opt level = hasLevel() ? new Opt(getLevel().flatten(prefix)) : new Opt();
        return createNode(getTest().flatten(prefix), getMsg().flatten(prefix), level); 
    }
    
    public FExp FCardinality.flatten(FQName prefix) { return createNode(getFExp().flatten(prefix)); }
    
    public FExp FDecouple.flatten(FQName prefix) { 
        return getFExp().flatten(prefix);
    }

    public FConnectionsOp FConnectionsOp.flatten(FQName prefix) { throw new UnsupportedOperationException(); }
    public FConnectionsOp FConnBoolOp.flatten(FQName prefix) {
        FConnBoolOp res = createNode(getA().flatten(prefix));
        res.connectionGraph = connectionGraph;
        return res;
    }
    
    public FStringExp FStringExp.flatten(FQName prefix) {
        FStringExp flattened = new FStringExp();
        flattened.setValue(getValue().flatten(prefix));
        if (hasMinimumLength())
            flattened.setMinimumLength(getMinimumLength().flatten(prefix));
        if (hasLeftJustified())
            flattened.setLeftJustified(getLeftJustified().flatten(prefix));
        if (hasSignificantDigits())
            flattened.setSignificantDigits(getSignificantDigits().flatten(prefix));
        if (hasFormat())
            flattened.setFormat(getFormat().flatten(prefix));
        return flattened;
    }
    public FExp FDotAddExp.flatten(FQName prefix) { 
        return type().isString() ? 
                new FStringAddExp(getLeft().flatten(prefix), getRight().flatten(prefix)) : 
                super.flatten(prefix);
    }
    
    public FMinMaxExp FMinMaxExp.flatten(FQName prefix) { 
        return createNode(getX().flatten(prefix), hasY() ? getY().flatten(prefix) : null); 
    }
    
    public FExp FSizeExp.flatten(FQName prefix) {
        return new FSizeExp(getFExp().flatten(prefix), 
                hasDim() ? new Opt<FExp>(getDim().flatten(prefix)) : new Opt<FExp>());
    }
    
    public FExp InstDerExp.flatten(FQName prefix) {
        return setLocationOf(getFExp().flattenDer(prefix, order()));
    }
    
    public FExp FExp.flattenDer(FQName prefix, int order) {
        return dynamicFExp(diff(TIME, order)).flatten(prefix);
    }
    
     public FExp FIdUseExp.flattenDer(FQName prefix, int order) {
         return setLocationOf(flatten(prefix, order));
     }

    public FInfArgsFunctionCall FInfArgsFunctionCall.flatten(FQName prefix) {
        List<FExp> l = new List<FExp>();
        for (FExp e : getFExps()) 
            l.add(e.flatten(prefix));
        return createNode(l); 
    }
    
    public FFillExp FFillExp.flatten(FQName prefix) {
        FFillExp res = (FFillExp) super.flatten(prefix);
        res.setFillExp(getFillExp().flatten(prefix));
        return res;
    }
    
    public FCatExp FCatExp.flatten(FQName prefix) {
        FCatExp res = (FCatExp) super.flatten(prefix);
        res.setDim(getDim().flatten(prefix));
        return res;
    }
    
    public FTimeExp FTimeExp.flatten(FQName prefix) { return setLocationOf(new FTimeExp()); }
    
    public FExp FEndExp.flatten(FQName prefix)  {
        if (expandSize()) {
            return mySize().flattenFExp(0);
        } else {
            return new FEndExp();
        }
    }
    
    public FExp Size.flattenFExp(int d) {
        return createFExp(d);
    }
    
    public FExp MutableSize.flattenFExp(int d) {
        if (exps[d] != null) {
            return exps[d].flatten(exps[d].sizeFlatteningPrefix());
        } else {
            return super.flattenFExp(d);
        }
    }
    
    inh FQName FExp.sizeFlatteningPrefix();
    eq Root.getChild().sizeFlatteningPrefix()          = new FQNameEmpty();
    eq InstNode.getChild().sizeFlatteningPrefix()      = retrieveFQName();
    eq InstClassDecl.getChild().sizeFlatteningPrefix() = new FQNameEmpty();
    
    inh FExp DummyModification.myFExp();
    eq InstFunctionArgument.getChild().myFExp()   = null;
    eq InstPositionalArgument.getChild().myFExp() = getFExp();
    eq InstNamedArgument.getChild().myFExp()      = getFExp();
    eq Root.getChild().myFExp()                   = null;

    public FRecordConstructor InstRecordConstructor.flatten(FQName prefix) {
        List<FExp> args = new List();
        for (InstFunctionArgument ifa : getArgs()) {
            args.add(ifa.flatten(prefix));
        }
        return new FRecordConstructor(getRecord().flattenRecordName(), args);
    }

    public FExp InstComponentDecl.flattenInRecordConstructor(FQName prefix) {
        return null;
    }
    
    public FExp InstAssignable.flattenInRecordConstructor(FQName prefix) {
        if (hasBindingFExp()) {
            return flattenBindingFExp();
        } else {
            return cevalNoBExp(defaultVariableEvaluator(), Index.NULL).buildLiteral();
        }
    }
    
    public FIdUse InstAccess.flattenRecordName() {
        return new FIdUse(myInstClassDecl().qualifiedName());
    }
    
    public FFunctionCall FFunctionCall.flatten(FQName prefix) {
        List args = new List();
        for (FExp e : getArgs()) 
            args.add(e.flatten(prefix));
        getFTypeNoTransform().clearFlattened();
        return new FFunctionCall(getName().flatten(new FQNameEmpty()), args, getFType().flatten(prefix, null, true));
    }
    
    public void ASTNode.clearFlattened() {
        for (ASTNode n : noTransform()) {
            n.clearFlattened();
        }
    }
    public void FRecordType.clearFlattened() { flattened = false; super.clearFlattened(); }
    public void FFunctionType.clearFlattened() { flattened = false; super.clearFlattened(); }

    public FFunctionCall InstFunctionCall.flatten(FQName prefix) {
        List args = new List();
        for (InstFunctionArgument e : getArgs()) 
            args.add(e.flatten(prefix));
        InstCallable target = myInstCallable().actualInstCallable();
        FIdUse name = new FIdUse(new FQNameString(target.qualifiedName()));
        return createFFunctionCall(name, args, getFType().flatten(prefix, null, true));
    }

    public FFunctionCall InstFunctionCall.createFFunctionCall(FIdUse name, List args, FType type) {
        return setLocationOf(new FFunctionCall(name, args, type));
    }
    
    public FFunctionCall InstPartialFunctionCall.createFFunctionCall(FIdUse name, List args, FType type) {
        List<FIdUse> argNames = new List<FIdUse>();
        for (String s : namedArgs())
            argNames.add(new FIdUse(s));
        return new FPartialFunctionCall(name, args, type, argNames);
    }

    public FFunctionCall InstVectorFunctionCall.createFFunctionCall(FIdUse name, List args, FType type) {
        boolean[] vectorFlags = new boolean[getNumArg()];
        int i = 0;
        for (InstFunctionArgument e : getArgs())
            vectorFlags[i++] = e.isVectorized();
        return new FVectorFunctionCall(name, args, type, size(), vectorFlags);
    }

    public FFunctionCall InstClassDecl.flattenOverloadedFunctionCall(FQName prefix, FExp... args) {
        FType[] argTypes = new FType[args.length];
        for (int i = 0; i < args.length; i++)
            argTypes[i] = args[i].type();
        return flattenOverloadedFunctionCall(prefix, args, argTypes);
    }

    public FFunctionCall InstClassDecl.flattenOverloadedFunctionCall(FQName prefix, FExp[] args, FType[] argTypes) {
        // TODO: handle array operations (scalar * matrix, etc)
        FIdUse name = new FIdUse(new FQNameString(qualifiedName()));
        int nIn = myInputs().size();
        if (nIn > args.length)
            args = Arrays.copyOf(args, nIn);
        Map<InstComponentDecl,FExp> argMap = new HashMap<InstComponentDecl,FExp>();
        for (int i = 0; i < nIn; i++) {
            InstComponentDecl in = myInputs().get(i);
            argMap.put(in, args[i]);
        }
        FExp.FunctionContextReplacer crp = new FExp.ExpFunctionContextReplacer(argMap);
        for (int i = 0; i < nIn; i++) {
            InstComponentDecl in = myInputs().get(i);
            if (args[i] == null) {
                args[i] = crp.get(in).flatten(prefix);
            } else if (!in.type().typeCompatible(argTypes[i], true)) {
                InstClassDecl constructor = in.type().matchOverloadedConstructor(argTypes[i]);
                args[i] = constructor.flattenOverloadedFunctionCall(prefix, args[i]);
            } else {
                args[i] = args[i].flatten(prefix);
            }
        }
        List<FExp> argList = new List<FExp>(args);
        return new FFunctionCall(name, argList, functionType().flatten(prefix, null, true));
    }

    public FExp InstFunctionArgument.flatten(FQName prefix) {
        return getFExp().flatten(prefix);
    }

    public FExp InstDefaultArgument.flatten(FQName prefix) {
        return getFExp().flatten(getFExp().retrieveFQName());
    }

    public abstract FForIndex CommonForIndex.flatten(FQName prefix);

    @Override
    public FForIndex InstForIndex.flatten(FQName prefix) {
        return new FForIndex(getInstPrimitive().createFVariable(), getFExp().flatten(prefix));
    }

    @Override
    public FForIndex FForIndex.flatten(FQName prefix) {
        return (FForIndex) fullCopy();
    }

    /**
     * Flatten variability specifier.
     *
     * This is done during variability calculation to keep compatibility with FExp. 
     */
    abstract public FTypePrefixVariability TypePrefixVariability.flatten();
    public FTypePrefixVariability Continuous.flatten()     { return fContinuous();     }
    public FTypePrefixVariability Discrete.flatten()       { return fDiscrete();       }
    public FTypePrefixVariability Parameter.flatten()      { return fFixedParameter(); }
    public FTypePrefixVariability IndexParameter.flatten() { return fIndexParameter(); }
    public FTypePrefixVariability Constant.flatten()       { return fConstant();       }
}

aspect InstantiatedExpressions {

    
    public FEquationType AbstractEquation.equationType() {
        return isInitial() ? new FInitialEquation() : new FNormalEquation();
    }

    public FEquationType Algorithm.equationType() {
        return hasInitial() ? new FInitialEquation() : new FNormalEquation();
    }

    public <T extends FAbstractEquation> T AbstractEquation.copyStringComment(T eqn) {
        if (getComment().hasStringComment()) {
            eqn.setFStringComment(getComment().getStringComment().flatten());
        }
        return eqn;
    }

    syn String AbstractEquation.stringComment() =
            getComment().hasStringComment() ? getComment().getStringComment().getComment() : null;

    public FAbstractEquation AbstractEquation.instantiate() {
        return contribute(copyLocationTo(new FUnsupportedEquation(equationType())));
    }

    public FAbstractEquation Equation.instantiate() {
        return contribute(copyLocationTo(copyStringComment(new FEquation(
                equationType(), getLeft().instantiate(), getRight().instantiate()))));
    }
    
    public FAbstractEquation ConnectClause.instantiate() {
        FConnectClause c = new FConnectClause(equationType(), this,
                new FIdUseInstAccess(getConnector1().newInstAccess()),
                new FIdUseInstAccess(getConnector2().newInstAccess()));
        c.setLocation(this);
        return contribute(copyStringComment(c));
    }
    
    protected FIfWhenElseEquation IfWhenElseEquation.instantiate(FIfWhenElseEquation res) {
        res.setType(equationType());
        for (AbstractEquation eqn : getAbstractEquations())
            res.addFAbstractEquation(eqn.instantiate());
        res.setLocation(this);
        return contribute(copyStringComment(res));
    }
    
    protected FIfWhenEquation IfWhenEquation.instantiate(FIfWhenEquation res) {
        super.instantiate(res);
        res.setTest(getTest().instantiate());
        if (hasElse())
            res.setElse(getElse().instantiate());
        return res;
    }
    
    public abstract FIfWhenElseEquation IfWhenElseEquation.instantiate();
    
    public FIfWhenElseEquation IfEquation.instantiate() {
        return instantiate(new FIfEquation());
    }
    
    public FIfWhenElseEquation WhenEquation.instantiate() {
        return instantiate(new FWhenEquation());
    }
    
    public FIfWhenElseEquation ElseEquation.instantiate() {
        return instantiate(new FElseEquation());
    }
        
    public FFunctionCallEquation FunctionCallEquation.instantiate() {
        List<FFunctionCallLeft> l = new List<FFunctionCallLeft>();
        for (FunctionCallLeft a : getLefts()) 
            l.add(a.instantiate());
        return contribute(copyLocationTo(copyStringComment(
                new FFunctionCallEquation(equationType(), l, getCall().instantiate()))));
    }
    
    public  FFunctionCallLeft FunctionCallLeft.instantiate() {
        Opt id = hasAccess() ? 
                new Opt(setLocationOf(new FIdUseExp(new FIdUseInstAccess(getAccess().newInstAccess())))) : 
                new Opt();
        return new FFunctionCallLeft(id);
    }
    
    public FAlgorithm Algorithm.instantiate() {
        List l = Statement.instantiateStatementList(getStatements());
        return copyLocationTo(new FAlgorithm(equationType(), l));
    }
    
    public InstExternal ExternalClause.instantiate() {
        // TODO: Interpret annotations and add information to InstExternal
        Opt lang = hasExternalLanguage() ? new Opt(getExternalLanguage().instantiate()) : new Opt();
        Opt call = hasExternalFunctionCall() ? new Opt(getExternalFunctionCall().instantiate()) : new Opt();
        return copyLocationTo(new InstExternal(this, lang, call));
    }
    
    public static final String FCExternalLanguage.LANGUAGE_STRING         = "C";
    public static final String FFortran77ExternalLanguage.LANGUAGE_STRING = "FORTRAN 77";
    public static final String FBuiltinExternalLanguage.LANGUAGE_STRING   = "builtin";
    
    public FExternalLanguage ExternalLanguage.instantiate() {
        String lang = getLanguage();
        if (lang.equals(FCExternalLanguage.LANGUAGE_STRING))
            return new FCExternalLanguage();
        else if (lang.equals(FFortran77ExternalLanguage.LANGUAGE_STRING))
            return new FFortran77ExternalLanguage();
        else if (lang.equals(FBuiltinExternalLanguage.LANGUAGE_STRING))
            return new FBuiltinExternalLanguage();
        else 
            return new FUnknownExternalLanguage(lang);
    }
    
    public InstExternalCall ExternalFunctionCall.instantiate() {
        InstExternalCall res = new InstExternalCall();
        if (hasReturnVar())
            res.setReturnVar(getReturnVar().newInstAccess());
        res.setName(getFunctionName().name());
        for (Exp e : getArgs())
            res.addArg(e.instantiate());
        return res;
    }
    
    public static List Statement.instantiateStatementList(List<Statement> l) {
        List l2 = new List();
        for (Statement s : l) 
            l2.add(s.instantiate());
        return l2;
    }
    
    public FStatement Statement.instantiate() {
        FStatement s = instantiateStatement();
        s.setLocation(this);
        return s;
    }
    
    protected abstract FStatement Statement.instantiateStatement();
    
    protected FStatement AlgorithmAnnotation.instantiateStatement() {
        return null;
    }
    
    protected FAssignStmt AssignStmt.instantiateStatement() {
        FIdUseExp left = new FIdUseExp(new FIdUseInstAccess(getLeft().newInstAccess()));
        left.setLocation(this);
        return new FAssignStmt(left, getRight().instantiate());
    }
    
    protected FFunctionCallStmt FunctionCallStmt.instantiateStatement() {
        List<FFunctionCallLeft> l = new List<FFunctionCallLeft>();
        for (FunctionCallLeft a : getLefts()) 
            l.add(a.instantiate());
        return new FFunctionCallStmt(l, getFunctionCall().instantiate());
    }
    
    protected FBreakStmt BreakStmt.instantiateStatement() {
        return new FBreakStmt();
    }
    
    protected FReturnStmt ReturnStmt.instantiateStatement() {
        return new FReturnStmt();
    }
    
    protected FIfWhenStmt IfWhenStmt.instantiateStatement() {
        List l = new List();
        for (IfWhenClause c : getIfWhenClauses()) 
            l.add(c.instantiate());
        return instantiateIfWhenStmt(l);
    }
    
    protected abstract FIfWhenStmt IfWhenStmt.instantiateIfWhenStmt(List l);
    
    protected FIfStmt IfStmt.instantiateIfWhenStmt(List icl) {
        List esl = new List();
        if (hasElseClause()) {
            esl = Statement.instantiateStatementList(getElseClause().getStmts());
        }
        return new FIfStmt(icl, esl);
    }
    
    protected FWhenStmt WhenStmt.instantiateIfWhenStmt(List l) {
        return new FWhenStmt(l);
    }
    
    public FIfWhenClause IfWhenClause.instantiate() {
        FExp t = getTest().instantiate();
        List l = Statement.instantiateStatementList(getStatements());
        FIfWhenClause c = instantiateIfWhenClause(t, l);
        c.setLocation(this);
        return c;
    }
    
    protected abstract FIfWhenClause IfWhenClause.instantiateIfWhenClause(FExp t, List l);
    
    protected FIfClause IfClause.instantiateIfWhenClause(FExp t, List l) {
        return new FIfClause(t, l);
    }
    
    protected FWhenClause WhenClause.instantiateIfWhenClause(FExp t, List l) {
        return new FWhenClause(t, l);
    }
    
    
    protected InstForStmt ForStmt.instantiateStatement() {
        List il = new List();
        for (ForIndex i : getForIndexList()) 
            il.add(i.instantiate());
        List sl = Statement.instantiateStatementList(getForStmtList().getStmts());
        return new InstForStmt(il, sl);
    }
    
    protected FWhileStmt WhileStmt.instantiateStatement() {
        List l = Statement.instantiateStatementList(getWhileStmts());
        return new FWhileStmt(getTest().instantiate(), l);
    }

    public FArraySubscripts ArraySubscripts.instantiate() {
        List l = new List();
        for (Subscript s : getSubscripts())
            l.add(s.instantiate());
        return copyLocationTo(new FArraySubscripts(l));
    }
    
    abstract public FSubscript Subscript.instantiate();
    public FSubscript ColonSubscript.instantiate() { 
        return copyLocationTo(new FColonSubscript());
    }
    
    public FSubscript ExpSubscript.instantiate() {
        return copyLocationTo(new FExpSubscript(getExp().instantiate()));
    }
    
    public FExp Exp.instantiate() {
        return copyLocationTo(new FUnsupportedExp());
    }

    
    public InstDerExp DerExp.instantiate() {
        return copyLocationTo(new InstDerExp(getExp().instantiate()));
    }
    

    public FExp AccessExp.instantiate() {
        return copyLocationTo(new FIdUseExp(new FIdUseInstAccess(getAccess().newInstAccess())));
    }


    public InstAccess Access.instantiate() { 
        return copyLocationTo(newInstAccess());
    }

    public FExp ArrayConstructor.instantiate() {
       List l = new List();
       for (Exp e : getFunctionArguments().getExps())
           l.add(e.instantiate());
       return copyLocationTo(new FArray(l));
    }
    
    public FExp IterExp.instantiate() {
        List<CommonForIndex> ifil = new List<CommonForIndex>();
        // Add indices backwards, since they should be interpreted in the opposite order compared to for loops
        for (int i = getNumForIndex() - 1; i >= 0; i--)
            ifil.add(getForIndex(i).instantiate());
        return copyLocationTo(new FIterExp(getExp().instantiate(), ifil));
    }

    public FExp RangeExp.instantiate() {
        List l = new List();
        for (Exp e : getExps()) 
            l.add(e.instantiate());
        return copyLocationTo(new FRangeExp(l));
    }

    public FExp IfExp.instantiate() {
        FIfExp n = new FIfExp(getIfExp().instantiate(),
                              getThenExp().instantiate(),
                              getElseExp().instantiate());
        return copyLocationTo(n);
    }

    public FExp Matrix.instantiate() {
        FMatrix m = new FMatrix();
        for (MatrixRow r : getRows())
            m.addFExp(r.instantiate());
        return copyLocationTo(m);
    }
    
    public FMatrixRow MatrixRow.instantiate() {
        FMatrixRow r = new FMatrixRow();
        for (Exp e : getExps())
            r.addFExp(e.instantiate());
        return copyLocationTo(r);
    }
    
    public FExp AddExp.instantiate() { 
        return copyLocationTo(new FAddExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp SubExp.instantiate() { 
        return copyLocationTo(new FSubExp(getLeft().instantiate(),getRight().instantiate()));
    }

    public FExp MulExp.instantiate() { 
        return copyLocationTo(new FMulExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp DivExp.instantiate() { 
        return copyLocationTo(new FDivExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp PowExp.instantiate() { 
        return copyLocationTo(new FPowExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp DotAddExp.instantiate() { 
        return copyLocationTo(new FDotAddExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp DotSubExp.instantiate() { 
        return copyLocationTo(new FDotSubExp(getLeft().instantiate(),getRight().instantiate()));
    }

    public FExp DotMulExp.instantiate() { 
        return copyLocationTo(new FDotMulExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp DotDivExp.instantiate() { 
        return copyLocationTo(new FDotDivExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp DotPowExp.instantiate() { 
        return copyLocationTo(new FDotPowExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp NegExp.instantiate() { 
        return copyLocationTo(new FNegExp(getExp().instantiate()));
    }

    public FExp LtExp.instantiate() { 
        return copyLocationTo(new FLtExp(getLeft().instantiate(),getRight().instantiate()));
    }

    public FExp LeqExp.instantiate() { 
        return copyLocationTo(new FLeqExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp GtExp.instantiate() { 
        return copyLocationTo(new FGtExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp GeqExp.instantiate() { 
        return copyLocationTo(new FGeqExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp EqExp.instantiate() { 
        return copyLocationTo(new FEqExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp NeqExp.instantiate() { 
        return copyLocationTo(new FNeqExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp NotExp.instantiate() { 
        return copyLocationTo(new FNotExp(getExp().instantiate()));
    }
    
    public FExp OrExp.instantiate() { 
        return copyLocationTo(new FOrExp(getLeft().instantiate(),getRight().instantiate()));
    }
    
    public FExp AndExp.instantiate() { 
        return copyLocationTo(new FAndExp(getLeft().instantiate(),getRight().instantiate()));
    }

    public FExp RealLitExp.instantiate() {
        double value = Double.parseDouble(getUNSIGNED_NUMBER());
        return copyLocationTo(new FRealLitExp(value));
    }
    
    public FExp IntegerLitExp.instantiate() { 
        try {
            int value = Integer.parseInt(getUNSIGNED_INTEGER());
            return copyLocationTo(new FIntegerLitExp(value));
        } catch (NumberFormatException e) {
            double value = Double.parseDouble(getUNSIGNED_INTEGER());
            return copyLocationTo(new FOverflowIntLitExp(value, getUNSIGNED_INTEGER()));
        }
    }
    
    public FExp StringLitExp.instantiate() { 
        return copyLocationTo(new FStringLitExp(getSTRING()));
    }
    
    public FExp BooleanLitExpTrue.instantiate() { 
        return copyLocationTo(new FBooleanLitExpTrue());
    }
    
    public FExp BooleanLitExpFalse.instantiate() { 
        return copyLocationTo(new FBooleanLitExpFalse());
    }
    
    public FExp TimeExp.instantiate() { 
        return copyLocationTo(new FTimeExp());
    }   

    public FExp EndExp.instantiate() { 
        return copyLocationTo(new FEndExp());
    }
    
    public InstNamedArgument NamedArgument.instantiate() {
        return copyLocationTo(new InstNamedArgument(getExp().instantiate(), getName().instantiate()));
    }
    
    protected FAbstractFunctionCall FunctionCall.createInstNode(InstAccess name, List<InstFunctionArgument> args) {
        return new InstFunctionCall(name, args);
    }
    
    protected FAbstractFunctionCall PartialFunctionCall.createInstNode(InstAccess name, List<InstFunctionArgument> args) {
        return new InstPartialFunctionCall(name, args);
    }
    
    public FAbstractFunctionCall FunctionCall.instantiate() {
        // Instantiate arguments
        List<InstFunctionArgument> args = new List<InstFunctionArgument>();
        if (hasFunctionArguments()) {
            int i = 0;
            for (Exp arg : getFunctionArguments().getExpList()) {
                InstPositionalArgument iarg = new InstPositionalArgument(arg.instantiate(), i++);
                iarg.setLocation(arg);
                args.add(iarg);
            }
            for (NamedArgument arg : getFunctionArguments().getNamedArguments())
                args.add(arg.instantiate());
        }
        
        // Create InstFunctionCall
        return copyLocationTo(createInstNode(getName().newInstAccess(), args));
    }

    public InstForIndex ForIndex.instantiate() {
        InstForIndexPrimitive ip = new InstForIndexPrimitive(getForIndexDecl().name(), 
                new InstParseAccess("Integer"), new Opt<FArraySubscripts>(), getForIndexDecl(), 
                new Opt<InstModification>(), new Opt<InstConstrainingComponent>(), new Opt<FExp>());
        InstForIndex res;
        if (hasExp()) {
            res = new InstForIndexWithExp(ip, getExp().instantiate());
        } else {
            res = new InstForIndexNoExp(ip);
        }
        return copyLocationTo(res);
    }
    
    public InstForClauseE ForClauseE.instantiate() {
        List<InstForIndex> forIndex = new List();
        List<FAbstractEquation> eqns = new List();
        for (ForIndex fi : getForIndexs()) {
            forIndex.add(fi.instantiate());     
        }
        for (AbstractEquation ae : getAbstractEquations()) {
            eqns.add(ae.instantiate());
        }
        return copyStringComment(new InstForClauseE(equationType(), forIndex, eqns));
    }

}

aspect AttributeContributer {
    
    /**
     * Class used during instantiation of equations and flattening of variables
     * to delecate to different contributers. This class is subtyped for each
     * contributer!
     */
    public abstract class AttributeContributer {
        private final String name;

        public AttributeContributer(String name) {
            this.name = name;
        }

        /**
         * This method is called during instantiation when an equation is
         * created.
         * Instance accesses are expected if component references are made.
         */
        protected abstract void contribute(AbstractEquation src, FAbstractEquation dest);

        /**
         * This method is called during flattening of components. All
         * expressions that are added must be flattened.
         */
        protected abstract void contribute(InstAssignable src, FVariable dest);

        /**
         * This method is called during flattening of functions. All
         * expressions that are added must be flattened.
         */
        protected abstract void contribute(InstBaseClassDecl src, FFunctionDecl dest);

        /**
         * This method is called during flattening of the model. All
         * expressions that are added must be flattened.
         */
        protected abstract void contribute(InstNode src, FClass dest);

        /**
         * This method is called in order to determine if an attribute should
         * be considered as active. Return true if the attributes that was
         * added earlier alters the models behaviour.
         */
        protected abstract boolean containsActiveAttributes(FAbstractEquation equation);

        /**
         * This method is called in order to determine if an attribute should
         * be considered as active. Return true if the attributes that was
         * added earlier alters the models behaviour.
         */
        protected abstract boolean containsActiveAttributes(FVariable variable);

        /**
         * This method is called in order to determine if an attribute should
         * be considered as active. Return true if the attributes that was
         * added earlier alters the models behaviour.
         */
        protected abstract boolean containsActiveAttributes(FFunctionDecl function);

        /**
         * This method is called in order to determine if an attribute should
         * be considered as active. Return true if the attributes that was
         * added earlier alters the models behaviour.
         */
        protected abstract boolean containsActiveAttributes(FClass fClass);

        @Override
        public String toString() {
            return name;
        }
    }

    /**
     * A list that contains all attribute contributers. New contributers are added
     * dynamically during static evaluation by calling addAttributeContributer().
     * 
     * @see ASTNode.addAttributeContributer()
     */
    private static Collection<AttributeContributer> ASTNode.ATTRIBUTE_CONTRIBUTES;
    
    /**
     * Add InstantiationContributer to the list of contributers. This method
     * should only be called from AbstractEquation in order to ensure that the
     * checker is added corretly during static evaluation, hence the private
     * visibility.
     */
    private static AttributeContributer ASTNode.addAttributeContributer(AttributeContributer contributer) {
        if (ATTRIBUTE_CONTRIBUTES == null)
            ATTRIBUTE_CONTRIBUTES = new ArrayList<AttributeContributer>();
        ATTRIBUTE_CONTRIBUTES.add(contributer);
        return contributer;
    }
    
    public static Collection<AttributeContributer> ASTNode.attributeContributers() {
        return Collections.unmodifiableCollection(ATTRIBUTE_CONTRIBUTES);
    }
    
    public class AbstractEquation {
        public <N extends FAbstractEquation> N contribute(N equation) {
            for (AttributeContributer contributer : attributeContributers())
                contributer.contribute(this, equation);
            return equation;
        }
    }
    
    public class InstAssignable {
        public <N extends FVariable> N contribute(N variable) {
            for (AttributeContributer contributer : attributeContributers())
                contributer.contribute(this, variable);
            return variable;
        }
    }
    
    public class InstBaseClassDecl {
        public <N extends FFunctionDecl> N contribute(N function) {
            for (AttributeContributer contributer : attributeContributers())
                contributer.contribute(this, function);
            return function;
        }
    }
    
    public class InstNode {
        public FClass contribute(FClass fClass) {
            for (AttributeContributer contributer : attributeContributers())
                contributer.contribute(this, fClass);
            return fClass;
        }
    }
    
}

aspect ComponentCount {
    private int FClass.numComponents = 0;

    protected void FClass.countComponent() {
        numComponents++;
    }

    public int FClass.numberOfComponents() {
        return numComponents;
    }
}

