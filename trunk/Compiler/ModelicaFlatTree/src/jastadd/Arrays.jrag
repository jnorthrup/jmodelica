/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Collection;
import java.util.HashSet;
import java.util.Map;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Iterator;
import java.util.NoSuchElementException;

aspect Arrays {

	/**
	 * Get the array subscripts of a ComponentDecl.
	 * 
	 * @return If the ComponentDecl has subscripts, then return these, otherwise
	 * null.
	 */
	syn lazy ArraySubscripts ComponentDecl.arraySubscripts() =
		hasVarArraySubscripts() ? getVarArraySubscripts() : null;

	/**
	 * Check if an expression is inside array subscripts.
	 */
	inh boolean FExp.inArraySubscripts();
	eq FArraySubscripts.getChild().inArraySubscripts() = true;
	eq FAbstractEquation.getChild().inArraySubscripts() = false;
	eq Root.getChild().inArraySubscripts() = false;
	
	/**
	 * Check if an access is an array access.
	 * 
	 * @return True if the access has array subscripts, otherwise false.
	 */
	syn boolean Access.isArrayAccess() = false;
	eq ArrayAccess.isArrayAccess() = hasArraySubscripts();
	
	/**
	 * Get the array subscripts of an access, if any.
	 * 
	 * @return The array subscripts of the access, if any, otherwise null.
	 */
	syn ArraySubscripts Access.arraySubscripts() = null;
	eq ArrayAccess.arraySubscripts() = hasArraySubscripts()? getArraySubscripts(): null;

	/**
	 * Return an Index with these array subscripts.
	 * 
	 * This version is cached, to avoid repeating constant evaluation.
	 * 
	 * @throws ConstantEvaluationException  if the subscripts can't be evaluated to 
	 *                                      constant Integer values.
	 */
	syn lazy Index FArraySubscripts.asIndex() = createIndex();
	
	/**
	 * Return an Index with these array subscripts.
	 * 
	 * This version is not cached, to allow indices to be re-evaluated at each use 
	 * during function evaluation.
	 * 
	 * @throws ConstantEvaluationException  if the subscripts can't be evaluated to 
	 *                                      constant Integer values.
	 */
	public Index FArraySubscripts.createIndex() {
		int[] i = new int[getNumFSubscript()];
		int j = 0;
		for (FSubscript s : getFSubscripts()) 
			i[j++] = s.value();
		return new Index(i);
	}
	
	/**
	 * Get the dimensions to use in dimension conversion.
	 */
	syn lazy int[] FDimensionConvert.dimensionsToKeep();
	eq FScalarExp.dimensionsToKeep() = new int[] {};
	eq FVectorExp.dimensionsToKeep() {
		Size s = getFExp().size();
		int i = getFExp().ndims();
		for (i = (i > 0) ? i - 1 : 0; i > 0 && s.get(i) == 1; i--);
		return new int[] { i };
	}
	eq FMatrixExp.dimensionsToKeep() = new int[] { 0, 1 };

	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FAbstractEquation.ndims() = -1;
	eq FEquation.ndims() {
		if (getLeft().ndims() == getRight().ndims()) {
			return getLeft().ndims();
		}
		return -1;
	}

	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FArraySubscripts.ndims() { 
		return getNumFSubscript();
	}

	// Array dimensions
	/**
	 * Get array dimensions of array subscripts when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn lazy int FArraySubscripts.accessNdims() { 
		//log.debug("FArraySubscripts.accessNdims()");
		// Need to check if each individual subscript increases 
		// dimension. (ndims(x[1])=0)
		int nd = 0;
		for (FSubscript fs : getFSubscripts()) {
			nd += fs.ndims();
		}
		return nd;
	}
	
	/**
	 * Get array dimensions of a single part of an access.
	 */
	syn int InstAccess.localNdims() = 
		hasFArraySubscripts() ? getFArraySubscripts().accessNdims() : myInstComponentDecl().ndims();

	
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FSubscript.ndims();
	eq FExpSubscript.ndims()     = getFExp().ndims();
	eq FColonSubscript.ndims()   = 1;
	eq FIntegerSubscript.ndims() = 0;
	
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FExp.ndims() = 0;
	syn lazy int FAbstractArrayExp.ndims() = super.ndims();
	eq FInstAccessExp.ndims() = getInstAccess().ndims();
	eq FRangeExp.ndims() = 1;
	eq FLinspace.ndims() = 1;
	eq FArray.ndims() {
		if (isIterArray())
			return getFExp(0).ndims();
		if (getNumFExp()==0)  //Empty array
			return 1;
		// We assume that the FArray is set up correctly and that
		// all branches are equal.
		return getFExp(0).ndims() + 1;
	}
	eq FAbstractCat.ndims() {
		int ndims = 2;
		for (FExp e : getFExps())
			if (e.ndims() > ndims)
				ndims = e.ndims();
		return ndims;
	}
	eq FCatExp.ndims()         = getFExp(0).ndims();
	eq FReductionExp.ndims()   = getFExp().isIterExp() ? iterExp().ndims() : 0;
	eq FSubscriptedExp.ndims() = getFArraySubscripts().accessNdims();
	eq FIterExp.ndims() {
		int exp = getFExp().ndims();
		return (exp >= 0) ? exp + localNdims() : -1;
	}
	
	/**
	 * The number of dimensions of the iteration indices of this iteration expression.
	 */
	syn int FIterExp.localNdims() = getNumForIndex();
	
	eq FSymmetric.ndims()    = 2;
	eq FCross.ndims()        = 1;
	eq FSkew.ndims()         = 2;
	eq FOuterProduct.ndims() = 2;
	eq FIdentity.ndims()     = 2;
	eq FDiagonal.ndims()     = 2;
	
	eq FScalarExp.ndims() = 0;
	eq FVectorExp.ndims() = 1;
	eq FMatrixExp.ndims() = 2;
	
	eq FUnaryBuiltIn.ndims()              = getFExp().ndims();
	eq FEventGenExp.ndims()               = getX().ndims();
	eq FMathematicalFunctionCall.ndims()  = getFExp().ndims();
	
	eq FHomotopyExp.ndims()   = getActual().ndims();
	eq FSemiLinearExp.ndims() = size().ndims();

    eq FDelayExp.ndims()      = getFExp().ndims();

	eq FSizeExp.ndims() = hasDim() ? 0 : 1;
	eq FNdimsExp.ndims() = 0;
	
	eq FArrayDimAsArgsExp.ndims()     = getNumFExp();
	eq FFillExp.ndims()               = getNumFExp() + getFillExp().ndims();
	eq FFunctionCall.ndims()          = hasOutputs() ? expOutput().ndims() : -1;
	eq FVectorFunctionCall.ndims()    = size().ndims();
	eq InstFunctionCall.ndims()       = hasOutputs() ? expOutput().ndims() : -1;
    eq InstPartialFunctionCall.ndims() = hasOutputs() ? 0 : -1;
	eq InstVectorFunctionCall.ndims() = getDims();
	
	/**
	 * Get array dimensions of function argument.
	 */
	syn int InstFunctionArgument.ndims() = -1;
	eq InstDefaultArgument.ndims()       = getFExp().ndims();
	eq InstPositionalArgument.ndims()    = getFExp().ndims();
	eq InstNamedArgument.ndims()         = getFExp().ndims();
	
	eq FArgumentExp.ndims() = copiedFExp().ndims();

    eq FBinExp.ndims()   = overloadNdims();
    eq FUnaryExp.ndims() = overloadNdims();

    syn int FExp.overloadNdims() {
        if (shouldUseOverloadedOperator()) {
            InstClassDecl oper = overloadedOperator(true);
            if (oper != null && !oper.myOutputs().isEmpty())
                return oper.myOutputs().get(0).ndims();
        }
        return ndimsBase();
    }

    syn int FExp.ndimsBase()   = -1;
    eq FBinExp.ndimsBase()     = getLeft().ndims();
    eq FUnaryExp.ndimsBase()   = getFExp().ndims();
    eq FArtmBinExp.ndimsBase() = Math.max(getLeft().ndims(), getRight().ndims());
    eq FDivExp.ndimsBase()     = getLeft().ndims();
    eq FPowExp.ndimsBase()     = getLeft().ndims();
    eq FMulExp.ndims() {
        int left = getLeft().ndims();
        int right = getRight().ndims();
        if (isElementWise())
            return Math.max(left, right);
        if (left > 2 || right > 2)
            return -1;
        return left + right - 2;
    }

	eq FIfExp.ndims() = getThenExp().ndims();
	
	eq FSmoothExp.ndims() = getFExp().ndims();
	
	eq FVectUnaryBuiltIn.ndims() = getFExp().ndims();
	
	/**
	 * Check if multiplication is equivalent with an element-wise multiplication.
	 * 
	 * True if any operand is scalar.
	 */
	syn boolean FMulExp.isElementWise() = (getLeft().ndims() * getRight().ndims() == 0);
	
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FIdUse.ndims() {
		// Notice here the use of accessNdims. Also, if the access has
		// no subscripts, it may still have dimension > 0 if its declaration
		// is an array declaration. 
		// If the FQName is marked as scalarized, then dimension must 
		// be 0 and using myFV() might cause a NullPointerException.
		// This is because if scalarization is in progress, 
		// then this node will be hanging without a proper AST.
		int n = 0;
		if (!getFQName().isScalarized())
			for (FArraySubscripts fas : allFArraySubscripts())
				n += fas.accessNdims();
		return n;
	}
	eq FIdUseInstAccess.ndims() = getInstAccess().ndims();
	eq FIdUseExp.ndims() = getFIdUse().ndims();
		
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAccess.ndims() {
		int n = 0;
		for (FArraySubscripts fas : allFArraySubscripts())
			n += fas.accessNdims();
		return n;
	}
	
	/**
	 * Get the expanded FArraySubscripts of each part of this access.
	 */
	syn java.util.List<FArraySubscripts> InstAccess.allFArraySubscripts() = Arrays.asList(new FArraySubscripts());
	eq InstArrayAccess.allFArraySubscripts() = Arrays.asList(getExpandedSubscripts());
	eq InstScalarAccess.allFArraySubscripts() = Arrays.asList(getExpandedSubscripts());
	eq InstDot.allFArraySubscripts() {
		int n = getNumInstAccess();
		java.util.List<FArraySubscripts>[] lists = new java.util.List[n];
		for (int i = 0; i < n; i++)
			lists[i] = getInstAccess(i).allFArraySubscripts();
		return concatenation(lists);
	}
	eq InstGlobalAccess.allFArraySubscripts() = getInstAccess().allFArraySubscripts();
	
	/**
	 * Get the expanded FArraySubscripts of each part of the fully qualified version of this access.
	 */
	syn java.util.List<FArraySubscripts> InstAccess.qualifiedAllFArraySubscripts() = 
		concatenation(surroundingFArraySubscripts(), allFArraySubscripts());
	eq InstGlobalAccess.qualifiedAllFArraySubscripts() = allFArraySubscripts();
	
	/**
	 * Get the expanded FArraySubscripts for any surrounding components.
	 */
	inh ArrayList<FArraySubscripts> InstAccess.surroundingFArraySubscripts();
	inh lazy ArrayList<FArraySubscripts> InstArrayComponentDecl.surroundingFArraySubscripts();
	eq Root.getChild().surroundingFArraySubscripts()          = new ArrayList<FArraySubscripts>(0);
	eq InstClassDecl.getChild().surroundingFArraySubscripts() = new ArrayList<FArraySubscripts>(0);
	eq InstArrayComponentDecl.getChild().surroundingFArraySubscripts() {
		FArraySubscripts fas;
		ArrayList<FArraySubscripts> res;
		if (isTopDimension()) {
			fas = new FArraySubscripts();
			res = concatenation(surroundingFArraySubscripts(), Collections.singletonList(fas));
		} else {
			res = (ArrayList<FArraySubscripts>) surroundingFArraySubscripts().clone();
			int i = res.size() - 1;
			fas = res.get(i).fullCopy();
			res.set(i, fas);
		}
		fas.addFSubscript(getIndex());
		return res;
	}
	
	public class ASTNode {
        public static <T> ArrayList<T> concatenation(java.util.List<T>... lists) {
			int size = 0;
			for (java.util.List<T> list : lists)
				size += list.size();
			ArrayList<T> res = new ArrayList<T>(size);
			for (java.util.List<T> list : lists)
				res.addAll(list);
			return res;
		}
	}
	
	/**
	 * Get the expanded FArraySubscripts of each part of this access.
	 */
	syn lazy ArrayList<FArraySubscripts> FIdUse.allFArraySubscripts() {
		ArrayList<FArraySubscripts> res = getFQName().createFArraySubscriptsList();
		if (!hasFArraySubscripts() && myFV().isArray()) 
			res.set(res.size() - 1, getExpandedSubscripts());
		return res;
	}
	
	/**
	 * Create a list with an FArraySubscripts for each part of this access, empty for parts that has none.
	 */
	public ArrayList<FArraySubscripts> FQName.createFArraySubscriptsList() {
		ArrayList<FArraySubscripts> res = new ArrayList<FArraySubscripts>(numParts());
		for (int i = 0, n = numParts(); i < n; i++)
			res.add(createFArraySubscriptsForPart(i));
		return res;
	}
	
	/**
	 * Get an FArraySubscripts for part <code>i</code> of this access, creating an empty one if it has none.
	 */
	public FArraySubscripts FQName.createFArraySubscriptsForPart(int i) {
		return new FArraySubscripts();
	}
	
	public FArraySubscripts FQNameFull.createFArraySubscriptsForPart(int i) {
		FQNamePart part = getFQNamePart(i);
		return part.hasFArraySubscripts() ? part.getFArraySubscripts() : new FArraySubscripts();
	}
	
	/**
	 * Get the expanded array subscripts of this access.
	 * 
	 * An access without subscripts returns subscripts that span the entire component.
	 * Any colon subscripts are expanded into constant vector expressions.
	 */
	syn FArraySubscripts InstScalarAccess.getExpandedSubscripts() = myInstComponentDecl().expandedSubscripts();
	syn FArraySubscripts InstArrayAccess.getExpandedSubscripts() = getFArraySubscripts().expandedSubscripts();
	
//	private static final FArraySubscripts InstAccess.EMPTY_FAS = new FArraySubscripts();
	
	/**
	 * Get the expanded array subscripts of this access.
	 * 
	 * @return  an FArraySubscripts that spans the entire FV this access points to.
	 */
	syn FArraySubscripts FIdUse.getExpandedSubscripts() {
		Size s = myFV().size();
		if (s.isUnknown() && myFV().inRecord()) {
			FQName name = getFQName();
			FAbstractVariable record = lookupOutermostFV(name);
			if (!record.isUnknown()) {
				FAttribute attr = record.findHierarchicalAttribute(name);
				if (attr != null)
					attr = attr.findAttribute(FAttribute.SIZE);
				if (attr != null && attr.hasValue())
					s = new MutableSize(attr.getValue());
			}
		}
		return s.createExpandedFArraySubscripts();
	}
	
	/**
	 * Create a copy of this FArraySubscripts with all colon indices expanded.
	 */
	public FArraySubscripts FArraySubscripts.expandedSubscripts() {
		FArraySubscripts res = new FArraySubscripts();
		for (FSubscript s : getFSubscripts())
			res.addFSubscript(s.expandedSubscript());
		return res;
	}
	
	/**
	 * Create a copy of this FSubscript, expanding it to a vector if it is a colon.
	 */
	public FSubscript FSubscript.expandedSubscript() {
		return (FSubscript) fullCopy();
	}
	public FSubscript FColonSubscript.expandedSubscript() {
		return size().createExpandedFSubscript(0);
	}
	
	/**
	 * Create an FArraySubscripts that spans all array cells of this component.
	 * 
	 * If this is a scalar component, an empty FArraySubscripts is returned.
	 */
	public FArraySubscripts InstComponentDecl.expandedSubscripts() {
		return size().createExpandedFArraySubscripts();
	}
	
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstAssignable.ndims() = hasFArraySubscripts() ? getFArraySubscripts().ndims() : 0;
	
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int InstNode.ndims() = 0;
	
	eq InstComponentDecl.ndims()      = hasFArraySubscripts() ? getFArraySubscripts().ndims() : 0;
	eq InstArrayComponentDecl.ndims() = retrieveArrayCompNdims();
	
	inh int InstArrayComponentDecl.retrieveArrayCompNdims();
	eq InstNode.getChild().retrieveArrayCompNdims() = ndims() - 1;

	syn int FAbstractVariable.ndims() = -1;
	
	eq FVariable.ndims()         = isScalarized()? 0 : getFQName().ndims();
	eq FFunctionArray.ndims()    = getType().ndims();
	eq FFunctionVariable.ndims() = 0;
	
	syn int CommonForIndex.ndims() = hasFExp() ? getFExp().ndims() : 1;
	
	/**
	 * Get array dimensions.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */	
	syn int FQName.ndims() = 0;
	eq FQNameFull.ndims() {
		// Only look at the array subscripts for the last FQNamePart,
		// all other array subscripts has been expanded in the instantiation.
		FQNamePart last = getFQNamePart(getNumFQNamePart() - 1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().ndims(); 
		} else {
			return 0;
		}
	}

	/**
	 * Get array dimensions of an identifier when used in an identifier.
	 * 
	 * Here it is not sufficient to check the number of subscripts; the 
	 * identifier x[1] has the dimension 0, not 1.
	 * 
	 * A value > 0 indicates an array, 0 indicates a scalar and -1 indicates
	 * an error in computation of the array dimensions.
	 * 
	 * @return Array dimension.
	 */		
	syn int FQName.accessNdims() = 0;
	eq FQNameFull.accessNdims() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().accessNdims(); 
		} else {
			return 0;
		}
	}

	
	// Array sizes
	
	/**
	 * Get the array sizes. 
	 */
	syn lazy Size FAbstractEquation.size() = Size.SCALAR;
	eq FEquation.size() {
		Size left = getLeft().size();
		Size right = getRight().size();
		return left.equals(right) ? left : Size.SCALAR;
	}

	syn Size FAbstractEquation.totalSize() = size().expand(parentTotalSize());
	
	inh Size FAbstractEquation.parentTotalSize();
	eq InstForClauseE.getChild().parentTotalSize() {
		Size s = parentTotalSize();
		for (InstForIndex i : getInstForIndexs()) {
			if (i.hasFExp())
				s = i.getFExp().size().expand(s);
			else
				s = new Size(0).expand(s);
		}
		return s;
	}
	eq InstRoot.getChild().parentTotalSize() = Size.SCALAR;
	eq FlatRoot.getChild().parentTotalSize() = Size.SCALAR;
	
	syn FArraySubscripts FAbstractEquation.expandedSubscripts() {
		FArraySubscripts fas = parentExpandedSubscripts();
		Size size = size();
		for (int i = 0; i < size.ndims(); i++) {
			fas.addFSubscript(size.createExpandedFSubscript(i));
		}
		return fas;
	}
	
	inh FArraySubscripts FAbstractEquation.parentExpandedSubscripts();
	eq InstForClauseE.getChild().parentExpandedSubscripts() {
		FArraySubscripts fas = parentExpandedSubscripts();
		for (InstForIndex i : getInstForIndexs()) {
			if (i.hasFExp())
				fas.addFSubscript(new FExpSubscript(i.getFExp().flatten(myInstNode().getFQName())));
			else
				fas.addFSubscript(new FColonSubscript());
		}
		return fas;
	}
	eq InstRoot.getChild().parentExpandedSubscripts() = new FArraySubscripts();
	eq FlatRoot.getChild().parentExpandedSubscripts() = new FArraySubscripts();
	
	/**
	 * Get the array sizes. 
	 */
	syn lazy Size FArraySubscripts.declarationSize() = declarationSize(getFSubscripts());
	
	/**
	 * Get the array size for a collection of FSubscripts.
	 */
	public static Size FArraySubscripts.declarationSize(Iterable<? extends FSubscript> subs) {
		int ndims = 0;
		for (FSubscript fs : subs)
			ndims++;
		if (ndims == 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims);
		for (FSubscript fs : subs)
			fs.addDeclarationSize(s);
		return s;
	}
	
	/**
	 * Add the size of the dimension denoted by this subscript when used 
	 *        in a declaration to the given Size.
	 */
	public abstract void FSubscript.addDeclarationSize(MutableSize s);
	
	public void FExpSubscript.addDeclarationSize(MutableSize s) {
		FExp e = getFExp();
		if (e.ndims() == 0)
			s.append(e);
		else
			s.append(e.size(), 0);
	}
	
	public void FColonSubscript.addDeclarationSize(MutableSize s) {
		FExp e = new FUnknownSizeExp(surroundingVariableDecl(), myDim());
		e.setParent(this);
		s.append(e);
	}
	
	public void FIntegerSubscript.addDeclarationSize(MutableSize s) {
		s.append(getValue());
	}
	
	/**
	 * The variable declaration that this subscript is a part of the size of, if any.
	 */
	inh CommonVariableDecl FColonSubscript.surroundingVariableDecl();
	eq FVariable.getFQName().surroundingVariableDecl()                   = this;
	eq InstComponentDecl.getFArraySubscripts().surroundingVariableDecl() = this;
	eq FExp.getChild().surroundingVariableDecl()                         = null;
	eq Root.getChild().surroundingVariableDecl()                         = null;
	
	/**
	 * The dimension this subscript is used for.
	 */
	inh int FSubscript.myDim();
	eq FArraySubscripts.getFSubscript(int i).myDim() = i;

	/**
	 * Get the array sizes when the array subscripts are used in an
	 * access. See also documentation of accessNdims(). 
	 */
	syn lazy Size FArraySubscripts.accessSize() {
		if (accessNdims() == 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(accessNdims());
		for (FSubscript fs : getFSubscripts()) 
			if (fs.ndims() == 1)
				s.append(fs.size());
		return s;
	}

	
	/**
	 * Get the array sizes. 
	 */
	syn Size FSubscript.size();
	eq FExpSubscript.size()     = getFExp().size();
	eq FColonSubscript.size()   = mySize();
	eq FIntegerSubscript.size() = Size.SCALAR;
	
	/**
	 * Get the size this subscript(s) would have if all subscripts were colons.
	 */
	inh Size FEndExp.mySize();
	inh Size FSubscript.mySize();
	inh Size FArraySubscripts.mySize();
	eq FIdUse.getChild().mySize()                       = myFV().size();
	eq FIdUseInstAccess.getChild().mySize()             = getInstAccess().size();
	eq InstScalarAccess.getExpandedSubscripts().mySize() = myInstComponentDecl().size();
	eq InstArrayAccess.getFArraySubscripts().mySize()   = myInstComponentDecl().size();
	eq InstArrayAccess.getExpandedSubscripts().mySize() = myInstComponentDecl().size();
	eq FSubscriptedExp.getFArraySubscripts().mySize()   = getFExp().size();
	eq FExpSubscript.getFExp().mySize()                 = mySize();
	eq FlatRoot.getChild().mySize()                     = Size.SCALAR;
	eq InstRoot.getChild().mySize()                     = Size.SCALAR;
	
	eq FArraySubscripts.getFSubscript(int i).mySize() {
		MutableSize s = new MutableSize(1);
		if (mySize().has(i))
			s.set(0, mySize(), i);
		else 
			s.set(0, Size.UNKNOWN);
		return s;
	}
	
	/**
	 * Get the array sizes. 
	 */
	syn Size FExp.size() = Size.SCALAR;
	syn lazy Size FAbstractArrayExp.size() = super.size();
	eq FInstAccessExp.size() = getInstAccess().size();

    eq FBinExp.size()   = overloadSize();
    eq FUnaryExp.size() = overloadSize();

    syn Size FExp.overloadSize() {
        if (shouldUseOverloadedOperator()) {
            InstClassDecl oper = overloadedOperator(true);
            if (oper != null && !oper.myOutputs().isEmpty())
                return oper.myOutputs().get(0).size();
        }
        return sizeBase();
    }

    syn Size FExp.sizeBase()  = null;
    eq FBinExp.sizeBase()     = getLeft().size();
    eq FUnaryExp.sizeBase()   = getFExp().size();
    eq FArtmBinExp.sizeBase() = getLeft().isArray() ? getLeft().size() : getRight().size();

    eq FDivExp.sizeBase() = getLeft().size();
    eq FPowExp.sizeBase() = getLeft().size();

    eq FMulExp.sizeBase() {
        if (!getLeft().isArray())
            return getRight().size();
        if (!getRight().isArray())
            return getLeft().size();
        if (!isArray())
            return Size.SCALAR;
        MutableSize s = new MutableSize(ndims());
        if (getLeft().ndims() == 2)
            s.append(getLeft().size(), 0);
        if (getRight().ndims() == 2)
            s.append(getRight().size(), 1);
        return s;
    }

	syn boolean FRangeExp.hasStep() = getNumFExp() > 2;
	
 	eq FRangeExp.size() {
 		MutableSize s = new MutableSize(1);
 		FExp start = getFExp(0);
 		FExp stop = getFExp(hasStep() ? 2 : 1);
 		if (!hasStep() && start.isIntegerLiteral(1) && stop.type().isInteger()) {
 			s.append(stop);
 		} else {
 			start = start.makeRangeSizeExp();
 			stop = stop.makeRangeSizeExp();
 	 		FExp step = hasStep() ? getFExp(1).fullCopy() : null;
 			FExp exp = new FSubExp(stop, start);
 			if (hasStep())
 				exp = new FDivExp(exp, step);
 			exp = new FAddExp(new FIntegerFuncExp(exp), new FIntegerLitExp(1));
 			exp = new FMaxExp(exp, new Opt(new FIntegerLitExp(0)));
 			s.append(dynamicFExp(exp));
		}
		return s;
	}
 	
 	/**
 	 * Create a new expression suitable for use in an expression calculating the 
 	 *        array size of a range expression.
 	 */
 	public FExp FExp.makeRangeSizeExp() {
 		return type().wrapRangeSizeExp(fullCopy());
 	}
 	
 	/**
 	 * Wrap the given expression so it is suitable for use in an expression 
 	 *        calculating the array size of a range expression.
 	 */
 	public FExp FType.wrapRangeSizeExp(FExp exp) {
 		return exp;
 	}
 	
 	public FExp FEnumType.wrapRangeSizeExp(FExp exp) {
 		return new FEnumIntegerExp(exp);
 	}
 	
 	public FExp FBooleanType.wrapRangeSizeExp(FExp exp) {
 		return new FIfExp(exp, new FIntegerLitExp(2), new FIntegerLitExp(1));
 	}
 	
 	syn boolean FExp.isIntegerLiteral(int v)  = false;
 	eq FIntegerLitExp.isIntegerLiteral(int v) = getValue() == v;
 	
 	eq FLinspace.size() {
		MutableSize s = new MutableSize(ndims());
 		s.append(getN());
		return s;
 	}
	
	eq FArray.size() {
	    if (getFExp(0) == null)
	        return new Size(0);
		if (isIterArray())
			return getFExp(0).size();
		return getFExp(0).size().expand(getNumFExp());
	}
	
	syn int FAbstractCat.dimension();
	eq FCatExp.dimension()    = getDim().ceval().intValue() - 1;
	eq FMatrix.dimension()    = 0;
	eq FMatrixRow.dimension() = 1;
	
	syn int FSizeExp.dimension() = getDim().ceval().intValue() - 1;
	
	eq FAbstractCat.size() {
		try {
			int dim = dimension();
			MutableSize ms = getFExp(0).size().promote(ndims()).mutableClone();
			for (int i = 1; i < getNumFExp(); i++)
				ms.add(dim, getFExp(i).size().promote(ndims()), dim);
			return ms;
		} catch (ConstantEvaluationException e) {
			return Size.SCALAR;
		}
	}
	
	eq FReductionExp.size() = getFExp().isIterExp() ? iterExp().size() : Size.SCALAR;
	
	eq FIterExp.size() {
		if (ndims() <= 0)
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		s.append(localSize());
		s.append(getFExp().size());
		return s;
	}
	
	/**
	 * The size of the iteration indices of this iteration expression.
	 */
	syn lazy Size FIterExp.localSize() {
		MutableSize s = new MutableSize(localNdims());
		for (CommonForIndex fi : getForIndexList())
			if (fi.hasFExp() && fi.getFExp().ndims() == 1)
				s.append(fi.getFExp().size());
		return s;
	}
	
	/**
	 * Check if this expression is inside an iteration expression.
	 */
	inh boolean FExp.inIterExp();
	eq FIterExp.getFExp().inIterExp()  = true;
	eq FClass.getChild().inIterExp()   = false;
	eq InstNode.getChild().inIterExp() = false;
	
	/**
	 * Return a size that represents the given size with sizes of surrounding iteration expressions appended.
	 */
	inh Size FExp.expandSizeForIterExp(Size s);
	eq FIterExp.getFExp().expandSizeForIterExp(Size s)  = expandSizeForIterExp(s.expand(localSize()));
	eq FClass.getChild().expandSizeForIterExp(Size s)   = s;
	eq InstNode.getChild().expandSizeForIterExp(Size s) = s;
	
	eq FSubscriptedExp.size() = getFArraySubscripts().accessSize();
	
	eq FTranspose.size() {
		Size size = getFExp().size();
		if (size.ndims() < 2)
			return size;
		MutableSize s = new MutableSize(size.ndims());
		s.append(size, 1);
		s.append(size, 0);
		for (int i = 2; i < s.ndims(); i++)
			s.append(size, i);
		return s;
	}
	
	eq FCross.size()     = new Size(3);
	eq FSkew.size()      = new Size(3, 3);
	
	eq FOuterProduct.size() {
		MutableSize s = new MutableSize(2);
		s.append(getX().size());
		s.append(getY().size());
		return s;
	}
	
	eq FIdentity.size() {
		MutableSize s = new MutableSize(2);
		s.append(getFExp());
		s.append(getFExp());
		return s;
	}
	
	eq FDiagonal.size() {
		MutableSize s = new MutableSize(2);
		Size s2 = getFExp().size();
		if (s2 != Size.SCALAR) { 
			s.append(s2, 0);
			s.append(s2, 0);
		}
		return s;
	}
	
	eq FDimensionConvert.size() {
		if (getFExp().isArray() && isArray()) {
			MutableSize s = new MutableSize(ndims());
			Size s2 = getFExp().size(); 
			for (int d : dimensionsToKeep()) {
				if (d < s2.ndims())
					s.append(s2, d);
				else
					s.append(1);
			}
			return s;
		} else {
			return sizeForScalarArg();
		}
	}
	eq FScalarExp.size()        = Size.SCALAR;
	
    eq FVectorExp.size() {
        Size s = getFExp().size();
        if (s.ndims() > 0 && s.isUnknown()) {
            FExp e = null;
            for (int i = 0; i < s.ndims(); i++) {
                FExp e1 = s.createFExp(i);
                if (e == null) {
                    e = e1;
                } else {
                    e = new FMulExp(e,e1);
                }
            }
            dynamicFExp(e);
            MutableSize ss = new MutableSize(1);
            ss.set(0, e);
            return ss;
        }
        return super.size();
    }
	
	syn Size FDimensionConvert.sizeForScalarArg();
	eq FScalarExp.sizeForScalarArg() = Size.SCALAR;
	eq FVectorExp.sizeForScalarArg() = new Size(1);
	eq FMatrixExp.sizeForScalarArg() = new Size(1, 1);
	
	eq FSizeExp.size()  = hasDim() ? Size.SCALAR : new Size(getFExp().ndims());
	eq FNdimsExp.size() = Size.SCALAR;
	
	eq FSmoothExp.size() = getFExp().size();
	
	eq FUnaryBuiltIn.size()             = getFExp().size();
	eq FVectUnaryBuiltIn.size()         = getFExp().size().contractRight(ndims());
	
	eq FEventGenExp.size()              = getX().size();
	eq FMathematicalFunctionCall.size() = getFExp().size();
	eq FHomotopyExp.size()              = getActual().size();
	eq FSemiLinearExp.size()            = vectorizedSize();

    eq FDelayExp.size()                 = getFExp().size();

    syn Size FBuiltInFunctionCall.vectorizedSize() {
        for (FExp e : myArgs())
            if (e.isArray())
                return e.size();
        return Size.SCALAR;
    }
    
    syn FExp[] FBuiltInFunctionCall.myArgs() = null;
    eq FSemiLinearExp.myArgs() {
        FExp[] e = {getX(), getPosSlope(), getNegSlope()};
        return e;
    }
    
	
	eq FArrayDimAsArgsExp.size() {
		if (!isArray())
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		for (FExp fe : getFExps()) 
			s.append(fe);
		appendSpecificLengths(s);
		return s;
	}
	
	protected void FArrayDimAsArgsExp.appendSpecificLengths(MutableSize s) {}
	protected void FFillExp.appendSpecificLengths(MutableSize s) {
		s.append(getFillExp().size());
	}
	
	inh Size FFunctionCallLeft.size();
	eq FFunctionCallEquation.getLeft(int i).size() = getCall().sizeOfOutput(i);
	eq FFunctionCallStmt.getLeft(int i).size()     = getCall().sizeOfOutput(i);
	
	syn Size FAbstractFunctionCall.sizeOfOutput(int i) = (i == 0) ? size() : Size.SCALAR;

    syn Size InstFunctionCall.sizeOfOutput(int i) {
        Size s = myCallOutputs().get(i).size();
        if (!s.isUnknown() || isCircular())
            return s;
        
        HashMap<ASTNode, FExp> varMap = new HashMap<ASTNode, FExp>();
        for (int j = 0; j < getNumArg(); j++)
            varMap.put(myCallInputs().get(j), getArg(j).getFExp());
        
        MutableSize ms = new MutableSize(s.ndims());
        for (int j = 0; j < s.ndims(); j++) {
            try {
                ms.append(dynamicFExp(s.createSizeFExp(j, (HashMap) varMap.clone())));
            } catch (ConstantEvaluationException e) {
                ms.append(dynamicFExp(new FUnknownSizeExp(unknownInstComponentDecl(), j)));
            }
        }
        return ms;
    }
    eq InstVectorFunctionCall.sizeOfOutput(int i) = 
        (i == 0) ? vectorizedSize() : super.sizeOfOutput(i);

	/**
	 * Return the size the function call is expanded to. This is the size of the 
	 * entire function call, and the size of a vectorized argument to a scalar input.
	 * 
	 * If arguments doesn't match, the size matching the most arguments is returned.
	 */
	syn lazy Size InstVectorFunctionCall.vectorizedSize() {
		boolean func = inFunction();
		int tot = getNumArg(), n = 0, ndims = ndims();
		Size[] candidates = new Size[tot];
		int[] freq = new int[tot];
		
		for (InstFunctionArgument arg : getArgs()) {
			if (arg.isVectorized()) {
				Size s = arg.size().contractRight(ndims);
				for (int i = 0; i < n && s != null; i++) {
					if (!candidates[i].equivalent(s, func)) {
						if (func && candidates[i].isUnknown())
							candidates[i] = candidates[i].createKnown(s);
						s = null;
						freq[i]++;
					}
				}
				if (s != null)
					candidates[n++] = s;
			}
		}
	
		int index = 0;
		for (int i = 1; i < n; i++) 
			if (freq[index] < freq[i]) 
				index = i;
		return candidates[index];
	}
	
	inh Size InstFunctionArgument.vectorizedSize();
	eq FAbstractFunctionCall.getChild().vectorizedSize() = Size.SCALAR;
	eq InstVectorFunctionCall.getArg().vectorizedSize()  = vectorizedSize();
	
	/**
	 * Get array sizes of function argument.
	 */
	syn Size InstFunctionArgument.size() = null;
	eq InstDefaultArgument.size()        = getFExp().size();
	eq InstPositionalArgument.size()     = getFExp().size();
	eq InstNamedArgument.size()          = getFExp().size();
    
    eq FArgumentExp.size() = copiedFExp().size();
	
	syn Size FFunctionCall.sizeOfOutput(int i) = getSizes()[i];
	
	eq FFunctionCall.size()    = hasOutputs() ? sizeOfOutput(0) : Size.SCALAR;
	eq InstFunctionCall.size() = hasOutputs() ? sizeOfOutput(0) : Size.SCALAR;
    eq InstPartialFunctionCall.size() = Size.SCALAR;
	
	eq FIfExp.size() {
		if (isParameterIf()) {
			try {
				return cevalSelectExp().size();
			} catch (ConstantEvaluationException e) {
			}
		}
		return getThenExp().size();
	}
	
	/**
	 * Get the array sizes.
	 */
	syn lazy Size FIdUse.size() {
		if (ndims() == 0)
			return Size.SCALAR;
		
		MutableSize s = new MutableSize(ndims());
		for (FArraySubscripts fas : allFArraySubscripts())
			for (FSubscript fs : fas.getFSubscripts()) 
				if (fs.ndims() >= 1)
					s.append(fs.size());
		return s;
	}
	eq FIdUseInstAccess.size() = getInstAccess().size();
		
	eq FIdUseExp.size() = getFIdUse().size();
	
    /**
     * Get the array sizes. 
     */
    syn Size InstAccess.size()   = Size.SCALAR;
    eq InstScalarAccess.size()   = myInstComponentDecl().size();
    eq InstArrayAccess.size()    = getFArraySubscripts().accessSize();
			
	/**
	 * Get the array sizes. 
	 */
	eq InstAssignable.size() {
		Size s = declaredSize();
		if (hasBindingFExp() && s.isUnknown() && (!isInput() || !inFunction()))
			s = s.createKnown(getBindingFExp());
		return s;
	}
	
	/**
	 * Get the array sizes as declared. May be unknown. 
	 */
	syn Size InstComponentDecl.declaredSize() = 
		hasFArraySubscripts() ? getFArraySubscripts().declarationSize() : Size.SCALAR;
	
	/**
	 * Get the array sizes. 
	 */
	eq InstDot.size() {
		if (!isArray())
			return Size.SCALAR;
		MutableSize s = new MutableSize(ndims());
		for (InstAccess ia : getInstAccesss())
			s.append(ia.size());
		return s;
	}
	eq InstGlobalAccess.size() = getInstAccess().size();
	
	/**
	 * Get the array sizes. 
	 */
	syn Size InstNode.size()               = FArraySubscripts.declarationSize(myFSubscripts());	
	syn lazy Size InstComponentDecl.size() = declaredSize();

	/**
	 * Get the array sizes. 
	 */	
	syn lazy Size FAbstractVariable.size() = Size.SCALAR;
	eq FVariable.size()      = isScalarized()? Size.SCALAR: getFQName().size();
	eq FFunctionArray.size() = getType().size();
		
	/**
	 * Get the array sizes of the loop index expression. 
	 */	
	syn Size CommonForIndex.size() = hasFExp() ? getFExp().size() : Size.SCALAR;
	// TODO: support automatic extrapolation of the loop expression
	
	/**
	 * Get the array sizes. 
	 */
	syn Size FQName.size() = Size.SCALAR;
	syn lazy Size FQNameFull.size() {
		FQNamePart last = getFQNamePart(getNumFQNamePart()-1);
		if (last.hasFArraySubscripts()) {
			return last.getFArraySubscripts().declarationSize(); 
		} else {
			return Size.SCALAR;
		}
	}

    /**
     * Create a copy of this FExp with variable uses and function calls replaced with expressions 
     * that allow calculations of unknown sizes.
     * 
     * For non-FExp nodes, this simply makes a full copy.
     * 
     * @param varMap  a map of variables to replace and expressions to replace them with.
     *                Also contains uses that have been replaced, to detect circularities.
     */
    public FExp FExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
        FExp exp = copy();
        for (int i = 0; i < getNumChild(); i++) 
            exp.setChild(getChild(i).createSizeFExp(varMap), i);
        return exp;
    }
    
    public FExp FSizeExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
        if (varMap.containsKey(this))
            throw new ConstantEvaluationException();
        varMap.put(this, null);
        Size s = getFExp().size();
        if (s.ndims() == 0)
            throw new ConstantEvaluationException();
        return s.createSizeFExp(dimension(), varMap);
    }
    
    public FExp FUnknownSizeExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
        boolean circ = varMap.containsKey(this);
        varMap.put(this, null);
        if (!circ && varMap.containsKey(getVariable()))
            return varMap.get(getVariable()).size().createSizeFExp(getDim(), varMap);
        else
            return new FSizeExp(getVariable().createUseExp(), getDim());
    }

    public FExp FIdUseExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return getFIdUse().createSizeFExp(varMap);
    }

    public FExp FInstAccessExp.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return getInstAccess().createSizeFExp(varMap);
    }

    public FExp FIdUseInstAccess.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return getInstAccess().createSizeFExp(varMap);
    }

    public FExp InstAccess.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return createSizeFExpForUse(varMap, myInstComponentDecl());
    }

    public FExp FIdUse.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return createSizeFExpForUse(varMap, myFV());
    }

    /**
     * Helper method for {@link ASTNode#createSizeFExp(Map)} - should not be called directly.
     */
    protected FExp CommonAccess.createSizeFExpForUse(Map<ASTNode, FExp> varMap, CommonVariableDecl var) {
        if (varMap.containsKey(this))
            throw new ConstantEvaluationException();
        varMap.put(this, null);
        FExp exp = varMap.get(var);
        if (exp != null) 
            return exp;  // Known argument of function
        else if (onlyUsesSize()) 
            return var.size().createDummyFExp(varMap);
        else
            return createSizeFExpForKeptUse(varMap);
    }

    /**
     * Helper method for {@link ASTNode#createSizeFExp(Map)} - should not be called directly.
     */
    protected FExp CommonAccess.createSizeFExpForKeptUse(Map<ASTNode, FExp> varMap) {
        CommonAccess res = fullCopy();
        res.replaceExpsWithSizeFExp(varMap);
        return res.createFExp();
    }

    /**
     * Helper method for {@link ASTNode#createSizeFExp(Map)} - should not be called directly.
     */
    protected void CommonAccess.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {}

    protected void InstArrayAccess.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {
        for (FSubscript sub : getFArraySubscripts().getFSubscripts())
            sub.replaceExpsWithSizeFExp(varMap);
    }

    protected void InstDot.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {
        for (InstAccess part : getInstAccesss())
            part.replaceExpsWithSizeFExp(varMap);
    }

    protected void FIdUse.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {
        getFQName().replaceExpsWithSizeFExp(varMap);
    }

    /**
     * Helper method for {@link ASTNode#createSizeFExp(Map)} - should not be called directly.
     */
    protected void FQName.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {}

    protected void FQNameFull.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {
        for (FQNamePart part : getFQNameParts())
            if (part.hasFArraySubscripts())
                for (FSubscript sub : part.getFArraySubscripts().getFSubscripts())
                    sub.replaceExpsWithSizeFExp(varMap);
    }

    /**
     * Helper method for {@link ASTNode#createSizeFExp(Map)} - should not be called directly.
     */
    protected void FSubscript.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {}

    protected void FExpSubscript.replaceExpsWithSizeFExp(Map<ASTNode, FExp> varMap) {
        setFExp(getFExp().createSizeFExp(varMap));
    }

    public FExp FFunctionCall.createSizeFExp(Map<ASTNode, FExp> varMap) {
        if (onlyUsesSize()) 
            return size().createDummyFExp(varMap);
        FFunctionCall res = new FFunctionCall(getName().fullCopy(), new List<FExp>(), getSizes());
        for (FExp arg : getArgs())
            res.addArg(arg.createSizeFExp(varMap));
        return res;
    }

    public FExp InstFunctionCall.createSizeFExp(Map<ASTNode, FExp> varMap) {
        if (onlyUsesSize()) 
            return size().createDummyFExp(varMap);
        InstFunctionCall res = new InstFunctionCall(getName().fullCopy(), new List<InstFunctionArgument>());
        for (InstFunctionArgument arg : getArgs())
            res.addArg(arg.createSizeFExpArg(varMap));
        return res;
    }

    /**
     * Helper method for {@link ASTNode#createSizeFExp(Map)}.
     */
    public InstFunctionArgument InstFunctionArgument.createSizeFExpArg(Map<ASTNode, FExp> varMap) {
        return fullCopy();
    }

    public InstPositionalArgument InstPositionalArgument.createSizeFExpArg(Map<ASTNode, FExp> varMap) {
        return new InstPositionalArgument(getPos(), getFExp().createSizeFExp(varMap));
    }

    public InstNamedArgument InstNamedArgument.createSizeFExpArg(Map<ASTNode, FExp> varMap) {
        return new InstNamedArgument(getName().fullCopy(), getFExp().createSizeFExp(varMap));
    }

    /**
     * Check is this expression is used in a way that means that only its size is ever needed.
     * 
     * Typically applies to the first argument of a size() expression.
     */
    inh boolean ASTNode.onlyUsesSize();
    eq FSizeExp.getFExp().onlyUsesSize()       = true;
    eq FExpSubscript.getChild().onlyUsesSize() = false;
    eq InstNode.getChild().onlyUsesSize()      = false;
    eq Root.getChild().onlyUsesSize()          = false;

    /**
     * Create a copy of this FExp with variable uses and function calls replaced with expressions 
     * that allow calculations of unknown sizes.
     * 
     * For non-FExp nodes, this simply makes a full copy.
     * 
     * @param varMap  a map of variables to replace and expressions to replace them with.
     *                Also contains uses that have been replaced, to detect circularities.
     */
    public ASTNode ASTNode.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return fullCopy();
    }

    public List List.createSizeFExp(Map<ASTNode, FExp> varMap) {
        List node = new List();
        for (ASTNode ch : this)
            node.add(ch.createSizeFExp(varMap));
        return node;
    }

    public Opt Opt.createSizeFExp(Map<ASTNode, FExp> varMap) {
        return getNumChild() == 0 ? new Opt() : new Opt(getChild(0).createSizeFExp(varMap));
    }

	/**
	 * Create a copy of this expression suitable for when it is used to describe a size.
	 * 
	 * Default implementation simply returns a copy.
	 */
	public FExp FExp.createSizeFExp() {
		return unboundCopy();
	}
	
	public FExp FUnknownSizeExp.createSizeFExp() {
		return new FSizeExp(getVariable().createUseExp(), getDim());
	}
		
	/**
	 * check if an expression is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FExp.isArray() = ndims()>0;
	
	/**
	 * check if an access is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstAccess.isArray() = ndims()>0;

	/**
	 * check if a variable is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean FAbstractVariable.isArray() = ndims()>0;
	
	/**
	 * check if an instance node is an array expression.
	 * 
	 * @return True if array dimension > 0 else false
	 */
	syn boolean InstNode.isArray() = ndims()>0;
	
	public abstract int[]  CommonForIndex.myIndices();
	public abstract String CommonForIndex.name();
	
	/**
	 * Expand for all values of for indices given in <code>indices</code>.
	 * 
	 * This is used to get the set of values for array indices while error checking 
	 * and to expand summation reduction expressions.
	 * 
	 * Size of new Array will be (n + m), where n = indices.size() and m = ndims().  
	 */
    public Array Array.createExpanded(Iterable<? extends CommonForIndex> forIndices, boolean scalarize) {
		if (!forIndices.iterator().hasNext())
			return (Array) fullCopy();
		Indices newIndices = Indices.create(forIndices);
		Array arr = new Array(Indices.create(expandedSize(newIndices.size())));
		Map<String,FExp> indexMap = new HashMap<String,FExp>();
		for (Index i : newIndices) {
			newIndices.fillIndexMap(indexMap, i, forIndices);
			for (CommonForIndex fi : forIndices)
				indexMap.put(fi.uniqueIterExpName(), fi.evaluationValue().buildLiteral());
            fillSubset(arr, i, indexMap, scalarize);
		}
		for (CommonForIndex fi : forIndices) 
			fi.setEvaluationValue(null);
		return arr;
	}
	
	protected Size Array.expandedSize(Size size) {
		return size().expand(size);
	}
	
    protected void Array.fillSubset(Array arr, Index i, Map<String,FExp> indexMap, boolean scalarize) {
		for (Index i2 : indices()) {
            arr.set(i.expand(i2), createSubsetExp(get(i2), indexMap, scalarize));
		}
	}
    
    protected void ScalarAsArray.fillSubset(Array arr, Index i, Map<String,FExp> indexMap, boolean scalarize) {
        arr.set(i, createSubsetExp(get(Index.NULL), indexMap, scalarize));
    }
    
    protected FExp Array.createSubsetExp(FExp e, Map<String,FExp> indexMap, boolean scalarize) {
        if (scalarize)
            return e.dynamicFExp(e.scalarize(indexMap));
        else
            return e.dynamicFExp(e.fullCopy()).replaceIndices(indexMap);
    }
	
	/**
	 * Replaces all uses of indices in <code>indexMap</code> with the respective expressions.
	 * 
	 * May alter the tree below this.
	 */
	protected ASTNode ASTNode.replaceIndices(Map<String,FExp> indexMap) {
		ASTNode res = replaceFromIndexMap(indexMap);
		if (this == res) {
			for (int i = 0, n = getNumChild(); i < n; i++) {
				ASTNode sub = getChild(i);
				ASTNode repl = sub.replaceIndices(indexMap);
				if (repl != sub)
					setChild(repl, i);
			}
		}
		return res;
	}
	
	protected FExp FExp.replaceIndices(Map<String,FExp> indexMap) {
		return (FExp) super.replaceIndices(indexMap);
	}
	
	/**
	 * If this node is a use of an index in <code>indexMap</code>, return the 
	 *        respective expression, otherwise return <code>this</code>.
	 */
	protected ASTNode ASTNode.replaceFromIndexMap(Map<String,FExp> indexMap) {
		return this;
	}
	protected ASTNode FInstAccessExp.replaceFromIndexMap(Map<String,FExp> indexMap) {
		FExp res = indexMap.get(name());
		return (res == null) ? this : res;
	}
	protected ASTNode FIdUseExp.replaceFromIndexMap(Map<String,FExp> indexMap) {
		FExp res = indexMap.get(name());
		return (res == null) ? this : res;
	}
	
	/**
	 * Expand index for all values of each for index used in expression.
	 */
    syn lazy Array FExpSubscript.getExpanded() = getFExp().getArray().createExpanded(collectForIndices(), getFExp().myFClass() != null);
	
	/**
	 * Collect all ForIndexs used in the expression of this FExpSubscript.
	 */
	coll HashSet<CommonForIndex> FExpSubscript.collectForIndices() 
		[new HashSet<CommonForIndex>()] with add root FExpSubscript;
	FIdUse contributes myForIndex() when isForIndex()
		to FExpSubscript.collectForIndices() for each allSurroundingFExpSubscripts();
	FInstAccessExp contributes myForIndex() when isForIndex()
		to FExpSubscript.collectForIndices() for each allSurroundingFExpSubscripts();
	
	/**
	 * Return the FForIndex or InstForIndex that this variable belongs to, if any.
	 */
	syn CommonForIndex FIdUse.myForIndex()            = myFV().myForIndex();
	syn CommonForIndex FIdUseInstAccess.myForIndex()  = getInstAccess().myInstComponentDecl().myForIndex();
	syn CommonForIndex FInstAccessExp.myForIndex()    = getInstAccess().myInstComponentDecl().myForIndex();
	inh CommonForIndex FAbstractVariable.myForIndex();
	inh CommonForIndex InstComponentDecl.myForIndex();
	eq FForIndex.getFVariable().myForIndex()        = this;
	eq InstForIndex.getInstPrimitive().myForIndex() = this;
	eq FClass.getChild().myForIndex()               = null;
	eq FFunctionDecl.getChild().myForIndex()        = null;
	eq InstNode.getChild().myForIndex()             = null;
	
	/**
	 * Find the closest ancestor that is an FExpSubscript, if any.
	 */
	inh FExpSubscript FIdUse.surroundingFExpSubscript();
	inh FExpSubscript FInstAccessExp.surroundingFExpSubscript();
	inh FExpSubscript FExpSubscript.surroundingFExpSubscript();
	eq FExpSubscript.getChild().surroundingFExpSubscript() = this;
	eq Root.getChild().surroundingFExpSubscript()          = null;
	
	/**
	 * Find the all ancestors that are FExpSubscripts, if any.
	 */
	syn ArrayList<FExpSubscript> FIdUse.allSurroundingFExpSubscripts() {
		ArrayList<FExpSubscript> list = new ArrayList<FExpSubscript>();
		FExpSubscript cur = surroundingFExpSubscript();
		while (cur != null) {
			list.add(cur);
			cur = cur.surroundingFExpSubscript();
		}
		return list;
	}
	
	/**
	 * Find the all ancestors that are FExpSubscripts, if any.
	 */
	syn ArrayList<FExpSubscript> FInstAccessExp.allSurroundingFExpSubscripts() {
		ArrayList<FExpSubscript> list = new ArrayList<FExpSubscript>();
		FExpSubscript cur = surroundingFExpSubscript();
		while (cur != null) {
			list.add(cur);
			cur = cur.surroundingFExpSubscript();
		}
		return list;
	}

    /**
     * Computes a generic array expansion of the expression.
     * 
     * This is used mainly to scalarize array expressions. Should be overridden for all 
     * expression types possible, since default implementation clones the original expression 
     * for each cell.
     * 
     * @return An Array with scalar expressions if this is an array expression, 
     *          a ScalarAsArray containing <code>this</code> otherwise.
     */
    syn lazy Array FExp.getArray() {
        if (!isArray())
            return new ScalarAsArray(this);
        
        if (useTempVar())
            return createTempArray();
        
        Array res = new Array(indices());
        for (Index i : res.indices())
            res.set(i, new FSubscriptedExp(unboundCopy(), i.createFArraySubscripts()));
        return res;
    }
    
    /**
     * Computes a generic array expansion of the temporary replacing this expression.
     */
    syn Array FExp.createTempArray() {
        Array res = new Array(indices());
        for (Index i : res.indices()) {
            res.set(i, tempExp(i.createFArraySubscripts()));
        }
        return res;
    }

	/**
	 * Allows for more efficient execution of {@link #getArray()} in some cases.
	 * 
	 * When the Array of a parent node is the same as a childs, replace 
	 * getArray() with {@link #createArray()} for the types the child can have, 
	 * let getArray() for those types delegate to copyArray() and use copyArray() 
	 * on the child in getArray() for the parent.
	 * 
	 * This ensures that the Array is created only once and that only as many copies 
	 * as necessary are made.
	 */
	syn Array FExp.copyArray() = (Array) createArray().unboundCopy();
	
	/**
	 * Allows for more efficient execution of {@link #getArray()} in some cases.
	 * 
	 * See {@link #copyArray()} for instructions. 
	 * When overriding createArray(), always declare it as lazy.
	 */
	syn Array FExp.createArray() = getArray();
	
	eq FBinExp.getArray() {
		if (isArray()) {
			/* Standard implementation covers many binary operators.
			 * Apply operator element-wise, if one operand is scalar, use it with 
			 * all elements in other operand. Used for operators that does not 
			 * allow a scalar and an array as well, since that is caught by the 
			 * error check.
			 */
			Array left  = getLeft().getArray();
			Array right = getRight().getArray();
			Array res   = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode(left.get(i).fullCopy(), right.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FUnaryExp.getArray() {
		if (isArray()) {
			Array src = getFExp().getArray();
			Array res = new Array(indices());
			for (Index i : res.indices())
				res.set(i, createNode(src.get(i).fullCopy()));
			return res;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FMulExp.getArray() {
		if (isElementWise())
			return super.getArray();
        if (useTempVar())
            return createTempArray();
		if (!isArray())
			return new ScalarAsArray(composeMulScalarCellExp(Index.NULL));
		
		Array res = new Array(indices());
		for (Index i : res.indices()) 
			res.set(i, composeMulScalarCellExp(i));
		return res;
	}
	
	protected FExp FMulExp.composeMulScalarCellExp(Index i) {
		return vectorMultiplication(getLeft().getArray().leftMulIterator(i), 
		                            getRight().getArray().rightMulIterator(i), type());
	}
	
	protected static FExp FExp.vectorMultiplication(Iterator<FExp> left, Iterator<FExp> right, FType type) {
		if (!left.hasNext())
			return type.zeroLiteral();
		FExp cur = new FMulExp( left.next().fullCopy(), right.next().fullCopy());
		while (left.hasNext()) 
			cur = new FAddExp(cur, new FMulExp( left.next().fullCopy(), right.next().fullCopy()));
		return cur;
	}
	
	eq FPowExp.getArray() {
		if (!isArray())
			return new ScalarAsArray(this);
		
		int e = getRight().ceval().intValue();
		if (e <= 0)
			return new FIdentity(new FIntegerLitExp(size().get(0))).getArray();
		
		Array base = getLeft().getArray();
		Array res = base;
		FType type = type();
		for (; e > 1; e--) {
			Array cur = new Array(indices());
			for (Index i : cur.indices()) {
				Iterator<FExp> left = res.leftMulIterator(i);
				Iterator<FExp> right = base.rightMulIterator(i);
				cur.set(i, vectorMultiplication(left, right, type));
			}
			res = cur;
		}
		return res;
	}
	
	eq FTranspose.getArray() {
		Array inner = getFExp().getArray();
		Array res = new Array(indices());
		int[] ind = new int[ndims()];
		Index ti = new Index(ind);
		for (Index i : res.indices()) {
			ind[0] = i.get(1);
			ind[1] = i.get(0);
			for (int j = 2; j < ind.length; j++)
				ind[j] = i.get(j);
			res.set(i, inner.get(ti));
		}
		return res;
	}
	
	eq FSymmetric.getArray() {
		Array inner = getFExp().getArray();
		Array res = new Array(indices());
		int[] ind = new int[ndims()];
		Index ti = new Index(ind);
		for (Index i : res.indices()) {
			ind[0] = i.get(0);
			ind[1] = i.get(1);
			if (ind[0] > ind[1]) {
				int temp = ind[0];
				ind[0] = ind[1];
				ind[1] = temp;
			}
			res.set(i, inner.get(ti));
		}
		return res;
	}
	
	eq FCross.getArray() {
		Array res = new Array(indices());
		Array x = getX().getArray();
		Array y = getY().getArray();
		for (Index i : res.indices()) {
			int j = i.first() % 3 + 1;
			int k = j % 3 + 1;
			FExp m1 = new FMulExp(x.get(j).fullCopy(), y.get(k).fullCopy());
			FExp m2 = new FMulExp(x.get(k).fullCopy(), y.get(j).fullCopy());
			res.set(i, new FSubExp(m1, m2));
		}
		return res;
	}
	
	eq FSkew.getArray() {
		Array res = new Array(indices());
		Array inner = getFExp().getArray();
		Index j = new Index(new int[1]);
		for (Index i : res.indices()) {
			/* Result is:
			 * [    0, -x[3],  x[2];
			 *   x[3],     0, -x[1];
			 *  -x[2],  x[1],     0 ]
			 */
			FExp cell = null;
			j.set(0, 6 - i.get(0) - i.get(1));
			switch ((i.get(0) - i.get(1) + 2) % 3) {
			case 0:
				cell = inner.get(j);
				break;
			case 1:
				cell = new FNegExp(inner.get(j).fullCopy());
				break;
			case 2:
				cell = new FIntegerLitExp(0);
				break;
			}
			res.set(i, cell);
		}
		return res;
	}
	
	eq FOuterProduct.getArray() {
		Array res = new Array(indices());
		Array x = getX().getArray();
		Array y = getY().getArray();
		for (Index i : res.indices()) 
			res.set(i, new FMulExp(x.get(i.first()).fullCopy(), y.get(i.last()).fullCopy()));
		return res;
	}
	
	eq FIdentity.getArray() {
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, new FIntegerLitExp((i.get(0) == i.get(1)) ? 1 : 0));
		return arr;
	}
	
	eq FDiagonal.getArray() {
		Array arr = new Array(indices());
		Array inner = getFExp().getArray();
		for (Index i : arr.indices())
			arr.set(i, (i.get(0) == i.get(1)) ? inner.get(i.subIndex(1)) : new FIntegerLitExp(0));
		return arr;
	}
	
	eq FDimensionConvert.getArray() {
        if (useTempVar())
            return createTempArray();
		Indices ind = indices();
		Array arr = new Array(ind);
		if (getFExp().isArray()) {
			Array x = getFExp().getArray();
			for (Index i : ind)
				arr.set(i, x.get(ind.translate(i)));
		} else {
			Index i = ind.iterator().next();
			arr.set(i, getFExp());
		}
		return arr;
	}
	
	eq FSizeExp.getArray() {
		if (hasDim()) 
			return super.getArray();
		
		Array arr = new Array(indices());
		Size size = getFExp().size();
		for (Index i : arr.indices())
			arr.set(i, size.createFExp(i.first() - 1));
		return arr;
	}
	
	eq FArray.getArray() {
		if (isIterArray())
			return getFExp(0).copyArray();
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			fillArray(arr, i, 0);
		return arr;
	}
	
	eq FAbstractCat.getArray() {
		Array arr = new Array(indices());
		int dim = dimension();
		int adj = 0;
		for (FExp exp : getFExps()) {
			Array expArr = exp.getArray();
			for (Index i : expArr.indices()) 
				arr.set(i.adjusted(dim, adj, ndims()), expArr.get(i));
			adj += (exp.ndims() > dim) ? exp.size().get(dim) : 1;
		}
		return arr;
	}
	
	eq FReductionExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		FIterExp exp = (FIterExp) getFExp();
		Array arr = new Array(indices());
		for (Index i : arr.indices())
			arr.set(i, createNode(exp.extract(i)));
		return arr;
	}	
	
	public FExp FIterExp.extract(Index i) {
		FExp exp = getFExp().getArray().get(i).fullCopy();
		List fil = (List) getForIndexList().fullCopy();
		return new FIterExp(exp, fil);
	}
	
    syn lazy Array FIterExp.createArray() = getFExp().getArray().createExpanded(getForIndexList(), getFExp().myFClass() != null);
	eq FIterExp.getArray() = copyArray();
	
	eq FSubscriptedExp.getArray() {
		if (!isArray()) 
			return new ScalarAsArray(this);
		Array arr = new Array(indices());
		Array old = getFExp().getArray();
		Indices ind = arr.indices();
		for (Index i : ind)
			arr.set(i, old.get(ind.translate(i)));
		return arr;
	}
	
	eq FSmoothExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner = getFExp().getArray();
		for (Index i : arr.indices())
			arr.set(i, new FSmoothExp(getOrder().fullCopy(), inner.get(i)));
		return arr;
	}
	
	eq FVectUnaryBuiltIn.getArray() {
		if (!isArray())
			return super.getArray();
		
		// TODO: This only supports scalar -> scalar functions, see #528
		Array arr = new Array(indices());
		Array inner = getFExp().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner.get(i)));
		return arr;
	}
	
	eq FUnaryBuiltIn.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner = getFExp().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner.get(i)));
		return arr;
	}
	
	eq FEventGenExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner = getX().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner.get(i)));
		return arr;
	}
	
	eq FBinEventGenExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner1 = getX().getArray();
		Array inner2 = getY().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner1.get(i), inner2.get(i)));
		return arr;
	}
	
	eq FMathematicalFunctionCall.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner = getFExp().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner.get(i)));
		return arr;
	}
	
	eq FAtan2Exp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner1 = getFExp().getArray();
		Array inner2 = getY().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner1.get(i), inner2.get(i)));
		return arr;
	}
	
	eq FHomotopyExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner1 = getActual().getArray();
		Array inner2 = getSimplified().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner1.get(i), inner2.get(i)));
		return arr;
	}
	
	eq FSemiLinearExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		Array arr = new Array(indices());
		Array inner1 = getX().getArray();
		Array inner2 = getPosSlope().getArray();
		Array inner3 = getNegSlope().getArray();
		for (Index i : arr.indices())
			arr.set(i, createNode(inner1.get(i), inner2.get(i), inner3.get(i)));
		return arr;
	}
	
	eq FVectorFunctionCall.getArray() {
		Array arr = new Array(indices());
		Size[] sizes = (Size[]) getSizes().clone();
		sizes[0] = Size.SCALAR;
		
		for (Index i : arr.indices()) {
			List<FExp> args = new List<FExp>();
			for (FExp arg : getArgs())
				args.add(arg.getArray().subArrayFExp(i));
			arr.set(i, new FFunctionCall(getName().fullCopy(), args, sizes));
		}
		return arr;
	}

    eq FReinit.getArray() {
        if (!getVar().isArray())
            return super.getArray();
        
        Array arr = new Array(getVar().indices());
        Array inner1 = getVar().getArray();
        Array inner2 = getFExp().getArray();
        for (Index i : arr.indices())
            arr.set(i, new FReinit(inner1.get(i), inner2.get(i)));
        return arr;
    }

    eq FDelayExp.getArray() {
        if (!getFExp().isArray())
            return super.getArray();
        
        Array arr = new Array(getFExp().indices());
        Array exp = getFExp().getArray();
        Array delay = getDelay().getArray();
        Array max = hasMax() ? getMax().getArray() : null;
        for (Index i : arr.indices()) 
            arr.set(i, new FDelayExp(exp.get(i), delay.get(i), (max == null) ? new Opt() : new Opt(max.get(i))));
        return arr;
    }

	/**
	 * Add a copy of this expression to arr at position i. 
	 */
	public void FExp.fillArray(Array arr, Index i, int level) {
		if (isArray())
			arr.set(i, getArray().get(i.subIndex(level)).fullCopy());
		else
			arr.set(i, fullCopy());
	}
	
	/**
	 * Add a copy of the expression at position i to arr. 
	 * 
	 * @param arr    the Array to add the expression to.
	 * @param i      the index to add at, denotes position in both Array and FArray.
	 * @param level  the level this FArray is at in a structure of nestled FArrays.
	 */
	public void FArray.fillArray(Array arr, Index i, int level) {
	    if (isIterArray())
	        super.fillArray(arr, i, level);
	    else
	        getFExp(i.get(level) - 1).fillArray(arr, i, level + 1);
	}

    eq InstFunctionCall.getArray() {
        if (variability().knownParameterOrLess()) {
            Array arr = new Array(indices());
            CValueArray carr = (CValueArray) cevalArray(Index.NULL);
            for (Index i : arr.indices()) {
                arr.set(i, carr.getCell(i).buildInstLiteral());
            }
            return arr;
        }
        return super.getArray();
    }

    eq FFunctionCall.getArray() {
        FClass fc = myFClass();
        if (!isArray() || fc == null)
            return super.getArray();
        
        if (variability().knownParameterOrLess() && inKeptBExp()) {
            Array arr = new Array(indices());
            CValueArray carr = (CValueArray) cevalArray(Index.NULL);
            for (Index i : arr.indices()) {
                arr.set(i, carr.getCell(i).buildLiteral());
            }
            return arr;
        }
        
        FArraySubscripts fas = collectIterExpSubscripts();
        Array arr = new Array(indices());
        for (Index i : arr.indices()) {
            FArraySubscripts fas2 = fas.fullCopy();
            fas2.addFSubscripts(i);
            arr.set(i, new FIdUseExp(tempVarName(), fas2));
        }
        return arr;
    }

	/**
	 * Collect an FArraySubscriptss for the indexes of surrounding iteration expressions, 
	 * to use in getArray() for children.
	 */
	inh FArraySubscripts FExp.collectIterExpSubscripts();
	eq FClass.getChild().collectIterExpSubscripts()   = new FArraySubscripts();
	eq InstRoot.getChild().collectIterExpSubscripts() = new FArraySubscripts();
	eq FIterExp.getFExp().collectIterExpSubscripts() {
		FArraySubscripts res = collectIterExpSubscripts();
		for (CommonForIndex i : getForIndexs())
			res.addFSubscript(i.iterExpSubscript());
		return res;
	}
	
	/**
	 * Creates an FSubscript to use when scalarizing iteration expressions.
	 * 
	 * Returns a use of {@link #uniqueIterExpName()} if there is no current evaluation value, 
	 * or that value if there is one.
	 */
	syn FSubscript CommonForIndex.iterExpSubscript() = 
		evaluationValue().isUnknown() ? 
			new FExpSubscript(new FIdUseExp(uniqueIterExpName())) : 
			new FIntegerSubscript(evaluationValue().intValue());
	
	/**
	 * A name that is not a valid Modelica identifier, and is unique among the iteraton indices 
	 * of nestled iteration expressions.
	 */
	syn lazy String CommonForIndex.uniqueIterExpName() = name() + '|' + iterExpDepth();
	
	/**
	 * The number of nestled iteration expressions surrounding this index or iteration expression.
	 */
	inh int CommonForIndex.iterExpDepth();
	inh int FIterExp.iterExpDepth();
	eq FIterExp.getFExp().iterExpDepth()  = iterExpDepth() + 1;
	eq FClass.getChild().iterExpDepth()   = 0;
	eq InstNode.getChild().iterExpDepth() = 0;
	
	eq FIfExp.getArray() {
		if (!isArray())
			return super.getArray();
		
		if (getThenExp().size().equivalent(getElseExp().size(), inFunction())) {
			Array arr = new Array(indices());
			Array thenArr = getThenExp().getArray();
			Array elseArr = getElseExp().getArray();
			for (Index i : arr.indices()) {
				FExp ifExp = getIfExp().fullCopy();
				arr.set(i, new FIfExp(ifExp, thenArr.get(i), elseArr.get(i)));
			}
			return arr;
		} else {
			return cevalSelectExp().copyArray();
		}
	}
	
	eq FIdUseExp.getArray() {
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			Array array = new Array(indices());
			for (Index i : array.indices()) 
				array.set(i, createNode(getFIdUse().specify(i, false)));
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	eq FInstAccessExp.getArray() {
		if (isArray()) {
			/*
			 * Based on an array access, say x, corresponding to the declaration
			 * Real x[2], the array {x[1],x[2]} is generated. 
			 */
			Indices ind = indices();
			Array array = new Array(ind);
			for (Index i : ind) {
				InstAccess ia = getInstAccess().specify(i);
				array.set(i, new FInstAccessExp(ia));
			}
			return array;
		} else {
			return new ScalarAsArray(this);
		}
	}
	
	public void FExp.setScalarizedFlag() {
		for (FExp child : childFExps())
			child.setScalarizedFlag();
	}
	
	public void FIdUseExp.setScalarizedFlag() {
		getFIdUse().getFQName().scalarized = true;
	}
	
	/**
	 * Returns a scalar FIdUseInstAccess, as specified by an index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  ignored (needed by superclass implementation) 
	 */
	public FIdUseInstAccess FIdUseInstAccess.specify(Index i, boolean scalarize) {
		InstAccess ia = getInstAccess().specify(i);
		return new FIdUseInstAccess(ia);
	}
	
	/**
	 * Returns a scalar FIdUse, as specified by an index.
	 * 
	 * The use is marked scalarized if this use is.
	 * 
	 * @param i  the Index specifying what array subscripts to use
	 */
	public FIdUse FIdUse.specify(Index i) {
		return new FIdUse(getFQName().specify(i));
	}
	
	/**
	 * Returns a scalar FIdUse, as specified by an index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the use should be marked as scalarized 
	 */
	public FIdUse FIdUse.specify(Index i, boolean scalarize) {
		return new FIdUse(getFQName().specify(i, scalarize));
	}
	
	/**
	 * Creates a new FQName with the FArraySubscripts taken from the given Index.
	 * 
	 * The FQName is marked scalarized if this use is.
	 * 
	 * @param i  the Index specifying what array subscripts to use
	 */
	public FQName FQName.specify(Index i) {
		return specify(i, isScalarized());
	}
	
	/**
	 * Creates a new FQName with the FArraySubscripts taken from the given Index.
	 * 
	 * @param i          the Index specifying what array subscripts to use
	 * @param scalarize  <code>true</code> if the FQName should be marked as scalarized 
	 */
	public FQName FQName.specify(Index i, boolean scalarize) {
		FQName fqn = copyAndAddFas(i.createFArraySubscripts());
		fqn.scalarized = scalarize;
		return fqn;
	}
	
	public FQName FQNameFull.specify(Index i, boolean scalarize) {
		FQNameFull res = new FQNameFull();
		int[] dim = new int[1];
		int np = getNumFQNamePart();
		for (int j = 0; j < np; j++) {
			FQNamePart part = getFQNamePart(j);
			int n = part.numFSubscripts();
			if (n == 0 && j == np - 1)
				n = i.ndims() - dim[0];
			FArraySubscripts newfas = null;
			if (n > 0) {
				boolean hasfas = part.hasFArraySubscripts();
				newfas = new FArraySubscripts();
				FArraySubscripts oldfas = hasfas ? part.getFArraySubscripts() : null;
				for (int k = 0; k < n; k++) {
					FSubscript fs = hasfas ?
							oldfas.getFSubscript(k).createSpecified(i, dim) :
							new FIntegerSubscript(i.get(dim[0]++));
					newfas.addFSubscript(fs);
				}
                // If this is last part, append the rest of i to newfas
                while (j == np - 1 && dim[0] < i.ndims())
                    newfas.addFSubscript(i.get(dim[0]++));
			}
			FQNamePart newpart = (newfas == null) ? 
					new FQNamePart(part.getName()) : 
					new FQNamePartArray(part.getName(), newfas);
			res.addFQNamePart(newpart);
		}
		res.scalarized = scalarize;
		return res;
	}
	
	/**
	 * Creates a new FSubscript that specifies this array subscript to a single index.
	 * 
	 * - For scalar subscripts, a copy is returned.
	 * - For colon subscripts, the given index is used as the new subscript.
	 * - For other vector subscripts, the given index is used as the index of a 
	 *   cell in the vector, and that cell is used as the new subscript.
	 *   In this case, dim will be incremented.
	 * 
	 * @param i    the Index specifying what array subscripts to use
	 * @param dim  the dimension in <code>i</code> to use, 
	 *             wrapped in an array so that it can be changed by the method
	 */
	public FSubscript FSubscript.createSpecified(Index i, int[] dim) {
		return fullCopy();
	}
	
	public FSubscript FColonSubscript.createSpecified(Index i, int[] dim) {
		return new FIntegerSubscript(i.get(dim[0]++));
	}
	
	public FSubscript FExpSubscript.createSpecified(Index i, int[] dim) {
		if (ndims() == 0)
			return fullCopy();
		
		int index = i.get(dim[0]++) - 1;
		return new FExpSubscript(getFExp().getArray().getFExp(index));
	}
	
	/**
	 * Gets the number of FSubscripts in the FArraySubscripts of this FQNamePart, if any.
	 */
	syn int FQNamePart.numFSubscripts() = 
		hasFArraySubscripts() ? getFArraySubscripts().getNumFSubscript() : 0;
	
	/**
	 * Creates a new InstAccess with the FArraySubscripts taken from the given Index.
	 * 
	 * @param i  the Index specifying what array subscripts to use
	 */
	public InstAccess InstAccess.specify(Index i) {
		return specifyEach(i, new int[1]);
	}

	/**
	 * Create a copy with the FArraySubscripts of each part set to match the Index.
	 * 
	 * @param i    the Index specifying what array subscripts to use
	 * @param dim  the next dimension in <code>i</code> to use, 
	 *             wrapped in an array so that it can be changed by the method
	 */
	protected InstAccess InstAccess.specifyEach(Index i, int[] dim) {
		return (InstAccess) fullCopy();
	}

	protected InstDot InstDot.specifyEach(Index i, int[] dim) {
		List<InstAccess> l = new List<InstAccess>();
		for (InstAccess ia : getInstAccesss())
			l.add(ia.specifyEach(i, dim));
		return new InstDot(l);
	}

	protected InstGlobalAccess InstGlobalAccess.specifyEach(Index i, int[] dim) {
		return new InstGlobalAccess(getInstAccess().specifyEach(i, dim));
	}
	
	protected InstNamedAccess InstScalarAccess.specifyEach(Index i, int[] dim) { //TODO:Necessary?
		FArraySubscripts oldfas = allFArraySubscripts().get(0);
		int n = oldfas.getNumFSubscript();
		if (n > 0) {
			FArraySubscripts newfas = new FArraySubscripts();
			for (int k = 0; k < n; k++) {
				FSubscript fs = oldfas.getFSubscript(k).createSpecified(i, dim);
				newfas.addFSubscript(fs);
			}
			return getArrayCopy(newfas);
		} else {
			return fullCopy();
		}
	}
	
	syn InstArrayAccess InstScalarAccess.getArrayCopy(FArraySubscripts fas);
	eq InstParseAccess.getArrayCopy(FArraySubscripts fas) = new InstParseArrayAccess(getID(), fas);
	eq InstAmbiguousAccess.getArrayCopy(FArraySubscripts fas) = new InstAmbiguousArrayAccess(getID(), fas);
	eq InstComponentAccess.getArrayCopy(FArraySubscripts fas) = new InstComponentArrayAccess(getID(), fas);

	protected InstNamedAccess InstArrayAccess.specifyEach(Index i, int[] dim) {
		InstArrayAccess res = fullCopy();
		FArraySubscripts oldfas = allFArraySubscripts().get(0);
		int n = oldfas.getNumFSubscript();
		if (n > 0) {
			FArraySubscripts newfas = new FArraySubscripts();
			for (int k = 0; k < n; k++) {
				FSubscript fs = oldfas.getFSubscript(k).createSpecified(i, dim);
				newfas.addFSubscript(fs);
			}
			res.setFArraySubscripts(newfas);
		}
		return res;
	}

	eq FRangeExp.getArray() {
		//log.debug("FRangeExp.getArray(): size = " + size().get(0));
		Array array = new Array(indices());
		if (type().isReal()) {
			double i1 = getFExp(0).ceval().realValue();
			double i2 = 1.0;
			if (hasStep()) 
				i2 = getFExp(1).ceval().realValue();
			for (Index i : array.indices()) { 
				array.set(i, new FRealLitExp(i1));
				i1 += i2;
			}
		} else {
			int i1 = getFExp(0).ceval().intValue();
			int i2 = 1;
			if (hasStep()) 
				i2 = getFExp(1).ceval().intValue();
			for (Index i : array.indices()) { 
				array.set(i, type().createLiteral(i1));
				i1 += i2;
			}
		}
		
		return array;
	}
	
	eq FLinspace.getArray() {
		int n = size().get(0);
		FExp len = new FSubExp(getStopExp().fullCopy(), getStartExp().fullCopy());
		FExp step = new FDivExp(len, new FIntegerLitExp(n - 1));
		Array array = new Array(indices());
		for (Index i : array.indices()) {
			FExp part = new FMulExp(new FIntegerLitExp(i.first() - 1), step.unboundCopy());
			array.set(i, new FAddExp(getStartExp().fullCopy(), part));
		}
		return array;
	}
	
	eq FArrayDimAsArgsExp.getArray() = new Array(indices()).fill(fillExp());
	
	/**
	 * Get the expression the array is filled with.
	 * 
	 * E.g. a literal 1 in the case of <code>ones()</code>.
	 * Will only create new nodes if necessary.
	 */
	syn FExp FArrayDimAsArgsExp.fillExp();
	eq FZeros.fillExp()   = new FIntegerLitExp(0);
	eq FOnes.fillExp()    = new FIntegerLitExp(1);
	eq FFillExp.fillExp() = getFillExp();
	
	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FExp.indices()                   = Indices.create(size());
	syn lazy Indices FAbstractArrayExp.indices() = super.indices();
	eq FIdUseExp.indices()                       = getFIdUse().indices();
	eq FInstAccessExp.indices()                  = getInstAccess().indices();
	eq FDimensionConvert.indices() {
		int n = getFExp().ndims();
		if (n == 0) {
			return Indices.create(size());
		} else {
			int extra = Math.max(ndims() - n, 0);
            int[] keep = dimensionsToKeep();
            if (keep.length + extra == 0)
                return Indices.create(Size.SCALAR);
            return NonConsecutiveIndices.create(getFExp().size(), keep, extra);
		}
	}
	
	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FArraySubscripts.indices() = Indices.createFromFas(this);
	
	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FSubscript.indices() = Indices.create(size());
	
	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FType.indices() = Indices.create(size());
	
	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FExpSubscript.indices() = getFExp().indices();

	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FIdUse.indices() = Indices.createFromFas(allFArraySubscripts());
	syn Indices FIdUseInstAccess.indices() = getInstAccess().indices();

	/**
	 * Get the set of all array indices of an instance array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices InstAccess.indices() = Indices.createFromFas(qualifiedAllFArraySubscripts());
		
	/**
	 * Get the set of all array indices of an subscripted array expression. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FSubscriptedExp.indices() = getFArraySubscripts().indices();

	/**
	 * Get the set of all array indices of an instance primitive component. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstAssignable.indices() = Indices.create(size());

	/**
	 * Get the set of all array indices of an FVariable. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices FAbstractVariable.indices() = null;
	eq FVariable.indices()      = isScalarized() ? null : Indices.create(size());
	eq FFunctionArray.indices() = Indices.create(size());

	/**
	 * Get the set of all array indices of an InstComponentDecl. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn lazy Indices InstComponentDecl.indices() = Indices.create(size());
	
	/**
	 * Get the set of all array indices of an array access. 
	 * 
	 * @return An Indices object containing all indices in each array dimension.
	 */
	syn Indices FEquation.indices() = getLeft().indices();
	
	/**
	 * Get the set of all indices this array subscript spans.
	 * 
	 * @return an int array containing the indices spanned
	 */
	syn int[] FSubscript.myIndices();
	
	eq FColonSubscript.myIndices() {
		int n = size().get(0);
		if (n < 0)
			return new int[0];
		int[] ind = new int[n];
		for (int i = 0; i < n; i++)
			ind[i] = i + 1;
		return ind;
	}
	
	eq FExpSubscript.myIndices()     = getFExp().myIndices();
	eq FIntegerSubscript.myIndices() = new int[] { getValue() };
	
	syn int[] FExp.myIndices() {
		try {
			int n = 0;
			if (ndims() == 0)
				n = 1;
			else if (ndims() == 1)
				n = size().get(0);
			if (n > 0) {
				int[] indices = new int[n];
				int j = 0;
				for (CValue val : ceval())
					indices[j++] = val.intValue();
				return indices;
			}
		} catch (ConstantEvaluationException e) {
		}
		return new int[0];
	}
	
	/**
	 * Get the set of all values this for index spans.
	 * 
	 * @return an int array containing the values spanned
	 */
	syn int[] FForIndex.myIndices() {
		if (hasFExp())
			return getFExp().myIndices();
		else
			return new int[0]; // TODO: return 1..n, where n is given by use.
	}
	
	/**
	 * Get the set of all values this for index spans.
	 * 
	 * @return an int array containing the values spanned
	 */
	syn int[] InstForIndex.myIndices() {
		if (hasFExp())
			return getFExp().myIndices();
		else
			return new int[0]; // TODO: return 1..n, where n is given by use.
	}
	
	/**
	 * Try to infer type of an expression from its surrounding Array.
	 * 
	 * An FExp that is the direct child of an Array always has the same type as the Array, except scalar.
	 * 
	 * @return  if this expression is in an Array, the inferred type, otherwise type()
	 */
	syn FType FExp.inferType() = inArray() ? inferredType() : type();
	
	/**
	 * Check if this expression is the direct child of an Array.
	 */
	inh boolean FExp.inArray();
	inh boolean List.inArray();
	eq List.getChild().inArray()    = inArray();
	eq Array.getChild().inArray()   = true;
	eq ASTNode.getChild().inArray() = false;
	
	/**
	 * Helper attribute to {@link FExp#inferType()}.
	 */
	inh FType FExp.inferredType();
	inh FType List.inferredType();
	eq List.getChild().inferredType()    = inferredType();
	eq Array.getChild().inferredType()   = type().scalarType();
	eq ASTNode.getChild().inferredType() = null;

	/**
	 * The type of the expression this Array belongs to.
	 */
	inh FType Array.type();
	eq FExp.getArray().type()             = type();
	eq FExpSubscript.getExpanded().type() = type();

}

aspect ArrayHelpers {
	
	/**
	 * An array size. Can be multi-dimensional.
	 */
	public class Size {
		
		/**
		 * Used for unknown lengths.
		 */
		public static final int UNKNOWN = -1;
		
		/**
		 * Used to represent the size of scalar expressions.
		 */
		public static final Size SCALAR = new Size();
		
		protected int[] size;
		
		/**
		 * Private constructor that creates a scalar size.
		 */
		private Size() {
			size = new int[0];
		}
		
		/**
		 * Constructs a Size with the given lengths.
		 */
		public Size(int... size) {
			if (size.length == 0)
				throw new IllegalArgumentException();
			this.size = size;
		}
		
		/**
		 * Get the number of dimensions.
		 */
		public int ndims() {
			return size.length;
		}
		
		/**
		 * Get length in the <code>i</code>th dimension.
		 */
		public int get(int i) {
			return (i >= 0 && i < size.length) ? size[i] : UNKNOWN;
		}
		
		/**
		 * Get length in the last dimension.
		 */
		public int last() {
			return get(size.length - 1);
		}
		
		/**
		 * Check if this size has an <code>i</code>th dimension.
		 */
		public boolean has(int i) {
			return size.length > i;
		}
		
		/**
		 * Returns the number of elements spanned by this Size.
		 * 
		 * Only valid if all dimensions are known or currently evaluable.
		 */
		public int numElements() {
			int res = 1;
			for (int i = 0; i < size.length && res > 0; i++)
				res *= get(i);
			return res < 0 ? 0 : res;
		}
		
        /**
         * True if any dimension is verified to be zero
         */
        public boolean isZero() {
            return !isUnknown() && numElements() == 0;
        }
		
		/**
		 * Create a new flattened FArraySubscripts object describing this size.
		 */
		public FArraySubscripts flattenFArraySubscripts(FQName prefix) {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < size.length; i++)
				fas.addFSubscript(flattenFSubscript(i, prefix));
			return fas;
		}
		
		/**
		 * Create a new flattened FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript flattenFSubscript(int i, FQName prefix) {
			return size[i] == UNKNOWN ? new FColonSubscript() : new FIntegerSubscript(size[i]);
		}
		
		/**
		 * Create a new FArraySubscripts object with ranges spanning this size.
		 */
		public FArraySubscripts rangeFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (int i = 0; i < size.length; i++)
				fas.addFSubscript(rangeFSubscript(i));
			return fas;
		}
		
		/**
		 * Create a new FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript rangeFSubscript(int i) {
			return size[i] == UNKNOWN ? new FColonSubscript() : new FExpSubscript(new FRangeExp(1, size[i]));
		}
		
		/**
		 * Check if any lengths are unknown.
		 */
		public boolean isUnknown() {
			for (int s : size)
				if (s == UNKNOWN)
					return true;
			return false;
		}
        
        /**
         * Check if length in dimension d is unknown.
         */
        public boolean isUnknown(int d) {
            return size[d] == UNKNOWN;
        }
        
		/**
		 * Check if all lengths have a value (fix length or expression).
		 */
		public boolean isComplete() {
			for (int i = 0; i < size.length; i++)
				if (!hasValue(i))
					return false;
			return true;
		}
		
		/**
		 * Check is the length in any dimension equals 0.
		 */
		public boolean isEmpty() {
			for (int i = 0; i < size.length; i++)
				if (read(i) == 0)
					return true;
			return false;
		}
		
		/**
		 * Check if a given index fits within this size.
		 * 
		 * Unknown lengths are assumed to be long enough.
		 */
		public boolean isOKIndex(Index i) {
			int[] ind = i.index();
			if (size.length != ind.length)
				return false;
			for (int j = 0; j < size.length; j++) {
				int a = ind[j];
				int b = get(j);
				if (a < 1 || (a > b && b != UNKNOWN))
					return false;
			}
			return true;
		}
		
		/**
		 * Check if the lengths in the given dimension has a value (fix length or integer).
		 */
		protected boolean hasValue(int dim) {
			return size[dim] != UNKNOWN;
		}
		
		/**
		 * Create a copy of this size.
		 */
		protected Size clone() {
			return (size.length == 0) ? SCALAR : new Size(size.clone());
		}
		
		/**
		 * Create a copy of this size as a MutableSize.
		 */
		public MutableSize mutableClone() {
			MutableSize ms = new MutableSize(size.length);
			System.arraycopy(size, 0, ms.size, 0, size.length);
			return ms;
		}
		
		/**
		 * Create a copy of this with <code>dim</code> dimensions, if necessary 
		 *        adding dimensions of length 1 to the right side, or removing dimensions 
		 *        from the left side.
		 */
		public Size promote(int dim) {
			if (dim == size.length) 
				return this;
			if (dim == 0)
				return SCALAR;
			Size ns = new Size(new int[dim]);
			int old = dim < size.length ? dim : size.length;
			System.arraycopy(size, size.length - old, ns.size, 0, old);
			Arrays.fill(ns.size, old, dim, 1);
			return ns;
		}
		
		/**
		 * If this size contains any dimensions that are represented with expressions, then creates 
		 * and attempts to evaluate a copy of this size. Otherwise, return this.
		 */
		public Size evaluated() {
		    return this;
		}
		
        /**
         * Replace FUnknownSizeExps with equivalent FSizeExps
         */
        public void replaceUnknowns(FFunctionVariable parent) {}
		
		/**
		 * Return a Size that have the same lengths as this size where they are known, 
		 *        and any that are unknown copied from the size of <code>exp</code>. 
		 * 
		 * If the size of <code>exp</code> have more dimensions, the last part is assumed to match this size.
		 */
		public Size createKnown(FExp exp) {
			Size known;
			if (!exp.size().isUnknown() || this instanceof MutableSize) { 
				known = clone();
			} else {
				known = new MutableSize(size.length);
				System.arraycopy(size, 0, known.size, 0, size.length);
			}
			known.fillUnknownFrom(exp);
			return known;
		}
		
		/**
		 * Return a Size that have the same lengths as this size where they are known, 
		 * and any that are unknown in this size but known in <code>s</code> is copied from there. 
		 */
		public Size createKnown(Size s) {
			Size known = clone();
			for (int i = 0; i < size.length; i++)
				if (known.size[i] == UNKNOWN && s.size[i] != UNKNOWN)
					known.set(i, s.size[i]);
			return known;
		}
		
		/**
		 * Sets length <code>i</code> to <code>s</code>.
		 */
		protected void set(int i, int s) {
			size[i] = s;
		}
		
		/**
		 * For each unknown length, copy the equivalent length from size of <code>exp</code>. 
		 * 
		 * If the size of <code>exp</code> have more dimensions than this, the last part is ignored.
		 */
		protected void fillUnknownFrom(FExp exp) {
			Size other = exp.size();
			if (other.size.length >= size.length)
				for (int i = 0; i < size.length; i++) 
					if (!hasValue(i))
						copyFrom(i, exp, i);
		}
		
		/**
		 * Copy value of dimension <code>d2</code> in <code>other</code> to dimension 
		 *        <code>d1</code> in <code>this</code>.
		 */
		protected void copyFrom(int d1, FExp exp, int d2) {
			size[d1] = exp.size().size[d2];
		}
		
		/**
		 * Check if another object is equal to this one.
		 */
		public boolean equals(Object s) {
			return s instanceof Size && equivalent((Size) s, false);
		}
		
		/**
		 * Calculate hash code.
		 */
		public int hashCode() {
			int res = 0;
			for (int i = 0; i < size.length; i++)
				res = (res << 8) ^ size[i];
			return res;
		}
		
		/**
		 * Check if another size is equivalent to this one.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length, 
		 *                      otherwise consider unknown lengths to differ from all lengths, including
		 *                      other unknown lengths
		 */
		public boolean equivalent(Size s, boolean allowUnknown) {
			return equivalentExcept(s, allowUnknown, -1);
		}
		
		/**
		 * Check if another size is equivalent to this one, except in a given dimension.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length
		 * @param dim			dimension not to check
		 */
		public boolean equivalentExcept(Size s, boolean allowUnknown, int dim) {
			if (size.length != s.size.length)
				return false;
			for (int i = 0; i < size.length; i++) 
				if (i != dim && !equivalentDim(s, allowUnknown, i, i)) 
					return false;
			return true;
		}
		
		/**
		 * Check if a specific dimension of another size is equivalent to a specific 
		 *        dimension of this one.
		 * 
		 * @param allowUnknown  if <code>true</code>, consider unknown lengths equal to any length
		 * @param myDim         the dimension in this Size to compare
		 * @param itsDim        the dimension in the other Size to compare
		 */
		public boolean equivalentDim(Size s, boolean allowUnknown, int myDim, int itsDim) {
			int myLen = read(myDim);
			int itsLen = s.read(itsDim);
			boolean same = myLen == itsLen;
			if (same || !allowUnknown)
				return same;
			return myLen == UNKNOWN || itsLen == UNKNOWN;
		}
		
		/**
		 * Make sure that size is final, then get value of size[i].
		 */
		protected int read(int i) {
			return size[i];
		}
		
		private static final String SEP = ", ";
		
		/**
		 * Returns a string representation on the form "[l1, l2, l3]".
		 */
		public String toString() {
			if (size.length == 0)
				return "scalar";
			StringBuilder buf = new StringBuilder("[");
			String prefix = "";
			for (int i = 0; i < size.length; i++) {
				buf.append(prefix);
				buf.append(toString(i));
				prefix = SEP;
			}
			buf.append("]");
			return buf.toString();
		}
		
		/**
		 * Returns a string representation of a single length.
		 */
		protected String toString(int i) {
			return (size[i] == UNKNOWN) ? ":" : Integer.toString(size[i]);
		}
		
		/**
		 * Returns a string representation on the form "l1, l2, l3".
		 */
		public String toUnclosedString() {
			String tmp = toString();
			return tmp.substring(1, tmp.length() - 1);
		}
		
		/**
		 * Creates a new Size that is a copy of this one, but with dimensions removed 
		 * from each side. If nothing is changed, <code>this</code> is returned. 
		 * 
		 * @param left   the number of dimensions to remove from the left side
		 * @param right  the number of dimensions to remove from the right side
		 */
		public Size contract(int left, int right) {
			int ndims = size.length - left - right;
			if (ndims == size.length)
				return this;
			if (ndims == 0)
				return Size.SCALAR;
			int[] ns = new int[ndims];
			System.arraycopy(size, left, ns, 0, ndims);
			return new Size(ns);
		}
		
		/**
		 * Creates a new Size that is a copy of this one, but with dimensions removed 
		 * from the left side. If nothing is changed, <code>this</code> is returned. 
		 * 
		 * @param n   the number of dimensions of the new size
		 */
		public Size contractLeft(int n) {
			return contract(size.length - n, 0);
		}
		
		/**
		 * Creates a new Size that is a copy of this one, but with dimensions removed 
		 * from the right side. If nothing is changed, <code>this</code> is returned. 
		 * 
		 * @param n   the number of dimensions of the new size
		 */
		public Size contractRight(int n) {
			return contract(0, size.length - n);
		}
		
		/**
		 * Creates a new Size that is a copy of this one, but with one more dimension 
		 * on the left side.
		 * 
		 * @param s  the length of the new dimension
		 */
		public Size expand(int s) {
			int[] ns = new int[size.length + 1];
			ns[0] = s;
			System.arraycopy(size, 0, ns, 1, size.length);
			return new Size(ns);
		}
		
        /**
         * Creates a new Size that is a copy of this one, but with one more dimension 
         * on the right side.
         * 
         * @param s  the length of the new dimension
         */
        public Size expandRight(int s) {
            int[] ns = new int[size.length + 1];
            System.arraycopy(size, 0, ns, 0, size.length);
            ns[size.length] = s;
            return new Size(ns);
        }
        
		/**
		 * Creates a new Size that is a concatenation of <code>s</code> and this size.
		 * 
		 * <code>s</code> is added on the left side.
		 */
		public Size expand(Size s) {
			return s.expandFrom(this);
		}
		
		/**
		 * Delegate method for expand(Size). Double dispatch is needed there.
		 */
		protected Size expandFrom(Size s) {
            int ndims = size.length + s.size.length;
            if (ndims == 0)
                return Size.SCALAR;
            int[] ns = new int[ndims];
            System.arraycopy(size, 0, ns, 0, size.length);
            System.arraycopy(s.size, 0, ns, size.length, s.size.length);
            return new Size(ns);
		}
		
		/**
		 * Create an FExp that describes the length of dimension <code>d</code>, 
		 *        given the supplied variable values.
		 *        
		 * @param varMap  a map of variables to replace and expressions to replace them with
		 */
		public FExp createSizeFExp(int d, Map<ASTNode, FExp> varMap) {
			return createFExp(d);
		}
        
        /**
         * Create an FArraySubscripts that defines this size as used in variable declarations.
         * 
         * Dimension that nothing is known about get an FColonSubscript.
         */
        public FArraySubscripts createFArraySubscripts() {
            FArraySubscripts res = new FArraySubscripts();
            for (int i = 0; i < ndims(); i++)
                res.addFSubscript(createFSubscript(i));
            return res;
        }
        
        /**
         * Create an FSubscript that defines the length of dimension <code>d</code>.
         * 
         * If nothing is known of the length of the dimension, an FColonSubscript is created.
         */
        public FSubscript createFSubscript(int d) {
            return hasValue(d) ? new FExpSubscript(createFExp(d)) : new FColonSubscript();
        }
		
		/**
		 * Create an FArraySubscripts that spans this size.
		 * 
		 * Dimension that nothing is known about get an FColonSubscript.
		 */
		public FArraySubscripts createExpandedFArraySubscripts() {
			FArraySubscripts res = new FArraySubscripts();
			for (int i = 0; i < ndims(); i++)
				res.addFSubscript(createExpandedFSubscript(i));
			return res;
		}
		
		/**
		 * Create an FSubscript that spans the length of dimension <code>d</code>.
		 * 
		 * If nothing is known of the length of the dimension, an FColonSubscript is created.
		 */
		public FSubscript createExpandedFSubscript(int d) {
			if (hasValue(d)) {
				List<FExp> lim = new List<FExp>();
				lim.add(new FIntegerLitExp(1));
				lim.add(createFExp(d));
				return new FExpSubscript(new FRangeExp(lim));
			} else {
				return new FColonSubscript();
			}
		}
		
		/**
		 * Create an FExp that describes this size.
		 * 
		 * The resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp() {
			List<FExp> cells = new List<FExp>();
			for (int i = 0; i < size.length; i++)
				cells.add(createFExp(i));
			return new FArray(cells);
		}
		
		/**
		 * Create an FExp that describes the length of dimension <code>d</code>.
		 * 
		 * The resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp(int d) {
			return new FIntegerLitExp(size[d]);
		}
		
		/**
		 * Create an FExp that describes the number of elements of this size.
		 */
		public FExp createNumElementsFExp() {
			return new FIntegerLitExp(numElements());
		}
		
		/**
		 * Create a dummy expression that has the size described by this Size.
		 */
		public FExp createDummyFExp(Map<ASTNode, FExp> varMap) {
			FZeros z = new FZeros();
			for (int i = 0; i < size.length; i++)
				z.addFExp(createSizeFExp(i, varMap));
			return z;
		}
		
		/**
		 * Create a zero expression of this size.
		 */
		public FExp createZeroFExp() {
			if (size.length == 0) {
				return new FIntegerLitExp(0);
			} else {
				FZeros res = new FZeros();
				for (int i = 0; i < size.length; i++)
					res.addFExp(createFExp(i));
				return res;
			}
		}
		
		public FFunctionVariable createFunctionVariable(String name, FType type) {
		    return createFunctionVariable(name, type, new Opt<FTypePrefixInputOutput>());
		}
		
		public FFunctionVariable createFunctionVariable(String name, FType type, FTypePrefixInputOutput inputOutput) {
		    return createFunctionVariable(name, type, new Opt<FTypePrefixInputOutput>(inputOutput));
		}
		
		public FFunctionVariable createFunctionVariable(String name, FType type, Opt<FTypePrefixInputOutput> inputOutput) {
		    if (this == Size.SCALAR)
		        return new FFunctionVariable(inputOutput, type.scalarType(), new Opt<FExp>(), new FQNameString(name));
		    else
		        return new FFunctionArray(inputOutput, type.arrayType(this), new Opt<FExp>(), new FQNameString(name));
		}
		
	}
	
	/**
	 * A mutable Size that can handle FExp sizes, possibly with unknown ceval().
	 */
	public class MutableSize extends Size {
		
		private int i;
		private FExp[] exps;
		private boolean[] evaluated;
		
		/**
		 * Constructs a new mutable Size of <code>ndims</code> dimensions.
		 */
		public MutableSize(int ndims) {
			super(new int[ndims]);
			Arrays.fill(size, UNKNOWN);
			exps = new FExp[ndims];
			i = 0;
			evaluated = new boolean[ndims];
		}
		
		/**
		 * Constructs the size descrived by a vector expression.
		 */
		public MutableSize(FExp exp) {
			this(exp.ndims() == 1 ? exp.size().get(0) : 0);
			for (FExp dim : exp.getArray().iterable())
				append(dim);
		}
		
		/**
		 * Sets the next length to <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(int s) {
			set(i++, s);
		}
		
		/**
		 * Sets the next length to the value of <code>e</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(FExp e) {
			set(i++, e);
		}
		
		/**
		 * Sets the next length to the length of dimension <code>d</code> 
		 *        of <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(Size s, int d) {
			set(i++, s, d);
		}
		
		/**
		 * Sets the next <code>s.ndims()</code> lengths from <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void append(Size s) {
			if (s instanceof MutableSize) {
				MutableSize ms = (MutableSize) s;
				for (int j = 0; j < ms.size.length; j++, i++) {
					exps[i] = ms.exps[j];
					size[i] = ms.size[j];
				}
			} else {
				for (int si : s.size) {
					exps[i] = null;
					size[i++] = si;
				}
			}
		}
		
		/**
		 * Sets length <code>i</code> to <code>s</code>.
		 */
		public void set(int i, int s) {
			size[i] = s;
			exps[i] = null;
		}
		
		/**
		 * Sets length <code>d</code> to the value of <code>e</code>.
		 */
		public void set(int d, FExp e) {
			int s = UNKNOWN;
			if (okExp(e) && e.hasOnlyLiterals()) {
				try {
					s = e.ceval().intValue();
				} catch (ConstantEvaluationException uoe) {
				}
			}
			size[d] = s;
			exps[d] = (s == UNKNOWN) ? e : null;
		}
		
		/**
		 * Sets length <code>d1</code> to the length of dimension <code>d2</code> 
		 *        of <code>s</code>.
		 * 
		 * May overwrite lengths set with <code>set()</code>.
		 */
		public void set(int d1, Size s, int d2) {
			size[d1] = s.size[d2];
			exps[d1] = (s instanceof MutableSize) ? ((MutableSize) s).exps[d2] : null;
		}
		
		/**
		 * Make sure dimension i of size is ready to use.
		 */
		private void evaluate(int i) {
			if (i >= 0 && i < evaluated.length && !evaluated[i]) {
				evaluated[i] = true;
				if (exps[i] != null) {
					try {
						size[i] = exps[i].ceval().intValue();
						exps[i] = null;
					} catch (ConstantEvaluationException e) {
					}
				}
			}
		}
		
		/**
		 * Make sure size is ready to use.
		 */
		private void evaluate() {
			for (int i = 0; i < size.length; i++) 
				evaluate(i);
		}
		
        /**
         * Replace FUnknownSizeExps with equivalent FSizeExps
         */
        public void replaceUnknowns(FFunctionVariable parent) {
            for (int i = 0; i < exps.length; i++) {
                if (exps[i] != null) {
                    exps[i] = exps[i].createSizeFExp();
                    exps[i].parent = parent;
                }
            }
        }
		
		/**
		 * Adds <code>s</code> to length <code>d</code>.
		 */
		public void add(int d, int s) {
			if (s == UNKNOWN) {
				size[d] = UNKNOWN;
				exps[d] = null;
			} else if (size[d] != UNKNOWN) {
				size[d] += s;
			} else if (exps[d] != null) {
				FExp e = new FAddExp(exps[d].createSizeFExp(), new FIntegerLitExp(s));
				exps[d] = exps[d].dynamicFExp(e);
			}
		}
		
		/**
		 * Adds the value of <code>e</code> to length <code>d</code>.
		 */
		public void add(int d, FExp e) {
			try {
				add(d, e.ceval().intValue());
			} catch (ConstantEvaluationException uoe) {
				FExp e2 = new FAddExp(createFExp(d), e.createSizeFExp());
				exps[d] = e.dynamicFExp(e2);
				size[d] = UNKNOWN;
			}
		}
		
		/**
		 * Adds the length of dimension <code>d2</code> of <code>s</code> 
		 *        to length <code>d1</code> of this size.
		 */
		public void add(int d1, Size s, int d2) {
			FExp e = (s instanceof MutableSize) ? ((MutableSize) s).exps[d2] : null;
			if (e != null)
				add(d1, e);
			else
				add(d1, s.size[d2]);
		}
		
		/**
		 * Get length in the <code>i</code>th dimension.
		 */
		public int get(int i) {
			evaluate(i);
			if (i < 0 || i >= size.length)
				return UNKNOWN;
			if (exps[i] == null) // We want to evaluate FUnknownSizeExps as well
				return size[i];
			try {
				return exps[i].ceval().intValue();
			} catch (ConstantEvaluationException e) {
				return UNKNOWN;
			}
		}
		
		/**
		 * Check if the lengths in the given dimension has a value (fix length or integer).
		 */
		protected boolean hasValue(int dim) {
			return size[dim] != UNKNOWN || okExp(exps[dim]);
		}
		
        /**
         * Check if an expression is valid.
         */
        protected static boolean okExp(FExp e) {
            return okExp(e, false);
        }
        
        protected static boolean okExp(FExp e, boolean allowUnknownSize) {
            return e != null && e.isValidExp(allowUnknownSize);
        }
		
		/**
		 * Copy value of dimension <code>d2</code> in size of <code>exp</code> to dimension 
		 *        <code>d1</code> in <code>this</code>.
		 */
		protected void copyFrom(int d1, FExp exp, int d2) {
			set(d1, exp.size(), d2);
			if (exps[d1] != null && exps[d1] instanceof FUnknownSizeExp)
				exps[d1] = exps[d1].dynamicFExp(exps[d1].createSizeFExp());
			if (!hasValue(d1)) {
				FExp copyExp = exp.fullCopy();
				Opt dimExp = new Opt(new FIntegerLitExp(d2 + 1));
				FSizeExp sizeExp  = new FSizeExp(copyExp, dimExp);
				exps[d1] = exp.dynamicFExp(sizeExp);
			}
		}
		
		/**
		 * Creates a new Size that is a copy of this one, but with dimensions removed 
		 * from each side.
		 * 
		 * @param left   the number of dimensions to remove from the left side
		 * @param right  the number of dimensions to remove from the right side
		 */
		public Size contract(int left, int right) {
			int ndims = size.length - left - right;
			if (ndims == 0)
				return Size.SCALAR;
			MutableSize ns = new MutableSize(ndims);
			System.arraycopy(size, left, ns.size, 0, ndims);
			System.arraycopy(exps, left, ns.exps, 0, ndims);
			return ns;
		}
		
		/**
		 * Creates a new Size that is a copy of this one, but with one more dimension 
		 * on the left side.
		 * 
		 * @param s  the length of the new dimension
		 */
		public Size expand(int s) {
			evaluate();
			MutableSize ns = new MutableSize(size.length + 1);
			ns.size[0] = s;
			ns.exps[0] = null;
			System.arraycopy(size, 0, ns.size, 1, size.length);
			System.arraycopy(exps, 0, ns.exps, 1, size.length);
			return ns;
		}
		
		/**
		 * Creates a new Size that is a concatenation of <code>s</code> and this size.
		 * 
		 * <code>s</code> is added on the left side.
		 */
		public Size expand(Size s) {
            return createExpanded(s, this);
        }
        
        /**
         * Delegate method for expand(Size). Double dispatch is needed there.
         */
        protected Size expandFrom(Size s) {
            return createExpanded(this, s);
        }
        
        private static Size createExpanded(Size a, Size b) {
			int ndims = a.size.length + b.size.length;
			if (ndims == 0)
				return Size.SCALAR;
			MutableSize ns = new MutableSize(ndims);
			if (a instanceof MutableSize) {
			    MutableSize m = (MutableSize) a;
			    m.evaluate();
				System.arraycopy(m.exps, 0, ns.exps, 0, m.size.length);
			}
            if (b instanceof MutableSize) {
                MutableSize m = (MutableSize) b;
                m.evaluate();
                System.arraycopy(m.exps, 0, ns.exps, a.size.length, m.size.length);
            }
			System.arraycopy(a.size, 0, ns.size, 0, a.size.length);
			System.arraycopy(b.size, 0, ns.size, a.size.length, b.size.length);
			return ns;
		}
		
        /**
         * Create an FExp that describes the length of dimension <code>d</code>, 
         *        given the supplied variable values.
         *        
         * @param varMap  a map of variables to replace and expressions to replace them with
         */
        public FExp createSizeFExp(int d, Map<ASTNode, FExp> varMap) {
            evaluate(d);
            return (okExp(exps[d], true)) ?
                    exps[d].createSizeFExp(varMap) :
                    super.createSizeFExp(d, varMap);
        }
		
		/**
		 * Create an FExp that describes the length of dimension <code>d</code>.
		 * 
		 * the resulting expression is not expanded like createSizeFExp().
		 */
		public FExp createFExp(int d) {
			evaluate(d);
            return (okExp(exps[d], true)) ?
					exps[d].createSizeFExp() : 
					super.createFExp(d);
		}
		
		/**
		 * Create an FExp that describes the number of elements of this size.
		 */
		public FExp createNumElementsFExp() {
			evaluate();
			int known = 1;
			FExp res = null;
			for (int i = 0; i < size.length; i++) {
				// TODO: this will fail if hasValue(i) == false
				if (size[i] == UNKNOWN) {
					FExp e = exps[i].unboundCopy();
					res = (res == null) ? e : new FMulExp(res, e);
				} else {
					known *= size[i];
				}
			}
			if (res == null)
				res = new FIntegerLitExp(known);
			else if (known > 1)
				res = new FMulExp(res, new FIntegerLitExp(known));
			return res;
		}

		/**
         * If this size contains any dimensions that are represented with expressions, then creates 
         * and attempts to evaluate a copy of this size. Otherwise, return this.
         */
        public Size evaluated() {
            boolean copy = false;
            for (FExp e : exps)
                if (e != null)
                    copy = true;
            if (copy) {
                MutableSize res = new MutableSize(size.length);
                System.arraycopy(size, 0, res.size, 0, size.length);
                System.arraycopy(exps, 0, res.exps, 0, exps.length);
                res.evaluate();
                return res;
            } else {
                return this;
            }
        }

		/**
		 * For each unknown length, copy the equivalent length from the size of <code>exp</code>. 
		 * 
		 * If <code>exp</code> has more dimensions, the last part is assumed to match this size.
		 */
		public void makeKnown(FExp exp) {
			fillUnknownFrom(exp);
		}
		
		/**
		 * Create a new flattened FSubscript for dimension <code>i</code>.
		 */
		protected FSubscript flattenFSubscript(int i, FQName prefix) {
			evaluate(i);
			return exps[i] == null ? super.flattenFSubscript(i, prefix) : 
				new FExpSubscript(exps[i].flatten(prefix));
		}
		
		/**
		 * Create a new FSubscript with a range spanning dimension <code>i</code>.
		 */
		protected FSubscript rangeFSubscript(int i) {
			evaluate(i);
			return !okExp(exps[i]) ? super.rangeFSubscript(i) : 
				new FExpSubscript(new FRangeExp(new FIntegerLitExp(1), exps[i].fullCopy()));
		}
		
		/**
		 * Returns a string representation of a single length.
		 */
		protected String toString(int i) {
			evaluate(i);
			// TODO: use okExp() instead of "== null"?
			return exps[i] == null ? super.toString(i) : exps[i].prettyPrint("");
		}
		
		/**
		 * Create a copy of this size.
		 */
		protected MutableSize clone() {
			MutableSize ms = new MutableSize(size.length);
			System.arraycopy(size, 0, ms.size, 0, size.length);
			System.arraycopy(exps, 0, ms.exps, 0, exps.length);
			ms.evaluated = evaluated;
			return ms;
		}
		
		/**
		 * Create a copy of this size as a MutableSize.
		 */
		public MutableSize mutableClone() {
			return clone();
		}
		
		/**
		 * Create a copy of this with <code>dim</code> dimensions, if necessary 
		 *        adding dimensions of length 1 to the right side, or removing dimensions 
		 *        from the left side.
		 */
		public Size promote(int dim) {
			evaluate();
			if (dim == size.length) 
				return this;
			if (dim == 0)
				return SCALAR;
			MutableSize ns = new MutableSize(dim);
			int old = dim < size.length ? dim : size.length;
			System.arraycopy(size, size.length - old, ns.size, 0, old);
			System.arraycopy(exps, exps.length - old, ns.exps, 0, old);
			Arrays.fill(ns.size, old, dim, 1);
			return ns;
		}
		
		/**
		 * Make sure that size is final, then get value of size[i].
		 */
		protected int read(int i) {
			evaluate(i);
			return size[i];
		}
		
		public boolean isUnknown() {
			evaluate();
			return super.isUnknown();
		}
		
	}
	
	public class Array {
		
		protected Indices indices;
		protected int length;
		
		/**
		 * Create an Array spanning a given Indices.
		 */
		public Array(Indices indices) {
			this.indices = indices;
			setChild(new List<FExp>(), 0);
			length = indices.numElements();
			if (length > 0)
				setFExp(null, length - 1);
		}
		
		/**
		 * Creates an iterator that iterates over all FExp nodes in this Array.
		 */
		public Iterator<FExp> iteratorFExp() {
			return getFExps().iterator();
		}
		
		/**
		 * Returns an Iterable<FExp> containing all expressions in Array.
		 */
		public Iterable<FExp> iterable() {
			return getFExps();
		}
		
		/**
		 * Creates a left-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * left side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the row 
		 * specified by i is returned.
		 */
		public Iterator<FExp> leftMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return createMatrixRowIterator(i.first(), size().get(1));
		}
		
		/**
		 * Creates a right-hand iterator for multiplication. 
		 * 
		 * Creates an iterator that iterates over all FExp nodes involved in 
		 * calculating the cell i in a multiplication with this Array at the 
		 * right side. 
		 * 
		 * If this Array is a vector, i is ignored and an iterator that iterates 
		 * over all elements in the Array is returned. 
		 * 
		 * If this Array is a matrix, an iterator that iterates over the column 
		 * specified by i is returned.
		 */
		public Iterator<FExp> rightMulIterator(Index i) {
			if (ndims() < 2)
				return new AIterator();
			else
				return createMatrixColIterator(i.last(), size().get(1), size().get(0));
		}
		
		/**
		 * Returns the element referenced by <code>i</code> in this Array.
		 */
		public FExp get(Index i) {
			return getFExp(i.internal(indices));
		}
		
		/**
		 * Returns element <code>i</code> in this Array.
		 * 
		 * For vectors, this is equivalent to <code>get(new Index(new int[]{i}))</code>.
		 */
		public FExp get(int i) {
			return getFExp(i - 1);
		}
		
		/**
		 * Sets the element referenced by <code>i</code> in this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp(exp.unboundCopy(), i.internal(indices));
		}
		
		/**
		 * Returns the Indices associated with this Array.
		 */
		public Indices indices() {
			return indices;
		}
		
		/**
		 * Set all expressions in Array to copies of <code>exp</code>.
		 * 
		 * If <code>exp</code> is an array, it is duplicated as many times as 
		 * nessecary to fill this Array with scalar expressions.
		 * 
		 * @return <code>this</code> 
		 */
		public Array fill(FExp exp) {
			if (exp.isArray()) {
				int n = exp.size().numElements();
				for (int i = 0; i < length; i++)
					setFExp(exp.getArray().getFExp(i % n).fullCopy(), i);
			} else {
				for (int i = 0; i < length; i++)
					setFExp(exp.fullCopy(), i);
			}
			return this;
		}
		
		/**
		 * Returns the number of dimensions spanned by this Array.
		 */
		public int ndims() {
			return indices.ndims();
		}
		
		/**
		 * Returns the size of this Array in each dimension.
		 */
		public Size size() {
			return indices.size();
		}
		
	    /**
	     * Recursive method for building an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *  
	     * @param it       the iterator returned by a call to {@link #iteratorFExp()}
	     * @param builder  helper object that processes each subexpression
	     * @param dim      the dimension to start at, use 0 to process entire array
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.Map,FExp)
	     */
	    protected FExp buildFArray(Iterator<FExp> it, ElementBuilder builder, int dim) {
	    	FArray arr = new FArray(new List<FExp>());
	    	int n = size().get(dim);
	    	if (dim < ndims() - 1) {
	    		for (int i = 0; i < n; i++)
	    			arr.addFExp(buildFArray(it, builder, dim + 1));
	    	} else {
	    		for (int i = 0; i < n; i++) 
	    			arr.addFExp(builder.build(it.next()).unboundCopy());
	    	}
	    	return arr;
	    }
		
	    /**
	     * Build an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *  
	     * @param builder  helper object that processes each subexpression
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.Map,FExp)
	     * @see #buildFArray(Iterator,ElementBuilder,int)
	     */
	    protected FExp buildFArray(ElementBuilder builder) {
			Size s = size();
			if (s.isEmpty()) {
				List<FExp> dims = new List<FExp>();
				for (int i = 0, n = s.ndims(); i < n ; i++)
					dims.add(s.createFExp(i));
				return new FFillExp(dims, type().zeroLiteral());
			} else {
		    	return buildFArray(iteratorFExp(), builder, 0);
			}
	    }
	    
	    /**
	     * Create an FExp describing the part of this array indicated by <code>i</code>.
	     * 
	     * If <code>i</code> has fewer dimensions than this, an FArray is created.
	     * Otherwise a copy of a specific cell is returned. 
	     */
	    public FExp subArrayFExp(Index i) {
	    	if (i.ndims() >= ndims())
	    		return get(i).fullCopy();
	    	
	    	Index j = i.promote(ndims());
	    	int start = j.internal(indices);
	    	Iterator<FExp> it = new AIterator(start, 1, length - start);
	    	return buildFArray(it, new IdentityBuilder(), ndims() - i.ndims());
	    }
		
		/**
		 * Create an iterator that iterates over a row. Assumes the Array is a matrix.
		 */
		private AIterator createMatrixRowIterator(int row, int width) {
			return new AIterator((row - 1) * width, 1, width);
		}
		
		/**
		 * Create an iterator that iterates over a column. Assumes the Array is a matrix.
		 */
		private AIterator createMatrixColIterator(int col, int width, int height) {
			return new AIterator(col - 1, width, height);
		}

		
	    /**
	     * Discribes the helper object for {@link #buildFArray(Iterator,ElementBuilder,int)}. 
	     */
	    protected interface ElementBuilder {
	    	public FExp build(FExp e);
	    }
	    
	    /**
	     * Builder for buildFArray(), that returns a straight copy of the FExp.
	     */
	    public class IdentityBuilder implements ElementBuilder {
	    	public FExp build(FExp exp) {
	    		return exp.fullCopy();
	    	}
	    }
		
	    
		/**
		 * Iterates over FExp nodes in this Array.
		 */
		private class AIterator implements Iterator<FExp> {
			
			private int i = 0;
			private int s;
			private int l;
			private int n;
			
			/**
			 * Create an iterator that iterates over all elements in the Array. 
			 */
			public AIterator() {
				s = 0;
				l = 1;
				n = length;
			}
			
			/**
			 * Create an iterator that iterates over a consecutive strech of the elements 
			 * in the Array. 
			 */
			public AIterator(int start, int step, int number) {
				s = start;
				l = step;
				n = number;
			}
			
			public boolean hasNext() {
				return i < n;
			}
			
			public FExp next() {
				if (i >= n)
					throw new NoSuchElementException();
				return getFExp(s + l * i++);
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
	}

	public class ScalarAsArray {

		/**
		 * Constructs a ScalarAsArray containing <code>exp</code>.
		 */
		public ScalarAsArray(FExp exp) {
			this(exp, Indices.create(Size.SCALAR));
		}
		
		/**
		 * Constructs a ScalarAsArray containing <code>exp</code>, 
		 *        pretending to have <code>ind</code> indices.
		 * 
		 * This makes indices().iterator() meaningful.
		 */
		public ScalarAsArray(FExp exp, Indices ind) {
			this(new List().add(exp.fullCopy()));
			indices = ind;
			length = 1;
		}
		
	    /**
	     * Recursive method for building an FArray describing this Array.
	     *        For use by methods creating specific types of FArrays.
	     *        
	     * This implementation only applies builder to the single expression of this 
	     * ScalarAsArray.
	     * 
	     * @see #buildLiteral(boolean)
	     * @see #buildScalarized(java.util.Map,FExp)
	     */
	    protected FExp buildFArray(Iterator<FExp> it, ElementBuilder builder, int dim) {
	    	return builder.build(it.next()).unboundCopy();
	    }
	    
		/**
		 * Returns the single element wrapped by this Array. 
		 */
		public FExp get(Index i) {
			return getFExp(0);
		}
		
		/**
		 * Sets the single element wrapped by this Array to <code>exp</code>.
		 */
		public void set(Index i, FExp exp) {
			setFExp(exp.unboundCopy(), 0);
		}
		
	}

	
	/**
	 * Represents the index/indices of a single cell in an (possibly 
	 *        multi-dimensional) array.
	 *        
	 * Index objects are reused to a high degree. Always use clone() when retaining 
	 * an Index object.
	 */
	public class Index implements Cloneable {
		
		public static final Index NULL = new Index(0);
		
		protected int[] index;
		
		/**
		 * Construct an Index representing the indices given in <code>ind</code>.
		 */
		public Index(int[] ind) {
			index = ind;
		}
		
		/**
		 * Returns the indices that specify this cell.
		 */
		public int[] index() {
			return index;
		}
		
		/**
		 * Returns the number of dimensions of this Index.
		 */
		public int ndims() {
			return index.length;
		}
		
		/**
		 * Returns the index for the first dimension.
		 */
		public int first() {
			return index.length > 0 ? index[0] : -1;
		}
		
		/**
		 * Returns the index for the last dimension.
		 */
		public int last() {
			return index.length > 0 ? index[index.length - 1] : -1;
		}
		
		/**
		 * Returns the index for the <code>i</code>th dimension (zero-based).
		 */
		public int get(int i) {
			return index[i];
		}
		
		/**
		 * Sets the index for the <code>i</code>th dimension (zero-based).
		 */
		public void set(int i, int index) {
			this.index[i] = index;
		}
		
		/**
		 * Compare two Index for equality.
		 */
		public boolean equals(Object i) {
			return (i instanceof Index) && Arrays.equals(index, ((Index) i).index);
		}
		
		/**
		 * Calculate hash code.
		 * 
		 * Creates perfect hash when ndims() <= 3 and all indices are <= 1023.
		 */
		public int hashCode() {
			int shift = index.length <= 3 ? 10 : 5;
			int res = 0;
			for (int i = 0; i < index.length; i++)
				res = (res << shift) ^ index[i];
			return res;
		}
		
		/**
		 * Returns an Index that describes the last <code>ndims() - level</code> dimensions 
		 * of this Index.
		 * 
		 * @param level  the first index to copy. Must be between 0 and ndims(), inclusive.
		 */
		public Index subIndex(int level) {
			return partIndex(level, index.length);
		}
        
        /**
         * Returns an Index that describes dimensions from <code>i</code>, inclusively, 
         * to <code>j</code>, excludingly, of this Index.
         * 
         * @param i  the first index to copy. Must be between 0 and ndims(), inclusively.
         * @param j  the index after the last to copy. Must be between <code>i</code> and ndims(), inclusively.
         */
        public Index partIndex(int i, int j) {
            if (i == 0 && j == index.length)
                return this;
            if (i == j)
                return NULL;
            Index copy = new Index(j - i);
            System.arraycopy(index, i, copy.index, 0, copy.index.length);
            return copy;
        }
		
		/**
		 * Creates a new Index that is a copy of this Index, but promoted to <code>ndims</code> 
		 * dimensions by adding ones to the end.
		 * 
		 * The new Index will not be bound to any Indices object.
		 */
		public Index promote(int ndims) {
			return adjusted(0, 0, ndims);
		}
		
		/**
		 * Creates a new Index that is a copy of this Index, but with <code>adj</code>
		 *        added to dimension <code>dim</code> and promoted to <code>ndims</code> 
		 *        dimensions by adding ones to the end.
		 * 
		 * The new Index will not be bound to any Indices object.
		 */
		public Index adjusted(int dim, int adj, int ndims) {
			Index copy = new Index(new int[ndims]);
			System.arraycopy(index, 0, copy.index, 0, index.length);
			Arrays.fill(copy.index, index.length, ndims, 1);
			copy.index[dim] += adj;
			return copy;
		}
		
		/**
		 * Create a new FArraySubscripts object describing this index.
		 */
		public FArraySubscripts createFArraySubscripts() {
			return FArraySubscripts.createLiteralSubscripts(index);
		}
		
		/**
		 * Copies this Index. Always use clone() when saving an Index.
		 */
		public Index clone() {
			try {
				Index i = (Index) super.clone();
				i.index = index.clone();
				return i;
			} catch (CloneNotSupportedException e) {
				return null;
			}
		}
		
		/**
		 * Returns an Index that is the result of appending <code>i</code> to this Index.
		 * 
		 * @param i  the Index to append.
		 */
		public Index expand(Index i) {
			if (index.length == 0)
				return i;
			if (i.index.length == 0)
				return this;
			Index expanded = new Index(index.length + i.index.length);
			System.arraycopy(index, 0, expanded.index, 0, index.length);
			System.arraycopy(i.index, 0, expanded.index, index.length, i.index.length);
			return expanded;
		}
		
		/**
		 * Return a string representation on the form "[i1,i2,i3]".
		 */
		public String toString() {
			return buildString(new StringBuilder("[")).append(']').toString();
		}
		
		/**
		 * Return a string representation on the form "i1,i2,i3".
		 */
		public String toUnclosedString() {
			return buildString(new StringBuilder()).toString();
		}
		
		/**
		 * Internal implementation of toString methods.
		 * 
		 * Note that this must give the same result as a prettyPrint() on an equivalent 
		 * FArraySubscripts, or inlining breaks.
		 */
		private StringBuilder buildString(StringBuilder buf) {
			boolean sep = false;
			for (int i : index) {
				if (sep)
					buf.append(',');
				buf.append(i);
				sep = true;
			}
			return buf;
		}
		
		
		/**
		 * Return the internal index in an Array of the cell this Index refers to.
		 *        Only for use from Array.
		 * 
		 * @param ind  the indices to resolve the internal index with
		 */
		public int internal(Indices ind) {
			return ind.internal(this);
		}
		
		/**
		 * Construct an empty Index.
		 */
		protected Index() {
		}
		
		/**
		 * Construct an Index of ndims dimensions, 
		 *        pointing at the spot before the first cell.
		 */
		protected Index(int ndims) {
			index = new int[ndims];
			for (int i = ndims - 2; i >= 0; i--)
				index[i] = 1;
			if (ndims > 0)
				index[ndims - 1] = 0;
		}
		
	}
	
	/**
	 * Indices represents the set of array indices in each dimension.
	 * 
	 * Only supports indices of the form (1..n1, 1..n2, ... , 1..nk). 
	 * See {@link NonConsecutiveIndices}. 
	 * 
	 * New Indices objects should be created with the create() methods. 
	 * The subclass used is selected automatically. 
	 * 
	 * The Indices class is typically used to iterate over all possible indices
	 * of an array access of declaration.
	 */
	public class Indices implements Iterable<Index> {
		protected int ndims;
		protected Size size;
		
		/**
		 *  Used to represent the Indices of scalar expressions.
		 */
		public static final Indices SCALAR = new Indices(Size.SCALAR);
		
		/**
		 * A perfect hash for all Indices that have consecutive indicies, 
		 *        ndims <= 3 and size[i] <= 1023 for 0 <= i < ndims. -1 for other 
		 *        Indices.
		 */
		protected int hash;
		
		/**
		 * Create an Indices object based on array sizes. 
		 */
		public static Indices create(Size size) {
			if (size == Size.SCALAR)
				return SCALAR;
			else
				return new Indices(size);
		}
		
		/**
		 * Create an Indices object based on FArraySubcripts.
		 */
		public static Indices createFromFas(FArraySubscripts fas) {
			return NonConsecutiveIndices.createFromFas(fas);
		}
		
		/**
		 * Create an Indices object based on a list of FArraySubcripts.
		 */
		public static Indices createFromFas(java.util.List<FArraySubscripts> fasl) {
			return NonConsecutiveIndices.createFromFas(fasl);
		}
		
		/**
		 * Create an Indices object based on a list of int arrays.
		 */
		public static Indices create(ArrayList<int[]> ind) {
			return NonConsecutiveIndices.create(ind, true);
		}
		
		/**
		 * Create an Indices object based on a list of CommonForIndexes.
		 */
		public static Indices create(Iterable<? extends CommonForIndex> forIndices) {
			ArrayList<int[]> ind = new ArrayList<int[]>();
			for (CommonForIndex fi : forIndices) 
				ind.add(fi.myIndices());
			return NonConsecutiveIndices.create(ind, false);
		}
		
		/**
		 * Check that i is valid for this Indices object.
		 */
		public boolean isValid(Index i) {
			if (i.ndims() != ndims)
				return false;
			int[] index = i.index();
			for (int j = 0; j < ndims; j++)
				if (index[j] < 1 || index[j] > size.get(j))
					return false;
			return true;
		}
		
		/**
		 * Returns an Iterator, that iterates over all indices spanned by this Indices object.
		 */
		public Iterator<Index> iterator() {
			return new IIterator();
		}
		
		/**
		 * Returns the number of elements spanned by this Indices object.
		 */
		public int numElements() {
			return size.numElements();
		}
		
		/**
		 * Returns the number of dimensions spanned by this Indices object.
		 */
		public int ndims() {
			return ndims;
		}
		
		/**
		 * Returns the size of this Indices object in each dimension.
		 */
		public Size size() {
			return size;
		}
		
		/**
		 * Translates an Index to the corresponding Index in the underlying 
		 *        expression.
		 * 
		 * Default implementation always returns <code>i</code>.
		 */
		public Index translate(Index i) {
			return i;
		}
		
		/**
		 * Add values to an index map for a given index from this set and a given set of for indices.
		 * 
		 * Also sets the evaluation values of the index variables.
		 */
		public void fillIndexMap(Map<String,FExp> indexMap, Index i, Iterable<? extends CommonForIndex> forIndices) {
			int j = 0;
			int[] ii = translate(i).index();
			for (CommonForIndex fi : forIndices) {
				indexMap.put(fi.name(), new FIntegerLitExp(ii[j]));
				fi.setEvaluationValue(new CValueInteger(ii[j]));
				j++;
			}
		}
				
		
		/**
		 * Internal constructor to create an Indices object based on array sizes. 
		 */
		protected Indices(Size size) {
			ndims = size.ndims();
			this.size = size;
			hash = -1;
			if (ndims < 4) {
				int h = 0;
				for (int i = 0; i < ndims; i++) {
					int s = size.get(i);
					if (s > 1023) 
						return;
					h = (h << 10) | s;
				}
				hash = h;
			}
		}
				
		/**
		 * Calculate the internal index in an Array that spans this Indices.
		 */
		protected int internal(Index i) {
			if (i.ndims() > ndims)
				throw new UnsupportedOperationException("Too many dimensions in Index.");
			int[] index = i.index();
			int res = 0;
			for (int j = 0; j < ndims; j++)
				res = res * size.get(j) + (j < index.length ? index[j] - 1 : 0);
			return res;
		}
		
		/**
		 * Iterates over all indices spanned by this Indices.
		 */
		protected class IIterator implements Iterator<Index> {
			
			protected IIndex index;
			protected int max;
			
			public IIterator() {
				index = new IIndex();
				max = numElements() - 1;
			}
			
			public boolean hasNext() {
				return index.internal < max;
			}
			
			public Index next() {
				if (index.internal >= max)
					throw new NoSuchElementException();
				index.internal++;
				if (ndims == 0)
					return index;
				int[] ind = index.index();
				int i;
				for (i = ndims - 1; i > 0 && ind[i] >= size.get(i); i--)
					ind[i] = 1;
				ind[i]++;
				return index;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
		}
		
		/**
		 * Internal implementation of Index.
		 */
		protected class IIndex extends Index {
			
			public int internal;
			
			/**
			 * Construct an Index over the number of dimensions of the enclosing Indices, 
			 *        pointing at the spot before the first cell.
			 */
			public IIndex() {
				super(ndims);
				internal = -1;
			}
			
			/**
			 * Return the internal index in an Array of the cell this Index refers to.
			 *        Only for use from Array.
			 * 
			 * @param ind  the indices to resolve the internal index with
			 */
			public int internal(Indices ind) {
				if (Indices.this == ind || (hash != -1 && hash == ind.hash)) 
					return internal;
				else
					return ind.internal(this);
			}
			
		}
		
	}

	/**
	 * NonConsecutiveIndices describes a set of array indices that isn't 
	 *        limited to 1..n.
	 * 
	 * For example, consider the declaration Real x[4,4,4] and the access
	 * x[:,1,1:2:4]. The array indices for the declaration is then
	 * {1,2,3,4}, {1,2,3,4}, and {1,2,3,4} respectively for the three dimensions.
	 * For the access, we have {1,2,3,4}, {1} and {1,3} respectively. The access 
	 * will have size [4,2], and this class will handle the necessary translations 
	 * between indices.
	 */
	public class NonConsecutiveIndices extends Indices {
		// The indices are stored as a list of integer arrays.
		protected ArrayList<int[]> indices; 
		protected Index trans;
		protected boolean[] trim;
		
		/**
		 * Create a NonConsecutiveIndices object based on FArraySubcripts.
		 *        Use Indices.create(FArraySubscripts fas).
		 */
		public static NonConsecutiveIndices createFromFas(FArraySubscripts fas) {
			int n = fas.getNumFSubscript();
			ArrayList<int[]> ind = new ArrayList<int[]>(n);
			boolean[] trim = new boolean[n];
			
			int i = 0;
			for (FSubscript fs : fas.getFSubscripts()) { 
				ind.add(fs.myIndices());
				trim[i++] = fs.ndims() == 0;
			}
			return new NonConsecutiveIndices(ind, trim, 0);
		}
		
		/**
		 * Create a NonConsecutiveIndices object based on a list of FArraySubcripts.
		 *        Use Indices.create(ArrayList<FArraySubscripts> fasl).
		 */
		public static NonConsecutiveIndices createFromFas(java.util.List<FArraySubscripts> fasl) {
			int n = 0;
			for (FArraySubscripts fas : fasl)
				n += fas.getNumFSubscript();
			ArrayList<int[]> ind = new ArrayList<int[]>(n);
			boolean[] trim = new boolean[n];
			
			int i = 0;
			for (FArraySubscripts fas : fasl) {
				for (FSubscript fs : fas.getFSubscripts()) {
					ind.add(fs.myIndices());
					trim[i++] = fs.ndims() == 0;
				} 
			}
			return new NonConsecutiveIndices(ind, trim, 0);
		}

        /**
         * Create a NonConsecutiveIndices object based on a list of int arrays
         *        Use Indices.create(ArrayList<int[]> ind).
         * 
         * @param ind   one array for each dimension, containing the indices to span for that dimension.
         * @param trim  remove dimensions that only span one index.
         */
        public static NonConsecutiveIndices create(ArrayList<int[]> ind, boolean trim) {
            boolean[] trims = new boolean[ind.size()];
            for (int i = 0; i < trims.length; i++)
                trims[i] = trim && ind.get(i).length == 1;
            return new NonConsecutiveIndices(ind, trims, 0);
        }

        /**
         * Create a NonConsecutiveIndices object based on a Size, an array of dimensions to trim, 
         * and a number of extra dimensions to add to the end.
         */
        public static NonConsecutiveIndices create(Size s, int[] dim, int extra) {
            int n = s.ndims();
            ArrayList<int[]> ind = new ArrayList<int[]>(n);
            boolean[] trims = new boolean[n];
            for (int i = 0; i < n; i++) {
                ind.add(new int[] { 1 });
                trims[i] = true;
            }
            for (int d : dim) {
                if (d < n) {
                    int[] ii = new int[s.get(d)];
                    for (int i = 0; i < ii.length; i++)
                        ii[i] = i + 1;
                    ind.set(d, ii);
                    trims[d] = false;
                }
            }
            return new NonConsecutiveIndices(ind, trims, extra);
        }

		/**
		 * Translates an Index to the corresponding Index in the underlying 
		 * expression.
		 */
		public Index translate(Index i) {
			int[] ii = i.index();
			int[] ti = trans.index();
			for (int ji = 0, jt = 0; ji < ndims && jt < ti.length; ji++, jt++) {
				while (trim[jt]) 
					jt++;
				ti[jt] = indices.get(jt)[ii[ji] - 1];
			}
			return trans;
		}

		
		/**
		 * Internal constructor to create a NonConsecutiveIndices object based on a 
		 * list of int arrays containing the used indexes on the underlying array.
		 * 
		 * @param trim   the dimensions to remove
		 * @param extra  number of extra dimensions of length 1 to add
		 */
		protected NonConsecutiveIndices(ArrayList<int[]> ind, boolean[] trim, int extra) {
			super(getSize(ind, trim, extra));
			this.trim = trim;
			indices = ind;
			trans = new Index(ind.size());
			for (int i = 0; i < ind.size(); i++)
				if (indices.get(i).length > 0)
					trans.index()[i] = indices.get(i)[0];
		}
		
		/**
		 * Calculate size for this indices from a list of int arrays containing the 
		 * used indexes on the underlying array.
		 */
		protected static Size getSize(ArrayList<int[]> ind, boolean[] trim, int extra) {
			int n = 0;
			for (boolean tr : trim)
				if (!tr)
					n++;
			MutableSize size = new MutableSize(n + extra);
			for (int i = 0; i < trim.length; i++)
				if (!trim[i])
					size.append(ind.get(i).length);
			for (int i = 0; i < extra; i++)
				size.append(1);
			return size;
		}
		
	}
	
}
