/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;


aspect ExternalConstantEvaluation {
    
    /**
     * Check external arguments
     */
    syn boolean FExternalStmt.canEvaluate() {
        if (myOptions().getIntegerOption("external_constant_evaluation") == 0)
            return false;
        for (CommonVariableDecl cvd : varsToSerialize()) {
            if (cvd.type().isRecord()) {
                return false;
            }
        }
        return true;
    }
    
    syn CommonVariableDecl FExternalStmt.cachedExternalObject() {
        CommonVariableDecl eo = null;
        for (CommonVariableDecl cvd : varsToSerialize()) {
            if (cvd.type().isExternalObject() && cvd.type().isScalar()) {
                if (eo != null) {
                    return null;
                } else {
                    eo = cvd;
                }
            }
        }
        return eo;
    }
    
    
    public void CValue.markExternalObject(String name) {
        
    }
    
    private String CValueExternalObject.marked = null;
    public void CValueExternalObject.markExternalObject(String name) {
        if (marked == null) {
            marked = name;
        }
    }
    
    public String CValue.getMarkedExternalObject() {
        throw new ConstantEvaluationException();
    }
    
    public String CValueExternalObject.getMarkedExternalObject() {
        if (marked == null) {
            return super.getMarkedExternalObject();
        }
        return marked;
    }
    
    
    /**
     * External functions does not have a FAlgorithm in the instance tree
     * so we have to generate one.
     */
    syn nta FAlgorithm InstExternal.getFAlgorithm() {
        FAlgorithm fab = new FAlgorithm(new List());
        fab.addFStatement(createStmt(surroundingInstClass(), new FQNameFull(""), false));
        return fab;
    }
    
    public int FExternalStmt.evaluateConstructor(Map<CommonVariableDecl, CValue> values) {
        ArrayList<FExp> args = myConstructorArgs();
        CValue[] vals = new CValue[args.size()];
        for (int i = 0; i < args.size(); i++)
            vals[i] = args.get(i).ceval();
        values.put(myConstructorOutput(), new CValueExternalObject(vals));
        return EVAL_CONT;
    }
    
    inh boolean FExternalStmt.isConstructorStmt();
    eq Root.getChild().isConstructorStmt() = false;
    eq FFunctionDecl.getChild().isConstructorStmt() = isConstructor();
    eq InstClassDecl.getChild().isConstructorStmt() = isConstructor();
    
    inh boolean FExternalStmt.isDestructorStmt();
    eq Root.getChild().isDestructorStmt() = false;
    eq FFunctionDecl.getChild().isDestructorStmt() = isDestructor();
    eq InstClassDecl.getChild().isDestructorStmt() = isDestructor();
    
    public ExternalFunctionCache.ExternalFunction FExternalStmt.myExternalFunction() {
        ExternalFunctionCache efc = root().getUtilInterface().getExternalFunctionCache();
        if (efc == null) {
            return ExternalFunctionCache.FAILED_EXTERNAL_FUNCTION;
        }
        return efc.getExternalFunction(this);
    }
    
    /**
     * Evaluate this external statement.
     */
    public int FExternalStmt.evaluateExternal(Map<CommonVariableDecl, CValue> values) {
        
        if (isConstructorStmt()) {
            return evaluateConstructor(values);
        }
        
        int res = 0;
        int timeout = myOptions().getIntegerOption("external_constant_evaluation");
        ExternalFunctionCache.ExternalFunction ef = myExternalFunction();
        try {
            res = ef.evaluate(this, values, timeout);
        } catch (IOException e) {
//            ModelicaCompiler.log.debug(e);
            res = -2;
        }
        
        if (res != 0) {
            ModelicaCompiler.log.debug("Could not evaluate external function " + getName() + ", error code: " + res);
            throw new ConstantEvaluationException(null, "Failed to evaluate external function call, error during evaluation");
        }
        
        return EVAL_CONT;
    }
    
    
    /**
     * A class for handling communication with an external process during
     * constant evaluation.
     */
    public class ProcessCommunicator {
        private BufferedReader in;
        private BufferedWriter out;
        private Process process;
        private Timer timer;
        private TimerTask task;
        String buffLine = null;
        
        public ProcessCommunicator(Process proc) {
            process = proc;
            in  = new BufferedReader(new InputStreamReader(process.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
            timer = new Timer();
        }
        
        private String getLine() throws IOException {
            String line = buffLine;
            if (line == null)
                line = in.readLine();
            if (line == null)
                throw new IOException();
            buffLine = null;
            return line;
        }
        
        private void buffLine(String line) {
            buffLine = line;
        }
        
        /**
         * Print <code>val</code>, serialized, to the process 
         */
        public void put(CValue val, FType type, boolean allowUninitialized) throws IOException {
//            ModelicaCompiler.log.debug("ProcessCommunicator WRITE: " + val.toString() + " of type: "+type.toString());
            val.serialize(out, type, allowUninitialized);
            out.flush();
        }
        
        /**
         * Read <code>type</code>, serialized, from the process 
         */
        public CValue get(FType type) throws IOException {
            CValue val = type.deserialize(this);
//            ModelicaCompiler.log.debug("ProcessCommunicator READ: " + val.toString());
            return val;
        }
        
        /**
         * Read a line. Check equals to <code>s</code>.
         */
        public void accept(String s) throws IOException {
            log();
            abort();
            String line = getLine();
            if (line == null || !line.equals(s)) {
                ModelicaCompiler.log.debug(String.format("ProcessCommunicator did not receive expected line\n\t'%s' != '%s'", s, (line == null ? "null" : line)));
                throw new IOException();
            }
        }
        
        public void check(String s) throws IOException {
            out.write(s);
            out.write("\n");
            out.flush();
        }
        
        private void log() throws IOException {
            String line = getLine();
            while (line.equals("LOG")) {
                double warning = deserializeReal();
                String name    = deserializeString();
                String format  = deserializeString();
                String value   = deserializeString();
                if (warning != 0)
                    ModelicaCompiler.log.warning("%s: " + format, name, value);
                else
                    ModelicaCompiler.log.info("%s: " + format, name, value);
                line = getLine();
            }
            buffLine(line);
        }
        
        private void abort() throws IOException, ConstantEvaluationException {
            String line = getLine();
            if (line.equals("ABORT")) {
                throw new AbortConstantEvaluationException("Evaluation aborted by request of external function");
            }
            buffLine(line);
        }
        
        class AbortConstantEvaluationException extends ConstantEvaluationException {
            public AbortConstantEvaluationException(String string) {
                super(null, string);
            }
        }
        
        /**
         * Wait for and retrieve exit value from process.
         */
        public int end() {
            int res;
            try {
                process.waitFor();
                res = process.exitValue();
            } catch (InterruptedException e) {
                res = -99;
            } catch (IllegalThreadStateException e) {
                res = -100;
            }
            return res;
        }
        
        /**
         * Tear down everything
         */
        public void destroy() {
            timer.cancel();
            timer.purge();
            timer = null;
            try {
                in.close();
            } catch (IOException e) {
            }
            try {
                out.close();
            } catch (IOException e) {
            }
            
            process.destroy();
            process = null;
        }
        
        public double deserializeReal() throws IOException {
            String s = in.readLine();
            if (s == null)
                throw new IOException();
            try {
                return Double.parseDouble(s);
            } catch (NumberFormatException e) {
                throw new IOException();
            }
        }
        
        public String deserializeString() throws IOException {
            String s = in.readLine();
            if (s == null)
                throw new IOException();
            try {
                int len = Integer.parseInt(s);
                char[] c = new char[len];
                in.read(c,0,len);
                s = in.readLine();
                return new String(c);
            } catch (NumberFormatException e) {
                throw new IOException();
            }
        }
        
        public void startTimer(int timeout) {
            if (timeout >= 0) {
                if (task != null) {
                    //XXX: Throw exception instead?
                    task.cancel();
                    timer.purge();
                }
                task = new TimerTask() {
                    @Override
                    public void run() {
                        process.destroy();
                        cancel();
                    }
                };
                timer.schedule(task, timeout);
            }
        }
        
        public void cancelTimer() {
            if (task != null) {
                task.cancel();
            }
            task = null;
            timer.purge();
        }
    }
    
    /**
     * Print this constant value to <code>buff</code>
     */
    public void CValue.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        throw new IOException();
    }
    public void CValueUnknown.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        if (allowUninitialized)
            type.uninitialized().serialize(buff, type, false);
        else
            super.serialize(buff, type, allowUninitialized);
    }
    public void CValueArray.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        for (int s : size().size) {
            buff.write("" + s + "\n");
        }
        for (Index i : indices()) {
            getCell(i).serialize(buff, type.scalarType(), allowUninitialized);
        }
    }
    public void CValueReal.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Double.toString(realValue()));
        buff.write("\n");
    }
    public void CValueInteger.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Integer.toString(intValue()));
        buff.write("\n");
    }
    public void CValueBoolean.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(booleanValue() ? "1\n" : "0\n");
    }
    public void CValueString.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        String s = stringValue();
        buff.write("" + s.length() + " ");
        buff.write(s);
        buff.write("\n");
    }
    public void CValueEnum.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Integer.toString(intValue()));
        buff.write("\n");
    }
    public void CValueExternalObject.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        for (CValue v : values)
            v.serialize(buff, type, allowUninitialized);
    }
    
    public CValue FType.uninitialized() { return zeroCValue(); }
    public CValue FEnumType.uninitialized() { return (new FIntegerType(size())).zeroCValue(); }
    
    
    /**
     * Read a constant value of <code>this</code> type from <code>buff</code>
     */
    public CValue FType.deserialize(ProcessCommunicator com) throws IOException {
        if (isArray()) {
            CValueArray a = new CValueArray(size().ceval());
            for (Index i : a.indices()) {
                a.setCell(i, deserializeScalar(com));
            }
            return a;
        } else {
            return deserializeScalar(com);
        }
    }
    public CValue FType.deserializeScalar(ProcessCommunicator com) throws IOException {
        throw new IOException();
    }
    public CValue FRealType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueReal(com.deserializeReal());
    }
    public CValue FIntegerType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueInteger((int) com.deserializeReal());
    }
    public CValue FBooleanType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueBoolean(com.deserializeReal() != 0);
    }
    public CValue FStringType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueString(com.deserializeString());
    }
    public CValue FEnumType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueEnum(this, (int) com.deserializeReal());
    }
}

aspect ExternalConstantEvaluationCaching {
    
    protected ExternalFunctionCache ModelicaCompiler.externalFunctionCache = new ExternalFunctionCache(this);
    
    public ExternalFunctionCache ModelicaCompiler.getExternalFunctionCache() {
        return externalFunctionCache;
    }
    
    public class ExternalFunctionCache {
        
        /**
         * Maps external functions names to compiled executables.
         */
        private Map<String, ExternalFunction> cachedExternals = new HashMap<String, ExternalFunction>();
        
        private LinkedHashSet<ExternalFunction> livingCachedExternals = new LinkedHashSet<ExternalFunction>();
        
        private ModelicaCompiler mc;
        
        public ExternalFunctionCache(ModelicaCompiler mc) {
            this.mc = mc;
        }
        
        /**
         * If there is no executable corresponding to <code>ext</code>, create one.
         */
        public ExternalFunction getExternalFunction(FExternalStmt ext) {
            ExternalFunction ef = cachedExternals.get(ext.getName());
            if (ef == null) {
                if (mc == null) {
                    return FAILED_EXTERNAL_FUNCTION;
                }
                String executable = mc.compileExternal(ext);
                if (executable == null) {
                    ef = FAILED_EXTERNAL_FUNCTION;
                } else {
                    if (ext.cachedExternalObject() != null) {
                        ef = new MappedExternalFunction(ext, executable);
                    } else {
                        ef = new CompiledExternalFunction(ext, executable);
                    }
                }
                cachedExternals.put(ext.getName(), ef);
            }
            return ef;
        }
        
        /**
         * Remove executables compiled by the constant evaluation framework.
         */
        public void removeExternalFunctions() {
            for (ExternalFunction ef : cachedExternals.values()) {
                ef.remove();
            }
            cachedExternals = new HashMap<String, ExternalFunction>();
        }
        
        /**
         * Kill cached processes
         */
        public void destroyProcesses() {
            for (ExternalFunction ef : new ArrayList<ExternalFunction>(livingCachedExternals)) {
                ef.destroyProcess();
            }
        }
        
        public void tearDown() {
            destroyProcesses();
            removeExternalFunctions();
        }
        
        public static abstract class ExternalFunction {
            public abstract int evaluate(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout)
                    throws IOException;
            public abstract void destroyProcess();
            public abstract void remove();
        }
        
        public static final ExternalFunction FAILED_EXTERNAL_FUNCTION = new FailedExternalFunction();
        
        private static class FailedExternalFunction extends ExternalFunction {
            
            @Override
            public int evaluate(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout) 
                    throws IOException {
                ModelicaCompiler.log.debug("Evaluating failed external function: " + ext.getName());
                throw new ConstantEvaluationException(null, 
                        "Failed to evaluate external function call, could not start process");
            }
            
            @Override
            public void destroyProcess() {
                // Do nothing.
            }
            
            @Override
            public void remove() {
                // Do nothing.
            }
        }
        
        private class CompiledExternalFunction extends ExternalFunction {
            protected String executable;
            protected ProcessBuilder processBuilder;
            
            public CompiledExternalFunction(FExternalStmt ext, String executable) {
                this.executable = executable;
                this.processBuilder = createProcessBuilder(ext);
            }
            
            protected ProcessCommunicator createProcessCommunicator(FExternalStmt ext) throws IOException {
                return new ProcessCommunicator(processBuilder.start());
            }
            
            @Override
            public int evaluate(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout) 
                    throws IOException {
                ModelicaCompiler.log.debug("Evaluating compiled external function: " + ext.getName());
                ProcessCommunicator com = null;
                try {
                    com = createProcessCommunicator(ext);
                    setup(ext, values, timeout, com);
                    evaluate(ext, values, timeout, com);
                    return teardown(ext, values, timeout, com);
                } finally {
                    if (com != null) {
                        com.destroy();
                    }
                }
            }
            
            public void setup(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout,
                    ProcessCommunicator com) throws IOException {
                com.startTimer(timeout);
                com.accept("START");
                for (CommonVariableDecl eo : ext.externalObjectsToSerialize()) {
                    com.put(values.get(eo), eo.type(), eo.canBeUnknown());
                }
                com.accept("READY");
                com.cancelTimer();
            }
            
            public void evaluate(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout,
                    ProcessCommunicator com) throws IOException {
                com.startTimer(timeout);
                com.check("EVAL");
                for (CommonVariableDecl arg : ext.functionArgsToSerialize()) {
                    com.put(values.get(arg), arg.type(), arg.canBeUnknown());
                }
                com.accept("CALC");
                com.accept("DONE");
                for (CommonVariableDecl cvd : ext.varsToDeserialize())
                    values.put(cvd, com.get(cvd.type()));
                com.accept("READY");
                com.cancelTimer();
            }
            
            public int teardown(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout,
                    ProcessCommunicator com) throws IOException {
                com.startTimer(timeout);
                com.check("EXIT");
                com.accept("END");
                int result = com.end();
                com.cancelTimer();
                return result;
            }
            
            @Override
            public void destroyProcess() {
                
            }
            
            @Override
            public void remove() {
                destroyProcess();
                new File(executable).delete();
            }
            
            private ProcessBuilder createProcessBuilder(FExternalStmt ext) {
                ProcessBuilder pb = new ProcessBuilder(executable);
                pb.redirectErrorStream(true);
                if (ext.libraryDirectory() != null) {
                    // Update environment in case of shared library
                    String platform = ModelicaCompiler.reduceBits(ModelicaCompiler.getPlatform(), 
                            mc.getCCompiler().getTargetPlatforms());
                    File f = new File(ext.libraryDirectory(), platform);
                    String libLoc = f.isDirectory() ? f.getPath() : ext.libraryDirectory();
                    appendPath(pb, libLoc, platform);
                }
                return pb;
            }
            
            /**
             * Append a library location <code>libLoc</code> to the path variable in environment of <code>pb</code>.
             */
            private void appendPath(ProcessBuilder pb, String libLoc, String platform) {
                String sep = platform.startsWith("win") ? ";" : ":";
                String var = platform.startsWith("win") ? "PATH" : "LD_LIBRARY_PATH";
                String res = pb.environment().get(var);
                if (res == null)
                    res = libLoc;
                else
                    res = res + sep + libLoc;
                pb.environment().put(var, res);
            }
        }
        
        private class MappedExternalFunction extends CompiledExternalFunction {
            
            Map<String, ExternalFunction> lives = new HashMap<String, ExternalFunction>();
            
            public MappedExternalFunction(FExternalStmt ext, String executable) {
                super(ext, executable);
            }
            
            private ExternalFunction getActual(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout) {
                CommonVariableDecl cvd = ext.cachedExternalObject();
                String name = cvd.ceval().getMarkedExternalObject();
                ExternalFunction ef = lives.get(name);
                if (ef == null) {
                    LiveExternalFunction lef = new LiveExternalFunction(name);
                    try {
                        lef.ready(ext, values, timeout);
                        ef = lef;
                    } catch (IOException e) {
                        ef = FAILED_EXTERNAL_FUNCTION;
                    } catch (ConstantEvaluationException e) {
                        ef = FAILED_EXTERNAL_FUNCTION;
                    }
                    lives.put(name, ef);
                }
                return ef;
            }
            
            @Override
            public int evaluate(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout) 
                    throws IOException {
                return getActual(ext, values, timeout).evaluate(ext, values, timeout);
            }
            
            @Override
            public void destroyProcess() {
                for (ExternalFunction ef : lives.values()) {
                    ef.destroyProcess();
                }
                lives.clear();
            }
            
            private class LiveExternalFunction extends ExternalFunction {
                
                private String name;
                
                protected ProcessCommunicator com;
                
                public LiveExternalFunction(String name) {
                    this.name = name;
                }
                
                @Override
                public int evaluate(FExternalStmt ext, Map<CommonVariableDecl, CValue> values, int timeout) 
                        throws IOException {
                    ModelicaCompiler.log.debug("Evaluating live external function: " + ext.getName());
                    try {
                        ready(ext, values, timeout);
                        MappedExternalFunction.this.evaluate(ext, values, timeout, com);
                    } catch (ProcessCommunicator.AbortConstantEvaluationException e) {
                        
                    } catch (ConstantEvaluationException e) {
                        destroyProcess();
                        throw e;
                    } catch (IOException e) {
                        destroyProcess();
                        throw e;
                    }
                    return 0;
                }
                
                protected void ready(FExternalStmt ext, Map<CommonVariableDecl, 
                        CValue> values, int timeout) throws IOException {
                    if (com == null) {
                        com = createProcessCommunicator(ext);
                        MappedExternalFunction.this.setup(ext, values, timeout, com);
                        ModelicaCompiler.log.debug("Setup live external function: " + ext.getName());
                    }
                    livingCachedExternals.remove(this);
                    livingCachedExternals.add(this);
                    if (livingCachedExternals.size() > 10) {
                        livingCachedExternals.iterator().next().destroyProcess();
                    }
                }
                
                @Override
                public void destroyProcess() {
                    if (com != null) {
                        livingCachedExternals.remove(this);
                        com.destroy();
                        com = null;
                    }
                }
                
                @Override
                public void remove() {
                    throw new UnsupportedOperationException();
                }
            }
        }
    }
    
    public String ModelicaCompiler.compileExternal(FExternalStmt ext) {
        String executable = null;
        if (outDir == null)
            setRandomOutDir();
        String source = ext.getName().replace(".", "_");
        TargetObject target = createTargetObject("ceval", "0.1");
        Set<String> libs = new HashSet<String>();
        Set<String> libDirs = new HashSet<String>();
        Set<String> incDirs = new HashSet<String>();
        if (ext.library() != null)
            for (String lib : ext.library())
                libs.add(lib);
        if (ext.libraryDirectory() != null)
            libDirs.add(ext.libraryDirectory());
        if (ext.includeDirectory() != null)
            incDirs.add(ext.includeDirectory());
        try {
            target.getTemplates().generateCFiles(ModelicaCompiler.this, null, createCGenerator(ext), sourceDir, source);
            executable = getCCompiler().compileCCodeLocal(source, target, outDir, libs, libDirs, incDirs, 1);
            new File(sourceDir, source + ".c").delete();
            log.debug(String.format("Compiled external function \"%s\" to executable \"%s\" for constant evaluation.", ext.getName(), executable));
        } catch (FileNotFoundException e) {
            log.debug(String.format("Could not generate code for constant evaluation of external function \"%s\".", ext.getName()));
        } catch (CcodeCompilationException e) {
            log.debug(String.format("Could not compile external function \"%s\" for constant evaluation.", ext.getName()));
            e.printStackTrace(new PrintStream(log.debugStream()));
        }
        return executable;
    }
}


