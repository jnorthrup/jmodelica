/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.InputStreamReader;
import java.io.IOException;
import java.io.OutputStreamWriter;
import java.util.Map;
import java.util.Timer;
import java.util.TimerTask;


aspect ExternalConstantEvaluation {
    
    /**
     * Retrieve ModelicaCompiler from root. Might be null.
     */
    syn ModelicaCompiler FExternalStmt.myCompiler() = root().getUtilInterface().getModelicaCompiler();
    
    /**
     * Check external arguments
     */
    syn boolean FExternalStmt.canEvaluate() {
        if (myOptions().getIntegerOption("external_constant_evaluation") == 0)
            return false;
        for (CommonVariableDecl cvd : varsToSerialize()) {
            if (cvd.type().isRecord()) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Create a process of this external function. Returns null if there was no
     * compiler or the process could not be started.
     */
    public Process FExternalStmt.createExternCEvalProc(FExternalStmt ext) {
        ModelicaCompiler mc = myCompiler();
        if (mc != null)
            return mc.createExternCEvalProc(this);
        return null;
    }
    
    /**
     * External functions does not have a FAlgorithm in the instance tree
     * so we have to generate one.
     */
    syn nta FAlgorithm InstExternal.getFAlgorithm() {
        FAlgorithm fab = new FAlgorithm(new List());
        fab.addFStatement(createStmt(surroundingInstClass(), new FQNameFull(""), false));
        return fab;
    }
    
    public int FExternalStmt.evaluateConstructor(Map<CommonVariableDecl, CValue> values) {
        ArrayList<FExp> args = myConstructorArgs();
        CValue[] vals = new CValue[args.size()];
        for (int i = 0; i < args.size(); i++)
            vals[i] = args.get(i).ceval();
        values.put(myConstructorOutput(), new CValueExternalObject(vals));
        return EVAL_CONT;
    }
    
    inh boolean FExternalStmt.isConstructorStmt();
    eq Root.getChild().isConstructorStmt() = false;
    eq FFunctionDecl.getChild().isConstructorStmt() = isConstructor();
    eq InstClassDecl.getChild().isConstructorStmt() = isConstructor();
    
    inh boolean FExternalStmt.isDestructorStmt();
    eq Root.getChild().isDestructorStmt() = false;
    eq FFunctionDecl.getChild().isDestructorStmt() = isDestructor();
    eq InstClassDecl.getChild().isDestructorStmt() = isDestructor();
    
    /**
     * Evaluate this external statement.
     */
    public int FExternalStmt.evaluateExternal(Map<CommonVariableDecl, CValue> values) {
        
        if (isConstructorStmt()) {
            return evaluateConstructor(values);
        }
        
        Process proc = createExternCEvalProc(this);
        
        if (proc == null) {
            throw new ConstantEvaluationException(null, "Failed to evaluate external function call, could not start process");
        } 
        
        int res = 0;
        int timeout = myOptions().getIntegerOption("external_constant_evaluation");
        ProcessCommunicator com = new ProcessCommunicator(proc, timeout);
        try {
            com.accept("START");
            for (CommonVariableDecl cvd : varsToSerialize()) {
                com.put(values.get(cvd), cvd.type(), cvd.canBeUnknown());
            }
            com.accept("CALC");
            com.accept("DONE");
            for (CommonVariableDecl cvd : varsToDeserialize())
                values.put(cvd, com.get(cvd.type()));
            com.accept("END");
            res = com.end();
        } catch (IOException e) {
//            ModelicaCompiler.log.debug(e);
            res = -2;
        }
        com.destroy();
        
        if (res != 0) {
            ModelicaCompiler.log.debug("Could not evaluate external function " + getName() + ", error code: " + res);
            throw new ConstantEvaluationException(null, "Failed to evaluate external function call, error during evaluation");
        }
        
        return EVAL_CONT;
    }
    
    
    /**
     * A class for handling communication with an external process during
     * constant evaluation.
     */
    public class ProcessCommunicator {
        private BufferedReader in;
        private BufferedWriter out;
        private Process process;
        private Timer timer;
        String buffLine = null;
        
        public ProcessCommunicator(Process proc, int timeout) {
            process = proc;
            in  = new BufferedReader(new InputStreamReader(process.getInputStream()));
            out = new BufferedWriter(new OutputStreamWriter(process.getOutputStream()));
            timer = new Timer();
            if (timeout >= 0) {
                timer.schedule(new TimerTask() {
                    @Override
                    public void run() {
                        process.destroy();
                        cancel();
                    }
                }, timeout);
            }
        }
        
        private String getLine() throws IOException {
            String line = buffLine;
            if (line == null)
                line = in.readLine();
            if (line == null)
                throw new IOException();
            buffLine = null;
            return line;
        }
        
        private void buffLine(String line) {
            buffLine = line;
        }
        
        /**
         * Print <code>val</code>, serialized, to the process 
         */
        public void put(CValue val, FType type, boolean allowUninitialized) throws IOException {
//            ModelicaCompiler.log.debug("ProcessCommunicator WRITE: " + val.toString() + " of type: "+type.toString());
            val.serialize(out, type, allowUninitialized);
            out.flush();
        }
        
        /**
         * Read <code>type</code>, serialized, from the process 
         */
        public CValue get(FType type) throws IOException {
            CValue val = type.deserialize(this);
//            ModelicaCompiler.log.debug("ProcessCommunicator READ: " + val.toString());
            return val;
        }
        
        /**
         * Read a line. Check equals to <code>s</code>.
         */
        public void accept(String s) throws IOException {
            log();
            String line = getLine();
            if (line == null || !line.equals(s)) {
                ModelicaCompiler.log.debug(String.format("ProcessCommunicator did not receive expected line\n\t'%s' != '%s'", s, (line == null ? "null" : line)));
                throw new IOException();
            }
        }
        
        private void log() throws IOException {
            String line = getLine();
            while (line.equals("LOG")) {
                double warning = deserializeReal();
                String name    = deserializeString();
                String format  = deserializeString();
                String value   = deserializeString();
                if (warning != 0)
                    ModelicaCompiler.log.warning("%s: " + format, name, value);
                else
                    ModelicaCompiler.log.info("%s: " + format, name, value);
                line = getLine();
            }
            buffLine(line);
        }
        
        /**
         * Wait for and retrieve exit value from process.
         */
        public int end() {
            int res;
            try {
                process.waitFor();
                res = process.exitValue();
            } catch (InterruptedException e) {
                res = -99;
            } catch (IllegalThreadStateException e) {
                res = -100;
            }
            return res;
        }
        
        /**
         * Tear down everything
         */
        public void destroy() {
            try {
                in.close();
            } catch (IOException e) {
            }
            try {
                out.close();
            } catch (IOException e) {
            }
            
            process.destroy();
            process = null;
            timer.cancel();
            timer.purge();
            timer = null;
        }
        
        public double deserializeReal() throws IOException {
            String s = in.readLine();
            if (s == null)
                throw new IOException();
            try {
                return Double.parseDouble(s);
            } catch (NumberFormatException e) {
                throw new IOException();
            }
        }
        
        public String deserializeString() throws IOException {
            String s = in.readLine();
            if (s == null)
                throw new IOException();
            try {
                int len = Integer.parseInt(s);
                char[] c = new char[len];
                in.read(c,0,len);
                s = in.readLine();
                return new String(c);
            } catch (NumberFormatException e) {
                throw new IOException();
            }
        }
    }
    
    /**
     * Print this constant value to <code>buff</code>
     */
    public void CValue.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        throw new IOException();
    }
    public void CValueUnknown.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        if (allowUninitialized)
            type.uninitialized().serialize(buff, type, false);
        else
            super.serialize(buff, type, allowUninitialized);
    }
    public void CValueArray.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        for (int s : size().size) {
            buff.write("" + s + "\n");
        }
        for (Index i : indices()) {
            getCell(i).serialize(buff, type.scalarType(), allowUninitialized);
        }
    }
    public void CValueReal.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Double.toString(realValue()));
        buff.write("\n");
    }
    public void CValueInteger.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Integer.toString(intValue()));
        buff.write("\n");
    }
    public void CValueBoolean.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(booleanValue() ? "1\n" : "0\n");
    }
    public void CValueString.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        String s = stringValue();
        buff.write("" + s.length() + " ");
        buff.write(s);
        buff.write("\n");
    }
    public void CValueEnum.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        buff.write(Integer.toString(intValue()));
        buff.write("\n");
    }
    public void CValueExternalObject.serialize(BufferedWriter buff, FType type, boolean allowUninitialized) throws IOException {
        for (CValue v : values)
            v.serialize(buff, type, allowUninitialized);
    }
    
    public CValue FType.uninitialized() { return zeroCValue(); }
    public CValue FEnumType.uninitialized() { return (new FIntegerType(size())).zeroCValue(); }
    
    
    /**
     * Read a constant value of <code>this</code> type from <code>buff</code>
     */
    public CValue FType.deserialize(ProcessCommunicator com) throws IOException {
        if (isArray()) {
            CValueArray a = new CValueArray(size().ceval());
            for (Index i : a.indices()) {
                a.setCell(i, deserializeScalar(com));
            }
            return a;
        } else {
            return deserializeScalar(com);
        }
    }
    public CValue FType.deserializeScalar(ProcessCommunicator com) throws IOException {
        throw new IOException();
    }
    public CValue FRealType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueReal(com.deserializeReal());
    }
    public CValue FIntegerType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueInteger((int) com.deserializeReal());
    }
    public CValue FBooleanType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueBoolean(com.deserializeReal() != 0);
    }
    public CValue FStringType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueString(com.deserializeString());
    }
    public CValue FEnumType.deserializeScalar(ProcessCommunicator com) throws IOException {
        return new CValueEnum(this, (int) com.deserializeReal());
    }
}
