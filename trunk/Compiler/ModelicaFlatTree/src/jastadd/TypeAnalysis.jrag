/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.TreeSet;
import java.util.Set;
import java.util.HashSet;


aspect FlatTypeAnalysis {

    syn lazy FType FAbstractVariable.type();
    eq FRealVariable.type()             = fRealType(size());
    eq FIntegerVariable.type()          = fIntegerType(size());
    eq FBooleanVariable.type()          = fBooleanType(size());
    eq FStringVariable.type()           = fStringType(size());
    eq FEnumVariable.type()             = getType();
    eq FRecordVariable.type()           = getType();
    eq FDerivativeVariable.type()       = fRealScalarType();
    eq FFunctionVariable.type()         = getType();
    eq UnknownFVariable.type()          = fUnknownType();
    eq FExternalObjectVariable.type()   = getType();

    syn FType FRealVariable.stateSelectType() = myFClass().stateSelectType();
    syn lazy FType FClass.stateSelectType() {
        FEnumType type = new FEnumType(Size.SCALAR, "StateSelect", new List());
        for (String el : new String[] { "never", "avoid", "default", "prefer", "always" }) 
            type.addFEnumLiteralType(new FEnumLiteralType(Size.SCALAR, el));
        return type;
    }

    // Re-evaluate record types for function variables
    private boolean FFunctionVariable.typeRewritten = false;
    rewrite FFunctionVariable { 
        when (!typeRewritten) to FFunctionVariable {
            if (getType().isRecord()) {
                FRecordType type = (FRecordType) getType();
                type.setFClass(myFClass());
            } else if (getType().isFunction()) {
                FFunctionType type = (FFunctionType) getType();
                type.setFClass(myFClass());
            }
            typeRewritten = true;
            return this;
        }
    }

    syn FType FRecordVariable.getType() = myFRecordDecl().type().sizedType(size());

    syn FType FEnumVariable.getType() = myFEnumDecl().type().sizedType(size());

    syn nta FType FExternalObjectVariable.getType() = getConstructor().myFCallable().myOutputs().get(0).type().sizedType(size());


    public FExternalStmt FAlgorithm.getFExternalStmt() {
        for (FStatement stmt : getFStatements())
            if (stmt instanceof FExternalStmt)
                return (FExternalStmt) stmt;
        return null;
    }

    inh CommonVariableDecl FExternalStmt.myConstructorOutput();
    eq Root.getChild().myConstructorOutput() = null;
    eq FFunctionDecl.getChild().myConstructorOutput()     = myOutputs().get(0);
    eq InstFullClassDecl.getChild().myConstructorOutput() = myOutputs().get(0);

    public ArrayList<FExp> FExternalStmt.myConstructorArgs() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        for (FExp arg : getArgs()) {
            if (arg.isConstructorTypeArg()) {
                res.add(arg);
            }
        }
        return res;
    }

    syn boolean FExp.isConstructorTypeArg() = false;
    eq FIdUseExp.isConstructorTypeArg()     = !myCommonVarDecl().isOutput();
    eq FSizeExp.isConstructorTypeArg()      = true;

    // TODO: Reduce code duplication here
    syn lazy FRecordType FRecordDecl.type() {
        FRecordType type = new FRecordType(Size.SCALAR, name(), new List(), myFClass());
        for (FVariable fv : getFVariables()) 
            type.addComponent(new FRecordComponentType(fv.name(), (FType) fv.type().fullCopy()));
        return type;
    }

    public class FRecordComponentType implements Comparable<FRecordComponentType> {
        public int compareTo(FRecordComponentType other) {
            return getName().compareTo(other.getName());
        }
    }

    syn lazy FType FEnumDecl.type() {
        FEnumType type = new FEnumType(Size.SCALAR, name(), new List());
        for (FEnumLiteral el : enumLiterals()) 
            type.addFEnumLiteralType(new FEnumLiteralType(Size.SCALAR, el.name()));
        return type;
    }

    syn FType FEnumLiteral.type() = myFEnumDecl().type();
    eq FEnumLitExp.type()     = hasType() ? getType() : myFEnumDecl().type();


    public FType FExp.promoteTypeForFExpList(Iterable<FExp> exps) {
        Iterator<FExp> it = exps.iterator();
        if (!it.hasNext())
            return fUnknownType();
        FType tot = it.next().type();
        while (it.hasNext())
            tot = tot.typePromotion(it.next().type());
        return tot;
    }

    syn lazy FType FAbstractEquation.type() = fUnknownType();
    eq FEquation.type() = getRight().type().typePromotion(getLeft().type());

    syn lazy FType FStatement.type() = fUnknownType();
    eq FAssignStmt.type()            = getRight().type().typePromotion(getLeft().type());
    eq FFunctionCallStmt.type()      = getCall().type();
    eq FInitArrayStmt.type()         = getFIdUseExp().type();

    /**
     * True if this equation exclusively equates real types.
     */
    syn boolean FAbstractEquation.isReal() = isReal(true);

    /**
     * True if this equation exclusively equates non-real types.
     */
    syn boolean FAbstractEquation.isNonReal() = !isReal(false);

    /**
     * True if this equation equates at least one real type and one non real type.
     */
    syn boolean FAbstractEquation.isMixed() {
        return !isReal(true) && isReal(false);
    }

    syn boolean FAbstractEquation.isReal(boolean exclusive) {
        boolean res = exclusive;
        for (FVariable fv : referencedFVariablesInLHS()) {
            boolean fvRes = fv.isReal();
            res = exclusive ? res && fvRes : res || fvRes;
        }
        return res;
    }
    eq FEquation.isReal(boolean exclusive) = type().isReal();

    eq FIfWhenElseEquation.isReal(boolean exclusive) {
        boolean res = exclusive;
        for (FAbstractEquation equation : getFAbstractEquations()) {
            boolean fvRes = equation.isReal(exclusive);
            res = exclusive ? res && fvRes : res || fvRes;
        }
        return res;
    }
    eq FIfEquation.isReal(boolean exclusive) {
        return super.isReal(exclusive) && (!exclusive || (!hasElse() || getElse().isReal()));
    }

    syn boolean FRelExp.isRealComparison()    = getRight().type().numericPromotion(getLeft().type()).isReal();
    syn boolean FRelExp.isIntegerComparison() = getRight().type().numericPromotion(getLeft().type()).isInteger();
    syn boolean FRelExp.isBooleanComparison() = getRight().type().numericPromotion(getLeft().type()).isBoolean();
    syn boolean FRelExp.isStringComparison()  = getRight().type().numericPromotion(getLeft().type()).isString();


    syn FType FExp.type() = fUnknownType();
    
    eq FNoExp.type() = fNoType();
    
    syn lazy FType FAbstractArrayExp.type() = super.type();

    eq FUnaryExp.type()   = 
        shouldUseOverloadedOperator() ? getFExp().type().matchOverloadedOperatorType(null, operatorName()) : getFExp().type();
    eq FArtmBinExp.type() = getLeft().type().looseNumericPromotion(getRight().type(), false, operatorName());
    eq FSubExp.type()     = getLeft().type().numericPromotion(getRight().type(), false, operatorName());
    eq FNegExp.type()     = getFExp().type().hasNeg() ? super.type() : fUnknownType();

    eq FDotAddExp.type() {
        FType t = rawType();
        return t.hasAdd() ? t : fUnknownType();
    }

    syn FType FDotAddExp.rawType() = getLeft().type().looseTypePromotion(getRight().type(), false, operatorName());
    eq FAddExp.rawType()           = getLeft().type().typePromotion(getRight().type(), false, operatorName());

    eq FUnaryBuiltIn.type() = getFExp().type();
    eq FEdgeExp.type()      = fBooleanType(size());
    eq FChangeExp.type()    = fBooleanType(size());
    eq FLoadResource.type() = fStringScalarType();

    eq FDimensionConvert.type() = getFExp().type().sizedType(size());

    eq FDotDivExp.type() {
        FType t = super.type();
        if (t.isInteger())
            t = fRealType(t.size());
        return t;
    }

    eq FDivExp.type() {
        if (getRight().type().isScalar() || shouldUseOverloadedOperator())
            return super.type();
        else
            return fUnknownType();
    }

    eq FMulExp.type() {
        FType res = null;
        if (ndims() < 0)
            return fUnknownType();
        if (isElementWise())
            return super.type();
        Size left = getLeft().size();
        Size right = getRight().size();
        if (shouldUseOverloadedOperator()) {
            res = getLeft().type().matchOverloadedOperatorType(getRight().type(), operatorName());
            if (!res.isUnknown())
                return res;
        }
        if (!left.equivalentDim(right, inFunction(), left.ndims() - 1, 0))
            return fUnknownType();
        if (left.ndims() > 2 || right.ndims() > 2)
            return fUnknownType();
        if (left.ndims() == 1 && right.ndims() > 0 && shouldUseOverloadedOperator())
            return fUnknownType();
        res = getLeft().type().scalarNumericPromotion(getRight().type(), operatorName());
        if (left.ndims() == 1 && right.ndims() == 1) 
            return res;
        else
            return res.arrayType(size());
    }

    eq FDotPowExp.type() {
        FType t = getLeft().type().looseNumericPromotion(getRight().type());
        return (t.isUnknown() || shouldUseOverloadedOperator()) ? t : fRealType(t.size());
    }

    eq FPowExp.type() {
        if (shouldUseOverloadedOperator()) {
            FType res = getLeft().type().matchOverloadedOperatorType(getRight().type(), operatorName());
            if (!res.isUnknown())
                return res;
        }
        if (getRight().type().isUnknown() || getRight().ndims() != 0)
            return fUnknownType();
        if (getLeft().ndims() == 0)
            return super.type();
        // Left operand is not scalar, must be matrix exponentiation
        if (ndims() != 2 || size().get(0) != size().get(1))
            return fUnknownType();
        if (!getRight().type().isInteger() || !getRight().isConstantExp())
            return fUnknownType();
        if (getRight().ceval().intValue() < 0)
            return fUnknownType();
        return fRealArrayType(size());
    }

    eq FEnumIntegerExp.type() = getFExp().type().isEnumScalar() ? fIntegerScalarType() : fUnknownType();
    eq FStringExp.type()      = fStringScalarType();

    eq FEventGenExp.type()    = fRealType(size());
    eq FIntegerFuncExp.type() = fIntegerType(size());
    eq FBinEventGenExp.type() = argType();

    eq FHomotopyExp.type()    = getActual().type();
    eq FSemiLinearExp.type()  = fRealType(size());

    syn FType FEventGenExp.argType() = getX().type();
    eq FBinEventGenExp.argType() = 
            getX().type().scalarType().numericPromotion(getY().type().scalarType()).sizedType(size());

    eq FRecordConstructor.type() = getType();
    syn FType FRecordConstructor.getType() {
        FRecordType frt = getRecord().recordType().fullCopy();
        for (int i = 0; i < frt.getNumComponent(); i++) {
            frt.getComponent(i).getFType().transferSizes(getArg(i).type());
        }
        return frt;
    }

    syn FRecordType FIdUse.recordType() = myFRecordDecl().type();

    eq FTranspose.type() = 
        getFExp().ndims() < 2 ? 
            fUnknownType() : 
            getFExp().type().arrayType(size());

    eq FSymmetric.type() = getFExp().ndims() == 2 && getFExp().size().get(0) == getFExp().size().get(1) ?
        getFExp().type() : 
        fUnknownType();

    eq FCross.type() = getX().type().numericPromotion(getY().type());
    eq FSkew.type()  = getFExp().type().arrayType(size());

    eq FOuterProduct.type() { 
        if (getX().ndims() != 1 || getY().ndims() != 1)
            return fUnknownType();
        FType scalar = getX().type().scalarType().numericPromotion(getY().type().scalarType());
        return scalar.sizedType(size());
    }

    eq FNdimsExp.type() = fIntegerScalarType();

    eq FSizeExp.type() {
        if (hasDim()) {
            if (!getDim().variability().parameterOrLess())
                return fUnknownType();
            if (!getDim().type().isIntegerScalar())
                return fUnknownType();
            int dim = dimension();
            if (dim < 0 || dim > getFExp().ndims() - 1)
                return fUnknownType();
            return fIntegerScalarType();
        } else {
            return fIntegerArrayType(size());
        }
    }
    eq FUnknownSizeExp.type() = fIntegerScalarType();

    eq FMinMaxExp.type() = 
        hasY() ? 
            getX().type().scalarType().typePromotion(getY().type().scalarType()) : 
            getX().type().scalarType();

    eq FRangeExp.type() {
        FType tot = promoteTypeForFExpList(getFExps());
        if (!tot.isScalar() || !tot.canBeRange() || (!tot.isNumeric() && hasStep()))
                return fUnknownType();
        return tot.arrayType(size());
    }

    syn boolean FType.canBeRange() = false;
    eq FIntegerType.canBeRange()   = true;
    eq FRealType.canBeRange()      = true;
    eq FBooleanType.canBeRange()   = true;
    eq FEnumType.canBeRange()      = true;

    eq FArgumentExp.type() = copiedFExp().type();

    eq FLinspace.type() {
        // TODO: check that endpoints are real
        try {
            if ((getN().variability().parameterOrLess() && getN().ceval().intValue() >= 2) || inFunction())
                return fRealArrayType(size());
        } catch (ConstantEvaluationException e) {
        }
        return fUnknownType();
    }

    eq FRelExp.type() {
        if (shouldUseOverloadedOperator()) 
            return getLeft().type().matchOverloadedOperatorType(getRight().type(), operatorName());
        FType left = getLeft().type();
        if (left.equivalentTo(getRight().type()) && left.isScalar())
            return fBooleanScalarType();
        else
            return fUnknownType();
    }
    eq FEqRelExp.type() {
        if ((getLeft().type().isReal() || getRight().type().isReal()) && !inFunction())
            return fUnknownType();
        return super.type();
    }
    eq FLogBinExp.type() {
        if (shouldUseOverloadedOperator()) 
            return getLeft().type().matchOverloadedOperatorType(getRight().type(), operatorName());
        FType left = getLeft().type();
        if (left.typeCompatible(getRight().type()) && left.isBoolean())
            return left;
        else
            return fUnknownType();
    }
    eq FNotExp.type() = shouldUseOverloadedOperator() ? 
            getFExp().type().matchOverloadedOperatorType(null, operatorName()) : 
            (getFExp().type().isBoolean() ? getFExp().type() : fUnknownType());

    eq FIfExp.type() {
        FType thenType = getThenExp().type();
        FType elseType = getElseExp().type();
        if (!getIfExp().isOKTestExp() || thenType.ndims() != elseType.ndims())
            return fUnknownType();
        
        if (thenType.equivalentTo(elseType))
            return thenType.typePromotion(elseType);
        
        if (isParameterIf()) {
            try {
                FExp sel = cevalSelectExp();
                FType scalar = thenType.scalarType();
                scalar = scalar.typePromotion(elseType.scalarType());
                return scalar.arrayType(sel.size());
            } catch (ConstantEvaluationException e) {
            }
        }
        
        // Test doesn't seem to be parameter expression - require sizes to be same
        return thenType.typePromotion(elseType, inFunction(), null);
    }

    syn boolean FIfExp.isParameterIf() = getIfExp().variability().parameterOrLess();

    syn boolean FExp.isOKTestExp() = type().isBoolean() && type().isScalar();

    eq FRealLitExp.type()     = fRealScalarType();
    eq FIntegerLitExp.type()  = fIntegerScalarType();
    eq FBooleanLitExp.type()  = fBooleanScalarType();
    eq FStringLitExp.type()   = fStringScalarType();
    eq FTimeExp.type()        = fRealScalarType();
    eq FAbstractDerExp.type() = fRealType(size());

    eq FVectUnaryBuiltIn.type() = scalarType().sizedType(size());

    eq FSmoothExp.type() = getFExp().type();

    eq FConnectionsOp.type() = fNoType();
    eq FConnBoolOp.type()    = fBooleanScalarType();

    eq FCardinality.type() = fIntegerScalarType();

    eq FTerminate.type() = fNoType();
    eq FReinit.type() = fNoType();
    eq FAssert.type() = fNoType();
    eq FGetInstanceName.type() = fStringScalarType();

    eq FDelayExp.type() = getFExp().type();
    eq FSpatialDistExp.type() = getIn0().type();

    /**
     * The scalar type of the expression.
     * 
     * Base implementation assumes same as argument.
     */
    syn FType FVectUnaryBuiltIn.scalarType() = getFExp().type().scalarType();
    eq FSignExp.scalarType() = fIntegerScalarType();

    // TODO: expand to handle boolean and enum index
    eq FEndExp.type() = fIntegerScalarType();

    eq FSampleExp.type() {
        for (FExp ch : childFExps())
            if (!ch.variability().parameterOrLess())
                return fUnknownType();
        return fBooleanScalarType();
    }

    eq FSimulationStateBuiltIn.type() = fBooleanScalarType();

    /**
     * Check if this FArray is on the form "{exp for i in exp}".
     */
    syn boolean FArray.isIterArray() = getNumFExp() == 1 && getFExp(0).isIterExp();

    /**
     * Check if this FExp is on the form "exp for i in exp".
     */
    syn boolean FExp.isIterExp() = false;
    eq FIterExp.isIterExp()      = true;

    /**
     * Returns the expression being iterated over in an FIterExp child. 
     *        Only valid if {@link #isIterExp()} returns <code>true</code>.
     */
    public FExp FReductionExp.iterExp() { return ((FIterExp) getFExp()).getFExp(); }

    eq FArray.type() {
        if (isIterArray())
            return getFExp(0).type();
        
        // Check that the types of the elements are consistent
        int n = getNumFExp();
        FType t = n > 0 ? getFExp(0).type() : fUnknownType();
        boolean func = inFunction();
        for (int i = 1; i < n && !t.isUnknown(); i++) {
            t = mergeArrayCellTypes(t, getFExp(i).type(), func);
        }
        return t.arrayType(size());
    }
    
    syn FType FArray.mergeArrayCellTypes(FType t1, FType t2, boolean func) {
        if (t1.isNoType()) {
            return t2;
        } else if (t2.isNoType()) {
            return t1;
        } else {
            return t1.typePromotion(t2, func, null);
        }
    }
    
    syn boolean FExp.isNoExp() = false;
    eq FNoExp.isNoExp() = true;
    
    syn boolean FType.isNoType() = false;
    eq FNoType.isNoType() = true;

    eq FAbstractCat.type() {
        if (!dimensionIsOk())
            return fUnknownType();
        int dim = dimension();
        
        FType t = getFExp(0).type().scalarType();
        Size s = getFExp(0).size().promote(ndimsForArg(0));
        boolean func = inFunction();
        for (int i = 1; i < getNumFExp(); i++) {
            // Check that the types of the elements are consistent
            FType t2 = getFExp(i).type().scalarType();
            if (!t.equivalentTo(t2, func)) 
                return fUnknownType();
            if (t.isNumeric()) 
                t = t.numericPromotion(t2, func, null);
            
            // Check that the sizes are consistent
            Size s2 = getFExp(i).size().promote(ndimsForArg(i));
            if (!s.equivalentExcept(s2, func, dim))
                return fUnknownType();
        }
        return t.arrayType(size());
    }

    syn int FAbstractCat.ndimsForArg(int i) = ndims();
    eq FCatExp.ndimsForArg(int i)           = getFExp(i).ndims();

    eq FReductionExp.type() {
        if (getFExp().isIterExp())
            return iterExp().type();
        return getFExp().type().scalarType();
    }

    eq FIterExp.type() {
        if (ndims() < 0)
            return fUnknownType();
        return getFExp().type().arrayType(size());
    }

    eq FIdentity.type() {
        if (!getFExp().variability().parameterOrLess() && !inFunction())
            return fUnknownType();
        return fIntegerArrayType(size());
    }
    eq FDiagonal.type() = getFExp().type().arrayType(size());

    eq FSubscriptedExp.type() = getFExp().type().sizedType(size());

    eq FArrayDimAsArgsExp.type() = (size().ndims() > 0) ? fIntegerArrayType(size()) : fUnknownType();
    eq FFillExp.type()           = (size().ndims() > 0) ? getFillExp().type().arrayType(size()) : fUnknownType();

    eq FIdUseExp.type() = getFIdUse().type();
    
    eq FDSRefExp.type() = getOrg().type();

    syn lazy FType FIdUse.type() = myFV().type().sizedType(size());

    syn FType InstAccess.type() {
        if (myInstComponentDecl().isAssignable()) {
            InstAssignable ip = (InstAssignable) myInstComponentDecl();
            FType t = ip.type().scalarType();
            return isArray() ? t.arrayType(size()) : t;
        } else if (myInstClassDecl().isEnum()) {
            return myInstClassDecl().enumType();
        } else if (myInstClassDecl().isBoolean()) {
            return myInstClassDecl().fBooleanType(size());
        } else {
            return fUnknownType();
        }
	}

    eq FIgnoredBuiltIn.type() = fUnknownType();

    inh FType FFunctionCallLeft.type();
    eq FFunctionCallEquation.getLeft(int i).type() = getCall().typeOfOutput(i);
    eq FFunctionCallStmt.getLeft(int i).type()     = getCall().typeOfOutput(i);

	syn FType FAbstractFunctionCall.typeOfOutput(int i) = (i == 0) ? type() : fUnknownType();
    syn lazy FType InstFunctionCall.typeOfOutput(int i) = myCallOutputs().get(i).type().sizedType(sizeOfOutput(i));
    syn lazy FType FFunctionCall.typeOfOutput(int i)    = myCallOutputs().get(i).type().sizedType(sizeOfOutput(i));

    eq FFunctionCall.type()    = hasOutputs() ? typeOfOutput(0) : fUnknownType();
    eq FMathematicalFunctionCall.type() = fRealType(size());
    eq FPartialFunctionCall.type() {
        List<FRecordComponentType> inputs = new List<FRecordComponentType>();
        Set<String> s = new HashSet<String>();
        for (FIdUse u : getArgNames()) {
            s.add(u.name());
        }
        for (CommonVariableDecl cvd : myFCallable().myInputs()) {
            if (!s.contains(cvd.name()))
                inputs.add(new FRecordComponentType(cvd.name(), cvd.type()));
        }
        List<FRecordComponentType> outputs = new List<FRecordComponentType>();
        for (CommonVariableDecl cvd : myFCallable().myOutputs()) {
            outputs.add(new FRecordComponentType(cvd.name(), cvd.type()));
        }
        return new FFunctionType(size(), name(), inputs, outputs, myFClass());
    }

    // TODO: expand to handle boolean end enum index
    syn lazy FType FSubscript.type();
    eq FColonSubscript.type()   = fIntegerArrayType(size());
    eq FIntegerSubscript.type() = fIntegerScalarType();
    eq FExpSubscript.type()     = getFExp().type();

    public FType FType.lookupHierarchical(FQName name, int part) {
        return this;
    }
    
    public FType FRecordType.lookupHierarchical(FQName name, int part) {
        FAbstractVariable res = null;
        String pn = name.partName(part);
        for (FRecordComponentType frct : getComponents())
            if (frct.getName().equals(pn))
                return frct.getFType().lookupHierarchical(name, part + 1);
        return null;
    }
}


aspect TypePromotion {

    /**
     * Combine two types to the broadest common denominator.
     * 
     * If types are not compatible, the unknown type is returned.
     * An integer type combined with a real type results in a real type.
     */
    syn FType FType.typePromotion(FType type) = typePromotion(type, false, null);

    /**
     * Combine two types to the broadest common denominator.
     * 
     * If scalar types are not compatible or if both are array and sizes 
     * doesn't match, the unknown type is returned.
     * An integer type combined with a real type results in a real type.
     */
    syn FType FType.looseTypePromotion(FType type) = looseTypePromotion(type, false, null);

    /**
     * Combine two types to the broadest common numeric denominator.
     * 
     * If either is non-numeric or if sizes doesn't match, 
     * the unknown type is returned.
     * An integer type combined with a real type results in a real type.
     */
    syn FType FType.numericPromotion(FType type) = numericPromotion(type, false, null);

    /**
     * Combine two types to the broadest common numeric denominator.
     * 
     * If either is non-numeric or if both are array and sizes doesn't match, 
     * the unknown type is returned. 
     * An integer type combined with a real type results in a real type.
     */
    syn FType FType.looseNumericPromotion(FType type) = looseNumericPromotion(type, false, null);

    /**
     * Combine two types to the broadest common denominator.
     * 
     * If types are not compatible, the unknown type is returned.
     * An integer type combined with a real type results in a real type.
     * If <code>allowUnknown</code> is <code>true</code>, then unknown 
     * lengths are considered equal to any length. If non-<code>null</code>, 
     * <code>operator</code> defines what operator to use in operator 
     * overloading.
     */
    syn FType FType.typePromotion(FType type, boolean allowUnknown, String operator) {
        if ((isOperatorRecord() || type.isOperatorRecord()) && operator != null) {
            return matchOverloadedOperatorType(type, operator, false, allowUnknown);
        } else if (isNumeric())
            return numericPromotion(type, allowUnknown, operator);
        else if (!equivalentTo(type, allowUnknown))
            return fUnknownType();
        else
            return this;
    }

    /**
     * Combine two types to the broadest common denominator.
     * 
     * If scalar types are not compatible or if both are array and sizes 
     * doesn't match, the unknown type is returned.
     * An integer type combined with a real type results in a real type.
     * If <code>allowUnknown</code> is <code>true</code>, then unknown 
     * lengths are considered equal to any length. If non-<code>null</code>, 
     * <code>operator</code> defines what operator to use in operator 
     * overloading.
     */
    syn FType FType.looseTypePromotion(FType type, boolean allowUnknown, String operator) {
        if ((isOperatorRecord() || type.isOperatorRecord()) && operator != null) {
            return matchOverloadedOperatorType(type, operator, true, allowUnknown);
        } else if (looslyDimensionCompatible(type, allowUnknown)) {
            FType scalar = scalarType().typePromotion(type.scalarType(), false, operator);
            return scalar.sizedType(isScalar() ? type.size() : size());
        } else {
            return fUnknownType();
        }
    }

    /**
     * Combine two types to the broadest common numeric denominator.
     * 
     * If either is non-numeric or if sizes doesn't match, 
     * the unknown type is returned. Operator records with suitable 
     * overloaded operators are considered numeric for this purpose.
     * An integer type combined with a real type results in a real type.
     * If <code>allowUnknown</code> is <code>true</code>, then unknown 
     * lengths are considered equal to any length. If non-<code>null</code>, 
     * <code>operator</code> defines what operator to use in operator 
     * overloading.
     */
    syn FType FType.numericPromotion(FType type, boolean allowUnknown, String operator) {
        if (isOperatorRecord() || type.isOperatorRecord()) {
            return matchOverloadedOperatorType(type, operator, false, allowUnknown);
        } else if (dimensionCompatible(type, allowUnknown)) {
            return scalarNumericPromotion(type, operator).arrayType(size());
        } else {
            return fUnknownType();
        }
    }

    /**
     * Combine two types to the broadest common numeric denominator.
     * 
     * If either is non-numeric or if both are array and sizes doesn't match, 
     * the unknown type is returned. Operator records with suitable 
     * overloaded operators are considered numeric for this purpose.
     * An integer type combined with a real type results in a real type.
     * If <code>allowUnknown</code> is <code>true</code>, then unknown 
     * lengths are considered equal to any length. If non-<code>null</code>, 
     * <code>operator</code> defines what operator to use in operator 
     * overloading.
     */
    syn FType FType.looseNumericPromotion(FType type, boolean allowUnknown, String operator) {
        if (isOperatorRecord() || type.isOperatorRecord()) {
            return matchOverloadedOperatorType(type, operator, true, allowUnknown);
        } else if (looslyDimensionCompatible(type, allowUnknown)) {
            return scalarNumericPromotion(type, operator).sizedType(isScalar() ? type.size() : size());
        } else {
            return fUnknownType();
        }
    }

    /**
     * Combine two types to the broadest common scalar numeric denominator.
     * 
     * If either is non-numeric, the unknown type is returned.
     * An integer type combined with a real type results in a real type.
     * If non-<code>null</code>, <code>operator</code> defines what operator 
     * to use in operator overloading.
     */
    syn FType FType.scalarNumericPromotion(FType type, String operator) = 
        scalarType().matchOverloadedOperatorType(type.scalarType(), operator, false, false);
    eq FPrimitiveNumericType.scalarNumericPromotion(FType type, String operator) {
        if (isOperatorRecord() || type.isOperatorRecord()) {
            return scalarType().matchOverloadedOperatorType(type.scalarType(), operator, false, false);
        } else if (type.isNumeric()) 
            return isReal() ? scalarType() : type.scalarType();
        else 
            return super.scalarNumericPromotion(type, operator);
    }

}


aspect FTypeCompatibility {

    syn boolean FType.typeCompatible(FType type) = typeCompatible(type, false);

    syn boolean FType.typeCompatible(FType type, boolean allowUnknown) = false;
    eq FRealType.typeCompatible(FType type, boolean allowUnknown) = 
        (type.isReal() || type.isInteger()) && dimensionCompatible(type, allowUnknown);
    eq FIntegerType.typeCompatible(FType type, boolean allowUnknown) = 
        type.isInteger() && dimensionCompatible(type, allowUnknown);
    eq FBooleanType.typeCompatible(FType type, boolean allowUnknown) = 
        type.isBoolean() && dimensionCompatible(type, allowUnknown);
    eq FStringType.typeCompatible(FType type, boolean allowUnknown) = 
        type.isString() && dimensionCompatible(type, allowUnknown);
    eq FRecordType.typeCompatible(FType type, boolean allowUnknown) = 
        typeMatches(type, true, allowUnknown);
    eq FEnumType.typeCompatible(FType type, boolean allowUnknown) = 
        typeMatches(type, true, allowUnknown);
    eq FExternalObjectType.typeCompatible(FType type, boolean allowUnknown) = 
        typeMatches(type, true, allowUnknown);
    eq FFunctionType.typeCompatible(FType type, boolean allowUnknown) =
        typeMatches(type, true, allowUnknown);
    
    syn boolean FType.typeMatches(FType type, boolean compatible, boolean allowUnknown) =
        compatible ? typeCompatible(type, allowUnknown) : equivalentTo(type, allowUnknown);
    eq FRecordType.typeMatches(FType type, boolean compatible, boolean allowUnknown) {
        if (!dimensionCompatible(type, allowUnknown) || !type.isRecord())
            return false;
        FRecordType rec = (FRecordType) type;
        if (getName().equals(rec.getName())) 
            return true;
        if (getNumComponent() != rec.getNumComponent())
            return false;
        TreeSet<FRecordComponentType> comps1 = new TreeSet<FRecordComponentType>();
        TreeSet<FRecordComponentType> comps2 = new TreeSet<FRecordComponentType>();
        for (FRecordComponentType t : getComponents())
            comps1.add(t);
        for (FRecordComponentType t : rec.getComponents())
            comps2.add(t);
        return typeMatches(comps1, comps2, compatible, allowUnknown);
    }
    eq FExternalObjectType.typeMatches(FType type, boolean compatible, boolean allowUnknown) {
        if (!dimensionCompatible(type, allowUnknown) || !type.isExternalObject())
            return false;
        FExternalObjectType obj = (FExternalObjectType) type;
        if (getName().equals(obj.getName())) 
            return true;
        return false;
    }
    eq FEnumType.typeMatches(FType type, boolean compatible, boolean allowUnknown) {
        if (!dimensionCompatible(type, allowUnknown) || !type.isEnum())
            return false;
        FEnumType enu = (FEnumType) type;
        if (getName().equals(enu.getName())) 
            return true;
        int n1 = getNumFEnumLiteralType(), n2 = enu.getNumFEnumLiteralType();
        if (n1 != n2)
            return n1 == 0 || n2 == 0;
        Iterator<FEnumLiteralType> it = enu.getFEnumLiteralTypes().iterator();
        for (FEnumLiteralType elt : getFEnumLiteralTypes())
            if (!elt.getName().equals(it.next().getName()))
                return false;
        return true;
    }
    eq FFunctionType.typeMatches(FType type, boolean compatible, boolean allowUnknown) {
        if (!dimensionCompatible(type, allowUnknown) || !type.isFunction())
            return false;
        FFunctionType obj = (FFunctionType) type;
        if (!compatible && !getName().equals(obj.getName())) 
            return false;
        if (getNumInput() != obj.getNumInput())
            return false;
        if (getNumOutput() > obj.getNumOutput())
            return false;
        
        return typeMatches(getInputs(), obj.getInputs(), compatible, allowUnknown) &&
                typeMatches(getOutputs(), obj.getOutputs(), compatible, allowUnknown);
    }
    
    syn boolean FType.typeMatches(Iterable<FRecordComponentType> comps1, Iterable<FRecordComponentType> comps2, 
            boolean compatible, boolean allowUnknown) {
        Iterator<FRecordComponentType> i1 = comps1.iterator();
        Iterator<FRecordComponentType> i2 = comps2.iterator();
        while (i1.hasNext()) {
            if (!i1.next().typeMatches(i2.next(), compatible, allowUnknown))
                return false;
        }
        return true;
    }
    
    syn boolean FRecordComponentType.typeMatches(FRecordComponentType type, boolean compatible, boolean allowUnknown) {
        return getName().equals(type.getName()) && getFType().typeMatches(type.getFType(), compatible, allowUnknown);
    }
    
    syn boolean FType.dimensionCompatible(FType type) = dimensionCompatible(type, false);
    syn boolean FType.dimensionCompatible(FType type, boolean allowUnknown) = 
        size().equivalent(type.size(), allowUnknown);

    syn boolean FType.looslyDimensionCompatible(FType type, boolean allowUnknown) = 
        isScalar() || type.isScalar() || dimensionCompatible(type, allowUnknown);

}


aspect FTypeEquivalent {

    /* The function equivalentTo is used in equation type checking where equations like
     * x=0
     * where x is declared as Real is ok.
     */
    syn boolean FType.equivalentTo(FType type) = equivalentTo(type, false);

    syn boolean FType.equivalentTo(FType type, boolean allowUnknown) = false;
    eq FPrimitiveNumericType.equivalentTo(FType type, boolean allowUnknown) = 
        type.isNumeric() && dimensionCompatible(type, allowUnknown);
    eq FBooleanType.equivalentTo(FType type, boolean allowUnknown) = 
        type.isBoolean() && dimensionCompatible(type, allowUnknown);
    eq FStringType.equivalentTo(FType type, boolean allowUnknown) = 
        type.isString() && dimensionCompatible(type, allowUnknown);
    eq FRecordType.equivalentTo(FType type, boolean allowUnknown) = 
        typeMatches(type, false, allowUnknown);
    eq FEnumType.equivalentTo(FType type, boolean allowUnknown) = 
        typeMatches(type, false, allowUnknown);
    eq FExternalObjectType.equivalentTo(FType type, boolean allowUnknown) = 
        typeMatches(type, false, allowUnknown);
    eq FFunctionType.equivalentTo(FType type, boolean allowUnknown) =
        typeMatches(type, false, allowUnknown);
}


aspect BuiltInFlatTypes {

    public static final FRealType    FRealType.SCALAR                   = new FRealType(Size.SCALAR);
    public static final FIntegerType FIntegerType.SCALAR                = new FIntegerType(Size.SCALAR);
    public static final FBooleanType FBooleanType.SCALAR                = new FBooleanType(Size.SCALAR);
    public static final FStringType  FStringType.SCALAR                 = new FStringType(Size.SCALAR);
    public static final FUnknownType FUnknownType.SCALAR                = new FUnknownType(Size.SCALAR);
    public static final FNoType      FNoType.SCALAR                     = new FNoType(Size.SCALAR);

    syn boolean FType.isReal()                  = false;
    eq FRealType.isReal()                       = true;
    syn boolean FType.isInteger()               = false;
    eq FIntegerType.isInteger()                 = true;
    syn boolean FType.isBoolean()               = false;
    eq FBooleanType.isBoolean()                 = true;
    syn boolean FType.isString()                = false;
    eq FStringType.isString()                   = true;
    syn boolean FType.isRecord()                = false;
    eq FRecordType.isRecord()                   = true;
    syn boolean FType.isOperatorRecord()        = false;
    eq FOperatorRecordType.isOperatorRecord()   = true;
    syn boolean FType.isEnum()                  = false;
    eq FEnumType.isEnum()                       = true;
    syn boolean FType.isExternalObject()        = false;
    eq FExternalObjectType.isExternalObject()   = true;
    syn boolean FType.isFunction()              = false;
    eq FFunctionType.isFunction()               = true;

    syn boolean FType.isArray()  = getSize() != Size.SCALAR;
    syn boolean FType.isScalar() = getSize() == Size.SCALAR;

    syn boolean FType.isNumeric()        = false;
    eq FPrimitiveNumericType.isNumeric() = true;

    syn boolean FType.isPrimitive() = false;
    eq FPrimitiveType.isPrimitive() = true;

    syn boolean FType.isRealScalar()            = isReal() && isScalar();
    syn boolean FType.isRealArray()             = isReal() && isArray();
    syn boolean FType.isIntegerScalar()         = isInteger() && isScalar();
    syn boolean FType.isIntegerArray()          = isInteger() && isArray();
    syn boolean FType.isBooleanScalar()         = isBoolean() && isScalar();
    syn boolean FType.isBooleanArray()          = isBoolean() && isArray();
    syn boolean FType.isStringScalar()          = isString() && isScalar();
    syn boolean FType.isStringArray()           = isString() && isArray();
    syn boolean FType.isRecordScalar()          = isRecord() && isScalar();
    syn boolean FType.isRecordArray()           = isRecord() && isArray();
    syn boolean FType.isEnumScalar()            = isEnum() && isScalar();
    syn boolean FType.isEnumArray()             = isEnum() && isArray();
    syn boolean FType.isNumericScalar()         = isNumeric() && isScalar();
    syn boolean FType.isNumericArray()          = isNumeric() && isArray();
    syn boolean FType.isPrimitiveScalar()       = isPrimitive() && isScalar();
    syn boolean FType.isPrimitiveArray()        = isPrimitive() && isArray();
    syn boolean FType.isExternalObjectScalar()  = isExternalObject() && isScalar();
    syn boolean FType.isExternalObjectArray()   = isExternalObject() && isArray();

    syn boolean FType.containsReal() = isReal();
    eq FRecordType.containsReal() {
        for (FRecordComponentType component : getComponents())
            if (component.getFType().containsReal())
                return true;
        return false;
    }
    syn boolean FType.containsInteger() = isInteger();
    eq FRecordType.containsInteger() {
        for (FRecordComponentType component : getComponents())
            if (component.getFType().containsInteger())
                return true;
        return false;
    }
    syn boolean FType.containsBoolean() = isBoolean();
    eq FRecordType.containsBoolean() {
        for (FRecordComponentType component : getComponents())
            if (component.getFType().containsBoolean())
                return true;
        return false;
    }
    syn boolean FType.containsRecord() = isRecord();
    syn boolean FType.containsEnum() = isEnum();
    eq FRecordType.containsEnum() {
        for (FRecordComponentType component : getComponents())
            if (component.getFType().containsEnum())
                return true;
        return false;
    }
    syn boolean FType.containsExternalObject() = isExternalObject();
    eq FRecordType.containsExternalObject() {
        for (FRecordComponentType component : getComponents())
            if (component.getFType().containsExternalObject())
                return true;
        return false;
    }

    // For type comparisons ending with "or records of such types"
    public abstract class FType {
        protected static interface TypeChecker {
            public boolean check(FType t);
        }
        
        private static final TypeChecker IS_REAL = new TypeChecker() {
            public boolean check(FType t) { return t.isReal(); }
        };
    }

    protected boolean FType.recursiveTypeCheck(TypeChecker ch) {
        return ch.check(this);
    }

    protected boolean FRecordType.recursiveTypeCheck(TypeChecker ch) {
        for (FRecordComponentType c : getComponents())
            if (!c.getFType().recursiveTypeCheck(ch))
                return false;
        return true;
    }

    syn boolean FType.onlyContainsReal() = recursiveTypeCheck(IS_REAL);

    syn boolean FType.hasAdd()        = false;
    eq FPrimitiveNumericType.hasAdd() = true;
    eq FStringType.hasAdd()           = true;

    syn boolean FType.hasNeg()        = false;
    eq FPrimitiveNumericType.hasNeg() = true;

    syn boolean FType.canBeIndex() = false;
    eq FIntegerType.canBeIndex()   = true;
    eq FBooleanType.canBeIndex()   = true;
    eq FEnumType.canBeIndex()      = true;

    syn int FType.ndims() = getSize().ndims();

    syn Size FType.size() = getSize();

    syn FType FType.sizedType(Size s) = 
        (s == Size.SCALAR) ? scalarType() : arrayType(s);

    syn FType FType.scalarType() {
        if (isScalar())
            return this;
        FType copy = (FType) fullCopy();
        copy.setSize(Size.SCALAR);
        return copy;
    }
    eq FUnknownType.scalarType()        = this;
    eq FNoType.scalarType()             = this;
    eq FRealType.scalarType()           = FRealType.SCALAR;
    eq FIntegerType.scalarType()        = FIntegerType.SCALAR;
    eq FBooleanType.scalarType()        = FBooleanType.SCALAR;
    eq FStringType.scalarType()         = FStringType.SCALAR;

    syn boolean FType.isUnknown() = false;
    eq FUnknownType.isUnknown()   = true;

    syn FType ASTNode.fUnknownType() = FUnknownType.SCALAR;
    syn FType ASTNode.fNoType()      = FNoType.SCALAR;

    syn FPrimitiveType ASTNode.fRealScalarType()            = FRealType.SCALAR;
    syn FPrimitiveType ASTNode.fIntegerScalarType()         = FIntegerType.SCALAR;
    syn FPrimitiveType ASTNode.fBooleanScalarType()         = FBooleanType.SCALAR;
    syn FPrimitiveType ASTNode.fStringScalarType()          = FStringType.SCALAR;

    syn FPrimitiveType ASTNode.fRealArrayType(Size size)            = new FRealType(size);
    syn FPrimitiveType ASTNode.fIntegerArrayType(Size size)         = new FIntegerType(size);
    syn FPrimitiveType ASTNode.fBooleanArrayType(Size size)         = new FBooleanType(size);
    syn FPrimitiveType ASTNode.fStringArrayType(Size size)          = new FStringType(size);

    syn FPrimitiveType ASTNode.fRealType(Size size) = 
        (size == Size.SCALAR) ? fRealScalarType() : fRealArrayType(size);
    syn FPrimitiveType ASTNode.fIntegerType(Size size) = 
        (size == Size.SCALAR) ? fIntegerScalarType() : fIntegerArrayType(size);
    syn FPrimitiveType ASTNode.fBooleanType(Size size) = 
        (size == Size.SCALAR) ? fBooleanScalarType() : fBooleanArrayType(size);
    syn FPrimitiveType ASTNode.fStringType(Size size) = 
        (size == Size.SCALAR) ? fStringScalarType() : fStringArrayType(size);

    syn FType FType.arrayType(Size size) {
        if (size == size())
            return this;
        FType copy = (FType) fullCopy();
        copy.setSize(size);
        return copy;
    }
    eq FUnknownType.arrayType(Size size)        = this;

    /**
     * Create a literal with the zero value for this type, if applicable.
     * 
     * For operator records, a function call is created.
     */
    public FExp FType.zeroLiteral()        { return new FNoExp(); }
    public FExp FRealType.zeroLiteral()    { return new FRealLitExp(0.0); }
    public FExp FIntegerType.zeroLiteral() { return new FIntegerLitExp(0); }
    public FExp FStringType.zeroLiteral()  { return new FStringLitExp(""); }
    public FExp FBooleanType.zeroLiteral() { return new FBooleanLitExpFalse(); }
    public FExp FEnumType.zeroLiteral()    { return new FEnumLitExp(this, 1); }
    public FExp FRecordType.zeroLiteral()  {
        List<FExp> args = new List<FExp>();
        for (FRecordComponentType t : getComponents())
            args.add(t.getFType().zeroLiteral());
        return new FRecordConstructor(new FIdUse(getName()), args); 
    }

    /**
     * Create a literal of the given integer value for this type, if applicable.
     */
    public FExp FType.createLiteral(int v)        { return null; }
    public FExp FIntegerType.createLiteral(int v) { return new FIntegerLitExp(v); }
    public FExp FRealType.createLiteral(int v)    { return new FRealLitExp(v); }
    public FExp FEnumType.createLiteral(int v)    { return new FEnumLitExp(this, v); }

    public FExp FBooleanType.createLiteral(int v) { 
        return (v == 1 || v == 2) ? FBooleanLitExp.create(v == 2) : null; 
    }

}


aspect ExternalObjectTypes {
    
    public interface FCallable {
        public boolean isConstructor();
        public boolean isDestructor();
    }

    syn boolean FExp.isConstructorCall()    = false;
    eq InstFunctionCall.isConstructorCall() = getName().myInstClassDecl().isConstructor();
    eq FFunctionCall.isConstructorCall()    = myFCallable().isConstructor();
    syn boolean FExp.isDestructorCall()     = false;
    eq InstFunctionCall.isDestructorCall()  = getName().myInstClassDecl().isDestructor();
    eq FFunctionCall.isDestructorCall()     = myFCallable().isDestructor();

    syn boolean InstClassDecl.isDestructor()      = name().equals("destructor") && inExternalObject();
    syn boolean FFunctionDecl.isDestructor()      = false;
    syn boolean FFunctionVariable.isDestructor()  = false;
    eq FDestructorDecl.isDestructor()             = true;
    syn boolean InstClassDecl.isConstructor()     = name().equals("constructor") && inExternalObject();
    syn boolean FFunctionDecl.isConstructor()     = false;
    syn boolean FFunctionVariable.isConstructor() = false;
    eq FConstructorDecl.isConstructor()           = true;

    syn boolean FExternalObjectVariable.hasConstructorCall(Index i) {
        if (hasBindingExp()) {
            FExp exp = (i == Index.NULL) ? getBindingExp() : getBindingExp().getArray().get(i);
            return exp.isConstructorCall();
        } else {
            return hasParameterEquation() && parameterEquation().hasConstructorCall(i);
        }
        
    }
    syn boolean FAbstractEquation.hasConstructorCall(Index i) = false;
    eq FEquation.hasConstructorCall(Index i) {
        FExp exp = getRight();
        if (i != Index.NULL)
            exp = exp.getArray().get(i);
        return exp.isConstructorCall();
    }

}

aspect AliasTypes {

    syn boolean FType.typeAliasCompatible(FType type) = typeCompatible(type);
    eq FRealType.typeAliasCompatible(FType type)      = type.isReal() && typeCompatible(type);

}
