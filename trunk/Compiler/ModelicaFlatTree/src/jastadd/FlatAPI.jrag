/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.HashSet;
import java.util.Set;
import java.util.ArrayList;
import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.math.BigInteger;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.DigestOutputStream;
import java.security.NoSuchAlgorithmException;

import org.jmodelica.util.streams.StreamGobbler;

aspect FlatAPI {

    public class FClass {
        /**
         * Calculates and holds value references for all variables.
         */
        private class ValueReferenceMap {
            private int index = 0;
            private int type = 0;
            private HashMap<FVariable, Integer> map = new HashMap<FVariable, Integer>();
            
            /**
             * Start a new variable vector, i.e. reset the index part to 0.
             */
            public void resetIndex() {
                index = 0;
            }

            /**
             * Increase the index counter by one.
             */
            public void incIndex() {
                index++;
            }
            
            /**
             * Set the value to use for the type bits.
             */
            public void setType(int t) {
                type = t << 28;
            }
            
            /**
             * Calculate indices for the variables in a list and add them to the map.
             * 
             * Indices are assigned in the order variable lists are added. Within a list, 
             * they are assigned in iterator order.
             */
            public void add(Iterable<? extends FVariable> list) {
                for (FVariable fv : list) {
                    map.put(fv, new Integer(index + type));
                    index++;
                }
            }
            
            /**
             * Get the index for a variable.
             * 
             * If it is not in the map, -1 is returned.
             */
            public int get(FVariable fv) {
                Integer i = map.get(fv);
                return (i == null) ? -1 : i.intValue();
            }
        }
    }
    
    syn lazy ValueReferenceMap FClass.valueReferenceMap() {
        ValueReferenceMap map = new ValueReferenceMap();
        map.setType(0);
        map.add(independentRealConstants());
        map.add(dependentRealConstants());
        map.add(independentRealParameters());
        map.add(dependentRealParameters());
        
        map.setType(1);
        // Handle enums as Integers
        map.add(independentIntegerConstants());
        map.add(independentEnumConstants());
        map.add(dependentIntegerConstants());
        map.add(dependentEnumConstants());
        map.add(independentIntegerEnumParameters());
        map.add(dependentIntegerParameters());
        map.add(dependentEnumParameters());
        
        map.setType(2);
        map.add(independentBooleanConstants());
        map.add(dependentBooleanConstants());
        map.add(independentBooleanParameters());
        map.add(dependentBooleanParameters());
        
        map.setType(0);
        map.add(derivativeVariables());
        map.add(differentiatedRealVariables());
        map.add(realInputs());
        map.add(algebraicContinousRealVariables());
        
        // Need to increase the index counter by one since the
        // 'time' variable is stored in this position
        map.incIndex();
        
        // Need to increase the index counter by one since the
        // '_homotopy_lambda' variable is stored in this position
        map.incIndex();
        
        map.add(discreteRealVariables());
        
        map.setType(1);
        // Handle enums as Integers
        map.add(discreteIntegerVariables());
        map.add(discreteEnumVariables());
        map.add(integerInputs());
        map.add(enumInputs());
        
        map.setType(2);
        map.add(discreteBooleanVariables());
        map.add(booleanInputs());
        
        map.resetIndex();
        map.setType(3);
        map.add(independentStringConstants());
        map.add(dependentStringConstants());
        map.add(independentStringParameters());
        map.add(dependentStringParameters());
        map.add(stringInputs());
        map.add(discreteStringVariables());
        
        return map;
    }
    
    /**
     * The value reference value is represented by a 32 bit unsigned integer 
     * variable. The lowest 27 bits is used to represent the index of a 
     * variable of the corresponding variable vector. Real, Integer, Boolean and 
     * enumeration variables share a vector, while String variables has their 
     * own vector. 
     * Bit 28 is reserved for representing negated/not negated.
     * Bits 29-31 represents the primitive type, where:
     * 0: Real
     * 1: Integer or enumeration
     * 2: Boolean
     * 3: String
     * Bit 32 is left unused.
     *
     */
    inh lazy int FAbstractVariable.valueReference();
    eq FClass.getFVariable(int i).valueReference()     = valueReferenceMap().get(getFVariable(i));
    eq FClass.getAliasVariable(int i).valueReference() = getAliasVariable(i).aliasValueReference();
    eq FClass.getAliasConstant(int i).valueReference() = getAliasConstant(i).aliasValueReference();
    eq FClass.getFAbstractEquation().valueReference()  = -1;
    eq Root.getChild().valueReference()                = -1;
    
    syn int FVariable.aliasValueReference() = alias()!=null? 
        alias().valueReference(): -1;

    syn int FAbstractVariable.indexInZ() = -1;
    eq FVariable.indexInZ() = valueReference() & 0x07FFFFFF;
    
    syn boolean FIdUseExp.isConsecutiveInZ(FIdUseExp use) = myFV().isConsecutiveInZ(use.myFV());
    
    syn boolean FAbstractVariable.isConsecutiveInZ(FAbstractVariable fv) = false;
    eq FVariable.isConsecutiveInZ(FAbstractVariable fv) = indexInZ() + 1 == fv.indexInZ();

    syn int FClass.independentRealConstantsOffset() = 0;
    syn int FClass.independentIntegerConstantsOffset() = 
        numIndependentRealConstants();  
    syn int FClass.independentEnumConstantsOffset() =
        independentIntegerConstantsOffset() +     
        numIndependentIntegerConstants();   
    syn int FClass.independentBooleanConstantsOffset() =
        independentEnumConstantsOffset() +    
        numIndependentEnumConstants();  
        
    syn int FClass.dependentRealConstantsOffset() = 
        independentBooleanConstantsOffset() + 
        numIndependentBooleanConstants();
    syn int FClass.dependentIntegerConstantsOffset() =
        dependentRealConstantsOffset() +     
        numDependentRealConstants();    
    syn int FClass.dependentEnumConstantsOffset() =
        dependentIntegerConstantsOffset() +       
        numDependentIntegerConstants(); 
    syn int FClass.dependentBooleanConstantsOffset() =
        dependentEnumConstantsOffset() +      
        numDependentEnumConstants();    

    syn int FClass.independentRealParametersOffset() = 
        dependentBooleanConstantsOffset() + 
        numDependentBooleanConstants();
    syn int FClass.independentIntegerParametersOffset() =
        independentRealParametersOffset() +      
        numIndependentRealParameters(); 
    syn int FClass.independentEnumParametersOffset() =
        independentIntegerParametersOffset() +    
        numIndependentIntegerParameters();  
    syn int FClass.independentBooleanParametersOffset() =
        independentEnumParametersOffset() +       
        numIndependentEnumParameters(); 
        
    syn int FClass.dependentRealParametersOffset() = 
        independentBooleanParametersOffset() + 
        numIndependentBooleanParameters();
    syn int FClass.dependentIntegerParametersOffset() =
        dependentRealParametersOffset() +    
        numDependentRealParameters();   
    syn int FClass.dependentEnumParametersOffset() =
        dependentIntegerParametersOffset() +      
        numDependentIntegerParameters();    
    syn int FClass.dependentBooleanParametersOffset() =
        dependentEnumParametersOffset() +     
        numDependentEnumParameters();   

    syn int FClass.derivativeVariablesOffset() = 
        dependentBooleanParametersOffset() + 
        numDependentBooleanParameters();
    syn int FClass.differentiatedRealVariablesOffset() = 
        derivativeVariablesOffset() + 
        numDerivativeVariables();
    syn int FClass.realInputsOffset() = 
        differentiatedRealVariablesOffset() + 
        numDifferentiatedRealVariables();
    syn int FClass.algebraicContinousRealVariablesOffset() = 
        realInputsOffset() + 
        numRealInputs();

    syn int FClass.timeOffset() =
        algebraicContinousRealVariablesOffset() + 
        numAlgebraicContinousRealVariables();

    syn int FClass.homotopyLambdaOffset() =
        timeOffset() + 1;

    syn int FClass.discreteRealVariablesOffset() = 
        homotopyLambdaOffset() + 1;

    syn int FClass.discreteIntegerVariablesOffset() = 
        discreteRealVariablesOffset() + 
        numDiscreteRealVariables();
    syn int FClass.discreteEnumVariablesOffset() = 
        discreteIntegerVariablesOffset() + 
        numDiscreteIntegerVariables();

    syn int FClass.integerInputsOffset() = 
        discreteEnumVariablesOffset() + 
        numDiscreteEnumVariables();
    syn int FClass.enumInputsOffset() = 
        integerInputsOffset() + 
        numIntegerInputs();

    syn int FClass.discreteBooleanVariablesOffset() = 
        enumInputsOffset() + 
        numEnumInputs();
    syn int FClass.booleanInputsOffset() = 
        discreteBooleanVariablesOffset() + 
        numDiscreteBooleanVariables();

    syn boolean FVariable.shouldContribute() = !isAlias() && !inRecord() && !isForIndex();
    
    syn boolean FDerivativeVariable.shouldContributeFiltered() = shouldContribute() && (myDifferentiatedVariable().stateSelectAttributeSet() || uses().size() > 0);
    
    public class FClass {
        public static <T1, T2 extends T1> Collection<T2> filterCollection(Collection<T1> input, Criteria<T1> filter) {
            Collection<T2> res = new ArrayList<T2>();
            for (T1 elm : input) {
                if (filter.test(elm))
                    res.add((T2)elm);
            }
            return res;
        }
        
        public static <T extends FVariable, C extends Set<T>> C intersectFVSet(
                C a, Collection<? extends FVariable> b) {
            try {
                // To avoid having to have different versions for different collections
                C res = (C) a.getClass().newInstance();
                res.addAll(a);
                res.retainAll(b);
                return res;
            } catch (IllegalAccessException e) {
            } catch (InstantiationException e) {
            }
            throw new IllegalArgumentException("First argument must be of class with public default constructor.");
        }
        
        public static final Criteria<FVariable> REAL_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isReal();
            }
        };
        
        public static final Criteria<FVariable> INTEGER_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isInteger();
            }
        };
        
        public static final Criteria<FVariable> BOOLEAN_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isBoolean();
            }
        };
        
        public static final Criteria<FVariable> STRING_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isString();
            }
        };
        
        public static final Criteria<FVariable> ENUM_VARIABLE_FILTER = new Criteria<FVariable>() {
            @Override
            public boolean test(FVariable var) {
                return var.isEnum();
            }
        };
        
    }
    
    
    

    syn int FClass.numReals() = reals().size();
    coll ArrayList<FRealVariable> FClass.reals() 
      [new ArrayList<FRealVariable>()] with add root FClass;
    FRealVariable contributes this when shouldContribute() to FClass.reals() for myFClass();

    syn int FClass.numIntegers() = integers().size();
    coll ArrayList<FIntegerVariable> FClass.integers() 
      [new ArrayList<FIntegerVariable>()] with add root FClass;
    FIntegerVariable contributes this when shouldContribute() to FClass.integers() for myFClass();

    syn int FClass.numEnums() = enums().size();
    coll ArrayList<FEnumVariable> FClass.enums() 
      [new ArrayList<FEnumVariable>()] with add root FClass;
    FEnumVariable contributes this when shouldContribute() to FClass.enums() for myFClass();

    syn int FClass.numBooleans() = booleans().size();
    coll ArrayList<FBooleanVariable> FClass.booleans() 
      [new ArrayList<FBooleanVariable>()] with add root FClass;
    FBooleanVariable contributes this when shouldContribute() to FClass.booleans() for myFClass();

    syn int FClass.numStrings() = strings().size();
    coll ArrayList<FStringVariable> FClass.strings() 
      [new ArrayList<FStringVariable>()] with add root FClass;
    FStringVariable contributes this when shouldContribute() to FClass.strings() for myFClass();

    syn int FClass.numIndependentConstants() = independentConstants().size();
    coll ArrayList<FVariable> FClass.independentConstants() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes this 
      when isIndependentConstant() && shouldContribute() 
      to FClass.independentConstants() for myFClass();

    syn int FClass.numExternalObjectVariables() = externalObjectVariables().size();
    coll ArrayList<FExternalObjectVariable> FClass.externalObjectVariables()
      [new ArrayList<FExternalObjectVariable>()] with add root FClass;
    FExternalObjectVariable contributes this when shouldContribute() to FClass.externalObjectVariables() for myFClass();

    syn int FClass.numIndependentRealConstants() = independentRealConstants().size();
    syn lazy Collection<FRealVariable> FClass.independentRealConstants() =
            filterCollection(independentConstants(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numIndependentIntegerConstants() = independentIntegerConstants().size();
    syn lazy Collection<FRealVariable> FClass.independentIntegerConstants() =
            filterCollection(independentConstants(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numIndependentEnumConstants() = independentEnumConstants().size();
    syn lazy Collection<FRealVariable> FClass.independentEnumConstants() =
            filterCollection(independentConstants(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numIndependentBooleanConstants() = independentBooleanConstants().size();
    syn lazy Collection<FRealVariable> FClass.independentBooleanConstants() =
            filterCollection(independentConstants(), BOOLEAN_VARIABLE_FILTER);
    
    syn int FClass.numIndependentStringConstants() = independentStringConstants().size();
    syn lazy Collection<FRealVariable> FClass.independentStringConstants() =
            filterCollection(independentConstants(), STRING_VARIABLE_FILTER);

    // TODO: Is there such a thing as a dependent constant??
    syn int FClass.numDependentConstants() = dependentConstants().size();
    syn ArrayList<FVariable> FClass.dependentConstants() = new ArrayList<FVariable>(0);
// This collection would never contain anything, replacing with just an empty list.
//  coll ArrayList<FVariable> FClass.dependentConstants() 
//    [new ArrayList<FVariable>()] with add root FClass;
//  FVariable contributes
//      this when false
//  to FClass.dependentConstants() for myFClass();
    
    syn int FClass.numDependentRealConstants() = dependentRealConstants().size();
    syn lazy Collection<FRealVariable> FClass.dependentRealConstants() =
            filterCollection(dependentConstants(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numDependentIntegerConstants() = dependentIntegerConstants().size();
    syn lazy Collection<FIntegerVariable> FClass.dependentIntegerConstants() =
            filterCollection(dependentConstants(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numDependentEnumConstants() = dependentEnumConstants().size();
    syn lazy Collection<FEnumVariable> FClass.dependentEnumConstants() =
            filterCollection(dependentConstants(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numDependentBooleanConstants() = dependentBooleanConstants().size();
    syn lazy Collection<FBooleanVariable> FClass.dependentBooleanConstants() =
            filterCollection(dependentConstants(), BOOLEAN_VARIABLE_FILTER);
    
    syn int FClass.numDependentStringConstants() = dependentStringConstants().size();
    syn lazy Collection<FStringVariable> FClass.dependentStringConstants() =
            filterCollection(dependentConstants(), STRING_VARIABLE_FILTER);

    syn int FClass.numIndependentParameters() = independentParameters().size();
    syn lazy ArrayList<FVariable> FClass.independentParameters() {
        ArrayList<FVariable> l = new ArrayList<FVariable>();
        l.addAll(regularIndependentParameters());
        l.addAll(structuralIndependentParameters());
        l.addAll(finalIndependentParameters());
        l.addAll(evalIndependentParameters());
        return l;
    }
    
    syn int FClass.numIndependentIntegerEnumParameters() = independentIntegerEnumParameters().size();
    syn lazy ArrayList<FVariable> FClass.independentIntegerEnumParameters() {
        ArrayList<FVariable> l = new ArrayList<FVariable>();
        l.addAll(regularIndependentIntegerParameters());
        l.addAll(regularIndependentEnumParameters());
        l.addAll(structuralIndependentIntegerParameters());
        l.addAll(structuralIndependentEnumParameters());
        l.addAll(finalIndependentIntegerParameters());
        l.addAll(finalIndependentEnumParameters());
        l.addAll(evalIndependentIntegerParameters());
        l.addAll(evalIndependentEnumParameters());
        return l;
    }
    
    syn int FClass.numIndependentRealParameters() = independentRealParameters().size();
    syn lazy ArrayList<FRealVariable> FClass.independentRealParameters() {
        ArrayList<FRealVariable> l = new ArrayList<FRealVariable>();
        l.addAll(regularIndependentRealParameters());
        l.addAll(structuralIndependentRealParameters());
        l.addAll(finalIndependentRealParameters());
        l.addAll(evalIndependentRealParameters());
        return l;
    }
    
    syn int FClass.numIndependentIntegerParameters() = independentIntegerParameters().size();
    syn lazy ArrayList<FIntegerVariable> FClass.independentIntegerParameters() {
        ArrayList<FIntegerVariable> l = new ArrayList<FIntegerVariable>();
        l.addAll(regularIndependentIntegerParameters());
        l.addAll(structuralIndependentIntegerParameters());
        l.addAll(finalIndependentIntegerParameters());
        l.addAll(evalIndependentIntegerParameters());
        return l;
    }
    
    syn int FClass.numIndependentEnumParameters() = independentEnumParameters().size();
    syn lazy ArrayList<FEnumVariable> FClass.independentEnumParameters() {
        ArrayList<FEnumVariable> l = new ArrayList<FEnumVariable>();
        l.addAll(regularIndependentEnumParameters());
        l.addAll(structuralIndependentEnumParameters());
        l.addAll(finalIndependentEnumParameters());
        l.addAll(evalIndependentEnumParameters());
        return l;
    }
    
    syn int FClass.numIndependentBooleanParameters() = independentBooleanParameters().size();
    syn lazy ArrayList<FBooleanVariable> FClass.independentBooleanParameters() {
        ArrayList<FBooleanVariable> l = new ArrayList<FBooleanVariable>();
        l.addAll(regularIndependentBooleanParameters());
        l.addAll(structuralIndependentBooleanParameters());
        l.addAll(finalIndependentBooleanParameters());
        l.addAll(evalIndependentBooleanParameters());
        return l;
    }
    
    syn int FClass.numIndependentStringParameters() = independentStringParameters().size();
    syn lazy ArrayList<FStringVariable> FClass.independentStringParameters() {
        ArrayList<FStringVariable> l = new ArrayList<FStringVariable>();
        l.addAll(regularIndependentStringParameters());
        l.addAll(structuralIndependentStringParameters());
        l.addAll(finalIndependentStringParameters());
        l.addAll(evalIndependentStringParameters());
        return l;
    }
    
    syn int FClass.numRegularIndependentParameters() = regularIndependentParameters().size();
    coll ArrayList<FVariable> FClass.regularIndependentParameters() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isRegularIndependentParameter() && shouldContribute()
    to FClass.regularIndependentParameters() for myFClass();
    
    syn int FClass.numRegularIndependentRealParameters() = regularIndependentRealParameters().size();
    syn lazy Collection<FRealVariable> FClass.regularIndependentRealParameters() =
            filterCollection(regularIndependentParameters(), REAL_VARIABLE_FILTER);

    syn int FClass.numRegularIndependentIntegerParameters() = regularIndependentIntegerParameters().size();
    syn lazy Collection<FIntegerVariable> FClass.regularIndependentIntegerParameters() =
            filterCollection(regularIndependentParameters(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numRegularIndependentEnumParameters() = regularIndependentEnumParameters().size();
    syn lazy Collection<FEnumVariable> FClass.regularIndependentEnumParameters() =
            filterCollection(regularIndependentParameters(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numRegularIndependentBooleanParameters() = regularIndependentBooleanParameters().size();
    syn lazy Collection<FBooleanVariable> FClass.regularIndependentBooleanParameters() =
            filterCollection(regularIndependentParameters(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numRegularIndependentStringParameters() = regularIndependentStringParameters().size();
    syn lazy Collection<FStringVariable> FClass.regularIndependentStringParameters() =
            filterCollection(regularIndependentParameters(), STRING_VARIABLE_FILTER);
    
    syn int FClass.numStructuralIndependentParameters() = structuralIndependentParameters().size();
    coll ArrayList<FVariable> FClass.structuralIndependentParameters() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isStructuralIndependentParameter() && shouldContribute()
    to FClass.structuralIndependentParameters() for myFClass();
    
    syn int FClass.numStructuralIndependentRealParameters() = structuralIndependentRealParameters().size();
    syn lazy Collection<FRealVariable> FClass.structuralIndependentRealParameters() =
            filterCollection(structuralIndependentParameters(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numStructuralIndependentIntegerParameters() = structuralIndependentIntegerParameters().size();
    syn lazy Collection<FIntegerVariable> FClass.structuralIndependentIntegerParameters() =
            filterCollection(structuralIndependentParameters(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numStructuralIndependentEnumParameters() = structuralIndependentEnumParameters().size();
    syn lazy Collection<FEnumVariable> FClass.structuralIndependentEnumParameters() =
            filterCollection(structuralIndependentParameters(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numStructuralIndependentBooleanParameters() = structuralIndependentBooleanParameters().size();
    syn lazy Collection<FBooleanVariable> FClass.structuralIndependentBooleanParameters() =
            filterCollection(structuralIndependentParameters(), BOOLEAN_VARIABLE_FILTER);
    
    syn int FClass.numStructuralIndependentStringParameters() = structuralIndependentStringParameters().size();
    syn lazy Collection<FStringVariable> FClass.structuralIndependentStringParameters() =
            filterCollection(structuralIndependentParameters(), STRING_VARIABLE_FILTER);
    
    syn int FClass.numFinalIndependentParameters() = finalIndependentParameters().size();
    coll ArrayList<FVariable> FClass.finalIndependentParameters()
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isFinalIndependentParameter() && shouldContribute()
    to FClass.finalIndependentParameters() for myFClass();
    
    syn int FClass.numFinalIndependentRealParameters() = finalIndependentRealParameters().size();
    syn lazy Collection<FRealVariable> FClass.finalIndependentRealParameters() =
            filterCollection(finalIndependentParameters(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numFinalIndependentIntegerParameters() = finalIndependentIntegerParameters().size();
    syn lazy Collection<FIntegerVariable> FClass.finalIndependentIntegerParameters() =
            filterCollection(finalIndependentParameters(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numFinalIndependentEnumParameters() = finalIndependentEnumParameters().size();
    syn lazy Collection<FEnumVariable> FClass.finalIndependentEnumParameters() =
            filterCollection(finalIndependentParameters(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numFinalIndependentBooleanParameters() = finalIndependentBooleanParameters().size();
    syn lazy Collection<FBooleanVariable> FClass.finalIndependentBooleanParameters() =
            filterCollection(finalIndependentParameters(), BOOLEAN_VARIABLE_FILTER);
    
    syn int FClass.numFinalIndependentStringParameters() = finalIndependentStringParameters().size();
    syn lazy Collection<FStringVariable> FClass.finalIndependentStringParameters() =
            filterCollection(finalIndependentParameters(), STRING_VARIABLE_FILTER);
    
    syn int FClass.numEvalIndependentParameters() = evalIndependentParameters().size();
    coll ArrayList<FVariable> FClass.evalIndependentParameters()
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isEvalIndependentParameter() && shouldContribute()
    to FClass.evalIndependentParameters() for myFClass();
    
    syn int FClass.numEvalIndependentRealParameters() = evalIndependentRealParameters().size();
    syn lazy Collection<FRealVariable> FClass.evalIndependentRealParameters() =
            filterCollection(evalIndependentParameters(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numEvalIndependentIntegerParameters() = evalIndependentIntegerParameters().size();
    syn lazy Collection<FIntegerVariable> FClass.evalIndependentIntegerParameters() =
            filterCollection(evalIndependentParameters(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numEvalIndependentEnumParameters() = evalIndependentEnumParameters().size();
    syn lazy Collection<FEnumVariable> FClass.evalIndependentEnumParameters() =
            filterCollection(evalIndependentParameters(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numEvalIndependentBooleanParameters() = evalIndependentBooleanParameters().size();
    syn lazy Collection<FBooleanVariable> FClass.evalIndependentBooleanParameters() =
            filterCollection(evalIndependentParameters(), BOOLEAN_VARIABLE_FILTER);
    
    syn int FClass.numEvalIndependentStringParameters() = evalIndependentStringParameters().size();
    syn lazy Collection<FStringVariable> FClass.evalIndependentStringParameters() =
            filterCollection(evalIndependentParameters(), STRING_VARIABLE_FILTER);
    
    syn int FClass.numDependentParameters() = dependentParameters().size();
    coll ArrayList<FVariable> FClass.dependentParameters() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isDependentParameter() && shouldContribute()
    to FClass.dependentParameters() for myFClass();

    syn int FClass.numDependentRealParameters() = dependentRealParameters().size();
    syn lazy Collection<FRealVariable> FClass.dependentRealParameters() =
            filterCollection(dependentParameters(), REAL_VARIABLE_FILTER);

    syn int FClass.numDependentIntegerParameters() = dependentIntegerParameters().size();
    syn lazy Collection<FIntegerVariable> FClass.dependentIntegerParameters() =
            filterCollection(dependentParameters(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numDependentEnumParameters() = dependentEnumParameters().size();
    syn lazy Collection<FEnumVariable> FClass.dependentEnumParameters() =
            filterCollection(dependentParameters(), ENUM_VARIABLE_FILTER);
    
    syn int FClass.numDependentBooleanParameters() = dependentBooleanParameters().size();
    syn lazy Collection<FBooleanVariable> FClass.dependentBooleanParameters() =
            filterCollection(dependentParameters(), BOOLEAN_VARIABLE_FILTER);
    
    syn int FClass.numDependentStringParameters() = dependentStringParameters().size();
    syn lazy Collection<FStringVariable> FClass.dependentStringParameters() =
            filterCollection(dependentParameters(), STRING_VARIABLE_FILTER);

    syn int FClass.numDiscreteRealVariables() = discreteRealVariables().size();
    syn lazy Collection<FRealVariable> FClass.discreteRealVariables() =
            filterCollection(discreteVariables(), REAL_VARIABLE_FILTER);

    syn int FClass.numDiscreteIntegerVariables() = discreteIntegerVariables().size();
    syn lazy Collection<FIntegerVariable> FClass.discreteIntegerVariables() =
            filterCollection(discreteVariables(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numDiscreteEnumVariables() = discreteEnumVariables().size();
    syn lazy Collection<FEnumVariable> FClass.discreteEnumVariables() =
            filterCollection(discreteVariables(), ENUM_VARIABLE_FILTER);

    syn int FClass.numDiscreteBooleanVariables() = discreteBooleanVariables().size();
    syn lazy Collection<FBooleanVariable> FClass.discreteBooleanVariables() =
            filterCollection(discreteVariables(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numDiscreteStringVariables() = discreteStringVariables().size();
    syn lazy Collection<FStringVariable> FClass.discreteStringVariables() =
            filterCollection(discreteVariables(), STRING_VARIABLE_FILTER);
        
    syn int FClass.numDifferentiatedRealVariables() = differentiatedRealVariables().size();
    // The LinkedHashSet is used here to avoid duplicates.
    coll LinkedHashSet<FRealVariable> FClass.allDifferentiatedRealVariables() 
      [new LinkedHashSet<FRealVariable>()] with add root FClass;
    FDerExp contributes (FRealVariable) getFIdUse().myFV() when getFIdUse().myFV().isFVariable() && !inDeadIfBranch()
    to FClass.allDifferentiatedRealVariables() for myFClass();
    FDerivativeVariable contributes
        myDifferentiatedVariable() when (shouldContribute())
    to FClass.allDifferentiatedRealVariables() for myFClass();
    FDynamicDerivativeVariable contributes
        myDifferentiatedVariable() when (shouldContribute())
        to FClass.allDifferentiatedRealVariables() for myFClass();
    FDynamicStateVariable contributes this when (shouldContribute())
    to FClass.allDifferentiatedRealVariables() for myFClass();

    syn lazy ArrayList<FRealVariable> FClass.differentiatedRealVariablesList() {
        ArrayList<FRealVariable> l = new ArrayList<FRealVariable>();
        for (FRealVariable fv : differentiatedRealVariables()) 
            l.add(fv);
        return l;
    }
    syn int FVariable.differentiatedRealVariableIndex() =
        myFClass().differentiatedRealVariablesList().indexOf(this);

    syn lazy LinkedHashSet<FRealVariable> FClass.differentiatedRealVariables() {
        LinkedHashSet<FRealVariable> set = new LinkedHashSet<FRealVariable>(allDifferentiatedRealVariables());
        set.removeAll(dynamicStates());
        return set;
    }

    /**
     * Collection that contains all differentiated variables that has been
     * found to be dynamic states. All of these variables originates from
     * the original model.
     */
    coll LinkedHashSet<FRealVariable> FClass.dynamicStates()
      [new LinkedHashSet<FRealVariable>()] with add root FClass;
    FRealVariable contributes this when (isDynamicState())
      to FClass.dynamicStates() for myFClass();
    syn int FClass.numDynamicStates() = dynamicStates().size();

    /**
     * Collection that contains all dynamic state variables introduced by the
     * compiler. This collection differs from dynamicStates() in that it 
     * contains all the actual states.
     */
    coll LinkedHashSet<FDynamicStateVariable> FClass.dynamicStateVariables()
      [new LinkedHashSet<FDynamicStateVariable>()] with add root FClass;
    FDynamicStateVariable contributes this 
      to FClass.dynamicStateVariables() for myFClass();
    syn int FClass.numDynamicStateVariables() = dynamicStateVariables().size();

    /**
     * Collection that contains all dynamic algebraic variables introduced by the
     * compiler.
     */
    coll LinkedHashSet<FDynamicAlgebraicVariable> FClass.dynamicAlgebraicVariables()
    [new LinkedHashSet<FDynamicAlgebraicVariable>()] with add root FClass;
      FDynamicAlgebraicVariable contributes this 
    to FClass.dynamicAlgebraicVariables() for myFClass();
    syn int FClass.numDynamicAlgebraicVariables() = dynamicAlgebraicVariables().size();

    /**
     * Returns the same set as differentiatedRealVariablesSet, except derivatives with no
     * uses that were not introduced because of stateselect.
     */
    coll LinkedHashSet<FRealVariable> FClass.differentiatedRealVariablesFilteredSet() 
      [new LinkedHashSet<FRealVariable>()] with add root FClass;
    FDerExp contributes (FRealVariable) getFIdUse().myFV() when getFIdUse().myFV().isFVariable() && !inDeadIfBranch()
    to FClass.differentiatedRealVariablesFilteredSet() for myFClass();
    FDerivativeVariable contributes
        myDifferentiatedVariable() when (shouldContributeFiltered())
    to FClass.differentiatedRealVariablesFilteredSet() for myFClass();
    FDynamicStateVariable contributes this
    to FClass.differentiatedRealVariablesFilteredSet() for myFClass();
    
    /**
     * \brief Collection of all callables called by a partial function call
     * or kept as a component.
     */
    coll LinkedHashSet<FFunctionDecl> FClass.myFFunctionDeclsPartial() 
        [new LinkedHashSet<FFunctionDecl>()] with add root FClass;
    FPartialFunctionCall contributes myFCallable().actualFFunctionDecl() to FClass.myFFunctionDeclsPartial() for myFClass();
    FFunctionVariable contributes myFCallable().actualFFunctionDecl() when type().isFunction()
        to FClass.myFFunctionDeclsPartial() for myFClass();
    
    /**
     * \brief Collection of all FFunctionDecls called by a partial function call.
     */
    coll LinkedHashSet<FFunctionDecl> FClass.myFFunctionDeclsPartialCalled() 
        [new LinkedHashSet<FFunctionDecl>()] with add root FClass;
    FPartialFunctionCall contributes myFCallable().actualFFunctionDecl() to FClass.myFFunctionDeclsPartialCalled() for myFClass();

    coll ArrayList<FDelayExp> FClass.myDelayExps()
        [new ArrayList<FDelayExp>()] with add root FClass;
    FDelayExp contributes this to FClass.myDelayExps() for myFClass();
    
    syn lazy int FDelayExp.myDelayIndex() = myFClass().myDelayExps().indexOf(originalFExp());
    
    coll ArrayList<FSpatialDistExp> FClass.mySpatialDistExps()
        [new ArrayList<FSpatialDistExp>()] with add root FClass;
    FSpatialDistExp contributes this to FClass.mySpatialDistExps() for myFClass();
    
    syn lazy int FSpatialDistExp.mySpatialDistIndex() = myFClass().mySpatialDistExps().indexOf(originalFExp());
    
    
    inh boolean FExp.inDeadIfBranch();
    eq FIfEquation.getFAbstractEquation().inDeadIfBranch() = getTest().inDeadIfBranchTest(false);
    eq FIfEquation.getElse().inDeadIfBranch()              = getTest().inDeadIfBranchTest(true);
    eq FIfExp.getThenExp().inDeadIfBranch()                = getIfExp().inDeadIfBranchTest(false);
    eq FIfExp.getElseExp().inDeadIfBranch()                = getIfExp().inDeadIfBranchTest(true);
    eq FClass.getChild().inDeadIfBranch()                  = false;
    eq InstNode.getChild().inDeadIfBranch()                = false;

    syn boolean FExp.inDeadIfBranchTest(boolean deadValue) = 
        (isConstantExp() && ceval().booleanValue() == deadValue) || inDeadIfBranch();

    syn int FClass.numDerivativeVariables() = derivativeVariables().size();
    coll ArrayList<FDerivativeVariable> FClass.derivativeVariables() 
      [new ArrayList<FDerivativeVariable>()] with add root FClass;
    FDerivativeVariable contributes
        this when (shouldContribute())
    to FClass.derivativeVariables() for myFClass();
    
    syn int FClass.numVariables() = variables().size();
    coll ArrayList<FVariable> FClass.variables() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when !isParameter() && !isConstant() && !isPreVariable() && shouldContribute()
    to FClass.variables() for myFClass();

    syn int FClass.numDiscreteVariables() = discreteVariables().size();
    coll ArrayList<FVariable> FClass.discreteVariables() 
      [new ArrayList<FVariable>()] with add root FClass;
    FRealVariable contributes
        this when isDiscrete() && !isInput() && !isPreVariable() && shouldContribute()
    to FClass.discreteVariables() for myFClass();   
    FIntegerVariable contributes
        this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
    to FClass.discreteVariables() for myFClass();   
    FEnumVariable contributes
        this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
    to FClass.discreteVariables() for myFClass();   
    FBooleanVariable contributes
        this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
    to FClass.discreteVariables() for myFClass();   
    FStringVariable contributes
        this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
    to FClass.discreteVariables() for myFClass();   

    syn int FClass.numNonFixedParameters() = nonFixedParameters().size();
    coll ArrayList<FVariable> FClass.nonFixedParameters()
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes this when isNonFixedParameter() && shouldContribute()
    to FClass.nonFixedParameters() for myFClass();

    syn boolean FAbstractVariable.isNonFixedParameter() = false;
    eq FStringVariable.isNonFixedParameter()            = false;
    eq FVariable.isNonFixedParameter()                  = isParameter() && !fixedAttribute();
    
    syn boolean ASTNode.containsNonFixedParameter() {
        for (ASTNode child : this)
            if (child.containsNonFixedParameter())
                return true;
        return false;
    }
    eq FIdUseExp.containsNonFixedParameter() = getFIdUse().containsNonFixedParameter();
    
    syn boolean FIdUse.containsNonFixedParameter() = myFV().isNonFixedParameter();
    eq FIdUseInstAccess.containsNonFixedParameter() = !isCircular() && myInstComponentDecl().isNonFixedParameter();
    
    syn boolean InstComponentDecl.isNonFixedParameter() = false;
    eq InstAssignable.isNonFixedParameter() {
        if (!isParameter())
            return false;
        for (InstModification mod : totalMergedEnvironment()) {
            FExp exp = mod.findAttribute(FAttribute.FIXED);
            if (exp == null)
                continue;
            if (!exp.ceval().booleanValue())
                return true;
        }
        if (hasBindingFExp())
            return getBindingFExp().containsNonFixedParameter();
        return false;
    }
    

    syn boolean ASTNode.containsFTimeExp() {
        for (ASTNode child : this)
            if (child.containsFTimeExp())
                return true;
        return false;
    }
    eq FTimeExp.containsFTimeExp() = true;
    syn lazy boolean FAbstractEquation.containsFTimeExp() = super.containsFTimeExp();
    
    syn boolean ASTNode.containsFHomotopyExp() {
        for (ASTNode child : this)
            if (child.containsFHomotopyExp())
                return true;
        return false;
    }
    eq FHomotopyExp.containsFHomotopyExp() = true;
    syn lazy boolean FAbstractEquation.containsFHomotopyExp() = super.containsFHomotopyExp();
    public boolean AbstractEquationBlock.containsFHomotopyExp() {
        for (FAbstractEquation eqn : allEquations()) {
            if (eqn.containsFHomotopyExp()) {
                return true;
            }
        }
        return false;
    }
    
    syn int FClass.numDiscretePreVariables() = discretePreVariables().size();
    syn lazy ArrayList<FVariable> FClass.discretePreVariables() {
        ArrayList<FVariable> l = new ArrayList<FVariable>();
        for (FVariable fv : discreteVariables()) {
            l.add((FVariable) lookupFV(fv.getFQName().preName()));
        }
        for (FVariable fv : continuousVariablesUsedInPreInInitial()) {
            l.add((FVariable) lookupFV(fv.getFQName().preName()));
        }
        return l;
    }
    
    syn int FClass.numAliasVariables() = aliasVariables().size();
    coll ArrayList<FVariable> FClass.aliasVariables() 
      [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when  !isParameter() && !isConstant() && isAlias()
    to FClass.aliasVariables() for myFClass();

    syn int FClass.numAllVariables() = allVariables().size();
    syn lazy ArrayList<FVariable> FClass.allVariables() {
          ArrayList<FVariable> set = new ArrayList<FVariable>();
          for (FVariable fv : getFVariables()) {
                  set.add(fv);
              }
          for (FVariable fv : getAliasVariables()) {
                  set.add(fv);
              }
          return set;
    }

    syn int FClass.numTempVariables() = tempVariables().size();
    coll ArrayList<FVariable> FClass.tempVariables() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isTemporary() && shouldContribute()
    to FClass.tempVariables() for myFClass();

    syn int FClass.numRealVariables() = realVariables().size();
    syn lazy Collection<FRealVariable> FClass.realVariables() =
            filterCollection(variables(), REAL_VARIABLE_FILTER);

    syn int FClass.numIntegerVariables() = integerVariables().size();
    syn lazy Collection<FIntegerVariable> FClass.integerVariables() =
            filterCollection(variables(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numEnumVariables() = enumVariables().size();
    syn lazy Collection<FEnumVariable> FClass.enumVariables() =
            filterCollection(variables(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanVariables() = booleanVariables().size();
    syn lazy Collection<FBooleanVariable> FClass.booleanVariables() =
            filterCollection(variables(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringVariables() = stringVariables().size();
    syn lazy Collection<FStringVariable> FClass.stringVariables() =
            filterCollection(variables(), STRING_VARIABLE_FILTER);
    
    syn int FClass.numAlgebraicContinousRealVariables() = algebraicContinousRealVariables().size();
    syn lazy Collection<FRealVariable> FClass.algebraicContinousRealVariables() {
        Collection<FRealVariable> set = new LinkedHashSet<FRealVariable>(realVariables());
        set.removeAll(differentiatedRealVariables());
        set.removeAll(derivativeVariables());
        set.removeAll(discreteVariables());
        set.removeAll(inputs());
        return set;
    }

    syn int FClass.numNormalAlgebraicContinousRealVariables() = normalAlgebraicContinousRealVariables().size();
    syn lazy Collection<FRealVariable> FClass.normalAlgebraicContinousRealVariables() {
        Collection<FRealVariable> set = new LinkedHashSet<FRealVariable>(algebraicContinousRealVariables());
        set.removeAll(dynamicStates());
        return set;
    }

    syn lazy ArrayList<FVariable> FClass.algebraicVariables() {
        ArrayList<FVariable> set = new ArrayList<FVariable>();
        set.addAll(algebraicContinousRealVariables());
        set.addAll(discreteVariables());
        return set;
    }

    syn lazy Collection<FVariable> FClass.normalAlgebraicVariables() {
        Collection<FVariable> set = new LinkedHashSet<FVariable>(algebraicVariables());
        set.removeAll(dynamicStates());
        return set;
    }

    // There are no free parameters in the Modelica compiler
    // but these attributes are refined in the Optimica compiler
    syn int FClass.numFreeParameters() {
        return 0;
    }


    /*
    syn int FClass.numAlgebraicContinousRealVariables() = algebraicContinousRealVariables().size();
    syn lazy ArrayList<FVariable> FClass.algebraicContinousRealVariables() { 
      ArrayList<FVariable> set = new ArrayList<FVariable>();
      set.addAll(algebraicVariables());
      set.retainAll(reals());
      set.removeAll(discreteVariables());
      return set;
    }
    */
    
    /*
    syn int FClass.numAlgebraicIntegerVariables() = algebraicIntegerVariables().size();
    syn lazy ArrayList<FVariable> FClass.algebraicIntegerVariables() = 
      intersectFVColl(algebraicVariables(), integers());
    
    syn int FClass.numAlgebraicEnumVariables() = algebraicEnumVariables().size();
    syn lazy ArrayList<FVariable> FClass.algebraicEnumVariables() = 
      intersectFVColl(algebraicVariables(), enums());
    
    syn int FClass.numAlgebraicBooleanVariables() = algebraicBooleanVariables().size();
    syn lazy ArrayList<FVariable> FClass.algebraicBooleanVariables() = 
      intersectFVColl(algebraicVariables(), booleans());

    syn int FClass.numAlgebraicStringVariables() = algebraicStringVariables().size();
    syn lazy ArrayList<FVariable> FClass.algebraicStringVariables() = 
      intersectFVColl(algebraicVariables(), strings());
*/
    
    syn int FClass.numVariablesWithBindingExp() = variablesWithBindingExp().size();
    coll ArrayList<FVariable> FClass.variablesWithBindingExp() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes this when 
        !isParameter() && !isConstant() && hasBindingExp() && shouldContribute()
        to FClass.variablesWithBindingExp() for myFClass();

    syn int FClass.numRealVariablesWithBindingExp() = realVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.realVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), REAL_VARIABLE_FILTER);

    syn int FClass.numIntegerVariablesWithBindingExp() = integerVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.integerVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), INTEGER_VARIABLE_FILTER);

    syn int FClass.numEnumVariablesWithBindingExp() = enumVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.enumVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanVariablesWithBindingExp() = booleanVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.booleanVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringVariablesWithBindingExp() = stringVariablesWithBindingExp().size();
    syn lazy Collection<FVariable> FClass.stringVariablesWithBindingExp() =
            filterCollection(variablesWithBindingExp(), STRING_VARIABLE_FILTER);
     
    syn int FClass.numInputs() = inputs().size();
    coll ArrayList<FVariable> FClass.inputs() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isInput() && shouldContribute()
    to FClass.inputs() for myFClass();

    syn int FVariable.inputIndex() =
        myFClass().inputs().indexOf(this); // TODO: Ouch indexOf in arraylist :(

    syn int FClass.numRealInputs() = realInputs().size();
    syn lazy Collection<FVariable> FClass.realInputs() =
            filterCollection(inputs(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numIntegerInputs() = integerInputs().size();
    syn lazy Collection<FVariable> FClass.integerInputs() =
            filterCollection(inputs(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numEnumInputs() = enumInputs().size();
    syn lazy Collection<FVariable> FClass.enumInputs() =
            filterCollection(inputs(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanInputs() = booleanInputs().size();
    syn lazy Collection<FVariable> FClass.booleanInputs() =
            filterCollection(inputs(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringInputs() = stringInputs().size();
    syn lazy Collection<FVariable> FClass.stringInputs() =
            filterCollection(inputs(), STRING_VARIABLE_FILTER);

    syn int FClass.numOutputs() = outputs().size();
    coll ArrayList<FVariable> FClass.outputs() 
        [new ArrayList<FVariable>()] with add root FClass;
    FVariable contributes
        this when isOutput() && shouldContribute()
    to FClass.outputs() for myFClass();

    syn int FClass.numRealOutputs() = realOutputs().size();
    syn lazy Collection<FVariable> FClass.realOutputs() =
            filterCollection(outputs(), REAL_VARIABLE_FILTER);
    
    syn int FClass.numIntegerOutputs() = integerOutputs().size();
    syn lazy Collection<FVariable> FClass.integerOutputs() =
            filterCollection(outputs(), INTEGER_VARIABLE_FILTER);
    
    syn int FClass.numEnumOutputs() = enumOutputs().size();
    syn lazy Collection<FVariable> FClass.enumOutputs() =
            filterCollection(outputs(), ENUM_VARIABLE_FILTER);

    syn int FClass.numBooleanOutputs() = booleanOutputs().size();
    syn lazy Collection<FVariable> FClass.booleanOutputs() =
            filterCollection(outputs(), BOOLEAN_VARIABLE_FILTER);

    syn int FClass.numStringOutputs() = stringOutputs().size();
    syn lazy Collection<FVariable> FClass.stringOutputs() =
            filterCollection(outputs(), STRING_VARIABLE_FILTER);

    syn int FClass.numScalarEquations() {
       int res = 0;
       for (FAbstractEquation e : equations())
               res += e.numScalarEquations();
        for (FVariable fv : getFVariables())
            if (!fv.variability().parameterOrLess() && fv.hasBindingExp())
                res += fv.getBindingExp().type().numScalarElements();
       return res;
    }
    syn lazy int FClass.numScalarEquationsAtInitialization() {
        int res = 0;
        for (FAbstractEquation e : equations())
            res += e.numScalarEquations();
        return res;
    }

    syn int FClass.numEquations() = equations().size();
    syn lazy ArrayList<FAbstractEquation> FClass.equations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : getFAbstractEquations()) {
            if (!e.isIgnored()) {
                l.add(e);
            }
        }
        return l;
    }

    syn ArrayList<FAbstractEquation> FClass.allEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        l.addAll(equations());
        l.addAll(initialEquations());
        l.addAll(getFParameterEquations().toArrayList());
        return l;
    }

    coll ArrayList<FAlgorithm> FClass.algorithms() 
        [new ArrayList<FAlgorithm>()] with add root FClass;
    FAlgorithm contributes this when !inFunction()
        to FClass.algorithms() for myFClass();

    syn int FClass.numContinuousEquations() = continuousEquations().size();
    syn lazy ArrayList<FAbstractEquation> FClass.continuousEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : getFAbstractEquations()) {
            if (!e.isIgnored() && e.isContinuous()) {
                l.add(e);
            }
        }
        return l;
    }

    syn int FClass.numContinuousNonMetaEquations() = continuousNonMetaEquations().size();
    syn lazy ArrayList<FAbstractEquation> FClass.continuousNonMetaEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : continuousEquations()) {
            if (!e.isMetaEquation()) {
                l.add(e);
            }
        }
        return l;
    }

    syn int FClass.numScalarVariables() {
        int res = 0;
        for (FVariable fv : getFVariables())
            if (!fv.variability().parameterOrLess())
                res += fv.type().numScalarElements();
        return res;
    }

    syn int FType.numScalarElements() = size().numElements();
    eq FRecordType.numScalarElements() {
        int res = 0;
        for (FRecordComponentType c : getComponents())
            res += c.getFType().numScalarElements();
        return res * super.numScalarElements();
    }

    syn int FAbstractEquation.numScalarEquations() = 1;
    eq FEquation.numScalarEquations()           = getLeft().type().numScalarElements();
    eq FConnectClause.numScalarEquations()      = getConnector1().type().numScalarElements();
    eq FAlgorithm.numScalarEquations() {
        Set<FVariable> assignedVars = new HashSet<FVariable>();
        for (FIdUseExp use : FIdUseExpsInLHS()) {
            if (!use.myFV().isUnknown() && !assignedVars.contains(use.myFV())) {
                FVariable fv = (FVariable) use.myFV();
                assignedVars.add(fv);
            }
        }
        return assignedVars.size();

    }
    eq FIfWhenElseEquation.numScalarEquations() = numScalarEqnsInList(getFAbstractEquations());
    eq FForClauseE.numScalarEquations()         = 
        numScalarEqnsInList(getFAbstractEquations()) * numForElems(getFForIndexs());
    eq InstForClauseE.numScalarEquations()      = 
        numScalarEqnsInList(getFAbstractEquations()) * numForElems(getInstForIndexs());
    eq FFunctionCallEquation.numScalarEquations() {
        int res = 0;
        for (FFunctionCallLeft l : getLefts())
            res += l.numScalarElements();
        return res;
    }
    
    syn boolean FAbstractEquation.isMetaEquation() = numScalarEquations() == 0;
    
    syn int FFunctionCallLeft.numScalarElements() {
        int res = 0;
        if (hasFExp()) {
            for (FExp exp : flatChildFExps()) {
                res += exp.numScalarElements();
            }
        }
        return res;
    }
    
    syn int FExp.numScalarElements() = type().numScalarElements();
    eq FNoExp.numScalarElements() = 0;
    
    public Iterable<FExp> FFunctionCallLeft.flatChildFExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        getFExp().flatChildFExps(res);
        return res;
    }
    
    public void FExp.flatChildFExps(ArrayList<FExp> res) {
        res.add(this);
    }
    
    public void FArray.flatChildFExps(ArrayList<FExp> res) {
        for (FExp exp : getFExps()) {
            exp.flatChildFExps(res);
        }
    }
    
    public void FRecordConstructor.flatChildFExps(ArrayList<FExp> res) {
        for (FExp exp : getArgs()) {
            exp.flatChildFExps(res);
        }
    }
    
    

    protected static int FAbstractEquation.numForElems(List<? extends CommonForIndex> list) {
        int res = 1;
        for (CommonForIndex i : list)
            res *= i.size().numElements();
        return res;
    }

    protected static int FAbstractEquation.numScalarEqnsInList(List<FAbstractEquation> list) {
        int res = 0;
        for (FAbstractEquation e : list) 
            res += e.numScalarEquations();
        return res;
    }
    
    
    
    syn boolean FRelExp.isTimeEventGenerating() = myOptions().getBooleanOption("relational_time_events") && solutionForTime().isValidExp();
    eq FEqRelExp.isTimeEventGenerating() = false;
    syn boolean FDelayExp.isTimeEventGenerating() = getDelay().variability().parameterOrLess();
    
    protected int FExp.checkIndex(int i) {
        if (i < 0) {
            throw new UnsupportedOperationException("Unknown switch index for relational operator, not in list of switches.");
        }
        return i;
    }
    
    syn int FClass.numSwitches() = numStateSwitches() + numTimeSwitches();
    syn int FClass.numStateSwitches() = relExpsWithStateEvent().size() + numSpatialDistSwitches() + numDelaySwitches();
    syn int FClass.numTimeSwitches() = relExpsWithTimeEvent().size();
    
    syn int FClass.numEventIndicators() = numStateSwitches();
    
    syn lazy ArrayList<FExp> FClass.switchExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        res.addAll(stateEventExps());
        res.addAll(relExpsWithTimeEvent());
        return res;
    }
    
    syn lazy int FRelExp.mySwitchIndex()   = isTimeEventGenerating() ?
            checkIndex(myFClass().switchExps().indexOf(originalFExp())) + myFClass().delayExpsWithStateEvent().size() :
            myEventIndicatorIndex();
    syn int FDelayExp.mySwitchIndex() = myEventIndicatorIndex();
    
    syn lazy ArrayList<FExp> FClass.stateEventExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        res.addAll(relExpsWithStateEvent());
        res.addAll(spatialDistExpsWithStateEvent());
        res.addAll(delayExpsWithStateEvent());
        return res;
    }
    
    syn lazy int FRelExp.myEventIndicatorIndex()   = checkIndex(myFClass().stateEventExps().indexOf(originalFExp()));
    syn lazy int FSpatialDistExp.myEventIndicatorIndex() = checkIndex(myFClass().stateEventExps().indexOf(originalFExp()));
    syn lazy int FDelayExp.myEventIndicatorIndex() = myFClass().relExpsWithStateEvent().size() + myDelayEventIndicatorIndex();
    
    syn lazy ArrayList<FExp> FClass.timeEventExps() {
        ArrayList<FExp> res = new ArrayList<FExp>();
        res.addAll(sampleExpsWithTimeEvent());
        res.addAll(relExpsWithTimeEvent());
        return res;
    }
    
    coll ArrayList<FSampleExp> FClass.sampleExpsWithTimeEvent() 
        [new ArrayList<FSampleExp>()] with add root FClass;
    FSampleExp contributes this when generatesEventInDAE()
        to FClass.sampleExpsWithTimeEvent() for myFClass();
    
    syn int FClass.numSpatialDistSwitches() = spatialDistExpsWithStateEvent().size();
    coll ArrayList<FSpatialDistExp> FClass.spatialDistExpsWithStateEvent() 
        [new ArrayList<FSpatialDistExp>()] with add root FClass;
    FSpatialDistExp contributes this when generatesEventInDAE()
        to FClass.spatialDistExpsWithStateEvent() for myFClass();
    
    syn int FClass.numDelaySwitches() = 2*delayExpsWithStateEvent().size();
    coll ArrayList<FDelayExp> FClass.delayExpsWithStateEvent() 
        [new ArrayList<FDelayExp>()] with add root FClass;
    FDelayExp contributes this when generatesEventInDAE() && !isTimeEventGenerating()
        to FClass.delayExpsWithStateEvent() for myFClass();
    
    
    syn int FDelayExp.myDelayEventIndicatorIndex() = 2*checkIndex(myFClass().delayExpsWithStateEvent().indexOf(originalFExp()));
    
    
    syn int FClass.numGuardExpInEquations() = guardExpInEquations().size();
    syn int FClass.numGuardExpInInitialEquations() = guardExpInInitialEquations().size();
    syn int FExp.guardExpInEquationsIndex() = myFClass().guardExpInEquations().indexOf(this);
    syn int FExp.guardExpInInitialEquationsIndex() = myFClass().guardExpInInitialEquations().indexOf(this);

    coll ArrayList<FExp> FClass.guardExpInEquations() 
        [new ArrayList<FExp>()] with addAll root FlatRoot;
    FWhenEquation contributes getTest().guards() when getTest().inEquationSection()
        to FClass.guardExpInEquations() for myFClass();
    FWhenStmt contributes guards() when inEquationSection()
        to FClass.guardExpInEquations() for myFClass();

    coll ArrayList<FExp> FClass.guardExpInInitialEquations() 
        [new ArrayList<FExp>()] with addAll root FlatRoot;
    FWhenEquation contributes getTest().guards() when getTest().inInitialEquationSection()
        to FClass.guardExpInInitialEquations() for myFClass();
    FWhenStmt contributes guards() when inInitialEquationSection()
        to FClass.guardExpInInitialEquations() for myFClass(); 

    coll Set<FExp> FAbstractEquation.transformedGuards() [new HashSet<FExp>()] 
        with add root FAbstractEquation;
    FIfExp contributes getIfExp() when isWhen()
        to FAbstractEquation.transformedGuards() for myFEquation();
    FIfEquation contributes getTest() when isWhen()
        to FAbstractEquation.transformedGuards() for this;

    syn ArrayList<FExp> FWhenStmt.guards() {
        ArrayList<FExp> l = new ArrayList<FExp>();
        for (FIfWhenClause clause : getFIfWhenClauses()) {
            l.addAll(clause.getTest().guards());
        }
        return l;
    }

    syn ArrayList<FExp> FExp.guards() {
        ArrayList<FExp> l = new ArrayList<FExp>();
        l.add(this);
        return l;
    }
    eq FArray.guards() {
        ArrayList<FExp> l = new ArrayList<FExp>();
        for (FExp e : childFExps())
            l.add(e);
        return l;
    }

    syn int FSmoothExp.order() = getOrder().ceval().intValue(); 

    /**
     * Check if an expression will generate an event. Parameters with
     * fixed=false are considered to generate events.
     */
    syn boolean FExp.generatesEvent() = generatesEvent(true);

    /**
     * Check if an expression will generate an event.
     * 
     * @param checkNonFixedParameters  Controls whether parameters with fixed = false should be
     *                                 considered to generate events.
     */
    syn boolean FExp.generatesEvent(boolean checkNonFixedParameters) = generatesEvent(false, checkNonFixedParameters);

    /**
     * Check if an expression will generate an event.
     * 
     * @param ignoreVariability        Controles whether variability should be ignored.
     * @param checkNonFixedParameters  Controls whether parameters with fixed = false should be
     *                                 considered to generate events.
     */
    syn boolean FExp.generatesEvent(boolean ignoreVariability, boolean checkNonFixedParameters) =
            inEventGeneratingLocation() && hasEventGeneratingType() &&
            (ignoreVariability || hasEventGeneratingVariability(checkNonFixedParameters)) &&
            myOptions().getBooleanOption("generate_event_switches");

    /**
     * Check if an expression will generate an event.
     * Does not check context further than expressions.
     */
    syn boolean FExp.hasEventGeneratingVariability(boolean checkNonFixedParameters) =
            !variability().parameterOrLess() || (checkNonFixedParameters && containsNonFixedParameter());

    syn boolean FExp.inEventGeneratingLocation() = !inFunction() && !inNoEventExp() && !inSmoothExp(myOptions().getBooleanOption("disable_smooth_events") ? 0 : 1);

    syn boolean FExp.hasEventGeneratingType() = false;
    eq FRelExp.hasEventGeneratingType()       = isRealComparison();
    eq FEventGenExp.hasEventGeneratingType()  = argType().isReal();
    eq FSpatialDistExp.hasEventGeneratingType() = true;
    eq FDelayExp.hasEventGeneratingType()     = true;
    eq FSampleExp.hasEventGeneratingType()    = true;
    
    syn boolean FExp.generatesEventInDAE() = generatesEventInDAE(originalFExp());
    syn boolean FRelExp.generatesEventInInitDAE() = generatesEventInInitDAE(originalFExp());
    
    syn boolean FExp.generatesEventInDAE(FExp orig) = inEquationSection() && orig==this && generatesEvent(false);
    syn boolean FRelExp.generatesEventInInitDAE(FExp orig) =
            (inInitialEquationSection() || inEquationSection() && containsNonFixedParameter())
            && orig==this && generatesEvent(true);
    
    coll ArrayList<FRelExp> FClass.relExpsWithEvent() 
        [new ArrayList<FRelExp>()] with add root FClass;
    FRelExp contributes this when generatesEventInDAE() 
        to FClass.relExpsWithEvent() for myFClass();
    
    syn ArrayList<FRelExp> FClass.relExpsWithStateEvent() {
        ArrayList<FRelExp> res = new ArrayList<FRelExp>();
        for (FRelExp exp : relExpsWithEvent()) {
            if (!exp.isTimeEventGenerating()) {
                res.add(exp);
            }
        }
        return res;
    }
    
    syn ArrayList<FRelExp> FClass.relExpsWithTimeEvent() {
        ArrayList<FRelExp> res = new ArrayList<FRelExp>();
        for (FRelExp exp : relExpsWithEvent()) {
            if (exp.isTimeEventGenerating()) {
                res.add(exp);
            }
        }
        return res;
    }

    coll ArrayList<FRelExp> FAbstractEquation.relExpInEquation() 
        [new ArrayList<FRelExp>()] with add root FAbstractEquation;
    FRelExp contributes this when generatesEventInDAE(this)
    to FAbstractEquation.relExpInEquation() for myFEquation();

    coll ArrayList<FRelExp> FStatement.relExpInStmt() 
        [new ArrayList<FRelExp>()] with add root FStatement;
    FRelExp contributes this when generatesEventInDAE()
    to FStatement.relExpInStmt() for myFStatement();
    
    coll ArrayList<FDelayExp> FAbstractEquation.delayExpInEquation() 
        [new ArrayList<FDelayExp>()] with add root FAbstractEquation;
    FDelayExp contributes this when generatesEventInDAE()
    to FAbstractEquation.delayExpInEquation() for myFEquation();
    
    inh FStatement FExp.myFStatement();
    inh FStatement FStatement.myFStatement();
    inh FStatement FIfWhenClause.myFStatement();
    eq FStatement.getChild().myFStatement()        = this;
    eq FAbstractEquation.getChild().myFStatement() = null;
    eq Root.getChild().myFStatement()              = null;
    
    syn int FClass.numInitialEquations() = initialEquations().size(); 
    syn lazy int FClass.numInitialScalarEquations() {
        int res = 0;
        for (FAbstractEquation e : initialEquations())
            res += e.numScalarEquations();
        return res;
    }
    syn lazy ArrayList<FAbstractEquation> FClass.initialEquations() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        for (FAbstractEquation e : getFInitialEquations()) {
            l.add(e);
        }
        return l;
    }

    syn int FClass.numInitialGuessEquations() {
        int n_eq = 0;
        for (FRealVariable fv : realVariables()) {
            if (!(fv.fixedAttribute())) {
                n_eq++;
            }
        }
        return n_eq;
    }
    
    syn int FClass.numInitialEventIndicators() = numRelExpInInitialEquations();
    
    syn ArrayList<FRelExp> FClass.eventExpInInitialEquations() = relExpInInitialEquations();
    
    syn int FClass.numRelExpInInitialEquations() = relExpInInitialEquations().size();
    coll ArrayList<FRelExp> FClass.relExpInInitialEquations()
        [new ArrayList<FRelExp>()] with add root FClass;
    FRelExp contributes this when generatesEventInInitDAE()
    to FClass.relExpInInitialEquations() for myFClass();

    coll ArrayList<FRelExp> FAbstractEquation.relExpInInitialEquation() 
        [new ArrayList<FRelExp>()] with add root FAbstractEquation;
    FRelExp contributes this when generatesEventInInitDAE(this)
    to FAbstractEquation.relExpInInitialEquation() for myFEquation();
    
    syn int FRelExp.relExpInInitialEquationsIndex()  = checkIndex(myFClass().relExpInInitialEquations().indexOf(originalFExp()));
/*  

    coll ArrayList<FVariable> FClass.structuralParameters() [new ArrayList<FVariable>()] with add root FClass;
    FIdUseExp contributes
        (FVariable)myFV() when inArraySubscripts()
    to FClass.structuralParameters() for myFClass();

    coll ArrayList<FEquation> FVariable.variableIncidence() [new ArrayList<FEquation>()] with add root FClass;
    FIdUseExp contributes
        myFEquation() when inFEquation()
    to FVariable.variableIncidence() for (FVariable)myFV();
    
    syn lazy ArrayList<ArrayList> FClass.variableIncidence() {
        ArrayList<ArrayList> l = new ArrayList<ArrayList>();
        for (FVariable fv : variables()) {
           l.add(fv.variableIncidence());
       } 
        return l;
    
    }
    
    */
    
    inh Set<FVariable> FExp.boundParameters();
    eq FVariable.getBindingExp().boundParameters()       = Collections.singleton(this);
    eq Root.getChild().boundParameters()                 = Collections.emptySet();
    eq FEquation.getRight().boundParameters()            = boundParameters();
    eq FFunctionCallEquation.getCall().boundParameters() = boundParameters();

    syn Set<FVariable> FAbstractEquation.boundParameters() = Collections.emptySet();
    eq FEquation.boundParameters() {
        if (isParameterEquation()) {
            return getLeft().referencedParametersInFExp();
        } else {
            return Collections.emptySet();
        }
    }
    
    syn Set<FVariable> FAbstractEquation.RHSVariables() = Collections.emptySet();
    eq FEquation.RHSVariables() {
        if (isParameterEquation()) {
            return getRight().referencedParametersInFExp();
        } else {
            return Collections.emptySet();
        }
    }
        
    eq FFunctionCallEquation.boundParameters() { 
        if (isParameterEquation()) { 
            return referencedParametersInLHS(); 
        } else {
            return Collections.emptySet();
        }
    }
    
    syn Set<FVariable> FAbstractVariable.myParameterDependencies() = Collections.emptySet();
    syn lazy Set<FVariable> FVariable.myParameterDependencies() {
        HashSet<FVariable> varSet = new HashSet<FVariable>();
        if (hasParameterEquation()) {
            for (FVariable vv: parameterEquation().RHSVariables()) {
                varSet.addAll(vv.myParameterDependencies());
            }
            return varSet;
        } else { //Base case
            varSet.add(this);
            return varSet;
        }
    }
    
    inh boolean FExp.inFEquation();
    eq FAbstractEquation.getChild().inFEquation()=true;
    eq Root.getChild().inFEquation()=false;
    
    inh FAbstractEquation FExp.myFEquation();
    inh FAbstractEquation FStatement.myFEquation();
    eq FAbstractEquation.getChild().myFEquation() = this;
    eq Root.getChild().myFEquation()              = null;
    
    inh FClass FAbstractVariable.myFClass();
    inh FClass FExp.myFClass();
    inh FClass FIdUse.myFClass();
    inh FClass FQName.myFClass();
    inh FClass FFunctionDecl.myFClass();
    inh FClass FRecordDecl.myFClass();
    inh FClass FAlgorithm.myFClass();
    inh FClass FAbstractEquation.myFClass();
    inh FClass FStatement.myFClass();
    inh lazy FClass FExternalStmt.myFClass();
    eq FClass.getChild().myFClass() = this;
    eq Root.getChild().myFClass() = null; 
    
    public Iterable<FAbstractEquation> FExp.enclosingEquationsIterator() {
        return myFEquation().enclosingEquationsIterator();
    }

    public Iterable<FAbstractEquation> FStatement.enclosingEquationsIterator() {
        return myFEquation().enclosingEquationsIterator();
    }
    
    inh FAbstractEquation FAbstractEquation.enclosingEquation();
    eq FAbstractEquation.getChild().enclosingEquation() = this;
    eq Root.getChild().enclosingEquation()              = null;
    
    /**
     * Returns the outermost enclosing equation or the equation itself if it is
     * the outermost.
     */
    syn FAbstractEquation FAbstractEquation.outermostEnclosingEquation() {
        FAbstractEquation enclosing = this;
        FAbstractEquation next = enclosingEquation();
        while (next != null) {
            enclosing = next;
            next = enclosing.enclosingEquation();
        }
        return enclosing;
    }
    
    /**
     * Returns an iterable that can be used to iterate over all surounding
     * equations (including this one).
     */
    public Iterable<FAbstractEquation> FAbstractEquation.enclosingEquationsIterator() {
        return new Iterable<FAbstractEquation>() {

            @Override
            public Iterator<FAbstractEquation> iterator() {
                return new Iterator<FAbstractEquation>() {

                    private FAbstractEquation next = FAbstractEquation.this;
                    
                    @Override
                    public boolean hasNext() {
                        return next != null;
                    }

                    @Override
                    public FAbstractEquation next() {
                        FAbstractEquation res = next;
                        next = next.enclosingEquation();
                        return res;
                    }

                    @Override
                    public void remove() {
                        throw new UnsupportedOperationException();
                    }
                    
                };
            }
            
        };
    }
    
    syn lazy boolean FVariable.isIndependentConstant() = isConstant();
    syn lazy boolean FVariable.isDependentConstant() = false;
    
    syn boolean FAbstractVariable.isDependentParameter() = false;
    syn lazy boolean FVariable.isDependentParameter() = 
        isParameter() && !isIndependentParameter();
    
    syn boolean FAbstractVariable.isIndependentParameter() = false;
    syn lazy boolean FVariable.isIndependentParameter() =
            isParameter() && !isNonFixedParameter() && !hasParameterEquation() && 
            (!hasBindingExp() || getBindingExp().isIndependentParameterExp());
    
    syn lazy boolean FVariable.isRegularIndependentParameter() =
        isIndependentParameter() && !variability().knownParameterOrLess();
    syn lazy boolean FVariable.isStructuralIndependentParameter() =
        isIndependentParameter() && variability().knownParameterOrLess();
    syn lazy boolean FVariable.isFinalIndependentParameter() =
        false; // TODO
    syn lazy boolean FVariable.isEvalIndependentParameter() =
        false; // TODO

    syn boolean FExp.isIndependentParameterExp() = isConstantExp() && !hasCompositeFunc();
    
    inh boolean FAbstractEquation.isParameterEquation();
    eq FClass.getFParameterEquation().isParameterEquation() = true;
    eq Root.getChild().isParameterEquation() = false;
    
    coll ArrayList<FExp> FAbstractEquation.replacedAtInitialExps()
        [new ArrayList<FExp>()] with add root FAbstractEquation;
    FDelayExp contributes this
        to FAbstractEquation.replacedAtInitialExps() for myFEquation();
    FSpatialDistExp contributes this
        to FAbstractEquation.replacedAtInitialExps() for myFEquation();
    
    syn boolean FAbstractEquation.replacedAtInitialization() = 
            isWhen() || replacedAtInitialExps().size() > 0;
    eq FAlgorithm.replacedAtInitialization() {
        if (super.replacedAtInitialization())
            return true;
        
        /* 
         * Even if there are no when statements, there might still be discrete 
         * variables which are dependent on their pre() variables 
         */
        Set<FVariable> notDefSet = referencedFVariablesInLHS();
        notDefSet.removeAll(defSet());
        for (FVariable fv : notDefSet)
            if (fv.isDiscrete())
                return true;
        return false;
    }
    
    syn List<FAbstractEquation> FAbstractEquation.getInitialEquationList() {
        List<FAbstractEquation> l = new List<FAbstractEquation>();
        if (replacedAtInitialization()) {
            l.add((FAbstractEquation) copySymbolic());
        }
        return l;
    }
    
    eq FIfEquation.getInitialEquationList() {
        return createInitialEquationList();
    }
    
    syn List<FAbstractEquation> FIfWhenElseEquation.createInitialEquationList() {
        List<FAbstractEquation> l = new List<FAbstractEquation>();
        for (FAbstractEquation e : getFAbstractEquations()) {
            if (e.replacedAtInitialization()) {
                l.addAll(e.getInitialEquations());
            } else {
                l.add(e.copySymbolic());
            }
        }
        return l;
    }
    
    eq FIfWhenEquation.createInitialEquationList() {
        if (getTest().isInitialGuard())
            return super.createInitialEquationList();
        else if (hasElse())
            return getElse().createInitialEquationList();
        else
            return new List<FAbstractEquation>();
    }
    

    rewrite FIfExp {
        when (isWhen() && isInitial()) to FExp {
            if (getIfExp().isInitialGuard())
                return getThenExp();
            else
                return getElseExp();
        }
    }
    
    rewrite FDelayExp {
        when (isInitial()) to FExp {
            return getFExp().copySymbolic();
        }
    }
    
    rewrite FSpatialDistExp {
        when (isInitial() && !isFunctionCallClause()) to FExp {
            return createInitialReplacement(false);
        }
    }
    
    public FExp FSpatialDistExp.createInitialReplacement(boolean second) {
        int size = getInitialValues().getArray().length;
        return new FIfExp(getPositiveVelocity().copySymbolic(),
                getInitialValues().getArray().get(second ? size : 1).copySymbolic(), 
                getInitialValues().getArray().get(second ? 1 : size).copySymbolic());
    }
    
    eq FFunctionCallEquation.getInitialEquationList() {
        if (getCall() instanceof FSpatialDistExp) {
            FSpatialDistExp call = (FSpatialDistExp) getCall();
            ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
            if (getNumLeft() > 0 && getLeft(0).hasFExp()) {
                l.add(new FEquation(getLeft(0).getFExp().copySymbolic(), call.createInitialReplacement(false)));
            }
            if (getNumLeft() > 1 && getLeft(1).hasFExp()) {
                l.add(new FEquation(getLeft(1).getFExp().copySymbolic(), call.createInitialReplacement(true)));
            }
            return new List<FAbstractEquation>(l);
        }
        return super.getInitialEquationList();
    }
    
    eq FAlgorithm.getInitialEquationList() {
        ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
        
        // Keeps fiduseexps in lhs which have not been removed
        Set<FIdUseExp> usesLHS = FIdUseExpsInLHS();
        
        // Keeps track of which variables are definetly set
        Set<FVariable> fvSet  = new HashSet<FVariable>();
        Set<FVariable> fvUse  = new HashSet<FVariable>();
        
        // Create a new algorithm with some statements removed
        ArrayList<FStatement> stmts = new ArrayList<FStatement>();
        for (FStatement stmt : getFStatements()) {
            stmt.addAsInitial(stmts, usesLHS, fvSet, fvUse);
        }
        
        Set<FVariable> lhs = lookupFVariablesInSet(usesLHS);

        // Add initial statements for variables which are not definetly set
        // in the new algorithm
        ArrayList<FStatement> initStmts = new ArrayList<FStatement>();
        for (FVariable fv : lhs)
            if (!fvSet.contains(fv))
                initStmts.add(new FAssignStmt(fv.createUseExp(), fv.createAlgorithmArgument(true)));
        for (FStatement stmt : stmts)
            initStmts.add(stmt);
        if (initStmts.size() > 0)
            l.add(new FAlgorithm(new List<FStatement>(initStmts)));
        
        // Create equations for variables which are no longer assigned 
        // in the new algorithm
        Set<FVariable> removedFVs = referencedFVariablesInLHS();
        removedFVs.removeAll(lhs);
        for (FVariable fv : removedFVs)
            l.add(new FEquation(fv.createUseExp(), fv.createFPreExp()));
        
        return new List<FAbstractEquation>(l);
    }
    
    
    public void FStatement.addAsInitial(ArrayList<FStatement> stmts, Set<FIdUseExp> usesLHS, 
            Set<FVariable> fvSet, Set<FVariable> fvUse) {
        
        defSet(fvSet, fvUse);
        stmts.add(copySymbolic());
    }
    public void FIfStmt.addAsInitial(ArrayList<FStatement> stmts, Set<FIdUseExp> usesLHS, 
            Set<FVariable> fvSet, Set<FVariable> fvUse) {
        
        if (!isWhen()) {
            super.addAsInitial(stmts, usesLHS, fvSet, fvUse);
            return;
        }
        
        boolean first = true;
        for (FIfWhenClause c : getFIfWhenClauses()) {
            if (c.getTest().isInitialGuard() && first) {
                for (FStatement s : c.getFStatements()) {
                    s.defSet(fvSet, fvUse);
                    stmts.add(s.copySymbolic());
                }
                first = false;
            } else {
                usesLHS.removeAll(c.findFIdUseExpsInTree());
            }
        }
    }
    
    syn boolean FExp.isInitialGuard() = false;
    eq FInitialExp.isInitialGuard() = true;
    eq FOrExp.isInitialGuard() = getLeft().isInitialGuard() || getRight().isInitialGuard();
            
    /**
     * Find LHS variables which are definetly assigned to before any use.
     */
    public Set<FVariable> FAlgorithm.defSet() {
        HashSet<FVariable> fvSet = new HashSet<FVariable>();
        HashSet<FVariable> fvUse = new HashSet<FVariable>();
        for (FStatement stmt : getFStatements()) {
            stmt.defSet(fvSet, fvUse);
        }
        return fvSet;
    }
    public void FStatement.defSetAdd(Set<FVariable> s1, Set<FVariable> s2, Collection<FVariable> fvs) {
        for (FVariable fv : fvs)
            if (!s1.contains(fv))
                s2.add(fv);
    }
    public void FStatement.defSet(Set<FVariable> fvSet, Set<FVariable> fvUse) {
        defSetAdd(fvSet, fvUse, lookupFVariablesInSet(FIdUseExpsInRHS()));
    }
    public void FAssignStmt.defSet(Set<FVariable> fvSet, Set<FVariable> fvUse) {
        defSetAdd(fvSet, fvUse, lookupFVariablesInSet(getRight().findFIdUseExpsInTree()));
        defSetAdd(fvUse, fvSet, lookupFVariablesInSet(getLeft().findFIdUseExpsInTree()));
    }
    public void FFunctionCallStmt.defSet(Set<FVariable> fvSet, Set<FVariable> fvUse) {
        defSetAdd(fvSet, fvUse, lookupFVariablesInSet(getCall().findFIdUseExpsInTree()));
        for (FFunctionCallLeft left : getLefts())
            if (left.hasFExp())
                defSetAdd(fvUse, fvSet, lookupFVariablesInSet(left.getFExp().findFIdUseExpsInTree()));
    }
    
    /**
     * Check if tree contains a function call returning an array or a record.
     */
    syn boolean ASTNode.hasCompositeFunc() {
        for (ASTNode n : this)
            if (n.hasCompositeFunc())
                return true;
        return false;
    }
    eq InstFunctionCall.hasCompositeFunc() = 
        type().isArray() || type().isRecord() || super.hasCompositeFunc();
    eq FFunctionCall.hasCompositeFunc()    = 
        type().isArray() || type().isRecord() || super.hasCompositeFunc();
    
    syn boolean FVariable.hasParamValueExp() = hasBindingExp() || startAttributeSet();
    syn FExp FVariable.paramValueExp() = hasBindingExp() ? getBindingExp() : startAttributeExp();
    
    syn boolean FVariable.isVariable() = !isParameter() && !isConstant();
    
    syn boolean FAbstractVariable.isFVariable() = false;
    eq FVariable.isFVariable()                  = true;

    syn boolean FAbstractVariable.isFFunctionVariable() = false;
    eq FFunctionVariable.isFFunctionVariable()          = true;

    syn boolean FAbstractVariable.isDifferentiatedVariable() = false;
    syn lazy boolean FVariable.isDifferentiatedVariable() = 
      myFClass().differentiatedRealVariables().contains(this);
    syn boolean FDynamicStateVariable.isDifferentiatedVariable() = true;

    syn boolean FAbstractVariable.isAbstractDerivativeVariable() = false;
    eq FAbstractDerivativeVariable.isAbstractDerivativeVariable() = true;

    syn boolean FAbstractVariable.isDerivativeVariable() = false;
    eq FDerivativeVariable.isDerivativeVariable() = true;

    syn FVariable FAbstractVariable.asFVariable() {
        throw new UnsupportedOperationException("asFVariable() is not supported for class type " + getClass().getSimpleName());
    }
    eq FVariable.asFVariable() = this;

    syn FDerivativeVariable FAbstractVariable.asDerivativeVariable() {
        throw new UnsupportedOperationException("isDerivativeVariable() is not supported for class type " + getClass().getSimpleName());
    }
    eq FDerivativeVariable.asDerivativeVariable() = this;

    syn boolean FAbstractVariable.isDummyDerivativeVariable() = false;
    eq FDummyDerivativeVariable.isDummyDerivativeVariable() = true;

    syn boolean FAbstractVariable.isDynamicDerivativeVariable() = false;
    eq FDynamicDerivativeVariable.isDynamicDerivativeVariable() = true;
    
    syn boolean FAbstractVariable.isPreVariable() = false;
    eq FPreRealVariable.isPreVariable() = true;
    eq FPreIntegerVariable.isPreVariable() = true;
    eq FPreBooleanVariable.isPreVariable() = true;
    eq FPreStringVariable.isPreVariable() = true;
    eq FPreEnumVariable.isPreVariable() = true;
    
    syn boolean FAbstractVariable.isAlgebraicVariable() = false;
    syn lazy boolean FVariable.isAlgebraicVariable()    = myFClass().algebraicVariables().contains(this);

    syn boolean FAbstractVariable.isDiscreteVariable() = false;
    syn lazy boolean FVariable.isDiscreteVariable()    = myFClass().discreteVariables().contains(this);

    syn boolean FAbstractVariable.isAlgebraicContinousRealVariable() = false;
    syn lazy boolean FVariable.isAlgebraicContinousRealVariable()    =
            myFClass().algebraicContinousRealVariables().contains(this);

    syn lazy String FClass.guid() {
        try {
            PipedInputStream in = new PipedInputStream();
            PipedOutputStream out = new PipedOutputStream(in);
            
            MessageDigest md5 = MessageDigest.getInstance("MD5");
            new StreamGobbler(in).start();
            prettyPrint(new CodeStream(new DigestOutputStream(out, md5)), "");
            out.close();
            
            return new BigInteger(1,md5.digest()).toString(16);
            
        } catch (IOException e) {
            throw new RuntimeException(e);
        } catch (NoSuchAlgorithmException e) {
            throw new RuntimeException(e);
        }
    }
    
    private FAbstractEquation FAbstractEquation.meDifferentiated = null;
    private FAbstractEquation FAbstractEquation.meIntegrated = null;
    private FVariable FVariable.meDifferentiated = null;
    private FVariable FVariable.meIntegrated = null;
    
    public void FAbstractEquation.setMeDifferentiated(FAbstractEquation e) {
        this.meDifferentiated = e;
    }
    
    public FAbstractEquation FAbstractEquation.getMeDifferentiated() {
        return this.meDifferentiated;
    }
    
    public void FVariable.setMeDifferentiated(FVariable var) {
        this.meDifferentiated = var;
    }
    
    public FVariable FVariable.getMeDifferentiated() {
        return this.meDifferentiated;
    }
    
    public void FAbstractEquation.setMeIntegrated(FAbstractEquation e) {
        this.meIntegrated = e;
    }
    
    public FAbstractEquation FAbstractEquation.getMeIntegrated() {
        return this.meIntegrated;
    }
    
    public void FVariable.setMeIntegrated(FVariable var) {
        this.meIntegrated = var;
    }
    
    public FVariable FVariable.getMeIntegrated() {
        return this.meIntegrated;
    }
    
    public FVariable FVariable.getTopIntegrated() {
        FVariable fv = this;
        while (fv.meIntegrated != null)
            fv = fv.meIntegrated;
        return fv;
    }
    
}

aspect ReferencedVariables {
    
    public interface FIdUseExpLookupVisitor {
        public void visit(ASTNode<? extends ASTNode> node, Set<FIdUseExp> set);
    }
    
    public class DefaultFidUseExpLookupVisitor implements FIdUseExpLookupVisitor {
        public static final FIdUseExpLookupVisitor instance = new DefaultFidUseExpLookupVisitor();
        
        @Override
        public void visit(ASTNode<? extends ASTNode> node, Set<FIdUseExp> set) {
            node.findFIdUseExpsInTree(set, this);
        }
    }
    
    public Set<FIdUseExp> ASTNode.findFIdUseExpsInTree() {
        return findFIdUseExpsInTree(DefaultFidUseExpLookupVisitor.instance);
    }
    
    public Set<FIdUseExp> ASTNode.findFIdUseExpsInTree(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> set = new LinkedHashSet<FIdUseExp>();
        visitor.visit(this, set);
        return set;
    }
    
    public void ASTNode.findFIdUseExpsInTree(Set<FIdUseExp> set, FIdUseExpLookupVisitor visitor) {
        for (ASTNode n : this) {
            visitor.visit(n, set);
        }
    }
    
    @Override
    public void FIdUseExp.findFIdUseExpsInTree(Set<FIdUseExp> set, FIdUseExpLookupVisitor visitor) {
        set.add(this);
        super.findFIdUseExpsInTree(set, visitor);
    }
    
    @Override
    public void FAttribute.findFIdUseExpsInTree(Set<FIdUseExp> set, FIdUseExpLookupVisitor visitor) {
    }

    syn Set<FIdUseExp> FAbstractEquation.FIdUseExpsInRHS() = FIdUseExpsInRHS(DefaultFidUseExpLookupVisitor.instance);

    syn Set<FIdUseExp> FAbstractEquation.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor) = Collections.emptySet();
    eq FEquation.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor)                         = getRight().findFIdUseExpsInTree(visitor);
    eq FFunctionCallEquation.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor)             = getCall().findFIdUseExpsInTree(visitor);
    eq FAlgorithm.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        for (FStatement stmt : getFStatements())
            res.addAll(stmt.FIdUseExpsInRHS(visitor));
        return res;
    }

    syn Set<FIdUseExp> FStatement.FIdUseExpsInRHS() = FIdUseExpsInRHS(DefaultFidUseExpLookupVisitor.instance);

    syn Set<FIdUseExp> FStatement.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        for (FIdUseExp use : findFIdUseExpsInTree(visitor))
            if (!use.useIsAssignment() && !use.myFV().isForIndex())
                res.add(use);
        res.removeAll(FIdUseExpsInLHS(visitor));
        return res;
    }
    
    eq FIfWhenElseEquation.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        for (FAbstractEquation fae : getFAbstractEquations())
            res.addAll(fae.FIdUseExpsInRHS(visitor));
        return res;
    }
    
    eq FIfWhenEquation.FIdUseExpsInRHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = super.FIdUseExpsInRHS(visitor);
        getTest().findFIdUseExpsInTree(res, visitor);
        if (hasElse())
            res.addAll(getElse().FIdUseExpsInRHS(visitor));
        return res;
    }
    
    syn Set<FIdUseExp> FAbstractEquation.FIdUseExpsInLHS() = FIdUseExpsInLHS(DefaultFidUseExpLookupVisitor.instance);
    
    syn Set<FIdUseExp> FAbstractEquation.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor) = Collections.emptySet();
    eq FEquation.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor)                         = getLeft().findFIdUseExpsInTree(visitor);
    eq FFunctionCallEquation.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor)             = getLefts().findFIdUseExpsInTree(visitor);
    eq FAlgorithm.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        for (FStatement stmt : getFStatements())
            res.addAll(stmt.FIdUseExpsInLHS(visitor));
        return res;
    }
    
    syn Set<FIdUseExp> FStatement.FIdUseExpsInLHS() = FIdUseExpsInLHS(DefaultFidUseExpLookupVisitor.instance);
    
    syn Set<FIdUseExp> FStatement.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        for (FIdUseExp use : findFIdUseExpsInTree(visitor))
            if (use.useIsAssignment() && !use.myFV().isForIndex())
                res.add(use);
        return res;
    }
    
    eq FIfWhenElseEquation.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        for (FAbstractEquation fae : getFAbstractEquations())
            res.addAll(fae.FIdUseExpsInLHS(visitor));
        return res;
    }
    
    eq FIfWhenEquation.FIdUseExpsInLHS(FIdUseExpLookupVisitor visitor) {
        Set<FIdUseExp> res = super.FIdUseExpsInLHS(visitor);
        if (hasElse())
            res.addAll(getElse().FIdUseExpsInLHS(visitor));
        return res;
    }
    
    syn ArrayList<FIdUseExp> FAbstractEquation.uniqueFIdUseExpsInLHS() {
        ArrayList<FIdUseExp>   res   = new ArrayList<FIdUseExp>();
        Set<FAbstractVariable> visit = new LinkedHashSet<FAbstractVariable>();
        for (FIdUseExp e : FIdUseExpsInLHS()) {
            FAbstractVariable fv = e.myFV();
            if (!visit.contains(fv)) {
                visit.add(fv);
                res.add(e);
            }
        }
        return res;
    }

    syn lazy Set<FIdUseExp> FAbstractEquation.referencedFIdUseExps() {
        Set<FIdUseExp> res = new LinkedHashSet<FIdUseExp>();
        res.addAll(FIdUseExpsInRHS());
        res.addAll(FIdUseExpsInLHS());
        return res;
    }

    public static Set<FVariable> ASTNode.lookupFVariablesInSet(Set<FIdUseExp> set) {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FIdUseExp use : set)
            if (use.myFV() instanceof FVariable)
                res.add((FVariable) use.myFV());
        return res;
    }

    syn Set<FVariable> FAbstractEquation.referencedFVariablesInRHS() = lookupFVariablesInSet(FIdUseExpsInRHS());
    syn Set<FVariable> FAbstractEquation.referencedFVariablesInLHS() = lookupFVariablesInSet(FIdUseExpsInLHS());
    syn Set<FVariable> FExp.referencedFVariablesInFExp()             = lookupFVariablesInSet(findFIdUseExpsInTree());
    syn Set<FVariable> FVariable.referencedFVariablesInBindingExp()  = lookupFVariablesInSet(getBindingExp().findFIdUseExpsInTree());
    syn lazy Set<FVariable> FAbstractEquation.referencedFVariables() = lookupFVariablesInSet(referencedFIdUseExps());

    public static Set<FVariable> ASTNode.parametersInSet(Set<? extends FVariable> set) {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FVariable fv : set)
            if (fv.isParameter())
                res.add(fv);
        return res;
    }
    
    syn Set<FVariable> FFunctionCallEquation.referencedParametersInLHS() = parametersInSet(referencedFVariablesInLHS());
    syn Set<FVariable> FExp.referencedParametersInFExp()                 = parametersInSet(referencedFVariablesInFExp());

    syn boolean FAbstractEquation.assignedInAllBranches(FAbstractVariable var) = true;
    eq FEquation.assignedInAllBranches(FAbstractVariable var) = assignedInAllBranchesVariables().contains(var.name());

    syn lazy Set<String> FEquation.assignedInAllBranchesVariables() {
        Set<String> res = new HashSet<String>();
        getLeft().assignedInAllBranchesVariables(res);
        getRight().assignedInAllBranchesVariables(res);
        return res;
    }

    public final Set<String> FExp.assignedInAllBranchesVariables() {
        Set<String> res = new HashSet<String>();
        assignedInAllBranchesVariables(res);
        return res;
    }

    public void FExp.assignedInAllBranchesVariables(Set<String> res) {
        for (FExp exp : childFExps())
            exp.assignedInAllBranchesVariables(res);
    }

    @Override
    public void FIdUseExp.assignedInAllBranchesVariables(Set<String> res) {
        res.add(name());
    }

    @Override
    public void FIfExp.assignedInAllBranchesVariables(Set<String> res) {
        getIfExp().assignedInAllBranchesVariables(res);
        Set<String> a = getThenExp().assignedInAllBranchesVariables();
        Set<String> b = getElseExp().assignedInAllBranchesVariables();
        if (a.size() > b.size()) {
            Set<String> tmp = a;
            a = b;
            b = tmp;
        }
        for (String name : a) {
            if (b.contains(name)) {
                res.add(name);
            }
        }
    }
}


aspect FlatEnumerations {
    
    public ArrayList<FEnumLiteral> FEnumDecl.enumLiterals() {
        return getFEnumSpecification().enumLiterals();
    }

    public ArrayList<FEnumLiteral> FEnumSpecification.enumLiterals() {
        return new ArrayList<FEnumLiteral>();
    }

    public ArrayList<FEnumLiteral> FEnumLiteralList.enumLiterals() {
        ArrayList<FEnumLiteral> l = new ArrayList<FEnumLiteral>();
        for (FEnumLiteral el : getFEnumLiterals()) {
            l.add(el);
        }
        return l;
    }
    
    /**
     * The number of enumeration literals defined in the enumeration this variable is of.
     */
    syn int FEnumVariable.numEnumLiterals() = myFEnumDecl().numEnumLiterals();
    
    /**
     * The number of enumeration literals defined in this enumeration.
     */
    syn int FEnumDecl.numEnumLiterals() = getFEnumSpecification().numEnumLiterals();
    
    /**
     * The number of enumeration literals defined in this enumeration.
     */
    syn int FEnumSpecification.numEnumLiterals() = 0;
    eq FEnumLiteralList.numEnumLiterals() = getNumFEnumLiteral();
    
}

aspect FlatCausality {

    syn boolean FTypePrefixInputOutput.inputCausality() = false;
    eq FInput.inputCausality() = true;  
    syn boolean FTypePrefixInputOutput.outputCausality() = false;
    eq FOutput.outputCausality() = true;    
    
    syn boolean FAbstractVariable.isInput() = false;
    eq FVariable.isInput() = 
      hasFTypePrefixInputOutput()? getFTypePrefixInputOutput().inputCausality(): false;    
    syn boolean FAbstractVariable.isOutput() = false;
    eq FVariable.isOutput() = 
      hasFTypePrefixInputOutput()? getFTypePrefixInputOutput().outputCausality(): false;
      
}

aspect FlatTypes {

    syn boolean FAbstractVariable.isReal()              = type().isReal();
    syn boolean FAbstractVariable.isInteger()           = type().isInteger();
    syn boolean FAbstractVariable.isBoolean()           = type().isBoolean();
    syn boolean FAbstractVariable.isString()            = type().isString();
    syn boolean FAbstractVariable.isRecord()            = type().isRecord();
    syn boolean FAbstractVariable.isEnum()              = type().isEnum();
    syn boolean FAbstractVariable.isExternalObject()    = type().isExternalObject();
    
    syn boolean FExp.isComposite()              = isArray() || type().isRecord();
    syn boolean FType.isComposite()             = isArray() || isRecord();
    syn boolean FAbstractVariable.isComposite() = isArray() || isRecord();
    syn boolean InstComponentDecl.isComposite() = isArray() || isRecord();
    
    inh boolean FAbstractVariable.inRecord();
    eq FRecordDecl.getChild().inRecord() = true;
    eq FClass.getChild().inRecord()      = false;
    eq FForIndex.getChild().inRecord()   = false;

    inh boolean InstComponentDecl.inRecord();
    inh boolean InstExtends.inRecord();
    eq InstNode.getInstComponentDecl().inRecord()               = false;
    eq Root.getChild().inRecord()                               = false;
    eq InstForIndex.getInstPrimitive().inRecord()               = false;
    eq InstRecord.getInstComponentDecl().inRecord()             = true;
    eq InstRecord.getInstExtends().inRecord()                   = true;
//    eq InstRecordConstructor.getInstComponentDecl().inRecord()  = true;
    eq InstArrayComponentDecl.getInstComponentDecl().inRecord() = inRecord();
    eq InstExtends.getInstComponentDecl().inRecord()            = inRecord();

    inh boolean InstComponentDecl.inRecordDecl();
    eq InstNode.getChild().inRecordDecl()                     = false;
    eq InstAssignable.getChild().inRecordDecl()               = inRecordDecl();
    eq InstRecord.getInstComponentDecl().inRecordDecl()       = false;
    eq InstRecord.getInstExtends().inRecordDecl()             = false;
    eq InstRecord.getInstClassDecl().inRecordDecl()           = false;
    eq InstRecord.getRedeclaredInstClassDecl().inRecordDecl() = false;
    eq InstRecord.getElementInstModification().inRecordDecl() = false;
    eq InstForIndex.getInstPrimitive().inRecordDecl()         = false;
    eq InstClassDecl.getInstComponentDecl().inRecordDecl()    = isRecord();
    eq FClass.getChild().inRecordDecl()                       = false;
    eq FRecordDecl.getChild().inRecordDecl()                  = true;

    inh boolean InstComponentDecl.inRecordConstructor();
    eq InstRecordConstructor.getInstComponentDecl().inRecordConstructor() = true;
    eq InstNode.getChild().inRecordConstructor()                          = false;

    syn int FRecordDecl.indexOf(String name) {
        for (int i = 0; i < getNumFVariable(); i++)
            if (getFVariable(i).name().equals(name))
                return i;
        return -1;
    }
    
    syn int FRecordDecl.indexOfArg(String name) {
        int k = 0;
        for (int i = 0; i < getNumFVariable(); i++) {
            if (getFVariable(i).modifiableInRecord) {
                if (getFVariable(i).name().equals(name))
                    return k;
                k++;
            }
        }
        return -1;
    }
    
    syn FExp FRecordDecl.extractArg(FRecordConstructor frc, String name) {
        return frc.getArg(indexOf(name));
    }
    
    syn FExp FRecordConstructor.myArgFExp(String name) {
        return getRecord().myFRecordDecl().extractArg(this, name);
    }
    
    inh FRecordDecl FExp.containingRecordDecl();
    inh FRecordDecl FAbstractVariable.containingRecordDecl();
    eq FRecordDecl.getChild().containingRecordDecl() = this;
    eq Root.getChild().containingRecordDecl()        = null;

}

/**
 * Evaluation of attriubtes for primitive types.
 */
aspect Attributes {
    
    public static final String FAttribute.QUANTITY     = "quantity";
    public static final String FAttribute.UNIT         = "unit";
    public static final String FAttribute.DISPLAY_UNIT = "displayUnit";
    public static final String FAttribute.MIN          = "min";
    public static final String FAttribute.MAX          = "max";
    public static final String FAttribute.START        = "start";
    public static final String FAttribute.FIXED        = "fixed";
    public static final String FAttribute.NOMINAL      = "nominal";
    public static final String FAttribute.STATE_SELECT = "stateSelect";
    public static final String FAttribute.SIZE         = "size()";

    public static final String FAttribute.STATE_SELECT_TYPE = "StateSelect";

    syn lazy FDerivedType FVariable.myFDerivedType() = findFDerivedType(getDerivedType());
    syn FDerivedType FEnumDecl.myFDerivedType()      = findFDerivedType(name());
    eq FRecordVariable.myFDerivedType()              = null;
    
    inh FDerivedType FVariable.findFDerivedType(String name);
    inh FDerivedType FEnumDecl.findFDerivedType(String name);
    eq FClass.getChild().findFDerivedType(String name) = findMatching(getFDerivedTypes(), name);
    eq Root.getChild().findFDerivedType(String name)   = null;
    
    eq FAttribute.matches(String str)   = getName().name().equals(str);
    eq FDerivedType.matches(String str) = getName().equals(str);
    
    syn FAttribute FVariable.findAttributeLocal(String name) = findMatching(getFAttributes(), name);
    
    syn lazy FAttribute FVariable.findAttribute(String name) {
        FAttribute res = findAttributeLocal(name);
        if (res == null && myFDerivedType() != null)
            res = myFDerivedType().findAttribute(name);
        return res;
    }
    syn FAttribute FAttribute.findAttribute(String name)        = findMatching(getFAttributes(), name);
    syn FAttribute FDerivedType.findAttribute(String name)      = findMatching(getFAttributes(), name);
    syn FAttribute FAbstractEquation.findAttribute(String name) = findMatching(getFAttributes(), name);
    syn FAttribute FFunctionDecl.findAttribute(String name)     = findMatching(getFAttributes(), name);
    syn boolean FVariable.attributeSet(FAttribute a)   = (a != null) && a.getAttributeSet();
    syn FExp    FVariable.attributeExp(FAttribute a)   = (a != null && a.hasValue()) ? a.getValue() : null;
    syn boolean FVariable.attributeSet(String name)    = attributeSet(findAttribute(name));
    syn FExp    FVariable.attributeExp(String name)    = attributeExp(findAttribute(name));
    syn String  FVariable.attributeString(String name) = attributeCValueString(name).stringValue();
    
    syn FAttribute FAbstractVariable.findHierarchicalAttribute(FQName name) = null;
    eq FVariable.findHierarchicalAttribute(FQName name) = name.findHierarchicalAttribute(getFQName(), this);
    
    syn FAttribute FQName.findHierarchicalAttribute(FQName prefix, FVariable var) = null;
    eq FQNameString.findHierarchicalAttribute(FQName prefix, FVariable var)       = var.findAttribute(getName());
    eq FQNameFull.findHierarchicalAttribute(FQName prefix, FVariable var) {
        int i = prefix.numMatchingParts(this);
        int n = getNumFQNamePart();
        if (i >= n)
            return null;
        FAttribute attr = var.findAttribute(getFQNamePart(i).getName());
        for (i++; i < n && attr != null; i++)
            attr = attr.findAttribute(getFQNamePart(i).getName());
        return attr;
    }
    
    syn CValue FVariable.attributeCValueString(String name) {
        FAttribute a = findAttribute(name);
        return (attributeSet(a) ? attributeExp(a).ceval() : new CValueString("")).expandArray(size());
    }
    syn CValue FVariable.attributeCValueBoolean(String name, boolean def) {
        FAttribute a = findAttribute(name);
        return (attributeSet(a) ? attributeExp(a).ceval() : new CValueBoolean(def)).expandArray(size());
    }
    syn CValue FVariable.attributeCValueReal(String name, double def) {
        FAttribute a = findAttribute(name);
        return (attributeSet(a) ? attributeExp(a).ceval() : new CValueReal(def)).expandArray(size());
    }
    syn CValue FVariable.attributeCValueInteger(String name, int def) {
        FAttribute a = findAttribute(name);
        return (attributeSet(a) ? attributeExp(a).ceval() : new CValueInteger(def)).expandArray(size());
    }
    syn CValue FVariable.attributeCValueEnum(String name, FType type, int def) {
        FAttribute a = findAttribute(name);
        return (attributeSet(a) ? attributeExp(a).ceval() : new CValueEnum(type, def)).expandArray(size());
    }
    
    public void FVariable.setAttribute(String name, String type, FExp exp) {
        setAttribute(name, type, exp, 0);
    }
    
    public void FVariable.setAttribute(String name, String type, FExp exp, int level) {
        FAttribute attr = findMatching(getFAttributes(), name);
        if (attr == null) {
            attr = new FAttribute(new FIdUse(type), new FIdDecl(name), exp, true, level);
            addFAttribute(attr);
        } else {
            attr.setValue(exp);
            attr.setLevel(level);
        }
    }

    public void FVariable.unsetAttribute(String name) {
        List<FAttribute> newList = new List<FAttribute>();
        for (FAttribute attr : getFAttributes()) {
            if (!attr.matches(name))
                newList.add(attr);
        }
        setFAttributeList(newList);
        flushCache();
    }

    // Quantity attribute
    syn boolean FVariable.quantityAttributeSet()    = attributeSet(FAttribute.QUANTITY);
    syn FExp    FVariable.quantityAttributeExp()    = attributeExp(FAttribute.QUANTITY);
    syn CValue  FVariable.quantityAttributeCValue() = attributeCValueString(FAttribute.QUANTITY);
    syn String  FVariable.quantityAttribute()       = quantityAttributeCValue().stringValue();

    // Unit attribute
    syn boolean FVariable.unitAttributeSet()    = attributeSet(FAttribute.UNIT);
    syn FExp    FVariable.unitAttributeExp()    = attributeExp(FAttribute.UNIT);
    syn CValue  FVariable.unitAttributeCValue() = attributeCValueString(FAttribute.UNIT);
    syn String  FVariable.unitAttribute()       = unitAttributeCValue().stringValue();

    // Display Unit attribute
    syn boolean FVariable.displayUnitAttributeSet()    = attributeSet(FAttribute.DISPLAY_UNIT);
    syn FExp    FVariable.displayUnitAttributeExp()    = attributeExp(FAttribute.DISPLAY_UNIT);
    syn CValue  FVariable.displayUnitAttributeCValue() = attributeCValueString(FAttribute.DISPLAY_UNIT);
    syn String  FVariable.displayUnitAttribute()       = displayUnitAttributeCValue().stringValue();

    // min attribute
    syn boolean FVariable.minAttributeSet()           = attributeSet(FAttribute.MIN);
    syn FExp    FVariable.minAttributeExp()           = attributeExp(FAttribute.MIN);
    syn CValue  FRealVariable.minAttributeCValue()    = attributeCValueReal(FAttribute.MIN, -1e20);
    syn CValue  FIntegerVariable.minAttributeCValue() = attributeCValueInteger(FAttribute.MIN, (int) -1e10);
    syn CValue  FEnumVariable.minAttributeCValue()    = attributeCValueEnum(FAttribute.MIN, type(), 1);
    syn double  FRealVariable.minAttribute()          = minAttributeCValue().realValue();
    syn int     FIntegerVariable.minAttribute()       = minAttributeCValue().intValue();
    syn int     FEnumVariable.minAttribute()          = minAttributeCValue().intValue();

    // max attribute
    syn boolean FVariable.maxAttributeSet()           = attributeSet(FAttribute.MAX);
    syn FExp    FVariable.maxAttributeExp()           = attributeExp(FAttribute.MAX);
    syn CValue  FRealVariable.maxAttributeCValue()    = attributeCValueReal(FAttribute.MAX, 1e20);
    syn CValue  FIntegerVariable.maxAttributeCValue() = attributeCValueInteger(FAttribute.MAX, (int) 1e10);
    syn CValue  FEnumVariable.maxAttributeCValue()    = attributeCValueEnum(FAttribute.MAX, type(), numEnumLiterals());
    syn double  FRealVariable.maxAttribute()          = maxAttributeCValue().realValue();
    syn int     FIntegerVariable.maxAttribute()       = maxAttributeCValue().intValue();
    syn int     FEnumVariable.maxAttribute()          = maxAttributeCValue().intValue();

    // start attribute
    syn boolean FVariable.useBindingExpAsStart()  = 
        (isIndependentParameter() && hasBindingExp() && !isAlias()) || isIndependentConstant();
    
    syn boolean FVariable.startAttributeSet()     = attributeSet(FAttribute.START);
    syn FExp    FVariable.startAttributeExp()     = attributeExp(FAttribute.START);
    syn FExp    FVariable.createStartAttributeExp() {
        FExp e = startAttributeExp();
        return (e == null) ? startAttributeCValue().buildLiteral() : e.fullCopy();
    }
    
    syn CValue FVariable.startAttributeCValue()   = CValue.UNKNOWN;
    eq FRealVariable.startAttributeCValue()       = attributeCValueReal(FAttribute.START, 0.0);
    eq FDerivativeVariable.startAttributeCValue() = new CValueReal(0.0);
    eq FIntegerVariable.startAttributeCValue()    = attributeCValueInteger(FAttribute.START, 0);
    eq FBooleanVariable.startAttributeCValue()    = attributeCValueBoolean(FAttribute.START, false);
    eq FStringVariable.startAttributeCValue()     = attributeCValueString(FAttribute.START);
    eq FEnumVariable.startAttributeCValue()       = attributeCValueEnum(FAttribute.START, type(), 1);

    syn double  FRealVariable.startAttribute()    = startAttributeCValue().realValue();
    syn int     FIntegerVariable.startAttribute() = startAttributeCValue().intValue();
    syn boolean FBooleanVariable.startAttribute() = startAttributeCValue().booleanValue();
    syn String  FStringVariable.startAttribute()  = startAttributeCValue().stringValue();
    syn int     FEnumVariable.startAttribute()    = startAttributeCValue().intValue();

    // fixed attribute
    syn boolean FVariable.fixedAttributeSet()           = attributeSet(FAttribute.FIXED);
    syn FExp    FVariable.fixedAttributeExp()           = attributeExp(FAttribute.FIXED);
    syn CValue  FVariable.fixedAttributeCValue()        = attributeCValueBoolean(FAttribute.FIXED, isParameter() || isConstant());
    syn boolean FVariable.fixedAttribute()              = fixedAttributeCValue().reduceBooleanOr();
    public void FVariable.setFixedAttribute(boolean value) { setFixedAttribute(FBooleanLitExp.create(value)); }
    public void FVariable.setFixedAttribute(FExp value)    { setAttribute(FAttribute.FIXED, "Boolean", value); }
        
    // Nominal attribute
    syn boolean FRealVariable.nominalAttributeSet()    = attributeSet(FAttribute.NOMINAL);
    syn FExp    FRealVariable.nominalAttributeExp()    = attributeExp(FAttribute.NOMINAL);
    syn CValue  FRealVariable.nominalAttributeCValue() = attributeCValueReal(FAttribute.NOMINAL, 1.0);
    syn double  FRealVariable.nominalAttribute()       = nominalAttributeCValue().realValue();

    syn boolean FDerivativeVariable.nominalAttributeSet()    = myDifferentiatedVariable().nominalAttributeSet();
    syn FExp    FDerivativeVariable.nominalAttributeExp()    = myDifferentiatedVariable().nominalAttributeExp();
    syn CValue  FDerivativeVariable.nominalAttributeCValue() = myDifferentiatedVariable().nominalAttributeCValue();
    
    // State Select attribute
    syn boolean FVariable.stateSelectAttributeSet()        = attributeSet(FAttribute.STATE_SELECT);
    syn FExp    FRealVariable.stateSelectAttributeExp()    = attributeExp(FAttribute.STATE_SELECT);
    syn CValue  FRealVariable.stateSelectAttributeCValue() = attributeCValueEnum(FAttribute.STATE_SELECT, stateSelectType(), 3);
    syn int     FRealVariable.stateSelectAttributeInt()    = stateSelectAttributeCValue().intValue();
    
    public void FVariable.warnStartAttributeNotSet() {
        if (!ASTNode.printer_C.C_blockResidualAttributePrinter.attributeSet(this, "start"))
            warning("Iteration variable \"" + name() + "\" is missing start value!");
    }
    
    
    /**
     * Return the maximum numeric value that this expression can take, considering min/max values of variables.
     * 
     * Only implemented for a small subset of expressions:
     *  - flat access to Real or Integer
     *  - numeric literal
     *  - negation
     */
    syn double FExp.maxRealValue() {
        throw new UnsupportedOperationException();
    }
    
    /**
     * Return the minimum numeric value that this expression can take, considering min/max values of variables.
     * 
     * Only implemented for a small subset of expressions:
     *  - flat access to Real or Integer
     *  - numeric literal
     *  - negation
     */
    syn double FExp.minRealValue() {
        throw new UnsupportedOperationException();
    }
    
    eq FRealLitExp.maxRealValue()    = getValue();
    eq FRealLitExp.minRealValue()    = getValue();
    eq FIntegerLitExp.maxRealValue() = getValue();
    eq FIntegerLitExp.minRealValue() = getValue();
    eq FNegExp.maxRealValue()        = -getFExp().minRealValue();
    eq FNegExp.minRealValue()        = -getFExp().maxRealValue();
    eq FIdUseExp.maxRealValue()      = myFV().maxRealValue();
    eq FIdUseExp.minRealValue()      = myFV().minRealValue();

    /**
     * Return the maximum numeric value that this variable can take.
     * 
     * Only implemented for Real and Integer variables.
     */
    syn double FAbstractVariable.maxRealValue() {
        throw new UnsupportedOperationException();
    }

    /**
     * Return the minimum numeric value that this variable can take.
     * 
     * Only implemented for Real and Integer variables.
     */
    syn double FAbstractVariable.minRealValue() {
        throw new UnsupportedOperationException();
    }
    
    eq FRealVariable.maxRealValue()    = variability().knownParameterOrLess() ? ceval().realValue() : maxAttribute();
    eq FRealVariable.minRealValue()    = variability().knownParameterOrLess() ? ceval().realValue() : minAttribute();
    eq FIntegerVariable.maxRealValue() = variability().knownParameterOrLess() ? ceval().intValue() : maxAttribute();
    eq FIntegerVariable.minRealValue() = variability().knownParameterOrLess() ? ceval().intValue() : minAttribute();
    
    
    /**
     * Check if this attribute is in an FVariable.
     */
    inh boolean FAttribute.isInFV();
    eq FVariable.getChild().isInFV()         = true;
    eq FDerivedType.getChild().isInFV()      = false;
    eq FAbstractEquation.getChild().isInFV() = false;
    eq FFunctionDecl.getChild().isInFV()     = false;
    eq FClass.getChild().isInFV()            = false;

    /**
     * Check if this attribute is in a specific FVariable.
     */
    inh boolean FAttribute.isInFV(FVariable fv);
    eq FVariable.getChild().isInFV(FVariable fv)         = fv == this;
    eq FDerivedType.getChild().isInFV(FVariable fv)      = false;
    eq FAbstractEquation.getChild().isInFV(FVariable fv) = false;
    eq FFunctionDecl.getChild().isInFV(FVariable fv)     = false;
    eq FClass.getChild().isInFV(FVariable fv)            = false;

    /**
     * Check if this attribute is in an FDerivedType.
     */
    inh boolean FAttribute.isInDerivedType();
    eq FVariable.getChild().isInDerivedType()         = false;
    eq FDerivedType.getChild().isInDerivedType()      = true;
    eq FAbstractEquation.getChild().isInDerivedType() = false;
    eq FFunctionDecl.getChild().isInDerivedType()     = false;
    eq FClass.getChild().isInDerivedType()            = false;

    /**
     * Check if this attribute is in a specific FDerivedType.
     */
    inh boolean FAttribute.isInDerivedType(FDerivedType t);
    eq FVariable.getChild().isInDerivedType(FDerivedType t)         = false;
    eq FDerivedType.getChild().isInDerivedType(FDerivedType t)      = t == this;
    eq FAbstractEquation.getChild().isInDerivedType(FDerivedType t) = false;
    eq FFunctionDecl.getChild().isInDerivedType(FDerivedType t)     = false;
    eq FClass.getChild().isInDerivedType(FDerivedType t)            = false;

}

aspect Nominals {
    syn FExp FAbstractEquation.nominal() {
        FExp nom = FExp.nominalDefault();
        nom.setParent(this);
        return nom;
    }
    eq FEquation.nominal() {
        FExp nom = getLeft().dynamicFExp(FExp.nominalMax(getLeft(), getRight()));
        if (nom.variability().knownParameterOrLess()) {
            try {
                nom = getLeft().dynamicFExp(nom.ceval().buildLiteral());
            } catch (ConstantEvaluationException e) {
                
            }
        }
        return nom;
    }
    
    public static FExp FExp.nominalMax(FExp e1, FExp e2) {
        return new FMaxExp(e1.nominal(), new Opt<FExp>(e2.nominal()));
    }
    public static FExp FExp.nominalDefault() {
        return new FIntegerLitExp(1);
    }
    
    syn FExp FExp.nominal() = FExp.nominalDefault();
    eq FLitExp.nominal()    = new FAbsExp(fullCopy());
    
    eq FDotAddExp.nominal() = FExp.nominalMax(getLeft(), getRight());
    eq FDotSubExp.nominal() = FExp.nominalMax(getLeft(), getRight());
    eq FDotMulExp.nominal() = new FMulExp(getLeft().nominal(), getRight().nominal());
    eq FDotDivExp.nominal() = new FDivExp(getLeft().nominal(), getRight().nominal());
    eq FNegExp.nominal()    = getFExp().nominal();
    eq FAbsExp.nominal()    = getFExp().nominal();
    eq FMinMaxExp.nominal() = hasY() ? FExp.nominalMax(getX(), getY()) : getX().nominal();
    
    eq FIfExp.nominal()     = FExp.nominalMax(getThenExp(), getElseExp());
    
    eq FNoEventExp.nominal() = getFExp().nominal();
    eq FSmoothExp.nominal()  = getFExp().nominal();
    
    eq FHomotopyExp.nominal()    = FExp.nominalMax(getActual(), getSimplified());
    eq FSpatialDistExp.nominal() = FExp.nominalMax(getIn0(), getIn1());
    eq FDelayExp.nominal()       = getFExp().nominal();
    
    eq FIdUseExp.nominal() = myFV().nominal();
    
    syn FExp FAbstractVariable.nominal() {
        if (variability().parameterOrLess() && valueIsFixed()) {
            return new FAbsExp(createUseExp());
        } else {
            return variableNominal();
        }
    }
    
    syn FExp FAbstractVariable.variableNominal() {
        return FExp.nominalDefault();
    }
    
    eq FRealVariable.variableNominal() {
        if (nominalAttributeSet()) {
            return new FAbsExp(nominalAttributeExp().unboundCopy());
        } else {
            return super.variableNominal();
        }
    }
}

aspect FVariableUses {
    
    /**
     * Collection attribute returning all variable uses in expressions.
     */
    coll HashSet<FIdUseExp> FAbstractVariable.uses() [new LinkedHashSet<FIdUseExp>()] 
        with add root FClass;
    
    FIdUseExp contributes this to FAbstractVariable.uses() for myFV();
    
    /**
     * All uses of this variable that are not the left-hand side of an equation. 
     * (Unless the variable has a binding expression, then this is the same as uses().)
     */
    syn lazy Set<FIdUseExp> FAbstractVariable.nonDefiningUses() {
        Set<FIdUseExp> res = new HashSet<FIdUseExp>();
        for (FIdUseExp use : uses())
            if (hasBindingExp() || !use.isLeftHandSide())
                res.add(use);
        return res;
    }
    
    /**
     * All uses of this variable that are the left-hand side of an equation. 
     * (Unless the variable has a binding expression, then this is empty.)
     */
    syn lazy Set<FIdUseExp> FAbstractVariable.definingUses() {
        if (hasBindingExp()) {
            return Collections.emptySet();
        } else {
            Set<FIdUseExp> res = new HashSet<FIdUseExp>();
            for (FIdUseExp use : uses())
                if (use.isLeftHandSide())
                    res.add(use);
            return res;
        }
    }
    
    /**
     * Check if this variable is used on the left hand side of a function call equation or statement.
     */
    syn lazy boolean FAbstractVariable.usedAsFunctionCallLeft() {
        for (FExp e : definingUses()) 
            if (e.inFunctionCallLeft())
                return true;
        return false;
    }
    
    inh boolean FExp.inFunctionCallLeft();
    eq FFunctionCallLeft.getChild().inFunctionCallLeft() = true;
    eq FClass.getChild().inFunctionCallLeft()            = false;
    eq InstRoot.getChild().inFunctionCallLeft()          = false;
    
    inh boolean FExp.inFunctionCallLeftTop();
    eq FFunctionCallLeft.getChild().inFunctionCallLeftTop() = true;
    eq FExp.getChild().inFunctionCallLeftTop()              = false;
    eq FClass.getChild().inFunctionCallLeftTop()            = false;
    eq InstRoot.getChild().inFunctionCallLeftTop()          = false;
    
    /**
     * Checks if this expression is used in a function call
     */
    inh boolean FExp.inFunctionCall();
    eq FFunctionCall.getChild().inFunctionCall() = true;
    eq FClass.getChild().inFunctionCall()        = false;
    eq InstRoot.getChild().inFunctionCall()      = false;
    
    inh boolean FExp.isFunctionCallArg();
    eq FFunctionCall.getArg().isFunctionCallArg() = true;
    eq BaseNode.getChild().isFunctionCallArg()    = false;
    
    /**
     * Returnes the function input that this expressions corresponds to.
     * NOTICE, this method will throw exception if this exp does not reside in a function call.
     */
    inh CommonVariableDecl FExp.myCorrespondingInput();
    eq FFunctionCall.getArg(int i).myCorrespondingInput()    = myFCallable().myInput(i);
    eq InstFunctionCall.getArg(int i).myCorrespondingInput() = myInstCallable().myCallInputs().get(i);
    eq FClass.getChild().myCorrespondingInput() {
        throw new UnsupportedOperationException();
    }
    eq InstRoot.getChild().myCorrespondingInput() {
        throw new UnsupportedOperationException();
    }
    
    /**
     * All uses of this variable that are the left-hand side of an assignment or 
     * function call statement. 
     */
    coll HashSet<FIdUseExp> FFunctionVariable.assigningUses() [new HashSet<FIdUseExp>()] 
        with add root FFunctionDecl;
    FIdUseExp contributes this when isAssignedTo() && myFuncVar() != null
        to FFunctionVariable.assigningUses() for myFuncVar();
    
    /**
     * Check if this is the left hand side of an equation.
     */
    inh boolean FExp.isLeftHandSide();
    eq BaseNode.getChild().isLeftHandSide()    = false;
    eq FEquation.getLeft().isLeftHandSide()    = true;
    eq FFunctionCallLeft.getChild().isLeftHandSide()  = true;
    eq FArray.getChild().isLeftHandSide()             = isLeftHandSide();
    eq FRecordConstructor.getChild().isLeftHandSide() = isLeftHandSide();
    
    /**
     * Check if this is the left hand side of an assignment or function call statement.
     */
    inh boolean FAssignableExp.isAssignedTo();
    inh boolean FFunctionCallLeft.isAssignedTo();
    eq BaseNode.getChild().isAssignedTo()         = false;
    eq FAssignStmt.getLeft().isAssignedTo()       = true;
    eq FFunctionCallStmt.getLeft().isAssignedTo() = true;
    eq FFunctionCallLeft.getFExp().isAssignedTo() = isAssignedTo();
    
    inh boolean FExp.inBindingExp();
    eq Root.getChild().inBindingExp() = false;
    eq InstAssignable.getBindingFExp().inBindingExp() = true;
    eq FVariable.getBindingExp().inBindingExp() = true;
    
    /**
     * Check if this is exp is bound in a declaration
     */
    inh boolean FExp.isBound();
    eq Root.getChild().isBound()                   = false;
    eq InstValueModification.getFExp().isBound()   = true;
    eq InstFunctionCall.getArg().isBound()        = false;
    
    inh boolean FExp.inParamBindingExp();
    eq Root.getChild().inParamBindingExp() = false;
    eq FVariable.getBindingExp().inParamBindingExp() = isParameter();
    
    inh FTypePrefixVariability FExp.bindingExpVariability();
    eq Root.getChild().bindingExpVariability() = fContinuous();
    eq FVariable.getChild().bindingExpVariability() = variability();
    eq FVariable.getFAttribute().bindingExpVariability() = fParameter();
    eq FRecordVariable.getFAttribute(int i).bindingExpVariability() {
        int partIndex = myFRecordDecl().indexOf(getFAttribute(i).name());
        return variability().getPart(partIndex);
    }
    
    /**
     * Collection attribute returning all dependent parameters which
     * depends on the parameter.
     */
    
    coll HashSet<FVariable> FAbstractVariable.dependentParameters() 
      [new LinkedHashSet<FVariable>()] 
        with addAll root FlatRoot;
    
    FIdUseExp contributes boundParameters() when myFV().isParameter()
        to FAbstractVariable.dependentParameters() for myFV();
    
    syn lazy Collection<FRealVariable> FAbstractVariable.dependentRealParameters() =
            FClass.filterCollection(dependentParameters(), FClass.REAL_VARIABLE_FILTER);

    syn lazy Collection<FIntegerVariable> FAbstractVariable.dependentIntegerParameters() =
            FClass.filterCollection(dependentParameters(), FClass.INTEGER_VARIABLE_FILTER);

    syn lazy Collection<FEnumVariable> FAbstractVariable.dependentEnumParameters() =
            FClass.filterCollection(dependentParameters(), FClass.ENUM_VARIABLE_FILTER);
    
    syn lazy Collection<FBooleanVariable> FAbstractVariable.dependentBooleanParameters() =
            FClass.filterCollection(dependentParameters(), FClass.BOOLEAN_VARIABLE_FILTER);

    syn lazy Collection<FStringVariable> FAbstractVariable.dependentStringParameters() =
            FClass.filterCollection(dependentParameters(), FClass.STRING_VARIABLE_FILTER);

    /**
     * Collection attribute returning all input variables (FVariables)
     * referenced in an equation.
     */
     
    coll LinkedHashSet<FVariable> FAbstractEquation.retrieveInputs() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when 
        myFV().isFVariable() && myFV().isInput() to 
        FAbstractEquation.retrieveInputs() for myFEquation();

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.inputs() = 
        retrieveInputs();
    
    eq FIfWhenElseEquation.inputs()  {
        LinkedHashSet<FVariable> s = new LinkedHashSet<FVariable>();
        s.addAll(retrieveInputs());
        for (FAbstractEquation e : getFAbstractEquations()) {
            s.addAll(e.inputs());
        }
        return s;
    }
    eq FIfWhenEquation.inputs()  {
        LinkedHashSet<FVariable> s = new LinkedHashSet<FVariable>();
        s.addAll(super.inputs());
        if (hasElse())
            s.addAll(getElse().inputs());
        return s;
    }

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.realInputs() = 
            new LinkedHashSet<FVariable>(FClass.filterCollection(inputs(), FClass.REAL_VARIABLE_FILTER));

    
    /**
     * Collection attribute returning all algebraic variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.algebraicVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when isAlgebraicVariableAccess() to 
        FAbstractEquation.algebraicVariables() for each enclosingEquationsIterator();

    syn boolean FIdUseExp.isAlgebraicVariableAccess() = inAlgebraicAccessLocation() && myFV().isAlgebraicVariable();

    inh boolean FIdUseExp.inAlgebraicAccessLocation();
    eq FlatRoot.getChild().inAlgebraicAccessLocation()   = false;
    eq SourceRoot.getChild().inAlgebraicAccessLocation()   = false;
    eq FAbstractEquation.getFAttribute().inAlgebraicAccessLocation() = false;
    eq FAbstractEquation.getChild().inAlgebraicAccessLocation() = true;

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.algebraicContinousRealVariables() = 
        FClass.intersectFVSet(algebraicVariables(), myFClass().algebraicContinousRealVariables());

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteRealVariables() = 
        FClass.intersectFVSet(algebraicVariables(), myFClass().discreteRealVariables());

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteIntegerVariables() = 
        FClass.intersectFVSet(algebraicVariables(), myFClass().discreteIntegerVariables());

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteBooleanVariables() = 
        FClass.intersectFVSet(algebraicVariables(), myFClass().discreteBooleanVariables());

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteStringVariables() = 
        FClass.intersectFVSet(algebraicVariables(), myFClass().discreteStringVariables());

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteEnumVariables() = 
        FClass.intersectFVSet(algebraicVariables(), myFClass().discreteStringVariables());


    /**
     * Collection attribute returning all derivative variables (FDerivativeVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FDerivativeVariable> FAbstractEquation.derivativeVariables() 
        [new LinkedHashSet<FDerivativeVariable>()] with add root FAbstractEquation;

    FDerExp contributes (FDerivativeVariable) myFV() when myFV().isDerivativeVariable() to 
        FAbstractEquation.derivativeVariables() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all differentiated variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.differentiatedRealVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when myFV().isDifferentiatedVariable() to 
        FAbstractEquation.differentiatedRealVariables() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all independent parameter variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.dependentParameters() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when myFV().isDependentParameter() to 
        FAbstractEquation.dependentParameters() for each enclosingEquationsIterator();
        
    /**
     * Collection attribute returning all dependent parameter variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.parameters() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when myFV().isParameter() to 
        FAbstractEquation.parameters() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all discrete variables (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.discreteVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when myFV().isDiscreteVariable() to 
        FAbstractEquation.discreteVariables() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all non-fixed parameters (FVariables)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.nonFixedParameters()
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FIdUseExp contributes (FVariable) myFV() when myFV().isNonFixedParameter() to
        FAbstractEquation.nonFixedParameters() for each enclosingEquationsIterator();

    /**
     * Collection attribute returning all pre variables (FPreVariable)
     * referenced in an equation.
     */
    coll LinkedHashSet<FVariable> FAbstractEquation.discretePreVariables() 
        [new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

    FPreExp contributes (FVariable) myFV() when myFV().isPreVariable() to 
        FAbstractEquation.discretePreVariables() for each enclosingEquationsIterator();

    syn lazy LinkedHashSet<FVariable> FAbstractEquation.variables() {
        LinkedHashSet<FVariable> l = new LinkedHashSet<FVariable>();
        l.addAll(differentiatedRealVariables());
        l.addAll(derivativeVariables());
        l.addAll(algebraicVariables());
        l.addAll(discreteVariables());
        return l;
    }

    /**
     * Get the differenetiated variabel (FVariable) corresponding to 
     * a derivative variable (FDerivativeVariable)
     * TODO: this is incorrect what if order=2!
     */
    syn FRealVariable FAbstractDerivativeVariable.myDifferentiatedVariable() =
        (FRealVariable) lookupFV(getFQName());

    /**
     * Get the derivative variabel (FDerivativeVariable) corresponding to 
     * a differentiated variable (FVariable)
     * TODO: this is sort of the same as meDifferentiated()
     */
    syn FDerivativeVariable FVariable.myDerivativeVariable() =
        (FDerivativeVariable) lookupDerFV(getFQName(), order() + 1);
    
    /**
     * Get the pre variable connected to a normal variable, if any.
     */
    syn FAbstractVariable FAbstractVariable.myPreVariable() = lookupPreFV(getFQName());
    
    /**
     * Get the normal variable connected to a pre variable.
     * 
     * Will be unknown for non-pre variables.
     */
    syn FAbstractVariable FAbstractVariable.myNonPreVariable() = unknownFVariable();
    eq FPreBooleanVariable.myNonPreVariable() = lookupFV(getFQName());
    eq FPreIntegerVariable.myNonPreVariable() = lookupFV(getFQName());
    eq FPreRealVariable.myNonPreVariable()    = lookupFV(getFQName());
    eq FPreStringVariable.myNonPreVariable()  = lookupFV(getFQName());
    eq FPreEnumVariable.myNonPreVariable()    = lookupFV(getFQName());
    
}

aspect LinearFVariables {
    
    /**
     * Check linearity of variable.
     * 
     * The attribute isLinear returns true if all uses of the variable appears
     * linearly in equations and in initial equations. Parameters and constants
     * are assumed to be literals in the linearity computation. Accordingly,
     * multiplication of a variable with a parameter or constant does not render
     * the variable nonlinear. Also, parameters and constants are considered
     * to be linear themselves.
     */
    syn lazy boolean FVariable.isLinear() {
        if (isParameter() || isConstant()) {
            return true;
        }
        for (FIdUseExp e : uses()) {
            if (!e.isLinear()) {
                return false;
            }
        }
        return true;
    }
    
    /**
     * Check if a subexpression appears linearly.
     * 
     * Note that this method does not check if the expression itself is linear
     * but wheather it apperas linearly in a composite expression. For example
     * the sub expression 'sin(x)' appears linearly in '1+sin(x)'.
     */
    inh boolean FExp.isLinear();
    eq FlatRoot.getChild().isLinear() = true;
    eq SourceRoot.getChild().isLinear() = true;
    
    eq FAbstractEquation.getChild().isLinear() = true;
    
    eq FMulExp.getLeft().isLinear() =
        (getRight().isConstantExp() || getRight().isLinearParameterExp())?
                isLinear() : false;
    eq FMulExp.getRight().isLinear() =
        (getLeft().isConstantExp() || getLeft().isLinearParameterExp())?
                isLinear() : false;
    eq FDivExp.getLeft().isLinear() =
        (getRight().isConstantExp() || getRight().isLinearParameterExp())?
                isLinear() : false;         
    eq FDivExp.getRight().isLinear() = false;       
    eq FPowExp.getChild().isLinear() = false;
    eq FFunctionCall.getChild().isLinear() = false;
    eq FMathematicalFunctionCall.getChild().isLinear() = false;
                
    // This definition is to avoid errors when isParameterExp is redefined
    // to include free parameters in the Optimica extension.
    syn boolean FExp.isLinearParameterExp() = isParameterExp();
    
    coll Set<FIdUseExp> FAbstractEquation.collectUses() 
        [new LinkedHashSet<FIdUseExp>()] with add root FAbstractEquation;

    FIdUseExp contributes this when 
        !myFV().isUnknown() to 
        FAbstractEquation.collectUses() for myFEquation();
    
    syn Set<FIdUseExp> FAbstractEquation.collectUses(Set<FVariable> vars) {
        HashSet<FIdUseExp> set = new HashSet<FIdUseExp>();
        for (FIdUseExp e : collectUses()) {
            if (vars.contains(e.myFV())) {
                set.add(e);         
            }
        }
        return set;
    }
    
    syn boolean FAbstractEquation.checkLinearity(Set<FVariable> vars) {
        for (FIdUseExp e : collectUses(vars)) {
            if (!e.isLinear(vars)) {
                return false;
            }
        }
        return true;
    }
    eq FIfWhenElseEquation.checkLinearity(Set<FVariable> vars) = false;
    eq FAlgorithm.checkLinearity(Set<FVariable> vars) = false;
    
    inh boolean FExp.isLinear(Set<FVariable> vars);
    eq FlatRoot.getChild().isLinear(Set<FVariable> vars)   = true;
    eq SourceRoot.getChild().isLinear(Set<FVariable> vars) = true;
    
    eq FAbstractEquation.getChild().isLinear(Set<FVariable> vars) = true;
    eq FStatement.getChild().isLinear(Set<FVariable> vars)        = false;
    
    eq FMulExp.getLeft().isLinear(Set<FVariable> vars)  = getRight().isIndependent(vars) && isLinear(vars);
    eq FMulExp.getRight().isLinear(Set<FVariable> vars) = getLeft().isIndependent(vars) && isLinear(vars);
    eq FDivExp.getLeft().isLinear(Set<FVariable> vars)  = getRight().isIndependent(vars) && isLinear(vars);         
    eq FDivExp.getRight().isLinear(Set<FVariable> vars) = false;
    eq FPowExp.getChild().isLinear(Set<FVariable> vars) = false;
    eq FFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FMathematicalFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FAbstractFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FIfExp.getIfExp().isLinear(Set<FVariable> vars) = !isWhen();
    
    syn boolean FExp.isIndependent(Set<FVariable> set) {
        for (FExp e : childFExps()) {
            if (!e.isIndependent(set)) {
                return false;
            }
        }
        return true;
    }

    syn boolean FIfExp.isIndependent(Set<FVariable> set) {
        // Don't check the guard exp since it is discrete and does not affect
        // linearity.
        return getThenExp().isIndependent(set) && getElseExp().isIndependent(set);
    }

    eq FIdUseExp.isIndependent(Set<FVariable> set) {
        return !set.contains(myFV());   
    }
}

aspect FlatDiagnostics {

    syn String FClass.diagnostics() {
        StringBuilder str = new StringBuilder();
        str.append("Diagnostics for flattened class " + name() + "\n");

        str.append(modelDiagnostics());
        
        str.append("\n");
        
        str.append(variableDiagnostics());
        
        str.append("\n");  

        str.append(aliasDiagnostics());
        
        str.append("\n");  
        
        str.append(incidence());

        str.append("\n");  
        
        str.append(dependencyDiagnostics());

        str.append("\n");
        
//      str.append(dersAndDiffs());
        
        str.append("\n");  
        
        str.append(getConnectionSetManager().printConnectionSets());
        
        return str.toString();
    }

    public String FClass.modelDiagnostics() {
        StringBuilder str = new StringBuilder();
        modelDiagnosticsPrintRow(str, "Number of independent constants:", independentConstants());
        modelDiagnosticsPrintRow(str, "  Number of Real independent constants:", independentRealConstants());
        modelDiagnosticsPrintRow(str, "  Number of Real independent constants:", independentRealConstants());
        modelDiagnosticsPrintRow(str, "  Number of Integer independent constants:", independentIntegerConstants());
        modelDiagnosticsPrintRow(str, "  Number of Enum independent constants:", independentEnumConstants());
        modelDiagnosticsPrintRow(str, "  Number of Boolean independent constants:", independentBooleanConstants());
        modelDiagnosticsPrintRow(str, "  Number of String independent constants:", independentStringConstants());

        modelDiagnosticsPrintRow(str, "Number of dependent constants:", dependentConstants());
        modelDiagnosticsPrintRow(str, "  Number of Real dependent constants:", dependentRealConstants());
        modelDiagnosticsPrintRow(str, "  Number of Integer dependent constants:", dependentIntegerConstants());
        modelDiagnosticsPrintRow(str, "  Number of Enum dependent constants:", dependentEnumConstants());
        modelDiagnosticsPrintRow(str, "  Number of Boolean dependent constants:", dependentBooleanConstants());
        modelDiagnosticsPrintRow(str, "  Number of String dependent constants:", dependentStringConstants());

        modelDiagnosticsPrintRow(str, "Number of independent parameters:", independentParameters());
        modelDiagnosticsPrintRow(str, "  Number of Real independent parameters:", independentRealParameters());
        modelDiagnosticsPrintRow(str, "  Number of Integer independent parameters:", independentIntegerParameters());
        modelDiagnosticsPrintRow(str, "  Number of Enum independent parameters:", independentEnumParameters());
        modelDiagnosticsPrintRow(str, "  Number of Boolean independent parameters:", independentBooleanParameters());
        modelDiagnosticsPrintRow(str, "  Number of String independent parameters:", independentStringParameters());
                  
        modelDiagnosticsPrintRow(str, "Number of dependent parameters:", dependentParameters());
        modelDiagnosticsPrintRow(str, "  Number of Real dependent parameters:", dependentRealParameters());
        modelDiagnosticsPrintRow(str, "  Number of Integer dependent parameters:", dependentIntegerParameters());
        modelDiagnosticsPrintRow(str, "  Number of Enum dependent parameters:", dependentEnumParameters());
        modelDiagnosticsPrintRow(str, "  Number of Boolean dependent parameters:", dependentBooleanParameters());
        modelDiagnosticsPrintRow(str, "  Number of String dependent parameters:", dependentStringParameters());
        
        modelDiagnosticsPrintRow(str, "Number of variables:", variables());
        modelDiagnosticsPrintRow(str, "  Number of Real variables:", realVariables());
        modelDiagnosticsPrintRow(str, "  Number of Integer variables:", integerVariables());
        modelDiagnosticsPrintRow(str, "  Number of Enum variables:", enumVariables());
        modelDiagnosticsPrintRow(str, "  Number of Boolean variables:", booleanVariables());
        modelDiagnosticsPrintRow(str, "  Number of String variables:", stringVariables());

        modelDiagnosticsPrintRow(str, "Number of Real differentiated variables:", differentiatedRealVariables()); 
        modelDiagnosticsPrintRow(str, "Number of Real derivative variables:", derivativeVariables()); 
        modelDiagnosticsPrintRow(str, "Number of Real continous algebraic variables:", algebraicContinousRealVariables());

        modelDiagnosticsPrintRow(str, "Number of inputs:", inputs());
        modelDiagnosticsPrintRow(str, "  Number of Real inputs:", realInputs());
        modelDiagnosticsPrintRow(str, "  Number of Integer inputs:", integerInputs());
        modelDiagnosticsPrintRow(str, "  Number of Enum inputs:", enumInputs());
        modelDiagnosticsPrintRow(str, "  Number of Boolean inputs:", booleanInputs());
        modelDiagnosticsPrintRow(str, "  Number of String inputs:", stringInputs());
        
        modelDiagnosticsPrintRow(str, "Number of discrete variables:", discreteVariables());
        modelDiagnosticsPrintRow(str, "  Number of Real discrete variables:", discreteRealVariables());
        modelDiagnosticsPrintRow(str, "  Number of Integer discrete variables:", discreteIntegerVariables());
        modelDiagnosticsPrintRow(str, "  Number of Enum discrete variables:", discreteEnumVariables());
        modelDiagnosticsPrintRow(str, "  Number of Boolean discrete variables:", discreteBooleanVariables());
        modelDiagnosticsPrintRow(str, "  Number of String discrete variables:", discreteStringVariables());
        
        modelDiagnosticsPrintRow(str, "Number of equations:", equations());
        
        modelDiagnosticsPrintRow(str, "Number of variables with binding expression:", variablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Real variables with binding exp:", realVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Integer variables binding exp:", integerVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Enum variables binding exp:", enumVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of Boolean variables binding exp:", booleanVariablesWithBindingExp());
        modelDiagnosticsPrintRow(str, "  Number of String variables binding exp:", stringVariablesWithBindingExp());
            
        modelDiagnosticsPrintRow(str, "Total number of equations:", equations(), variablesWithBindingExp());
    
        modelDiagnosticsPrintRow(str, "Number of initial equations:", initialEquations());

        str.append(String.format("Number of event indicators in equations:      %6d\n", numEventIndicators()));
        str.append(String.format("Number of event indicators in init equations: %6d\n", numRelExpInInitialEquations()));


        return str.toString();
    }
    
    private static void FClass.modelDiagnosticsPrintRow(StringBuilder sb, String label, Collection<? extends FDiagnosticsNode> ... lists) {
        int num = 0;
        int numScalar = 0;
        for (Collection<? extends FDiagnosticsNode> list : lists) {
            num += list.size();
            numScalar += countNumScalars(list);
        }
        sb.append(String.format("%-46s%6d(%5d scalars)\n", label, num, numScalar));
    }

    private static int FClass.countNumScalars(Collection<? extends FDiagnosticsNode> nodes) {
        int num = 0;
        for (FDiagnosticsNode node : nodes)
            num += node.numScalars();
        return num;
    }

    public interface FDiagnosticsNode {
        public int numScalars();
    }
    public class FAbstractEquation implements FDiagnosticsNode {}
    public class FVariable implements FDiagnosticsNode {}
    
    syn int FAbstractEquation.numScalars() = numScalarEquations();
    syn int FVariable.numScalars() = type().numScalarElements();
    
    public String FClass.aliasDiagnostics() {
        StringBuilder str = new StringBuilder();
        str.append("Alias sets:\n");
        if (getAliasManager()!=null) {
            str.append(getAliasManager());
            int n_elim = 0;
            for (AliasManager.AliasSet aliasSet : getAliasManager().getAliasSets()) {
                n_elim += aliasSet.numAliases() - 1;
            }
            str.append(n_elim + " variables can be eliminated\n");
                
        } else {
            str.append("  Alias sets not computed.\n");
        }
        return str.toString();  
        
    }

    public String FClass.aliasDiagnosticsShort() {
        StringBuilder str = new StringBuilder();
        if (getAliasManager()!=null) {
            int n_elim = 0;
            Set<AliasManager.AliasSet> aliasSets = getAliasManager().getAliasSets();
            for (AliasManager.AliasSet aliasSet : aliasSets) {
                n_elim += aliasSet.numAliases() - 1;
            }
            str.append(aliasSets.size());
            str.append(" sets, ");
            str.append(n_elim);
            str.append(" eliminated variables");
        } else {
            str.append("Alias sets not computed");
        }
        return str.toString();  
        
    }

    public String FClass.variableDiagnostics() {
        
        StringBuilder str = new StringBuilder();
        
        str.append("Independent constants: \n");
        for (FVariable fv : independentConstants()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }
        str.append("\n");
        
        str.append("Dependent constants: \n");
        for (FVariable fv : dependentConstants()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }
        str.append("\n");
        
        str.append("Independent parameters: \n");
        for (FVariable fv : independentParameters()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            if (fv.hasBindingExp()) {
                str.append(", evaluated binding exp: ");
                str.append(fv.getBindingExp().ceval());
            }
            str.append("\n");
        }
        str.append("\n");
        
        str.append("Dependent parameters: \n");
        for (FVariable fv : dependentParameters()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }

        str.append("\n");  
        str.append("Differentiated variables: \n");
        for (FVariable fv : differentiatedRealVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            str.append("\n");
        }

        str.append("\n");  
        str.append("Derivative variables: \n");
        for (FVariable fv : derivativeVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }
        str.append("\n");  

        str.append("Discrete variables: \n");
        for (FVariable fv : discreteVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            str.append(", alias: ");
            if (!fv.isAlias()) {
                str.append("no");
            } else {
                if (fv.isNegated()) {
                    str.append("-");
                }
                str.append(fv.alias().valueReference());
            }
            str.append("\n");
        }
        str.append("\n");
        
        str.append("Algebraic real variables: \n");
        for (FVariable fv : algebraicContinousRealVariables()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
            str.append(", alias: ");
            if (!fv.isAlias()) {
                str.append("no");
            } else {
                if (fv.isNegated()) {
                    str.append("-");
                }
                str.append(fv.alias().valueReference());
            }
            str.append("\n");
        }
        str.append("\n");
        
        str.append("Input variables: \n");
        for (FVariable fv : inputs()) {
            str.append(" " + fv.name());
            str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
                    + fv.isLinear());
                str.append("\n");
        }

        return str.toString();
        
    }

    public String FClass.dependencyDiagnostics() {
        
        StringBuilder str = new StringBuilder();
            
        if (myOptions().getBooleanOption("equation_sorting")) {
            
            str.append("Variable dependencies:\n");
            
            if (getNumFVariable() > myOptions().getIntegerOption("diagnostics_limit")) {
                str.append("Oh dear, the model has way to many variables (" + getNumFVariable() + ")!\n");
                str.append("Current limit is set to " + myOptions().getIntegerOption("diagnostics_limit") + ", you can change this by changing the option 'diagnostics_limit'.\n");
                return str.toString();
            }
            
            str.append("Derivative variables: \n");
            for (FVariable fv : derivativeVariables()) {
                str.append(" " + fv.name() + "\n");
                for (FVariable d : fv.dependsOn()) {
                    str.append("    " + d.name() + "\n");
                }
            }
            str.append("\n");
            str.append("Differentiated variables: \n");
            for (FVariable fv : differentiatedRealVariables()) {
                str.append(" " + fv.name() + "\n");
                for (FVariable d : fv.dependsOn()) {
                    str.append("    " + d.name() + "\n");
                }
            }
            str.append("\n");
            str.append("Algebraic real variables: \n");
            for (FVariable fv : algebraicContinousRealVariables()) {
                str.append(" " + fv.name() + "\n");
                for (FVariable d : fv.dependsOn()) {
                    str.append("    " + d.name() + "\n");
                }
            }
            str.append("\n");
        }
        return str.toString();
    }
    
    public String FClass.directDependencyDiagnostics() {
        StringBuilder sb = new StringBuilder();
        for (FVariable output : realOutputs()) {
            sb.append(output.name());
            sb.append("\n");
            for (FVariable input : output.directDependencies()) {
                sb.append("    ");
                sb.append(input.name());
                sb.append("\n");
            }
        }
        return sb.toString();
    }
    
    public Set<FVariable> FVariable.directDependencies() {
        Set<FVariable> res = new LinkedHashSet<FVariable>();
        for (FVariable dv : dependsOn()) {
            if (dv.isInput()) {
                res.add(dv);
            }
        }
        return res;
    }
    
    public String FClass.incidence() {
        StringBuilder str = new StringBuilder();
        
        LinkedHashSet<FVariable> h;
        LinkedHashSet<FDerivativeVariable> dh;
        
        str.append("Incidence:\n");
        
        int i = 0;
        for (FAbstractEquation fe : equations()) {
            str.append(" eq " + i + ": ");
            dh = fe.derivativeVariables();
            for (FVariable fv : dh) {
                str.append(fv.name() + " ");
            }
            h = fe.algebraicVariables();
            for (FVariable fv : h) {
                str.append(fv.name() + " ");
            }
            str.append("\n");
//          str.append(fe.getClass().getName() + " " + fe.prettyPrint(""));
//          str.append("\n");
            i++;
        }
        
        return str.toString();
        
    }
    
    public String FClass.dersAndDiffs() {
        StringBuilder str = new StringBuilder();
        str.append("Derivatives and differentiated variables:\n");
        for (FDerivativeVariable fdv : derivativeVariables()) {
            if (fdv.myDifferentiatedVariable()!=null) {
                str.append(" " + fdv.name() + ", " + fdv.myDifferentiatedVariable().name() + "\n");
            }
        }   
        str.append("Differentiated variables and derivatives:\n");
        for (FVariable fv : differentiatedRealVariables()) {
            if (fv.myDerivativeVariable()!=null) {
                str.append(" " + fv.name() + ", " + fv.myDerivativeVariable().name() + "\n");
            }
        }
        return str.toString();
        
    }
    
    public String FClass.printDAEBLT() {
        return getDAEBLT() == null ? "" : getDAEBLT().toString();
    }

    public String FClass.printDAEInitBLT() {
        return getDAEInitBLT().toString();
    }
    
    public String FClass.printMatchedDAE() {
        return computeMatchedDAEBiPGraph().toString();
    }


    syn String FClass.attributeLevels() {
        StringBuilder str = new StringBuilder();
        str.append("Variables:\n");
        for (FVariable v : getFVariables())
            v.attributeLevels(str);
        for (FVariable v : getAliasVariables())
            v.attributeLevels(str);
        if (getNumFDerivedType() > 0) {
            str.append("\nTypes:\n");
            for (FDerivedType t : getFDerivedTypes())
                t.attributeLevels(str);
        }
        return str.toString();
    }

    public void FVariable.attributeLevels(StringBuilder str) {
        str.append("  ");
        str.append(name());
        attributeLevelsForList(getFAttributes(), str);
        str.append("\n");
    }

    public void FDerivedType.attributeLevels(StringBuilder str) {
        str.append("  ");
        str.append(getName());
        attributeLevelsForList(getFAttributes(), str);
        str.append("\n");
    }

    public void FAttribute.attributeLevels(StringBuilder str) {
        str.append(name());
        str.append(":");
        str.append(getLevel());
        attributeLevelsForList(getFAttributes(), str);
        if (hasValue()) {
            str.append("=");
            str.append(getValue());
        }
    }

    public static void ASTNode.attributeLevelsForList(List<FAttribute> l, StringBuilder str) {
        if (l.getNumChild() > 0) {
            str.append("(");
            String sep = ", ";
            String pref = "";
            for (FAttribute a : l) {
                str.append(pref);
                a.attributeLevels(str);
                pref = sep;
            }
            str.append(")");
        }
    }

}

aspect FlatAlgorithmAPI {
    
    syn boolean FIdUseExp.inFAlgorithm() = myFAlgorithm() != null;
    
    syn FAlgorithm FIdUseExp.myFAlgorithm() = getFIdUse().myFAlgorithm();
    inh lazy FAlgorithm FIdUse.myFAlgorithm();
    inh lazy FAlgorithm FStatement.myFAlgorithm();
    inh FAlgorithm FExp.myFAlgorithm();
    eq FAbstractEquation.getChild().myFAlgorithm() = null;
    eq FAlgorithm.getChild().myFAlgorithm() = this;
    eq Root.getChild().myFAlgorithm() = null;
    
    coll ArrayList<FAlgorithm> FClass.myAlgorithms()
        [new ArrayList<FAlgorithm>()] with add root FClass;
    FAlgorithm contributes this when !inFunction()
        to FClass.myAlgorithms() for myFClass();
    
    inh boolean FIdUse.useIsAssignment();
    inh boolean FAssignableExp.useIsAssignment();
    inh boolean FArray.useIsAssignment();
    inh boolean FRecordConstructor.useIsAssignment();
    eq FAssignStmt.getLeft().useIsAssignment()       = true;
    eq FFunctionCallLeft.getFExp().useIsAssignment() = true;
    eq FAssignableExp.getChild().useIsAssignment()   = useIsAssignment();
    eq FArraySubscripts.getChild().useIsAssignment() = false;
    eq FArray.getFExp().useIsAssignment()            = useIsAssignment();
    eq FRecordConstructor.getArg().useIsAssignment() = useIsAssignment();
    eq FExp.getChild().useIsAssignment()             = false;
    eq FStatement.getChild().useIsAssignment()       = false;
    eq FAlgorithm.getChild().useIsAssignment()       = false;
    eq Root.getChild().useIsAssignment()             = false;
    
    private String FAlgorithm.functionName = null;
    public String FAlgorithm.generateFunctionName() {
        if (functionName == null)
            functionName = myFClass().generateFunctionName();
        return functionName;
    }
    private int FClass.generatedFunctionNumber = 1;
    public String FClass.generateFunctionName() {
        String name, part;
        do {
            part = "algorithm_" + generatedFunctionNumber;
            name = name() + "." + part;
            generatedFunctionNumber++;
        } while (lookupFunc(name) != null || variablesMap().lookup(part) != null);
        return name;
    }
    
}

aspect FlatExternalFunctionAPI {
    
    /**
     * Gives the arguments to pass to gcc required by external functions.
     */
    syn String FClass.externalCompilerArgs() {
        StringBuilder buf = new StringBuilder();
        for (String lib : externalLibraries()) {
            buf.append(" -l");
            buf.append(lib);
        }
        for (String dir : externalLibraryDirectories()) {
            buf.append(" -L");
            buf.append(dir);
        }
        for (String dir : externalIncludeDirectories()) {
            buf.append(" -I");
            buf.append(dir);
        }
        return buf.toString();
    }

    syn String FClass.externalLibArgs() {
        StringBuilder buf = new StringBuilder();
        for (String lib : externalLibraries()) {
            buf.append(" -l");
            buf.append(lib);
        }
        for (String dir : externalLibraryDirectories()) {
            buf.append(" -L");
            buf.append(dir);
        }
        return buf.toString();
    }

    syn String FClass.externalIncludeArgs() {
        StringBuilder buf = new StringBuilder();
        for (String dir : externalIncludeDirectories()) {
            buf.append(" -I");
            buf.append(dir);
        }
        return buf.toString();
    }
    
    coll HashSet<FExternalStmt> FClass.myExternals()
        [new HashSet<FExternalStmt>()] with add root FClass;
    FExternalStmt contributes this
        to FClass.myExternals() for myFClass();
    
    syn HashSet<String> FClass.externalLibraries() {
        HashSet<String> res = new HashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.library() != null)
                for (String lib : ext.library())
                    res.add(lib);
        return res;
    }
    
    syn HashSet<String> FClass.externalIncludes() {
        HashSet<String> res = new HashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.include() != null)
                res.add(ext.include());
        return res;
    }
    
    syn HashSet<String> FClass.externalLibraryDirectories() {
        HashSet<String> res = new HashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.libraryDirectory() != null)
                res.add(ext.libraryDirectory());
        return res;
    }
    
    syn HashSet<String> FClass.externalIncludeDirectories() {
        HashSet<String> res = new HashSet<String>();
        for (FExternalStmt ext : myExternals())
            if (ext.includeDirectory() != null)
                res.add(ext.includeDirectory());
        return res;
    }
    
    syn String[] FExternalStmt.library() = library;
    syn String FExternalStmt.include()            = include;
    syn String FExternalStmt.libraryDirectory()   = libraryDir;
    syn String FExternalStmt.includeDirectory()   = includeDir;

    private String[] FExternalStmt.library;
    private String FExternalStmt.include;
    private String FExternalStmt.libraryDir;
    private String FExternalStmt.includeDir;
    
    public void FExternalStmt.extractLibrary(InstExternal n) {
        library = n.annotation("Library").asStringVector();
        include = n.annotation("Include").string();
        libraryDir = n.annotation("LibraryDirectory").string();
        includeDir = n.annotation("IncludeDirectory").string();
        
        if (libraryDir == null || includeDir == null) {
            String libraryName = n.libraryName();
            if (libraryName != null) {
                String defDir = "modelica://" + libraryName + "/Resources";
                libraryDir = (libraryDir == null && library != null) ? 
                        defDir + "/Library" : libraryDir;
                includeDir = (includeDir == null && include != null) ? 
                        defDir + "/Include" : includeDir;
            }
        }
        
        if (includeDir != null) 
            includeDir = n.uri2path(includeDir);
        if (libraryDir != null) {
            libraryDir = n.uri2path(libraryDir);
        }
    }
    
    /**
     * Converts an URI to a file-system path.
     * 
     * Only modelica:// and file:// URIs are supported.
     * 
     * @param str  the string to interpret as an URI
     */
    public String InstExternal.uri2path(String str) {
        try {
            URI uri = new URI(str);
            if (uri.getScheme().equals("file")) {
                return uri.getPath();
            } else if (uri.getScheme().equals("modelica")) {
                String pack = new File(packagePath(uri.getAuthority())).getAbsolutePath();
                return pack != null ? pack + uri.getPath() : null;
            }
        } catch (URISyntaxException e) {
        }
        return null;
    }
    
}

aspect Sparsity {

    // There are no free parameters in the Modelica compiler
    // but these attributes are refined in the Optimica compiler
    syn lazy int FClass.freeParametersEquationSparsity_n_nz() {
        return 0;
    }
    
    syn lazy ArrayList<Integer>[] FClass.freeParametersEquationSparsity() {
        ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numFreeParameters()];
        
        for (int i=0; i<numFreeParameters(); i++) {
            sp[i] = new ArrayList<Integer>();
        }
                
        return sp;
        
    }

    public void FAbstractEquation.calculateEquationSparsity(
            ArrayList<Integer>[] sp, int i, Set<? extends FVariable> vars, int offset) {
        for (int j = 0; j < numScalarEquations(); j++) {
            for (FVariable fv : vars) {
                sp[fv.indexInZ() - offset].add(new Integer(i)); 
            }
            i++;
        }
    }

    public void FFunctionCallEquation.calculateEquationSparsity(
            ArrayList<Integer>[] sp, int i, Set<? extends FVariable> vars, int offset) {
        Set<FVariable> rv = FClass.intersectFVSet(referencedFVariablesInRHS(), vars);
//      Set<FVariable> lv = FClass.intersectFVSet(referencedFVariablesInLHS(), vars);
        Set<FVariable> lv = referencedFVariablesInLHS();
        
        for (FVariable fv : lv) {
//          sp[fv.indexInZ() - offset].add(new Integer(i)); 
            if (vars.contains(fv))
                sp[fv.indexInZ() - offset].add(new Integer(i)); 
            for (FVariable ffv : rv) {
                if (ffv != fv) {
                    sp[ffv.indexInZ() - offset].add(new Integer(i)); 
                }
            }
            i++;     
        }
    }

    syn lazy int FClass.derivativeVariablesEquationSparsity_n_nz() {
        int n_nz = 0;
        ArrayList<Integer>[] sp = derivativeVariablesEquationSparsity();
        for (int j=0; j<numDerivativeVariables(); j++) {
            n_nz += sp[j].size();
        }
        return n_nz;        
    }

    syn lazy ArrayList<Integer>[] FClass.derivativeVariablesEquationSparsity() {
        
        ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numDerivativeVariables()];
        
        for (int i=0; i<numDerivativeVariables(); i++) {
            sp[i] = new ArrayList<Integer>();
        }
        
        int i = 0;
        for (FAbstractEquation fe : equations()) {
            fe.derivativeVariablesEquationSparsity(sp,i);
            i += fe.numScalarEquations();
        }
        return sp;      
    }

    public void FAbstractEquation.derivativeVariablesEquationSparsity(ArrayList<Integer>[] sp, int i) {
        calculateEquationSparsity(sp, i, derivativeVariables(), myFClass().derivativeVariablesOffset());
    }

    syn lazy int FClass.differentiatedRealVariablesEquationSparsity_n_nz() {
        int n_nz = 0;
        ArrayList<Integer>[] sp = differentiatedRealVariablesEquationSparsity();
        for (int j=0; j<numDifferentiatedRealVariables(); j++) {
            n_nz += sp[j].size();
        }
        return n_nz;        
    }

    syn lazy ArrayList<Integer>[] FClass.differentiatedRealVariablesEquationSparsity() {
        
        ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numDifferentiatedRealVariables()];
        
        for (int i=0; i<numDifferentiatedRealVariables(); i++) {
            sp[i] = new ArrayList<Integer>();
        }
        
        int i = 0;
        for (FAbstractEquation fe : equations()) {
            fe.differentiatedRealVariablesEquationSparsity(sp,i);
            i += fe.numScalarEquations();
        }
        return sp;      
    }

    public void FAbstractEquation.differentiatedRealVariablesEquationSparsity(ArrayList<Integer>[] sp, int i) {
        calculateEquationSparsity(sp, i, differentiatedRealVariables(), myFClass().differentiatedRealVariablesOffset());
    }
    
    syn lazy int FClass.realInputsEquationSparsity_n_nz() {
        int n_nz = 0;
        ArrayList<Integer>[] sp = realInputsEquationSparsity();
        for (int j=0; j<numRealInputs(); j++) {
            n_nz += sp[j].size();
        }
        return n_nz;        
    }

    syn lazy ArrayList<Integer>[] FClass.realInputsEquationSparsity() {
        
        ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numRealInputs()];
        
        for (int i=0; i<numRealInputs(); i++) {
            sp[i] = new ArrayList<Integer>();
        }
        
        int i = 0;
        for (FAbstractEquation fe : equations()) {
            fe.realInputsEquationSparsity(sp,i);
            i += fe.numScalarEquations();
        }
        return sp;      
    }

    public void FAbstractEquation.realInputsEquationSparsity(ArrayList<Integer>[] sp, int i) {
        calculateEquationSparsity(sp, i, realInputs(), myFClass().realInputsOffset());
    }
    
    syn lazy int FClass.algebraicRealVariablesEquationSparsity_n_nz() {
        int n_nz = 0;
        ArrayList<Integer>[] sp = algebraicRealVariablesEquationSparsity();
        for (int j=0; j<numAlgebraicContinousRealVariables(); j++) {
            n_nz += sp[j].size();
        }
        return n_nz;        
    }

    syn lazy ArrayList<Integer>[] FClass.algebraicRealVariablesEquationSparsity() {
        
        ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numAlgebraicContinousRealVariables()];
        
        for (int i=0; i<numAlgebraicContinousRealVariables(); i++) {
            sp[i] = new ArrayList<Integer>();
        }
        
        int i = 0;
        for (FAbstractEquation fe : equations()) {
            fe.algebraicRealVariablesEquationSparsity(sp,i);
            i += fe.numScalarEquations();
        }
        return sp;      
    }

    public void FAbstractEquation.algebraicRealVariablesEquationSparsity(ArrayList<Integer>[] sp, int i) {
        calculateEquationSparsity(sp, i, algebraicContinousRealVariables(), myFClass().algebraicContinousRealVariablesOffset());
    }

}

aspect ExpressionGeneralisation {
    /**
     * Returns the expression stripped of any negations
     */
    syn FExp FExp.stripNegations()     = this;
    eq FNegExp.stripNegations()        = getFExp().stripNegations();
    
    
    syn boolean FEquation.isNegated() = getLeft().isNegated() ^ getRight().isNegated();
    
    /**
     * Check if the expressions is negated
     */
    syn boolean FExp.isNegated()  = false;
    eq FNegExp.isNegated()        = !getFExp().isNegated();
    
    /**
     * Return this expression negated if <code>neg</code> is true.
     */
    syn FExp FExp.negated(boolean neg) {
        if (neg)
            return new FNegExp(unboundCopy());
        else
            return unboundCopy();
    }
}
