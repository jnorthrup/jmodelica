
/*
Copyright (C) 2009 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/** \file XMLGenerator.java
*  \brief XMLGenerator class.
*/


import java.io.PrintStream;

/**
 * A generator class for XML code generation which takes an Optimica model described by
 * <FClass> and provides an XML document for the meta-data in the model. Uses a
 * template for the static general structure of tags and an internal class
 * <TagGenerator> for the parts of the XML that are dynamic, that is, may vary
 * depending on the contents of the underlying model.
 * 
 * This class extends XMLVariableGenerator.
 * 
 * @see AbstractGenerator
 * @see XMLVariableGenerator
 * @see TagGenerator
 * 
 */
public class OptimicaXMLVariableGenerator extends XMLVariableGenerator {
		

	/**
	 * Constructor.
	 * 
	 * @param expPrinter Printer object used to generate code for expressions.
	 * @param escapeCharacter Escape characters used to decode tags.
	 * @param fclass An FClass object used as a basis for the code generation.
	 */
	public OptimicaXMLVariableGenerator(Printer expPrinter, char escapeCharacter,
			FClass fclass) {
		super(expPrinter,escapeCharacter, fclass);

	}
	
	@Override
	protected void addRealAttributes(PrintStream genPrinter, TagGenerator tg, FRealVariable realvariable) {
		super.addRealAttributes(genPrinter, tg, realvariable);
		genPrinter.print(tg.generateTag("Free")+realvariable.freeAttribute()+tg.generateTag("Free"));
		double ig_val = 0;
		// If initialGuess attribute is not specified, use start attribute
		if (realvariable.initialGuessAttributeSet()) {
			ig_val = realvariable.initialGuessAttribute();			
		} else {
			ig_val = realvariable.startAttribute();			
		}
		genPrinter.print(tg.generateTag("InitialGuess")+ig_val+tg.generateTag("InitialGuess"));
	}
	
	@Override
	protected void addIntegerAttributes(PrintStream genPrinter, TagGenerator tg, FIntegerVariable integervariable) {
		super.addIntegerAttributes(genPrinter, tg, integervariable);
		genPrinter.print(tg.generateTag("Free")+integervariable.freeAttribute()+tg.generateTag("Free"));
		int ig_val = 0;
		// If initialGuess attribute is not specified, use start attribute
		if (integervariable.initialGuessAttributeSet()) {
			ig_val = integervariable.initialGuessAttribute();			
		} else {
			ig_val = integervariable.startAttribute();			
		}
		genPrinter.print(tg.generateTag("InitialGuess")+ig_val+tg.generateTag("InitialGuess"));
	}
	
	@Override
	protected void addBooleanAttributes(PrintStream genPrinter, TagGenerator tg, FBooleanVariable booleanvariable) {
		super.addBooleanAttributes(genPrinter, tg, booleanvariable);
		genPrinter.print(tg.generateTag("Free")+booleanvariable.freeAttribute()+tg.generateTag("Free"));
		boolean ig_val = false;
		// If initialGuess attribute is not specified, use start attribute
		if (booleanvariable.initialGuessAttributeSet()) {
			ig_val = booleanvariable.initialGuessAttribute();			
		} else {
			ig_val = booleanvariable.startAttribute();			
		}
		genPrinter.print(tg.generateTag("InitialGuess")+ig_val+tg.generateTag("InitialGuess"));
	}
	
	@Override
	protected void addLinearInfo(PrintStream genPrinter, TagGenerator tg, FVariable variable) {
		super.addLinearInfo(genPrinter, tg, variable);
		boolean[] linearTimedVariables = variable.isLinearTimedVariables();
		
		if(linearTimedVariables.length > 0) {
			genPrinter.print(tg.generateTag("isLinearTimedVariables"));
			for(int i=0;i<linearTimedVariables.length;i++) {
				genPrinter.print(tg.generateTag("TimePoint", true));
				genPrinter.print("index=\""+i+"\" isLinear=\""+linearTimedVariables[i]+"\"");
				genPrinter.print(tg.generateTag("TimePoint", true));
			}
			genPrinter.print(tg.generateTag("isLinearTimedVariables"));
		}
	}
	
	class DAETag_XML_Optimization extends DAETag {
		
		public DAETag_XML_Optimization (
		  AbstractGenerator myGenerator, FClass fclass) {
			super("XML_Optimization","Optimization problem's representation",
			  myGenerator,fclass);
		}
		
		/*
		 * (non-Javadoc)
		 * @see org.jmodelica.codegen.AbstractTag#generate(java.io.PrintStream)
		 */
		public void generate(PrintStream genPrinter) {
			String indent="\t\t";
			FOptClass optClass = (FOptClass) fclass;
			
			genPrinter.println("<opt:Optimization>");			
			
			//Objective function
			genPrinter.println(indent+"<opt:ObjectiveFunction>");
			objectiveFunction_XML(genPrinter,optClass,indent+"\t");
			genPrinter.println(indent+"</opt:ObjectiveFunction>");
			
			//Interval start time
			genPrinter.println(indent+"<opt:IntervalStartTime>");	
			intervalStartTime_XML(genPrinter,optClass,indent+"\t");
			genPrinter.println(indent+"</opt:IntervalStartTime>");
			
			//Interval final time
			genPrinter.println(indent+"<opt:IntervalFinalTime>");	
			intervalFinalTime_XML(genPrinter,optClass,indent+"\t");
			genPrinter.println(indent+"</opt:IntervalFinalTime>");
			
			//Time points
			genPrinter.println(indent+"<opt:TimePoints>");	
			timePoints_XML(genPrinter,optClass,indent+"\t");
			genPrinter.println(indent+"</opt:TimePoints>");
						
			//Constraints
			genPrinter.println(indent+"<opt:Constraints>");
			for(FConstraint c : optClass.constraints())
				c.prettyPrint_XML(genPrinter,indent+"\t",c);	
			genPrinter.println(indent+"</opt:Constraints>");
			
			genPrinter.println("\t</opt:Optimization>");
		}
	}
	
	
	//XML code generation for the objective function
	private void objectiveFunction_XML(PrintStream genPrinter, FOptClass optClass, String indent){
		if(optClass.objectiveExp()!=null){
			FExp objFunct = (FExp)optClass.objectiveExp();
			objFunct.prettyPrint_XML(genPrinter,indent);
		}else{
			FStringLitExp strLit = new FStringLitExp();
			genPrinter.println(indent+"<exp:" + strLit.xmlTag() + ">No objective function</exp:"+strLit.xmlTag()+">");
		}	
	}
	
	//XML code generation for interval start time
	private void intervalStartTime_XML(PrintStream genPrinter, FOptClass optClass, String indent){
		genPrinter.println(indent + "<opt:Value>" + optClass.startTimeAttribute() + "</opt:Value>");
		genPrinter.println(indent + "<opt:Free>" + optClass.startTimeFreeAttribute() + "</opt:Free>");
		genPrinter.println(indent + "<opt:InitialGuess>" + optClass.startTimeInitialGuessAttribute() + "</opt:InitialGuess>");
	}
	
	//XML code generation for interval final time
	private void intervalFinalTime_XML(PrintStream genPrinter, FOptClass optClass, String indent){
		genPrinter.println(indent + "<opt:Value>" + optClass.finalTimeAttribute() + "</opt:Value>");
		genPrinter.println(indent + "<opt:Free>" + optClass.finalTimeFreeAttribute() + "</opt:Free>");
		genPrinter.println(indent + "<opt:InitialGuess>" + optClass.finalTimeInitialGuessAttribute() + "</opt:InitialGuess>");
	}
	
	//XML code generatorio for the time points
	private void timePoints_XML(PrintStream genPrinter, FOptClass optClass, String indent){
		double[] points = optClass.timePoints();
		
		for(int i=0;i<points.length;i++) {
			genPrinter.println(indent + "<opt:Index>" + optClass.timePointIndex(points[i]) + "</opt:Index>");
			genPrinter.println(indent + "<opt:Value>" + points[i] + "</opt:Value>");
		}
	}
	
	
	
}

