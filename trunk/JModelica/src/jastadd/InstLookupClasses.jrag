import java.util.HashSet;

aspect InstLookupClasses {

	syn lazy HashSet InstAccess.lookupInstClass() circular [emptyHashSet()]{
	 	return lookupInstClass(name());
	}

	eq InstDot.lookupInstClass() {
	   return getRight().lookupInstClass();
    }
    
	inh HashSet InstAccess.lookupInstClass(String name) circular [emptyHashSet()];
	inh HashSet InstNode.lookupInstClass(String name);
    inh HashSet IModification.lookupInstClass(String name);
		
	eq InstNode.getInstClassDecl(int i).lookupInstClass(String name) = genericLookupInstClass(name); 
	eq InstNode.getInstComponentDecl(int i).lookupInstClass(String name) = genericLookupInstClass(name); 
	eq InstNode.getInstExtends(int i).lookupInstClass(String name) = superLookupInstClass(name);

    eq InstNode.getDynamicClassName().lookupInstClass(String name) = genericLookupInstClass(name);

	eq InstComponentDecl.getInstClassDecl().lookupInstClass(String name) = genericLookupInstClassInComponent(name);	
	eq InstComponentDecl.getInstComponentDecl().lookupInstClass(String name) = genericLookupInstClassInComponent(name);	
	eq InstComponentDecl.getInstExtends().lookupInstClass(String name) = superLookupInstClassInComponent(name);
    eq InstComponentDecl.getDynamicClassName().lookupInstClass(String name) = genericLookupInstClassInComponent(name);
	
	eq InstExtends.getInstClassDecl().lookupInstClass(String name) = genericLookupInstClassInExtends(name);	
	eq InstExtends.getInstComponentDecl().lookupInstClass(String name) = genericLookupInstClassInExtends(name);	
	eq InstExtends.getInstExtends().lookupInstClass(String name) = superLookupInstClassInExtends(name);	
    eq InstExtends.getDynamicClassName().lookupInstClass(String name) = genericLookupInstClassInExtends(name);

	// The lexical scope of modifiers in short classes is the "outer" scope, although
	// the short class declaration is modeled as containing an extends clause
	eq InstExtendsShortClass.getIClassModification().lookupInstClass(String name) = lookupInstClass(name);
	eq InstShortClassDecl.getChild().lookupInstClass(String name) = lookupInstClass(name);
	eq InstReplacingShortClassDecl.getChild().lookupInstClass(String name) = getIClassRedeclare().lookupInstClass(name);
	eq InstReplacingFullClassDecl.getChild().lookupInstClass(String name) = getIClassRedeclare().lookupInstClass(name);
	eq InstReplacingShortClassDecl.getOriginalInstClass().lookupInstClass(String name) = lookupInstClass(name);
	eq InstReplacingFullClassDecl.getOriginalInstClass().lookupInstClass(String name) = lookupInstClass(name);
	
	eq InstReplacingComposite.getOriginalInstComponent().lookupInstClass(String name) = lookupInstClass(name);
	eq InstReplacingPrimitive.getOriginalInstComponent().lookupInstClass(String name) = lookupInstClass(name);
 	eq InstReplacingComposite.getDynamicClassName().lookupInstClass(String name) = lookupInstClass(name);
 	eq InstReplacingPrimitive.getDynamicClassName().lookupInstClass(String name) = lookupInstClass(name);
  
	eq InstReplacingComposite.getClassName().lookupInstClass(String name) = getIComponentRedeclare().lookupInstClass(name);
	eq InstReplacingPrimitive.getClassName().lookupInstClass(String name) = getIComponentRedeclare().lookupInstClass(name);

	syn HashSet InstClassDecl.lookupInstClassInIClassRedeclare(String name) = emptyHashSet();
	eq InstReplacingShortClassDecl.lookupInstClassInIClassRedeclare(String name) = getIClassRedeclare().lookupInstClass(name);

	syn boolean InstClassDecl.isRedeclared() = false;
	eq InstReplacingShortClassDecl.isRedeclared() = true;

/*
	eq InstComponentDecl.getChild(int i).lookupInstClass(String name) {
		if (getInstNode(i) instanceof InstExtends)
			return myInstClass().superLookupInstClass(name);
		else
		 	return myInstClass().genericLookupInstClass(name); 
	}

	eq InstExtends.getInstNode(int i).lookupInstClass(String name) {
		if (getInstNode(i) instanceof InstExtends)
			return getClassName().myInstClassDecl().superLookupInstClass(name);
		else
		 	return getClassName().myInstClassDecl().genericLookupInstClass(name); 
	}
*/



/*	
	eq InstFullClassDecl.getSuper(int i).lookupInstClass(String name) {
	  HashSet h = superLookupInstClass(name);
	  return h;
	}  
*/		
	eq SourceRoot.getChild().lookupInstClass(String name) = emptyHashSet();
	
	// This equation is necessary since InstAccesses may be present in FExps.
	eq FlatRoot.getChild().lookupInstClass(String name) = emptyHashSet();
	
	syn lazy HashSet InstProgramRoot.lookupElementInstClass(String name) {
		HashSet set = new HashSet(4);
		for (InstClassDecl bcd : instClassDecls()) {
			if (bcd.matchInstClassDecl(name))
				set.add(bcd);	
		}

		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	
	syn lazy HashSet InstProgramRoot.lookupInstPredefinedType(String name) {
		HashSet set = new HashSet(4);
		for (InstClassDecl bcd : getInstPredefinedTypes()) {
			if (bcd.matchInstClassDecl(name))
				set.add(bcd);	
		}

		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}


	syn lazy HashSet InstProgramRoot.lookupInstBuiltInFunction(String name) {
		HashSet set = new HashSet(4);
		for (InstClassDecl bcd : getInstBuiltInFunctions()) {
			if (bcd.matchInstClassDecl(name))
				set.add(bcd);	
		}		
		
		
		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
/*
	syn lazy HashSet SourceRoot.lookupLibrary(String name) {
		HashSet set = new HashSet(4);
		for (int i=0;i<getNumLibNode();i++) {
			if (getLibNode(i).getName().equals(name))
				set.add(getLibNode(i).getClassDecl());
		}
		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	*/
	eq InstProgramRoot.getChild().lookupInstClass(String name) = genericLookupInstClass(name);
	//eq SourceRoot.getLibNode().lookupInstClass(String name) = genericLookupClass(name);
	

	eq InstProgramRoot.getInstPredefinedType().lookupInstClass(String name) {
		HashSet set = new HashSet(4);
		for (InstClassDecl bcd : getInstBuiltInTypes()) {
			if (bcd.matchInstClassDecl(name))
				set.add(bcd);	
		}		
		

		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}


	syn lazy  HashSet InstProgramRoot.genericLookupInstClass(String name) {
		HashSet set = new HashSet(4);
		
		if (lookupElementInstClass(name).size()>0)
			set.addAll(lookupElementInstClass(name));
		
		if (lookupInstPredefinedType(name).size()>0)
			set.addAll(lookupInstPredefinedType(name));
		
		if (lookupInstBuiltInFunction(name).size()>0)
			set.addAll(lookupInstBuiltInFunction(name));
		
/*		if (lookupLibrary(name).size()>0)
			set.addAll(lookupLibrary(name));
*/

		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	
	eq InstDot.getRight().lookupInstClass(String name) {
		return getLeft().qualifiedLookupInstClass(name);
	}
	
	syn HashSet InstAccess.qualifiedLookupInstClass(String name) circular [emptyHashSet()] = emptyHashSet();	
	eq InstClassAccess.qualifiedLookupInstClass(String name) = myInstClassDecl().memberInstClass(name);

/*
	syn HashSet InstNode.lookupInstClassInImport(String name) circular [emptyHashSet()] = emptyHashSet();
	
	eq InstBaseClassDecl.lookupInstClassInImport(String name) {
		HashSet h;
		for (InstImport ii : getInstImports()) {
	    	h = ii.lookupInstClassInImport(name);
	    	if (h.size()>0)
	    	   return h;
	    }
	    return emptyHashSet();
	}
*/
	// TODO: rewrite so that classes are only looked up in constraining types.	
	syn lazy HashSet InstNode.genericLookupInstClass(String name) circular [emptyHashSet()] {
	
		HashSet set = new HashSet(4);
		
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : instExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}

		for (InstImport ii : instImports()) {
			set.addAll(ii.lookupInstClassInImport(name));		
		}

/*
		if (lookupInstClassInImport(name).size()>0)
			set.addAll(lookupInstClassInImport(name));
	*/
		if (set.size()>0)
			return set;
		else
			return lookupInstClass(name);
	}
	
	syn HashSet InstNode.superLookupInstClass(String name) circular [emptyHashSet()] {
	
		HashSet set = new HashSet();

		/*		
		if (lookupInstClassInImport(name).size()>0)
				set.addAll(lookupInstClassInImport(name));
			*/
		
		for (InstImport ii : instImports()) {
			set.addAll(ii.lookupInstClassInImport(name));		
		}
						
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
					set.add(icd);
			}
		}		
	
		if (set.size()>0)
			return set;
		else
			return lookupInstClass(name);
	}

	// TODO: rewrite so that classes are only looked up in constraining types.	
	syn lazy HashSet InstComponentDecl.genericLookupInstClass(String name) circular [emptyHashSet()] {
	
		HashSet set = new HashSet(4);
		
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : instExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}

		for (InstImport ii : instImports()) {
			set.addAll(ii.lookupInstClassInImport(name));		
		}

/*
		if (lookupInstClassInImport(name).size()>0)
			set.addAll(lookupInstClassInImport(name));
	*/
		if (set.size()>0)
			return set;
		else
			return myInstClass().genericLookupInstClass(name);
	}


	// TODO: rewrite so that classes are only looked up in constraining types.	
	syn lazy HashSet InstComponentDecl.genericLookupInstClassInComponent(String name) circular [emptyHashSet()] {
	    if (myInstClass().isRedeclared())
			return myInstClass().lookupInstClassInIClassRedeclare(name);
		
		HashSet set = new HashSet(4);
		
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : instExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}

		for (InstExtends ie : instExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}

		for (InstImport ii : instImports()) {
			set.addAll(ii.lookupInstClassInImport(name));		
		}

		if (set.size()>0) // Did not find any local class
			return set;
		else // continue search att myInstClass()
			return myInstClass().genericLookupInstClass(name);
	}
	
	syn HashSet InstComponentDecl.superLookupInstClassInComponent(String name) circular [emptyHashSet()] {
		if (myInstClass().isRedeclared())
			return myInstClass().lookupInstClassInIClassRedeclare(name);
		
		HashSet set = new HashSet();

		for (InstImport ii : instImports()) {
			set.addAll(ii.lookupInstClassInImport(name));		
		}
							
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
					set.add(icd);
			}
		}		
	
		if (set.size()>0) //Found local class
			return set;
		else // else search for non-local class
			return myInstClass().superLookupInstClass(name);
	}

	
	// TODO: rewrite so that classes are only looked up in constraining types.	
	syn lazy HashSet InstExtends.genericLookupInstClassInExtends(String name) circular [emptyHashSet()] {
	   	if (getClassName().myInstClassDecl().isRedeclared())
			return getClassName().myInstClassDecl().lookupInstClassInIClassRedeclare(name);
	
		HashSet set = new HashSet(4);
		
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : instExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}
/*
		if (lookupInstClassInImport(name).size()>0)
			set.addAll(lookupInstClassInImport(name));
	*/
	
		if (set.size()>0) // Did not find any local class
			return set;
		else // continue search att myInstClass()
			return getClassName().myInstClassDecl().genericLookupInstClass(name);
	}
	
	syn HashSet InstExtends.superLookupInstClassInExtends(String name) circular [emptyHashSet()] {
	   	if (getClassName().myInstClassDecl().isRedeclared())
			return getClassName().myInstClassDecl().lookupInstClassInIClassRedeclare(name);
		
		HashSet set = new HashSet();
		/*
		if (lookupInstClassInImport(name).size()>0)
				set.addAll(lookupInstClassInImport(name));
			*/		
		for (InstClassDecl icd : instClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
					set.add(icd);
			}
		}		
		if (set.size()>0) //Found local class
			return set;
		else // else search for non-local class
			return getClassName().myInstClassDecl().superLookupInstClass(name);
	}

	syn HashSet InstNode.memberInstClass(String name) circular [emptyHashSet()] = emptyHashSet();
	
	eq InstFullClassDecl.memberInstClass(String name) {
		HashSet set = new HashSet();
		
		for (InstClassDecl icd : constrainingInstClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : constrainingInstExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));

		}
		
		
		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	
	eq InstShortClassDecl.memberInstClass(String name) {
		
		
		if (hasInstConstraining())
			return getInstConstraining().getInstNode().memberInstClass(name);
		else {
/*			HashSet set = new HashSet();
			for (InstExtends ie : instExtends()) {
				HashSet h = ie.getClassName().lookupInstClass();
				if (h.size()==1)
					set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
			}
			return set;
*/
			return getInstExtends(0).memberInstClass(name);			
		 }	
	
	}
	
	eq InstExtends.memberInstClass(String name) {
		HashSet set = new HashSet();
		
		for (InstClassDecl icd : constrainingInstClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : constrainingInstExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}
		
		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	
	eq InstComponentDecl.memberInstClass(String name) {
		HashSet set = new HashSet();
		
		for (InstClassDecl icd : constrainingInstClassDecls()) {
			if (icd.matchInstClassDecl(name)) {
				set.add(icd);
			}
		}
		
		for (InstExtends ie : constrainingInstExtends()) {
			HashSet h = ie.getClassName().lookupInstClass();
			if (h.size()==1)
				set.addAll(((InstClassDecl)h.iterator().next()).memberInstClass(name));
		}
		
		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	
	syn boolean InstClassDecl.matchInstClassDecl(String name) = false;
	eq InstBuiltInClassDecl.matchInstClassDecl(String name) = name().equals(name); 
	eq InstBaseClassDecl.matchInstClassDecl(String name) = name().equals(name);
	
	// This attribute should to be circular due to lookup in import-statements
	// If the lookup is triggered by lookup of A in 'extends A', and
	// there are import statements, evaluation might get back to the 
	// ClassAccess A when when looking up the ClassAccess to import.
	// See NameTests.ImportTest1 for an example. 
	syn lazy InstClassDecl InstAccess.myInstClassDecl() circular [unknownInstClassDecl()] {
		 return unknownInstClassDecl();
	}
	eq InstClassAccess.myInstClassDecl()  {
		HashSet set = lookupInstClass(name());
		if (set.size() > 0)
			return (InstClassDecl)set.iterator().next();
		else
			return unknownInstClassDecl();
	}
	eq InstDot.myInstClassDecl() {
	 	return getRight().myInstClassDecl();
	}	
	
	syn lazy InstClassDecl InstNode.myInstClass() circular [unknownInstClassDecl()] = unknownInstClassDecl(); 
	eq InstComponentDecl.myInstClass() = getClassName().myInstClassDecl();
	//eq InstShortClassDecl.myInstClass()  = getClassName().myInstClassDecl();
	eq InstClassDecl.myInstClass() = this;
	eq InstExtends.myInstClass() = getClassName().myInstClassDecl();
	eq UnknownInstComponentDecl.myInstClass() = unknownInstClassDecl();	

	
}

aspect InstLookupImport {

	inh HashSet InstImport.lookupImportInstClass(String name) circular [emptyHashSet()];
	
	eq InstRoot.getChild().lookupImportInstClass(String name) = emptyHashSet();
	
	eq InstImport.getPackageName().lookupInstClass(String name) {
	 	HashSet h = lookupImportInstClass(name);
	 	return h;
	}
	    	
	eq InstProgramRoot.getChild().lookupImportInstClass(String name) {
		HashSet set = new HashSet(4);
		
		if (lookupElementInstClass(name).size()>0)
			set.addAll(lookupElementInstClass(name));
	/*
		if (lookupLibrary(name).size()>0)
			set.addAll(lookupLibrary(name));
    */

		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	
	/*
	eq Program.getLibNode().lookupImportClass(String name) {
		HashSet set = new HashSet(4);

		if (lookupLibrary(name).size()>0)
			set.addAll(lookupLibrary(name));
			
		if (set.size()>0)
			return set;
		else
			return emptyHashSet();
	}
	*/
	
	syn HashSet InstImport.lookupInstClassInImport(String name) circular [emptyHashSet()];
	
	eq InstImportQualified.lookupInstClassInImport(String name)   {
	    if (name.equals(getPackageName().getLastInstAccess().name())) {
   		  return getPackageName().lookupInstClass();
		} else
			return emptyHashSet();
	}
	
	eq InstImportUnqualified.lookupInstClassInImport(String name)  {
		return getPackageName().myInstClassDecl().memberInstClass(name);
	}
	
	eq InstImportRename.lookupInstClassInImport(String name)  {
	    
		// Does the alias name match?
		if (name.equals(((ImportClauseRename)getImportClause()).getIdDecl().getID())) {
			return getPackageName().lookupInstClass();
			
		} else
			return emptyHashSet();
	}
	
}

aspect InstLocalClasses {

	syn InstClassDecl InstClassDecl.localInstClassDecl(int i) = null;
	eq InstFullClassDecl.localInstClassDecl(int i) = instClassDecls().get(i);
	
	syn int InstClassDecl.numLocalInstClassDecl() = 0;
	eq InstFullClassDecl.numLocalInstClassDecl() = instClassDecls().size();

}

aspect InstLookupClassesInModifications {

	inh HashSet IElementModification.lookupInstClassInInstClass(String name);	

	eq IElementModification.getName().lookupInstClass(String name) = lookupInstClassInInstClass(name);

	eq InstComponentDecl.getIModification().lookupInstClassInInstClass(String name) = /*myInstClass().*/memberInstClass(name);		
	eq IElementModification.getIModification().lookupInstClassInInstClass(String name) = getName().myInstComponentDecl().memberInstClass(name);
	eq InstExtends.getIClassModification().lookupInstClassInInstClass(String name) = /*getClassName().myInstClassDecl().*/memberInstClass(name);
	
//	eq InstShortClassDecl.getIClassModification().lookupInstClassInInstClass(String name) = getClassName().myInstClassDecl().memberInstClass(name);
	
	inh HashSet IClassRedeclare.lookupInstClassInInstClass(String name);
	eq IClassRedeclare.getName().lookupInstClass(String name) = lookupInstClassInInstClass(name);
	
	/**
	 * Terminating equation for attribute lookupInstClassInInstClass.
	 */
	eq InstRoot.getChild().lookupInstClassInInstClass(String name) {return emptyHashSet();}
	  
}



