aspect Types { 

   class Type {
      ArrayList<InstModification> env;
	
	  public boolean subType(Type t) {
	  	return false;
	  }

        public boolean superTypeComponentType(ComponentType t) {
          return false;
        }
        
        public boolean superTypeClassType(ClassType t) {
          return false;
        }
        
        public String name() {
          return getClass().getName();
        }
        
   }

	class ComponentType extends Type{
        ComponentDecl compDecl;
        
        public ComponentType(ComponentDecl compDecl, ArrayList<InstModification> env) {
	      this.compDecl = compDecl;
	      this.env = env;
		}
        
        public String toString() {
           StringBuffer str = new StringBuffer();
           str.append(compDecl.prettyPrint(""));
           str.append("\nEnv=");
           for (InstModification im : env) { 
	           str.append(im.getModification().prettyPrint("")+"\n");
	       }
           return str.toString();
         
        }
        
        public String name() {
           return compDecl.prettyPrint("");
        }
 
        
        public boolean subType(Type t) {
           return t.superTypeComponentType(this);
        }
        
        public boolean superTypeComponentType(ComponentType subType) {
           if (subType == this) return true;
           ComponentType superType = this;
                      
           if ((compDecl.myClass() instanceof PrimitiveClassDecl)) {
             if (subType.compDecl.myClass()== superType.compDecl.myClass())
             	return true;
           }  else if ((compDecl.myClass() instanceof FullClassDecl)) {
         
              FullClassDecl superClassDecl = (FullClassDecl)superType.compDecl.myClass();
              ArrayList<InstModification> superEnv = superType.env;
              
              if (compDecl.hasConstrainingClause()) {
              	ClassDecl cd_tmp = compDecl.getConstrainingClause().getAccess().myClassDecl();
              	if (cd_tmp instanceof FullClassDecl) {
              		superClassDecl = (FullClassDecl)cd_tmp;
                    superEnv = new ArrayList<InstModification>();
	                for (InstModification im : (List<InstModification>)compDecl.getConstrainingClause().constrainingClauseInstRoot().getInstNode(0).myEnvironment()) {
	    	          superEnv.add(im);
	                } 
                 }
              }	
              
         	  for (ComponentDecl superTypeComponent : superClassDecl.getComponentDecls()) {
           		  String cdName = superTypeComponent.name();
           		  HashSet set = subType.compDecl.myClass().memberComponent(cdName);
           	   if (set.size()!=1)
           	   	return false;
           	   ComponentDecl subTypeComponent = (ComponentDecl)set.iterator().next();	
           	   Type superTypeComponentType = type(superTypeComponent,superEnv);
           	   Type subTypeComponentType = type(subTypeComponent,subType.env);	
           	   if (!subTypeComponentType.subType(superTypeComponentType))
           	   	return false;
           	  }
           	}
           	
           return true;
        }
        
        
   		public static Type type(ComponentDecl cd) {
           return type(cd,new ArrayList<InstModification>());
        }
       
   		public static Type type(ComponentDecl cd, ArrayList<InstModification> env) {
   		   	  	  	  	 
   		  ComponentDecl replacingComponent = cd; 
   		  	  	 
	   	  for (InstModification im : env) {
			if (im.getModification().matchRedeclare(cd.name())!=null) {
				replacingComponent = im.getModification().matchRedeclare(cd.name());
			    break;
			}
		  }
	     
	     ArrayList<InstModification> newEnv = new ArrayList<InstModification>();
	     
	     for (InstModification im : env) {
			Modification m = im.getModification().matchModification(cd.name());
			if (m!=null)
				newEnv.add(new InstModification(im.getInstNode(),m));
		}
	     
	     // Add modifications at the declaration to env
	     
	     return new ComponentType(replacingComponent,newEnv);   
   		
   		}
   
   }
   
	class ClassType extends Type{
	
		ClassDecl classDecl;
		
		public ClassType(ClassDecl classDecl, ArrayList<InstModification> env) {
	      this.classDecl = classDecl;
	      this.env = env;
		}

		public ClassType(ClassDecl classDecl) {
	      this(classDecl,new ArrayList<InstModification>());
		}

       public String toString() {
           StringBuffer str = new StringBuffer();
           str.append(classDecl.name());
           str.append("\nEnv=");
           for (InstModification im : env) { 
	           str.append(im.getModification().prettyPrint("")+"\n");
	       }
           return str.toString();
         
        }
           
        public String name() {
           return classDecl.name();
        }
 

        public boolean subType(Type t) {
           return t.superTypeClassType(this);
        }
        
        public boolean superTypeClassType(ClassType t) {
           if (t == this) return true;
           if (!(classDecl instanceof FullClassDecl) || 
               !(t.classDecl instanceof FullClassDecl))
               	return false;
           FullClassDecl superClassDecl = (FullClassDecl)classDecl;
           FullClassDecl subClassDecl = (FullClassDecl)t.classDecl;
           for (ComponentDecl superTypeComponent : superClassDecl.getComponentDecls()) {
           		String cdName = superTypeComponent.name();
           		HashSet set = subClassDecl.memberComponent(cdName);
           	    if (set.size()!=1)
           	   	  return false;
           	    ComponentDecl subTypeComponent = (ComponentDecl)set.iterator().next();	
           	    Type superTypeComponentType = ComponentType.type(superTypeComponent);
           	     Type subTypeComponentType = ComponentType.type(subTypeComponent);	
           	   if (!subTypeComponentType.subType(superTypeComponentType))
           	   	return false;
           	  }
            // TODO: check local classes.
            return true;
            
    
        }

	    
	   
	   /*
	   
	   public ArrayList<String> getMemberClassNames() {
	   		ArrayList<String> nameList = new ArrayList<String>();
	        for (ComponentDecl d : classDecl.getComponentDecls())
	        	nameList.add(d.name()); 
	        for (ClassDecl cd : classDecl.getClassDecls())
	        	nameList.add(cd.name()); 
            return nameList;
	   } 

       public ArrayList<String> getMemberComponentNames() {
	  
	  public ClassType getClassTypeOfComponent(String name) {
	  	 
	     // Find first component redeclare
         ComponentDecl replacingCD = retrieveReplacingDecl(name);
         if (replacingCD==null)
            replacingCD = classDecl.memberComponent(name);
	     
	     ArrayList<InstModification> newEnv = new ArrayList<InstModification>();    
	     for (InstModification im : env) {
			Modification m = im.getModification().matchModification(name);
			if (m!=null)
				newEnv.add(new InstModification(im.getInstNode(),m));
		}
	     
	     return new ClassType(replacingCD.myClassDecl(),newEnv);   
	      
	  }
	  
	  */
	    
	}


    public void InstComposite.typeCheck() {
       
       if (getComponentDecl().hasConstrainingClause()) {
       // First type check the constraining clause itself by building the instance tree.
          instConstrainingClause().collectErrors();
                  
          // Then type check the constraining clause in relation to the declaration itself.
          ClassType subType = new ClassType(getComponentDecl().myClass());
          ClassType superType = new ClassType(getComponentDecl().getConstrainingClause().getAccess().myClassDecl());
          if (!subType.subType(superType))
        	   getComponentDecl().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
       }
       
       
    } 

	public void InstReplacingComponent.typeCheck() {
	    /*
	       This is questionable. Rather, the original declaration should actually
	       have been checked previously, when the enclosing class decl is checked in 
	       an empty environment.
	    */
		if (getOriginalDecl().hasConstrainingClause()) { 
          // First type check the constraining clause itself by building the instance tree.
          originalInstConstrainingClause().collectErrors();
          ArrayList<InstModification> env = new ArrayList<InstModification>();
	      for (InstModification im : (List<InstModification>)originalInstConstrainingClause().myEnvironment()) {
	    	 env.add(im);
	      } 


	         // Then type check the constraining clause in relation to the declaration itself.
          ClassType subType = new ClassType(getOriginalDecl().myClass());
          ClassType superType = new ClassType(getOriginalDecl().getConstrainingClause().getAccess().myClassDecl(),env);
          if (!subType.subType(superType))
        	   getOriginalDecl().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
       }
 
	
	   
	   if (getComponentDecl().hasConstrainingClause()) { 
          // First type check the constraining clause itself by building the instance tree.
          instConstrainingClause().collectErrors();

	         // Then type check the constraining clause in relation to the declaration itself.
          ClassType subType = new ClassType(getComponentDecl().myClass());
          ClassType superType = new ClassType(getComponentDecl().getConstrainingClause().getAccess().myClassDecl());
          if (!subType.subType(superType))
        	   getComponentDecl().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
       }
 
	
	
	    ArrayList<InstModification> env = new ArrayList<InstModification>();
	    for (InstModification im : (List<InstModification>)myEnvironment(name())) {
	    	env.add(im);
	    }

        for (InstModification im : (List<InstModification>)myEnvironment()) {
	   	 if (im.getModification().matchRedeclare(name())!=null) {
	   	        ComponentDecl replacingDecl = im.getModification().matchRedeclare(name());
	   	        if (replacingDecl.hasConstrainingClause()) {
    	   	          ClassType superType = new ClassType(getOriginalDecl().myClass());	
	                  ClassType subType = new ClassType(replacingDecl.getConstrainingClause().getAccess().myClassDecl());
	   	            if (!subType.subType(superType))
        	         replacingDecl.getConstrainingClause().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
			          
	   	        } else {
                  ComponentType superType = new ComponentType(getOriginalDecl(),new ArrayList<InstModification>());
				  ComponentType subType = new ComponentType(replacingDecl,env);
		          if (!subType.subType(superType))
        	         subType.compDecl.error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
			    }
			}
	   }	
       
        	
        // Check subtype for ALL redeclarations in myEnvironment!!
        
        // If there is a constraining clause: type check this as well, taking
        // modifications intoaccount.		
        		
	}

	public String InstReplacingComponent.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstReplacingComponent:\n");
	   str.append(" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   for (InstModification im : (List<InstModification>)myEnvironment()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }
	   str.append(" mergedEnvironment():\n");
	   for (InstModification im : (List<InstModification>)getMergedEnvironments()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }	
	   return str.toString();	
	}
	
    public String InstConstrainingClause.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstConstrainingClause:\n");
	   str.append(" ConstrainingClause: " + getConstrainingClause().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   for (InstModification im : (List<InstModification>)myEnvironment()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }
	   str.append(" mergedEnvironment():\n");
	   for (InstModification im : (List<InstModification>)getMergedEnvironments()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }	
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstPrimitive:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   for (InstModification im : (List<InstModification>)myEnvironment()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }
	   str.append(" mergedEnvironment():\n");
	   for (InstModification im : (List<InstModification>)getMergedEnvironments()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }	
	   return str.toString();	
	}

	public String InstComposite.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstComposite:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   for (InstModification im : (List<InstModification>)myEnvironment()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }
	   str.append(" mergedEnvironment():\n");
	   for (InstModification im : (List<InstModification>)getMergedEnvironments()) {
	   	 str.append("  "+im.getModification().prettyPrint("")+"\n");
	   }	
	   return str.toString();	
	}



    public String InstModification.toString() {
    	return getModification().prettyPrint("");
    
    }

}

aspect TypeErrorCheck {

 
  public void InstNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(InstNode n : getInstNodes()) {
		  n.collectErrors();
	  }
  }


}