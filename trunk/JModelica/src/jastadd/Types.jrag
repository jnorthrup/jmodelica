aspect Types { 
  
   /* DynamicInstList contains type representations that are created
      dynamically during type checking.
    */
   syn lazy List InstNode.getDynamicInstList() = new List();
   
   /* DynamicInstConstrainingList contains type representations that are created
      dynamically during type checking and should be flattened as constraining types.
    */
   syn lazy List InstNode.getDynamicInstConstrainingList() = new List();


   syn lazy InstComposite InstNode.createDynamicInstComposite(ComponentDecl decl) {
      // TODO: Check for redeclares
   	  InstComposite ic = new InstComposite(new List(),decl,decl.myClass());
   	  addDynamicInst(ic);
   	  ic.is$Final(true); // TODO: Is this really ok...?
   	  return ic;
   }
   
   syn lazy InstComposite InstNode.createDynamicInstConstrainingComposite(ComponentDecl decl) {
   	  // TODO: Check for redeclares
   	  InstComposite ic = new InstComposite(new List(),decl,decl.myClass());
   	  addDynamicInstConstraining(ic);
   	  ic.is$Final(true); // TODO: Is this really ok...?
   	  return ic;
   }
  
   // This attribute is used to check if the instance tree should be built based only on constraining types
   inh boolean InstNode.constrainingType();
   eq InstRoot.getChild().constrainingType() = false;
   eq InstNode.getDynamicInstConstraining().constrainingType() = true;
   eq BaseClassDecl.getInstRoot().constrainingType() = false;
  
   syn String InstNode.className() = "";
   syn String InstComponent.className() = getComponentDecl().myClass().name();

   // The double dispatch pattern applied to subtype testing.
   syn boolean InstNode.subType(InstNode t) = false;
   syn boolean InstNode.superTypeCompositeType(InstComposite subType) = false;
   syn boolean InstNode.superTypeClassType(InstRoot subType) = false;
   syn boolean InstNode.superTypePrimitiveComponentType(InstPrimitive subType) = false;
   
   eq InstComposite.subType(InstNode t) = t.superTypeCompositeType(this);
   eq InstPrimitive.subType(InstNode t) = t.superTypePrimitiveComponentType(this);

   eq InstComposite.superTypeCompositeType(InstComposite subType) {
       if (subType == this) return true;
       InstComposite superType = this;
   
       // Check that all elements (here: components) in superType are in subType 
       for (InstNode superTypeComponentInst : containedInstComponents()) {
          HashSet<InstNode> set = subType.memberComponentInst(superTypeComponentInst.name());
          if (set.size()!=1)
          	return false;
          InstNode subTypeComponentInst = set.iterator().next();
          if (!subTypeComponentInst.subType(superTypeComponentInst))
          	return false;
	   }
   	   
   	   return true;
   }
   
   eq InstPrimitive.superTypePrimitiveComponentType(InstPrimitive subType) {
       if (subType == this) return true;
       InstPrimitive superType = this;
       if (subType.className().equals(superType.className()))
       	  return true;
       else   
   	      return false;
   }

  // Rudimentary name analysis framework for looking up instances
  syn lazy HashSet<InstNode> InstNode.memberComponentInst(String name) {
     HashSet<InstNode> set = new HashSet<InstNode>(4);
     for (InstNode node : containedInstComponents()) {
     	// This is to take InstExtends into account
     if (node.name().equals(name))
        set.add(node);
 
     }
     return set;
  }

  syn lazy ArrayList<InstNode> InstNode.containedInstComponents() {
  	ArrayList<InstNode> l = new ArrayList<InstNode>();
    for (InstNode node : getInstNodes()) {
       if (node instanceof InstExtends)
       	  l.addAll(node.containedInstComponents());
       else
         l.add(node);
    }
    return l;
  }
  
  public void InstComposite.typeCheck() {
     // Notice that modifiers (including redeclarations) in a constraining clause
     // are applied to the declaration itself and is therefore also type checked.
     if (getComponentDecl().hasConstrainingClause()) {
         InstComponent superType = createDynamicInstConstrainingComposite(getComponentDecl());
	     InstComponent declaredType = createDynamicInstComposite(getComponentDecl());
    	 if (!declaredType.subType(superType))
     		superType.getComponentDecl().error("In the declaration '" +declaredType.getComponentDecl().prettyPrint("") +"', the declared class is not a subtype of the constraining class");
  	 }
  }
  
  public void InstReplacingComposite.typeCheck() {
     
     // Type check the original component
     InstComponent superType = createDynamicInstConstrainingComposite(getOriginalDecl());
     if (getOriginalDecl().hasConstrainingClause()) {
       InstComponent declaredType = createDynamicInstComposite(getOriginalDecl());
       if (!declaredType.subType(superType))
     	 superType.getComponentDecl().error("In the declaration '" +declaredType.getComponentDecl().prettyPrint("") +"', the declared class is not a subtype of the constraining class");
     }

     // The environment should be traversed backwards in order to perform correct
     // subtype tests in redeclaration chains.     	
       for (int i=myEnvironment().size()-1;i>=0;i--) {
        InstModification im = myEnvironment().get(i);
	   	if (im.getModification().matchComponentRedeclare(name())!=null) { 
           InstComponent constrainingSubType = im.getInstNode().createDynamicInstConstrainingComposite(im.getModification().matchComponentRedeclare(name()));
                        
           // Check consistency of the redeclaring component
           if (constrainingSubType.getComponentDecl().hasConstrainingClause()) {
              InstComponent declaredSubType = im.getInstNode().createDynamicInstComposite(constrainingSubType.getComponentDecl());
              if (!declaredSubType.subType(constrainingSubType))
     	         declaredSubType.getComponentDecl().error("In the declaration '" +declaredSubType.getComponentDecl().prettyPrint("") +"', the declared class is not a subtype of the constraining class");
           }
           
           // It is ok to check against the constrainingSubType, since the declaredSubType is a subtype
           // of the constrainingSubType. Then if constrainingSubType is a subtype of superType, then it
           // follows that declaredSubType is a subtype of superType by transitivity.
           if (!constrainingSubType.subType(superType))
             constrainingSubType.getComponentDecl().error("'" + constrainingSubType.getComponentDecl().prettyPrint("")+ "'"+ " is not a subtype of " + 
                "'"+superType.getComponentDecl().prettyPrint("")+"'");
                
           // If the redeclaring declaration has a constraining clause, the constraining
           // type of the redeclaring declaration of should be used in following subtype-test 
           // instead of the constraining type of the orignal declaration.
           if (constrainingSubType.getComponentDecl().hasConstrainingClause()) {    
              superType = constrainingSubType;
           }    	   
	    }
	 }
  }

}

aspect TypeErrorCheck {

 
  public void InstNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(InstNode n : getInstNodes()) {
		  n.collectErrors();
	  }
  }


}