aspect Types { 
  
   syn String InstNode.className() = "";
   syn String InstComponent.className() = getComponentDecl().myClass().name();


   syn boolean InstNode.subType(InstNode t) = false;
   syn boolean InstNode.superTypeCompositeType(InstComposite subType) = false;
   syn boolean InstNode.superTypeClassType(InstRoot subType) = false;
   syn boolean InstNode.superTypePrimitiveComponentType(InstPrimitive subType) = false;
   
   eq InstComposite.subType(InstNode t) = t.superTypeCompositeType(this);
   eq InstPrimitive.subType(InstNode t) = t.superTypePrimitiveComponentType(this);

   eq InstComposite.superTypeCompositeType(InstComposite subType) {
       if (subType == this) return true;
       InstComposite superType = this;
   
       // Check that all elements (here: components) in superType are in subType 
   
   	   return false;
   }
   
   eq InstPrimitive.superTypePrimitiveComponentType(InstPrimitive subType) {
       if (subType == this) return true;
       InstPrimitive superType = this;
       if (subType.className().equals(superType.className()))
       	  return true;
       else   
   	      return false;
   }

  
  /*
    
   interface Type {
 	
	  public boolean subType(Type t);  
      public boolean superTypeComponentType(ComponentType subType);
      public boolean superTypeClassType(ClassType subType);
      public boolean superTypePrimitiveComponentType(PrimitiveComponentType subType);
      //public boolean superTypePrimitiveClassType(PrimitiveClassType subType);
      public String className();   
   }

   interface ClassType extends Type {
   
   }

   interface ComponentType extends Type {
   
   }

   interface PrimitiveComponentType extends Type {
     
   }

   InstNode implements Type;
   InstRoot implements ClassType;
   InstComposite implements ComponentType;
   InstPrimitive implements PrimitiveComponentType; 

   syn String InstNode.className() = "";
   syn String InstComponent.className() = getComponentDecl().myClass().name();


   syn boolean InstNode.subType(Type t) = false;
   syn boolean InstNode.superTypeComponentType(ComponentType subType) = false;
   syn boolean InstNode.superTypeClassType(ClassType subType) = false;
   syn boolean InstNode.superTypePrimitiveComponentType(PrimitiveComponentType subType) = false;
   
   eq InstComposite.subType(Type t) = t.superTypeComponentType(this);
   eq InstPrimitive.subType(Type t) = t.superTypePrimitiveComponentType(this);

   eq InstComposite.superTypeComponentType(ComponentType subType) {
       if (subType == this) return true;
       ComponentType superType = this;
   
       // Check that all elements (here: components) in superType are in subType 
   
   	   return false;
   }
   
   eq InstPrimitive.superTypePrimitiveComponentType(PrimitiveComponentType subType) {
       if (subType == this) return true;
       PrimitiveComponentType superType = this;
       if (subType.className().equals(superType.className()))
       	  return true;
       else   
   	      return false;
   }
*/
	public String InstReplacingComponent.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstReplacingComponent:\n");
	   str.append(" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstPrimitive:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   return str.toString();	
	}

	public String InstComposite.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstComposite:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   
	   return str.toString();	
	}



    public String InstModification.toString() {
    	return getModification().prettyPrint("");
    
    }

}

aspect TypeErrorCheck {

 
  public void InstNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(InstNode n : getInstNodes()) {
		  n.collectErrors();
	  }
  }


}