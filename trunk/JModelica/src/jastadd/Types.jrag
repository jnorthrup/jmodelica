aspect Types { 

   public ClassType InstConstrainingClauseRoot.classType() {
   		return new ClassType(getConstrainingClause().getAccess().myClassDecl(),getMergedEnvironmentList());
   }
   
   /**
    * Returns a new ComponentType in a specified outer environment.
    * The input enviroment is cloned before the type is created.
    */
   public ComponentType InstComposite.declaredType(Environment outerEnv) {
      ComponentType type = declaredType();
      
      // Merge the outer modifications.
      type.env.mergeOuterEnvironment(outerEnv);
      
      return type; 
   }

   /**
    * Returns a new ComponentType in an empty enviroment.
    */
   public ComponentType InstComposite.declaredType() {
      ComponentType type =  new ComponentType(getComponentDecl());
      
      // If the component decl has a modification, this is part of the type
      if (getComponentDecl().hasModification())
      	 type.env.mergeOuterModification(this,getComponentDecl().getModification());
      
      // If the component decl has a constraining clause with modifications
      // this is part of the type.
      if (getComponentDecl().hasConstrainingClause() &&
           getComponentDecl().getConstrainingClause().hasClassModification())
      	 type.env.mergeInnerModification(this,getComponentDecl().getConstrainingClause().getClassModification());           
     
      return type; 
   }


   /**
    * Returns a new ComponentType corresponding to the replacing component decl.
    */
/*   public ComponentType InstReplacingComponent.declaredType() {
      ComponentType type =  new ComponentType(getComponentDecl());
      
      
      
      
      // If the component decl has a modification, this is part of the type
      if (getComponentDecl().hasModification())
      	 type.env.mergeOuterModification(this,getComponentDecl().getModification());
      
      // If the component decl has a constraining clause with modifications
      // this is part of the type.
      if (getComponentDecl().hasConstrainingClause() &&
           getComponentDecl().getConstrainingClause().hasClassModification())
      	 type.env.mergeInnerModification(this,getComponentDecl().getConstrainingClause().getClassModification());           
     
      return type; 
   }
*/

 
   /**
    * Returns a new ConstrainingComponentType in a specified outer environment.
    * The input enviroment is cloned before the type is created.
    */   
   public ConstrainingComponentType InstComposite.constrainingType(Environment outerEnv) {
      ConstrainingComponentType type = constrainingType();
      type.env.mergeOuterEnvironment(outerEnv);
      return type;
   }
   
   /**
    * Returns a new ConstrainingComponentType in an empty enviroment.
    */
   public ConstrainingComponentType InstComposite.constrainingType() {
      ConstrainingComponentType type;
      if (!getComponentDecl().hasConstrainingClause()) {
          type = new ConstrainingComponentType(getComponentDecl(),getComponentDecl().myClass()); 
      	 // Just add the modifiation at the declaration, if any.
      	 if (getComponentDecl().hasModification())
      	 	type.env.mergeOuterModification(this,getComponentDecl().getModification());
      } else {
         // Just add the modification of the constraining clause, if any
          type = new ConstrainingComponentType(getComponentDecl(),getComponentDecl().getConstrainingClause().getAccess().myClassDecl()); 
          if (getComponentDecl().hasConstrainingClause() &&
              getComponentDecl().getConstrainingClause().hasClassModification())
      	 	  type.env.mergeOuterModification(this,getComponentDecl().getConstrainingClause().getClassModification());           
      }
      return type;
   }
  
   class Type {
      Environment env;
	
	  public boolean subType(Type t) {
	  	return false;
	  }

        public boolean superTypeComponentType(ComponentType t) {
          return false;
        }
        
        public boolean superTypeClassType(ClassType t) {
          return false;
        }
        
        public String name() {
          return getClass().getName();
        }
                
        
   }

  class ConstrainingComponentType extends ComponentType {
        ClassDecl constrainingClass; // This class refers to the constraining
                                     // class of a component declarations, which
                                     // may be different than the declared class
                                     // due to constrainedby
       

        public ConstrainingComponentType() {
   		}
        
        public ConstrainingComponentType(ComponentDecl compDecl) {
	     super(compDecl);
		}
        
        public ConstrainingComponentType(ComponentDecl compDecl, Environment env) {
	       super(compDecl,env);
		}
		
		public ConstrainingComponentType(ComponentDecl compDecl, ClassDecl constrainingClass, Environment env) {
	       super(compDecl,env);
	       this.constrainingClass = constrainingClass;
		}

		public ConstrainingComponentType(ComponentDecl compDecl, ClassDecl constrainingClass) {
	       super(compDecl);
	       this.constrainingClass = constrainingClass;
		}
		
		public ClassType classType() {
        	return new ClassType(constrainingClass,env.clone());
        }
		
         public String toString() {
           StringBuffer str = new StringBuffer();
           str.append("** ConstrainingComponentType\n");
           str.append(compDecl.prettyPrint(""));
           str.append("\nConstraining class: "+constrainingClass.name()+"\n");
           str.append("Env=");
           str.append(env.toString());
           return str.toString();
        }
   }
   
   class ConstrainingClassType extends ClassType {
   
   }

   class PrimitiveComponentType extends ComponentType {
   
   }

   class PrimitiveClassType extends ClassType{
   
   }
   
   class PrimitiveConstrainingComponentType extends PrimitiveComponentType {
   }
   
   class PrimitiveConstrainingClassType extends PrimitiveClassType {
   
   }


	class ComponentType extends Type{
        ComponentDecl compDecl;
        
        public ComponentType() {
   		}
        
        public ComponentType(ComponentDecl compDecl) {
	      this.compDecl = compDecl;
	      this.env = new Environment();
		}
        
        public ComponentType(ComponentDecl compDecl, Environment env) {
	      this.compDecl = compDecl;
	      this.env = env;
		}
        
        public ClassType classType() {
        	return new ClassType(compDecl.myClass(),(Environment)env.clone());
        }
        
        public String toString() {
           StringBuffer str = new StringBuffer();
           str.append("** ComponentType\n");
           str.append(compDecl.prettyPrint(""));
           str.append("\nEnv=");
           str.append(env.toString());
           return str.toString();
        }
        
        public String name() {
           return compDecl.prettyPrint("");
        }
 
        
        public boolean subType(Type t) {
           return t.superTypeComponentType(this);
        }
        
        public boolean superTypeComponentType(ComponentType subType) {
           if (subType == this) return true;
           ComponentType superType = this;
                      
           if ((compDecl.myClass() instanceof PrimitiveClassDecl)) {
             if (subType.compDecl.myClass()== superType.compDecl.myClass())
             	return true;
           }  else if ((compDecl.myClass() instanceof FullClassDecl)) {
         
              FullClassDecl superClassDecl = (FullClassDecl)superType.compDecl.myClass();
              Environment superEnv = superType.env;
              
              if (compDecl.hasConstrainingClause()) {
              	ClassDecl cd_tmp = compDecl.getConstrainingClause().getAccess().myClassDecl();
              	if (cd_tmp instanceof FullClassDecl) {
              		superClassDecl = (FullClassDecl)cd_tmp;
                    superEnv = new Environment();
	                for (InstModification im : (Environment)compDecl.getConstrainingClause().instConstrainingClauseRoot().getInstNode(0).myEnvironment()) {
	    	          superEnv.add(im);
	                } 
                 }
              }	
              
         	  for (ComponentDecl superTypeComponent : superClassDecl.getComponentDecls()) {
           		  String cdName = superTypeComponent.name();
           		  HashSet set = subType.compDecl.myClass().memberComponent(cdName);
           	   if (set.size()!=1)
           	   	return false;
           	   ComponentDecl subTypeComponent = (ComponentDecl)set.iterator().next();	
           	   Type superTypeComponentType = type(superTypeComponent,superEnv);
           	   Type subTypeComponentType = type(subTypeComponent,subType.env);	
           	   if (!subTypeComponentType.subType(superTypeComponentType))
           	   	return false;
           	  }
           	}
           	
           return true;
        }
        
        
   		public static Type type(ComponentDecl cd) {
           return type(cd,new Environment());
        }
       
   		public static Type type(ComponentDecl cd, Environment env) {
   		   	  	  	  	 
   		  ComponentDecl replacingComponent = cd; 
   		  	  	 
	   	  for (InstModification im : env) {
			if (im.getModification().matchRedeclare(cd.name())!=null) {
				replacingComponent = im.getModification().matchRedeclare(cd.name());
			    break;
			}
		  }
	     
	     Environment newEnv = new Environment();
	     
	     for (InstModification im : env) {
			Modification m = im.getModification().matchModification(cd.name());
			if (m!=null)
				newEnv.add(new InstModification(im.getInstNode(),m));
		}
	     
	     // Add modifications at the declaration to env
	     
	     return new ComponentType(replacingComponent,newEnv);   
   		
   		}
   }
   
	class ClassType extends Type{
	
		ClassDecl classDecl;
		
	    public ClassType() {
   		}
 
		
		public ClassType(ClassDecl classDecl, Environment env) {
	      this.classDecl = classDecl;
	      this.env = env;
		}

		public ClassType(ClassDecl classDecl) {
	      this(classDecl,new Environment());
		}

       public String toString() {
           StringBuffer str = new StringBuffer();
           str.append(classDecl.name());
           str.append("\nEnv=");
           for (InstModification im : env) { 
	           str.append(im.getModification().prettyPrint("")+"\n");
	       }
           return str.toString();
         
        }
           
        public String name() {
           return classDecl.name();
        }
 

        public boolean subType(Type t) {
           return t.superTypeClassType(this);
        }
        
        public boolean superTypeClassType(ClassType t) {
           if (t == this) return true;
           if (!(classDecl instanceof FullClassDecl) || 
               !(t.classDecl instanceof FullClassDecl))
               	return false;
           FullClassDecl superClassDecl = (FullClassDecl)classDecl;
           FullClassDecl subClassDecl = (FullClassDecl)t.classDecl;
           for (ComponentDecl superTypeComponent : superClassDecl.getComponentDecls()) {
           		String cdName = superTypeComponent.name();
           		HashSet set = subClassDecl.memberComponent(cdName);
           	    if (set.size()!=1)
           	   	  return false;
           	    ComponentDecl subTypeComponent = (ComponentDecl)set.iterator().next();	
           	    Type superTypeComponentType = ComponentType.type(superTypeComponent);
           	     Type subTypeComponentType = ComponentType.type(subTypeComponent);	
           	   if (!subTypeComponentType.subType(superTypeComponentType))
           	   	return false;
           	  }
            // TODO: check local classes.
            return true;
            
    
        }
	    
	}


    public void InstComposite.typeCheck() {
       
       if (getComponentDecl().hasConstrainingClause()) {
       // First type check the constraining clause itself by building the instance tree.
          getComponentDecl().getConstrainingClause().instConstrainingClauseRoot().collectErrors();
                  
          // Then type check the constraining clause in relation to the declaration itself.
          ClassType subType = new ClassType(getComponentDecl().myClass());
          ClassType superType = new ClassType(getComponentDecl().getConstrainingClause().getAccess().myClassDecl());
          if (!subType.subType(superType))
        	   getComponentDecl().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
       }
    } 

	public void InstReplacingComponent.typeCheck() {
	    /*
	       This is questionable. Rather, the original declaration should actually
	       have been checked previously, when the enclosing class decl is checked in 
	       an empty environment.
	    */
		if (getOriginalDecl().hasConstrainingClause()) { 
          // First type check the constraining clause itself by building the instance tree.
          getOriginalDecl().getConstrainingClause().instConstrainingClauseRoot().collectErrors();
          Environment env = (Environment)getOriginalDecl().getConstrainingClause().instConstrainingClauseRoot().myEnvironment().clone();

	         // Then type check the constraining clause in relation to the declaration itself.
          ClassType subType = new ClassType(getOriginalDecl().myClass());
          ClassType superType = new ClassType(getOriginalDecl().getConstrainingClause().getAccess().myClassDecl(),env);
          if (!subType.subType(superType))
        	   getOriginalDecl().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
       }
 
	
	   
	   if (getComponentDecl().hasConstrainingClause()) { 
          // First type check the constraining clause itself by building the instance tree.
          getComponentDecl().getConstrainingClause().instConstrainingClauseRoot().collectErrors();

	         // Then type check the constraining clause in relation to the declaration itself.
          ClassType subType = new ClassType(getComponentDecl().myClass());
          ClassType superType = new ClassType(getComponentDecl().getConstrainingClause().getAccess().myClassDecl());
          if (!subType.subType(superType))
        	   getComponentDecl().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
       }
	
	    Environment env = (Environment)myEnvironment(name()).clone();
	
        for (InstModification im : (Environment)myEnvironment()) {
	   	 if (im.getModification().matchRedeclare(name())!=null) {
	   	        ComponentDecl replacingDecl = im.getModification().matchRedeclare(name());
	   	        if (replacingDecl.hasConstrainingClause()) {
    	   	          ClassType superType = new ClassType(getOriginalDecl().myClass());	
	                  ClassType subType = new ClassType(replacingDecl.getConstrainingClause().getAccess().myClassDecl());
	   	            if (!subType.subType(superType))
        	         replacingDecl.getConstrainingClause().error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
			          
	   	        } else {
                  ComponentType superType = new ComponentType(getOriginalDecl(),new Environment());
				  ComponentType subType = new ComponentType(replacingDecl,env);
		          if (!subType.subType(superType))
        	         subType.compDecl.error("'" + subType.name()+ "'"+ " is not a subtype of " + "'"+superType.name()+"'");    
			    }
			}
	   }	
       
        	
        // Check subtype for ALL redeclarations in myEnvironment!!
        
        // If there is a constraining clause: type check this as well, taking
        // modifications intoaccount.		
        		
	}

	public String InstReplacingComponent.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstReplacingComponent:\n");
	   str.append(" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstPrimitive:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   return str.toString();	
	}

	public String InstComposite.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstComposite:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   str.append(" Declared type:\n");
	   str.append(declaredType().toString());
	   str.append(" Constraining type:\n");
	   str.append(constrainingType().toString());
	   
	   return str.toString();	
	}



    public String InstModification.toString() {
    	return getModification().prettyPrint("");
    
    }

}

aspect TypeErrorCheck {

 
  public void InstNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(InstNode n : getInstNodes()) {
		  n.collectErrors();
	  }
  }


}