aspect Types { 
  
   syn lazy List InstNode.getDynamicInstList() = new List();


   syn lazy InstComposite InstNode.createDynamicInstComposite(ComponentDecl decl) {
   	  InstComposite ic = new InstComposite(new List(),decl);
   	  addDynamicInst(ic);
   	  ic.is$Final(true); // TODO: Is this really ok...?
   	  return ic;
   }
  
  
   syn String InstNode.className() = "";
   syn String InstComponent.className() = getComponentDecl().myClass().name();


   syn boolean InstNode.subType(InstNode t) = false;
   syn boolean InstNode.superTypeCompositeType(InstComposite subType) = false;
   syn boolean InstNode.superTypeClassType(InstRoot subType) = false;
   syn boolean InstNode.superTypePrimitiveComponentType(InstPrimitive subType) = false;
   
   eq InstComposite.subType(InstNode t) = t.superTypeCompositeType(this);
   eq InstPrimitive.subType(InstNode t) = t.superTypePrimitiveComponentType(this);

   eq InstComposite.superTypeCompositeType(InstComposite subType) {
       if (subType == this) return true;
       InstComposite superType = this;
   
       // Check that all elements (here: components) in superType are in subType 
       for (InstNode superTypeComponentInst : containedInstComponents()) {
          HashSet<InstNode> set = subType.memberComponentInst(superTypeComponentInst.name());
          if (set.size()!=1)
          	return false;
          InstNode subTypeComponentInst = set.iterator().next();
          if (!subTypeComponentInst.subType(superTypeComponentInst))
          	return false;
	   }
   	   
   	   return true;
   }
   
   eq InstPrimitive.superTypePrimitiveComponentType(InstPrimitive subType) {
       if (subType == this) return true;
       InstPrimitive superType = this;
       if (subType.className().equals(superType.className()))
       	  return true;
       else   
   	      return false;
   }

  syn lazy HashSet<InstNode> InstNode.memberComponentInst(String name) {
     HashSet<InstNode> set = new HashSet<InstNode>(4);
     for (InstNode node : containedInstComponents()) {
     	// This is to take InstExtends into account
     if (node.name().equals(name))
        set.add(node);
 
     }
     return set;
  }

  syn lazy ArrayList<InstNode> InstNode.containedInstComponents() {
  	ArrayList<InstNode> l = new ArrayList<InstNode>();
    for (InstNode node : getInstNodes()) {
       if (node instanceof InstExtends)
       	  l.addAll(node.containedInstComponents());
       else
         l.add(node);
    }
    return l;
  }
  
  public void InstComposite.typeCheck() {
      
  }
  
  public void InstReplacingComposite.typeCheck() {
     // 1.  If the original declaration has a constraining clause,
     //   1.1 Type check the constraining clause.
     //   1.2 Check that the declaration is a subtype of the contstraining clause.
     
     
         
     // Check subtype condition for all applicable redeclarations. This may include checking
     // of a chain of redeclarations.

     InstComponent superType = createDynamicInstComposite(getOriginalDecl());
     //InstNode superType = createDynamicInstConstrainingType(getOriginalDecl());
     for (InstModification im : myEnvironment()) {
	   	if (im.getModification().matchRedeclare(name())!=null) { 
           InstComponent subType = im.getInstNode().createDynamicInstComposite(im.getModification().matchRedeclare(name()));
           if (!subType.subType(superType))
             subType.getComponentDecl().error("'" + subType.getComponentDecl().prettyPrint("")+ "'"+ " is not a subtype of " + 
                "'"+superType.getComponentDecl().prettyPrint("")+"'");   	   
	    }
	 }
  }
  
  /*
    
   interface Type {
 	
	  public boolean subType(Type t);  
      public boolean superTypeComponentType(ComponentType subType);
      public boolean superTypeClassType(ClassType subType);
      public boolean superTypePrimitiveComponentType(PrimitiveComponentType subType);
      //public boolean superTypePrimitiveClassType(PrimitiveClassType subType);
      public String className();   
   }

   interface ClassType extends Type {
   
   }

   interface ComponentType extends Type {
   
   }

   interface PrimitiveComponentType extends Type {
     
   }

   InstNode implements Type;
   InstRoot implements ClassType;
   InstComposite implements ComponentType;
   InstPrimitive implements PrimitiveComponentType; 

   syn String InstNode.className() = "";
   syn String InstComponent.className() = getComponentDecl().myClass().name();


   syn boolean InstNode.subType(Type t) = false;
   syn boolean InstNode.superTypeComponentType(ComponentType subType) = false;
   syn boolean InstNode.superTypeClassType(ClassType subType) = false;
   syn boolean InstNode.superTypePrimitiveComponentType(PrimitiveComponentType subType) = false;
   
   eq InstComposite.subType(Type t) = t.superTypeComponentType(this);
   eq InstPrimitive.subType(Type t) = t.superTypePrimitiveComponentType(this);

   eq InstComposite.superTypeComponentType(ComponentType subType) {
       if (subType == this) return true;
       ComponentType superType = this;
   
       // Check that all elements (here: components) in superType are in subType 
   
   	   return false;
   }
   
   eq InstPrimitive.superTypePrimitiveComponentType(PrimitiveComponentType subType) {
       if (subType == this) return true;
       PrimitiveComponentType superType = this;
       if (subType.className().equals(superType.className()))
       	  return true;
       else   
   	      return false;
   }
*/

	public String InstReplacingComposite.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstReplacingComponent:\n");
	   str.append(" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstPrimitive:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   return str.toString();	
	}

	public String InstComposite.toString() {
	   StringBuffer str = new StringBuffer();
	   str.append("InstComposite:\n");
	   str.append(" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(" myEnvironment():\n");
	   str.append(myEnvironment().toString());
	   str.append(" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString());
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   
	   return str.toString();	
	}



    public String InstModification.toString() {
    	return getModification().prettyPrint("");
    
    }

}

aspect TypeErrorCheck {

 
  public void InstNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(InstNode n : getInstNodes()) {
		  n.collectErrors();
	  }
  }


}