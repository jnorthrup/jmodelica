import java.util.HashSet;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import org.jmodelica.parser.*;

aspect RootAccess {
	
	inh lazy Root ASTNode.retrieveRoot();
	eq SourceRoot.getProgram().retrieveRoot() = this;
	eq FlatRoot.getFClass().retrieveRoot() = this;
	syn lazy Root ASTNode.root() = retrieveRoot();
	eq Root.root() = this;
	
	syn lazy List ASTNode.emptyList() = root().emptyList();
	eq Root.emptyList() = getEmptyList();
	syn lazy List Root.getEmptyList() = new List();
	
	syn lazy HashSet ASTNode.emptyHashSet() = root().emptyHashSet();
	eq Root.emptyHashSet() = getEmptyHashSet();
	syn lazy HashSet Root.getEmptyHashSet() = new HashSet(4);
	
	syn lazy ArrayList ASTNode.emptyArrayList() = root().emptyArrayList();
	eq Root.emptyArrayList() = getEmptyArrayList();
	syn lazy ArrayList Root.getEmptyArrayList() = new ArrayList();
	
	syn lazy ModelicaParser Root.modelicaParser() = new ModelicaParser();
	syn lazy FlatModelicaParser Root.flatModelicaParser() = new FlatModelicaParser();
	
}

aspect DebugPrint {

	public int ASTNode.printLevel = 0;
	public void ASTNode.debugPrint(Object msg) {
		if (printLevel>0)
			System.out.println(msg);
	}
	
}

aspect NodeMethods {

  public void ASTNode.setStart(int start) {
    this.start = start;  
  } 
 
  public int ASTNode.beginLine() { return getLine(getStart()); }
  public int ASTNode.beginColumn() { return getColumn(getStart()); }

	public String ASTNode.getNodeName() {
		return dump();
	}
	
	public String IdDecl.getNodeName() {
		return dump() + ": '" + getID() + "'";
	}

	public String Access.getNodeName() {
		return dump() + ": '" + getID() + "'";
	}
	
	public String RealLitExp.getNodeName() {
		return dump() + ": " + getUNSIGNED_NUMBER();
	}
	
	public String InstComponentDecl.getNodeName() {
		return dump() + ": '" + getComponentDecl().getClassName().qualifiedName() + " " + getComponentDecl().getName().getID() + "'";
	}

}

aspect FileNames {

	syn lazy String ASTNode.fileName() = retrieveFileName();
	eq FullClassDecl.fileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq Root.fileName() = getFileName();
	
	inh lazy String ASTNode.retrieveFileName();
	eq SourceRoot.getProgram().retrieveFileName() = getFileName();
	eq FlatRoot.getFClass().retrieveFileName() = getFileName();
	
	eq FullClassDecl.getEquation().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getAlgorithm().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getSuper().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getImport().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getClassDecl().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getComponentDecl().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getAnnotation().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	eq FullClassDecl.getExternalClause().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
	
	private String Root.fName = "";
	public void Root.setFileName(String fName) { this.fName = fName; }
	public String Root.getFileName() {return fName; }

	private String FullClassDecl.fName = "";
	public void FullClassDecl.setFileName(String fName) { this.fName = fName; }
	public String FullClassDecl.getFileName() {return fName; }
	
	
	

}
	
aspect Names {
  // simple names
  syn String Access.name() = getID();
  syn String ParseAccess.name() = getID();
  syn String ClassAccess.name() = getID();
  syn String AmbiguousAccess.name() = getID();
  syn String ComponentAccess.name() = getID();
  syn String IdDecl.name() = getID();
  syn String Dot.name() = getLeft().name() + "." + getRight().name();
  
   // simple names of InstAccess:es
  syn String InstAccess.name() = getID();
  syn String InstParseAccess.name() = getID();
  syn String InstClassAccess.name() = getID();
  syn String InstAmbiguousAccess.name() = getID();
  syn String InstComponentAccess.name() = getID();
  syn String InstDot.name() = getLeft().name() + "." + getRight().name(); 
  
  syn lazy String Access.qualifiedName() = getID();
  eq Dot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn lazy String InstAccess.qualifiedName() = getID();
  eq InstDot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn String ClassDecl.name();
  eq BaseClassDecl.name() = getName().getID();
  eq BuiltInClassDecl.name() = getName().getID();
  //eq LibNode.name() = getName();
  
  syn String ComponentDecl.name() = getName().getID();
  
  syn String ClassDecl.qualifiedName();
  eq BaseClassDecl.qualifiedName() = classNamePrefix().equals("")? 
                                                  name(): classNamePrefix() + "." + name();
  inh String BaseClassDecl.classNamePrefix();
  eq FullClassDecl.getClassDecl().classNamePrefix() = classNamePrefix().equals("")?
                                                      name(): classNamePrefix() + "." + name();
  eq BuiltInClassDecl.qualifiedName() = getName().getID();
  
  eq SourceRoot.getProgram().classNamePrefix() = "";
  
  syn String InstClassDecl.qualifiedName();
  eq InstBaseClassDecl.qualifiedName() = instClassNamePrefix().equals("")? 
                                                  name(): instClassNamePrefix() + "." + name();
  inh String InstBaseClassDecl.instClassNamePrefix();
  eq InstFullClassDecl.getInstClassDecl().instClassNamePrefix() = instClassNamePrefix().equals("")?
                                                      name(): instClassNamePrefix() + "." + name();

  eq InstBuiltInClassDecl.qualifiedName() = name();
  
  eq SourceRoot.getChild().instClassNamePrefix() = "";
  eq InstRoot.getChild().instClassNamePrefix() = "";
  
  syn String FunctionCall.name() = getName().name();
  
  syn String InstClassDecl.primitiveName();
  eq InstBaseClassDecl.primitiveName() = name();
  eq InstBuiltInClassDecl.primitiveName() = name();
  
  eq InstFullClassDecl.primitiveName() {
  	if (extendsPrimitive())
  		return getInstExtends(0).getClassName().myInstClassDecl().finalClass().primitiveName();
  	else 
  		return name();
  }
  
  inh InstClassDecl ASTNode.enclosingInstClassDecl();
  eq SourceRoot.getProgram().enclosingInstClassDecl() = null;
  eq FlatRoot.getChild().enclosingInstClassDecl() = null;
  eq InstBaseClassDecl.getChild().enclosingInstClassDecl() = this;
  eq InstComponentDecl.getChild().enclosingInstClassDecl() = myInstClass();
  
  inh BaseClassDecl ASTNode.enclosingClassDecl();
  eq SourceRoot.getProgram().enclosingClassDecl() = null;

  eq FullClassDecl.getEquation().enclosingClassDecl() = this; 
  eq FullClassDecl.getAlgorithm().enclosingClassDecl() = this; 
  eq FullClassDecl.getSuper().enclosingClassDecl() = this;  
  eq FullClassDecl.getImport().enclosingClassDecl() = this; 
  eq FullClassDecl.getClassDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getComponentDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getAnnotation().enclosingClassDecl() = this; 
  eq FullClassDecl.getExternalClause().enclosingClassDecl() = this; 	

  eq ShortClassDecl.getExtendsClauseShortClass().enclosingClassDecl() = this;
  
  eq ExtendClassDecl.getClassModification().enclosingClassDecl() = this;
  eq ExtendClassDecl.getComposition().enclosingClassDecl() = this;
  
  
   	/**
	 * Access method for the last Access of a qualified or
	 * unqualified name.
	 */ 
	syn Access Access.getLastAccess() = this;
    eq Dot.getLastAccess() = getRight().getLastAccess();
    
    syn InstAccess InstAccess.getLastInstAccess() = this;
    eq InstDot.getLastInstAccess() = getRight().getLastInstAccess();
    
    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn Access Access.getFirstAccess() = this;
    eq Dot.getFirstAccess() = getLeft().getFirstAccess();
   
   	inh Access Access.getNextAccess();
   	eq Dot.getLeft().getNextAccess() = getRight().getFirstAccess();
   	eq SourceRoot.getProgram().getNextAccess() = null;

    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn InstAccess InstAccess.getFirstInstAccess() = this;
    eq InstDot.getFirstInstAccess() = getLeft().getFirstInstAccess();
   
   	inh InstAccess InstAccess.getNextInstAccess();
   	eq InstDot.getLeft().getNextInstAccess() = getRight().getFirstInstAccess();
   	eq SourceRoot.getProgram().getNextInstAccess() = null;
    eq FlatRoot.getChild().getNextInstAccess() = null;

   	
   	/**
   	 * stripFirstAccess removes the first access in a qualified
   	 * name. If the name is not qualified, null is returned. 
   	 */
   	public Access Access.stripFirstAccess() {
   		return null;
   	}
   	
   	public Access Dot.stripFirstAccess() {
		// A right skewed Dot three is stipped by
		//getRight().myDecl();
		return (Access)getRight().fullCopy();
	}
   	
   	syn ArraySubscripts Access.arraySubscripts() = null;
   	syn ArraySubscripts ParseAccess.arraySubscripts() = 
   	   hasArraySubscripts()? getArraySubscripts(): null;
   	syn ArraySubscripts ComponentAccess.arraySubscripts() = 
   	   hasArraySubscripts()? getArraySubscripts(): null;
   	syn ArraySubscripts AmbiguousAccess.arraySubscripts() = 
   	   hasArraySubscripts()? getArraySubscripts(): null;

	syn boolean Access.isQualified() = false;
	eq Dot.isQualified() = true;
}

aspect FlatNames {
	
	public FQName.FQName(String name) {
		this(new List().add(new FQNamePart(name,new Opt())));
	}

	public FQName.FQName(FQName fqname) {
		this((List)fqname.getFQNamePartList().fullCopy());
	}

	public FQName FQName.append(InstAccess access,FQName prefix) {
		InstAccess fa = access.getFirstInstAccess();
		// TODO: fix array subscripts
		addFQNamePart(new FQNamePart(fa.name(),new Opt()));
			                  //fa.arraySubscripts()!=null? new Opt(fa.arraySubscripts().flatten(prefix)):new Opt()));
		while (fa.getNextInstAccess()!=null) {
			fa = fa.getNextInstAccess();
			addFQNamePart(new FQNamePart(fa.name(),new Opt()));
//			                  fa.arraySubscripts()!=null? new Opt(fa.arraySubscripts().flatten(prefix)):new Opt()));
		}
		return this;
	}

	public FQName FQName.append(String name) {
		addFQNamePart(new FQNamePart(name, new Opt()));
		return this;
	}

	public FQName FQName.append(FQName fqname) {
		for (int i=0;i<fqname.getNumFQNamePart();i++)
			addFQNamePart((FQNamePart)fqname.getFQNamePart(i).fullCopy());
		return this;
	}

	syn lazy FQName InstNode.getFQNamePrefix() {
		FQName prefix = retrieveFQName();
		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
		return myName;	
	}
	
	syn lazy FQName InstNode.getFQName() = getFQNamePrefix();
	
	eq InstComponentDecl.getFQName() {
		FQName prefix = retrieveFQName();
		FQName myName = prefix!=null? new FQName(prefix):
		                              new FQName();
		//TODO: fix array subscripts
		if (prefix!=null)
			myName.addFQNamePart(new FQNamePart(name(),new Opt()));
			                            //arraySubscripts()!=null? 
		                                //new Opt(arraySubscripts().flatten(prefix)): new Opt()));
		else
			myName.addFQNamePart(new FQNamePart(name(),new Opt()));
			                            //arraySubscripts()!=null? 
		                                //new Opt(arraySubscripts().flatten(new FQName())): new Opt()));
		
		return myName;
	}

	eq InstClassDecl.getFQName() = new FQName();
	inh lazy FQName InstNode.retrieveFQName();
	eq InstComponentDecl.getChild().retrieveFQName() = getFQName();
	eq InstComponentDecl.getIModification().retrieveFQName() = retrieveFQName();
	eq InstReplacingShortClassDecl.getChild().retrieveFQName() = retrieveFQName();
	eq InstClassDecl.getChild().retrieveFQName() = null; //getFQName();
	
	
	
	eq InstRoot.getChild().retrieveFQName() = null;
	eq SourceRoot.getProgram().retrieveFQName() = null;

	
	syn lazy String FQName.name() {
		StringBuffer str = new StringBuffer();
		for (int i=0;i<getNumFQNamePart();i++) {
			str.append(getFQNamePart(i).getName());
			if (i<getNumFQNamePart()-1)
				str.append(".");
		}
		return str.toString();
	}
	syn String FQNamePart.name() = getName();

	syn String FIdUse.name() = getID();
	syn String FIdUseExp.name() = getFIdUse().name();
	eq FIdUseQualified.name() = getFQName().name();
	
	syn String FIdDecl.name() = getFQName().name();

	syn String FClass.name() = getFQName().name();
	syn String FVariable.name() = getFQName().name();

}

aspect Visibility {
	
	syn boolean BaseClassDecl.isPublic() = getVisibilityType().isPublic();
	syn boolean ComponentDecl.isPublic() = getVisibilityType().isPublic();

	syn boolean BaseClassDecl.isProtected() = getVisibilityType().isProtected();
	syn boolean ComponentDecl.isProtected() = getVisibilityType().isProtected();

	syn boolean VisibilityType.isPublic() = false;
	eq PublicVisibilityType.isPublic() = true;

	syn boolean VisibilityType.isProtected() = false;
	eq ProtectedVisibilityType.isProtected() = true;
	
}

aspect ComponentDeclMethods {
   	/**
   	 * Check if a ComponentDecl is declared flow.
   	 */
   	syn boolean ComponentDecl.isFlow() {
   	
   		if (hasTypePrefixFlow())
   			return true;
   	
   		return false;
   	}

   	/**
   	 * Check if a ComponentDecl is declared parameter.
   	 */
   	syn boolean ComponentDecl.isParameter() {
   	
   		if (hasTypePrefixOther())
   			if (getTypePrefixOther() instanceof Parameter)
   				return true;
   	
   		return false;
   	}
   	  
   	/**
   	 * Check if a ComponentDecl is declared inner.
   	 */
   	syn boolean ComponentDecl.isInner() {
		return hasInner();
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared outer.
   	 */
   	syn boolean ComponentDecl.isOuter() {
		return hasOuter();
   	}
   	
   	
   	 /**
   	 * Check if a ComponentDecl is declared constant.
   	 */
   	syn boolean ComponentDecl.isConstant() {
   	
   		if (hasTypePrefixOther())
   			if (getTypePrefixOther() instanceof Constant)
   				return true;
   	
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isDiscrete() {
   	
   		if (hasTypePrefixOther())
   			if (getTypePrefixOther() instanceof Discrete)
   				return true;
   	
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isInput() {
   	
   		if (hasTypePrefixInputOutput())
   			if (getTypePrefixInputOutput() instanceof Input)
   				return true;
   		if (myClass().isInput())
   			return true;
   		
   		return false;
   	}
   	
   	/**
   	 * Check if a ComponentDecl is declared discrete.
   	 */
   	syn boolean ComponentDecl.isOutput() {
   	
   		if (hasTypePrefixInputOutput())
   			if (getTypePrefixInputOutput() instanceof Output)
   				return true;
	    if (myClass().isOutput())
   			return true;
	    
   	
   		return false;
   	}

	syn boolean AbstractEquation.isInitial() {
		if (hasAbstractEquationModifier())
			if (getAbstractEquationModifier() instanceof Initial)
				return true;
		return false;
	
	}

	

}

aspect ShortClassUtil {
    // TODO: rename this attribute to finalAliasClass
	syn ClassDecl ClassDecl.finalClass() = this;
	eq ShortClassDecl.finalClass() = getExtendsClauseShortClass().getSuper().myClassDecl().finalClass();

	syn InstClassDecl InstClassDecl.finalClass() = this;
	eq InstShortClassDecl.finalClass() = getInstExtends(0).getClassName().myInstClassDecl().finalClass();

	syn BaseClassDecl BaseClassDecl.nextAliasClass() = null;
	eq ShortClassDecl.nextAliasClass() = (BaseClassDecl)getExtendsClauseShortClass().getSuper().myClassDecl();

	syn boolean BaseClassDecl.isAliasClass() = false;
	eq ShortClassDecl.isAliasClass() = true;

	syn boolean ClassDecl.isInput() = false;
	eq ShortClassDecl.isInput() {
		if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
   			if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Input)
   				return true;
		return getExtendsClauseShortClass().getSuper().myClassDecl().isInput();
	}
	
	syn boolean ClassDecl.isOutput() = false;
	eq ShortClassDecl.isOutput() {
		if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
   			if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Output)
   				return true;
		return getExtendsClauseShortClass().getSuper().myClassDecl().isOutput();
		
	}

/*
   syn boolean BaseClassDecl.hasModification() = false;
   eq ShortClassDecl.hasModification() = hasClassModification();
   
   syn Modification BaseClassDecl.getModification() = null;
   eq ShortClassDecl.getModification() = getClassModification();
*/
}

aspect AllElements {

	syn lazy HashSet ClassDecl.allLocalClassDecl() = emptyHashSet();
	eq ShortClassDecl.allLocalClassDecl() = finalClass().allLocalClassDecl();
	eq FullClassDecl.allLocalClassDecl() {
		LinkedHashSet set = new LinkedHashSet(); // This is to get the same order every time
		for (int i=0;i<numLocalClassDecl();i++) 
			set.add(localClassDecl(i));
		for (int i=0;i<getNumSuper();i++)
			set.addAll(getSuper(i).getSuper().myClassDecl().allLocalClassDecl());
		return set;
	}
	
    syn lazy HashSet ClassDecl.allLocalComponentDecl() = emptyHashSet();
	eq ShortClassDecl.allLocalComponentDecl() = finalClass().allLocalComponentDecl();
	eq FullClassDecl.allLocalComponentDecl() {
		debugPrint("<<<FullClassDecl.allLocalComponentDecl(): ");
		LinkedHashSet set = new LinkedHashSet();
		for (int i=0;i<getNumComponentDecl();i++) 
			set.add(getComponentDecl(i));
		for (int i=0;i<getNumSuper();i++)
			set.addAll(getSuper(i).getSuper().myClassDecl().allLocalComponentDecl());
		return set;
	}
	
}

aspect Math {
	public boolean FFunctionCall.rewrittenToExp = false;
	rewrite FFunctionCall {
		when (getName().name().equals("Modelica.Math.sin") && 
		      !rewrittenToExp)
		      to FFunctionCall {
		      	rewrittenToExp = true;
		      	return new FFunctionCall(new FIdUse("sin"),new List().add(getArgs(0)));
		      }
	}

}
