abstract InstNode ::= /InstNode*/ /FQName/ FExp* /DynamicInst:InstNode*/ /DynamicInstConstraining:InstNode*/ /MergedEnvironment:Environment/;
abstract InstRoot : InstNode ::= /FPrimitiveType*/;
InstClassRoot : InstRoot ::= <ClassDecl:ClassDecl>;
//InstFullClassDeclRoot :InstRoot ::= InstFullClassDecl;
InstProgramRoot : InstRoot ::= <Program:Program>
					           /UnknownInstClassDecl/
                               /UnknownInstComponentDecl/
                               /InstPredefinedType:InstClassDecl*/ 
                               /InstBuiltInType:InstClassDecl*/   
                               /InstBuiltInFunction:InstClassDecl*/;

abstract InstClassDecl: InstNode ::= <ClassDecl:ClassDecl>;
abstract InstBaseClassDecl : InstClassDecl ::=  /InstImport*/ [InstConstraining];
InstFullClassDecl : InstBaseClassDecl ::= ;
InstShortClassDecl : InstBaseClassDecl ::= ClassName:InstAccess [IClassModification];
InstPrimitiveClassDecl : InstFullClassDecl;
InstBuiltInClassDecl : InstClassDecl ::= ;
UnknownInstClassDecl : InstFullClassDecl;

abstract InstImport ::= PackageName:InstAccess <ImportClause:ImportClause>;
InstImportQualified : InstImport;
InstImportUnqualified : InstImport;
InstImportRename : InstImport;

abstract InstConstraining ::=  ClassName:InstAccess [IClassModification] /InstNode/;
InstConstrainingClass : InstConstraining ::= <BaseClassDecl:BaseClassDecl>;
InstConstrainingComponent : InstConstraining ::= <ComponentDecl:ComponentDecl>;

// The class to expand may differ from the declared class of the component due to 
// redeclaration of classes.
abstract InstComponentDecl : InstNode ::= ClassName:InstAccess <ComponentDecl:ComponentDecl> <InstClassDecl:InstClassDecl> [IModification] [InstConstraining];
InstComposite : InstComponentDecl;
InstPrimitive : InstComponentDecl ::= /FVariable/;
InstBuiltIn : InstComponentDecl;
UnknownInstComponentDecl : InstComponentDecl;

InstExtends : InstNode ::= ClassName:InstAccess <ExtendsClause:ExtendsClause> [IClassModification];

InstReplacingComposite : InstComposite ::= <OriginalInstDecl:InstComponentDecl>;
InstReplacingPrimitive : InstPrimitive ::= <OriginalInstDecl:InstComponentDecl>;

// Accesses in the instance tree
abstract InstAccess ::= <ID>;
InstDot : InstAccess ::= Left:InstAccess Right:InstAccess;

InstParseAccess : InstAccess;// ::= [ArraySubscripts];
InstClassAccess : InstAccess;
InstAmbiguousAccess : InstAccess;// ::= [ArraySubscripts];

InstComponentAccess : InstAccess;// ::= [ArraySubscripts];

Environment ::= InstModification*;

// The intrinsic reference to the InstNode can be discussed here. In principle,
// each IModification can be used to retrieve the corresponding InstNode, but it is probably
// better for performance to keep an explicit reference.
// It could be removed later.
InstModification ::= <InstNode:InstNode> <IModification:IModification>;
InstCompleteModification : InstModification;
InstClassModification : InstModification;
InstValueModification : InstModification ::=;// /FExp/;
InstComponentModification : InstModification ;
InstComponentRedeclare : InstModification ;
InstClassRedeclare : InstModification ;

// These nodes are used to create instance copies of modification trees intended for
// error checking.	
abstract IModification ::= <Modification:Modification>;
ICompleteModification : IModification ::= IClassModification [IValueModification];
IValueModification : IModification ::=; // /FExp/;

IClassModification : IModification ::= IArgument*;
abstract IArgument : IModification ::=;

abstract INamedModification : IArgument ::= Name:InstAccess;
abstract IElementModification : INamedModification ::= [IModification];
IComponentModification : IElementModification; 
abstract IElementRedeclare : INamedModification;
IClassRedeclare : IElementRedeclare ::= /InstBaseClassDecl/;
IComponentRedeclare : IElementRedeclare ::= /InstComponentDecl/;
	