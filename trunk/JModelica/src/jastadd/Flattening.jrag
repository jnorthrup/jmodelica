import java.util.ArrayList;

aspect Flattening {
    
	// Generic traversal method to find the class to flatten.
	public InstNode ASTNode.findFlatten(String className, FClass fc) {
		InstNode n = null;
		for(int i = 0; i < getNumChild(); i++) {
     		n = getChild(i).findFlatten(className,fc);
 			if (n!=null)
 				return n;
     	}
     	return n;
	}
	
	// Check if the FullClassDecl matches the name of class to be flattened. 
	public InstNode FullClassDecl.findFlatten(String className, FClass fc) {
		debugPrint("FullClassDecl.findFlatten: "+name());
		FlatRoot fr = new FlatRoot();
		fr.setFClass(fc);
		//System.out.println("Model.instantiate: "+getFullClassName() +" : " +getClassName());
   		if (className.equals(qualifiedName())) {
  	 		fc.setFQName(new FQName(qualifiedName())); 
  	 		InstRoot r = getInstRoot();
			r.dumpTree("");
			r.printIVarAccesses("");
			fc.addFEquationBlock(new FEquationBlock(new List()));
			r.flatten(fc);
			fc.genConnectionEquations();
			return r;	
   		} else {
  			return getClassDeclList().findFlatten(className,fc);
   		}  	
	}

	// Generic method for flattening	
	public void ASTNode.flatten(FClass fc) {
		for (int i=0;i<getNumChild();i++) {
			getChild(i).flatten(fc);
		}
	}

	public void InstNode.flatten(FClass fc) {
		List l = equations();
		for (int i=0;i<l.getNumChild();i++) {
		   ((AbstractEquation)l.getChild(i)).flatten(getFQName(),fc);
		}
		getInstNodeList().flatten(fc);
	}
	
	public void InstPrimitive.flatten(FClass fc) {
		fc.addFVariable(createFVariable());
	}
	
	
	public FVariable InstPrimitive.createFVariable() {
		FExp e = myBindingExp();
		List attr = new List();
		for (int i=0;i<getNumMergedEnvironment();i++) {
			getMergedEnvironment(i).getModification().collectAttributes(attr,getMergedEnvironment(i).getInstNode().getFQNamePrefix());
		}
		
		//attr.dumpTree("*** ");
		FVariable fv = null;
		if (e!=null)
			fv = new FVariable(getComponentDecl().myClass().finalClass().primitiveName(),getFQName(),e);
		else
			fv = new FVariable(getComponentDecl().myClass().finalClass().primitiveName(),getFQName());
		
		fv.setFAttributeList(attr);
		
		// FIXME: Make sure that prefixes specified in short class declarations are propagated
		if (getComponentDecl().isFlow())
			fv.setFTypePrefixFlow(new FFlow());
		if (getComponentDecl().isInput())
			fv.setFTypePrefixInputOutput(new FInput());
		if (getComponentDecl().isOutput())
			fv.setFTypePrefixInputOutput(new FOutput());
		if (getComponentDecl().isDiscrete())
			fv.setFTypePrefixOther(new FDiscrete());	
		if (getComponentDecl().isParameter())
			fv.setFTypePrefixOther(new FParameter());
		if (getComponentDecl().isConstant())
			fv.setFTypePrefixOther(new FConstant());
		
		if (getComponentDecl().getComment().hasStringComment())
			fv.setFStringComment(new FStringComment(getComponentDecl().getComment().getStringComment().getComment()));
		
		return fv;
		
		
	}
	
	syn FExp InstPrimitive.myBindingExp() {
		debugPrint("InstPrimitive.myBindingExp(): getNumMergedEnvironment() = " + getNumMergedEnvironment());
		// A value modification is usually found last in the env list
		for (int i=0;i<getNumMergedEnvironment();i++) {
			//System.out.println("**************");
			//getMergedEnvironment(i).getModification().dumpTree("");
			//System.out.println("**************");
			if (getMergedEnvironment(i).getModification().hasValueMod()) {
				return getMergedEnvironment(i).getModification().valueMod().flatten(getMergedEnvironment(i).getInstNode().getFQNamePrefix());
			}
		}
		return null;
	}
	
	syn boolean Modification.hasValueMod() = false;
	eq ValueModification.hasValueMod() = true;
	eq CompleteModification.hasValueMod() = hasValueModification();
	
	syn Exp Modification.valueMod() = null;
	eq ValueModification.valueMod() = getExp();
	eq CompleteModification.valueMod() = getValueModification().getExp();
	
	public void ASTNode.collectAttributes(List attrs, FQName prefix) {
		for (int i=0;i<getNumChild();i++)
			getChild(i).collectAttributes(attrs, prefix);
	}

	public void ComponentModification.collectAttributes(List attrs, FQName prefix) {
        debugPrint("<<<<<<<<<<<ComponentModification.collectAttributes: "+getName());
		if (hasModification()) {
			FQName fqn = new FQName(new List().add(new FQNamePart(getName().getID(),new Opt())));
            boolean attr_set = false;
            for (int i=0;i<attrs.getNumChild();i++)
            	if (((FAttribute)attrs.getChild(i)).getName().name().equals(getName().name()))
					attr_set = true;
			if (!attr_set) {
			List my_attr = new List();
			getModification().collectAttributes(my_attr,prefix);
			attrs.add(new FAttribute(new FIdUse(getName().myClassDecl().name()),
									new FIdDecl(fqn),
			                        getModification().hasValueMod()? new Opt(getModification().valueMod().flatten(prefix)): new Opt(),
			                        true,
			                        hasEach()? new Opt(new FEach()): new Opt(),
			                   		hasFinal()? new Opt(new FFinal()): new Opt(),
			                   		my_attr));
			}
			}
	}

}

aspect FlatVariables {

   public static FPrimitiveType FVariable.primitiveType(String type) {
	  if (type.equals("Real")) {
		  return new FRealType();
     } else if (type.equals("Integer")) {
	  return new FIntegerType();
    } else if (type.equals("Boolean")) {
		  return new FBooleanType();
	  } else if (type.equals("String")) {
		  return new FStringType();
	  } else {
		  return null;
	  }
  }
 
  public FVariable.FVariable(String type, FQName fqname) {	  
  	this(new Opt(),
  	      new Opt(),
  	      new Opt(),
  	      primitiveType(type),
  	      new List(),
  	      new Opt(),
  	      new Opt(),
  	      new FQName(fqname));
  }
  
  public FVariable.FVariable(String type, FQName fqname, FExp bexp) {
  	this(new Opt(),
  	      new Opt(),
  	      new Opt(),
  	      primitiveType(type),
  	      new List(),
  	      new Opt(bexp),
  	      new Opt(),
  	      new FQName(fqname));
  }
  
  syn boolean FVariable.isParameter() {
  		if (hasFTypePrefixOther())
   			if (getFTypePrefixOther() instanceof FParameter)
   				return true;
   	
   		return false;
  }
  
    syn boolean FVariable.isVariable() {
  		if (!hasFTypePrefixOther())
  			return true;
  		if (hasFTypePrefixOther())
   			if (getFTypePrefixOther() instanceof FContinuous || getFTypePrefixOther() instanceof FDiscrete)
   				return true;
   	
   		return false;
  }
  
}

aspect InstNodeInterface {

	syn ArraySubscripts InstComponent.arraySubscripts() = 
		getComponentDecl().arraySubscripts()!=null?
			getComponentDecl().arraySubscripts(): null;

}

aspect FlatExpressions {

	public void AbstractEquation.flatten(FQName prefix, FClass fc) {}

	public void Equation.flatten(FQName prefix, FClass fc) {
		fc.getFEquationBlock(0).addFAbstractEquation(new FEquation(getLeft().flatten(prefix),getRight().flatten(prefix)));
	}

	public FArraySubscripts ArraySubscripts.flatten(FQName prefix) {
	 	debugPrint("ArraySubscripts.flatten, prefix:" + prefix);
		List l = new List();
		for (int i=0;i<getNumSubscript();i++)
			l.add(getSubscript(i).flatten(prefix));
		return new FArraySubscripts(l);
	}
	
	abstract public FSubscript Subscript.flatten(FQName prefix);
	public FSubscript ColonSubscript.flatten(FQName prefix) { 
		return new FColonSubscript();
	}
	
	public FSubscript ExpSubscript.flatten(FQName name) {
	    debugPrint("ExpSubscript.flatten, prefix:" + name);
		return new FExpSubscript(getExp().flatten(name));
	}
	
	public FExp Exp.flatten(FQName prefix) {
		return null;
	}

	public FExp AccessExp.flatten(FQName prefix) {
		return new FIdUseExp(new FIdUseQualified("", getAccess().flatten(prefix)));
	}
	
	public FQName Access.flatten(FQName prefix) { 
		FQName myName = new FQName(prefix);
		myName.append(this,prefix);
		return myName;
	}

	public FExp ArrayConstructor.flatten(FQName prefix) {
	   List l = new List();
	   for (int i=0;i<getFunctionArguments().getNumExp();i++)
	   	 l.add(getFunctionArguments().getExp(i).flatten(prefix));
	   return new FArrayConstructor(l);
	}


	public FExp RangeExp.flatten(FQName prefix) {
		List l = new List();
		for (int i=0;i<getNumExp();i++)
			l.add(getExp(i).flatten(prefix));
		return new FRangeExp(l);
	}

    public FExp IfExp.flatten(FQName prefix) {
		List etl = new List();
		for (int i=0;i<getNumElseIfExp();i++) {
			etl.add(getElseIfExp(i).flatten(prefix));
		}
		return new FIfExp(getIfExp().flatten(prefix),
		                  getThenExp().flatten(prefix),
		                  etl,
		                  getElseExp().flatten(prefix));
	}
	
	public FExp ElseIfExp.flatten(FQName prefix) {
		return new FElseIfExp(getIfExp().flatten(prefix),
		                      getThenExp().flatten(prefix));
	}


/*	
	
	
	
	
	
	
	eq Matrix.flatten(FQName prefix) {
		List l = new List();
	    for (int i=0;i<getNumExpList();i++) {
	   	  l.add(getExpList(i).instantiate((QName)decls.clone()));
		}
		return new FMatrix(l);
	}
	
	eq ExpList.flatten(FQName prefix) {
	   List l = new List();
	   for (int i=0;i<getNumExp();i++)
	   	 l.add(getExp(i).instantiate((QName)decls.clone()));
	   return new FExpList(l);
	}
	*/
	
	public FExp AddExp.flatten(FQName prefix) { return new FAddExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp SubExp.flatten(FQName prefix) { return new FSubExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp MulExp.flatten(FQName prefix) { return new FMulExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp DivExp.flatten(FQName prefix) { return new FDivExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp PowExp.flatten(FQName prefix) { return new FPowExp(getBase().flatten(prefix),getExponent().flatten(prefix)); }
	public FExp NegExp.flatten(FQName prefix) { return new FNegExp(getExp().flatten(prefix)); }

	public FExp LtExp.flatten(FQName prefix) { return new FLtExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp LeqExp.flatten(FQName prefix) { return new FLeqExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp GtExp.flatten(FQName prefix) { return new FGtExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp GeqExp.flatten(FQName prefix) { return new FGeqExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp EqExp.flatten(FQName prefix) { return new FEqExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp NeqExp.flatten(FQName prefix) { return new FNeqExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp NotExp.flatten(FQName prefix) { return new FNotExp(getExp().flatten(prefix)); }
	public FExp OrExp.flatten(FQName prefix) { return new FOrExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }
	public FExp AndExp.flatten(FQName prefix) { return new FAndExp(getLeft().flatten(prefix),getRight().flatten(prefix)); }

	public FExp RealLitExp.flatten(FQName prefix) { return new FRealLitExp(getUNSIGNED_NUMBER()); }
	public FExp StringLitExp.flatten(FQName prefix) { return new FStringLitExp(getSTRING()); }
	public FExp BooleanLitExpTrue.flatten(FQName prefix) { return new FBooleanLitExpTrue(); }
	public FExp BooleanLitExpFalse.flatten(FQName prefix) { return new FBooleanLitExpFalse(); }
	
	public FExp TimeExp.flatten(FQName prefix) { return new FTimeExp(); }
	
	
	public FExp FunctionCall.flatten(FQName prefix) {
		List l = new List();
		List args = new List();
		if (hasFunctionArguments())
			args =  getFunctionArguments().getExpList();
		for (int i=0;i<args.getNumChild();i++) {
			l.add(((Exp)args.getChild(i)).flatten(prefix));
		}
		return new FFunctionCall(new FIdUseQualified("",new FQName().append(getName(),prefix)),l);	
	}
	
	public FExp SumRedExp.flatten(FQName prefix) {
		return new FSumRedExp(getExp().flatten(prefix),
		                     getForIndex().flatten(prefix));
		
	
	}
	
	public FForIndex ForIndex.flatten(FQName prefix) {
		return new FForIndex(new FIdDecl(new FQName().append(getForIndexDecl().name())),
		                     hasExp()? new Opt(getExp().flatten(prefix)): new Opt());
	}
	
	
	//ForClauseE : AbstractEquation ::= ForIndex* ForEqns:AbstractEquation*;
    //ForIndex ::= ForIndexDecl [Exp];
	public void ForClauseE.flatten(FQName prefix, FClass fc) {
		List forIndex = new List();
		List eqns = new List();
		for (int i=0;i<getNumForIndex();i++)
			forIndex.add(getForIndex(i).flatten(prefix));
		FClass fcc = new FClass();
		fcc.setFQName(new FQName().append("tmp")); 
		fcc.addFEquationBlock(new FEquationBlock(new List()));
		fcc.dumpTree("");
		for (int i=0;i<getNumForEqns();i++)
			getForEqns(i).flatten(prefix,fcc);
		for (int i=0;i<fcc.getFEquationBlock(0).getNumFAbstractEquation();i++)
			eqns.add(fcc.getFEquationBlock(0).getFAbstractEquation(i));
		fc.getFEquationBlock(0).addFAbstractEquation(new FForClauseE(forIndex,eqns));
	}
	
	/*
	eq SizeExp.flatten(FQName prefix) {
		return new FSizeExp((FIdUse)getAccess().instantiate(decls),getDim().instantiate(decls));
	}
	
	public void FClass.cleanInputOutput() {
	
		for (int i=0;i<getNumFVariable();i++) {
			if (getFVariable(i).getNumFQName()>1 && getFVariable(i).hasFTypePrefixInputOutput())
				getFVariable(i).setFTypePrefixInputOutputOpt(new Opt());
		}
	
	}
	
*/

}
