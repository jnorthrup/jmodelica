	class Kind {
   		static Kind CLASS_ACCESS = new Kind();
   		static Kind COMPONENT_ACCESS = new Kind();
   		static Kind AMBIGUOUS_ACCESS = new Kind();
	}


aspect NameClassification {


	/**
	 * This is just a bogus attribute that makes sure that the
	 * right child of a Dot is touched (=rewrites trigged) before
	 * the left child. Should not be necessary. CHECK.
	 */ 
	
	 /*
	boolean Dot.poked = false;
	rewrite Dot { 
		when (!poked)
  			to Dot{
    			getLeft().getID();
    			getRight().getID();
    			
    			poked = true;
    			return this;
 			}
	}
*/

	/**
	 * This is the classification framework introduced in the paper by 
	 * Ekman and Hedin. Rewrites of ParseAccess is controlled by the attribute
	 * kind, which is defined below.
	 */
	 /*
	rewrite ParseAccess {
  		when(kind()==Kind.COMPONENT_ACCESS)
  			to Access {
  			    debugPrint("****** ParseAccess: "+getID() + " rewritten to ComponentAccess");
    			ComponentAccess a = new ComponentAccess(getID(),getArraySubscriptsOpt());
     			a.setStart(getStart());
     			return a;
  			}
  		when(kind()==Kind.AMBIGUOUS_ACCESS) 
  			to Access {
  				debugPrint("****** ParseAccess: "+getID() + " rewritten to AmbiguousAccess");
    			AmbiguousAccess a = new AmbiguousAccess(getID(),getArraySubscriptsOpt());
    			a.setStart(getStart());
     			return a;
  			}
  		when(kind()==Kind.CLASS_ACCESS) 
  			to Access {
	 			debugPrint("ParseAccess: "+getID() + " rewritten to ClassAccess");
    
     			ClassAccess a =  new ClassAccess(getID());
     			a.setStart(getStart());
     			return a;
  			}
	}
*/

	rewrite ParseAccess {
	   to Access {
  		if (kind()==Kind.COMPONENT_ACCESS) {
  			    debugPrint("****** ParseAccess: "+getID() + " rewritten to ComponentAccess");
    			ComponentAccess a = new ComponentAccess(getID(),getArraySubscriptsOpt());
     			a.setStart(getStart());
     			return a;
  		} else if (kind()==Kind.CLASS_ACCESS) {
	 			debugPrint("ParseAccess: "+getID() + " rewritten to ClassAccess");
     			ClassAccess a =  new ClassAccess(getID());
     			a.setStart(getStart());
     			return a;
  		} else {
  				debugPrint("****** ParseAccess: "+getID() + " rewritten to AmbiguousAccess");
    			AmbiguousAccess a = new AmbiguousAccess(getID(),getArraySubscriptsOpt());
    			a.setStart(getStart());
     			return a;
  		}
  		}
	}
	// Check this section so that all inh calls are caught at the right level
	
	/**
	 * Here a few cases are classified based on their context.
	 */
	inh Kind Access.kind();
	eq SourceRoot.getProgram().kind() = Kind.AMBIGUOUS_ACCESS;
	eq Dot.getLeft().kind() {
	 	debugPrint("Dot.getLeft().kind()"+ this);
	 	return getRight().predKind();
	}
	//eq Equation.getLeft().kind() = Kind.COMPONENT_ACCESS;
	//eq Equation.getRight().kind() = Kind.COMPONENT_ACCESS;
	eq ExtendsClause.getSuper().kind() = Kind.AMBIGUOUS_ACCESS;
	eq FunctionCall.getName().kind() = Kind.AMBIGUOUS_ACCESS;
	eq ImportClause.getPackageName().kind() = Kind.CLASS_ACCESS;
	eq ImportClauseQualified.getPackageName().kind() = Kind.CLASS_ACCESS;
	eq ClassRedeclare.getName().kind() = Kind.CLASS_ACCESS;
	eq ComponentRedeclare.getName().kind() = Kind.COMPONENT_ACCESS;
//	eq ShortClassDecl.getClassName().kind() = Kind.CLASS_ACCESS;

	/**
	 * The attribute predKind defines the kind for qualified
	 * names.
	 */
	syn Kind Access.predKind() = Kind.AMBIGUOUS_ACCESS;
	eq Dot.predKind() {
		debugPrint("Dot.predKind");
		return getLeft().predKind();
	}
	eq ClassAccess.predKind() = Kind.CLASS_ACCESS;
	eq ComponentAccess.predKind() = Kind.AMBIGUOUS_ACCESS;
	eq AmbiguousAccess.predKind() = Kind.AMBIGUOUS_ACCESS;


	/**
	 * Helper class for definition of kinds.
	 */

}
aspect ResolveAmbiguousNames {
	/**
	 * This rewrite determines whether an AmbiguousAccess is a TypeAcces or a
	 * ComponentAccess by attempting type and component lookups respectively.
	 */
	boolean AmbiguousAccess.rewritten = false;
	rewrite AmbiguousAccess {
	    when(!duringNameClassification()&&!rewritten) 
	    to Access {
	    debugPrint("rewrite AmbiguousAccess: " +getID());
  		if (!lookupComponent(name()).isEmpty()) {
     			//debugPrint(getID());
     			//
     			//debugPrint(lookupDecl(getID()));
     			debugPrint("****** AmbiguousAccess: "+getID() + " rewritten to ComponentAccess");
     			ComponentAccess c = new ComponentAccess(name(),
     			                                        getArraySubscriptsOpt());
  	 			c.setStart(getStart());
  	 			return c;
  		} else if(!lookupClass(name()).isEmpty()) {
    			debugPrint("****** AmbiguousAccess: "+getID() + " rewritten to ClassAccess");
    			ClassAccess t = new ClassAccess(name()); 
    			t.setStart(getStart());
  	 			return t;
  		}
  		rewritten = true;
  		return this;
  		}
  	}


}


