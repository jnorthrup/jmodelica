aspect InstantiationTree {


    /**
     * TODO: Is it a good idea to inherit? Should env be a component?
     */
    class Environment extends ArrayList<InstModification> {
    
        public Environment() {
        	super();
        }

        /**
         * Merge an outer modification into the environment: add it at the beginning.
         */    
    	public void mergeOuterModification(InstNode n, Modification outerMod) {
    		InstModification im = new InstModification(n,outerMod);
    		ArrayList<InstModification> outerMods = im.expand();
    		addAll(0,outerMods);
    	}

        /**
         * Merge an inner modification into the environment: add it last.
         */    
    	public void mergeInnerModification(InstNode n, Modification innerMod) {
    		InstModification im = new InstModification(n,innerMod);
    		ArrayList<InstModification> innerMods = im.expand();
    		addAll(innerMods);    	
    	}

        /**
         * Merge an outer environment: add it first.
         */ 
    	public void mergeOuterEnvironment(Environment outerEnv) {
    		addAll(0,outerEnv);
    	}

        /**
         * Merge an inner environment: add it last.
         */
    	public void mergeInnerEnvironment(Environment innerEnv) {
    	   addAll(innerEnv);
    	}

        public Environment clone() {
        	Environment env = new Environment();
        	env.addAll(this);
        	return env;
        }
    	
    	/**
    	 * TODO: implement!
    	 */
        public Environment peel(String name) {
        	return new Environment();
        }
        
        public String toString() {
           StringBuffer str = new StringBuffer();
           str.append("{");
           for (InstModification im : this) {
           	  str.append("  " + im.getModification().prettyPrint("") + ",\n");
           }
           str.append("}\n");
           return str.toString();
        }
        
        public String toString(String indent) {
           StringBuffer str = new StringBuffer();
           str.append(indent+"{");
           for (int i=0;i<size();i++) {
              InstModification im = get(i);
              if (i==0)
              	str.append(im.getModification().prettyPrint(""));
           	  else
           	  	str.append(indent + " " +  im.getModification().prettyPrint(""));
              if (i !=size()-1)
              	str.append(",\n");
           }
           str.append("}\n");
           return str.toString();
        }
    
    }

	class InstModification {
	   private InstNode instNode;
	   private Modification modification;
	   
	   public InstModification(InstNode instNode, Modification modification) {
	   	  this.instNode = instNode;
	   	  this.modification = modification;
	   }
	   
	   public InstNode getInstNode() {
	  	  return instNode; 
	   }
	   
	   public Modification getModification() {
	   	  return modification;
	   }
	  
	   public ArrayList<InstModification> expand() { 	  
	   	  ArrayList<InstModification> l = new ArrayList<InstModification>();
	   	  if (getModification() instanceof CompleteModification) {  
				CompleteModification cm = (CompleteModification)getModification();
				for (int i=0;i<cm.getClassModification().getNumArgument();i++) {
					InstModification im = new InstModification(getInstNode(),cm.getClassModification().getArgument(i));
				    l.addAll(im.expand());
				} if (cm.hasValueModification())
					l.add(new InstModification(getInstNode(),cm.getValueModification()));
				return l;
			} if (getModification() instanceof ClassModification) { 
				ClassModification cm = (ClassModification)getModification();
				for (int i=0;i<cm.getNumArgument();i++) {
					InstModification im = new InstModification(getInstNode(),cm.getArgument(i));
					l.addAll(im.expand());
				}
				return l;
		  } else {
		     l.add(this);
		  }
		  return l;
	    }
	}



    syn int InstNode.getNumMergedEnvironment() =
    	getMergedEnvironmentList().size();
    
    syn InstModification InstNode.getMergedEnvironment(int i) = 
        getMergedEnvironmentList().get(i); 

    /* getMergedEnvironment gives the environment applicable
       to the children of the InstNode. It consists of the outer modifications
       in the environment (with the name of the InstNode itself, if any,
       removed) merged with potential local modifications.
    
       TODO: Should this attribute be lazy? Probably yes
      
    */   
    
    // TODO: merge also class redeclaration modifications    
	syn lazy Environment InstNode.getMergedEnvironmentList() {
		debugPrint("InstNode.getMergedEnvironmentList()");
		// Retrieve modifications upwards
		Environment env = nameScope()? myEnvironment(name()).clone(): myEnvironment();
		for (int i=0;i<localModifications().size();i++)
			env.mergeInnerModification(this,(Modification)localModifications().get(i));
  
		return env;
	}
	
	/**
	 * myEnvironment represents the environment of the InstNode itself. It is defined
	 * as an inherited attribute and is computed from the outer environment located at
	 * ancestor InstNodes.
	 */	
	inh lazy Environment InstNode.myEnvironment();
	inh lazy Environment InstNode.myEnvironment(String name);
	
	
	/**
	 * When no arguments are supplied to myEnvironment, the MergedEnvironment of the ancestor
	 * InstNode is simply duplicated. This is typically the case for extends clauses.
	 */
	eq InstNode.getInstNode().myEnvironment() {
		Environment env = new Environment();
		for (int i=0;i<getNumMergedEnvironment();i++)			
			env.mergeInnerModification(getMergedEnvironment(i).getInstNode(),
			                             getMergedEnvironment(i).getModification());	
		return env;
	}
	
	/** 
	 * When a string argument representing a component name is given as argument to myEnvironment,
	 * the resulting environment consists only of modifications with a matching prefix. In effect, this 
	 * results in a "peeling" operation, where the first name in a qualified name is removed, and the rest
	 * of the modification is added to myEnvironment. The algorithm is somewhat complicated by component
	 * redeclares that needs to be taken into account. 
	 */
	eq InstNode.getInstNode().myEnvironment(String name) = localMyEnvironment(name);
	
	
	syn Environment InstNode.localMyEnvironment(String name) {
	    if(!is$Final) throw new Error("Node '"+toString() +"' is not final\n**Parent: "+getParent().getParent().toString());
		//System.out.println("InstNode.getInstNode().myEnvironment(): "+name() + " looking for " + name);
		Environment env = new Environment();
	    boolean foundReplacing = false;
		for (int i=0;i<getNumMergedEnvironment();i++) {
		    // Find first ComponentRedeclare: this is the replacing Component, and
		    // its modifications should be included, not only those that resides in a constraining clause.
		    // Notice that potential modifications in a constraining clause are added below in the call to
		    // matchModification.
		    if (!foundReplacing && getMergedEnvironment(i).getModification() instanceof  ComponentRedeclare &&
		          ((ComponentRedeclare)getMergedEnvironment(i).getModification()).getName().getID().equals(name)) {
		        foundReplacing = true;
		        ComponentRedeclare cdr = (ComponentRedeclare)getMergedEnvironment(i).getModification();
		        if (cdr.getName().getID().equals(name) && 
		            cdr.getComponentDecl().hasModification()) 
		    		env.mergeInnerModification(getMergedEnvironment(i).getInstNode(),
		    		   cdr.getComponentDecl().getModification());
		    }
            // This merges modifications in the environment. For ComponentRedeclare:s
            // only modifications in the constraining clause are merged.
			Modification m = getMergedEnvironment(i).getModification().matchModification(name);
			if (m!=null)
				env.mergeInnerModification(getMergedEnvironment(i).getInstNode(),m);
		}
		//System.out.println("| " + env.toString(""));
		return env;
	}
		
	syn lazy Modification Modification.matchModification(String name) = null;
	eq CompleteModification.matchModification(String name) {
		for (int i=0;i<getClassModification().getNumArgument();i++)
			if (getClassModification().getArgument(i).matchModification(name)!=null)
				return getClassModification().getArgument(i).matchModification(name);
		return null;
	}
	
	eq ComponentModification.matchModification(String name) {
		debugPrint("ComponentModification.matchModification: " + name);
		if (name.equals(getName().getID()))
			return getModification();
		return null;
	}
	
	// Only add modifiers in constraining clauses
	eq ComponentRedeclare.matchModification(String name) {
		if (name.equals(getName().getID()) && getComponentDecl().hasConstrainingClause() &&
		    getComponentDecl().getConstrainingClause().hasClassModification())
			return getComponentDecl().getConstrainingClause().getClassModification();
//		if (name.equals(getName().getID()) && getComponentDecl().hasModification())
//			return getComponentDecl().getModification();

		return null;
	}
	
	syn lazy ComponentDecl Modification.matchComponentRedeclare(String name) = null;
	eq ComponentRedeclare.matchComponentRedeclare(String name) {
		if (getName().getID().equals(name))
			return getComponentDecl();
		else
			return null;
	}
	
    syn lazy BaseClassDecl Modification.matchClassRedeclare(String name) = null;
	eq ClassRedeclare.matchClassRedeclare(String name) {
		//if (getName().getID().equals(name))
		if (getBaseClassDecl().name().equals(name))
			return getBaseClassDecl();
		else
			return null;
	}
	
	
	eq BaseClassDecl.getInstRoot().myEnvironment() = new Environment();
	eq BaseClassDecl.getInstRoot().myEnvironment(String name) = new Environment();
	
	// Definition of the NTA representing the root of the 
	// instantiation tree
	syn InstRoot BaseClassDecl.getInstRoot() = new InstClassRoot(new List(),this);

//	syn nta InstConstrainingClauseRoot ConstrainingClause.instConstrainingClauseRoot() = new InstConstrainingClauseRoot(new List(),this);


	syn lazy List InstNode.getInstNodeList() {
	
		List l = new List();
		List comps = components();
		List supers = superClasses();	
		
		for (int i=0;i<comps.getNumChild();i++) {
			ComponentDecl cd = (ComponentDecl)comps.getChild(i);
		    l.add(createInstNode(cd));
		}				
	
		for (int i=0;i<supers.getNumChild();i++) {
			l.add(createInstNode(((ExtendsClause)supers.getChild(i))));
		}
		return l;
	}

    public InstNode InstNode.createInstNode(ComponentDecl cd) {
            // Check if the component is redeclared
            InstModification im = retrieveReplacingComponent(cd.name());

            // Check if the class of the component is redeclared
			if (im != null) {
		       ComponentDecl replacingComponent = im.getModification().matchComponentRedeclare(cd.name());
		       // This is a bit tricky. The retrieveReplacingClass method should be invoked in the InstNode
		       // ancestor InstNode of the InstNode for which the ComponentRedeclare is given.
               ClassDecl classToExpand = im.getInstNode().ancestorInstNode().retrieveReplacingClass(replacingComponent.myClass().name());
			    if (classToExpand!=null) {
			    // TODO: Add support for InstReplacingPrimitive
				 return new InstReplacingComposite(new List<FExp>(),replacingComponent,classToExpand,cd);
			    } else {
			     return new InstReplacingComposite(new List<FExp>(),replacingComponent,replacingComponent.myClass(),cd);
			    }
			} else {
			    // Check if the class of the component is redeclared
                ClassDecl classToExpand = retrieveReplacingClass(cd.myClass().name());
			    if (classToExpand!=null) {
			        return cd.newInstComponent(classToExpand);
				} else {
					return cd.newInstComponent(cd.myClass());   
  				}
            }
    }
    
   public InstNode InstNode.createInstNode(ExtendsClause ec) {
   		return ec.newInstExtends();
   }

   inh InstNode InstNode.ancestorInstNode();
//   eq InstRoot.getChild().ancestorInstNode() = null;
   eq InstNode.getChild().ancestorInstNode() = this;
   

	eq InstPrimitive.getInstNodeList() = new List();

    /**
     * In order to retrieve a replacing class declaration, it is necessary to
     * search in the MergedEnvironment() of the parent InstNode, which is equivalent to 
     * searching the evironment myEnvironment() (notice, without argument.)
     */
    syn BaseClassDecl InstNode.retrieveReplacingClass(String name) {
        Environment env = getMergedEnvironmentList();
        for (int i=0;i<env.size();i++) {
			if (env.get(i).getModification().matchClassRedeclare(name)!=null) {
				return env.get(i).getModification().matchClassRedeclare(name);
			}
		}
		return null;
    }

    /**
     * Notice that retrieveReplacingComponent returns an InstModification object so that
     * this modification can be checked for class redeclarations which must be done at the
     * correct ancestor InstNode.
     */
	syn InstModification InstNode.retrieveReplacingComponent(String name) {
		for (int i=0;i<getNumMergedEnvironment();i++) {
			if (getMergedEnvironment(i).getModification().matchComponentRedeclare(name)!=null) {
				return getMergedEnvironment(i);
			}
		}
		return null;
	}


	// Attribute for building an InstComposite node based
	// on a ComponentDecl
	public InstComponent ComponentDecl.newInstComponent(ClassDecl classToExpand) {
	   //return myClass().newInstComponent(this);
	   return classToExpand.newInstComponent(this);
	}
	
	// Dispatch w.r.t. class type
	public abstract InstComponent ClassDecl.newInstComponent(ComponentDecl cd);

	public InstComponent BaseClassDecl.newInstComponent(ComponentDecl cd) {
		if (!extendsPrimitive())
			return new InstComposite(new List(),cd,this);
		else {
			return new InstPrimitive(new List(),cd,this);
		}
	}
	
	public InstComponent ShortClassDecl.newInstComponent(ComponentDecl cd) {
		return getClassName().myClassDecl().newInstComponent(cd);
	}
	
	public InstComponent PrimitiveClassDecl.newInstComponent(ComponentDecl cd) {
		return new InstPrimitive(new List(),cd,this);
	}
	
	public InstComponent BuiltInClassDecl.newInstComponent(ComponentDecl cd) {
		return null;
	}
	
	// Build an InstExtends
	public InstExtends ExtendsClause.newInstExtends() {
		return new InstExtends(new List(),this);
	}

	syn boolean ClassDecl.extendsPrimitive() = false;
	eq ShortClassDecl.extendsPrimitive() = finalClass().extendsPrimitive();
	eq FullClassDecl.extendsPrimitive(){
		return (getNumSuper()==1 && getSuper(0).getSuper().myClassDecl().finalClass().isPrimitive());
	}
	
	// The following attributes defines a generic interface
	// for InstNodes	
	// Just to avoid casts... (Is this a good idea? yes.)
	syn lazy List ClassDecl.equations() = root().emptyList();
	eq FullClassDecl.equations() = getEquationList();
	eq ShortClassDecl.equations() = getClassName().myClassDecl().equations();
	
	syn lazy List ClassDecl.superClasses() = root().emptyList();
	eq FullClassDecl.superClasses() = getSuperList();
	eq ShortClassDecl.superClasses() = getClassName().myClassDecl().superClasses();
	
	
	// TODO: should Lists really be return here?
	syn lazy List ClassDecl.components() = root().emptyList();
	eq FullClassDecl.components() = getComponentDeclList();
	eq ShortClassDecl.components() = getClassName().myClassDecl().components();
	
	syn boolean InstNode.nameScope() = false;
	eq InstComponent.nameScope() = true;

    syn String InstNode.name() = "";
    eq InstComponent.name() = getComponentDecl().name();
	
	syn lazy ArrayList<Modification> InstNode.localModifications() = new ArrayList<Modification>();
	eq InstComponent.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		// Add modifications of the declaration itself
		if (getComponentDecl().hasModification())
			l.add(getComponentDecl().getModification());
			
	    // If there is a constraining clause, these modifications should be merged as well 
		if (getComponentDecl().hasConstrainingClause() &&
		       getComponentDecl().getConstrainingClause().hasClassModification())
		  	l.add(getComponentDecl().getConstrainingClause().getClassModification());	
		    
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getComponentDecl().myClass().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		// This is to take into account the case when we instantiate a
		// component based on a class which inherits from a primitive type
//		if (getComponentDecl().myClass().extendsPrimitive()) {
//			if (getComponentDecl().myClass().getSuper(0).hasClassModification())	
//				l.add(getComponentDecl().myClass().getSuper(0).getSuper().getClassModification());	
//		}
		
		return l;
		
	}

	eq InstReplacingComposite.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		// If there is a constraining clase, return its modifications
		if (getOriginalDecl().hasConstrainingClause()) {
		  if (getOriginalDecl().getConstrainingClause().hasClassModification()) {
			l.add(getOriginalDecl().getConstrainingClause().getClassModification());
          }
        } else {
            // If no constraining clause, use the original declaration 
            // and return its modifiers
     		if (getOriginalDecl().hasModification())
				l.add(getOriginalDecl().getModification());     
        }

		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getOriginalDecl().myClass().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		
		return l;
	}
	
	eq InstExtends.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (getExtendsClause().hasClassModification())
			l.add(getExtendsClause().getClassModification());
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getExtendsClause().getSuper().myClassDecl().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		return l;
	}

	syn lazy ArrayList<Modification> ClassDecl.classModifications() = new ArrayList<Modification>();
	eq FullClassDecl.classModifications() {
		if (!extendsPrimitive())
			return new ArrayList<Modification>();
		else {
		    // Add (optional) modification on the ExtendsClause
			ArrayList<Modification> l = new ArrayList<Modification>();
			if (getSuper(0).hasClassModification())
				l.add(getSuper(0).getClassModification());
			// If we inherit from a ShortClassDecl there might be additional
			// modifications	
			ArrayList<Modification> classMods = getSuper(0).getSuper().myClassDecl().classModifications();
			for (int i = 0;i<classMods.size();i++)
				l.add(classMods.get(i));		
			return l;
		}
		
	}
	
	eq ShortClassDecl.classModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (hasClassModification())
			l.add(getClassModification());
		ArrayList<Modification> classMods = getClassName().myClassDecl().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		return l;
	}
	
	/**
	 * classToExpand returns the class to expand for a particular InstComponent when taking
	 * the environment into account.
	 */
	syn lazy ClassDecl InstComponent.classToExpand() {
         ClassDecl classToExpand = getClassDecl();
	     if (!constrainingType())
	       return classToExpand;
	     else {
	        if (!getComponentDecl().hasConstrainingClause()) // Constraining clause same as original decl in this case
	          return classToExpand;
	        else {
	          return getComponentDecl().getConstrainingClause().getAccess().myClassDecl();
	        }
	     }


/*
	  
	  if (retrieveReplacingClass(getComponentDecl().myClass().name())!=null) {
	     classToExpand = retrieveReplacingClass(getComponentDecl().myClass().name());
	  } else {
	     classToExpand = getComponentDecl().myClass();
	  }
	     
	     if (!constrainingType())
	       return classToExpand;
	     else {
	        if (!getComponentDecl().hasConstrainingClause()) // Constraining clause same as original decl in this case
	          return classToExpand;
	        else {
	          if (retrieveReplacingClass(getComponentDecl().getConstrainingClause().getAccess().myClassDecl().name())!=null) {
	             classToExpand = retrieveReplacingClass(getComponentDecl().getConstrainingClause().getAccess().myClassDecl().name());
	          } else {
	             classToExpand = getComponentDecl().getConstrainingClause().getAccess().myClassDecl();
	          }
	          return classToExpand;
	        }
	     }
	*/
	}
	
	syn List InstNode.equations();
	eq InstClassRoot.equations() = getClassDecl().equations();
	eq InstComponent.equations() = classToExpand().equations();
	eq InstExtends.equations() = getExtendsClause().getSuper().myClassDecl().equations();
	
	syn lazy List InstNode.components();
	eq InstClassRoot.components() = getClassDecl().components();
	// This attribute also needs to take into account that a class declaration
	// may be redeclared.
	eq InstComponent.components() = classToExpand().components();
	eq InstExtends.components() = getExtendsClause().getSuper().myClassDecl().components();
	
	syn lazy List InstNode.superClasses();
	eq InstClassRoot.superClasses() = getClassDecl().superClasses();
	eq InstComponent.superClasses() = classToExpand().superClasses();
	eq InstExtends.superClasses() = getExtendsClause().getSuper().myClassDecl().superClasses();

}

aspect InstanceDumpTree {

	// Some basic dump routines
	public void InstNode.dumpTree(String indent) {
		System.out.println(indent + dump());
		System.out.println(toString(indent+"|"));
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstComposite.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name());
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstPrimitive.dumpTree(String indent) {
		System.out.println(indent + dump()
							  + ": " + 
		                      getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name());
		System.out.println(toString(indent+"|"));

	}
	
 	public String InstNode.toString() {
		return toString("");
    }
	public String InstNode.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstNode:\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString(indent+" "));
	   return str.toString();	
	}
  
  
	public String InstReplacingComposite.toString() {
		return toString("");
    }
	public String InstReplacingComposite.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstReplacingComponent:\n");
	   str.append(indent+" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString(indent+" "));
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
		return toString("");
    }
	public String InstPrimitive.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstPrimitive:\n");
	   str.append(indent+" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString(indent+" "));
	   return str.toString();	
	}

	public String InstComposite.toString() {
		return toString("");
    }
	public String InstComposite.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstComposite:\n");
	   str.append(indent+" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironmentList().toString(indent+" "));
	   //str.append(indent+" Declared type:\n");
	   //str.append(indent+declaredType().toString());
	   //str.append(indent+" Constraining type:\n");
	   //str.append(indent+constrainingType().toString());
	   
	   return str.toString();	
	}

	public String InstModification.toString() {
		return toString("");
    }
    public String InstModification.toString(String indent) {
    	return getModification().prettyPrint(indent);
    
    }
	
	
}

aspect InstancePrettyPrint {

	public String InstNode.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent + str.substring(str.lastIndexOf('.')+1);
		return str;

	}
	public String InstPrimitive.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name();
		return str;

	}

}
