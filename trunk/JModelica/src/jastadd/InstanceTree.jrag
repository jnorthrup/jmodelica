import java.util.ArrayList;

aspect InstantiationTree {

   	// This rewrite eliminates CompositeModifications as children of
	// InstModifications, which simplifies implementation.
	/*
	public boolean InstModification.rewritten = false;
	rewrite InstModification in Environment.getInstModification(){
		when(!rewritten)
		to List {
			if (getModification() instanceof CompleteModification) {  
				List l = new List();
				CompleteModification cm = (CompleteModification)getModification();
				for (int i=0;i<cm.getClassModification().getNumArgument();i++)
					l.add(new InstModification(getInstNode(),cm.getClassModification().getArgument(i)));
				if (cm.hasValueModification())
					l.add(new InstModification(getInstNode(),cm.getValueModification()));
				return l;
		} if (getModification() instanceof ClassModification) { 
				List l = new List();
				ClassModification cm = (ClassModification)getModification();
				for (int i=0;i<cm.getNumArgument();i++)
					l.add(new InstModification(getInstNode(),cm.getArgument(i)));
				return l;
		} else {
			this.rewritten = true;
			return new List().add(this);
		}
		}
	}
	*/
	
	rewrite InstCompleteModification in Environment.getInstModification(){
		to List {
			List l = new List();
			for (int i=0;i<getClassModification().getNumArgument();i++)
				l.add(getClassModification().getArgument(i).newInstModification(getInstNode()));
			if (hasValueModification())
				l.add(getValueModification().newInstModification(getInstNode()));
			return l;	
		}
	}
	
	rewrite InstClassModification in Environment.getInstModification(){
		to List {
			List l = new List();
			for (int i=0;i<getClassModification().getNumArgument();i++)
				l.add(getClassModification().getArgument(i).newInstModification(getInstNode()));
			return l;	
		}
	}

	public InstModification Modification.newInstModification(InstNode n) {
		return new InstModification(n,this);
	}

	public InstModification CompleteModification.newInstModification(InstNode n) {
		return new InstCompleteModification(n,this);
	}

	public InstModification ClassModification.newInstModification(InstNode n) {
		return new InstClassModification(n,this);
	}
	
	public InstModification ValueModification.newInstModification(InstNode n) {
		return new InstValueModification(n,this);
	}

	public InstModification ComponentModification.newInstModification(InstNode n) {
		return new InstComponentModification(n,this,getName().newInstAccess());
	}

	public InstModification ComponentRedeclare.newInstModification(InstNode n) {
		return new InstComponentRedeclare(n,this,getName().newInstAccess());
	}

	public InstModification ClassRedeclare.newInstModification(InstNode n) {
		return new InstClassRedeclare(n,this,getName().newInstAccess());
	}
	
	syn CompleteModification InstCompleteModification.getCompleteModification() = (CompleteModification)getModification();
	syn boolean InstCompleteModification.hasValueModification() = getCompleteModification().hasValueModification();
	syn ValueModification InstCompleteModification.getValueModification() = getCompleteModification().getValueModification();
	syn ClassModification InstCompleteModification.getClassModification() = getCompleteModification().getClassModification();

	syn ClassModification InstClassModification.getClassModification() = (ClassModification)getModification();
	syn ValueModification InstValueModification.getValueModification() = (ValueModification)getModification();
	syn ComponentModification InstComponentModification.getComponentModification() = (ComponentModification)getModification();
	syn ComponentRedeclare InstComponentRedeclare.getComponentRedeclare() = (ComponentRedeclare)getModification();
	syn ClassRedeclare InstClassRedeclare.getClassRedeclare() = (ClassRedeclare)getModification();

        /**
         * Merge an outer modification into the environment: add it at the beginning.
         */    
    	public void Environment.mergeOuterModification(InstNode n, Modification outerMod) {
    		//InstModification im = new InstModification(n,outerMod);
    		InstModification im = outerMod.newInstModification(n);
			getInstModificationList().insertChild(im,0);

    	}

        /**
         * Merge an inner modification into the environment: add it last.
         */    
    	public void Environment.mergeInnerModification(InstNode n, Modification innerMod) {
    		//InstModification im = new InstModification(n,innerMod);
    		InstModification im = innerMod.newInstModification(n);
    		getInstModificationList().addChild(im);    	
    	}

        /**
         * Merge an outer environment: add it first.
         */ 
//    	public void Environment.mergeOuterEnvironment(Environment outerEnv) {
//    		addAll(0,outerEnv);
//    	}

        /**
         * Merge an inner environment: add it last.
         */
//    	public void mergeInnerEnvironment(Environment innerEnv) {
//    	   addAll(innerEnv);
//    	}

        public Environment Environment.duplicate() {
        	Environment env = new Environment();
         	for (InstModification im : getInstModifications())
        		env.addInstModification((InstModification)im.copy());
        	return env;
        }
    	
    	/**
    	 * TODO: implement!
    	 */
//        public Environment peel(String name) {
//        	return new Environment();
//        }
        
        public String Environment.toString() {
           StringBuffer str = new StringBuffer();
           str.append("{");
           for (InstModification im : getInstModifications()) {
           	  str.append("  " + im.getModification().prettyPrint("") + ",\n");
           }
           str.append("}\n");
           return str.toString();
        }
        
        public String Environment.toString(String indent) {
           StringBuffer str = new StringBuffer();
           str.append(indent+"{");
           for (int i=0;i<getNumInstModification();i++) {
              InstModification im = getInstModification(i);
              if (i==0)
              	str.append(im.getModification().prettyPrint(""));
           	  else
           	  	str.append(indent + " " +  im.getModification().prettyPrint(""));
              if (i !=getNumInstModification()-1)
              	str.append(",\n");
           }
           str.append("}\n");
           return str.toString();
        }



 
    /* getMergedEnvironment gives the environment applicable
       to the children of the InstNode. It consists of the outer modifications
       in the environment (with the name of the InstNode itself, if any,
       removed) merged with potential local modifications.
    
       TODO: Should this attribute be lazy? Probably yes
      
    */   
    
    // TODO: merge also class redeclaration modifications    
	syn lazy Environment InstNode.getMergedEnvironment() {
		// Retrieve modifications upwards
		Environment env = nameScope()? myEnvironment(name()).duplicate(): myEnvironment().duplicate();
		for (int i=0;i<localModifications().size();i++)
			env.mergeInnerModification(this,(Modification)localModifications().get(i));
  
		return env;
	}
	
	// Wrapper functions
//	syn int InstNode.getNumMergedEnvironment() = getMergedEnvironmentList().getNumInstModification();
//    syn InstModification InstNode.getMergedEnvironment(int i) = getMergedEnvironmentList().getInstModification(i);
//	syn List InstNode.getMergedEnvironmentList() = getEnvironment().getInstModificationList();
	
	/**
	 * myEnvironment represents the environment of the InstNode itself. It is defined
	 * as an inherited attribute and is computed from the outer environment located at
	 * ancestor InstNodes.
	 */	
	inh nta Environment InstNode.myEnvironment();
	syn nta Environment InstNode.myEnvironment(String compName) = myEnvironment("",compName);
	eq InstComponentDecl.myEnvironment(String compName) = myEnvironment(myInstClass().name(),compName);
	inh  nta Environment InstNode.myEnvironment(String className, String compName); // TODO: Make sure this is lazy - removed for debugging
	
	
	/**
	 * When no arguments are supplied to myEnvironment, the MergedEnvironment of the ancestor
	 * InstNode is simply duplicated. This is typically the case for extends clauses.
	 */
	eq InstNode.getInstNode().myEnvironment() = getMergedEnvironment().duplicate();
	
	/** 
	 * When a string argument representing a component name is given as argument to myEnvironment,
	 * the resulting environment consists only of modifications with a matching prefix. In effect, this 
	 * results in a "peeling" operation, where the first name in a qualified name is removed, and the rest
	 * of the modification is added to myEnvironment. The algorithm is somewhat complicated by component
	 * redeclares that needs to be taken into account. 
	 */
	eq InstNode.getInstNode().myEnvironment(String className, String compName) = localMyEnvironment(className, compName);
	
	syn Environment InstNode.localMyEnvironment(String className, String compName) {
	    if(!is$Final) throw new Error("Node '"+toString() +"' is not final\n**Parent: "+getParent().getParent().toString());
		//System.out.println("InstNode.getInstNode().myEnvironment(): "+name() + " looking for " + name);
		ArrayList<InstModification> env = new ArrayList<InstModification>();
		ArrayList<InstModification> envCM = new ArrayList<InstModification>();
	    Environment mergedEnv = getMergedEnvironment();
	    boolean foundReplacingComponent = false;
   	    boolean foundReplacingClass = false;
   	    
		for (InstModification im : mergedEnv.getInstModifications()) {
		    // Find first ComponentRedeclare: this is the replacing Component, and
		    // its modifications should be included, not only those that resides in a constraining clause.
		    // Notice that potential modifications in a constraining clause are added below in the call to
		    // matchModification.
		    if (!foundReplacingComponent && im.getModification() instanceof  ComponentRedeclare &&
		          ((ComponentRedeclare)im.getModification()).getName().getID().equals(compName)) {
		        foundReplacingComponent = true;
		        ComponentRedeclare cdr = (ComponentRedeclare)im.getModification();
	            if (cdr.getComponentDecl().hasModification()) 
	    			env.add(cdr.getComponentDecl().getModification().newInstModification(im.getInstNode()));
	    	    ArrayList<Modification> classMods = cdr.getComponentDecl().myClass().classModifications();
	    	    //ArrayList<Modification> classMods = im.myInstClassDecl().classModifications();
	            for (int j = 0;j<classMods.size();j++)
	               envCM.add(classMods.get(j).newInstModification(im.getInstNode()));   
		    }
		    /*
		    if (!foundReplacingClass && getMergedEnvironment(i).getModification() instanceof  ClassRedeclare &&
		          ((ClassRedeclare)getMergedEnvironment(i).getModification()).getName().getID().equals(className)) {
		        foundReplacingClass = true;
		        ClassRedeclare cdr = (ClassRedeclare)getMergedEnvironment(i).getModification();
		        if (cdr.getBaseClassDecl().name().equals(className)) {
		        	ArrayList<Modification> classMods = cdr.getBaseClassDecl().classModifications();
		            for (int j = 0;j<classMods.size();j++)
		               envCM.mergeInnerModification(getMergedEnvironment(i).getInstNode(),
		    		   	                          classMods.get(j));
		        } 
		    }
		    */
		     
            // This merges modifications in the environment. For ComponentRedeclare:s
            // only modifications in the constraining clause are merged, see the corresponding
            // implementation of matchModification
			Modification m = im.getModification().matchModification(compName);
			if (m!=null) 
					env.add(m.newInstModification(im.getInstNode()));
			
			/*		
			// This merges modifications in the environment. For ClassRedeclare:s
            // only modifications in the constraining clause are merged, see the corresponding
            // implementation of matchModification
			m = getMergedEnvironment(i).getModification().matchModification(className);
			if (m!=null) 
					env.mergeInnerModification(getMergedEnvironment(i).getInstNode(),m);		
	        
	        // If the modification in MergedEnvironment is a ClassRedeclare, then it should be 
	        // added to myEnvironment only if the InstNode of the ClassRedeclare is the current
	        // InstNode
	        if (getMergedEnvironment(i).getModification() instanceof ClassRedeclare &&
	            getMergedEnvironment(i).getInstNode() == this)
	            	env.mergeInnerModification(getMergedEnvironment(i).getInstNode(),getMergedEnvironment(i).getModification());	
	        */
		}
//		env.mergeInnerEnvironment(envCM);
		Environment theEnv = new Environment();
		for (InstModification im : env)
			theEnv.addInstModification(im);
		for (InstModification im : envCM)
			theEnv.addInstModification(im);

		//System.out.println("| " + env.toString(""));
		return theEnv;
	}
		
	syn lazy Modification Modification.matchModification(String name) = null;
	eq CompleteModification.matchModification(String name) {
		for (int i=0;i<getClassModification().getNumArgument();i++)
			if (getClassModification().getArgument(i).matchModification(name)!=null)
				return getClassModification().getArgument(i).matchModification(name);
		return null;
	}
	
	eq ComponentModification.matchModification(String name) {
		debugPrint("ComponentModification.matchModification: " + name);
		if (name.equals(getName().getID()))
			return getModification();
		return null;
	}
	
	// Only add modifiers in constraining clauses
	eq ComponentRedeclare.matchModification(String name) {
		if (name.equals(getName().getID()) && getComponentDecl().hasConstrainingClause() &&
		    getComponentDecl().getConstrainingClause().hasClassModification())
			return getComponentDecl().getConstrainingClause().getClassModification();
		return null;
	}	
	
	// Only add modifiers in constraining clauses
//	eq ClassRedeclare.matchModification(String name) {
//		if (name.equals(getName().getID()) && getComponentDecl().hasConstrainingClause() &&
//		    getComponentDecl().getConstrainingClause().hasClassModification())
//			return getComponentDecl().getConstrainingClause().getClassModification();
//		return null;
//	}		
	
	
	syn lazy ComponentDecl Modification.matchComponentRedeclare(String name) = null;
	eq ComponentRedeclare.matchComponentRedeclare(String name) {
		if (getName().getID().equals(name))
			return getComponentDecl();
		else
			return null;
	}
	
    syn lazy ClassRedeclare Modification.matchClassRedeclare(String name) = null;
	eq ClassRedeclare.matchClassRedeclare(String name) {
		//if (getName().getID().equals(name))
		if (getBaseClassDecl().name().equals(name))
			return this;
		else
			return null;
	}
	
	
	eq BaseClassDecl.getInstRoot().myEnvironment() = new Environment();
	eq BaseClassDecl.getInstRoot().myEnvironment(String className, String compName) = new Environment();

	eq Program.getInstProgramRoot().myEnvironment() = new Environment();
	eq Program.getInstProgramRoot().myEnvironment(String className, String compName) = new Environment();
	
	
	
	// Definition of the NTA representing the root of the 
	// instantiation tree
	syn lazy InstRoot BaseClassDecl.getInstRoot() = new InstClassRoot(new List(),this);
//	syn lazy InstRoot InstBaseClassDecl.getInstRoot() = new InstClassRoot(new List(),getBaseClassDecl());

//	syn nta InstConstrainingClauseRoot ConstrainingClause.instConstrainingClauseRoot() = new InstConstrainingClauseRoot(new List(),this);

//    syn lazy List InstPrimitiveClassDecl.getInstNodeList() = emptyList();
//    syn lazy List InstShortClassDecl.getInstNodeList() = getShortClassDecl().extendsPrimitive()? emptyList() : super.getInstNodeList();
	
	syn lazy List InstNode.getInstNodeList() {
	
		List l = new List();
		List comps = components();
		List classes = classes();
		List supers = superClasses();	
		
		for (int i=0;i<classes.getNumChild();i++) {
			BaseClassDecl bcd = (BaseClassDecl)classes.getChild(i);
		    l.add(createInstNode(bcd));
		}				
		
		
		
		for (int i=0;i<comps.getNumChild();i++) {
			ComponentDecl cd = (ComponentDecl)comps.getChild(i);
		    l.add(createInstNode(cd));
		}				
	
		for (int i=0;i<supers.getNumChild();i++) {
			l.add(createInstNode(((ExtendsClause)supers.getChild(i))));
		}
		
		
		return l;
	}

 
    public InstNode InstNode.createInstNode(ComponentDecl cd) {
            // Check if the component is redeclared
            InstModification im = retrieveReplacingComponent(cd.name());

            // Check if the class of the component is redeclared
			if (im != null) {
		       ComponentDecl replacingComponent = im.getModification().matchComponentRedeclare(cd.name());
               ClassDecl classToExpand = im.getInstNode().retrieveReplacingClass(replacingComponent.myClass().name());
			    if (classToExpand!=null) {
			    // TODO: Add support for InstReplacingPrimitive
				 InstReplacingComposite irc = new InstReplacingComposite(new List<FExp>(),cd.newInstClassAccess(),replacingComponent,classToExpand,new Opt(),new Opt(),cd);
				 if (cd.hasModification())
					irc.setIModification(cd.getModification().newIModification());
				 if (cd.hasConstrainingClause())
					irc.setInstConstraining(cd.getConstrainingClause().newInstConstraining());
 				 return irc;
			    } else {
			     InstReplacingComposite irc = new InstReplacingComposite(new List<FExp>(),cd.newInstClassAccess(),replacingComponent,replacingComponent.myClass(),new Opt(),new Opt(),cd);
				 if (cd.hasModification())
					irc.setIModification(cd.getModification().newIModification());
				 if (cd.hasConstrainingClause())
					irc.setInstConstraining(cd.getConstrainingClause().newInstConstraining());
 				 return irc;
			    }
			} else {
			    // Check if the class of the component is redeclared
                ClassDecl classToExpand = retrieveReplacingClass(cd.myClass().name());
			    if (classToExpand!=null) {
			        return cd.newInstComponentDecl(classToExpand);
				} else {
					return cd.newInstComponentDecl(cd.myClass());   
  				}
            }
    }
    
   public InstNode InstNode.createInstNode(BaseClassDecl bcd) {
   		return bcd.newInstClassDecl();
   }    
    
   public InstNode InstNode.createInstNode(ExtendsClause ec) {
   		return ec.newInstExtends();
   }

   inh InstNode InstNode.ancestorInstNode();
//   eq InstRoot.getChild().ancestorInstNode() = null;
   eq InstNode.getChild().ancestorInstNode() = this;
   

	eq InstPrimitive.getInstNodeList() = emptyList();

    public BaseClassDecl InstNode.retrieveReplacingAliasClass(InstModification im) {
		ClassRedeclare cr = (ClassRedeclare)im.getModification();
		BaseClassDecl nextAliasClass = cr.getBaseClassDecl().nextAliasClass();
		
		BaseClassDecl replacingBaseClassDecl = null;
		while (nextAliasClass != null) {
			replacingBaseClassDecl = 
		    	im.getInstNode().retrieveReplacingClass(nextAliasClass.name());
			if (replacingBaseClassDecl==null) {
				nextAliasClass = nextAliasClass.nextAliasClass();
			} else {
				nextAliasClass = null;
			}
			
		}
		
		return replacingBaseClassDecl;

    }

    syn BaseClassDecl InstNode.retrieveReplacingClass(String name) {
        //String name = cd.myClass().name();    
        Environment env = getMergedEnvironment();
        for (InstModification im : env.getInstModifications()) {
			if (im.getModification().matchClassRedeclare(name)!=null) {
			    ClassRedeclare cr = im.getModification().matchClassRedeclare(name);
			    // Check if this class, in turn, is redeclared
                BaseClassDecl bcdr = null;
                if (cr.getBaseClassDecl().isAliasClass())
                	bcdr = retrieveReplacingAliasClass(im);
			    return bcdr!=null? bcdr: cr.getBaseClassDecl();
			}
		}


/* NO!! This does not work for hierarchical redeclarations of classes in packages.
   In order to handle this, the new lookup-scheme based on types rather than classes
   needs to be implemented.

		// Ok, there was no ClassRedeclare in the Environment, but there may still be
		// ClassRedeclares in package modifications.
		Environment envCM = new Environment();
		ArrayList<Modification> classMods = cd.getClassName().classModifications();
	    for (int j = 0;j<classMods.size();j++)
		   envCM.mergeInnerModification(this,
		    		   	                classMods.get(j));

		for (int i = 0;i<envCM.size();i++)
		    if (envCM.get(i).getModification().matchClassRedeclare(cd.myClass().name())!=null) {
				return envCM.get(i).getModification().matchClassRedeclare(cd.myClass().name());
			}
*/			
			
		return null;
    }

    /**
     * Notice that retrieveReplacingComponent returns an InstModification object so that
     * this modification can be checked for class redeclarations which must be done at the
     * correct ancestor InstNode.
     */
	syn InstModification InstNode.retrieveReplacingComponent(String name) {
		for (InstModification im : getMergedEnvironment().getInstModifications()) {
			if (im.getModification().matchComponentRedeclare(name)!=null) {
				return im;
			}
		}
		return null;
	}


	// Attribute for building an InstComposite node based
	// on a ComponentDecl
	public InstComponentDecl ComponentDecl.newInstComponentDecl(ClassDecl classToExpand) {
	   //return myClass().newInstComponentDecl(this);
	   return classToExpand.newInstComponentDecl(this);
	}
	
	// Dispatch w.r.t. class type
	public abstract InstComponentDecl ClassDecl.newInstComponentDecl(ComponentDecl cd);

	public InstComponentDecl BaseClassDecl.newInstComponentDecl(ComponentDecl cd) {
		if (!extendsPrimitive()){
			InstComponentDecl icd = new InstComposite(new List(),cd.newInstClassAccess(),cd,this,new Opt(),new Opt());
			if (cd.hasModification())
				icd.setIModification(cd.getModification().newIModification());
			if (cd.hasConstrainingClause())
				icd.setInstConstraining(cd.getConstrainingClause().newInstConstraining());
			return icd;
		} else {
			InstPrimitive icd = new InstPrimitive(new List(),cd.newInstClassAccess(),cd,this,new Opt(),new Opt());
			if (cd.hasModification())
				icd.setIModification(cd.getModification().newIModification());
			if (cd.hasConstrainingClause())
				icd.setInstConstraining(cd.getConstrainingClause().newInstConstraining());
			return icd;

		}
	}
	
	public InstComponentDecl ShortClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return getClassName().myClassDecl().newInstComponentDecl(cd);
	}
	
	public InstComponentDecl PrimitiveClassDecl.newInstComponentDecl(ComponentDecl cd) {
		InstPrimitive ipr = new InstPrimitive(new List(),cd.newInstClassAccess(),cd,this,new Opt(),new Opt());
		if (cd.hasModification())
			ipr.setIModification(cd.getModification().newIModification());
		if (cd.hasConstrainingClause())
			ipr.setInstConstraining(cd.getConstrainingClause().newInstConstraining());
		return ipr;
	}
	
	public InstComponentDecl BuiltInClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return new InstBuiltIn(new List(),cd.newInstClassAccess(),cd,this,new Opt(),new Opt());
	}
	
	// Build an InstExtends
	public InstExtends ExtendsClause.newInstExtends() {
		InstExtends ie = new InstExtends(new List(),getSuper().newInstAccess(),this, new Opt());
		if (hasClassModification())
			ie.setIClassModification(getClassModification().newIModification());
		return ie;
	}

	public InstConstraining ConstrainingClause.newInstConstraining() {
	    Opt opt = hasClassModification()? new Opt(getClassModification().newIModification()) : new Opt();
		return new InstConstraining(this,getAccess().newInstAccess(),opt);
	}

	public abstract IModification Modification.newIModification();
	public ICompleteModification CompleteModification.newIModification() {
		ICompleteModification icm = new ICompleteModification(this,getClassModification().newIModification(),new Opt());
        if (hasValueModification())
        	icm.setIValueModification(getValueModification().newIModification());
        return icm;
	}	
	public IValueModification ValueModification.newIModification() {
		return new IValueModification(this);
	}
	public IClassModification ClassModification.newIModification () {
		List l = new List();
		for (Argument a : getArguments()) {
			l.add(a.newIModification());
		}
		return new IClassModification(this,l);
	}
	public IComponentModification ComponentModification.newIModification() {
		IComponentModification icm = new IComponentModification(this,getName().newInstAccess(),new Opt());
		if (hasModification())
			icm.setIModification(getModification().newIModification());
		return icm;
	}
	public IComponentRedeclare ComponentRedeclare.newIModification() {
	    // TODO: Can this component be redeclared?
		return new IComponentRedeclare(this,getName().newInstAccess(),getComponentDecl().newInstComponentDecl(getComponentDecl().myClass()));
	}
	public IComponentRedeclare PN_ComponentRedeclare.newIModification() {
		return null; // This should never be called since all PN_ComponentRedeclare:s are rewritten	    
	}	
	
	public IClassRedeclare ClassRedeclare.newIModification() {
		return new IClassRedeclare(this,getName().newInstAccess(),getBaseClassDecl().newInstClassDecl());
	}
	
	

	


	syn boolean ClassDecl.extendsPrimitive() = false;
	eq ShortClassDecl.extendsPrimitive() = finalClass().extendsPrimitive();
	eq FullClassDecl.extendsPrimitive(){
		return (getNumSuper()==1 && getSuper(0).getSuper().myClassDecl().finalClass().isPrimitive());
	}
	
	// The following attributes defines a generic interface
	// for InstNodes	
	// Just to avoid casts... (Is this a good idea? yes.)
	syn lazy List ClassDecl.equations() = root().emptyList();
	eq FullClassDecl.equations() = getEquationList();
	eq ShortClassDecl.equations() = getClassName().myClassDecl().equations();
	
	syn lazy List ClassDecl.superClasses() = root().emptyList();
	eq FullClassDecl.superClasses() = getSuperList();
	eq ShortClassDecl.superClasses() = getClassName().myClassDecl().superClasses();
	
	
	// TODO: should Lists really be return here?
	syn lazy List ClassDecl.components() = root().emptyList();
	eq FullClassDecl.components() = getComponentDeclList();
	eq ShortClassDecl.components() = getClassName().myClassDecl().components();
	//eq PrimitiveClassDecl.components() = emptyList();
	
	syn lazy List ClassDecl.classes() = emptyList();
    eq FullClassDecl.classes() = getClassDeclList();
	
	syn boolean InstNode.nameScope() = false;
	eq InstComponentDecl.nameScope() = true;

    syn String InstNode.name() = "";
    eq InstComponentDecl.name() = getComponentDecl().name();
    eq InstBaseClassDecl.name() = getBaseClassDecl().name();
    eq InstBuiltInClassDecl.name() = getBuiltInClassDecl().name();
	
	syn lazy ArrayList<Modification> InstNode.localModifications() = new ArrayList<Modification>();
	eq InstComponentDecl.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		// Add modifications of the declaration itself
		if (getComponentDecl().hasModification())
			l.add(getComponentDecl().getModification());
			
	    // If there is a constraining clause, these modifications should be merged as well 
		if (getComponentDecl().hasConstrainingClause() &&
		       getComponentDecl().getConstrainingClause().hasClassModification())
		  	l.add(getComponentDecl().getConstrainingClause().getClassModification());	
		    
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getComponentDecl().myClass().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		// This is to take into account the case when we instantiate a
		// component based on a class which inherits from a primitive type
//		if (getComponentDecl().myClass().extendsPrimitive()) {
//			if (getComponentDecl().myClass().getSuper(0).hasClassModification())	
//				l.add(getComponentDecl().myClass().getSuper(0).getSuper().getClassModification());	
//		}
		
		return l;
		
	}

	eq InstReplacingComposite.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		// If there is a constraining clase, return its modifications
		if (getOriginalDecl().hasConstrainingClause()) {
		  if (getOriginalDecl().getConstrainingClause().hasClassModification()) {
			l.add(getOriginalDecl().getConstrainingClause().getClassModification());
          }
        } else {
            // If no constraining clause, use the original declaration 
            // and return its modifiers
     		if (getOriginalDecl().hasModification())
				l.add(getOriginalDecl().getModification());     
        }

		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getOriginalDecl().myClass().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		
		return l;
	}
	
	eq InstExtends.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (getExtendsClause().hasClassModification())
			l.add(getExtendsClause().getClassModification());
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getExtendsClause().getSuper().myClassDecl().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		return l;
	}

/*    
    syn ArrayList<Modification> Access.classModifications() {
    	ArrayList<Modification> classMods = new ArrayList<Modification>();
    	ClassAccess access = (ClassAccess)getFirstAccess();
    	while (access!=null) {
    		classMods.addAll(access.myClassDecl().classModifications());
    		access = (ClassAccess)access.getNextAccess();
    	}
    	return classMods;
    }
*/

	syn lazy ArrayList<Modification> ClassDecl.classModifications() = new ArrayList<Modification>();
	eq FullClassDecl.classModifications() {
		if (!extendsPrimitive())
			return new ArrayList<Modification>();
		else {
		    // Add (optional) modification on the ExtendsClause
			ArrayList<Modification> l = new ArrayList<Modification>();
			if (getSuper(0).hasClassModification())
				l.add(getSuper(0).getClassModification());
			// If we inherit from a ShortClassDecl there might be additional
			// modifications	
			ArrayList<Modification> classMods = getSuper(0).getSuper().myClassDecl().classModifications();
			for (int i = 0;i<classMods.size();i++)
				l.add(classMods.get(i));		
			return l;
		}
		
	}
	
	syn lazy ArrayList<Modification> InstClassDecl.classModifications() = new ArrayList<Modification>();
	eq InstFullClassDecl.classModifications() = getFullClassDecl().classModifications();
	
	eq ShortClassDecl.classModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (hasClassModification())
			l.add(getClassModification());
		ArrayList<Modification> classMods = getClassName().myClassDecl().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		return l;
	}
	
	/**
	 * classToExpand returns the class to expand for a particular InstComponentDecl when taking
	 * the environment into account. This method is used in type checking.
	 */
	syn lazy ClassDecl InstComponentDecl.classToExpand() {
         ClassDecl classToExpand = getClassDecl();
	     if (!constrainingType())
	       return classToExpand;
	     else {
	        if (!getComponentDecl().hasConstrainingClause()) // Constraining clause same as original decl in this case
	          return classToExpand;
	        else {
	          return getComponentDecl().getConstrainingClause().getAccess().myClassDecl();
	        }
	     }


/*
	  
	  if (retrieveReplacingClass(getComponentDecl().myClass().name())!=null) {
	     classToExpand = retrieveReplacingClass(getComponentDecl().myClass().name());
	  } else {
	     classToExpand = getComponentDecl().myClass();
	  }
	     
	     if (!constrainingType())
	       return classToExpand;
	     else {
	        if (!getComponentDecl().hasConstrainingClause()) // Constraining clause same as original decl in this case
	          return classToExpand;
	        else {
	          if (retrieveReplacingClass(getComponentDecl().getConstrainingClause().getAccess().myClassDecl().name())!=null) {
	             classToExpand = retrieveReplacingClass(getComponentDecl().getConstrainingClause().getAccess().myClassDecl().name());
	          } else {
	             classToExpand = getComponentDecl().getConstrainingClause().getAccess().myClassDecl();
	          }
	          return classToExpand;
	        }
	     }
	*/
	}
	
	syn List InstNode.equations() = emptyList();
	eq InstClassRoot.equations() = getClassDecl().equations();
	eq InstComponentDecl.equations() = classToExpand().equations();
	eq InstExtends.equations() = getExtendsClause().getSuper().myClassDecl().equations();
	eq InstFullClassDecl.equations() = getFullClassDecl().equations();
	
	syn lazy List InstNode.components() = emptyList();
	eq InstClassRoot.components() = getClassDecl().components();
	// This attribute also needs to take into account that a class declaration
	// may be redeclared.
	eq InstComponentDecl.components() = classToExpand().components();
//	eq InstExtends.components() = getClassName().myInstClassDecl().components();
	eq InstExtends.components() = getExtendsClause().getSuper().myClassDecl().components();
	eq InstBaseClassDecl.components() = getBaseClassDecl().components();
	eq InstShortClassDecl.components() = getClassName().myInstClassDecl().components();
//	eq InstPrimitiveClassDecl.components() = emptyList();
	
	syn lazy List InstNode.superClasses() = emptyList();
	eq InstClassRoot.superClasses() = getClassDecl().superClasses();
	eq InstComponentDecl.superClasses() = classToExpand().superClasses();
	eq InstExtends.superClasses() = getExtendsClause().getSuper().myClassDecl().superClasses();
    eq InstBaseClassDecl.superClasses() = getBaseClassDecl().superClasses();

	syn lazy List InstNode.classes() = emptyList();
	eq InstClassRoot.classes() = getClassDecl().classes();
	eq InstProgramRoot.classes() = getProgram().classes();
	eq InstBaseClassDecl.classes() = getBaseClassDecl().classes();
    eq InstShortClassDecl.classes() = getClassName().myInstClassDecl().classes();

}

aspect InstanceClasses {

	syn lazy InstProgramRoot Program.getInstProgramRoot() {
		return new InstProgramRoot(new List(), this);
	}

    public InstBaseClassDecl BaseClassDecl.newInstClassDecl() {
    	return null;
    }    
    public InstFullClassDecl FullClassDecl.newInstClassDecl() {
    	InstFullClassDecl fcd = new InstFullClassDecl(new List(),this,new Opt());
	  if (hasConstrainingClause())
	    fcd.setInstConstraining(getConstrainingClause().newInstConstraining());

    	fcd.setStart(getStart());
    	return fcd;
    }
    public InstShortClassDecl ShortClassDecl.newInstClassDecl() {
    	InstShortClassDecl scd =  new InstShortClassDecl(new List(),this, new Opt(), getClassName().newInstAccess(), new Opt());
   	  if (hasClassModification())
		scd.setIClassModification(getClassModification().newIModification());
	  if (hasConstrainingClause())
	    scd.setInstConstraining(getConstrainingClause().newInstConstraining());
    	
    	scd.setStart(getStart());
    	return scd;
    }
    public InstPrimitiveClassDecl PrimitiveClassDecl.newInstClassDecl() {
    	return new InstPrimitiveClassDecl(new List(),this, new Opt());
    }


	public InstAccess ComponentDecl.newInstClassAccess() {
		return getClassName().newInstAccess();
	}
	public InstAccess Access.newInstAccess() {
		InstAccess ia =  new InstParseAccess(getID());
		ia.setStart(getStart());
		return ia;
	}
	public InstAccess Dot.newInstAccess() {
		InstAccess ia = new InstDot("",getLeft().newInstAccess(),getRight().newInstAccess());
		ia.setStart(getStart());
		return ia;
	}	
	

    
    syn lazy List Program.classes() = getElementList();

	syn FullClassDecl InstFullClassDecl.getFullClassDecl() = (FullClassDecl)getBaseClassDecl();
	syn ShortClassDecl InstShortClassDecl.getShortClassDecl() = (ShortClassDecl)getBaseClassDecl();
	syn PrimitiveClassDecl InstPrimitiveClassDecl.getPrimitiveClassDecl() = (PrimitiveClassDecl)getBaseClassDecl();

	ArrayList<InstClassDecl> InstNode.instClassDeclList;
	ArrayList<InstComponentDecl> InstNode.instComponentDeclList;
	ArrayList<InstExtends> InstNode.instExtendsList;
	
	boolean InstNode.instNodeListsComputed  = false;
	public void InstNode.computeInstNodeLists() {
		ArrayList<InstClassDecl> instClassDeclList = new ArrayList<InstClassDecl>();
		ArrayList<InstComponentDecl> instComponentDeclList = new ArrayList<InstComponentDecl>();
		ArrayList<InstExtends> instExtendsList = new ArrayList<InstExtends>();
		
		for (InstNode n : getInstNodes()) {
			if (n instanceof InstClassDecl)
				instClassDeclList.add((InstClassDecl)n);
			else if (n instanceof InstComponentDecl)
				instComponentDeclList.add((InstComponentDecl)n);
			else if (n instanceof InstExtends)
				instExtendsList.add((InstExtends)n);
		}
		this.instClassDeclList = instClassDeclList;
		this.instComponentDeclList = instComponentDeclList;
		this.instExtendsList = instExtendsList;
		instNodeListsComputed = true;
	}
	
	syn ArrayList<InstClassDecl> InstNode.instClassDecls() {
		if (!instNodeListsComputed)
			computeInstNodeLists();
		return instClassDeclList;
	}

	syn ArrayList<InstComponentDecl> InstNode.instComponentDecls() {
		if (!instNodeListsComputed)
			computeInstNodeLists();
		return instComponentDeclList;
	}

	syn ArrayList<InstExtends> InstNode.instExtends() {
		if (!instNodeListsComputed)
			computeInstNodeLists();
		return instExtendsList;
	}

    syn lazy List InstBaseClassDecl.getInstImportList() = emptyList();
    
    eq InstFullClassDecl.getInstImportList() {
    	List l = new List();
    	for (ImportClause ic : getFullClassDecl().getImports()) {
    		InstImport iic = ic.newInstImport();
    		iic.setStart(ic.getStart());
    		l.add(iic);
    	}
    	return l;
    }

	public abstract InstImport ImportClause.newInstImport(); 
	public InstImport ImportClauseQualified.newInstImport() {
		return new InstImportQualified(getPackageName().newInstAccess(),this);
	}
	public InstImport ImportClauseUnqualified.newInstImport() {
		return new InstImportUnqualified(getPackageName().newInstAccess(),this);
	}
	public InstImport ImportClauseRename.newInstImport() {
		return new InstImportRename(getPackageName().newInstAccess(),this);
	}
	
}


aspect InstanceDumpTree {

	// Some basic dump routines
	public void InstNode.dumpTree(String indent) {
		System.out.println(indent + dump());
		System.out.println(toString(indent+"|"));
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstBaseClassDecl.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getBaseClassDecl().name());
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstExtends.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getExtendsClause().getSuper().name());
        getClassName().dumpTree(indent + "|");
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstComposite.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name());
        getClassName().dumpTree(indent + "|");
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstPrimitive.dumpTree(String indent) {
		System.out.println(indent + dump()
							  + ": " + 
		                      getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name());
	    getClassName().dumpTree(indent + "|");

		System.out.println(toString(indent+"|"));

	}
	
	public String InstAccess.toString() {
		return name();
	}
	
 	public String InstNode.toString() {
		return toString("");
    }
	public String InstNode.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstNode:\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   return str.toString();	
	}
  
	public String InstReplacingComposite.toString() {
		return toString("");
    }
	public String InstReplacingComposite.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstReplacingComponent:\n");
	   str.append(indent+" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
		return toString("");
    }
	public String InstPrimitive.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstPrimitive:\n");
	   str.append(indent+" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   return str.toString();	
	}

	public String InstComposite.toString() {
		return toString("");
    }

	public String InstFullClassDecl.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstFullClassDecl:\n");
	   str.append(indent+" Class decl: " + getFullClassDecl().name() + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   //str.append(indent+" Declared type:\n");
	   //str.append(indent+declaredType().toString());
	   //str.append(indent+" Constraining type:\n");
	   //str.append(indent+constrainingType().toString());
	   
	   return str.toString();	
	}

	public String InstFullClassDecl.toString() {
		return toString("");
    }


	public String InstModification.toString() {
		return toString("");
    }
    public String InstModification.toString(String indent) {
    	return getModification().prettyPrint(indent);
    
    }
	
}

aspect InstancePrettyPrint {

	public String InstNode.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent + str.substring(str.lastIndexOf('.')+1);
		return str;

	}
	public String InstPrimitive.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name();
		return str;

	}

}
