
import java.util.ArrayList;

    /**
     * TODO: Is it a good idea to inherit? Should env be a component?
     */
    class Environment extends ArrayList<IModification> {
    
        public Environment() {
        	super();
        }

        /**
         * Merge an outer modification into the environment: add it at the beginning.
         */    
    	public void mergeOuterModification(IModification outerMod) {
    		ArrayList<IModification> outerMods = outerMod.expand();
    		addAll(0,outerMods);
    	}

        /**
         * Merge an inner modification into the environment: add it last.
         */    
    	public void mergeInnerModification(IModification innerMod) {
    		ArrayList<IModification> innerMods = innerMod.expand();
    		addAll(innerMods);    	
    	}

        /**
         * Merge an outer environment: add it first.
         */ 
    	public void mergeOuterEnvironment(Environment outerEnv) {
    		addAll(0,outerEnv);
    	}

        /**
         * Merge an inner environment: add it last.
         */
    	public void mergeInnerEnvironment(Environment innerEnv) {
    	   addAll(innerEnv);
    	}

        public Environment clone() {
        	Environment env = new Environment();
        	env.addAll(this);
        	return env;
        }
    	
    	/**
    	 * TODO: implement!
    	 */
        public Environment peel(String name) {
        	return new Environment();
        }
        
        public String toString() {
           StringBuffer str = new StringBuffer();
           str.append("{");
           for (IModification im : this) {
//           	  str.append("  " + im.getModification().prettyPrint("") + ",\n");
           	  str.append("  " + im.getModification().prettyPrint("") + ",");
           	  str.append(im.myInstNode().toString());
           	  str.append("\n");
           }
           str.append("}\n");
           return str.toString();
        }
        
        public String toString(String indent) {
           StringBuffer str = new StringBuffer();
           str.append(indent+"{");
           for (int i=0;i<size();i++) {
              IModification im = get(i);
              if (i==0)
              	str.append(im.getModification().prettyPrint(""));
           	  else
           	  	str.append(indent + " " +  im.getModification().prettyPrint(""));
           	  str.append(": ");
           	//  if (im.myInstNode().toString()!=null)
	           	  str.append(im.myInstNode().getClass().getName());

              if (i !=size()-1)
              	str.append(",\n");
           }
           str.append("}\n");
           return str.toString();
        }
    
    }

aspect InstModifications{

	public ArrayList<IModification> IModification.expand() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		l.add(this);
		return l;
	}

	public ArrayList<IModification> ICompleteModification.expand() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		for (IModification im : getIClassModification().getIArguments())
			l.add(im);
		if (hasIValueModification())
			l.add(getIValueModification());
		return l;	
		
	}

	public ArrayList<IModification> IClassModification.expand() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		for (IModification im : getIArguments())
			l.add(im);
		return l;	
	}


	public abstract IModification Modification.newIModification();
	public ICompleteModification CompleteModification.newIModification() {
		ICompleteModification icm = new ICompleteModification(this,getClassModification().newIModification(),new Opt());
        if (hasValueModification())
        	icm.setIValueModification(getValueModification().newIModification());
        return icm;
	}	
	public IValueModification ValueModification.newIModification() {
		return new IValueModification(this);
	}
	public IClassModification ClassModification.newIModification () {
		List l = new List();
		for (Argument a : getArguments()) {
			l.add(a.newIModification());
		}
		return new IClassModification(this,l);
	}
	public IComponentModification ComponentModification.newIModification() {
		IComponentModification icm = new IComponentModification(this,getName().newInstAccess(),new Opt());
		if (hasModification())
			icm.setIModification(getModification().newIModification());
		icm.setStart(getStart());
		return icm;
	}
	public IComponentRedeclare ComponentRedeclare.newIModification() {
	    // TODO: Can this component be redeclared?
		IComponentRedeclare icr = new IComponentRedeclare(this,getName().newInstAccess());
		icr.setStart(getStart());
		return icr;
	}
	
	public IComponentRedeclare PN_ComponentRedeclare.newIModification() {
		return null; // This should never be called since all PN_ComponentRedeclare:s are rewritten	    
	}	
	
	public IClassRedeclare ClassRedeclare.newIModification() {
		IClassRedeclare icr = new IClassRedeclare(this,getName().newInstAccess());
		icr.setStart(getStart());
		return icr;
	}
	
	
	syn CompleteModification ICompleteModification.getCompleteModification() = (CompleteModification)getModification();
	syn ClassModification IClassModification.getClassModification() = (ClassModification)getModification();
	syn ValueModification IValueModification.getValueModification() = (ValueModification)getModification();
	syn ComponentModification IComponentModification.getComponentModification() = (ComponentModification)getModification();
	syn ClassRedeclare IClassRedeclare.getClassRedeclare() = (ClassRedeclare)getModification();
	syn ComponentRedeclare IComponentRedeclare.getComponentRedeclare() = (ComponentRedeclare)getModification();


}

aspect Environments {

 	syn lazy ArrayList<IModification> InstNode.localIModifications() = new ArrayList<IModification>();
 	
 	eq InstComponentDecl.localIModifications() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		// Add modifications of the declaration itself
		if (hasIModification())
			l.add(getIModification());
			
	    // If there is a constraining clause, these modifications should be merged as well 
		if (hasInstConstraining() &&
		       getInstConstraining().hasIClassModification())
		  	l.add(getInstConstraining().getIClassModification());	
        l.addAll(myInstClass().classIModifications());
		return l;
		
	}
 	
	eq InstReplacingComposite.localIModifications() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		// If there is a constraining clase, return its modifications
		if (getOriginalInstComponent().hasInstConstraining()) {
		  if (getOriginalInstComponent().getInstConstraining().hasIClassModification()) {
			l.add(getOriginalInstComponent().getInstConstraining().getIClassModification());
          }
        } else {
            // If no constraining clause, use the original declaration 
            // and return its modifiers
     		if (getOriginalInstComponent().hasIModification())
				l.add(getOriginalInstComponent().getIModification());     
        }
        l.addAll(myInstClass().classIModifications());
		return l;
	}
	 
	eq InstShortClassDecl.localIModifications() {
		ArrayList<IModification> l = new ArrayList<IModification>();
   		if (hasIClassModification())
				l.add(getIClassModification());     
		if (hasInstConstraining()) {
		  if (getInstConstraining().hasIClassModification()) {
			l.add(getInstConstraining().getIClassModification());
          }
        } 
        l.addAll(getInstExtends(0).getClassName().myInstClassDecl().classIModifications());
   		return l;
	}	 
		 	
	eq InstReplacingShortClassDecl.localIModifications() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		// If there is a constraining clase, return its modifications
		if (getOriginalInstClass().hasInstConstraining()) {
		  if (getOriginalInstClass().getInstConstraining().hasIClassModification()) {
			l.add(getOriginalInstClass().getInstConstraining().getIClassModification());
          }
        } else {
            // If no constraining clause, use the original declaration 
            // and return its modifiers
     		if (getOriginalInstClass().hasIClassModification())
				l.add(getOriginalInstClass().getIClassModification());     
        }	
        l.addAll(getInstExtends(0).getClassName().myInstClassDecl().classIModifications());
		return l;
	}
	 	
	// TODO: This should probably be implemented as an AST node child. 	
	syn lazy boolean InstClassDecl.hasIClassModification() = false;
	eq InstShortClassDecl.hasIClassModification() = getInstExtends(0).hasIClassModification(); 	
	syn lazy IClassModification InstClassDecl.getIClassModification() = null;
	eq InstShortClassDecl.getIClassModification() = getInstExtends(0).getIClassModification(); 	

	eq InstExtends.localIModifications() {
		ArrayList<IModification> l = new ArrayList<IModification>();
		if (hasIClassModification())
			l.add(getIClassModification());
        l.addAll(getClassName().myInstClassDecl().classIModifications());
		return l;
	}

	eq InstExtendsShortClass.localIModifications() {
		// notice that modifications on short classes are merged in InstShortClassDecl nodes
		ArrayList<IModification> l = new ArrayList<IModification>();
		return l;
	}
 
 	syn lazy ArrayList<IModification> InstClassDecl.classIModifications() = getMergedEnvironment().clone();

 
 
    /* getMergedEnvironment gives the environment applicable
       to the children of the InstNode. It consists of the outer modifications
       in the environment (with the name of the InstNode itself, if any,
       removed) merged with potential local modifications.
    
       TODO: Should this attribute be lazy? Probably yes
      
    */   
    
    // TODO: merge also class redeclaration modifications    
	syn lazy Environment InstNode.getMergedEnvironment() {
		// Retrieve modifications upwards
		Environment env = nameScope()? myEnvironment(name()).clone(): myEnvironment().clone();
		for (IModification im : localIModifications())
			env.mergeInnerModification(im);
		return env;
	}


	
	
	
	/**
	 * myEnvironment represents the environment of the InstNode itself. It is defined
	 * as an inherited attribute and is computed from the outer environment located at
	 * ancestor InstNodes.
	 */	
	inh  lazy Environment InstNode.myEnvironment();
	inh lazy Environment InstNode.myEnvironment(String name); // TODO: Make sure this is lazy - removed for debugging
	
	/**
	 * When no arguments are supplied to myEnvironment, the MergedEnvironment of the ancestor
	 * InstNode is simply duplicated. This is typically the case for extends clauses.
	 */
	eq InstNode.getChild().myEnvironment() = getMergedEnvironment().clone();

/*
	eq InstReplacingShortClassDecl.getChild().myEnvironment() {
		Environment env = getMergedEnvironment().clone();
		if (getOriginalInstClass().hasInstConstraining()) {
			if (getOriginalInstClass().getInstConstraining().hasIClassModification())
				env.mergeInnerModification(getOriginalInstClass().getInstConstraining().getIClassModification());
		} else {
		    InstClassDecl origDecl = getOriginalInstClass();
			if (origDecl.getInstExtends(0).hasIClassModification())
				env.mergeInnerModification(origDecl.getInstExtends(0).getIClassModification());
		}
		return env;
	}
*/

	/** 
	 * When a string argument representing a component name is given as argument to myEnvironment,
	 * the resulting environment consists only of modifications with a matching prefix. In effect, this 
	 * results in a "peeling" operation, where the first name in a qualified name is removed, and the rest
	 * of the modification is added to myEnvironment. The algorithm is somewhat complicated by component
	 * redeclares that needs to be taken into account. 
	 */
	eq InstNode.getChild().myEnvironment(String name) = myEnvironment_def(name); // This is just to get caching at the right place.
	
	syn lazy Environment InstNode.myEnvironment_def(String name) {
		Environment env = new Environment();
		boolean componentRedeclareFound = false;
		IComponentRedeclare icr = retrieveReplacingComponent(name);
		boolean classRedeclareFound = false;
		IClassRedeclare iclr = retrieveReplacingClass(name);
		for (IModification im : getMergedEnvironment()) {
			// If a first component redeclare modification is found, add modifiers
			if (!componentRedeclareFound && im==icr) {
            	if (icr.getInstComponentDecl().hasIModification()) 
    				env.mergeInnerModification(icr.getInstComponentDecl().getIModification());
				componentRedeclareFound = true;
			}
			// If a first class redeclare modification is found, add modifiers
			if (!classRedeclareFound && im==iclr) {
            	if (iclr.getInstClassDecl().hasIClassModification()) 
    				env.mergeInnerModification(iclr.getInstClassDecl().getIClassModification());
				classRedeclareFound = true;
			}

			
			
			if (im.matchIModification(name) != null) {
				env.mergeInnerModification(im.matchIModification(name));
			}
		}
		return env;
		
	}

	eq Program.getInstProgramRoot().myEnvironment() = new Environment();
	eq Program.getInstProgramRoot().myEnvironment(String name) = new Environment();
	
	syn lazy IModification IModification.matchIModification(String name) = null;
	eq ICompleteModification.matchIModification(String name) {
		for (IModification im : getIClassModification().getIArguments())
			if (im.matchIModification(name)!=null)
				return im.matchIModification(name);
		return null;
	}
	
	eq IComponentModification.matchIModification(String name) {
		if (name.equals(getName().getID()))
			return hasIModification()? getIModification() : null;
		return null;
	}
	
	// Only add modifiers in constraining clauses
	eq IComponentRedeclare.matchIModification(String name) {
		if (name.equals(getName().getID()) && getInstComponentDecl().hasInstConstraining() &&
		    getInstComponentDecl().getInstConstraining().hasIClassModification())
			return getInstComponentDecl().getInstConstraining().getIClassModification();
		return null;
	}	
	
	// Only add modifiers in constraining clauses
	eq IClassRedeclare.matchIModification(String name) {
		if (name.equals(getName().name()) && getInstClassDecl().hasInstConstraining() &&
		    getInstClassDecl().getInstConstraining().hasIClassModification())
			return getInstClassDecl().getInstConstraining().getIClassModification();
		return null;
	}		
	
	
	syn lazy IComponentRedeclare IModification.matchIComponentRedeclare(String name) = null;
	eq IComponentRedeclare.matchIComponentRedeclare(String name) {
		if (getName().name().equals(name))
			return this;
		else
			return null;
	}
	
    syn lazy IClassRedeclare IModification.matchIClassRedeclare(String name) = null;
	eq IClassRedeclare.matchIClassRedeclare(String name) {
		//if (getName().getID().equals(name))
		if (getName().name().equals(name))
			return this;
		else
			return null;
	}
	
	 /**
     * TODO: Does the return type here need to be IReplacingComponent or can it be ComponentDecl?
     */
	syn IComponentRedeclare InstNode.retrieveReplacingComponent(String name) {
		for (IModification im : getMergedEnvironment()) {
			if (im.matchIComponentRedeclare(name)!=null) {
				return im.matchIComponentRedeclare(name);
			}
		}
		return null;
	}

	syn IClassRedeclare InstNode.retrieveReplacingClass(String name) {
		for (IModification im : getMergedEnvironment()) {
			if (im.matchIClassRedeclare(name)!=null) {
				return im.matchIClassRedeclare(name);
			}
		}
		return null;
	}

	inh lazy InstNode IModification.myInstNode();
	inh lazy InstNode InstNode.myInstNode();
	eq InstNode.getChild().myInstNode() = this;
	//The lexical scope of modifiers for short classes are "outside" of the short declaration
    eq InstExtendsShortClass.getChild().myInstNode() = myInstNode();
	
	/**
	 * InstPrimitive:s may have children of type InstExtends, if the InstPrimitive is instantiated
	 * eiter from a short class declaration that references a primitive type or from a 'type' class
	 * declaration that inherits a primitive type. In both cases, the result is one or a chain of InstExtends/
	 * InstExtendsShortClass children. The final node in such a chain holds the total merged environment of 
	 * the InstPrimitive.
	 */
	syn lazy Environment InstPrimitive.totalMergedEnvironment() {
		if (getNumInstExtends()==0)
			return getMergedEnvironment();
		else
			return getInstExtends(0).totalMergedEnvironment();
	}

	syn Environment InstExtends.totalMergedEnvironment() {
		if (getNumInstExtends()==0)
			return getMergedEnvironment();
		else
			return getInstExtends(0).totalMergedEnvironment();
	}

}

aspect InstanceTreeConstruction {
	
	syn lazy List InstNode.getDynamicClassNameList() = new List();
	syn lazy List IComponentRedeclare.getDynamicClassNameList() = new List();
	syn lazy List InstConstrainingComponent.getDynamicClassNameList() = new List();

	syn lazy List InstNode.getInstComponentDeclList() {
	
		List l = new List();
		ArrayList<ComponentDecl> comps = components();

		for (ComponentDecl cd : comps) {
		    l.add(createInstComponentDecl(cd));
		}				
		
		return l;
	}

	syn lazy List InstNode.getInstClassDeclList() {
	
		List l = new List();
		ArrayList<ClassDecl> classes = classes();
		
		for (ClassDecl cd : classes) {
		    l.add(createInstClassDecl(cd));
		}				
		
		return l;
	}

	syn lazy List InstNode.getInstExtendsList() {
	
		List l = new List();
		ArrayList<ExtendsClause> supers = superClasses();	

		for (ExtendsClause e : supers) {
		    l.add(createInstExtends(e));
		}				
		
		return l;
	}


	eq InstPrimitive.getInstComponentDeclList() = emptyList();
	eq InstPrimitive.getInstClassDeclList() = emptyList();
//	eq InstPrimitive.getInstExtendsList() = emptyList();

    public InstNode InstNode.createInstComponentDecl(ComponentDecl cd) {
    	// Check if the component is redeclared. 
    	// -> Yes: Create an InstReplacingComponent component
    	// -> No: Create an InstComponent 
    	IComponentRedeclare irc = retrieveReplacingComponent(cd.name());
    	if (irc!=null) {
    		ComponentDecl replacingComp = irc.getComponentRedeclare().getComponentDecl();
    		// Add the new access to the IComponentRedeclare node in order to get lookup in the right scope
    		irc.addDynamicClassName(replacingComp.getClassName().newInstAccess());
    		return irc.getDynamicClassName(irc.getNumDynamicClassName()-1).myInstClassDecl().newInstReplacingComponent(replacingComp,cd,irc);    	    		
    	} else { 
    		addDynamicClassName(cd.getClassName().newInstAccess());
    		return getDynamicClassName(getNumDynamicClassName()-1).myInstClassDecl().newInstComponentDecl(cd);    	
    	}
     }
    
   public InstNode InstNode.createInstClassDecl(ClassDecl bcd) {
    	// Check if the class is redeclared. 
    	// -> Yes: Create an InstReplacingClass component
    	// -> No: Create an InstClassDecl
    	IClassRedeclare icr = retrieveReplacingClass(bcd.name());
    	if (icr!=null) {
    	    BaseClassDecl replacingClass = icr.getClassRedeclare().getBaseClassDecl();
    		return bcd.newInstReplacingClass(replacingClass,icr);
    	} else {
			return bcd.newInstClassDecl();  
   		}
   }    
    
   public InstNode InstNode.createInstExtends(ExtendsClause ec) {
   		// This cannot be redeclared. Just create and return.
   		return ec.newInstExtends();
   }
		
		// Dispatch w.r.t. class type
	public abstract InstComponentDecl InstClassDecl.newInstComponentDecl(ComponentDecl cd);
	public InstComponentDecl InstBaseClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return newInstComponentDecl(cd,cd.getClassName());		
		
	}
	public InstComponentDecl InstPrimitiveClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return newInstComponentDecl(cd,cd.getClassName());
	}
	public InstComponentDecl InstBuiltInClassDecl.newInstComponentDecl(ComponentDecl cd) {
		return newInstComponentDecl(cd,cd.getClassName());
	}
		
	public abstract InstComponentDecl InstClassDecl.newInstComponentDecl(ComponentDecl cd, Access className);

	public InstComponentDecl InstBaseClassDecl.newInstComponentDecl(ComponentDecl cd, Access className) {
		if (!extendsPrimitive()){
			InstComponentDecl icd = new InstComposite(className.newInstAccess(),cd,new Opt(),new Opt());
			if (cd.hasModification())
				icd.setIModification(cd.getModification().newIModification());
			icd.setInstConstrainingOpt(cd.newInstConstrainingComponentOpt());
			icd.setStart(cd.getStart());
			return icd;
		} else {
			InstPrimitive icd = new InstPrimitive(className.newInstAccess(),cd,new Opt(),new Opt());
			if (cd.hasModification())
				icd.setIModification(cd.getModification().newIModification());
			icd.setInstConstrainingOpt(cd.newInstConstrainingComponentOpt());
			icd.setStart(cd.getStart());
			return icd;

		}
	}

	public InstComponentDecl InstPrimitiveClassDecl.newInstComponentDecl(ComponentDecl cd, Access className) {
		InstPrimitive ipr = new InstPrimitive(className.newInstAccess(),cd,new Opt(),new Opt());
		if (cd.hasModification())
			ipr.setIModification(cd.getModification().newIModification());
		ipr.setInstConstrainingOpt(cd.newInstConstrainingComponentOpt());
		ipr.setStart(cd.getStart());
		return ipr;
	}

	public InstComponentDecl InstBuiltInClassDecl.newInstComponentDecl(ComponentDecl cd, Access className) {
		return new InstBuiltIn(className.newInstAccess(),cd,new Opt(),new Opt());
	}

	public abstract InstComponentDecl InstClassDecl.newInstReplacingComponent(ComponentDecl replacingDecl,
	                                                                 ComponentDecl originalDecl, IComponentRedeclare icr);

	public InstComponentDecl InstBaseClassDecl.newInstReplacingComponent(ComponentDecl replacingDecl,
	                                                                 ComponentDecl originalDecl, IComponentRedeclare icr) {
		if (!extendsPrimitive()){
			InstReplacingComposite icd = new InstReplacingComposite(replacingDecl.newInstClassAccess(),replacingDecl,new Opt(),new Opt(),originalDecl,icr);
			if (originalDecl.hasModification()) //TODO: should this really be originalDecl
				icd.setIModification(originalDecl.getModification().newIModification());
			icd.setInstConstrainingOpt(originalDecl.newInstConstrainingComponentOpt());
			icd.setStart(originalDecl.getStart());
			return icd;
		} else {
			InstReplacingPrimitive icd = new InstReplacingPrimitive(replacingDecl.newInstClassAccess(),replacingDecl,new Opt(),new Opt(),originalDecl,icr);
			if (originalDecl.hasModification()) //TODO: should this really be originalDecl
				icd.setIModification(originalDecl.getModification().newIModification());
			icd.setInstConstrainingOpt(originalDecl.newInstConstrainingComponentOpt());
			icd.setStart(originalDecl.getStart());
			return icd;

		}
	}

	// This cannot be done.
	public InstComponentDecl InstBuiltInClassDecl.newInstReplacingComponent(ComponentDecl replacingDecl,
	                                                                        ComponentDecl originalDecl, 
	                                                                        IComponentRedeclare icr) {
		return null;
	}

    public InstClassDecl ClassDecl.newInstClassDecl() {
    	return null;
    }    

    public InstFullClassDecl FullClassDecl.newInstClassDecl() {
    	InstFullClassDecl fcd = new InstFullClassDecl(this,new Opt());
	    fcd.setInstConstrainingOpt(newInstConstrainingClassOpt());
    	fcd.setStart(getStart());
    	return fcd;
    }
    public InstShortClassDecl ShortClassDecl.newInstClassDecl() {
    	InstShortClassDecl scd =  new InstShortClassDecl(this, new Opt());
	    scd.setInstConstrainingOpt(newInstConstrainingClassOpt());    	
    	scd.setStart(getStart());
    	return scd;
    }
    public InstPrimitiveClassDecl PrimitiveClassDecl.newInstClassDecl() {
    	return new InstPrimitiveClassDecl(this, new Opt());
    }

    public InstClassDecl ClassDecl.newInstReplacingClass(ClassDecl replacingClass,IClassRedeclare icr) {
    	return null;
    }    

    public InstReplacingFullClassDecl FullClassDecl.newInstReplacingClass(ClassDecl replacingClass,IClassRedeclare icr) {
    	InstReplacingFullClassDecl fcd = new InstReplacingFullClassDecl(replacingClass,new Opt(),this,icr);
	    fcd.setInstConstrainingOpt(newInstConstrainingClassOpt()); //TODO: Should be constr clause of original or redeclared?
    	fcd.setStart(getStart());
    	return fcd;
    }
    public InstReplacingShortClassDecl ShortClassDecl.newInstReplacingClass(ClassDecl replacingClass,IClassRedeclare icr) {
    	InstReplacingShortClassDecl scd =  new InstReplacingShortClassDecl(replacingClass, new Opt(),this,icr);
	    scd.setInstConstrainingOpt(newInstConstrainingClassOpt());    	
    	scd.setStart(getStart());
    	return scd;
    }
    public InstReplacingFullClassDecl PrimitiveClassDecl.newInstReplacingClass(ClassDecl replacingClass,IClassRedeclare icr) {
    	return new InstReplacingPrimitiveClassDecl(replacingClass, new Opt(),this,icr);
    }

	// Build an InstExtends
	public InstExtends ExtendsClause.newInstExtends() {
		InstExtends ie = new InstExtends(getSuper().newInstAccess(),this, new Opt());
		if (hasClassModification())
			ie.setIClassModification(getClassModification().newIModification());
		ie.setStart(getStart());
		return ie;
	}

    public InstExtends ExtendsClauseShortClass.newInstExtends() {
		InstExtendsShortClass ie = new InstExtendsShortClass(getSuper().newInstAccess(),this, new Opt());
		if (hasClassModification())
			ie.setIClassModification(getClassModification().newIModification());
		ie.setStart(getStart());
		return ie;
    }


	public InstAccess ComponentDecl.newInstClassAccess() {
		return getClassName().newInstAccess();
	}
	
	public InstAccess Access.newInstAccess() {
		InstAccess ia =  new InstParseAccess(getID());
		ia.setStart(getStart());
		return ia;
	}
	public InstAccess Dot.newInstAccess() {
		InstAccess ia = new InstDot("",getLeft().newInstAccess(),getRight().newInstAccess());
		ia.setStart(getStart());
		return ia;
	}	


	syn lazy InstProgramRoot Program.getInstProgramRoot() {
		return new InstProgramRoot(this);
	}

	syn lazy InstClassDecl IClassRedeclare.getInstClassDecl() {
		return getClassRedeclare().getBaseClassDecl().newInstClassDecl();
	}

	syn lazy InstComponentDecl IComponentRedeclare.getInstComponentDecl() {
	    // TODO: Check if the component is redeclared. Really...?
    	// -> Yes: Create an InstReplacingComponent component
    	// -> No: Create an InstComponent 
	   	addDynamicClassName(getComponentRedeclare().getComponentDecl().getClassName().newInstAccess());
    	return getDynamicClassName(getNumDynamicClassName()-1).myInstClassDecl().newInstComponentDecl(getComponentRedeclare().getComponentDecl());
	}

	syn lazy InstComponentDecl InstReplacingComposite.getOriginalInstComponent() {
		// TODO: Check if the component is redeclared. Really...?
    	// -> Yes: Create an InstReplacingComponent component
    	// -> No: Create an InstComponent 
	   	addDynamicClassName(getOriginalDecl().getClassName().newInstAccess());
    	return getDynamicClassName(getNumDynamicClassName()-1).myInstClassDecl().newInstComponentDecl(getOriginalDecl());
	}


	syn lazy InstClassDecl InstReplacingShortClassDecl.getOriginalInstClass() {
		// TODO: Check if the component is redeclared. Really...?
    	// -> Yes: Create an InstReplacingComponent component
    	// -> No: Create an InstComponent 
		return getOriginalClassDecl().newInstClassDecl();
	}

	syn lazy InstClassDecl InstReplacingFullClassDecl.getOriginalInstClass() {
		// TODO: Check if the component is redeclared. Really...?
    	// -> Yes: Create an InstReplacingComponent component
    	// -> No: Create an InstComponent 
		return getOriginalClassDecl().newInstClassDecl();
	}



}

aspect InstaceConstrainingClauses {

	public Opt ComponentDecl.newInstConstrainingComponentOpt() {
		if (hasConstrainingClause()) {
	    	Opt opt = getConstrainingClause().hasClassModification()? new Opt(getConstrainingClause().getClassModification().newIModification()) : new Opt();
			return new Opt(new InstConstrainingComponent(getConstrainingClause().getAccess().newInstAccess(),opt,this));
		} else {
			return new Opt();
		}
	}

	public Opt BaseClassDecl.newInstConstrainingClassOpt() {
		if (hasConstrainingClause()) {
	    	Opt opt = getConstrainingClause().hasClassModification()? new Opt(getConstrainingClause().getClassModification().newIModification()) : new Opt();
			return new Opt(new InstConstrainingClass(getConstrainingClause().getAccess().newInstAccess(),opt,this));
		} else {
			return new Opt();
		}
	}
	
    syn lazy ConstrainingClause InstConstraining.getConstrainingClause();
    eq InstConstrainingComponent.getConstrainingClause() = getComponentDecl().getConstrainingClause();
    eq InstConstrainingClass.getConstrainingClause() = getBaseClassDecl().getConstrainingClause();

	syn lazy InstNode InstConstraining.getInstNode();
	eq InstConstrainingComponent.getInstNode() {
  		return getClassName().myInstClassDecl().newInstComponentDecl(getComponentDecl(),getConstrainingClause().getAccess());
	}

	eq InstConstrainingClass.getInstNode() {
		ClassDecl classToExpand = getClassName().myInstClassDecl().getClassDecl();
		return classToExpand.newInstClassDecl();
	}
	
	syn lazy FExp IValueModification.getFExp() { 
		return getValueModification().getExp().instantiate();
	}
	
	syn lazy List InstBaseClassDecl.getFAbstractEquationList() { 
	    List l = new List();
	    for (AbstractEquation e : equations()) {
	    	l.add(e.instantiate());
	    }
	    return l;

	}

}

aspect InstImportClauses {

    syn lazy List InstBaseClassDecl.getInstImportList() = emptyList();
    
    eq InstFullClassDecl.getInstImportList() {
    	List l = new List();
    	for (ImportClause ic : getBaseClassDecl().getImports()) {
    		InstImport iic = ic.newInstImport();
    		iic.setStart(ic.getStart());
    		l.add(iic);
    	}
    	return l;
    }

	syn lazy List<ImportClause> BaseClassDecl.getImports() = emptyList();


	public abstract InstImport ImportClause.newInstImport(); 
	public InstImport ImportClauseQualified.newInstImport() {
		return new InstImportQualified(getPackageName().newInstAccess(),this);
	}
	public InstImport ImportClauseUnqualified.newInstImport() {
		return new InstImportUnqualified(getPackageName().newInstAccess(),this);
	}
	public InstImport ImportClauseRename.newInstImport() {
		return new InstImportRename(getPackageName().newInstAccess(),this);
	}
	

} 

aspect InstanceAST_API {
	syn boolean InstNode.nameScope() = false;
	eq InstComponentDecl.nameScope() = true;
    eq InstBaseClassDecl.nameScope() = true;
    
    syn String InstNode.name() = "";
    eq InstComponentDecl.name() = getComponentDecl().name();
    eq InstBaseClassDecl.name() = getBaseClassDecl().name();
    eq InstBuiltInClassDecl.name() = getBuiltInClassDecl().name();
	syn BaseClassDecl InstBaseClassDecl.getBaseClassDecl() = (BaseClassDecl)getClassDecl();
	syn BuiltInClassDecl InstBuiltInClassDecl.getBuiltInClassDecl() = (BuiltInClassDecl)getClassDecl();

	
	syn ArrayList<AbstractEquation> InstNode.equations() = new ArrayList<AbstractEquation>();
	eq InstClassRoot.equations() = getClassDecl().equations();
	eq InstComponentDecl.equations() = myInstClass().equations();
	eq InstExtends.equations() = getClassName().myInstClassDecl().equations();
	eq InstFullClassDecl.equations() = getBaseClassDecl().equations();	
	
	syn lazy ArrayList<ComponentDecl> InstNode.components() = new ArrayList<ComponentDecl>();
	eq InstClassRoot.components() = getClassDecl().components();
	eq InstComponentDecl.components() = myInstClass().components();
	eq InstExtends.components() = extendsPrimitive()? new ArrayList<ComponentDecl>() : getClassName().myInstClassDecl().components();
	eq InstBaseClassDecl.components() = getBaseClassDecl().components();
//    eq InstPrimitiveClassDecl.components() = new ArrayList<ComponentDecl>();
	
	syn lazy ArrayList<ExtendsClause> InstNode.superClasses() = new ArrayList<ExtendsClause>();
	eq InstClassRoot.superClasses() = getClassDecl().superClasses();
	eq InstComponentDecl.superClasses() = myInstClass().superClasses();
	eq InstExtends.superClasses() = getClassName().myInstClassDecl().superClasses();
    eq InstBaseClassDecl.superClasses() = getBaseClassDecl().superClasses();

	syn lazy ArrayList<ClassDecl> InstNode.classes() = new ArrayList<ClassDecl>();
	eq InstClassRoot.classes() = getClassDecl().classes();
	eq InstProgramRoot.classes() = getProgram().classes();
	eq InstComponentDecl.classes() = myInstClass().classes();
	eq InstBaseClassDecl.classes() = getBaseClassDecl().classes();
	eq InstExtends.classes() = getClassName().myInstClassDecl().classes();
	
//    eq InstShortClassDecl.classes() = getClassName().myInstClass().classes();

/*
	syn FullClassDecl InstFullClassDecl.getFullClassDecl() = (FullClassDecl)getBaseClassDecl();
	syn ShortClassDecl InstShortClassDecl.getShortClassDecl() = (ShortClassDecl)getBaseClassDecl();
	syn PrimitiveClassDecl InstPrimitiveClassDecl.getPrimitiveClassDecl() = (PrimitiveClassDecl)getBaseClassDecl();
*/



	syn lazy ArrayList<InstClassDecl> InstNode.instClassDecls() {
		ArrayList<InstClassDecl> l = new ArrayList<InstClassDecl>();	
		for (InstClassDecl n : getInstClassDecls())
			l.add(n);	
		return l;
	}

	syn lazy ArrayList<InstComponentDecl> InstNode.instComponentDecls() {
		ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();	
		for (InstComponentDecl n : getInstComponentDecls())
			l.add(n);	
		return l;
	}

	syn lazy ArrayList<InstExtends> InstNode.instExtends() {
		ArrayList<InstExtends> l = new ArrayList<InstExtends>();	
		for (InstExtends n : getInstExtendss())
			l.add(n);	
		return l;
	}

	syn lazy ArrayList<InstClassDecl> InstNode.constrainingInstClassDecls() = 
		hasInstConstraining()? new ArrayList<InstClassDecl>() : instClassDecls();
	eq InstClassDecl.constrainingInstClassDecls() {
		if (hasInstConstraining()) {
            return getInstConstraining().getInstNode().instClassDecls();
		} else {	
		return instClassDecls();
		}
	}

	syn lazy ArrayList<InstComponentDecl> InstNode.constrainingInstComponentDecls() = 
		hasInstConstraining()? new ArrayList<InstComponentDecl>() : instComponentDecls();
	eq InstComponentDecl.constrainingInstComponentDecls() {
		if (hasInstConstraining()) {
            return getInstConstraining().getInstNode().instComponentDecls();
		} else {	
		return instComponentDecls();
		}
	}

	syn lazy ArrayList<InstExtends> InstNode.constrainingInstExtends() = 
		hasInstConstraining()? new ArrayList<InstExtends>() : instExtends();

	// TODO: this seems to be a trick? equations are added in InstComponentDecl and
	// InstBaseClassDecl since they have nodes of type InstConstraining
	syn boolean InstNode.hasInstConstraining() = false;
	syn InstConstraining InstNode.getInstConstraining() = null;

	syn boolean InstNode.extendsPrimitive() = false;
	eq InstShortClassDecl.extendsPrimitive() = getNumInstExtends()==1 && getInstExtends(0).extendsPrimitive();
	eq InstExtends.extendsPrimitive() = getClassName().myInstClassDecl().isPrimitive() || getClassName().myInstClassDecl().extendsPrimitive();
	eq InstFullClassDecl.extendsPrimitive() = getNumInstExtends()==1 && getInstExtends(0).extendsPrimitive();
	
}

aspect SourceAST_API {


	syn lazy ArrayList<AbstractEquation> ClassDecl.equations() = new ArrayList<AbstractEquation>();
	eq FullClassDecl.equations() {
		ArrayList<AbstractEquation> l = new ArrayList<AbstractEquation>();
		for (AbstractEquation e : getEquations())
			l.add(e);
		return l;
	}
	
	syn lazy ArrayList<ExtendsClause> ClassDecl.superClasses() = new ArrayList<ExtendsClause>();
	eq FullClassDecl.superClasses() {
		ArrayList<ExtendsClause> l = new ArrayList<ExtendsClause>();
		for (ExtendsClause e : getSupers())
			l.add(e);
		return l;
	}
	eq ShortClassDecl.superClasses() {
		ArrayList<ExtendsClause> l = new ArrayList<ExtendsClause>();
		l.add(getExtendsClauseShortClass());
		return l;
	}
	
	
	syn lazy ArrayList<ComponentDecl> ClassDecl.components() = new ArrayList<ComponentDecl>();
	eq FullClassDecl.components() {
		ArrayList<ComponentDecl> l = new ArrayList<ComponentDecl>();
		for (ComponentDecl cd : getComponentDecls())
			l.add(cd);
		return l;
	}

	syn lazy ArrayList<ClassDecl> ClassDecl.classes() = new ArrayList<ClassDecl>();
	eq FullClassDecl.classes() {
		ArrayList<ClassDecl> l = new ArrayList<ClassDecl>();
		for (ClassDecl cd : getClassDecls())
			l.add(cd);
		return l;
	}

    syn lazy ArrayList<ClassDecl> Program.classes() {
    	ArrayList<ClassDecl> l = new ArrayList<ClassDecl>();
    	for (Element e : getElements())
    		l.add((ClassDecl)e);
    	return l;
    
    } 

}

aspect InstanceDumpTree {

	// Some basic dump routines
	public void InstNode.dumpTree(String indent) {
		System.out.println(indent + dump());
		System.out.println(toString(indent+"|"));
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

	}
	
	public void InstBaseClassDecl.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getBaseClassDecl().name());
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

	}


	
	public void InstExtends.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getExtendsClause().getSuper().name());
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

		}
	
	public void InstComposite.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      myInstClass().name() + " "+
		                      getComponentDecl().name());
        getClassName().dumpTree(indent + "|");
		System.out.println(toString(indent+"|"));

		//getComponentDecl().dumpTree("");
		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");

	}
	
	public void InstPrimitive.dumpTree(String indent) {
		System.out.println(indent + dump()
							  + ": " + 
		                      myInstClass().name() + " "+
		                      getComponentDecl().name());
	    getClassName().dumpTree(indent + "|");
		System.out.println(toString(indent+"|"));

		for (InstNode n : getInstClassDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstComponentDecls())
			n.dumpTree(indent + " ");
		for (InstNode n : getInstExtendss())
			n.dumpTree(indent + " ");


	}
	
	public String InstClassAccess.toString() {
		String s = dump() +": "+name() + " at line: " + beginLine()+ ", ClassDecl at: ";
    	if (myInstClassDecl().isUnknown())
    		s+="Unknown";
    	else {
    		s += myInstClassDecl().beginLine();
        }
        s+="\n";
		return s;
	}

	public String InstComponentAccess.toString() {
		String s = dump() +": "+name() + " at line: " + beginLine()+ ", ComponentDecl at: ";
    	if (myInstComponentDecl().isUnknown())
    		s+="Unknown";
    	else {
    		s += myInstComponentDecl().beginLine();
		}
        s+="\n";
		return s;
	}

	
 	public String InstNode.toString() {
		return toString("");
    }
	public String InstNode.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstNode:\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));

	   return str.toString();	
	}

	public String InstComponentDecl.toString() {
		return toString("");
    }
    
	public String InstComponentDecl.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstComponent:\n");
	   str.append(indent+" Original decl:  " + getComponentDecl().prettyPrint("") + "\n");
       str.append(indent+ " "+ getClassName().toString());
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

  
	public String InstReplacingComposite.toString() {
		return toString("");
    }
	public String InstReplacingComposite.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstReplacingComponent:\n");
	   str.append(indent+" Replacing decl: " + getComponentDecl().prettyPrint("") + "\n");
	   str.append(indent+" Original decl:  " + getOriginalDecl().prettyPrint("") + "\n");
       str.append(indent+ " "+getClassName().toString());
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   //str.append(" Declared type:\n");
	   //str.append(declaredType().toString());
	   //str.append(" Constraining type:\n");
	   //str.append(constrainingType().toString());
	   return str.toString();	
	}

	public String InstPrimitive.toString() {
		return toString("");
    }
	public String InstPrimitive.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstPrimitive:\n");
	   str.append(indent+" Component decl: " + getComponentDecl().prettyPrint("") + "\n");
       str.append(indent+ " " +getClassName().toString());	   
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   return str.toString();	
	}

	public String InstComposite.toString() {
		return toString("");
    }

	public String InstExtends.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstExtendsDecl:\n");
	   str.append(indent+" Extends clause: " + getExtendsClause().getSuper().name() + "\n");
       str.append(indent+ " "+ getClassName().toString());
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   //str.append(indent+" Declared type:\n");
	   //str.append(indent+declaredType().toString());
	   //str.append(indent+" Constraining type:\n");
	   //str.append(indent+constrainingType().toString());
	   
	   return str.toString();	
	}

	public String InstExtends.toString() {
		return toString("");
    }

	public String InstFullClassDecl.toString(String indent) {
	   StringBuffer str = new StringBuffer();
	   str.append(indent+"InstFullClassDecl:\n");
	   str.append(indent+" Class decl: " + getBaseClassDecl().name() + "\n");
	   str.append(indent+" myEnvironment():\n");
	   str.append(myEnvironment().toString(indent+" "));
	   str.append(indent+" myEnvironment('"+name()+"'):\n");
	   str.append(myEnvironment(name()).toString(indent+" "));	   
	   str.append(indent+" mergedEnvironment():\n");
	   str.append(getMergedEnvironment().toString(indent+" "));
	   //str.append(indent+" Declared type:\n");
	   //str.append(indent+declaredType().toString());
	   //str.append(indent+" Constraining type:\n");
	   //str.append(indent+constrainingType().toString());
	   
	   return str.toString();	
	}

	public String InstFullClassDecl.toString() {
		return toString("");
    }



	public String IModification.toString() {
		return toString("");
    }
    public String IModification.toString(String indent) {
    	return getModification().prettyPrint(indent);
    
    }
	
}

aspect InstancePrettyPrint {

	public String InstNode.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent + str.substring(str.lastIndexOf('.')+1);
		return str;

	}
	public String InstPrimitive.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + myInstClass().name() + " "+
		                      getComponentDecl().name();
		return str;

	}

}
