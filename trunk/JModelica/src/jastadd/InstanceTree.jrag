aspect InstantiationTree {

	class InstModification {
	   private InstNode instNode;
	   private Modification modification;
	   
	   public InstModification(InstNode instNode, Modification modification) {
	   	  this.instNode = instNode;
	   	  this.modification = modification;
	  
	   }
	   
	   public InstNode getInstNode() {
	  	  return instNode; 
	   }
	   
	   public Modification getModification() {
	   	  return modification;
	   }
	  
	   public ArrayList<InstModification> expand() { 	  
	   	  ArrayList<InstModification> l = new ArrayList<InstModification>();
	   	  if (getModification() instanceof CompleteModification) {  
				CompleteModification cm = (CompleteModification)getModification();
				for (int i=0;i<cm.getClassModification().getNumArgument();i++) {
					InstModification im = new InstModification(getInstNode(),cm.getClassModification().getArgument(i));
				    l.addAll(im.expand());
				} if (cm.hasValueModification())
					l.add(new InstModification(getInstNode(),cm.getValueModification()));
				return l;
			} if (getModification() instanceof ClassModification) { 
				ClassModification cm = (ClassModification)getModification();
				for (int i=0;i<cm.getNumArgument();i++) {
					InstModification im = new InstModification(getInstNode(),cm.getArgument(i));
					l.addAll(im.expand());
				}
				return l;
		  } else {
		     l.add(this);
		  }
		  return l;
	    }
	}
	
	// This is actually an new kind of NTA that is defined directely in code.
    syn nta InstConstrainingClause InstComposite.instConstrainingClause() {
       return new InstConstrainingClause(new List(),getComponentDecl().getConstrainingClause());
    }

    syn nta InstConstrainingClause InstReplacingComponent.instConstrainingClause() {
       return new InstConstrainingClause(new List(),getComponentDecl().getConstrainingClause());
    }

    syn nta InstConstrainingClause InstReplacingComponent.originalInstConstrainingClause() {
       return new InstConstrainingClause(new List(),getOriginalDecl().getConstrainingClause());
    }
	
	// This rewrite eliminates CompositeModifications as children of
	// InstModifications, which simplifies implementation.
/*	public boolean InstModification.rewritten = false;
	rewrite InstModification in InstNode.getMergedEnvironment(){
		when(!rewritten)
		to List {
			if (getModification() instanceof CompleteModification) {  
			    debugPrint("xxxxxxxxx rewrite InstModification in InstNode.getMergedEnvironment()");
				List l = new List();
				CompleteModification cm = (CompleteModification)getModification();
				for (int i=0;i<cm.getClassModification().getNumArgument();i++) {
					InstModification im = new InstModification(getInstNode(),cm.getClassModification().getArgument(i));
				    l.addAll(im.expand());
				} 
				if (cm.hasValueModification())
				   l.add(new InstModification(getInstNode(),cm.getValueModification()));
				return l;
		} if (getModification() instanceof ClassModification) { 
			    debugPrint("yyyyy rewrite InstModification in InstNode.getMergedEnvironment()");
				List l = new List();
				ClassModification cm = (ClassModification)getModification();
				for (int i=0;i<cm.getNumArgument();i++) {
					InstModification im = new InstModification(getInstNode(),cm.getArgument(i));
					l.addAll(im.expand());
				}
				return l;
		} else {
			this.rewritten = true;
			return new List().add(this);
		}
		}
		
	}
	*/
	

    syn int InstNode.getNumMergedEnvironment() =
    	getMergedEnvironmentList().size();
    
    syn InstModification InstNode.getMergedEnvironment(int i) = 
        getMergedEnvironmentList().get(i); 

    /* getMergedEnvironment gives the environment applicable
       to the children of the InstNode. It consists of the outer modifications
       in the environment (with the name of the InstNode itself, if any,
       removed merged with potential local modifications.
    
       TODO: Should this attribute be lazy? Probably yes
    */   
        
	syn lazy ArrayList<InstModification> InstNode.getMergedEnvironmentList() {
		debugPrint("InstNode.getMergedEnvironmentList()");
		// Retrieve modifications upwards
		ArrayList<InstModification> env = nameScope()? myEnvironment(name()): myEnvironment();
		for (int i=0;i<localModifications().size();i++)
			env.add(new InstModification(this,(Modification)localModifications().get(i)));
 	    
 	    // Eliminate all CompleteModification:s and ClassModification:s
 	    ArrayList<InstModification> finalEnv = new ArrayList<InstModification>();
		for (InstModification im : env) {
		    if (im.getModification() instanceof CompleteModification || im.getModification() instanceof ClassModification) {
				finalEnv.addAll(im.expand());
			} else
			    finalEnv.add(im);
			
		}

		return finalEnv;
	}
		
	inh lazy ArrayList<InstModification> InstNode.myEnvironment();
	inh lazy ArrayList<InstModification> InstNode.myEnvironment(String name);
	
	eq InstNode.getInstNode().myEnvironment() {
		ArrayList<InstModification> env = new ArrayList<InstModification>();
		for (int i=0;i<getNumMergedEnvironment();i++)
			env.add(new InstModification(getMergedEnvironment(i).getInstNode(),
			                             getMergedEnvironment(i).getModification()));
		return env;
	}
	
	eq InstNode.getInstNode().myEnvironment(String name) =
	  localMyEnvironment(name);
	
	syn ArrayList<InstModification> InstNode.localMyEnvironment(String name) {
	    if(!is$Final) throw new Error("Node is not final");
		debugPrint("InstNode.getInstNode().myEnvironment(): " + name);
		ArrayList<InstModification> env = new ArrayList<InstModification>();
		//debugPrint("*****: "+getNumMergedEnvironment());
		for (int i=0;i<getNumMergedEnvironment();i++) {
			//getMergedEnvironment(i).getModification().dumpTree("----");
			Modification m = getMergedEnvironment(i).getModification().matchModification(name);
			if (m!=null)
				env.add(new InstModification(getMergedEnvironment(i).getInstNode(),m));
		}
		return env;
	}
	
	eq InstReplacingComponent.originalInstConstrainingClause().myEnvironment() = new ArrayList<InstModification>();
    
    eq ConstrainingClause.constrainingClauseInstRoot().myEnvironment()  {
    	ArrayList<InstModification> l = new ArrayList<InstModification>();
    	if (hasClassModification()) {
			for (int i=0;i<getClassModification().getNumArgument();i++)
			  // TODO: should it be constrainingClauseInstRoot().getInstNode(0)? (then circular!!!)
		      l.add(new InstModification(constrainingClauseInstRoot(),getClassModification().getArgument(i)));
    		
    	}
    	return l;
    }
	
	
	syn lazy Modification Modification.matchModification(String name) = null;
	eq CompleteModification.matchModification(String name) {
		for (int i=0;i<getClassModification().getNumArgument();i++)
			if (getClassModification().getArgument(i).matchModification(name)!=null)
				return getClassModification().getArgument(i).matchModification(name);
		return null;
	}
	
	eq ComponentModification.matchModification(String name) {
		debugPrint("ComponentModification.matchModification: " + name);
		if (name.equals(getName().getID()))
			return getModification();
		return null;
	}
	
	eq ComponentRedeclare.matchModification(String name) {
		if (name.equals(getName().getID()) && getComponentDecl().hasModification())
			return getComponentDecl().getModification();
		return null;
	}
	
	syn lazy ComponentDecl Modification.matchRedeclare(String name) = null;
	eq ComponentRedeclare.matchRedeclare(String name) {
		if (getName().getID().equals(name))
			return getComponentDecl();
		else
			return null;
	}
	
	eq BaseClassDecl.getInstRoot().myEnvironment() = new ArrayList<InstModification>();
	eq BaseClassDecl.getInstRoot().myEnvironment(String name) = new ArrayList<InstModification>();
	
	// Definition of the NTA representing the root of the 
	// instantiation tree
	syn InstRoot BaseClassDecl.getInstRoot() = new InstClassRoot(new List(),this);
	syn nta InstConstrainingClauseRoot ConstrainingClause.constrainingClauseInstRoot() = new InstConstrainingClauseRoot(new List(),this);


	syn lazy List InstNode.getInstNodeList() {
	
		List l = new List();
		List comps = components();
		List supers = superClasses();	
		
		
		debugPrint("InstNode.getInstNodeList: " +getClass().getName());
	
		debugPrint("########################################");
		debugPrint("Environment:");
		String s = "";
		for (int i=0;i<getNumMergedEnvironment();i++) {
		    s += getMergedEnvironment(i).getInstNode().getNodeName() + " -- ";
			s += getMergedEnvironment(i).getModification().prettyPrint("") + "\n";
		}
		debugPrint(s);
		
		
		for (int i=0;i<comps.getNumChild();i++) {
			ComponentDecl cd = (ComponentDecl)comps.getChild(i);
			ComponentDecl replacingCD = retrieveReplacingComponent(cd.name());
			if (replacingCD != null)
				l.add(new InstReplacingComponent(new List<FExp>(),replacingCD,cd));
			else
				l.add(cd.newInstComponent());
		}				
	
		for (int i=0;i<supers.getNumChild();i++) {
			l.add(((ExtendsClause)supers.getChild(i)).newInstExtends());
		}
		return l;
	}

	eq InstPrimitive.getInstNodeList() = new List();

	syn ComponentDecl InstNode.retrieveReplacingComponent(String name) {
		for (int i=0;i<getNumMergedEnvironment();i++) {
			if (getMergedEnvironment(i).getModification().matchRedeclare(name)!=null) {
				return getMergedEnvironment(i).getModification().matchRedeclare(name);
			}
		}
		return null;
	}


	// Attribute for building an InstComposite node based
	// on a ComponentDecl
	public InstComponent ComponentDecl.newInstComponent() {
	   return myClass().newInstComponent(this);
	}
	
	// Dispatch w.r.t. class type
	public abstract InstComponent ClassDecl.newInstComponent(ComponentDecl cd);

	public InstComponent BaseClassDecl.newInstComponent(ComponentDecl cd) {
		if (!extendsPrimitive())
			return new InstComposite(new List(),cd);
		else {
			return new InstPrimitive(new List(),cd);
		}
	}
	
	public InstComponent ShortClassDecl.newInstComponent(ComponentDecl cd) {
		return getClassName().myClassDecl().newInstComponent(cd);
	}
	
	public InstComponent PrimitiveClassDecl.newInstComponent(ComponentDecl cd) {
		return new InstPrimitive(new List(),cd);
	}
	
	public InstComponent BuiltInClassDecl.newInstComponent(ComponentDecl cd) {
		return null;
	}
	
	// Build an InstExtends
	public InstExtends ExtendsClause.newInstExtends() {
		return new InstExtends(new List(),this);
	}

	syn boolean ClassDecl.extendsPrimitive() = false;
	eq ShortClassDecl.extendsPrimitive() = finalClass().extendsPrimitive();
	eq FullClassDecl.extendsPrimitive(){
		return (getNumSuper()==1 && getSuper(0).getSuper().myClassDecl().finalClass().isPrimitive());
	}
	
	// The following attributes defines a generic interface
	// for InstNodes	
	// Just to avoid casts... (Is this a good idea? yes.)
	syn lazy List ClassDecl.equations() = root().emptyList();
	eq FullClassDecl.equations() = getEquationList();
	eq ShortClassDecl.equations() = getClassName().myClassDecl().equations();
	
	syn lazy List ClassDecl.superClasses() = root().emptyList();
	eq FullClassDecl.superClasses() = getSuperList();
	eq ShortClassDecl.superClasses() = getClassName().myClassDecl().superClasses();
	
	syn lazy List ClassDecl.components() = root().emptyList();
	eq FullClassDecl.components() = getComponentDeclList();
	eq ShortClassDecl.components() = getClassName().myClassDecl().components();
	
	syn boolean InstNode.nameScope() = false;
	eq InstComponent.nameScope() = true;

    syn String InstNode.name() = "";
    eq InstComponent.name() = getComponentDecl().name();

	/*
	syn lazy Modification InstNode.modificationTree() = null;
	eq InstComponent.modificationTree() = getComponentDecl().hasModification()? getComponentDecl().getModification():null;
	eq InstExtends.modificationTree() = getExtendsClause().hasClassModification()? getExtendsClause().getClassModification():null;
	*/
	
	syn lazy ArrayList<Modification> InstNode.localModifications() = new ArrayList<Modification>();
	eq InstComponent.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (getComponentDecl().hasModification())
			l.add(getComponentDecl().getModification());
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getComponentDecl().myClass().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		// This is to take into account the case when we instantiate a
		// component based on a class which inherits from a primitive type
//		if (getComponentDecl().myClass().extendsPrimitive()) {
//			if (getComponentDecl().myClass().getSuper(0).hasClassModification())	
//				l.add(getComponentDecl().myClass().getSuper(0).getSuper().getClassModification());	
//		}
		
		return l;
		
	}
	
    eq InstConstrainingClause.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (getConstrainingClause().hasClassModification())
			l.add(getConstrainingClause().getClassModification());
		return l;
	}
	
	eq InstReplacingComponent.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (getOriginalDecl().hasModification())
			l.add(getOriginalDecl().getModification());
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getOriginalDecl().myClass().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		
		return l;
	}
	
	

	eq InstExtends.localModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (getExtendsClause().hasClassModification())
			l.add(getExtendsClause().getClassModification());
		// This is to take modifiers short class declarations into account
		ArrayList<Modification> classMods = getExtendsClause().getSuper().myClassDecl().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		return l;
	}

	syn lazy ArrayList<Modification> ClassDecl.classModifications() = new ArrayList<Modification>();
	eq FullClassDecl.classModifications() {
		if (!extendsPrimitive())
			return new ArrayList<Modification>();
		else {
		    // Add (optional) modification on the ExtendsClause
			ArrayList<Modification> l = new ArrayList<Modification>();
			if (getSuper(0).hasClassModification())
				l.add(getSuper(0).getClassModification());
			// If we inherit from a ShortClassDecl there might be additional
			// modifications	
			ArrayList<Modification> classMods = getSuper(0).getSuper().myClassDecl().classModifications();
			for (int i = 0;i<classMods.size();i++)
				l.add(classMods.get(i));		
			return l;
		}
		
	}
	
	eq ShortClassDecl.classModifications() {
		ArrayList<Modification> l = new ArrayList<Modification>();
		if (hasClassModification())
			l.add(getClassModification());
		ArrayList<Modification> classMods = getClassName().myClassDecl().classModifications();
		for (int i = 0;i<classMods.size();i++)
			l.add(classMods.get(i));	
		return l;
	}
	
	syn List InstNode.equations();
	eq InstClassRoot.equations() = getClassDecl().equations();
	eq InstComponent.equations() = getComponentDecl().myClass().equations();
	eq InstExtends.equations() = getExtendsClause().getSuper().myClassDecl().equations();
	eq InstConstrainingClause.equations() = getConstrainingClause().getAccess().myClassDecl().equations();
	eq InstConstrainingClauseRoot.equations() = getConstrainingClause().getAccess().myClassDecl().equations();
	
	syn lazy List InstNode.components();
	eq InstClassRoot.components() = getClassDecl().components();
	eq InstComponent.components() = getComponentDecl().myClass().components();
	eq InstExtends.components() = getExtendsClause().getSuper().myClassDecl().components();
	eq InstConstrainingClause.components() = getConstrainingClause().getAccess().myClassDecl().components();
	eq InstConstrainingClauseRoot.components() = getConstrainingClause().getAccess().myClassDecl().components();

	
	syn lazy List InstNode.superClasses();
	eq InstClassRoot.superClasses() = getClassDecl().superClasses();
	eq InstComponent.superClasses() = getComponentDecl().myClass().superClasses();
	eq InstExtends.superClasses() = getExtendsClause().getSuper().myClassDecl().superClasses();
	eq InstConstrainingClause.superClasses() = getConstrainingClause().getAccess().myClassDecl().superClasses();
    eq InstConstrainingClauseRoot.superClasses() = getConstrainingClause().getAccess().myClassDecl().superClasses();
}

aspect InstanceDumpTree {

	// Some basic dump routines
	public void InstNode.dumpTree(String indent) {
		System.out.println(indent + dump());
		getInstNodeList().dumpTree(indent + " ");
	}
	

	
	public void InstComposite.dumpTree(String indent) {
		System.out.println(indent + dump()
		                      + ": " + 
		                      getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name());
		//getComponentDecl().dumpTree("");
		getInstNodeList().dumpTree(indent + " ");
	}
	
	public void InstPrimitive.dumpTree(String indent) {
		System.out.println(indent + dump()
							  + ": " + 
		                      getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name());
	}
	
}

aspect InstancePrettyPrint {

	public String InstNode.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent + str.substring(str.lastIndexOf('.')+1);
		return str;

	}
	public String InstPrimitive.prettyPrint(String indent) {
		String str = getClass().getName();
		str = indent+str.substring(str.lastIndexOf('.')+1);
		str+= ": " + getComponentDecl().myClass().name() + " "+
		                      getComponentDecl().name();
		return str;

	}

}
