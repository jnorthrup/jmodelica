import java.util.Collection;
import java.util.LinkedList;
import java.util.ArrayList;

aspect ErrorCheck {

  public ArrayList<Problem> Root.errors = new ArrayList<Problem>();
  public ArrayList<Problem> Root.warnings = new ArrayList<Problem>();
  
  public String ASTNode.errorPrefix() {
    return fileName() + ":\n" + "  *** Semantic Error: ";
  }
  public String ASTNode.warningPrefix() {
    return fileName() + ":\n" + "  *** WARNING: ";
  }

  protected static final int ASTNode.ERRORS = 0;
  protected static final int ASTNode.WARNINGS = 1;  
  
  class Problem implements Comparable {
    public int compareTo(Object o) {
      if(o instanceof Problem) {
        Problem other = (Problem)o;
        if(!fileName.equals(other.fileName))
          return fileName.compareTo(other.fileName);
        return message.compareTo(other.message);
      }
      return 0;
    }
    public static class Severity {
      public static final Severity ERROR = new Severity();
      public static final Severity WARNING = new Severity();
      private Severity() { }
    }
    public static class Kind {
      public static final Kind OTHER = new Kind();
      public static final Kind LEXICAL = new Kind();
      public static final Kind SYNTACTIC = new Kind();
      public static final Kind SEMANTIC = new Kind();
      private Kind() { }
    }
    protected int beginLine = 0;
    protected int beginColumn = 0;
    public int beginLine() { return beginLine; }
    public void setBeginLine(int beginLine) { this.beginLine = beginLine; }
    public int beginColumn() { return beginColumn; }
    public void setBeginColumn(int beginColumn) { this.beginColumn = beginColumn; }
  
    protected String fileName;
    public String fileName() { return fileName; }
    public void setFileName(String fileName) { this.fileName = fileName; }
    protected String message;
    public String message() { return message; }
    protected Severity severity = Severity.ERROR;
    public Severity severity() { return severity; }
    protected Kind kind = Kind.OTHER;
    public Kind kind() { return kind; }
    
    public Problem(String fileName, String message) {
      this.fileName = fileName;
      this.message = message;
    }
    public Problem(String fileName, String message, Severity severity) {
      this(fileName, message);
      this.severity = severity;
    }
    public Problem(String fileName, String message, Severity severity, Kind kind) {
        this(fileName, message, severity);
        this.kind = kind;
    }    
    public Problem(String fileName, String message, Severity severity, Kind kind, int beginLine, int beginColumn) {
        this(fileName, message, severity);
        this.kind = kind;
        this.beginLine = beginLine;
        this.beginColumn = beginColumn;
    }    
  
  
    public String toString() {
      String s = "";
      String lineData = "at line "+beginLine+", column "+beginColumn+":\n";
      if(this.kind == Kind.LEXICAL)
        s = "Lexical error "+lineData;
      else if(this.kind == Kind.SYNTACTIC)
        s = "Syntactic error "+lineData;
      else if(this.kind == Kind.SEMANTIC)
        s = "Semantic error "+lineData;
      return "In file '"+fileName + "':\n" + s +"  "+ message;
    }
  }

  syn int ASTNode.lineNumber() = start != 0 ? beginLine() : getParent().lineNumber();
  syn int ASTNode.columnNumber() = start != 0 ? beginColumn() : getParent().columnNumber();
  protected void ASTNode.error(String s) {
      root().errors.add(new Problem(fileName(), s, Problem.Severity.ERROR, Problem.Kind.SEMANTIC,lineNumber(),columnNumber()));
  }

  protected void ASTNode.warning(String s) {
	 root().warnings.add(new Problem(fileName(), "WARNING: " + s, Problem.Severity.WARNING));
  }

  
  public void ASTNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(int i = 0; i < getNumChild(); i++) {
		  getChild(i).collectErrors();
	  }
  }

  
  public boolean ASTNode.errorCheck() {
    ArrayList allErrors = root().errors;
    ArrayList allWarnings = root().warnings;
    collectErrors();    
    if (!allWarnings.isEmpty()) {
    	System.out.println("Warnings:");    
    	for(Iterator iter = allWarnings.iterator(); iter.hasNext(); ) {
    		Problem problem = (Problem) iter.next();
    		System.out.println(problem);
    	}
    }
   if(allErrors.isEmpty())
      return false;
    System.out.println(allErrors.size() + " error(s) found...");
    for(Iterator iter = allErrors.iterator(); iter.hasNext(); ) {
      Problem problem = (Problem)iter.next();
      System.out.println(problem);
    }
    return true;
  }
 
    syn lazy FullClassDecl ASTNode.retrieveFullClassDecl(String className) {
      for(int i = 0; i < getNumChild(); i++) {
		  FullClassDecl fcd = getChild(i).retrieveFullClassDecl(className);
	  	  if (fcd != null)
	  	  	return fcd;
	  }
	  return null;
    }   
  	
  	eq FullClassDecl.retrieveFullClassDecl(String className) {
	   	if (className.equals(qualifiedName())) {
	   		return this;
		} else
			return getClassDeclList().retrieveFullClassDecl(className);
	}

	/* We don't want to error check an entire model, just the classes
	   that are used. */
	public boolean SourceRoot.checkErrorsInClass(String className) {
		FullClassDecl fcd = retrieveFullClassDecl(className);
		if (fcd == null) {
			System.out.println("Class "+ className + "not found");
			return false;
		} else
			return fcd.errorCheck();
	}
	
	boolean FullClassDecl.errorChecked = false;
  	public void FullClassDecl.collectErrors() {
    	debugPrint("ErrorChecking: " + qualifiedName());
    	if (!errorChecked) {
    	errorChecked = true;
    	getEquationList().collectErrors();
    	getAlgorithmList().collectErrors();
    	getSuperList().collectErrors();
    	getImportList().collectErrors();
    	getComponentDeclList().collectErrors();
    	debugPrint("ErrorChecking: " + qualifiedName() + ": done with components");
    	if (!(getName().getID().equals(getEndName())))
    		error("The declaration and end names of a class should be the same");
  		}
  	}
	
	
	public void ComponentDecl.collectErrors() {
		super.collectErrors();
		if (getClassName().myClassDecl()!=null) {
			debugPrint("ComponentDecl.collectErrors:  "  + prettyPrint("") + ": " + getClassName().myClassDecl().qualifiedName());
			getClassName().myClassDecl().collectErrors();
		}
	}
	
   // Don't error check annotation
   public void Annotation.collectErrors() {}
	
  
}
