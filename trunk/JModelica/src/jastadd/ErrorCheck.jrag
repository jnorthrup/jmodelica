import java.util.Collection;
import java.util.LinkedList;
import java.util.ArrayList;


  
  class Problem implements Comparable {
    public int compareTo(Object o) {
      if(o instanceof Problem) {
        Problem other = (Problem)o;
        if(!fileName.equals(other.fileName))
          return fileName.compareTo(other.fileName);
        return message.compareTo(other.message);
      }
      return 0;
    }
    public static class Severity {
      public static final Severity ERROR = new Severity();
      public static final Severity WARNING = new Severity();
      private Severity() { }
    }
    public static class Kind {
      public static final Kind OTHER = new Kind();
      public static final Kind LEXICAL = new Kind();
      public static final Kind SYNTACTIC = new Kind();
      public static final Kind SEMANTIC = new Kind();
      private Kind() { }
    }
    protected int beginLine = 0;
    protected int beginColumn = 0;
    public int beginLine() { return beginLine; }
    public void setBeginLine(int beginLine) { this.beginLine = beginLine; }
    public int beginColumn() { return beginColumn; }
    public void setBeginColumn(int beginColumn) { this.beginColumn = beginColumn; }
  
    protected String fileName;
    public String fileName() { return fileName; }
    public void setFileName(String fileName) { this.fileName = fileName; }
    protected String message;
    public String message() { return message; }
    protected Severity severity = Severity.ERROR;
    public Severity severity() { return severity; }
    protected Kind kind = Kind.OTHER;
    public Kind kind() { return kind; }
    
    public Problem(String fileName, String message) {
      this.fileName = fileName;
      this.message = message;
    }
    public Problem(String fileName, String message, Severity severity) {
      this(fileName, message);
      this.severity = severity;
    }
    public Problem(String fileName, String message, Severity severity, Kind kind) {
        this(fileName, message, severity);
        this.kind = kind;
    }    
    public Problem(String fileName, String message, Severity severity, Kind kind, int beginLine, int beginColumn) {
        this(fileName, message, severity);
        this.kind = kind;
        this.beginLine = beginLine;
        this.beginColumn = beginColumn;
    }    
  
  
    public String toString() {
      String s = "";
      String lineData = "at line "+beginLine+", column "+beginColumn+":\n";
      if(this.kind == Kind.LEXICAL)
        s = "Lexical error "+lineData;
      else if(this.kind == Kind.SYNTACTIC)
        s = "Syntactic error "+lineData;
      else if(this.kind == Kind.SEMANTIC)
        s = "Semantic error "+lineData;
      return "In file '"+fileName + "':\n" + s +"  "+ message;
    }
  }

aspect ErrorCheck {

  public ArrayList<Problem> Root.errors = new ArrayList<Problem>();
  public ArrayList<Problem> Root.warnings = new ArrayList<Problem>();
  
  public String ASTNode.errorPrefix() {
    return fileName() + ":\n" + "  *** Semantic Error: ";
  }
  public String ASTNode.warningPrefix() {
    return fileName() + ":\n" + "  *** WARNING: ";
  }

  static final int ASTNode.ERRORS = 0;
  static final int ASTNode.WARNINGS = 1;  


  syn int ASTNode.lineNumber() = (start != 0 || getParent()==null)? beginLine() : getParent().lineNumber();
  syn int ASTNode.columnNumber() = (start != 0 || getParent()==null)? beginColumn() : getParent().columnNumber();
  void ASTNode.error(String s) {
      root().errors.add(new Problem(fileName(), s, Problem.Severity.ERROR, Problem.Kind.SEMANTIC,lineNumber(),columnNumber()));
  }

  void ASTNode.warning(String s) {
	 root().warnings.add(new Problem(fileName(), "WARNING: " + s, Problem.Severity.WARNING));
  }

  
  public void ASTNode.collectErrors() {
	  nameCheck();
	  typeCheck();	  
	  for(int i = 0; i < getNumChild(); i++) {
		  getChild(i).collectErrors();
	  }
  }


  public boolean ASTNode.errorCheck(StringBuffer str) {
    ArrayList allErrors = root().errors;
    ArrayList allWarnings = root().warnings;
    collectErrors();  
    if (!allWarnings.isEmpty()) {
    	str.append("\n");        	
    	str.append("Warnings:\n");    
    	for(Iterator iter = allWarnings.iterator(); iter.hasNext(); ) {
    		Problem problem = (Problem) iter.next();
    		str.append(problem+"\n");
    	}
    }
   if(allErrors.isEmpty())
      return false;
    str.append("\n");        	
    str.append(allErrors.size() + " error(s) found...\n");
    for(Iterator iter = allErrors.iterator(); iter.hasNext(); ) {
      Problem problem = (Problem)iter.next();
      str.append(problem+"\n");
    }
    
    return true;
  }
  
  public boolean ASTNode.errorCheck() {
 	StringBuffer str = new StringBuffer();
 	boolean errors = errorCheck(str);
 	System.out.println(str.toString());
 	return errors;
  }


 
    syn lazy FullClassDecl ASTNode.retrieveFullClassDecl(String className) {
      for(int i = 0; i < getNumChild(); i++) {
		  FullClassDecl fcd = getChild(i).retrieveFullClassDecl(className);
	  	  if (fcd != null)
	  	  	return fcd;
	  }
	  return null;
    }   
  	
  	eq FullClassDecl.retrieveFullClassDecl(String className) {
	   	if (className.equals(qualifiedName())) {
	   		return this;
		} else
			return getClassDeclList().retrieveFullClassDecl(className);
	}

	/* We don't want to error check an entire model, just the classes
	   that are used. */
	public boolean SourceRoot.checkErrorsInClass(String className) {
		FullClassDecl fcd = retrieveFullClassDecl(className);
		if (fcd == null) {
			System.out.println("Class "+ className + "not found");
			return false;
		} else
			return fcd.errorCheck();
	}

	public boolean SourceRoot.checkErrorsInClass(String className,StringBuffer errorString) {
		FullClassDecl fcd = retrieveFullClassDecl(className);
		if (fcd == null) {
			System.out.println("Class "+ className + " not found");
			return true;
		} else
			return fcd.errorCheck(errorString);
	}


	
	boolean FullClassDecl.errorChecked = false;
  	public void FullClassDecl.collectErrors() {
    	debugPrint("ErrorChecking: " + qualifiedName());
    	if (!errorChecked) {
    	errorChecked = true;
    	getEquationList().collectErrors();
    	getAlgorithmList().collectErrors();
    	getSuperList().collectErrors();
    	getImportList().collectErrors();
    	getComponentDeclList().collectErrors();
    	debugPrint("ErrorChecking: " + qualifiedName() + ": done with components");
    	if (!(getName().getID().equals(getEndName())))
    		error("The declaration and end names of a class should be the same");
  		}
  	}
	
 	
	public void ComponentDecl.collectErrors() {
		super.collectErrors();
		if (getClassName().myClassDecl()!=null) {
		debugPrint("ComponentDecl.collectErrors:  "  + prettyPrint("") + ": " + getClassName().myClassDecl().qualifiedName());
			getClassName().myClassDecl().collectErrors();
		}
	}
	

	
   // Don't error check annotation
   public void Annotation.collectErrors() {}
   
}


aspect InstanceErrorCheck {


 // Error checking in instance tree
    syn lazy InstFullClassDecl InstNode.retrieveInstFullClassDecl(String className) {
      for(int i = 0; i < getNumInstNode(); i++) {
		  InstFullClassDecl fcd = getInstNode(i).retrieveInstFullClassDecl(className);
	  	  if (fcd != null)
	  	  	return fcd;
	  }
	  return null;
    }   
  	
  	
  	
  	eq InstFullClassDecl.retrieveInstFullClassDecl(String className) {
	   	if (className.equals(qualifiedName())) {
	   		return this;
		} else
			for (InstClassDecl icd : instClassDecls()) {
				InstFullClassDecl fcd = icd.retrieveInstFullClassDecl(className);
				if (fcd!=null) 
					return fcd;
			}
		return null;
	}

	// We don't want to error check an entire model, just the classes
	//   that are used. 
	public boolean InstProgramRoot.checkErrorsInInstClass(String className) {
		InstFullClassDecl fcd = retrieveInstFullClassDecl(className);
		if (fcd == null) {
			System.out.println("Class "+ className + " not found");
			return true;
		} else
			return fcd.errorCheck();
	}

	public boolean InstProgramRoot.checkErrorsInInstClass(String className,StringBuffer errorString) {
		InstFullClassDecl fcd = retrieveInstFullClassDecl(className);
		if (fcd == null) {
			System.out.println("Class "+ className + " not found");
			return false;
		} else
			return fcd.errorCheck(errorString);
	}

	boolean InstNode.errorChecked = false;
  	public void InstFullClassDecl.collectErrors() {
    	if (!errorChecked) {
    	errorChecked = true;
 //       for (InstClassDecl icd : instClassDecls())
 //       	icd.collectErrors();
        for (InstComponentDecl icd : instComponentDecls())
        	icd.collectErrors();
        for (InstExtends ie : instExtends())
        	ie.collectErrors();	
        for (InstImport ii : getInstImports())
        	ii.collectErrors();		
//    	getEquationList().collectErrors();
//    	getAlgorithmList().collectErrors();
//    	getSuperList().collectErrors();
//    	getImportList().collectErrors();
//    	getComponentDeclList().collectErrors();
    	if (!(getFullClassDecl().getName().getID().equals(getFullClassDecl().getEndName())))
    		error("The declaration and end names of a class should be the same");
  		}
  	}	
  	
	boolean InstImport.errorChecked = false;
    public void InstImport.collectErrors() {
    if (!errorChecked) {
    	errorChecked = true;
		getPackageName().collectErrors();
		}
	}
	
	public void InstComponentDecl.collectErrors() {
    if (!errorChecked) {
		super.collectErrors();
		getClassName().collectErrors();
		if (!myInstClass().isUnknown()) {
			myInstClass().collectErrors();
		}
		}
	}
	
	public void InstExtends.collectErrors() {
    if (!errorChecked) {
		super.collectErrors();
		getClassName().collectErrors();
		if (!getClassName().myInstClassDecl().isUnknown()) {
			getClassName().myInstClassDecl().collectErrors();
		}
		}
	}	
	
  public void InstNode.collectErrors() {
    if (!errorChecked) {
    	errorChecked = true;
	  nameCheck();
	  typeCheck();	  
	  for(InstNode n : getInstNodes()) {
		  n.collectErrors();
	  }
	}
  }
  
  
/*  
    public void InstClassDecl.collectErrors() {

    }
*/  



}


