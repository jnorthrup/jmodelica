FlatRoot : Root ::= FClass;
FClass ::= FQName 
           FVariable* 
           FInitialEquation:FAbstractEquation*
           FEquationBlock*
           /FPrimitiveType*/; 

FEquationBlock ::= FAbstractEquation*;

abstract FAbstractVariable;
FUndefVariable : FAbstractVariable;

FVariable : FAbstractVariable ::= [FTypePrefixFlow] 
              [FTypePrefixOther] 
              [FTypePrefixInputOutput]
              Type:FPrimitiveType  
              /* Type:FTypeAccess */ // The child Type:FPrimitiveType would be replaced by this access
              FAttribute*
              [BindingExp:FExp]
              [FStringComment]
              FQName;

abstract FPrimitiveType;
FRealType : FPrimitiveType ::=;
FIntegerType : FPrimitiveType ::=; 
FStringType : FPrimitiveType ::=;
FBooleanType : FPrimitiveType ::=;

FQName ::= FQNamePart*;
FQNamePart ::= <Name:String> [FArraySubscripts];

FAttribute ::= Type:FIdUse
               Name:FIdDecl 			   
               [Value:FExp]
               <AttributeSet:boolean>
               [FEach]
               [FFinal]
               FAttribute*;

FEach ::=;
FFinal ::=;

abstract FTypePrefix;
abstract FTypePrefixFlow : FTypePrefix;
FFlow : FTypePrefixFlow::=;
abstract FTypePrefixOther : FTypePrefix;
// Continuous is not a valid prefix.  We will use it to identify 
// expressions that are not parameters, constants, or discrete.
FContinuous : FTypePrefixOther::=;
FDiscrete : FTypePrefixOther::=;
FParameter : FTypePrefixOther::=;
FConstant : FTypePrefixOther::=;
abstract FTypePrefixInputOutput : FTypePrefix;
FInput : FTypePrefixInputOutput::=;
FOutput : FTypePrefixInputOutput::=;

FStringComment ::= <Comment:String>;

FArraySubscripts ::= FSubscript*;
abstract FSubscript;
FColonSubscript : FSubscript::=;
FExpSubscript : FSubscript ::= FExp;

abstract FExp;
abstract FAbstractEquation;
FEquation : FAbstractEquation ::= Left:FExp Right:FExp;
FInitialEquation : FEquation;
FConnectClause : FAbstractEquation ::= [FStringComment] Connector1:FIdUseInstAccess Connector2:FIdUseInstAccess;

abstract FBinExp : FExp ::= Left:FExp Right:FExp;
abstract FUnaryExp : FExp ::= FExp;

abstract FArtmBinExp : FBinExp;
FAddExp : FArtmBinExp::=;
FSubExp : FArtmBinExp::=;
FMulExp : FArtmBinExp::=;
FMulExpMM : FMulExp::=;
FMulExpVM : FMulExp::=;
FMulExpMV : FMulExp::=;
FMulExpVV : FMulExp::=;
FDivExp : FArtmBinExp::=;
FPowExp : FArtmBinExp::=;
FNegExp : FUnaryExp ::=;

abstract FLogBinExp : FBinExp;
FLtExp : FLogBinExp;
FLeqExp : FLogBinExp;
FGtExp : FLogBinExp;
FGeqExp : FLogBinExp;
FEqExp : FLogBinExp;
FNeqExp : FLogBinExp;
FNotExp : FUnaryExp ::=;
FOrExp : FLogBinExp;
FAndExp : FLogBinExp;

FRealLitExp : FExp ::= <UNSIGNED_NUMBER>;

FFunctionCall : FExp ::= Name:FIdUse Args:FExp*;

FSumRedExp : FExp ::= FExp FForIndex;
FForIndex ::= FIdDecl [FExp];

FDer : FExp ::= FIdUseExp;

FScalar : FUnaryExp ::=;
FTranspose : FUnaryExp ::=;
FIdentity : FFunctionCall;
FOnes : FFunctionCall;
FZeros : FFunctionCall;

FSumExp : FUnaryExp ::=;

FForClauseE : FAbstractEquation ::= FForIndex* ForEqns:FAbstractEquation*;

FIfExp : FExp ::= IfExp:FExp ThenExp:FExp FElseIfExp* ElseExp:FExp;
FElseIfExp : FExp ::= IfExp:FExp ThenExp:FExp;

FIdUseExp : FExp ::= FIdUse;

FInstAccessExp : FExp ::= InstAccess;

FIdDecl ::= FQName;
FIdUse ::= <ID>;

FIdUseInstAccess : FIdUse ::= InstAccess;


FTypeAccess : FIdUse; // New type access

FIdUseQualified : FIdUse ::= FQName;
// The flat model does not contain qualified names, but is modeled
// as such in order to keep track of name parts and array indices, 
// which in turn enables different output on different formats.
//FDot : FIdUse ::= Left:FIdUse Right:FIdUse; 
FStringLitExp : FExp ::= <String>;
//FBooleanLitExp : FExp ::= <Val:boolean>;
abstract FBooleanLitExp : FExp ::=;
FBooleanLitExpTrue : FBooleanLitExp;
FBooleanLitExpFalse : FBooleanLitExp;

FArrayConstructor : FExp ::= FExp*;
FMatrix : FExp ::= FExpList*;
FExpList : FExp ::= FExp*;

FRangeExp : FExp ::= FExp*;

FNoExp : FExp::=;

FTimeExp : FExp;

// Built in functions
FSizeExp : FExp ::= FIdUseExp Dim:FExp;
