// MiniModelica abstract grammar
SourceRoot : Root ::= Program;

Program ::= Element* 
            /UnknownClassDecl/
            /UnknownComponentDecl/
            /PredefinedType:ClassDecl*/ 
            /BuiltInType:ClassDecl*/   
            /BuiltInFunction:ClassDecl*/
            /LibNode*/;



abstract ClassDecl : Element ::=;
abstract BaseClassDecl : ClassDecl::=VisibilityType 
									  [Encapsulated] 
	                                  [Partial] 
	                                  Restriction 
	                                  Name:IdDecl  
                                      [Redeclare]
	                                  [Final]
	                                  [Inner]
	                                  [Outer]
	                                  [Replaceable]
	                                  [ConstrainingClause]
                                      [ConstrainingClauseComment:Comment]
                                      /InstRoot/;

UnknownClassDecl : FullClassDecl::=;

PN_FullClassDecl : BaseClassDecl ::= [StringComment] 
                                       Composition 
                                       <EndName:String>;
	                      
FullClassDecl : BaseClassDecl ::= [StringComment]  
                                Equation:AbstractEquation* 
                                Algorithm:AbstractAlgorithm*
                                Super:ExtendsClause*  
                                Import:ImportClause* 
                                ClassDecl* 
                                ComponentDecl*
                                Annotation* 
                                [ExternalClause] 
                                <EndName:String>;

LibClassDecl : FullClassDecl ::= LibNode*;
LibNode ::= <FileName:String> <Name:String> <Structured:boolean> /ClassDecl/;

ShortClassDecl : BaseClassDecl ::= [TypePrefixFlow] 
                                [TypePrefixOther]
                                [TypePrefixInputOutput] 
                                ClassName:Access  
                                [ArraySubscripts] 
                                [ClassModification] 
                                Comment; 
                                
ExtendClassDecl : BaseClassDecl ::= [ClassModification] [StringComment] Composition  <EndName:String>;
                                   
PrimitiveClassDecl : FullClassDecl::=;
RealClassDecl : PrimitiveClassDecl::=;
IntegerClassDecl : PrimitiveClassDecl::=;
BooleanClassDecl : PrimitiveClassDecl::=;
StringClassDecl : PrimitiveClassDecl::=;

BuiltInClassDecl : ClassDecl ::= Name:IdDecl;
//RealType : BuiltInClassDecl ::=;
//IntegerType : BuiltInClassDecl ::=;
//StringType : BuiltInClassDecl ::=;
//BooleanType : BuiltInClassDecl ::=;

ConstrainingClause ::= Access [ClassModification];

abstract Restriction;
Model : Restriction::=;
Block : Restriction::=;
MClass : Restriction::=;
Connector : Restriction::=;
Type : Restriction::=;
MPackage : Restriction::=;
Function : Restriction::=;
Record : Restriction::=;

Replaceable::=;
Redeclare::=;
Encapsulated::=;
Partial::=;
Inner::=;
Outer::=;

abstract VisibilityType::=;
PublicVisibilityType : VisibilityType ::=;
ProtectedVisibilityType : VisibilityType ::=;
UnknownVisibilityType : VisibilityType ::=;

Composition ::= Clause* [AbstractExternalClause];

abstract AbstractExternalClause::=;

ExternalClause : AbstractExternalClause ::= [Language:StringWrapper] 
                                            [ReturnVar:Access] 
                                            [FunctionName:IdDecl]
                                            Args:Exp* 
                                            [Annotation1:Annotation] 
                                            [Annotation2:Annotation];

PN_ExternalClause : AbstractExternalClause ::= [Language:StringWrapper] 
                                               [PN_ExternalFunctionCall]
                                               [Annotation1:Annotation] 
                                               [Annotation2:Annotation];
                   
PN_ExternalFunctionCall ::= [ReturnVar:Access] FunctionName:IdDecl Args:Exp* ;

StringWrapper ::= <STRING>;

abstract Clause;

abstract ElementList : Clause ::= Element*;
PublicElementList : ElementList ::=;
ProtectedElementList : ElementList ::=;
EquationClause : Clause::= AbstractEquation*;
AlgorithmClause : Clause ::= AbstractAlgorithm*;

abstract Element : Clause;
ElementAnnotation : Element ::= Annotation;
PN_ExtendsClause : Element ::= Super:Access [ClassModification] [Annotation];
ExtendsClause : Element ::= VisibilityType Super:Access [ClassModification] [Annotation];
abstract ImportClause : Element ::= PackageName:Access Comment;
ImportClauseQualified : ImportClause;
//ImportClauseSingleDefinition : ImportClause;
ImportClauseUnqualified : ImportClause;
ImportClauseRename : ImportClause ::= IdDecl;

abstract AbstractComponentDecl : Element;
UnknownComponentDecl : ComponentDecl;
abstract BaseComponentDecl : AbstractComponentDecl ::= [Redeclare] 
                                         [Final] 
                                         [Inner] 
                                         [Outer] 
                                         [Replaceable] 
                                         [TypePrefixFlow] 
                                         [TypePrefixOther] 
                                         [TypePrefixInputOutput] 
                                         ClassName:Access 
                                         [TypeArraySubscripts:ArraySubscripts];

ComponentClause : BaseComponentDecl ::=  VisibilityType 
                                         Name:PN_ComponentDecl* 
                                         [ConstrainingClause] 
                                         Comment;

ComponentDecl : BaseComponentDecl ::= VisibilityType 
                                      Name:IdDecl 
                                      [VarArraySubscripts:ArraySubscripts] 
                                      [Modification] 
                                      [ConditionalAttribute]
                                      Comment 
                                      [ConstrainingClause] 
                                      CCComment:Comment;

PN_ComponentClause : BaseComponentDecl ::=  Name:PN_ComponentDecl* 
                                            [ConstrainingClause] 
                                            Comment;
                                            
PN_ComponentDecl ::= Name:IdDecl 
                     [VarArraySubscripts:ArraySubscripts] 
                     [Modification] 
                     [ConditionalAttribute]
                     Comment;

abstract TypePrefix;
abstract TypePrefixFlow : TypePrefix;
Flow : TypePrefixFlow::=;
abstract TypePrefixOther : TypePrefix;
Discrete : TypePrefixOther::=;
Parameter : TypePrefixOther::=;
Constant : TypePrefixOther::=;
abstract TypePrefixInputOutput : TypePrefix;
Input : TypePrefixInputOutput::=;
Output : TypePrefixInputOutput::=;

Comment::= [StringComment] [Annotation];
StringComment ::= <Comment:String>;

// Annotations and modifications
Each ::=;
Final ::=;

ConditionalAttribute ::= Exp;

abstract Modification::=;
CompleteModification : Modification ::= ClassModification [ValueModification];
ValueModification : Modification ::= Exp;
//AssignModification : Modification ::= Exp;

ClassModification : Modification ::= Argument*;
abstract Argument : Modification ::= [Each] [Final];

abstract NamedModification : Argument ::= Name:Access;
abstract ElementModification : NamedModification ::= [Modification] [StringComment];
// ClassModification : ElementModification; // is a(M.x=3) valid if M is a class?
ComponentModification : ElementModification; 
abstract ElementRedeclare : NamedModification ::= [Replaceable] [ConstrainingClause];
ClassRedeclare : ElementRedeclare ::= BaseClassDecl;
ComponentRedeclare : ElementRedeclare ::= BaseComponentDecl;

Annotation ::= ClassModification;

abstract AbstractExp;
abstract Exp : AbstractExp;

abstract AbstractEquationModifier;
abstract AbstractEquation ::= [AbstractEquationModifier] Comment;
Initial : AbstractEquationModifier ::=;
Equation : AbstractEquation ::= Left:Exp Right:Exp;
EquationAnnotation : AbstractEquation ::= Annotation;
ConnectClause : AbstractEquation ::= Comment Connector1:Access Connector2:Access;
ConditionalEquationE : AbstractEquation ::= IfExp:Exp IfEqns:AbstractEquation*
                                          ElseIfClauseE*
                                          ElseEqns:AbstractEquation*;
ElseIfClauseE ::= IfExp:Exp IfEqns:AbstractEquation*;
ForClauseE : AbstractEquation ::= ForIndex* ForEqns:AbstractEquation*;
ForIndex ::= ForIndexDecl [Exp];
// ForIndexDecl is introduced basically to make the name-analysis simpler:
// lookupDecl is supposed to return a ComponentDecls.
ForIndexDecl : ComponentDecl; // Is this really ok: FIXME! 
WhenClauseE : AbstractEquation ::= WhenExp:Exp WhenEqns:AbstractEquation*
                                   ElseWhenClauseE*;
ElseWhenClauseE ::= WhenExp:Exp WhenEqns:AbstractEquation*;         
EquationFunctionCall : AbstractEquation ::= FunctionCall;
         
abstract AbstractAlgorithm ::= [Initial] Comment;
Algorithm : AbstractAlgorithm ::= Access Exp;
AlgorithmFunctionAssign : AbstractAlgorithm ::= OutputExpressionList FunctionCall;
AlgorithmFunctionCall : AbstractAlgorithm ::= FunctionCall;
AlgorithmBreak : AbstractAlgorithm ::=;
AlgorithmReturn : AbstractAlgorithm ::=;
AlgorithmAnnotation : AbstractAlgorithm ::= Annotation;
ConditionalEquationA : AbstractAlgorithm ::= IfExp:Exp IfEqns:AbstractAlgorithm*
                                          ElseIfClauseA*
                                          ElseEqns:AbstractAlgorithm*;
ElseIfClauseA ::= IfExp:Exp IfEqns:AbstractAlgorithm*;
ForClauseA : AbstractAlgorithm ::= ForIndex* ForAlgs:AbstractAlgorithm*;
WhenClauseA : AbstractAlgorithm ::= WhenExp:Exp WhenAlgs:AbstractAlgorithm*
                                   ElseWhenClauseA*;
ElseWhenClauseA ::= WhenExp:Exp WhenAlgs:AbstractAlgorithm*;   
WhileClause : AbstractAlgorithm ::= WhileExp:Exp WhileAlgs:AbstractAlgorithm*;

IfExp : Exp ::= IfExp:Exp ThenExp:Exp ElseIfExp* ElseExp:Exp;
ElseIfExp : Exp ::= IfExp:Exp ThenExp:Exp;

abstract BinExp : Exp::= Left:Exp Right:Exp;

abstract ArtmBinExp : BinExp::=;
AddExp : ArtmBinExp::=;
SubExp : ArtmBinExp::=;
MulExp : ArtmBinExp::=;
DivExp : ArtmBinExp::=;
PowExp : ArtmBinExp::=; // Easy to make parser take care of this: should be a Primary
NegExp : Exp::= Exp;

RealLitExp : Exp ::= <UNSIGNED_NUMBER>;
StringLitExp : Exp ::= <STRING>;
//BooleanLitExp : Exp ::= <Value:boolean>;
FunctionCall : Exp ::= Name:Access [FunctionArguments];

FunctionArguments ::= Exp* ForIndex* NamedArgument*;
NamedArgument ::= Name:Access Exp;

SumRedExp : Exp ::= Exp ForIndex;

RangeExp : Exp ::= Exp*;

abstract LogBinExp : BinExp;
LtExp : LogBinExp;
LeqExp : LogBinExp;
GtExp : LogBinExp;
GeqExp : LogBinExp;
EqExp : LogBinExp;
NeqExp : LogBinExp;
NotExp : Exp ::= Exp;
OrExp : LogBinExp;
AndExp : LogBinExp;

abstract BooleanLitExp : Exp ::=;
BooleanLitExpTrue : BooleanLitExp;
BooleanLitExpFalse : BooleanLitExp;

OutputExpressionList : Exp ::= Exp*;

IdDecl ::=<ID>;

AccessExp : Exp ::= Access;

abstract Access ::= <ID>;
Dot : Access ::= Left:Access Right:Access;

ParseAccess : Access ::= [ArraySubscripts];
ClassAccess : Access;
AmbiguousAccess : Access ::= [ArraySubscripts];

ComponentAccess : Access ::= [ArraySubscripts];
//PackageAccess : Access ::=;

ArrayConstructor : Exp ::= FunctionArguments;
Matrix : Exp ::= ExpList*;
ExpList : Exp ::= Exp*;

ArraySubscripts ::= Subscript*;
abstract Subscript;
ColonSubscript : Subscript::=;
ExpSubscript : Subscript ::= Exp;

TimeExp : Exp;

// Dummy node used in the compilation
PN_DummyClause : Clause ::=;


// Built in functions
abstract BuiltInFunctionExp : Exp ::=;
SizeExp : BuiltInFunctionExp ::= Access Dim:Exp;

QName ::= QNamePart*;
QNamePart ::= <Name> QNameSubscript*;
QNameSubscript ::= <Value:Integer>;

