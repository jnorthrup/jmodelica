<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Getting started</title>

  <para>The examples in JModelica.org uses the Python scientific library
  SciPy, which is dependent on NumPy and the mathematical plotting library
  matplotlib for plotting. These packages will thus also be used in some
  examples in this chapter. Most Python functions have built-in documentation,
  which can be accessed from the Python shell by invoking the help function,
  for example <literal>help(numpy.size)</literal>. Use this feature frequently
  to learn more about the packages used in this tutorial, including the
  jmodelica package. It is possible do the tutorials without any Python
  knowledge (although it helps to know the basics). </para>

        <para>The tutorials in this chapter are preferably run in a Python shell using the Pylab mode. If
        you are running Windows, select the menu option 'pylab' provided with the
        JModelica.org installation. If you are running Linux or Mac OS X, open
        a terminal and enter the command:</para>

        <programlisting language="python">&gt; $JMODELICA_HOME/Python/jm_ipython.sh -pylab
</programlisting>

        <para>As your first action, go to the working directory you have
        created:</para>

        <programlisting language="python">In [1]: cd '/path/to/working/directory'
</programlisting>

        <para>In order to run the Python script, use the 'run' command:</para>

        <programlisting language="python">in [2]: run cstr.py
</programlisting>

  <para>In most cases it is convenient to store the Python commands in a
  script file and run the script from the file by invoking the Python command
  run:</para>

  <programlisting>&gt;&gt;&gt; run my_script.py</programlisting>

  <para>or</para>

  <programlisting>&gt;&gt;&gt; run -i my_script.py</programlisting>

  <para>where the latter will render all variables to be accessible in the
  Python interpreter after termination of the script.</para>

  <section>
    <title>Compilation of models</title>

    <para>This tutorial covers how to compile Modelica and Optimica models
    into C and XML and how to load the resulting DLLs into Python.</para>

    <section>
      <title>Compilation</title>

      <para>There are two compilers available,
      <literal>ModelicaCompiler</literal> and
      <literal>OptimicaCompiler</literal>. Any model containing Optimica code
      has to be compiled with the <literal>OptimicaCompiler</literal>. This is
      the case with the CSTR model which will be used in the following
      examples.</para>

      <section>
        <title>Simple compilation example</title>

        <para>Compiling a model file can be done with just a few lines of
        code.</para>

        <section>
          <title>Instantiating the compiler</title>

          <para>First the <literal>OptimicaCompiler</literal> must be imported
          and instantiated. The compiler instance can then be used multiple
          times on different model files.</para>

          <programlisting language="python"># Import the compiler
from jmodelica.compiler import OptimicaCompiler

# Get an instance of OptimicaCompiler
oc = OptimicaCompiler()
</programlisting>
        </section>

        <section>
          <title>Options</title>

          <para>Compiler options are read from an XML file 'options.xml' which
          can be found in the JModelica.org installation folder. The options
          are loaded from the file as the compiler is instantiated. Options
          for a compiler instance can be modified and new options can be added
          interactively. There are four type categories: string, real, integer
          and boolean. The following example demonstrates how to get and set a
          string option.</para>

          <programlisting language="python"># Get the string option default_msl_version
oc.get_string_option('default_msl_version')
&gt;&gt; '3.0.1'

# Set the default_msl_version to 3.0.1
oc.set_string_option('default_msl_version','3.0.1')
</programlisting>
        </section>

        <section>
          <title>Compiling</title>

          <para>Compile a model, using the previously created compiler
          instance, with the method <literal>compile_model</literal> which
          takes a model name and a model file name as arguments. Once
          compilation has completed successfully a DLL file along with a few
          other files will have been created on the file system. The DLL file
          can then be loaded using the class jmi.Model. The result model
          object is used to interact with the JMI Model interface.
          <literal>compile_model</literal> does the DLL loading for you and
          will return with the jmi.Model model object as return
          argument.</para>

          <programlisting language="python"># Compile the model and get a jmi.Model as return argument
cstr_model = oc.compile_model('CSTR.CSTR_Opt', 'CSTR.mo')</programlisting>

          <para>If the compilation has failed an exception will be
          raised.</para>
        </section>
      </section>

      <section>
        <title>Targets</title>

        <para>The <literal>compile_model</literal> method takes an optional
        argument target which is '<literal>mode</literal>l' by default. There
        are three other options for this argument,
        '<literal>model_noad</literal>', '<literal>algorithm</literal>' and
        '<literal>ipopt</literal>'. It is necessary to compile with target
        '<literal>ipopt</literal>' to use the Ipopt algorithm interface for
        optimization.</para>

        <programlisting language="python"># Compile the model with support for Ipopt and get a jmi.Model as return argument
cstr_model = oc.compile_model('CSTR.CSTR_Opt', 'CSTR.mo', target='ipopt')
</programlisting>
      </section>

      <section>
        <title>Compilation in more detail</title>

        <para>Compiling with <literal>compile_model</literal> actually bundles
        a few steps required for the compilation which can be run one by one.
        These steps will be described briefly here, for more information on
        these steps, see the Architecture section in the Introduction.</para>

        <section>
          <title>Flattening</title>

          <para>In the first step, the model is transformed into a flat
          representation which can be used to generate C and XML code. Before
          this can be done the model must be parsed and instantiated. If there
          are errors in the model, for example syntax or type errors, Python
          exceptions will be thrown during these steps.</para>

          <programlisting language="python"># Parse the model and get a reference to the source root
source_root = oc.parse_model('CSTR.mo')

# Generate an instance tree representation and get a reference to the model instance
model_instance = oc.instantiate_model(source_root, 'CSTR.CSTR_Opt')

# Perform flattening and get a flat representation
flat_rep = oc.flatten_model(model_instance)
</programlisting>
        </section>

        <section>
          <title>Code generation</title>

          <para>The next step is the code generation which produces C code
          containing the model equations and a couple of XML files containing
          model meta data such as variable names and types.</para>

          <programlisting language="python"># Generate code
oc.generate_code(flat_rep)
</programlisting>

          <para>Several files are generated in this step.</para>
        </section>

        <section>
          <title>Generate Shared Object file (DLL)</title>

          <para>Finally, the DLL file is built where the C code is linked with
          the JModelica.org Model Interface (JMI) runtime library. The target
          argument must be set here if something other than the default
          'model' is wanted.</para>

          <programlisting># Compile DLL
oc.compile_dll('CSTR_CSTR_Opt', target='ipopt')
</programlisting>
        </section>

        <section>
          <title>Loading the Shared Object file (DLL)</title>

          <para>The DLL file is loaded using the class Model from which the
          JMI Model interface can be reached.</para>

          <programlisting># Import Model
from jmodelica.jmi import Model
# Load dll file and create Model object
model = Model('CSTR_CSTR_Opt')
</programlisting>

          <para>The model object can now be used to manipulate parameters and
          for optimization and simulation.</para>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Simulation of models</title>

    <section>
      <title>Simulation of an electrical circuit</title>

      <para>This example focus on how to use the high-level simulation
      functionality on a model of an electric circuit. The model is depicted
      in Figure (RLC.png) and consists of resistances, inductors and a
      capacitor. The circuit is connected to a voltage source which generates
      a square-wave with an amplitude of 1.0 and a frequency of 0.6 Hz. This
      model is written in Modelica code and saved in the file RLC_Circuit.mo
      and is depicted in below.<figure>
          <title>Electric Circuit</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/RLC.png" scalefit="1" width="60%"></imagedata>
            </imageobject>
          </mediaobject>
        </figure></para>

      <para>To use the functionality provided by the JModelica.org platform
      they first have to be imported into the Python script. So we start by
      importing the following:</para>

      <programlisting language="Python">from jmodelica import simulate
import pylab as P</programlisting>

      <para>The method 'simulate' is the high-level simulation method and the
      'pylab' package is used here for plotting.</para>

      <para>Next, we need to provide the 'simulate' method with information
      about which model we would like to simulate and where it is stored. We
      also need information about the simulation interval. The information is
      then passed down in the following way,</para>

      <programlisting>res_object = simulate(model='RLC_Circuit_Square', file_name='RLC_Circuit.mo',
                          alg_args={'start_time':0.0,'final_time':20.0,'num_communication_points':0})
</programlisting>

      <para>The return argument from 'simulate' is a result object where the
      simulation result can be retrieved using the method
      <literal>get_result_data</literal>. Here 'alg_args' are the arguments
      for the algorithm stored in a dictionary. The 'num_communication_points'
      represents the number of communication points stored by the algorithm.
      The default is 500 points and when set to zero (0), the internal steps
      calculated by the algorithm are stored. If the problem requires that the
      default options in the specific solver needs to be changed, they should
      be passed down in a dictionary called 'solver_args'. Typically these
      options can be the tolerances. Using the default simulation package,
      Assimulo, information regarding which algorithms are supported and the
      solver arguments can be found here, http://www.jmodelica.org/assimulo .
      The default solver is IDA and for a selection of the solver arguments to
      IDA, see the table below.</para>

      <table>
        <title>Selection of solver arguments for IDA</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Argument</entry>

              <entry align="center">Option</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>suppress_alg (Suppress the algebraic variables on the
              error test)</entry>

              <entry>Boolean flag</entry>
            </row>

            <row>
              <entry>initstep (The initial step-size)</entry>

              <entry>Positive float</entry>
            </row>

            <row>
              <entry>maxorder (The maximum order used)</entry>

              <entry>Integer of max 5</entry>
            </row>

            <row>
              <entry>maxh (Maximum step-size)</entry>

              <entry>Positive float</entry>
            </row>

            <row>
              <entry>atol (Absolute Tolerance)</entry>

              <entry>Array of floats or Float</entry>
            </row>

            <row>
              <entry>rtol (Relative Tolerance)</entry>

              <entry>Float</entry>
            </row>
          </tbody>
        </tgroup>
      </table>

      <para>After a successful simulation the statistics are printed in the
      prompt and the results are stored in the variable 'res'. To view the
      result, we have to retrieve information about the variables we are
      interested of. This is easily done in the following way,</para>

      <programlisting>res = res_object.get_result_data()
square_y = res.get_variable_data('square.y')
resistor_v = res.get_variable_data('resistor.v')
inductor1_i = res.get_variable_data('inductor1.i')    </programlisting>

      <para>And then plotted with the help from pylab,</para>

      <programlisting>P.plot(square_y.t, square_y.x, resistor_v.t, resistor_v.x, inductor1_i.t, inductor1_i.x)    
P.legend(('square.y','resistor.v','inductor1.i'))
P.show()</programlisting>

      <para>The simulation result is shown in the figure below:</para>

      <figure>
        <title>Simulation result</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Result_RLC.svg" scalefit="1"
                       width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation and parameter sweeps</title>

      <para>This tutorial demonstrates how to run multiple simulations with
      different parameter values. Sweeping parameters is a useful technique
      for analysing model sensitivity with respect to uncertainty in physical
      parameters or initial conditions. Consider the following model of the
      Van der Pol oscillator:</para>

      <programlisting>  model VDP
    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0);
    Real x2(start = x2_0);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
  end VDP;</programlisting>

      <para>Notice that the initial values of the states are parametrized by
      the parameters <literal>x1_0</literal> and <literal>x2_0</literal>.
      Next, copy the Modelica code above into a file VDP.mo and save it in
      your working directory. Also, create a Python script file and name it
      vdp_pp.py. Start by copying the commands:</para>

      <programlisting>import numpy as N
import pylab as p
from jmodelica.compiler import ModelicaCompiler
from jmodelica import simulate</programlisting>

      <para>into the Python file. Compile and load the model:</para>

      <programlisting># Define model file name and class name
model_name = 'VDP'
mofile = 'VDP.mo'

# Create a Modelica compiler
mc = ModelicaCompiler()

# Compile and load model
model = mc.compile_model(model_name,mofile,target='ipopt')</programlisting>

      <para>Next, we define the initial conditions for which the parameter
      sweep will be done. The state <literal>x2</literal> starts at 0, whereas
      the initial condition for <literal>x1</literal> is swept between -3 and
      3:</para>

      <programlisting># Define initial conditions
N_points = 11
x1_0 = N.linspace(-3.,3.,N_points)
x2_0 = N.zeros(N_points)</programlisting>

      <para>In order to visualize the results of the simulations, we open a
      plot window:</para>

      <programlisting>fig = p.figure()
p.clf()
p.hold(True)
p.xlabel('x1')
p.ylabel('x2')</programlisting>

      <para>The actual parameter sweep is done by looping over the initial
      condition vectors and in each iteration set the parameter values into
      the model, simulate and plot:</para>

      <programlisting>for i in range(N_points):
    # Set initial conditions in model
    model.set_value('x1_0',x1_0[i])
    model.set_value('x2_0',x2_0[i])
    # Simulate 
    sim_res = simulate(model,alg_args={'final_time':20})
    # Get simulation result
    res = sim_res.result_data
    x1=res.get_variable_data('x1')
    x2=res.get_variable_data('x2')
    # Plot simulation result in phase plane plot
    p.plot(x1.x, x2.x,'b')
p.grid()
p.show()</programlisting>

      <para>You should now see the following plot:</para>

      <figure>
        <title>Simulation result-phase plane</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/vdp_pp.png" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>

  <section>
    <title>Solving optimal control problems</title>

    <section>
      <title>The van der Pol Oscillator</title>

      <para>We consider the following Optimica model:</para>

      <programlisting>optimization VDP_Opt (objective = cost(finalTime),
                      startTime = 0,
                      finalTime = 20)

  // The states
  Real x1(start=0,fixed=true);
  Real x2(start=1,fixed=true);

  // The control signal
  input Real u;

  Real cost(start=0,fixed=true);

equation
  der(x1) = (1 - x2^2) * x1 - x2 + u;
  der(x2) = x1;
  der(cost) = x1^2 + x2^2 + u^2;
constraint 
   u&lt;=0.75;
end VDP_Opt;
</programlisting>

      <para>Create a new file named VDP_Opt.mo and save it in you working
      directory. Next, create a Python script file and a write (or copy paste)
      the following commands:</para>

      <programlisting language="python"># Import the optimize function
from jmodelica import optimize

# Import the plotting library
import matplotlib.pyplot as plt</programlisting>

      <para>Next, we call the 'optimize' function which encapsulates
      operations for compiling, loading, executing the optimization algorithm,
      and loading the result from file:</para>

      <programlisting language="python">res_object = optimize("VDP_Opt", "VDP_Opt.mo")</programlisting>

      <para>In this case, we use the default settings for the optimization
      algorithm and provide only the name of the Optimica class (the first
      argument) and the name of the file (VDP.mo). The return object is a
      result object which contains a reference to a jmodelica.Model object
      representing the compiled model and also the optimization result. To
      access the optimization result and the optimal trajectories:</para>

      <programlisting language="python">res = res_object.get_result_data() #Get the result data
x1=res.get_variable_data('x1')
x2=res.get_variable_data('x2')
u=res.get_variable_data('u')</programlisting>

      <para>The return arguments are objects of the Python class
      jmodelica.io.Trajectory, which has two fields: 't' which represents the
      time vector and 'x' which represents the trajectory vector. t and x are
      both numpy arrays of the same length. Using the matplotlib package, we
      can visualize the optimization result:</para>

      <programlisting language="python">plt.figure(1)
plt.clf()
plt.subplot(311)
plt.plot(x1.t,x1.x)
plt.grid()
plt.ylabel('x1')
        
plt.subplot(312)
plt.plot(x2.t,x2.x)
plt.grid()
plt.ylabel('x2')
        
plt.subplot(313)
plt.plot(u.t,u.x)
plt.grid()
plt.ylabel('u')plt.xlabel('time')
plt.show()</programlisting>

      <para>You should now see the optimization result as shown below.</para>

      <figure>
        <title>Van der Pol optimization result.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/vdp.svg" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>The Hicks Ray Continuously Stirred Reactor (CSTR)</title>

      <para>This example is based on the Hicks-Ray Continuously Stirred Tank
      Reactors (CSTR) system. The model was originally presented in [1]. The
      system has two states, the concentration, c, and the temperature, T. The
      control input to the system is the temperature, Tc, of the cooling flow
      in the reactor jacket. The chemical reaction in the reactor is
      exothermic, and also temperature dependent; high temperature results in
      high reaction rate. The CSTR dynamics is given by:</para>

      <informalequation>
        <m:math display="block" overflow="scroll">
          <m:mtable>
            <m:mtr>
              <m:mtd columnalign="right">
                <m:mover>
                  <m:mi>c</m:mi>

                  <m:mo>.</m:mo>
                </m:mover>

                <m:mfenced>
                  <m:mi>t</m:mi>
                </m:mfenced>
              </m:mtd>

              <m:mtd columnalign="left">
                <m:mo>=</m:mo>

                <m:mfrac>
                  <m:mrow>
                    <m:msub>
                      <m:mi>F</m:mi>

                      <m:mn>0</m:mn>
                    </m:msub>

                    <m:mfenced separators="">
                      <m:msub>
                        <m:mi>c</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mo>-</m:mo>

                      <m:mi>c</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mfenced>
                  </m:mrow>

                  <m:mi>V</m:mi>
                </m:mfrac>

                <m:mo>-</m:mo>

                <m:msub>
                  <m:mi>k</m:mi>

                  <m:mn>0</m:mn>
                </m:msub>

                <m:mi>c</m:mi>

                <m:mo>⁡</m:mo>

                <m:mfenced>
                  <m:mi>t</m:mi>
                </m:mfenced>

                <m:msup>
                  <m:mi>e</m:mi>

                  <m:mrow>
                    <m:mo>-</m:mo>

                    <m:mi>EdivR</m:mi>

                    <m:mo>/</m:mo>

                    <m:mi>T</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:msup>
              </m:mtd>
            </m:mtr>

            <m:mtr>
              <m:mtd columnalign="right">
                <m:mover>
                  <m:mi>T</m:mi>

                  <m:mo>.</m:mo>
                </m:mover>

                <m:mfenced>
                  <m:mi>t</m:mi>
                </m:mfenced>
              </m:mtd>

              <m:mtd columnalign="left">
                <m:mo>=</m:mo>

                <m:mfrac>
                  <m:mrow>
                    <m:msub>
                      <m:mi>F</m:mi>

                      <m:mn>0</m:mn>
                    </m:msub>

                    <m:mfenced separators="">
                      <m:msub>
                        <m:mi>T</m:mi>

                        <m:mn>0</m:mn>
                      </m:msub>

                      <m:mo>-</m:mo>

                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mfenced>
                  </m:mrow>

                  <m:mi>V</m:mi>
                </m:mfrac>

                <m:mo>-</m:mo>

                <m:mfrac>
                  <m:mrow>
                    <m:mrow>
                      <m:mi>d</m:mi>

                      <m:mi>H</m:mi>
                    </m:mrow>

                    <m:msub>
                      <m:mi>k</m:mi>

                      <m:mn>0</m:mn>
                    </m:msub>

                    <m:mi>c</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>
                  </m:mrow>

                  <m:mrow>
                    <m:mi>ρ</m:mi>

                    <m:msub>
                      <m:mi>C</m:mi>

                      <m:mi>p</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:mfrac>

                <m:msup>
                  <m:mi>e</m:mi>

                  <m:mrow>
                    <m:mo>-</m:mo>

                    <m:mi>EdivR</m:mi>

                    <m:mo>/</m:mo>

                    <m:mi>T</m:mi>

                    <m:mo>⁡</m:mo>

                    <m:mfenced>
                      <m:mi>t</m:mi>
                    </m:mfenced>
                  </m:mrow>
                </m:msup>

                <m:mo>+</m:mo>

                <m:mfrac>
                  <m:mrow>
                    <m:mn>2</m:mn>

                    <m:mi>U</m:mi>
                  </m:mrow>

                  <m:mrow>
                    <m:mi>r</m:mi>

                    <m:mi>ρ</m:mi>

                    <m:msub>
                      <m:mi>C</m:mi>

                      <m:mi>p</m:mi>
                    </m:msub>
                  </m:mrow>
                </m:mfrac>

                <m:mfenced separators="">
                  <m:mrow>
                    <m:mi>T</m:mi>

                    <m:mi>c</m:mi>
                  </m:mrow>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>

                  <m:mo>-</m:mo>

                  <m:mi>T</m:mi>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>
                </m:mfenced>
              </m:mtd>
            </m:mtr>
          </m:mtable>

          <m:mspace linebreak="newline" />
        </m:math>
      </informalequation>

      <para>This tutorial will cover the following topics:</para>

      <itemizedlist>
        <listitem>
          <para>How to solve a DAE initialization problem. The initialization
          model have equations specifying that all derivatives should be
          identically zero, which implies that a stationary solution is
          obtained. Two stationary points, corresponding to different inputs,
          are computed. We call the stationary points A and B respectively.
          Point A corresponds to operating conditions where the reactor is
          cold and the reaction rate is low, whereas point B corresponds to a
          higher temperature where the reaction rate is high. For more
          information about the DAE initialization algorithm, see the JMI API
          documentation.</para>
        </listitem>

        <listitem>
          <para>An optimal control problem is solved where the objective is to
          transfer the state of the system from stationary point A to point B.
          The challenge is to ignite the reactor while avoiding uncontrolled
          temperature increase. It is also demonstrated how to set parameter
          and variable values in a model. More information about the
          simultaneous optimization algorithm can be found at JModelica.org
          API documentation.</para>
        </listitem>

        <listitem>
          <para>The optimization result is saved to file and then the
          important variables are plotted.</para>
        </listitem>
      </itemizedlist>

      <para>The Python commands in this tutorial may be copied and pasted
      directely into a Python shell, in some cases with minor modifications.
      Alternatively, you may copy the commands into a text file, e.g.,
      cstr.py.</para>

      <para>Start the tutorial by creating a working directory and copy the
      file $JMODELICA_HOME/Python/jmodelica/examples/files/CSTR.mo to your
      working directory. An on-line version of <link
      xlink:href="https://svn.jmodelica.org/trunk/Python/src/jmodelica/examples/files/CSTR.mo">CSTR.mo</link>
      is also available (depending on which browser you use, you may have to
      accept the site certificate by clicking through a few steps). If you
      choose to create Python script file, save it to the working
      directory.</para>


      <section>
        <title>Compile and instantiate a model object</title>

        <para>The functions and classes used in the tutorial script need to be
        imported into the Python script. This is done by the following Python
        commands. Copy them and past them either directly into you Python
        shell or, preferably, into your Python script file.</para>

        <programlisting language="python">import os.path
from jmodelica import initialize
from jmodelica import simulate
from jmodelica import optimize

import jmodelica.jmi as jmi
from jmodelica.compiler import OptimicaCompiler

import numpy as N
import matplotlib.pyplot as plt
</programlisting>

        <para>Before we can do operations on the model, such as optimizing it,
        the model file must be compiled and the resulting DLL file loaded in
        Python. These steps are described in more detail in the tutorial on
        Compilation of models.</para>

        <programlisting language="python"># Create a Modelica compiler instance
oc = OptimicaCompiler()
    
# Compile the stationary initialization model into a DLL and load it
init_model = oc.compile_model("CSTR.CSTR_Init", "CSTR.mo", target='ipopt')
</programlisting>

        <para>At this point, you may open the file CSTR.mo, containing the
        CSTR model and the static initialization model used in this section.
        Study the classes CSTR.CSTR and CSTR.CSTR_Init and make sure you
        understand the models. Before proceeding, have a look at the
        interactive help for one of the functions you used:</para>

        <programlisting language="python">In [8]: help(oc.compile_model)
</programlisting>
      </section>

      <section>
        <title>Solve the DAE initialization problem</title>

        <para>In the next step, we would like to specify the first operating
        point, A, by means of a constant input cooling temperature, and then
        solve the initialization problem assuming that all derivatives are
        zero.</para>

        <programlisting language="python"># Set inputs for Stationary point A
Tc_0_A = 250
init_model.set_value('Tc',Tc_0_A)
    
# Solve the DAE initialization system with Ipopt
init_result_object = initialize(init_model)
init_result = init_result_object.get_result_data()
    
# Store stationary point A
c_0_A = init_result.get_variable_data('c').x[0]
T_0_A = init_result.get_variable_data('T').x[0]

# Print some data for stationary point A 
print(' *** Stationary point A ***') 
print('input Tc = %f' % Tc_0_A) 
print('state c = %f' % c_0_A) 
print('state T = %f' % T_0_A)
</programlisting>

        <para>Notice how the function set_value is used to set the value of
        the control input. The initialization algorithm is invoked by calling
        the function 'initialize', which returns a result object where the
        initialization result is accessed with 'get_result_data' and stored in
        'init_result'. The 'initialize' function relies on the algorithm Ipopt
        for computing the solution of the initialization problem. The values
        of the states corresponding to grade A can then be extracted from the
        result object. Look carefully at the printouts in the Python shell to
        see a printout of the stationary values. Display the help text for the
        'initialize' function and take a moment to look through it. The
        procedure is now repeated for operating point B:</para>

        <programlisting language="python"># Set inputs for Stationary point B
Tc_0_B = 280
init_model.set_value('Tc',Tc_0_B)
        
# Solve the DAE initialization system with Ipopt
init_result_object = initialize(init_model)
init_result = init_result_object.get_result_data()
    
# Store stationary point B
c_0_B = init_result.get_variable_data('c').x[0]
T_0_B = init_result.get_variable_data('T').x[0]

# Print some data for stationary point B 
print(' *** Stationary point B ***') 
print('input Tc = %f' % Tc_0_B) 
print('state c = %f' % c_0_B) 
print('state T = %f' % T_0_B)
</programlisting>

        <para>We have now computed two stationary points for the system based
        on constant control inputs.</para>
      </section>

      <section>
        <title>Solving an optimal control problem</title>

        <para>The optimal control problem we are about to solve is given
        by:</para>

        <informalequation>
          <m:math display="block" overflow="scroll">
            <m:mtable>
              <m:mtr>
                <m:mtd columnalign="right"></m:mtd>

                <m:mtd columnalign="left">
                  <m:msub>
                    <m:mi mathvariant="normal">min</m:mi>

                    <m:mrow>
                      <m:mi>u</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mrow>
                  </m:msub>

                  <m:munderover>
                    <m:mo>∫</m:mo>

                    <m:mn>0</m:mn>

                    <m:mn>150</m:mn>
                  </m:munderover>

                  <m:msup>
                    <m:mfenced close=")" open="(" separators="">
                      <m:msup>
                        <m:mi>c</m:mi>

                        <m:mrow>
                          <m:mi>r</m:mi>

                          <m:mi>e</m:mi>

                          <m:mi>f</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mo>-</m:mo>

                      <m:mi>c</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mfenced>

                    <m:mn>2</m:mn>
                  </m:msup>

                  <m:mo>+</m:mo>

                  <m:msup>
                    <m:mfenced close=")" open="(" separators="">
                      <m:msup>
                        <m:mi>T</m:mi>

                        <m:mrow>
                          <m:mi>r</m:mi>

                          <m:mi>e</m:mi>

                          <m:mi>f</m:mi>
                        </m:mrow>
                      </m:msup>

                      <m:mo>-</m:mo>

                      <m:mi>T</m:mi>

                      <m:mo>⁡</m:mo>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mfenced>

                    <m:mn>2</m:mn>
                  </m:msup>

                  <m:mo>+</m:mo>

                  <m:msup>
                    <m:mfenced close=")" open="(" separators="">
                      <m:msubsup>
                        <m:mi>T</m:mi>

                        <m:mi>c</m:mi>

                        <m:mrow>
                          <m:mi>r</m:mi>

                          <m:mi>e</m:mi>

                          <m:mi>f</m:mi>
                        </m:mrow>
                      </m:msubsup>

                      <m:mo>-</m:mo>

                      <m:msub>
                        <m:mi>T</m:mi>

                        <m:mi>c</m:mi>
                      </m:msub>

                      <m:mfenced>
                        <m:mi>t</m:mi>
                      </m:mfenced>
                    </m:mfenced>

                    <m:mn>2</m:mn>
                  </m:msup>

                  <m:mrow>
                    <m:mi>d</m:mi>

                    <m:mi>t</m:mi>
                  </m:mrow>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right"></m:mtd>

                <m:mtd columnalign="left">
                  <m:mstyle mathvariant="normal">
                    <m:mi>subject</m:mi>

                    <m:mo> </m:mo>

                    <m:mo> </m:mo>

                    <m:mi>to</m:mi>
                  </m:mstyle>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right"></m:mtd>

                <m:mtd columnalign="left">
                  <m:mn>230</m:mn>

                  <m:mo>≤</m:mo>

                  <m:mi>u</m:mi>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>

                  <m:mo>≤</m:mo>

                  <m:mn>370</m:mn>
                </m:mtd>
              </m:mtr>

              <m:mtr>
                <m:mtd columnalign="right"></m:mtd>

                <m:mtd columnalign="left">
                  <m:mi>T</m:mi>

                  <m:mo>⁡</m:mo>

                  <m:mfenced>
                    <m:mi>t</m:mi>
                  </m:mfenced>

                  <m:mo>≤</m:mo>

                  <m:mn>350</m:mn>
                </m:mtd>
              </m:mtr>
            </m:mtable>

            <m:mspace linebreak="newline" />
          </m:math>
        </informalequation>

        <para>and is expressed in Optimica format in the class CSTR.CSTR_Opt
        in the CSTR.mo file above. Have a look at this class and make sure
        that you understand how the optimization problem is formulated and
        what the objective is.</para>

        <para>Direct collocation methods often require good initial guesses in
        order to ensure robust convergence. Since initial guesses are needed
        for all discretized variables along the optimization interval,
        simulation provides a convenient mean to generate state and derivative
        profiles given an initial guess for the control input(s). It is then
        convenient to set up a dedicated model for computation of initial
        trajectories. In the model CSTR.CSTR_Init_Optimization in the CSTR.mo
        file, a step input is filtered through a first order filter in order
        to generate a smooth input for the CSTR system. The filtering is done
        in order not to excite unstable modes of the system, and in particular
        to avoid sudden ignition. Notice also that the variable names in the
        initialization model must match those in the optimal control model.
        Therefore, also the cost function is included in the initialization
        model.</para>

        <para>Start by creating an input trajectory to be passed to the
        simulator:</para>

        <programlisting language="python"># Create the time vector
t = N.linspace(1,150.,100)
# Create the input vector from the target input value. The
# target input value is here increased in order to get a
# better initial guess.
u = (Tc_0_B+35)*N.ones(N.size(t,0))
# Create a matrix where the first column is time and the second column represents
# the input trajectory.
u_traj = N.transpose(N.vstack((t,u)))
</programlisting>

        <para>Next, compile the model and set model parameters:</para>

        <programlisting language="python"># Compile the optimization initialization model and load the DLL
init_sim_model = oc.compile_model("CSTR.CSTR_Init_Optimization", "CSTR.mo", target='ipopt')

# Set model parameters
init_sim_model.set_value('cstr.c_init',c_0_A)
init_sim_model.set_value('cstr.T_init',T_0_A)
init_sim_model.set_value('Tc_0',Tc_0_A)
init_sim_model.set_value('c_ref',c_0_B)
init_sim_model.set_value('T_ref',T_0_B)
init_sim_model.set_value('Tc_ref',u[0])
</programlisting>

        <para>Having initialized the model parameters, we can simulate the
        model using the 'simulate' function.</para>

        <programlisting language="python">sim_result_object = simulate(init_sim_model,alg_args={'start_time':0.,'final_time':150.,
                                                         'input_trajectory':u_traj})
res = sim_result_object.get_result_data()
</programlisting>

        <para>The function 'simulation' first computes consistent initial
        conditions and then simulates the model in the interval 0 to 150
        seconds with the input trajectory specified by 'u_traj'. Notice that
        the arguments to the simulation function is specified in a Python
        dictionary. Take a moment to read the interactive help for the
        'simulate' function.</para>

        <para>The simulation result object is returned and to retrieve the
        simulation data use the method 'get_result_data', from which you may
        now retrieve trajectories for plotting:</para>

        <programlisting language="python"># Extract variable profiles
c_init_sim=res.get_variable_data('cstr.c')
T_init_sim=res.get_variable_data('cstr.T')
Tc_init_sim=res.get_variable_data('cstr.Tc')

# Plot the results
plt.figure(1)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(c_init_sim.t,c_init_sim.x)
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(T_init_sim.t,T_init_sim.x)
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(Tc_init_sim.t,Tc_init_sim.x)
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

        <para>Look at the plots and make sure you understand the effect of the
        filter. Think about alternative, better ways to chose the input
        profile. Also, try to increase the value 35 that was added to the
        target input: how much can you increase this value without
        experiencing sudden ignition of the reactor?</para>

        <para>Once the initial guess is generated, we compile the model
        containing the optimal control problem:</para>

        <programlisting language="python">cstr = oc.compile_model("CSTR.CSTR_Opt", "CSTR.mo", target='ipopt')</programlisting>

        <para>We will now initialize the parameters of the model so that their
        values correspond to the optimization objective of transferring the
        system state from operating point A to operating point B. Accordingly,
        we set the parameters representing the initial values of the states to
        point A and the reference values in the cost function to point
        B:</para>

        <programlisting language="python">cstr.set_value('Tc_ref',Tc_0_B)
cstr.set_value('c_ref',c_0_B)
cstr.set_value('T_ref',T_0_B)

cstr.set_value('cstr.c_init',c_0_A)
cstr.set_value('cstr.T_init',T_0_A)
</programlisting>

        <para>In order to solve the optimization problem, we need to specify
        the mesh on which the optimization is performed. The simultaneous
        optimization algorithm is based on a collocation method that
        corresponds to a fixed step implicit Runge-Kutta scheme, where the
        mesh defines the length of each step. Also, the number of collocation
        points in each element, or step, needs to be provided. This number
        corresponds to the stage order of the Runge-Kutta scheme. The
        selection of mesh is analogous to the choice of step length in a
        one-step algorithm for solving differential equations. Accordingly,
        the mesh needs to be fine-grained enough to ensure sufficiently
        accurate approximation of the differential constraint. For an overview
        of simultaneous optimization algorithms, see [2].</para>

        <para>Collocation-based optimization algorithms often require a good
        initial guess in order to achieve fast convergence. Also, if the
        problem is non-convex, initialization is even more critical. Initial
        guesses can be provided in Optimica by the 'initialGuess' attribute,
        see the CSTR.mo file for an example for this. Notice that
        initialization in the case of collocation-based optimization methods
        means initialization of all the control and state profiles as a
        function of time. In some cases, it is sufficient to use constant
        profiles. For this purpose, the 'initialGuess' attribute works well.
        In more difficult cases, however, it may be necessary to initialize
        the profiles using simulation data, where an initial guess for the
        input(s) has been used to generate the profiles for the dependent
        variables. This approach for initializing the optimization problem is
        used in this tutorial.</para>

        <para>We are now ready to solve the actual optimization problem. This
        is done by invoking the method optimize:</para>

        <programlisting language="python"># Initialize the mesh
n_e = 100 # Number of elements 
hs = N.ones(n_e)*1./n_e # Equidistant points
n_cp = 3; # Number of collocation points in each element

opt_result_object = optimize(cstr,alg_args={'n_e':n_e,'hs':hs,'n_cp':n_cp,'init_traj':res})
res = opt_result_object.get_result_data()
</programlisting>

        <para>You should see the output of Ipopt in the Python shell as the
        algorithm iterates to find the optimal solution. Ipopt should
        terminate with a message like 'Optimal solution found' or 'Solved to
        an acceptable level' in order for an optimum to be found. Again, the
        arguments to the algorithm (number of elements, number of collocation
        points, element length vector and initial guess object) are given in a
        Python dictionary. The optimization result object is returned and the
        optimization data are stored in 'res'.</para>

        <para>We can now retrieve the trajectories of the variables that we
        intend to plot:</para>

        <programlisting language="python"># Extract variable profiles
c_res=res.get_variable_data('cstr.c')
T_res=res.get_variable_data('cstr.T')
Tc_res=res.get_variable_data('cstr.Tc')

c_ref=res.get_variable_data('c_ref') 
T_ref=res.get_variable_data('T_ref')
Tc_ref=res.get_variable_data('Tc_ref')
</programlisting>

        <para>Finally, we plot the result using the functions available in
        matplotlib:</para>

        <programlisting language="python">plt.figure(1)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(c_res.t,c_res.x)
plt.plot(c_ref.t,c_ref.x,'--')
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(T_res.t,T_res.x)
plt.plot(T_ref.t,T_ref.x,'--')
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(Tc_res.t,Tc_res.x)
plt.plot(Tc_ref.t,Tc_ref.x,'--')
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

        <para>Your should now see a plot as the one below:</para>

        <figure>
          <title>Optimization result</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/cstr.svg" scalefit="1" width="60%"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Take a minute to analyze the optimal profiles and to answer the
        following questions:</para>

        <orderedlist>
          <listitem>
            <para>Why is the concentration high in the beginning of the
            interval?</para>
          </listitem>

          <listitem>
            <para>Why is the input cooling temperature high in the beginning
            of the interval?</para>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>Verify optimal control solution</title>

        <para>Solving optimal control problems by means of direct collocation
        implies that the differential equation is approximated by a discrete
        time counterpart. The accuracy of the solution is dependent on the
        method of collocation and the number of elements. In order to assess
        the accuracy of the discretization, we may simulate the system using a
        DAE solver using the optimal control profile as input. With this
        approach, the state profiles are computed with high accuracy and the
        result may then be compared with the profiles resulting from
        optimization. Notice that this procedure does not verify the
        optimality of the resulting optimal control profiles, but only the
        accuracy of the discretization of the dynamics.</para>

        <para>The procedure for setting up and executing this simulation is
        similar to above:</para>

        <programlisting language="python"># Simulate to verify the optimal solution
# Set up input trajectory
t = Tc_res.t 
u = Tc_res.x
u_traj = N.transpose(N.vstack((t,u)))
    
# Comile the Modelica model first to C code and
# then to a dynamic library
sim_model = oc.compile_model("CSTR.CSTR","CSTR.mo",target='ipopt')

sim_model.set_value('c_init',c_0_A)
sim_model.set_value('T_init',T_0_A)
sim_model.set_value('Tc',u[0])

sim_result_object = simulate(sim_model,compiler='optimica',
                           alg_args={'start_time':0.,'final_time':150.,
                                     'input_trajectory':u_traj})
res = sim_result_object.get_result_data()
</programlisting>

        <para>Finally, we load the simulated data and plot it to compare with
        the optimized trajectories:</para>

        <programlisting language="python"># Extract variable profiles
c_sim=res.get_variable_data('c')
T_sim=res.get_variable_data('T')
Tc_sim=res.get_variable_data('Tc')

# Plot the results
plt.figure(3)
plt.clf()
plt.hold(True)
plt.subplot(311)
plt.plot(c_res.t,c_res.x,'--')
plt.plot(c_sim.t,c_sim.x)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Concentration')

plt.subplot(312)
plt.plot(T_res.t,T_res.x,'--')
plt.plot(T_sim.t,T_sim.x)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Temperature')

plt.subplot(313)
plt.plot(Tc_res.t,Tc_res.x,'--')
plt.plot(Tc_sim.t,Tc_sim.x)
plt.legend(('optimized','simulated'))
plt.grid()
plt.ylabel('Cooling temperature')
plt.xlabel('time')
plt.show()
</programlisting>

        <para>You should now see a plot similar to:</para>

        <figure>
          <title>Simulated system response</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/cstr_opt_cmp.svg" scalefit="1"
                         width="60%"></imagedata>
            </imageobject>
          </mediaobject>
        </figure>

        <para>Discuss why the simulated trajectories differs from the
        optimized counterparts.</para>
      </section>

      <section>
        <title>Exercises</title>

        <para>After completing the tutorial you may continue to modify the
        optimization problem and study the results.</para>

        <orderedlist>
          <listitem>
            <para>Remove the constraint on cstr.T. What is then the maximum
            temperature?</para>
          </listitem>

          <listitem>
            <para>Play around with weights in the cost function. What happens
            if you penalize the control variable with a larger weight? Do a
            parameter sweep for the control variable weight and plot the
            optimal profiles in the same figure.</para>
          </listitem>

          <listitem>
            <para>Add terminal constraints ('cstr.T(finalTime)=someParameter')
            for the states so that they are equal to point B at the end of the
            optimization interval. Now reduce the length of the optimization
            interval. How short can you make the interval?</para>
          </listitem>

          <listitem>
            <para>Try varying the number of elements in the mesh and the
            number of collocation points in each interval. 2-10 collocation
            points are supported.</para>
          </listitem>
        </orderedlist>
      </section>

      <section>
        <title>References</title>

        <para>[1] G.A. Hicks and W.H. Ray. Approximation Methods for Optimal
        Control Synthesis. <emphasis>Can. J. Chem. Eng</emphasis>.,
        40:522–529, 1971.</para>

        <para>[2] Bieger, L., A. Cervantes, and A. Wächter (2002): "Advances
        in simultaneous strategies for dynamic optimization."
        <emphasis>Chemical Engineering Science</emphasis>, <emphasis
        role="bold">57</emphasis>, pp. 575-593.</para>
      </section>
    </section>
  </section>

  <section>
    <title>Solving parameter estimation problems</title>

    <para>In this tutorial it will be demonstrated how to solve parameter
    estimation problems. We consider a quadruple tank system depicted in
    Figure below.</para>

    <figure>
      <title>A schematic figure of the quadruple tank process.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/qt_schematic.png" scalefit="1"
                     width="60%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The dynamics of the system is given by the differential
    equations:</para>

    <informalequation>
      <m:math display="block" overflow="scroll">
        <m:mtable>
          <m:mtr>
            <m:mtd columnalign="right">
              <m:msub>
                <m:mover>
                  <m:mi>x</m:mi>

                  <m:mo>.</m:mo>
                </m:mover>

                <m:mn>1</m:mn>
              </m:msub>
            </m:mtd>

            <m:mtd columnalign="left">
              <m:mo>=</m:mo>

              <m:mo>-</m:mo>

              <m:mfrac>
                <m:msub>
                  <m:mi>a</m:mi>

                  <m:mn>1</m:mn>
                </m:msub>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>2</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msqrt>
                <m:mrow>
                  <m:mn>2</m:mn>

                  <m:mi>g</m:mi>
                </m:mrow>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mn>1</m:mn>
                </m:msub>
              </m:msqrt>

              <m:mo>+</m:mo>

              <m:mfrac>
                <m:msub>
                  <m:mi>a</m:mi>

                  <m:mn>3</m:mn>
                </m:msub>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>1</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msqrt>
                <m:mrow>
                  <m:mn>2</m:mn>

                  <m:mi>g</m:mi>
                </m:mrow>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mn>3</m:mn>
                </m:msub>
              </m:msqrt>

              <m:mo>+</m:mo>

              <m:mfrac>
                <m:mrow>
                  <m:msub>
                    <m:mi>γ</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>

                  <m:msub>
                    <m:mi>k</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mrow>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>1</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msub>
                <m:mi>u</m:mi>

                <m:mn>1</m:mn>
              </m:msub>
            </m:mtd>
          </m:mtr>

          <m:mtr>
            <m:mtd columnalign="right">
              <m:msub>
                <m:mover>
                  <m:mi>x</m:mi>

                  <m:mo>.</m:mo>
                </m:mover>

                <m:mn>2</m:mn>
              </m:msub>
            </m:mtd>

            <m:mtd columnalign="left">
              <m:mo>=</m:mo>

              <m:mo>-</m:mo>

              <m:mfrac>
                <m:msub>
                  <m:mi>a</m:mi>

                  <m:mn>2</m:mn>
                </m:msub>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>2</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msqrt>
                <m:mrow>
                  <m:mn>2</m:mn>

                  <m:mi>g</m:mi>
                </m:mrow>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mn>2</m:mn>
                </m:msub>
              </m:msqrt>

              <m:mo>+</m:mo>

              <m:mfrac>
                <m:msub>
                  <m:mi>a</m:mi>

                  <m:mn>4</m:mn>
                </m:msub>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>2</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msqrt>
                <m:mrow>
                  <m:mn>2</m:mn>

                  <m:mi>g</m:mi>
                </m:mrow>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mn>4</m:mn>
                </m:msub>
              </m:msqrt>

              <m:mo>+</m:mo>

              <m:mfrac>
                <m:mrow>
                  <m:msub>
                    <m:mi>γ</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>

                  <m:msub>
                    <m:mi>k</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>
                </m:mrow>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>2</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msub>
                <m:mi>u</m:mi>

                <m:mn>2</m:mn>
              </m:msub>
            </m:mtd>
          </m:mtr>

          <m:mtr>
            <m:mtd columnalign="right">
              <m:msub>
                <m:mover>
                  <m:mi>x</m:mi>

                  <m:mo>.</m:mo>
                </m:mover>

                <m:mn>3</m:mn>
              </m:msub>
            </m:mtd>

            <m:mtd columnalign="left">
              <m:mo>=</m:mo>

              <m:mo>-</m:mo>

              <m:mfrac>
                <m:msub>
                  <m:mi>a</m:mi>

                  <m:mn>3</m:mn>
                </m:msub>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>3</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msqrt>
                <m:mrow>
                  <m:mn>2</m:mn>

                  <m:mi>g</m:mi>
                </m:mrow>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mn>3</m:mn>
                </m:msub>
              </m:msqrt>

              <m:mo>+</m:mo>

              <m:mfrac>
                <m:mrow>
                  <m:mfenced separators="">
                    <m:mn>1</m:mn>

                    <m:mo>-</m:mo>

                    <m:msub>
                      <m:mi>γ</m:mi>

                      <m:mn>2</m:mn>
                    </m:msub>
                  </m:mfenced>

                  <m:msub>
                    <m:mi>k</m:mi>

                    <m:mn>2</m:mn>
                  </m:msub>
                </m:mrow>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>3</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msub>
                <m:mi>u</m:mi>

                <m:mn>2</m:mn>
              </m:msub>
            </m:mtd>
          </m:mtr>

          <m:mtr>
            <m:mtd columnalign="right">
              <m:msub>
                <m:mover>
                  <m:mi>x</m:mi>

                  <m:mo>.</m:mo>
                </m:mover>

                <m:mn>4</m:mn>
              </m:msub>
            </m:mtd>

            <m:mtd columnalign="left">
              <m:mo>=</m:mo>

              <m:mo>-</m:mo>

              <m:mfrac>
                <m:msub>
                  <m:mi>a</m:mi>

                  <m:mn>4</m:mn>
                </m:msub>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>4</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msqrt>
                <m:mrow>
                  <m:mn>2</m:mn>

                  <m:mi>g</m:mi>
                </m:mrow>

                <m:msub>
                  <m:mi>x</m:mi>

                  <m:mn>4</m:mn>
                </m:msub>
              </m:msqrt>

              <m:mo>+</m:mo>

              <m:mfrac>
                <m:mrow>
                  <m:mfenced separators="">
                    <m:mn>1</m:mn>

                    <m:mo>-</m:mo>

                    <m:msub>
                      <m:mi>γ</m:mi>

                      <m:mn>1</m:mn>
                    </m:msub>
                  </m:mfenced>

                  <m:msub>
                    <m:mi>k</m:mi>

                    <m:mn>1</m:mn>
                  </m:msub>
                </m:mrow>

                <m:msub>
                  <m:mi>A</m:mi>

                  <m:mn>4</m:mn>
                </m:msub>
              </m:mfrac>

              <m:msub>
                <m:mi>u</m:mi>

                <m:mn>1</m:mn>
              </m:msub>
            </m:mtd>
          </m:mtr>
        </m:mtable>

        <m:mspace linebreak="newline" />
      </m:math>
    </informalequation>

    <para>Where the parameter values are given in the table below:</para>

    <table border="1">
      <caption>Quadruple tank parameter values</caption>

      <tr>
        <td>Name</td>

        <td>Value</td>

        <td>Unit</td>
      </tr>

      <tr>
        <td>A<subscript>i</subscript></td>

        <td>4.9</td>

        <td>cm<superscript>2</superscript></td>
      </tr>

      <tr>
        <td>a<subscript>i</subscript></td>

        <td>0.03</td>

        <td>cm<superscript>2</superscript></td>
      </tr>

      <tr>
        <td>k<subscript>i</subscript></td>

        <td>0.56</td>

        <td>cm<superscript>2</superscript>V<superscript>-1</superscript>s<superscript>-1</superscript></td>
      </tr>

      <tr>
        <td>γ<subscript>i</subscript></td>

        <td>0.3</td>

        <td>Vcm<superscript>-1</superscript></td>
      </tr>
    </table>

    <para>The states of the model are the tank water levels x1, x2, x3, and
    x4. The control inputs, u1 and u2, are the flows generated by the two
    pumps.</para>

    <para>The Modelica model for the system is located in <link
    xlink:href="https://svn.jmodelica.org/tags/1.3b1/Python/src/jmodelica/examples/files/QuadTankPack.mo">QuadTankPack.mo</link>.
    Download the file to your working directory and open it in a text editor.
    Locate the class <literal>QuadTankPack.QuadTank</literal> and make sure
    you understand the model. In particular, notice that all model variables
    and parameters are expressed in SI units.</para>

    <para>Measurement data, available in <link
    xlink:href="https://svn.jmodelica.org/tags/1.3b1/Python/src/jmodelica/examples/files/qt_par_est_data.mat">qt_par_est_data.mat</link>,
    has been logged in an identification experiment. Download also this file
    to your working directory.</para>

    <para>Open a text file and name it qt_par_est.py. Then enter the
    imports:</para>

    <programlisting>from scipy.io.matlab.mio import loadmat
import matplotlib.pyplot as plt
import numpy as N
from jmodelica import simulate
from jmodelica import optimize
from jmodelica.compiler import OptimicaCompiler</programlisting>

    <para>into the file. Next, we enter code to open the data file, extract
    the measurement time series and plot the measurements:</para>

    <programlisting># Load measurement data from file
data = loadmat('qt_par_est_data.mat',appendmat=False)

# Extract data series
t_meas = data['t'][6000::100,0]-60
y1_meas = data['y1_f'][6000::100,0]/100
y2_meas = data['y2_f'][6000::100,0]/100
y3_meas = data['y3_d'][6000::100,0]/100
y4_meas = data['y4_d'][6000::100,0]/100
u1 = data['u1_d'][6000::100,0]
u2 = data['u2_d'][6000::100,0]    

# Plot measurements and inputs
plt.figure(1)
plt.clf()
plt.subplot(2,2,1)
plt.plot(t_meas,y3_meas)
plt.title('x3')
plt.grid()
plt.subplot(2,2,2)
plt.plot(t_meas,y4_meas)
plt.title('x4')
plt.grid()
plt.subplot(2,2,3)
plt.plot(t_meas,y1_meas)
plt.title('x1')
plt.xlabel('t[s]')
plt.grid()
plt.subplot(2,2,4)
plt.plot(t_meas,y2_meas)
plt.title('x2')
plt.xlabel('t[s]')
plt.grid()
plt.show()

plt.figure(2)
plt.clf()
plt.subplot(2,1,1)
plt.plot(t_meas,u1)
plt.hold(True)
plt.title('u1')
plt.grid()
plt.subplot(2,1,2)
plt.plot(t_meas,u2)
plt.title('u2')
plt.xlabel('t[s]')
plt.hold(True)
plt.grid()
plt.show()  </programlisting>

    <para>You should now see two plots showing the measurement state profiles
    and the control input profiles:</para>

    <figure>
      <title>Measured state profiles</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/qt_x.svg" scalefit="1" width="60%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <figure>
      <title>Input profiles used in estimation experiment</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/qt_u.svg" scalefit="1" width="60%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>In order to evaluate the accuracy of nominal model parameter values,
    start by simulating the model, assuming that the start values of the
    states are given by the state measurement at the start of the experiment.
    This assumption can be expressed in the model:</para>

    <programlisting>model Sim_QuadTank
  QuadTank qt;
  input Real u1 = qt.u1;
  input Real u2 = qt.u2;
initial equation
  qt.x1 = 0.0627;
  qt.x2 = 0.06044;
  qt.x3 = 0.024;
  qt.x4 = 0.023;
end Sim_QuadTank;</programlisting>

    <para>Notice that initial equations have been added to the model. Before
    the model is simulated, a matrix containing the input trajectories is
    created:</para>

    <programlisting># Build input trajectory matrix for use in simulation
u = N.transpose(N.vstack((t_meas,u1,u2)))</programlisting>

    <para>Now, the model can be simulated:</para>

    <programlisting># Simulate model response with nominal parameters
res_sim = simulate('QuadTankPack.Sim_QuadTank',
                   'QuadTankPack.mo',
                   compiler='optimica',
                   alg_args={'input_trajectory':u,
                             'start_time':0.,
                             'final_time':60})</programlisting>

    <para>The simulation result can now be extracted:</para>

    <programlisting># Load simulation result
x1_sim = res_sim.result_data.get_variable_data('qt.x1')
x2_sim = res_sim.result_data.get_variable_data('qt.x2')
x3_sim = res_sim.result_data.get_variable_data('qt.x3')
x4_sim = res_sim.result_data.get_variable_data('qt.x4')
u1_sim = res_sim.result_data.get_variable_data('u1')
u2_sim = res_sim.result_data.get_variable_data('u2')</programlisting>

    <para>and then plotted:</para>

    <programlisting># Plot simulation result
plt.figure(1)
plt.subplot(2,2,1)
plt.plot(x1_sim.t,x3_sim.x)
plt.subplot(2,2,2)
plt.plot(x2_sim.t,x4_sim.x)
plt.subplot(2,2,3)
plt.plot(x3_sim.t,x1_sim.x)
plt.subplot(2,2,4)
plt.plot(x4_sim.t,x2_sim.x)
plt.show()

plt.figure(2)
plt.subplot(2,1,1)
plt.plot(u1_sim.t,u1_sim.x,'r')
plt.subplot(2,1,2)
plt.plot(u2_sim.t,u2_sim.x,'r')
plt.show()</programlisting>

    <para>The plot below shows the result of the simulation.</para>

    <figure>
      <title>Simulation result for the nominal model</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/qt_sim.svg" scalefit="1" width="60%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>Here, the simulated profiles are given by the green curves. Clearly,
    there is a mismatch in the response, especially for the two lower tanks.
    Think about why the model does not match the data, i.e., which parameters
    may have wrong values.</para>

    <para>The next step towards solving a parameter estimation problem is to
    identify which parameters to tune. Typically, parameters which are not
    known precisely are selected. Also, the selected parameters need of course
    affect the mismatch between model response and data, when tuned. In a
    first attempt, we aim at decreasing the mismatch for the two lower tanks,
    and therefore we select the lower tank outflow areas, a1 and a2, as
    parameters to optimize. The Optimica specification for the estimation
    problem contained in the class
    <literal>QuadTankPack.QuadTank_ParEst</literal>:</para>

    <programlisting>optimization QuadTank_ParEst (objective=sum((y1_meas[i] - qt.x1(t_meas[i]))^2 + 
                                            (y2_meas[i] - qt.x2(t_meas[i]))^2 for i in 1:N_meas),
                                             startTime=0,finalTime=60)
    
    // Initial tank levels
  parameter Modelica.SIunits.Length x1_0 = 0.06255;
  parameter Modelica.SIunits.Length x2_0 = 0.06045;
  parameter Modelica.SIunits.Length x3_0 = 0.02395;
  parameter Modelica.SIunits.Length x4_0 = 0.02325;

  QuadTank qt(x1(fixed=true),x1_0=x1_0,
              x2(fixed=true),x2_0=x2_0,
              x3(fixed=true),x3_0=x3_0,
              x4(fixed=true),x4_0=x4_0,
              a1(free=true,initialGuess = 0.03e-4,min=0,max=0.1e-4),
              a2(free=true,initialGuess = 0.03e-4,min=0,max=0.1e-4));

  // Number of measurement points
  parameter Integer N_meas = 61;
  // Vector of measurement times
  parameter Real t_meas[N_meas] = 0:60.0/(N_meas-1):60;
  // Measurement values for x1 
  // Notice that dummy values are entered here:
  // the real measurement values will be set from Python
  parameter Real y1_meas[N_meas] = ones(N_meas);
  // Measurement values for x2 	
  parameter Real y2_meas[N_meas] = ones(N_meas);
  // Input trajectory for u1 
  PRBS1 prbs1;
  // Input trajectory for u2
  PRBS2 prbs2;	
equation
  connect(prbs1.y,qt.u1);
  connect(prbs2.y,qt.u2);
end QuadTank_ParEst;</programlisting>

    <para>The cost function is here given as a squared sum of the difference
    between the measured profiles for x1 and x2 and the corresponding model
    profiles. Also the, parameters a1 and a2 are set to be free, and are given
    initial guesses as well as bounds. As for the measurement data, parameter
    vectors are declared, but only dummy data is provided in the model - the
    actual data values will be set from the Python script. Also, the input
    profiles are connected to signal generators that outputs the same input
    profiles as those used in the experiment. Take some time to look at
    QuadTankPack.mo and locate the classes used above.</para>

    <para>Before the optimization problem can be solved, the Optimica
    specification needs to be compiled:</para>

    <programlisting># Create Optimica compiler
oc = OptimicaCompiler()

# Compile model
qt_par_est = oc.compile_model("QuadTankPack.QuadTank_ParEst",
                              "QuadTankPack.mo",target='ipopt')</programlisting>

    <para>Next, we load the measurement data into the model:</para>

    <programlisting># Number of measurement points
N_meas = N.size(u1,0)

# Set measurement data into model
for i in range(0,N_meas):
    qt_par_est.set_value("t_meas["+`i+1`+"]",t_meas[i])
    qt_par_est.set_value("y1_meas["+`i+1`+"]",y1_meas[i])
    qt_par_est.set_value("y2_meas["+`i+1`+"]",y2_meas[i])</programlisting>

    <para>We are now ready to solve the optimization problem:</para>

    <programlisting># Number of element in collocation algorithm
n_e = 100
# Normalized element lengths
hs = N.ones(n_e)/n_e
# Number of collocation points
n_cp = 3

# Solve parameter optimization problem
res_opt = optimize(qt_par_est,alg_args={"n_e":n_e,"n_cp":3, \
                                        "result_mesh":"element_interpolation",
                                        "hs":hs})</programlisting>

    <para>Now, lets extract the optimal values of the parameters a1 and a2 and
    print them to the console:</para>

    <programlisting># Extract optimal values of parameters
a1_opt = res_opt.result_data.get_variable_data("qt.a1")
a2_opt = res_opt.result_data.get_variable_data("qt.a2")

# Print optimal parameter values
print('a1: ' + str(a1_opt.x[-1]*1e4) + 'cm^2')
print('a2: ' + str(a2_opt.x[-1]*1e4) + 'cm^2')</programlisting>

    <para>You should get an output similar to:</para>

    <programlisting>a1: 0.0266cm^2
a2: 0.0272cm^2</programlisting>

    <para>The estimated values are slightly smaller than the nominal values -
    think about why this may be the case. Also note that the estimated values
    do not necessarily correspond to the physically true values. Rather, the
    parameter values are adjusted to compensate for all kinds of modeling
    errors in order to minimize the mismatch between model response and
    measurement data.</para>

    <para>Next we plot the optimized profiles:</para>

    <programlisting># Load state profiles
x1_opt = res_opt.result_data.get_variable_data("qt.x1")
x2_opt = res_opt.result_data.get_variable_data("qt.x2")
x3_opt = res_opt.result_data.get_variable_data("qt.x3")
x4_opt = res_opt.result_data.get_variable_data("qt.x4")
u1_opt = res_opt.result_data.get_variable_data("qt.u1")
u2_opt = res_opt.result_data.get_variable_data("qt.u2")

plt.figure(1)
plt.subplot(2,2,1)
plt.plot(x3_opt.t,x3_opt.x,'k')
plt.subplot(2,2,2)
plt.plot(x4_opt.t,x4_opt.x,'k')
plt.subplot(2,2,3)
plt.plot(x1_opt.t,x1_opt.x,'k')
plt.subplot(2,2,4)
plt.plot(x2_opt.t,x2_opt.x,'k')
plt.show()</programlisting>

    <para>You will now see a plot looking like:</para>

    <figure>
      <title>State profiles corresponding to estimated values of a1 and
      a2.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/qt_est1.svg" scalefit="1" width="60%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The profiles corresponding to the estimated values of a1 and a2 are
    shown in black curves. As can be seen, the match between the model
    response and the measurement data has been significantly increased. Is the
    behavior of the model consistent with the estimated parameter
    values?</para>

    <para>Never the less, There is still a mismatch for the upper tanks,
    especially for tank 4. In order to improve the match, a second estimation
    problem may be formulated, where the parameters a1, a2, a3, a4 are free
    optimization variables, and where the squared errors of all four tank
    levels are penalized. Take a minute to locate the class
    <literal>QuadTankPack.QuadTank_ParEst2</literal> and make sure that you
    understand the model. Solve the optimization problem by typing the Python
    code:</para>

    <programlisting># Compile second parameter estimation model
qt_par_est2 = oc.compile_model("QuadTankPack.QuadTank_ParEst2",
                               "QuadTankPack.mo",target='ipopt')

# Number of measurement points
N_meas = N.size(u1,0)

# Set measurement data into model
for i in range(0,N_meas):
    qt_par_est2.set_value("t_meas["+`i+1`+"]",t_meas[i])
    qt_par_est2.set_value("y1_meas["+`i+1`+"]",y1_meas[i])
    qt_par_est2.set_value("y2_meas["+`i+1`+"]",y2_meas[i])
    qt_par_est2.set_value("y3_meas["+`i+1`+"]",y3_meas[i])
    qt_par_est2.set_value("y4_meas["+`i+1`+"]",y4_meas[i])

# Solve parameter estimation problem
res_opt2 = optimize(qt_par_est2,alg_args={"n_e":n_e,"n_cp":3, \
                                          "result_mesh":"element_interpolation","hs":hs})
</programlisting>

    <para>Next, we print the optimal parameter values:</para>

    <programlisting># Get optimal parameter values
a1_opt2 = res_opt2.result_data.get_variable_data("qt.a1")
a2_opt2 = res_opt2.result_data.get_variable_data("qt.a2")
a3_opt2 = res_opt2.result_data.get_variable_data("qt.a3")
a4_opt2 = res_opt2.result_data.get_variable_data("qt.a4")

# Print optimal parameter values 
print('a1:' + str(a1_opt2.x[-1]*1e4) + 'cm^2')
print('a2:' + str(a2_opt2.x[-1]*1e4) + 'cm^2')
print('a3:' + str(a3_opt2.x[-1]*1e4) + 'cm^2')
print('a4:' + str(a4_opt2.x[-1]*1e4) + 'cm^2')
</programlisting>

    <para>The output in the console should be similar to:</para>

    <programlisting>a1:0.0266cm^2
a2:0.0271cm^2
a3:0.0301cm^2
a4:0.0293cm^2
</programlisting>

    <para>Think about the result - can you explain why the estimated value of
    a4 is slightly smaller than the nominal value? Finally, plot the state
    profiles corresponding to the estimated parameters:</para>

    <programlisting># Extract state and input profiles
x1_opt2 = res_opt2.result_data.get_variable_data("qt.x1")
x2_opt2 = res_opt2.result_data.get_variable_data("qt.x2")
x3_opt2 = res_opt2.result_data.get_variable_data("qt.x3")
x4_opt2 = res_opt2.result_data.get_variable_data("qt.x4")
u1_opt2 = res_opt2.result_data.get_variable_data("qt.u1")
u2_opt2 = res_opt2.result_data.get_variable_data("qt.u2")

# Plot
plt.figure(1)
plt.subplot(2,2,1)
plt.plot(x3_opt2.t,x3_opt2.x,'r')
plt.subplot(2,2,2)
plt.plot(x4_opt2.t,x4_opt2.x,'r')
plt.subplot(2,2,3)
plt.plot(x1_opt2.t,x1_opt2.x,'r')
plt.subplot(2,2,4)
plt.plot(x2_opt2.t,x2_opt2.x,'r')
plt.show()</programlisting>

    <para>The resulting plot should look like:</para>

    <figure>
      <title>State profiles corresponding to estimated values of a1, a2, a3
      and a4</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/qt_est2.svg" scalefit="1" width="60%"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>

    <para>The red curves represent the case where a1, a2, a3 and a4 has been
    estimated.</para>

    <para>Take a moment to think about the results. Are there other parameters
    that could have been selected for estimation?</para>
  </section>

  <section>
    <title>Working with file I/O</title>

    <para>In this tutorial you will learn how to load simulation/optimization
    results.</para>

    <section>
      <title>I/O functionality</title>

      <para>The module <literal>jmodelica.io</literal> provides useful
      functions for exporting and loading simulation or optimization results
      from Dymola. The result files can be in Dymola textural or Dymola binary
      format. The variable data is saved together with the variable names
      which makes it possible to load the result files and match result data
      with a specific variable.</para>
    </section>

    <section>
      <title>Loading result data</title>

      <para>To load a result data file saved using the export functionality
      <literal>jmodelica.io.export_result_dymola</literal> the class
      <literal>ResultDymolaTextual</literal> in the same module,
      <literal>jmodelica.io</literal>, is used. The result object can then be
      used to retrieve data for a specific variable.</para>

      <programlisting language="python"># Load the CSTR results
res = jmodelica.io.ResultDymolaTextual('CSTR_CSTR_Opt_result.txt')

# Get variable data for T_ref
res.get_variable_data('T_ref').x
&gt;&gt; array([ 280.099198,  280.099198])
</programlisting>

      <para>There is a similar function for retrieving results from a file in
      Dymola binary format.</para>
    </section>
  </section>

  <section>
    <title>Setting and saving model parameters</title>

    <para>This tutorial shows how to set model parameters and how to load and
    save parameter data from/to XML files.</para>

    <section>
      <title>Model parameter XML files</title>

      <para>The model parameter meta data and values are saved in XML files
      which are generated during the compilation. They follow the name
      convention:</para>

      <itemizedlist>
        <listitem>
          <para>&lt;model class name&gt;.xml</para>
        </listitem>

        <listitem>
          <para>&lt;model class name&gt;_values.xml</para>
        </listitem>
      </itemizedlist>

      <para>The parameter meta data is saved in &lt;model class name&gt;.xml
      and the parameter values in &lt;model class name&gt;_values.xml. The
      name of the parameter is used to map a parameter value in the values
      file to a parameter specification.</para>
    </section>

    <section>
      <title>Get and set value</title>

      <para>The model parameters can be accessed with via the
      <literal>jmi.Model</literal> interface. It is possible to look at the
      whole vector of, for example, all real parameters in the model or one
      specific parameter. Accessing one specific parameter requires that the
      parameter name is known.</para>

      <para>The following code example assumes the CSTR model has been
      compiled and the DLL file loaded in <literal>jmi.Model</literal>.</para>

      <programlisting language="python"># Get independent real parameter vector
cstr_model.get_real_pi()
&gt;&gt; array([  1.66666667e-03,   1.00000000e+03,   1.66666667e-03,
            3.50000000e+02,   2.19000000e-01,   1.20000000e+09,
            8.75000000e+03,   9.15600000e+02,   1.00000000e+03,
            2.39000000e+02,  -5.00000000e+04,   1.00000000e+02,
            1.00000000e+03,   3.50000000e+02,   5.00000000e+02,
            3.20000000e+02,   3.00000000e+02,   1.00000000e+00,
            1.00000000e+00,   1.00000000e+00,   0.00000000e+00,
            1.50000000e+02])

# Get independent parameter c_ref
cstr_model.get_value('c_ref')
&gt;&gt; 500.0

# Set independent parameter
cstr_model.set_value('c_ref', 450)
# c_ref has now changed
cstr_model.get_value('c_ref')
&gt;&gt; 450.0
</programlisting>
    </section>

    <section>
      <title>Loading from and saving to XML</title>

      <section>
        <title>Loading XML values file</title>

        <para>It is possible to load the values from an XML file as is done
        automatically when the <literal>jmi.Model</literal> object was first
        created. If, for example, there were many local changes to parameters
        it could be desirable to reset everything as it was from the
        beginning.</para>

        <programlisting language="python"># Set parameter
cstr_model.set_value('c_ref', 450)
cstr_model.get_value('c_ref')
&gt;&gt; 450.0
# Load values XML file
cstr_model.load_parameters_from_XML()
# Parameter has now been reset
cstr_model.get_value('c_ref')
&gt;&gt; 500.0
</programlisting>

        <para>Default behaviour is to load the same file as was created during
        compilation. If another file should be used this must be passed to the
        method.</para>

        <programlisting language="python"># Load other XML file
cstr_model.load_parameters_from_XML('new_values.xml')</programlisting>
      </section>

      <section>
        <title>Writing to XML values file</title>

        <para>Setting a parameter value with
        <literal>Model.set_value</literal> only changes the value in the
        vector loaded when <literal>jmi.Model</literal> was created, which
        means that they will not be saved. To save all changes made to
        parameters in a model, the values have to be written to the XML values
        file.</para>

        <programlisting language="python"># Set parameter
cstr_model.set_value('c_ref', 450)
# Save parameters to values XML
cstr_model.write_parameters_to_XML()
# Changed parameter has now been saved in XML file
cstr_model.get_value('c_ref')
&gt;&gt; 450.0
</programlisting>

        <para>If <literal>write_parameters_to_XML()</literal> is called
        without arguments the values will be written to the XML file which was
        created when the model was compiled (following the name conventions
        mentioned above). It is also possible to save the changes in a new XML
        file. This is quite convenient since different parameter value
        settings can easily be saved and loaded in the model.</para>

        <programlisting language="python"># Save to specific XML file
cstr_model.write_parameters_to_XML('test_values.xml')</programlisting>
      </section>
    </section>
  </section>
</chapter>
