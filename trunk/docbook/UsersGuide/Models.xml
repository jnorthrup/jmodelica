<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch_models"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Working with Models</title>

  <section xml:id="models_sec_introduction">
    <title>Introduction to models</title>

    <para>Modelica and Optimica models can be compiled and loaded in the
    JModelica.org Python interface as model objects. These model objects can
    then be used for simulation and optimization purposes. This chapter will
    cover how to compile Modelica and Optimica models, set compiler parameters
    and options, load the compiled model in a Python model object and use the
    model object to perform model manipulations such as setting and getting
    parameters.</para>

    <section>
      <title>The different model objects in JModelica.org</title>

      <para>There are three different kinds of model objects that can be
      created with JModelica.org: <literal>JMUModel</literal>,
      <literal>FMUModel</literal> and <literal>CasadiModel</literal>. The
      <literal>JMUModel</literal> is created by loading a
      <emphasis>JMU</emphasis>, which is a compressed file with a
      JModelica.org specific structure. The <literal>FMUModel</literal> is
      created by loading an <emphasis>FMU</emphasis> (Functional Mock-up
      Unit), which is a compressed file following the FMI (Functional Mock-up
      Interface) standard. The <literal>CasadiModel</literal> is created by
      loading an <emphasis>FMUX</emphasis> which is a compressed file
      containing the XML file needed to work with CasADI.</para>

      <para>JMUs are created by compiling Modelica or Optimica models with
      JModelica.org. The JMU can then be loaded in a
      <literal>JMUModel</literal> object and used for simulation and
      optimization purposes.</para>

      <para>FMUs are created by compiling Modelica models with JModelica.org
      (or any other tool supporting FMU export). Optimica models can not be
      compiled into FMUs. The FMU can then be loaded in an
      <literal>FMUModel</literal> object and used for simulation
      purposes.</para>

      <para>FMUXes are created by compiling Modelica or Optimica models with
      JModelica.org. The FMUX main content is an XML file which follows the
      FMI standard with some additional JModelica.org specific elements and an
      equation section in which all equations used in the model are
      represented. The FMUX can be loaded in a <literal>CasadiModel</literal>
      and thereby use the automatic differentiation tool CasADi for
      optimization purposes. Read more about CasADi and how a
      <literal>CasadiModel</literal> object can be used for optimization in
      <xref linkend="opt_sec_pseudo-spectral" /> in <xref
      linkend="ch_optimization" />.</para>
    </section>
  </section>

  <section xml:id="models_sec_compilation">
    <title>Compilation</title>

    <para>Compiling a model is done in a few steps; importing a compiler
    function from JModelica.org, specifying a model class and file location
    and performing the actual compilation. This will be demonstrated in <xref
    linkend="models_sec_simple_jmu_compilation" /> for the JMU, in <xref
    linkend="models_sec_simple_fmu_compilation" /> for the FMU and in <xref
    linkend="models_sec_simple_fmux_compilation" /> for the FMUX.</para>

    <para>For more advanced usage of the compiler functions, there are
    compiler options and parameters which can be modified. These will be
    explained in <xref linkend="models_sec_compiler_settings" />.</para>

    <para><xref linkend="models_sec_compilation_in_more_detail" />, will go
    through some parts of the compilation process and how to perform these
    steps one by one.</para>

    <section xml:id="models_sec_simple_jmu_compilation">
      <title>Simple JMU compilation example</title>

      <para>The following steps compiles a model to a JMU in the JModelica.org
      Python interface:<procedure>
          <step>
            <para>Import the JModelica.org compiler function
            <literal>compile_jmu</literal> from
            <literal>jmodelica.compiler</literal>.</para>
          </step>

          <step>
            <para>Specify the model and model file.</para>
          </step>

          <step>
            <para>Perform the compilation.</para>
          </step>
        </procedure></para>

      <para>This is demonstrated in the following code example.<programlisting
      language="python"># Import the compiler function
from jmodelica.compiler import compile_jmu

# Specify Modelica model and model file
model_name = 'myPackage.myModel'
mo_file = 'myPackage.mo'

# Compile the model, return argument is the file name of the JMU
compile_jmu(model_name, mo_file)
&gt;&gt; '.\\myPackage_myModel.jmu'
</programlisting></para>

      <para>Once compilation has completed successfully a JMU file will have
      been created on the file system. The JMU file is essentially a
      compressed file archive containing files created during compilation that
      are needed when instantiating a model object. Return argument for
      <literal>compile_jmu</literal> is the full file path of the JMU that has
      just been created, this will be useful later when we want to create
      model objects. More about the JMU file and loading models can be found
      in <xref linkend="models_sec_loading_models" />.</para>

      <para>In the above example, compilation has been performed with default
      parameters and options. The only parameters specified are the model
      class name and file. <literal>compile_jmu</literal> has several other
      parameters which can be modified. The different parameters, their
      default values and interpretation will be explained in <xref
      linkend="models_sec_compiler_settings" />.</para>
    </section>

    <section xml:id="models_sec_simple_fmu_compilation">
      <title>Simple FMU compilation example</title>

      <para>The steps required to compile a model to an FMU is very similar to
      compiling a model to a JMU:<procedure>
          <step>
            <para>Import the JModelica.org compiler function
            <literal>compile_fmu</literal> from
            <literal>jmodelica.compiler</literal>.</para>
          </step>

          <step>
            <para>Specify the model and model file.</para>
          </step>

          <step>
            <para>Perform the compilation.</para>
          </step>
        </procedure></para>

      <para>The only difference is really the requirement on the model, it
      must be a pure Modelica model. The following code example demonstrates
      how to compile an FMU.<programlisting language="python"># Import the compiler function
from jmodelica.compiler import compile_fmu

# Specify Modelica model and model file
model_name = 'myPackage.myModel'
mo_file = 'myPackage.mo'

# Compile the model, return argument is the file name of the FMU
compile_fmu(model_name, mo_file)
&gt;&gt; '.\\myPackage_myModel.fmu'
</programlisting></para>

      <para>As in the JMU case, when the compilation has completed
      successfully an FMU file will have been created on the file system. The
      return argument is also the full file path of the FMU that has just been
      created, which will be useful later when we want to create model
      objects. More about the FMU file and loading models can be found in
      <xref linkend="models_sec_loading_models" />.</para>
    </section>

    <section xml:id="models_sec_simple_fmux_compilation">
      <title>Simple FMUX compilation example</title>

      <para>Compiling an FMUX follows the same principle as compiling a JMU
      and an FMU.</para>

      <procedure>
        <step>
          <para>Import the JModelica.org compiler function
          <literal>compile_fmux</literal> from
          <literal>jmodelica.</literal>compiler.</para>
        </step>

        <step>
          <para>Specify the model and model file.</para>
        </step>

        <step>
          <para>Perform the compilation.</para>
        </step>
      </procedure>

      <para>The Python code example below will perform these steps.</para>

      <programlisting language="python"># Import the compiler function
from jmodelica.fmi import compile_fmux

# Specify Modelica model and model file
model_name = 'myPackage.myModel'
mo_file = 'myPackage.mo'

# Compile the model, return argument is the file name of the FMUX
compile_fmux(model_name, mo_file)
&gt;&gt; '.\\myPackage_myModel.fmux'
</programlisting>
    </section>

    <section xml:id="models_sec_compiler_settings">
      <title>Compiler settings</title>

      <para>The compiler function parameters can be listed with the
      interactive help in Python. The parameters are explained in the
      corresponding Python <emphasis>docstring</emphasis> which is visualized
      with the interactive help. This is demonstrated in the code examples
      below.</para>

      <para>The parameter <literal>target</literal>, is further explained in
      <xref linkend="models_sec_compiler_targets_jmu" />, <xref
      linkend="models_sec_compiler_targets_fmu" /> and <xref
      linkend="models_sec_compiler_targets_fmux" />.</para>

      <section xml:id="models_sec_compile_jmu_parameters">
        <title>compile_jmu parameters</title>

        <para>The <literal>compile_jmu</literal> parameters can be listed with
        the interactive help.<programlisting language="python"># Display the docstring for compile_jmu with the Python command 'help'
from jmodelica.compiler import compile_jmu
help(compile_jmu)
Help on function compile_jmu in module jmodelica.jmi:

compile_jmu(class_name, file_name=[], compiler='auto', target='ipopt', compiler_options={}, 
            compile_to='.', compiler_log_level='warning')
    Compile a Modelica or Optimica model to a JMU.

    A model class name must be passed, all other arguments have default values.
    The different scenarios are:

    * Only class_name is passed:
        - Default compiler is ModelicaCompiler.
        - Class is assumed to be in MODELICAPATH.

    * class_name and file_name is passed:
        - file_name can be a single file as a string or a list of file_names
          (strings).
        - Default compiler setting is 'auto' which means that the appropriate
          compiler will be selected based on model file ending, i.e.
          ModelicaCompiler if .mo file and OptimicaCompiler if a .mop file is
          found in file_name list.

    Library directories can be added to MODELICAPATH by listing them in a
    special compiler option 'extra_lib_dirs', for example:

        compiler_options =
            {'extra_lib_dirs':['c:\MyLibs\MyLib1','c:\MyLibs\MyLib2']}

    Other options for the compiler should also be listed in the compiler_options
    dict.

    The compiler target is 'ipopt' by default which means that libraries for AD
    and optimization/initialization algortihms will be available as well as the
    JMI. The other targets are:

        'model' --
            AD and JMI is included.
        'algorithm' --
            AD and algorithm but no Ipopt linking.
        'model_noad' --
            Only JMI, that is no AD interface. (Must currently be used when
            model includes external functions.)

    Parameters::

        class_name --
            The name of the model class.

        file_name --
            Model file (string) or files (list of strings), can be both .mo or
            .mop files.
            Default: Empty list.

        compiler --
            'auto' if a compiler should be selected automatically depending on
            file ending, 'modelica' if a ModelicaCompiler should be used or
            'optimica' if a OptimicaCompiler should be used.
            Default: 'auto' (i.e. depends on argument file_name)

        target --
            Compiler target. 'model', 'algorithm', 'ipopt' or 'model_noad'.
            Default: 'ipopt'

        compiler_options --
            Options for the compiler.
            Default: Empty dict.

        compile_to --
            Specify location of the compiled JMU. Directory will be created if
            it does not exist.
            Default: Current directory.

        compiler_log_level --
            Set the log level for the compiler. Valid options are 'warning'/'w',
            'error'/'e' or 'info'/'i'.
            Default: 'warning'

    Returns::

        Name of the JMU which has been created.

</programlisting></para>
      </section>

      <section>
        <title>compile_fmu parameters</title>

        <para>The <literal>compile_fmu</literal> parameters can be listed with
        the interactive help.</para>

        <programlisting language="python"># Display the docstring for compile_fmu with the Python command 'help'
from jmodelica.compiler import compile_fmu
help(compile_fmu)
Help on function compile_fmu in module jmodelica.fmi:

compile_fmu(class_name, file_name=[], compiler='modelica', target='model_fmume', 
            compiler_options={}, compile_to='.', compiler_log_level='warning')
    Compile a Modelica model to an FMU.

    A model class name must be passed, all other arguments have default values.
    The different scenarios are:

    * Only class_name is passed:
        - Class is assumed to be in MODELICAPATH.

    * class_name and file_name is passed:
        - file_name can be a single file as a string or a list of file_names
          (strings).

    Library directories can be added to MODELICAPATH by listing them in a
    special compiler option 'extra_lib_dirs', for example:

        compiler_options =
            {'extra_lib_dirs':['c:\MyLibs\MyLib1','c:\MyLibs\MyLib2']}

    Other options for the compiler should also be listed in the compiler_options
    dict.

    The compiler target is 'model_fmume' by default which means that the shared
    file contains the FMI for Model Exchange API. This is currently the only
    target that is possible to use.

    Parameters::

        class_name --
            The name of the model class.

        file_name --
            Model file (string) or files (list of strings), can be both .mo or
            .mop files.
            Default: Empty list.

        compiler --
            The compiler used to compile the model. The only possible compiler
            that can be used currently is ModelicaCompiler.
            Default: 'modelica'

        target --
            Compiler target.
            Default: 'model_fmume'

        compiler_options --
            Options for the compiler.
            Default: Empty dict.

        compile_to --
            Specify location of the compiled FMU. Directory will be created if
            it does not exist.
            Default: Current directory.

        compiler_log_level --
            Set the log level for the compiler. Valid options are 'warning'/'w',
            'error'/'e' or 'info'/'i'.
            Default: 'warning'

    Returns::

        Name of the FMU which has been created.
</programlisting>
      </section>

      <section>
        <title>compile_fmux parameters</title>

        <para>The <literal>compile_fmux</literal> parameters can be listed
        with the interactive help.</para>

        <programlisting language="python"># Display the docstring for compile_fmux with the Python command 'help'
from jmodelica.compiler import compile_fmux
help(compile_fmux)
Help on function compile_fmux in module jmodelica.fmi:

compile_fmux(class_name, file_name=[], compiler='auto', compiler_options={}, compile_to='.', 
             compiler_log_level='warning')
    Compile a Modelica model to an FMUX.

    A model class name must be passed, all other arguments have default values.
    The different scenarios are:

    * Only class_name is passed:
        - Class is assumed to be in MODELICAPATH.

    * class_name and file_name is passed:
        - file_name can be a single file as a string or a list of file_names
          (strings).

    Library directories can be added to MODELICAPATH by listing them in a
    special compiler option 'extra_lib_dirs', for example:

        compiler_options =
            {'extra_lib_dirs':['c:\MyLibs\MyLib1','c:\MyLibs\MyLib2']}

    Other options for the compiler should also be listed in the compiler_options
    dict.


    Parameters::

        class_name --
            The name of the model class.

        file_name --
            Model file (string) or files (list of strings), can be both .mo or
            .mop files.
            Default: Empty list.

        compiler --
            The compiler used to compile the model.
            Default: 'auto'

        compiler_options --
            Options for the compiler.
            Default: Empty dict.

        compile_to --
            Specify location of the compiled FMUX. Directory will be created if
            it does not exist.
            Default: Current directory.

        compiler_log_level --
            Set the log level for the compiler. Valid options are 'warning'/'w',
            'error'/'e' or 'info'/'i'.
            Default: 'warning'

    Returns::

        Name of the FMUX which has been created.
</programlisting>
      </section>

      <section xml:id="models_sec_compiler_options">
        <title>Compiler options</title>

        <para>Compiler options are read from an XML file,
        <filename>options.xml</filename>, which can be found in the
        JModelica.org installation folder under the folder
        <filename>Options</filename>. The options are loaded from the file
        when a compiler is created, that is when
        <literal>compile_jmu</literal>, <literal>compile_fmu</literal> or
        <literal>compile_fmux</literal> is run. Options for a compiler
        instance can be modified interactively when compiling using the
        parameter <literal>compiler_options</literal>. This is shown in an
        example compiling an Optimica model below.</para>

        <programlisting language="python"># Compile with the compiler option 'enable_variable_scaling' set to True

# Specify Optimica model and model file
model_name = 'myPackage.myModel'
mo_file = 'myPackage.mop'

compile_jmu(model_name, mo_file, compiler_options={"enable_variable_scaling":True})
</programlisting>

        <para>There are four type categories: string, real, integer and
        boolean. The available options, default values and description are
        listed in <xref linkend="models_tab_compiler_options" />.<table
            xml:id="models_tab_compiler_options">
            <title>Compiler options</title>

            <tgroup cols="3">
              <colspec align="left" colname="col–para" colwidth="2.75*" />

              <colspec align="left" colname="col–def" colwidth="1*" />

              <colspec align="left" colname="col–descr" colwidth="3.25*" />

              <thead>
                <row>
                  <entry align="center">Option</entry>

                  <entry align="center">Default</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>normalize_minimum_time_problems</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>When this option is set to <literal>true</literal>
                  then minimum time optimal control problems encoded in
                  Optimica are converted to fixed interval problems by scaling
                  of the derivative variables. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>enable_variable_scaling</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, then the
                  "nominal" attribute will be used to scale variables in the
                  model. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>halt_on_warning</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>false</literal> one
                  or more compiler warnings will not stop compilation of the
                  model. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>automatic_add_initial_equations</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>When this option is set to <literal>true</literal>,
                  then additional initial equations are added to the model
                  based on a the result of a matching algorithm. Initial
                  equations are added for states that are not matched to an
                  equation. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_ode_jacobian</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>,
                  code for computing ODE Jacobians are generated. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>eliminate_alias_variables</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, then alias
                  variables are eliminated from the model. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>extra_lib_dirs</literal></entry>

                  <entry><literal>""</literal></entry>

                  <entry>The value of this option is appended to the value of
                  the <literal>MODELICAPATH</literal> environment variable for
                  determining in what directories to search for libraries.
                  (String option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_xml_equations</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, then model
                  equations are generated in XML format. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>state_start_values_fixed</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>This option enables the user to specify if initial
                  equations should be generated automatically for
                  differentiated variables even though the fixed attribute is
                  equal to fixed. Setting this option to
                  <literal>true</literal> is, however, often practical in
                  optimization problems. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>equation_sorting</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, equations
                  are sorted using the BLT algorithm. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>index_reduction</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, index
                  reduction is performed. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>enable_structural_diagnosis</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>Enable this option to invoke the structural error
                  diagnosis based on the matching algorithm. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>compliance_as_warning</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>When this option is set to <literal>true</literal>,
                  then compliance errors are treated as warnings instead. This
                  can lead to the compiler or solver crashing. Use with
                  caution! (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_html_diagnostics</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>When this option is set to <literal>true</literal>
                  model diagnostics is generated in HTML format. This includes
                  the flattened model, connection sets, alias sets and BLT
                  form. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_ode</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>,
                  code for solving ODEs is generated. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>convert_free_dependent_
                  parameters_to_algebraics</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, free
                  dependent parameters are converted to algebraic variables.
                  (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_dae</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, code for
                  solving DAEs is generated. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_dae_jacobian</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, code for
                  computing DAE Jacobians is generated. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>export_functions</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>Export used Modelica functions to generated C code in
                  a manner that is compatible with the external C interface in
                  the Modelica Language Specification. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>export_functions_vba</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, then
                  VBA-compatible wrappers for exported functions are created.
                  Requires <literal>export_functions = true</literal>.
                  (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_fmi_cs_xml</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal> the model
                  description part of the XML variables file will be FMI for
                  co simulation compliant. To generate an XML which will
                  validate with FMI schema the option generate_xml_equations
                  must also be false.</entry>
                </row>

                <row>
                  <entry><literal>advanced_tearing</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>, a
                  more advanced tearing algorithm is used. This algorithm may
                  give smaller torn systems, but may also take longer time to
                  execute. This option only has an effect if the option
                  <literal>enable_tearing</literal> is set to true.</entry>
                </row>

                <row>
                  <entry><literal>divide_by_vars_in_tearing</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>, a
                  less restrictive strategy is used for solving equations in
                  the tearing algorithm. Specifically, division by parameters
                  and variables is permitted, by default no such divisions are
                  made during tearing.</entry>
                </row>

                <row>
                  <entry><literal>enable_tearing</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>,
                  tearing of equation systems is enabled.</entry>
                </row>

                <row>
                  <entry><literal>generate_fmi_me_xml</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal> the model
                  description part of the XML variables file will be FMI for
                  model exchange compliant. To generate an XML which will
                  validate with FMI schema the option generate_xml_equations
                  must also be false.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="models_sec_compiler_targets_jmu">
        <title>Compiler targets for <literal>compile_jmu</literal></title>

        <para>There are four compiler targets available for
        <literal>compile_jmu</literal>:<itemizedlist>
            <listitem>
              <para><literal>ipopt</literal>: Compiled model will include JMI
              interface, AD and linking to Ipopt libraries. There is support
              for optimization and initialization algorithm.</para>
            </listitem>

            <listitem>
              <para><literal>model</literal>: Compiled model will include
              support for JMI interface and AD.</para>
            </listitem>

            <listitem>
              <para><literal>algorithm</literal>: Compiled model will include
              support for JMI interface. AD and algorithm but not link with
              the Ipopt libraries.</para>
            </listitem>

            <listitem>
              <para><literal>model_noad</literal>: Compiled model will only
              include the JMI interface.</para>
            </listitem>
          </itemizedlist></para>

        <para>The compiler target is '<literal>ipopt</literal>' by default
        which will work for most cases. However, if JModelica.org has been
        built without Ipopt libraries the target would have to be changed to
        any other suitable target that does not include the Ipopt
        libraries.</para>

        <para>The target <literal>model_noad</literal> must be used if the
        model contains external equations since external equations do not work
        with the AD interface at the moment.</para>
      </section>

      <section xml:id="models_sec_compiler_targets_fmu">
        <title>Compiler targets for <literal>compile_fmu</literal></title>

        <para>Currently, the only possible target available for
        <literal>compile_fmu</literal> is '<literal>model_fmume</literal>'.
        With this target the compiled model will include the FMI for Model
        Exchange API.</para>
      </section>

      <section xml:id="models_sec_compiler_targets_fmux">
        <title>Compiler targets for <literal>compile_fmux</literal></title>

        <para>Compiler targets are not relevant for
        <literal>compile_fmux</literal> since no binary file is
        compiled.</para>
      </section>
    </section>

    <section xml:id="models_sec_compilation_in_more_detail">
      <title>Compilation in more detail</title>

      <para>Compiling with <literal>compile_jmu</literal>,
      <literal>compile_fmu</literal> or <literal>compile_fmux</literal>
      bundles quite a few steps required for the compilation from model file
      to JMU, FMU or FMUX. Some of these steps will be described briefly here,
      for a more detailed review on the compilation steps see <xref
      linkend="intro_sec_architecture" /> in <xref
      linkend="ch_intro" />.</para>

      <section>
        <title>Create a compiler</title>

        <para>A compiler, can be either a Modelica or Optimica compiler, is
        created by importing the Python classes from the compiler module. The
        compiler constructors only has optional arguments. These are the paths
        to the template XML and C files which in most cases can be left to the
        default values. (Note that in the <literal>compile_fmux</literal> case
        the only template needed is to the Model description XML template file
        since no C code is produced.) This example code will create a Modelica
        compiler.<programlisting language="python"># import the class ModelicaCompiler from the compiler module
from jmodelica.compiler import ModelicaCompiler

# create a compiler instance
mc = ModelicaCompiler()
</programlisting></para>
      </section>

      <section>
        <title>Source tree generation and flattening</title>

        <para>In the first step of the compilation, the model is parsed and
        instantiated. Then the model is transformed into a flat representation
        which can be used to generate C and XML code. If there are errors in
        the model, for example syntax or type errors, Python exceptions will
        be thrown during these steps. <programlisting language="python"># Parse the model and get a reference to the source root
source_root = mc.parse_model('myPackage.mo')

# Generate an instance tree representation and get a reference to the model instance
model_instance = mc.instantiate_model(source_root, 'myPackage.myModel')

# Perform flattening and get a flat representation
flat_rep = mc.flatten_model(model_instance)
</programlisting></para>
      </section>

      <section>
        <title>Code generation</title>

        <para>The next step is the code generation which produces C code
        containing the model equations and a couple of XML files containing
        model meta data such as variable names and types and parameter values.
        Note that in the <literal>compile_fmux</literal> case, only XML code
        is generated in this step.<programlisting language="python"># Generate code
mc.generate_code(flat_rep)
</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="models_sec_loading_models">
    <title>Loading models</title>

    <para>Compiled models, JMUs, FMUs and FMUXes, are loaded in the
    JModelica.org Python interface with the <literal>JMUModel</literal> class
    from the <literal>pyjmi.jmi</literal> module, the
    <literal>FMUModel</literal> class from the <literal>pyfmi.fmi</literal>
    module and the <literal>CasadiModel</literal> class from the
    <literal>pyjmi.casadi_interface</literal> module respectively. This will
    be demonstrated in <xref linkend="models_sec_loading_a_jmu" />, <xref
    linkend="models_sec_loading_an_fmu" /> and <xref
    linkend="models_sec_loading_an_fmux" />.</para>

    <para>The model classes contain many methods with which models can be
    manipulated after instantiation. Amongst the most important methods are
    <literal>initialize</literal>, <literal>simulate</literal> and
    <literal>optimize</literal>. (<literal>optimize</literal> is only relevant
    for JMU model instances.) These are explained in <xref
    linkend="ch_simulation" /> and <xref linkend="ch_optimization" />. For
    more information on how to use the CasadiModel for optimization purposes,
    see <xref linkend="opt_sec_pseudo-spectral" /> in <xref
    linkend="ch_optimization" />. The more basic methods for variable and
    parameter manipulation are explained in <xref
    linkend="models_sec_variable_and_parameter_manipulation" />.</para>

    <section xml:id="models_sec_the_jmu_file">
      <title>The JMU</title>

      <para>The JMU is a compressed file which contains all files needed to
      load and work with the compiled model in JModelica.org. The JMU contains
      the shared object file, the XML files with model variable and parameter
      data and some other files created during compilation of the model. The
      JMU file format is a JModelica.org specific format but is designed to
      follow the FMU file format from the FMI standard as much as possible. A
      JMU is created when compiling a Modelica or Optimica model with
      <literal>jmodelica.compiler.compile_jmu</literal>, see <xref
      linkend="models_sec_compilation" />.</para>
    </section>

    <section>
      <title>The FMU</title>

      <para>The FMU (Functional Mock-up Unit) is a compressed file which
      follows the FMI (Functional Mock-up Interface) standard. An FMU is
      created when compiling a Modelica model with
      <literal>jmodelica.compiler.compile_fmu</literal>.</para>

      <para>Read more about the FMI/FMU standard in <xref
      linkend="ch_fmi" />.</para>
    </section>

    <section>
      <title>The FMUX</title>

      <para>The FMUX is a compressed file which only contains an XML file and
      a couple of resource files created during the flattening of the model.
      The XML file follows the FMI standard with some JModelica.org specific
      extra elements and a section of equations. The equations part contains
      all equations used in the model. The FMUX is created when compiling a
      Modelica or Optimica model with
      <literal>jmodelica.compiler.compile_fmux</literal>.</para>
    </section>

    <section xml:id="models_sec_loading_a_jmu">
      <title>Loading a JMU</title>

      <para>A JMU file is loaded in JModelica.org with the class
      <literal>JMUModel</literal> in the <literal>pyjmi.jmi</literal> module.
      The following simple example demonstrates how to do this in a Python
      shell or script.<programlisting language="python" xml:space="preserve"># Import JMUModel from jmodelica.jmi
from pyjmi.jmi import JMUModel
myModel = JMUModel('myPackage_myModel.jmu')
</programlisting></para>

      <para>The only parameter in the <literal>JMUModel</literal> constructor
      is the name of the JMU file, including any file path. When compiling and
      loading it is therefore practical to use the return argument from
      <literal>compile_jmu</literal>, which is the path to the JMU created.
      The following example demonstrates this.<programlisting
      language="python"># Import compile_jmu and JMUModel
from jmodelica.compiler import compile_jmu
from pyjmi.jmi import JMUModel

# Compile and load model
jmu_name = compile_jmu('myPackage.myModel','myPackage.mo')
myModel = JMUModel(jmu_name)
</programlisting></para>
    </section>

    <section xml:id="models_sec_loading_an_fmu">
      <title>Loading an FMU</title>

      <para>The FMU file can be loaded in JModelica.org with the class
      <literal>FMUModel</literal> in the <literal>pyfmi.fmi</literal> module.
      The following short example demonstrates how to do this in a Python
      shell or script.<programlisting language="python"># Import FMUModel from jmodelica.fmi
from pyfmi.fmi import FMUModel
myModel = FMUModel('myFMU.fmu')
</programlisting></para>

      <para>The <literal>FMUModel</literal> instance can then be used to set
      parameters and used for simulations.</para>
    </section>

    <section xml:id="models_sec_loading_an_fmux">
      <title>Loading an FMUX</title>

      <para>The FMUX file can be loaded in JModelica.org with the class
      <literal>CasadiModel</literal> in the
      <literal>pyjmi.casadi_interface</literal> module. The following short
      example demonstrates how to do this in a Python shell or
      script.<programlisting language="python"># Import CasadiModel from jmodelica.casadi_interface
from pyjmi.casadi_interface import CasadiModel
myModel = CasadiModel('myFMUX.fmux')
</programlisting></para>
    </section>
  </section>

  <section xml:id="models_sec_variable_and_parameter_manipulation">
    <title>Variable and parameter manipulation</title>

    <para>Model variables and parameters can be manipulated with methods in
    the model classes once the model has been loaded. Some short examples in
    <xref linkend="models_sec_setting_and_getting_variables" /> will
    demonstrate this. Model variable meta data and parameter values are saved
    in XML files which are generated during compilation, these are briefly
    explained in <xref linkend="models_sec_model_variable_XML_files" />. The
    XML file containing the parameters can be used to save different sets of
    parameters for one model, see <xref
    linkend="models_sec_loading_and_saving_parameters" />.</para>

    <section xml:id="models_sec_model_variable_XML_files">
      <title>Model variable XML files</title>

      <para>The model variable meta data and parameter values are saved in XML
      files which are generated during the compilation. They follow the name
      convention:</para>

      <itemizedlist>
        <listitem>
          <para><filename>modelDescription.xml</filename></para>
        </listitem>

        <listitem>
          <para><filename>&lt;model_class_name&gt;_values.xml</filename></para>
        </listitem>
      </itemizedlist>

      <para>The variable meta data is saved in
      <filename>modelDescription.xml</filename> and the parameter values in
      <filename>&lt;model_class_name&gt;_values.xml</filename>. Note that the
      parameter values file is JModelica.org specific and is not a part of the
      FMI standard and it is not part of the FMUX either. The name of the
      parameter is used to map a parameter value in the XML values file to a
      parameter specification in the XML variables file.</para>
    </section>

    <section xml:id="models_sec_setting_and_getting_variables">
      <title>Setting and getting variables</title>

      <para>The model variables can be accessed with via the model class
      interfaces. It is possible to set and get one specific variable at a
      time or a whole list of variables.</para>

      <para>The following code example demonstrates how to get and set a
      specific variable using an example JMU model from the
      <literal>pyjmi.examples</literal> package.<programlisting
      language="python"># Compile and load the model
from jmodelica.compiler import compile_jmu
from pyjmi.jmi import JMUModel
jmu_name = compile_jmu('RLC_Circuit','RLC_Circuit.mo')
rlc_circuit = JMUModel(jmu_name)

# Get the value of the variable 'resistor.R'
resistor_r = rlc_circuit.get('resistor.R')
resistor_r
&gt;&gt; 1.0

# Give 'resistor.R' a new value
resistor_r = 2.0
rlc_circuit.set('resistor.R', resistor_r)
rlc_circuit.get('resistor.R')
&gt;&gt; 2.0
</programlisting></para>

      <para>The following example demonstrates how to get and set a list of
      variables using the same example model as above. The model is assumed to
      already be compiled and loaded.<programlisting language="python"># Create a list of variables and values
vars = ['resistor.R', 'resistor.v', 'capacitor.C', 'capacitor.v']
values = rlc_circuit.get(vars)
values
&gt;&gt; [2.0, 0.0, 1.0, 0.0]

# Change some of the values
values[0] = 3.0
values[3] = 1.0
rlc_circuit.set(vars, values)
rlc_circuit.get(vars)
&gt;&gt; [3.0, 0.0, 1.0, 1.0]
</programlisting></para>
    </section>

    <section xml:id="models_sec_loading_and_saving_parameters">
      <title>Loading and saving parameters</title>

      <para>This section is only relevant for the
      <literal>JMUModel</literal>.</para>

      <section>
        <title>Loading XML values file</title>

        <para>It is possible to (re)load the parameter values from an XML file
        as is done automatically when the
        <literal>pyjmi.jmi.JMUModel</literal> object was first created. If,
        for example, there were many local changes to parameters it could be
        desirable to reset everything as it was from the beginning. The
        following example shows how reloading the parameter values from the
        XML file resets the parameters in the model. The model is taken from
        the <literal>pyjmi.examples</literal> package and is assumed to be
        compiled and loaded.</para>

        <programlisting language="python"># Look at parameters 'resistor.R' and 'sine.offset'
rlc_circuit.get('resistor.R)
&gt;&gt; 1.0
rlc_circuit.get('sine.offset')
&gt;&gt; 0.0

# Change them
rlc_circuit.set('resistor.R', 2.0)
rlc_circuit.set('sine.offset', 0.5)

# Look at them again
rlc_circuit.get('resistor.R)
&gt;&gt; 2.0
rlc_circuit.get('sine.offset')
&gt;&gt; 0.5

# Reset them by loading the original XML values file
rlc_circuit.load_parameters_from_XML()

# 'resistor.R' and 'sine.offset' have now been reset
rlc_circuit.get('resistor.R)
&gt;&gt; 1.0
rlc_circuit.get('sine.offset')
&gt;&gt; 0.0
</programlisting>

        <para>The default behaviour is to load the same file as was created
        during compilation. If another file should be used this must be passed
        as an argument to the method.</para>

        <programlisting language="python"># Load other XML file
rlc_circuit.load_parameters_from_XML('new_values.xml')
</programlisting>
      </section>

      <section>
        <title>Writing to XML values file</title>

        <para>Setting a parameter value with <literal>JMUModel.set</literal>
        only changes the value in the vector loaded when
        <literal>pyjmi.jmi.JMUModel</literal> was created, which means that it
        will not be saved when the model is discarded. To save all local
        changes made to the model parameters, the values have to be written to
        the XML values file.</para>

        <programlisting language="python"># Set a parameter
rlc_circuit.set('inductor.L', 1.5)

# Save parameters to the XML values file
rlc_circuit.write_parameters_to_XML()

# Load the XML values file once again and see that the changed parameter was saved in 
# the XML file
rlc_circuit.load_parameters_from_XML()
rlc_circuit.get('inductor.L')
&gt;&gt; 1.5
</programlisting>

        <para>If <literal>write_parameters_to_XML()</literal> is called
        without arguments the values will be written to the XML values file in
        the JMU which was created when the model was compiled (following the
        name conventions mentioned above). It is also possible to save the
        changes in a new XML file. This is quite convenient since different
        parameter value settings can then easily be saved and reloaded in the
        model.</para>

        <programlisting language="python"># Save to specific XML file
rlc_circuit.write_parameters_to_XML('test_values.xml')
</programlisting>
      </section>
    </section>
  </section>

  <section>
    <title>Debugging models</title>

    <para>The JModelica.org compilers can generate debugging information in
    order to facilitate localization of errors. There are two mechanisms for
    generating such diagnostics: dumping of debug information to the system
    output or generation of HTML code that can be viewed with a standard web
    browser.</para>

    <para>By setting the argument <literal>compiler_log_level</literal> to
    <literal>'i'</literal>, diagnostics is printed to the standard output,
    normally the terminal window from which the compiler is invoked. The
    resulting diagnostics provides detailed information from each of the
    transformation steps in the symbolic manipulation algorithms.</para>

    <para>By setting the compiler option
    <literal>generate_html_diagnostics</literal> to true, a number of HTML
    pages containing similar diagnostics is generated. The HTML files are
    generated in the directory <literal>Model_Name_diagnostics</literal>,
    where <literal>Model_Name</literal> is the name of the compiled model. As
    compared to the diagnostics generated by the
    <literal>compiler_log_level</literal> argument, the HTML diagnostics
    contains only the most important information, but it also provides a
    better overview. Opening the file
    <literal>Model_Name_diagnostics/index.html</literal> in a web browser,
    results in a page similar to the one shown below.</para>

    <programlisting>Modelica.Mechanics.Rotational.Examples.First

Number of independent constants:              1
  Number of Real independent constants:       1
  Number of Integer independent constants:    0
  Number of Enum independent constants:       0
  Number of Boolean independent constants:    0
  Number of String independent constants:     0
Number of dependent constants:                0
  Number of Real dependent constants:         0
  Number of Integer dependent constants:      0
  Number of Enum dependent constants:         0
  Number of Boolean dependent constants:      0
  Number of String dependent constants:       0
Number of independent parameters:             20
  Number of Real independent parameters:      14
  Number of Integer independent parameters:   0
  Number of Enum independent parameters:      4
  Number of Boolean independent parameters:   2
  Number of String independent parameters:    0
Number of dependent parameters:               6
  Number of Real dependent parameters:        6
  Number of Integer dependent parameters:     0
  Number of Enum dependent parameters:        0
  Number of Boolean dependent parameters:     0
  Number of String dependent parameters:      0
Number of variables :                         33
  Number of Real variables:                   33
  Number of Integer variables:                0
  Number of Enum variables:                   0
  Number of Boolean variables:                0
  Number of String variables:                 0
Number of Real differentiated variables:      4
Number of Real derivative variables:          4
Number of Real algebraic variables:           25
Number of inputs:                             0
  Number of Real inputs:                      0
  Number of Integer inputs:                   0
  Number of Enum inputs:                      0
  Number of Boolean inputs:                   0
  Number of String inputs:                    0
Number of discrete variables :                0
  Number of Real discrete variables:          0
  Number of Integer discrete variables:       0
  Number of Enum discrete variables:          0
  Number of Boolean discrete variables:       0
  Number of String discrete variables:        0
Number of equations:                          29
Number of variables with binding expression:  0
  Number of Real variables with binding exp:  0
  Number of Integer variables binding exp:    0
  Number of Enum variables binding exp:       0
  Number of Boolean variables binding exp:    0
  Number of String variables binding exp:     0
Total number of equations:                    29
Number of initial equations:                  4
Number of relational exps in equations:       1
Number of relational exps in init equations:  0
Flattened model

Transformed model

Problems:
0 errors, 0 compliance errors, 0 warnings

Alias sets

Connection sets

BLT diagnostics
Number of unsolved equation blocks in DAE initialization system: 1: {7}
Number of unsolved equation blocks in DAE system: 1: {7}
</programlisting>

    <para>Note that some of the entries, including <literal>Flattened
    model</literal>, <literal>Transformed model</literal>, <literal>Connection
    sets</literal>, <literal>Alias sets</literal> and <literal>BLT
    diagnostics</literal> are links to sub pages containing additional
    information. For example, the BLT diagnostics page contains information
    about individual systems of equations:</para>

    <programlisting>...

--- Block 12---
Solved block of 1 variables:
Computed variable:
  torque.flange.tau
Solution:
  ( sine.offset + (if time &lt; sine.startTime then 0 else ( sine.amplitude ) * 
  ( sin(( ( ( 2 ) * ( 3.141592653589793 ) ) * ( sine.freqHz ) ) * 
  ( time - ( sine.startTime ) ) + sine.phase) )) ) / (  - ( 1 ) )

--- Block 13---
Non-solved block of 7 variables:
Unknown variables:
  idealGear.der(phi_a,2)
  idealGear.der(phi_b,2)
  inertia2.der(_der_phi)
  inertia2.a
  idealGear.flange_b.tau
  idealGear.flange_a.tau
  inertia1.a
Equations:
  der_2_idealGear_phi_a = inertia1.a - ( 0 )
  der_2_idealGear_phi_a = ( idealGear.ratio ) * ( der_2_idealGear_phi_b ) + ( 0 ) * 
                          ( der_idealGear_phi_b ) + ( 0 ) * ( der_idealGear_phi_b ) + 
                          ( 0 ) * ( idealGear.phi_b )
  der_2_idealGear_phi_b = inertia2.der(_der_phi) - ( 0 )
  inertia2.a = inertia2.der(_der_phi)
  ( inertia2.J ) * ( inertia2.a ) =  - ( idealGear.flange_b.tau ) + inertia2.flange_b.tau
  0 = ( idealGear.ratio ) * ( idealGear.flange_a.tau ) + idealGear.flange_b.tau
  ( inertia1.J ) * ( inertia1.a ) =  - ( torque.flange.tau ) - ( idealGear.flange_a.tau )

...
</programlisting>
  </section>
</chapter>
