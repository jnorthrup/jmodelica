<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch_simulation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Simulation</title>

  <section>
    <title>Introduction</title>

    <para>JModelica.org supports simulation of models described in the
    Modelica language and models following the FMI standard see <xref
    linkend="ch_fmi" />. The simulation environment uses <link
    linkend="???"><link
    xlink:href="http://www.jmodelica.org/assimulo">Assimulo</link></link> as
    standard which is a standalone Python package for solving ordinary
    differential and differential algebraic equations.</para>
  </section>

  <section>
    <title xml:id="sim_sec_first">A first example</title>

    <para>This example focus on how to use JModelica.org's simulation
    functionality in the most basic way. The model which is to be simulated is
    the Van der Pol problem described in <xref linkend="sim_list_vdp" />. The
    model is also available from the examples in the file VDP.mop.</para>

    <programlisting xml:id="sim_list_vdp">model VDP
    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0);
    Real x2(start = x2_0);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
  end VDP;</programlisting>

    <para>Create a new file in your working directory called
    <literal>VDP.mo</literal> and save the model. Note that this model is
    described as an ODE and can thus be simulated using ODE solvers from
    Assimulo.</para>

    <para>Next, create a Python script file and write or (copy paste) the
    commands for compiling and loading a model:</para>

    <programlisting># Import the function for compilation of models and the JMUModel class
from jmodelica.jmi import compile_jmu
from jmodelica.jmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt</programlisting>

    <para>Next, we compile and load the model:</para>

    <programlisting># Compile model
jmu_name = compile_jmu("VDP","VDP.mo")

# Load model
vdp = JMUModel(jmu_name)</programlisting>

    <para>The function <literal>compile_jmu</literal> compiles the model into
    a binary, which is then loaded when the <literal>vdp</literal> object is
    created. This object represents the compiled model and is used to invoke
    the simulation algorithm (for more information about model creations and
    options, see ###):</para>

    <programlisting>res = vdp.simulate(final_time=10)</programlisting>

    <para>In this case we use the default simulation algorithm together with
    default options, except for the final time which we set to 10. The result
    object can now be used to access in a dictionary-like way the simulation
    result:</para>

    <programlisting>x1 = res['x1']
x2 = res['x2']
t  = res['time']</programlisting>

    <para>The variable trajectories are returned as numpy arrays and can be
    used for further analysis of the simulation result or for
    visualization:</para>

    <programlisting>plt.figure(1)
plt.plot(t, x1, t, x2)
plt.legend(('x1','x2'))
plt.title('Van der Pol oscillator.')
plt.ylabel('Angle (rad)')
plt.xlabel('Time (s)')
plt.show()</programlisting>

    <para>In <xref linkend="sim_fig_vdp_res" /> the simulation result is
    shown.</para>

    <figure xml:id="sim_fig_vdp_res">
      <title>Simulation result of the Van der Pol oscillator.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/vdp_result.svg" scale="70"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Simulation of Models</title>

    <para>Simulation of models in JModelica.org is preformed via the simulate
    method of a model object. The model objects in JModelica.org are:</para>

    <itemizedlist>
      <listitem>
        <para><literal>JMUModel (located in jmodelica.jmi)</literal></para>
      </listitem>

      <listitem>
        <para><literal>FMUModel (located in jmodelica.fmi)</literal></para>
      </listitem>
    </itemizedlist>

    <para>The difference between the two are that <literal>JMUModel</literal>
    supports compiled models from JModelica.org (extension .jmu) while the
    <literal>FMUModel</literal> supports compiled models from other
    simulation/modelling tools that follows the FMI standard (extension .fmu).
    For more information about compiling a model in JModelica.org see
    ###.</para>

    <para>The simulation method is the preferred method for simulation of
    models and which by default is connected to the Assimulo simulation
    package but can also be connected to other simulation platforms. The
    simulation method for <literal>JMUModel</literal> is defined as:</para>

    <programlisting>class JMUModel(...)
    ...
    def simulate(self,
             start_time=0.0,
             final_time=1.0,
             input=(),
             algorithm='AssimuloAlg', 
             options={}):</programlisting>

    <para>And used in the following way:</para>

    <programlisting>res = JMUModel.simulate() #Using default values</programlisting>

    <para>The only difference between the simulation method in
    <literal>FMUModel</literal> is that the algorithm is
    <literal>AssimuloFMIAlg</literal>. They are although both connected to the
    Assimulo package and able to use its solvers with the limitation that the
    FMI standard only support ODEs.</para>

    <section>
      <title>Arguments</title>

      <para>The start and final time attributes are simply the time where the
      solver should start the integration and stop the integration. The input
      however is a bit more complex. The input defines the input trajectories
      to the model and should be a 2-tuple consisting of the name(s) of the
      input variables in the model and the second argument should be a data
      matrix with the time vector as the first column and second column should
      correspond to the first name in the in the first argument and so
      forth.</para>

      <para>For example, consider that we have a model with an input variable
      <literal>u1 and that the model should be driven by a sinus curve as
      input. Also we are interested in the interval 0 to 10.</literal></para>

      <programlisting>t = N.linspace(0.,10.,100) #Create one hundred evenly spaced points
u = N.sin(t) #Create the input vector
u_traj = N.transpose(N.hstack((t,u))) #Create the data matrix and transpose 
                                      #it to the correct form</programlisting>

      <para>The above code have created the data matrix that we are interested
      in giving to the model as input, we just need to connect the data to a
      specific input variable, <literal>u1</literal>:</para>

      <programlisting>input_model = ('u1', u_traj)</programlisting>

      <para>Now we are ready to simulate using the input and simulate 10
      seconds.</para>

      <programlisting>res = model.simulate(final_time=10, input=input_model)</programlisting>

      <para>If we on the other hand would have two input variables, u1 and u2
      the script would instead look like:</para>

      <programlisting>t = N.linspace(0.,10.,100) #Create one hundred evenly spaced points
u1 = N.sin(t) #Create the first input vector
u2 = N.cos(t) #Create the second input vector
u_traj = N.transpose(N.hstack((t,u1,u2))) #Create the data matrix and 
                                          #transpose it to the correct form

input_model = (['u1','u2'], u_traj)

res = model.simulate(final_time=10, input=input_model)</programlisting>

      <para>Note that the variables are now a List of variables.</para>

      <para>The algorithm attribute is where the different simulation package
      can be specified, however currently only a connection to Assimulo is
      supported and connected through the algorithm
      <literal>AssimuloAlg</literal> for <literal>JMUModel</literal> and
      <literal>AssimuloFMIAlg</literal> for
      <literal>FMUModel</literal>.</para>

      <section>
        <title>Options for JMUModel</title>

        <para>The options attribute are where options to the specified
        algorithm are stored and are preferably used together with:</para>

        <programlisting>opts = JMUModel.simulate_options()</programlisting>

        <para>which returns the default options for the default algorithm.
        Information about the available options can be viewed by typing help
        on the <literal>opts</literal> variable:</para>

        <programlisting>&gt;&gt;&gt; help(opts)
   Options for simulation of a JMU model using the Assimulo simulation package.
   The Assimulo package contain both explicit solvers (CVode) for ODEs and 
   implicit solvers (IDA) for DAEs. The ODE solvers require that the problem
   is written on the form, ydot = f(t,y).
   
   Assimulo options::
   
       solver     --
           Specifies the simulation algorithm that is to be used.
           Default 'IDA'
                
       ncp        --
           Number of communication points. If ncp is zero, the solver
           will return the internal steps taken.
           Default '0'
                
       initialize --
           If set to True, an algorithm for initializing the
           differential equation is invoked, otherwise the
           differential equation is assumed to have consistent
           initial conditions. 
           Default is True.
                
       write_scaled_result --
           Set this parameter to True to write the result to file without
           taking scaling into account. If the value of scaled is False,
           then the variable scaling factors of the model are used to
           reproduced the unscaled variable values.
           Default: False
   
   The different solvers provided by the Assimulo simulation package provides
   different options. These options are given in dictionaries with names
   consisting of the solver name concatenated by the string '_option'. The most
   common solver options are documented below, for a complete list of options
   see, http://www.jmodelica.org/assimulo
   
   Options for IDA::
   
       rtol    --
           The relative tolerance.
           Default 1.0e-6
                 
       atol    --
           The absolute tolerance.
           Default 1.0e-6
       
       maxord  --
           The maximum order of the solver. Can range between 1 to 5.
           Default 5
   
   Options for CVode::

       rtol    --
           The relative tolerance. 
           Default 1.0e-6
               
       atol    --
           The absolute tolerance.
           Default 1.0e-6
                 
       discr   --
           The discretization method. Can be either 'BDF' or 'Adams'
           Default 'BDF'
       
       iter    --
           The iteration method. Can be either 'Newton' or 'FixedPoint'
           Default 'Newton'
 </programlisting>

        <para>Lets look at an example, consider that you want to simulate a
        JMU model using the solver CVode together with changing the
        discretization method (discr) from BDF to Adams:</para>

        <programlisting>...
opts = model.simulate_options() #Retrieve the default options

opts['solver'] = 'CVode' #Change the solver from IDA to CVode

opts['CVode_options']['discr'] = 'Adams' #Change from using BDF to Adams

model.simulate(options=opts) #Pass in the options to simulate and simulate</programlisting>

        <para>It should also be noted from the above example the options
        regarding a specific solver, say the tolerances for
        <literal>CVode</literal> or <literal>IDA</literal>, should be stored
        in a double dictionary where the first is named after the solver
        concatenated with <literal>_options</literal>:</para>

        <programlisting>opts['CVode_options'] = {'atol':1.0e-6} #Options specific for CVode

#or

opts['IDA_options'] = {'atol':1.0e-6} #Options specific for IDA</programlisting>

        <para>More information regarding the solver options can be found here,
        http://www.jmodelica.org/assimulo and a selection of solver arguments
        for the ODE solver CVode can be found in <xref
        linkend="sim_table_cvode" /> and for the DAE solver IDA in <xref
        linkend="sim_table_ida" />.</para>

        <table xml:id="sim_table_cvode">
          <title>Selection of solver arguments for CVode</title>

          <tgroup cols="2" xml:id="sim_table_cvode">
            <thead>
              <row>
                <entry align="center">Argument</entry>

                <entry align="center">Option</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>discr (The discretization method)</entry>

                <entry>'BDF' or 'Adams'</entry>
              </row>

              <row>
                <entry>iter (The iteration method)</entry>

                <entry>'Newton' or 'FixedPoint'</entry>
              </row>

              <row>
                <entry>maxord (The maximum order used)</entry>

                <entry>Integer of max 5 (BDF) or 12 (Adams)</entry>
              </row>

              <row>
                <entry>maxh (Maximum step-size)</entry>

                <entry>Positive float</entry>
              </row>

              <row>
                <entry>atol (Absolute Tolerance)</entry>

                <entry>Array of floats or Float</entry>
              </row>

              <row>
                <entry>rtol (Relative Tolerance)</entry>

                <entry>Float</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table xml:id="sim_table_ida">
          <title>Selection of solver arguments for IDA</title>

          <tgroup cols="2">
            <thead>
              <row>
                <entry align="center">Argument</entry>

                <entry align="center">Option</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>maxord (The maximum order used)</entry>

                <entry>Integer of max 5</entry>
              </row>

              <row>
                <entry>maxh (Maximum step-size)</entry>

                <entry>Positive float</entry>
              </row>

              <row>
                <entry>atol (Absolute Tolerance)</entry>

                <entry>Array of floats or Float</entry>
              </row>

              <row>
                <entry>rtol (Relative Tolerance)</entry>

                <entry>Float</entry>
              </row>

              <row>
                <entry>suppress_alg (Suppress the algebraic variables on the
                error test)</entry>

                <entry>Boolean</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Options for FMUModel</title>

        <para>The options attribute are where options to the specified
        algorithm are stored and are preferably used together with:</para>

        <programlisting>opts = FMUModel.simulate_options()</programlisting>

        <para>which returns the default options for the default algorithm.
        Information about the available options can be viewed by typing help
        on the <literal>opts</literal> variable:</para>

        <programlisting>&gt;&gt;&gt; help(opts)
   Options for the solving the FMU using the Assimulo simulation package.
   Currently, the only solver in the Assimulo package that fully supports
   simulation of FMUs is the solver CVode.
   
   Assimulo options::
   
       solver --
           Specifies the simulation algorithm that is to be used. Currently the 
           only supported solver is 'CVode'.
           Default: 'CVode'
                
       ncp    --
           Number of communication points. If ncp is zero, the solver will 
           return the internal steps taken.
           Default: '0'
           
       initialize --
           If set to True, the initializing algorithm defined in the FMU model
           is invoked, otherwise it is assumed the user have manually invoked
           model.initialize()
           Default is True.
   
       write_scaled_result --
           Set this parameter to True to write the result to file without
           taking scaling into account. If the value of scaled is False,
           then the variable scaling factors of the model are used to
           reproduced the unscaled variable values.
           Default: False
                
   The different solvers provided by the Assimulo simulation package provides
   different options. These options are given in dictionaries with names
   consisting of the solver name concatenated by the string '_option'. The most
   common solver options are documented below, for a complete list of options
   see, http://www.jmodelica.org/assimulo
   
   Options for CVode::
   
       rtol    -- 
           The relative tolerance. The relative tolerance are retrieved from
           the 'default experiment' section in the XML-file and if not
           found are set to 1.0e-4
           Default: 1.0e-4
           
       atol    --
           The absolute tolerance.
           Default: rtol*0.01*(nominal values of the continuous states)
       
       discr   --
           The discretization method. Can be either 'BDF' or 'Adams'
           Default: 'BDF'
       
       iter    --
           The iteration method. Can be either 'Newton' or 'FixedPoint'
           Default: 'Newton'
</programlisting>

        <para>Lets look at an example, consider that you want to simulate a
        FMU model using the solver CVode together with changing the
        discretization method (discr) from BDF to Adams and that you have
        already initialized the model:</para>

        <programlisting>...
opts = model.simulate_options() #Retrieve the default options

#opts['solver'] = 'CVode' #Not necessary, default solver is CVode

opts['CVode_options']['discr'] = 'Adams' #Change from using BDF to Adams

opts['initialize'] = False #Dont initialize the model

model.simulate(options=opts) #Pass in the options to simulate and simulate</programlisting>

        <para>It should also be noted from the above example the options
        regarding a specific solver, say the tolerances for
        <literal>CVode</literal>, should be stored in a double dictionary
        where the first is named after the solver concatenated with
        <literal>_options</literal>:</para>

        <programlisting>opts['CVode_options'] = {'atol':1.0e-6} #Options specific for CVode
</programlisting>

        <para>More information regarding the solver options can be found here,
        http://www.jmodelica.org/assimulo and a selection of solver arguments
        for the ODE solver CVode can be found in <xref
        linkend="sim_table_cvode" />.</para>
      </section>
    </section>

    <section>
      <title>Return argument</title>

      <para>The return argument from the simulate method is an object derived
      from a common result object <literal>ResultBase</literal> in
      algorithm_drivers.py with a few extra convenience methods for retrieving
      the result of a variable. The result object can be accessed in the same
      way as a dictionary type in Python with the name of the variable as
      key.</para>

      <programlisting>res = model.simulate()

y = res['y'] #Return the result for the variable/parameter/constant y
dery = res['der(y)'] #Return the result for the variable/parameter/constant der(y)</programlisting>

      <para>This can be done for all the variables, parameters and constants
      defined in the model and is the preferred way of retrieving the result.
      There are however some more options available in the result object, see
      <xref linkend="sim_table_result" />.</para>

      <table xml:id="sim_table_result">
        <title>Result Object</title>

        <tgroup cols="2">
          <thead>
            <row>
              <entry align="center">Option</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>options (Property)</entry>

              <entry>Gets the options object that was used during the
              simulation.</entry>
            </row>

            <row>
              <entry>solver (Property)</entry>

              <entry>Gets the solver that was used during the
              integration.</entry>
            </row>

            <row>
              <entry>result_file (Property)</entry>

              <entry>Gets the name of the generated result file.</entry>
            </row>

            <row>
              <entry>is_variable(name)</entry>

              <entry>Returns True if the given name is a time-varying
              variable.</entry>
            </row>

            <row>
              <entry>data_matrix (Property)</entry>

              <entry>Gets the raw data matrix.</entry>
            </row>

            <row>
              <entry>is_negated(name)</entry>

              <entry>Returns True if the given name is negated in the result
              matrix.</entry>
            </row>

            <row>
              <entry>get_column(name)</entry>

              <entry>Returns the column number in the data matrix which
              corresponds to the given variable.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>In the next sections, it will be shown how to use the JModelica.org
    platform for simulation of various JMUs and FMUs.</para>

    <para>The Python commands in these examples may be copied and pasted
    directly into a Python shell, in some cases with minor modifications.
    Alternatively, they may be copied into a text file, which also is the
    recommended way.</para>

    <section>
      <title>Simulation with inputs</title>

      <para>This example will demonstrate how a model with two inputs with
      data from a matlab-file can be simulated. The model to be simulated is a
      quadruple tank connected to two pumps, which is also the inputs to the
      model. The model is depicted in <xref linkend="sim_fig_quadtank" /> and
      in <xref linkend="sim_list_qt" /> the corresponding Modelica code is
      listed.</para>

      <figure xml:id="sim_fig_quadtank">
        <title></title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/qt_schematic.png" scalefit="1"
                       width="40%"></imagedata>
          </imageobject>
        </mediaobject>

        <caption>
          <para>A schematic picture of the quadruple tank process.</para>
        </caption>
      </figure>

      <programlisting xml:id="sim_list_qt">model QuadTank
    // Process parameters
  parameter Modelica.SIunits.Area A1=4.9e-4, A2=4.9e-4, A3=4.9e-4, A4=4.9e-4;
  parameter Modelica.SIunits.Area a1=0.03e-4, a2=0.03e-4, a3=0.03e-4, a4=0.03e-4;
  parameter Modelica.SIunits.Acceleration g=9.81;
  parameter Real k1_nmp(unit="m3^/s/V") = 0.56e-6, k2_nmp(unit="m^3/s/V") = 0.56e-6;
  parameter Real g1_nmp=0.30, g2_nmp=0.30;

   // Initial tank levels
  parameter Modelica.SIunits.Length x1_0 = 0.06270;
  parameter Modelica.SIunits.Length x2_0 = 0.06044;
  parameter Modelica.SIunits.Length x3_0 = 0.02400;
  parameter Modelica.SIunits.Length x4_0 = 0.02300;

   // Tank levels
  Modelica.SIunits.Length x1(start=x1_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x2(start=x2_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x3(start=x3_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x4(start=x4_0,min=0.0001/*,max=0.20*/);

  // Inputs
  input Modelica.SIunits.Voltage u1;
  input Modelica.SIunits.Voltage u2;

 equation
   der(x1) = -a1/A1*sqrt(2*g*x1) + a3/A1*sqrt(2*g*x3) +
                                   g1_nmp*k1_nmp/A1*u1;
   der(x2) = -a2/A2*sqrt(2*g*x2) + a4/A2*sqrt(2*g*x4) +
                                   g2_nmp*k2_nmp/A2*u2;
   der(x3) = -a3/A3*sqrt(2*g*x3) + (1-g2_nmp)*k2_nmp/A3*u2;
   der(x4) = -a4/A4*sqrt(2*g*x4) + (1-g1_nmp)*k1_nmp/A4*u1;

end QuadTank;</programlisting>

      <para>Lets begin with the the example, copy and paste the Modelica code
      and save it into <literal>QuadTank.mo</literal> and open a python script
      file. We start by importing the necessary objects:</para>

      <programlisting>from scipy.io.matlab.mio import loadmat
import matplotlib.pyplot as plt
import numpy as N

from jmodelica.jmi import compile_jmu
from jmodelica.jmi import JMUModel</programlisting>

      <para>The input data is stored in <literal>qt_par_est_data.mat</literal>
      which can be found in the <literal>examples/files</literal> catalogue in
      JModelica.org. Copy it into your working directory and paste the
      following commands to load the data-file and extract the data
      trajectories: </para>

      <programlisting>data = loadmat('qt_par_est_data.mat',appendmat=False)

# Extract data series  
t_meas = data['t'][6000::100,0]-60  
u1 = data['u1_d'][6000::100,0]
u2 = data['u2_d'][6000::100,0]</programlisting>

      <para>The trajectories have now been extracted and needs to be stacked
      into a data matrix with the first column as the time vector and the
      following columns the input of <literal>u1</literal> and
      <literal>u2</literal>. The names of the variables needs also be
      connected in the input object:</para>

      <programlisting># Build input trajectory matrix for use in simulation
u_data = N.transpose(N.vstack((t_meas,u1,u2)))
input_object = (['u1','u2'], u_data)</programlisting>

      <para>Next, we compile and load the model:</para>

      <programlisting># compile JMU
jmu_name = compile_jmu('QuadTank', 'QuadTank.mo')

# Load model
model = JMUModel(jmu_name)</programlisting>

      <para>Now, that the model is compiled and the input have been adapted,
      lets give the information to the simulate method and simulate:</para>

      <programlisting># Simulate model with input trajectories
res = model.simulate(final_time=60, input=input_object)</programlisting>

      <para>The result is retrieved by accessing the <literal>res</literal>
      variable as a dictionary with the variable name as key:</para>

      <programlisting>x1_sim = res['x1']
x2_sim = res['x2']
x3_sim = res['x3']
x4_sim = res['x4']
u1_sim = res['u1']
u2_sim = res['u2']
t_sim  = res['time']</programlisting>

      <para>And then plotted with the help from
      <literal>matplotlib</literal>:</para>

      <programlisting>plt.figure(1)
plt.subplot(2,2,1)
plt.plot(t_sim,x3_sim)
plt.title('x3')
plt.subplot(2,2,2)
plt.plot(t_sim,x4_sim)
plt.title('x4')
plt.subplot(2,2,3)
plt.plot(t_sim,x1_sim)
plt.title('x1')
plt.xlabel('t[s]')
plt.subplot(2,2,4)
plt.plot(t_sim,x2_sim)
plt.title('x2')
plt.xlabel('t[s]')
plt.show()

plt.figure(2)
plt.subplot(2,1,1)
plt.plot(t_sim,u1_sim,'r')
plt.title('u1')
plt.subplot(2,1,2)
plt.plot(t_sim,u2_sim,'r')
plt.title('u2')
plt.xlabel('t[s]')
plt.show()</programlisting>

      <para>In <xref linkend="sim_fig_qt_x" /> the result of the tank levels
      are shown and in <xref linkend="sim_fig_qt_u" /> the input signals are
      shown.</para>

      <figure xml:id="sim_fig_qt_x">
        <title>Tank levels</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/quadtank_x.svg" scale="70"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure xml:id="sim_fig_qt_u">
        <title>Input trajectories</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/quadtank_u.svg" scale="70"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation of an ODE</title>

      <para>Simulation of ODEs in JModelica.org is currently limited to models
      written explicitly on the form:</para>

      <equation>
        <m:math display="block">
          <m:mrow>
            <m:mover>
              <m:mi>y</m:mi>

              <m:mo>.</m:mo>
            </m:mover>

            <m:mo>=</m:mo>

            <m:mi>f(t,y)</m:mi>
          </m:mrow>
        </m:math>
      </equation>

      <para>An example is the Van der Pol oscillator described in <xref
      linkend="sim_sec_first" />. In <xref linkend="sim_list_vdp2" /> it is
      shown again for convenience.</para>

      <programlisting xml:id="sim_list_vdp2">model VDP
    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0);
    Real x2(start = x2_0);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
end VDP;</programlisting>

      <para>We see here that the state derivatives are written on the left
      hand side while the equations are written on the right hand side. There
      is also a limitation that events are currently not handled.</para>

      <para>Lets begin with the the example, copy and paste the Modelica code
      and save it into <literal>VDP.mo</literal> and open a python script
      file. We start by importing the necessary objects:</para>

      <programlisting># Import the function for compilation of models and the JMUModel class
from jmodelica.jmi import compile_jmu
from jmodelica.jmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt</programlisting>

      <para>Next, we compile and load the model:</para>

      <programlisting># Compile model
jmu_name = compile_jmu("VDP","VDP.mo")

# Load model
vdp = JMUModel(jmu_name)</programlisting>

      <para>Now we would like to change the default solver IDA to the ODE
      solver CVode and also change the relative tolerance to 0.0001. First we
      retrieve the default options and then change the option:</para>

      <programlisting>opts = vdp.simulate_options() #Retrieve the default options

opts['solver'] = 'CVode' #Change the solver to CVode
opts['CVode_options']['rtol'] = 0.0001 #Change the relative tolerance for CVode</programlisting>

      <para>Now lets simulate the problem ten seconds:</para>

      <programlisting>res = vdp.simulate(final_time=10, options=opts)</programlisting>

      <para>The result is retrieved by accessing the <literal>res</literal>
      variable as a dictionary with the variable name as key:</para>

      <programlisting>x1 = res['x1']
x2 = res['x2']
t  = res['time']</programlisting>

      <para>The variable trajectories are returned as numpy arrays and can be
      used for further analysis of the simulation result or for
      visualization:</para>

      <programlisting>plt.figure(1)
plt.plot(t, x1, t, x2)
plt.legend(('x1','x2'))
plt.title('Van der Pol oscillator.')
plt.ylabel('Angle (rad)')
plt.xlabel('Time (s)')
plt.show()</programlisting>

      <para>In <xref linkend="sim_fig_cvode_vdp" /> the simulation result is
      shown.</para>

      <figure xml:id="sim_fig_cvode_vdp">
        <title>Simulation result of the Van der Pol oscillator.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/vdp_cvode.svg" scale="70"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation of a discontinuous system</title>

      <para>The model which is to be simulated is an electric circuit. The
      model is depicted in <xref linkend="sim_fig_rlc" /> and consists of
      resistances, inductors and a capacitor. The circuit is connected to a
      voltage source which generates a square-wave with an amplitude of 1.0
      and a frequency of 0.6 Hz. The model is also available from the examples
      in the file RLC_Circuit.mo.</para>

      <figure xml:id="sim_fig_rlc">
        <title>Electric Circuit</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RLC.png" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This examples assumes that the file
      <literal>RLC_Circuit.mo</literal> is located in the working
      directory.</para>

      <para>Start by creating a Python script file and write or (copy paste)
      the command for importing the model object and for compiling a model
      together with the library used for plotting:</para>

      <programlisting language="Python"># Import the function for compilation of models and the JMUModel class
from jmodelica.jmi import compile_jmu
from jmodelica.jmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt</programlisting>

      <para>Next, we compile and load the model:</para>

      <programlisting># Compile model
jmu_name = compile_jmu("RLC_Circuit_Square","RLC_Circuit.mo")

# Load model
rlc = JMUModel(jmu_name)</programlisting>

      <para>Now we are ready to simulate our model. We are interested in
      simulating the model from 0.0 to 20.0 seconds. The start time is default
      to 0.0 so no need to change that, but the final time needs to be
      changed:</para>

      <programlisting>res = rlc.simulate(final_time=20.0) #Simulate the model from 0.0 to 20.0 seconds</programlisting>

      <para>After a successful simulation the statistics are printed in the
      prompt and the results are stored in the variable 'res'. To view the
      result, we have to retrieve information about the variables we are
      interested of. This is easily done in the following way,</para>

      <programlisting>square_y    = res['square.y']
resistor_v  = res['resistor.v']
inductor1_i = res['inductor1.i']
time        = res['time']</programlisting>

      <para>And then plotted with the help from
      <literal>matplotlib</literal>,</para>

      <programlisting>plt.figure(1)
plt.plot(time, square_y, time, resistor_v, time, inductor1_i)    
plt.legend(('square.y','resistor.v','inductor1.i'))
plt.show()</programlisting>

      <para>The simulation result is shown in <xref
      linkend="sim_fig_rlc_res" />.</para>

      <figure xml:id="sim_fig_rlc_res">
        <title>Simulation result</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Result_RLC.svg" scalefit="1"
                       width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation and parameter sweeps</title>

      <para>This tutorial demonstrates how to run multiple simulations with
      different parameter values. Sweeping parameters is a useful technique
      for analysing model sensitivity with respect to uncertainty in physical
      parameters or initial conditions. Consider the following model of the
      Van der Pol oscillator:</para>

      <programlisting>  model VDP
    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0);
    Real x2(start = x2_0);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
  end VDP;</programlisting>

      <para>Notice that the initial values of the states are parametrized by
      the parameters <literal>x1_0</literal> and <literal>x2_0</literal>.
      Next, copy the Modelica code above into a file VDP.mo and save it in
      your working directory. Also, create a Python script file and name it
      vdp_pp.py. Start by copying the commands:</para>

      <programlisting>import numpy as N
import pylab as p
from jmodelica.jmi import compile_jmu, JMUModel</programlisting>

      <para>into the Python file. Compile and load the model:</para>

      <programlisting># Define model file name and class name
model_name = 'VDP'
mofile = 'VDP.mo'

# Compile model
jmu_name = compile_jmu("VDP","VDP.mo")

# Load model
vdp = JMUModel(jmu_name)
</programlisting>

      <para>Next, we define the initial conditions for which the parameter
      sweep will be done. The state <literal>x2</literal> starts at 0, whereas
      the initial condition for <literal>x1</literal> is swept between -3 and
      3:</para>

      <programlisting># Define initial conditions
N_points = 11
x1_0 = N.linspace(-3.,3.,N_points)
x2_0 = N.zeros(N_points)</programlisting>

      <para>In order to visualize the results of the simulations, we open a
      plot window:</para>

      <programlisting>fig = p.figure()
p.clf()
p.hold(True)
p.xlabel('x1')
p.ylabel('x2')</programlisting>

      <para>The actual parameter sweep is done by looping over the initial
      condition vectors and in each iteration set the parameter values into
      the model, simulate and plot:</para>

      <programlisting>for i in range(N_points):
    # Set initial conditions in model
    model.set('x1_0',x1_0[i])
    model.set('x2_0',x2_0[i])
    # Simulate 
    res = model.simulate(final_time=20)
    # Get simulation result
    x1=res['x1']
    x2=res['x2']
    # Plot simulation result in phase plane plot
    p.plot(x1.x, x2.x,'b')
p.grid()
p.show()</programlisting>

      <para>You should now see a plot like in <xref
      linkend="sim_fig_psweep" />.</para>

      <figure xml:id="sim_fig_psweep">
        <title>Simulation result-phase plane</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/vdp_pp.png" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation of an FMU</title>

      <para>This example will show how to use the JModelica.org's
      FMI-interface together with its simulation package, Assimulo. The FMU to
      be simulated is the full Robot from the Modelica standard library (3.1)
      where it is located in
      <literal>Mechanics.MultiBody.Examples.Systems.RobotR3</literal>. It
      consists of brakes, motors, gears and path planning. The model consists
      of 36 continuous states and around 700 algebraic variables together with
      98 event functions and also a few thousand constants/parameters. The FMU
      was generated using Dymola 7.4.</para>

      <figure xml:id="sim_fig_rob">
        <title>Full Robot</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fullRobot.png" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This examples assumes that an FMU of the robot named
      <literal>Modelica_Mechanics_MultiBody_Examples_Systems_RobotR3_fullRobot.fmu</literal>
      exists in the working folder.</para>

      <para>Start by creating a Python script file and write or (copy paste)
      the command for importing the model object and the library used for
      plotting:</para>

      <programlisting language="Python"># Import the FMUModel class
from jmodelica.fmi import FMUModel

# Import the plotting library
import matplotlib.pyplot as plt</programlisting>

      <para>Next, we load the FMU into the model object:</para>

      <programlisting>robot = FMUModel('Modelica_Mechanics_MultiBody_Examples_Systems_RobotR3_fullRobot.fmu')</programlisting>

      <para>We are interested in simulating the Robot from time 0.0 to 1.8
      using 1000 communication points and using tolerances specified in the
      FMU. This information is specified to the simulate method:</para>

      <programlisting>res = robot.simulate(start_time=0.0, final_time=1.8, options={'ncp':1000})</programlisting>

      <para>This preforms the simulation and the statistics will be printed in
      the prompt.</para>

      <para>To retrieve data about a variable from the result data, access it
      as a dictionary with the name of the variable as key.</para>

      <programlisting language="Python">dq1  = res['der(mechanics.q[1])']
dq6  = res['der(mechanics.q[6])']
time = res['time']</programlisting>

      <para>Now we have loaded and retrieved the variables of interest. So
      lets plot them.</para>

      <programlisting language="Python">plt.plot(time,dq1,time,dq6)
plt.legend(['der(mechanics.q[1])','der(mechanics.q[6])'])
plt.xlabel('Time (s)')
plt.ylabel('Joint Velocity (rad/s)')
plt.title('Full Robot')
plt.show()</programlisting>

      <para>In <xref linkend="sim_fig_rob_res" /> the result is shown and in
      <xref linkend="sim_fig_rob_dym" /> a comparison between Dymola and
      JModelica.org is plotted.</para>

      <figure xml:id="sim_fig_rob_res">
        <title>Robot Results</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/robot_result.svg" scalefit="1"
                       width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure xml:id="sim_fig_rob_dym">
        <title>Comparison with Dymola</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DymolaFullRobotComparison.png"
                       scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>
</chapter>
