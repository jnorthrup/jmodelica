<HTML>
<HEAD>
<TITLE>Modelica.Utilities.Strings</TITLE>
<META name="HTML-Generator" content="Dymola">
<META name="description" content="&quot;Operations on strings&quot;">
<style type="text/css">
*       { font-size: 10pt; font-family: Arial,sans-serif; }
pre     { font-size:  9pt; font-family: Courier,monospace;}
h4      { font-size: 10pt; font-weight: bold; color: green; }
h3      { font-size: 11pt; font-weight: bold; color: green; }
h2      { font-size: 13pt; font-weight: bold; color: green; }
address {                  font-weight: normal} 
td      { solid #000; vertical-align:top; }
th      { solid #000; vertical-align:top; font-weight: bold; }
table   { solid #000; border-collapse: collapse;}
</style>
</HEAD>
<BODY><P>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE Strings<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><A NAME="Modelica.Utilities.Strings"></A><A HREF="Modelica_Utilities.html#Modelica.Utilities"
>Modelica.Utilities</A>.Strings</H2>
<B>Operations on strings</B>
<P>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Library content</h4>
<p>
Package <b>Strings</b> contains functions to manipulate strings.
</p>
<p>
In the table below an example
call to every function is given using the <b>default</b> options.
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><th><b><i>Function</i></b></th><th><b><i>Description</i></b></th></tr>
  <tr><td valign="top">len = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.length"
>length</a>(string)</td>
      <td valign="top">Returns length of string</td></tr>
  <tr><td valign="top">string2 = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.substring"
>substring</a>(string1,startIndex,endIndex)
       </td>
      <td valign="top">Returns a substring defined by start and end index</td></tr>
  <tr><td valign="top">result = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.repeat"
>repeat</a>(n)<br>
 result = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.repeat"
>repeat</a>(n,string)</td>
      <td valign="top">Repeat a blank or a string n times.</td></tr>
  <tr><td valign="top">result = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.compare"
>compare</a>(string1, string2)</td>
      <td valign="top">Compares two substrings with regards to alphabetical order</td></tr>
  <tr><td valign="top">identical =
<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual"
>isEqual</a>(string1,string2)</td>
      <td valign="top">Determine whether two strings are identical</td></tr>
  <tr><td valign="top">result = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.count"
>count</a>(string,searchString)</td>
      <td valign="top">Count the number of occurrences of a string</td></tr>
  <tr>
<td valign="top">index = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.find"
>find</a>(string,searchString)</td>
      <td valign="top">Find first occurrence of a string in another string</td></tr>
<tr>
<td valign="top">index = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.findLast"
>findLast</a>(string,searchString)</td>
      <td valign="top">Find last occurrence of a string in another string</td></tr>
  <tr><td valign="top">string2 = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.replace"
>replace</a>(string,searchString,replaceString)</td>
      <td valign="top">Replace one or all occurrences of a string</td></tr>
  <tr><td valign="top">stringVector2 = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.sort"
>sort</a>(stringVector1)</td>
      <td valign="top">Sort vector of strings in alphabetic order</td></tr>
  <tr><td valign="top">(token, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanToken"
>scanToken</a>(string,startIndex)</td>
      <td valign="top">Scan for a token (Real/Integer/Boolean/String/Identifier/Delimiter/NoToken)</td></tr>
  <tr><td valign="top">(number, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanReal"
>scanReal</a>(string,startIndex)</td>
      <td valign="top">Scan for a Real constant</td></tr>
  <tr><td valign="top">(number, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanInteger"
>scanInteger</a>(string,startIndex)</td>
      <td valign="top">Scan for an Integer constant</td></tr>
  <tr><td valign="top">(boolean, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanBoolean"
>scanBoolean</a>(string,startIndex)</td>
      <td valign="top">Scan for a Boolean constant</td></tr>
  <tr><td valign="top">(string2, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanString"
>scanString</a>(string,startIndex)</td>
      <td valign="top">Scan for a String constant</td></tr>
  <tr><td valign="top">(identifier, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanIdentifier"
>scanIdentifier</a>(string,startIndex)</td>
      <td valign="top">Scan for an identifier</td></tr>
  <tr><td valign="top">(delimiter, index) = <A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanDelimiter"
>scanDelimiter</a>(string,startIndex)</td>
      <td valign="top">Scan for delimiters</td></tr>
  <tr><td valign="top"><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanNoToken"
>scanNoToken</a>(string,startIndex)</td>
      <td valign="top">Check that remaining part of string consists solely of <br>
          white space or line comments ("// ...\n").</td></tr>
  <tr><td valign="top"><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.syntaxError"
>syntaxError</a>(string,index,message)</td>
      <td valign="top"> Print a "syntax error message" as well as a string and the <br>
           index at which scanning detected an error</td></tr>
</table>
<p>
The functions "compare", "isEqual", "count", "find", "findLast", "replace", "sort"
have the optional
input argument <b>caseSensitive</b> with default <b>true</b>.
If <b>false</b>, the operation is carried out without taking
into account whether a character is upper or lower case.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons_Library.html#Modelica.Icons.Library"
>Modelica.Icons.Library</A> (Icon for library).
<P><H3>Package Content</H3><p>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2 >
<TR><TH >Name</TH><TH>Description</TH></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.length" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.length"
>length</A>
</TD><TD>Returns length of string</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.substring" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.substring"
>substring</A>
</TD><TD>Returns a substring defined by start and end index</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.repeat" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.repeat"
>repeat</A>
</TD><TD>Repeat a string n times</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.compare" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.compare"
>compare</A>
</TD><TD>Compare two strings lexicographically</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.isEqual" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.isEqual"
>isEqual</A>
</TD><TD>Determine whether two strings are identical</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.count" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.count"
>count</A>
</TD><TD>Count the number of non-overlapping occurrences of a string</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.find" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.find"
>find</A>
</TD><TD>Find first occurrence of a string within another string</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.findLast" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.findLast"
>findLast</A>
</TD><TD>Find last occurrence of a string within another string</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.replace" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.replace"
>replace</A>
</TD><TD>Replace non-overlapping occurrences of a string from left to right</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.sort" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.sort"
>sort</A>
</TD><TD>Sort vector of strings in alphabetic order</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanToken" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanToken"
>scanToken</A>
</TD><TD>Scan for the next token and return it</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanReal" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanReal"
>scanReal</A>
</TD><TD>Scan for the next Real number and trigger an assert if not present</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanInteger" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanInteger"
>scanInteger</A>
</TD><TD>Scan for the next Integer number and trigger an assert if not present</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanBoolean" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanBoolean"
>scanBoolean</A>
</TD><TD>Scan for the next Boolean number and trigger an assert if not present</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanString" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanString"
>scanString</A>
</TD><TD>Scan for the next Modelica string and trigger an assert if not present</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanIdentifier" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanIdentifier"
>scanIdentifier</A>
</TD><TD>Scan for the next Identifier and trigger an assert if not present</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanDelimiter" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanDelimiter"
>scanDelimiter</A>
</TD><TD>Scan for the next delimiter and trigger an assert if not present</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.scanNoToken" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.scanNoToken"
>scanNoToken</A>
</TD><TD>Scan string and check that it contains no more token</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Files.listS.png" ALT="Modelica.Utilities.Strings.syntaxError" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings.syntaxError"
>syntaxError</A>
</TD><TD>Print an error message, a string and the index at which scanning detected an error</TD></TR>
<TR><TD><IMG SRC="Modelica.Utilities.Strings.AdvancedS.png" ALT="Modelica.Utilities.Strings.Advanced" WIDTH=20  HEIGHT=20 ALIGN = TOP >&nbsp;<A HREF="Modelica_Utilities_Strings_Advanced.html#Modelica.Utilities.Strings.Advanced"
>Advanced</A>
</TD><TD>Advanced scanning functions</TD></TR>
</TABLE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE length<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.length" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.length"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.length</H2>
<B>Returns length of string</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>length</b>(string);
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of characters of "string".
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>Number of characters of string</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> length <font color="darkgreen">&quot;Returns length of string&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string;
  <font color="blue">output </font>Integer result <font color="darkgreen">&quot;Number of characters of string&quot;</font>;
<font color="blue">external</font> &quot;C&quot; result = <font color="red">ModelicaStrings_length</font>(string);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>length;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE substring<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.substring" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.substring"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.substring</H2>
<B>Returns a substring defined by start and end index</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<b>substring</b>(string, startIndex, endIndex);
</pre></blockquote>
<h4>Description</h4>
<p>
This function returns
the substring from position startIndex
up to and including position endIndex of "string" .
</p>
<p>
If index, startIndex, or endIndex are not correct, e.g.,
if endIndex &gt; length(string), an assert is triggered.
</p>
<h4>Example</h4>
<blockquote><pre>
  string1 := "This is line 111";
  string2 := Strings.substring(string1,9,12); // string2 = "line"
</pre></blockquote>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String from which a substring is inquired</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>&nbsp;</TD><TD>Character position of substring begin (index=1 is first character in string)</TD></TR>
<TR><TD>Integer</TD><TD>endIndex</TD><TD>&nbsp;</TD><TD>Character position of substring end</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>result</TD><TD>String containing substring string[startIndex:endIndex]</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> substring <font color="darkgreen">
  &quot;Returns a substring defined by start and end index&quot;</font>

  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String from which a substring is inquired&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1) <font color="darkgreen">
    &quot;Character position of substring begin (index=1 is first character in string)&quot;</font>;
  <font color="blue">input </font>Integer endIndex(min=1) <font color="darkgreen">&quot;Character position of substring end&quot;</font>;
  <font color="blue">output </font>String result <font color="darkgreen">
    &quot;String containing substring string[startIndex:endIndex]&quot;</font>;
<font color="blue">external</font> &quot;C&quot; result=<font color="red">ModelicaStrings_substring</font>(string,startIndex,endIndex);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>substring;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE repeat<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.repeat" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.repeat"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.repeat</H2>
<B>Repeat a string n times</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
string2 = Strings.<b>repeat</b>(n);
string2 = Strings.<b>repeat</b>(n, string=" ");
</pre></blockquote>
<h4>Description</h4>
<p>
The first form returns a string consisting of n blanks.
</p>
<p>
The second form returns a string consisting of n substrings
defined by the optional argument "string".
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>n</TD><TD>1</TD><TD>Number of occurences</TD></TR>
<TR><TD>String</TD><TD>string</TD><TD>&quot; &quot;</TD><TD>String that is repeated</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>repeatedString</TD><TD>String containing n concatenated strings</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> repeat <font color="darkgreen">&quot;Repeat a string n times&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>Integer n(min=0) = 1 <font color="darkgreen">&quot;Number of occurences&quot;</font>;
  <font color="blue">input </font>String string=&quot; &quot; <font color="darkgreen">&quot;String that is repeated&quot;</font>;
  <font color="blue">output </font>String repeatedString <font color="darkgreen">&quot;String containing n concatenated strings&quot;</font>;
<font color="blue">algorithm </font>
  repeatedString :=&quot;&quot;;
  <font color="blue">for </font>i<font color="blue"> in </font>1:n<font color="blue"> loop</font>
     repeatedString := repeatedString + string;
  <font color="blue">end for</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>repeat;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE compare<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.compare" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.compare"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.compare</H2>
<B>Compare two strings lexicographically</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
result = Strings.<b>compare</b>(string1, string2);
result = Strings.<b>compare</b>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compares two strings. If the optional argument caseSensitive=false,
upper case letters are treated as if they would be lower case letters.
The result of the comparison is returned as:
</p>
<pre>
  result = Modelica.Utilities.Types.Compare.Less     // string1 &lt; string2
         = Modelica.Utilities.Types.Compare.Equal    // string1 = string2
         = Modelica.Utilities.Types.Compare.Greater  // string1 &gt; string2
</pre>
<p>
Comparison is with regards to lexicographical order,
e.g., "a" &lt; "b";
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>String</TD><TD>string2</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if case of letters is ignored</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Utilities_Types.html#Modelica.Utilities.Types.Compare"
>Compare</A></TD><TD>result</TD><TD>Result of comparison</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> compare <font color="darkgreen">&quot;Compare two strings lexicographically&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string1;
  <font color="blue">input </font>String string2;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">&quot;= false, if case of letters is ignored&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_Utilities_Types.html#Modelica.Utilities.Types.Compare"
>Modelica.Utilities.Types.Compare</A> result <font color="darkgreen">&quot;Result of comparison&quot;</font>;
<font color="blue">external</font> &quot;C&quot; result = <font color="red">ModelicaStrings_compare</font>(string1, string2, caseSensitive);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>compare;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE isEqual<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.isEqual" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.isEqual"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.isEqual</H2>
<B>Determine whether two strings are identical</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>isEqual</b>(string1, string2);
Strings.<b>isEqual</b>(string1, string2, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Compare whether two strings are identical,
optionally ignoring case.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string1</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>String</TD><TD>string2</TD><TD>&nbsp;</TD><TD>&nbsp;</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if lower and upper case are ignored for the comparison</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>identical</TD><TD>True, if string1 is identical to string2</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> isEqual <font color="darkgreen">&quot;Determine whether two strings are identical&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string1;
  <font color="blue">input </font>String string2;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">
    &quot;= false, if lower and upper case are ignored for the comparison&quot;</font>;
  <font color="blue">output </font>Boolean identical <font color="darkgreen">&quot;True, if string1 is identical to string2&quot;</font>;
<font color="blue">algorithm </font>
  identical :=<font color="red">compare</font>(string1, string2, caseSensitive) == Types.Compare.Equal;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>isEqual;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE count<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.count" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.count"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.count</H2>
<B>Count the number of non-overlapping occurrences of a string</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>count</b>(string, searchString)
Strings.<b>count</b>(string, searchString, startIndex=1,
                     caseSensitive=true)
</pre></blockquote>
<h4>Description</h4>
<p>
Returns the number of non-overlapping occurrences of string "searchString"
in "string". The search is started at index "startIndex" (default = 1).
If the optional argument "caseSensitive" is false,
for the counting it does not matter whether a letter is upper
or lower case.
/p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String that is analyzed</TD></TR>
<TR><TD>String</TD><TD>searchString</TD><TD>&nbsp;</TD><TD>String that is searched for in string</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start search at index startIndex</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if lower and upper case are ignored for count</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>result</TD><TD>Number of occurrences of &#39;searchString&#39; in &#39;string&#39;</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> count <font color="darkgreen">
  &quot;Count the number of non-overlapping occurrences of a string&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String that is analyzed&quot;</font>;
  <font color="blue">input </font>String searchString <font color="darkgreen">&quot;String that is searched for in string&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">&quot;Start search at index startIndex&quot;</font>;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">
    &quot;= false, if lower and upper case are ignored for count&quot;</font>;
  <font color="blue">output </font>Integer result <font color="darkgreen">&quot;Number of occurrences of &#39;searchString&#39; in &#39;string&#39;&quot;</font>;
<font color="blue">protected </font>
  Integer lenSearchString =<font color="red"> length</font>(searchString);
  Integer i = startIndex;
<font color="blue">algorithm </font>
  result := 0;
  <font color="blue">while </font>i &lt;&gt; 0<font color="blue"> loop</font>
     i :=<font color="red"> find</font>(string, searchString, i, caseSensitive);
     <font color="blue">if </font>i &gt; 0<font color="blue"> then</font>
        result := result + 1;
        i := i + lenSearchString;
     <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>count;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE find<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.find" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.find"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.find</H2>
<B>Find first occurrence of a string within another string</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<b>find</b>(string, searchString);
index = Strings.<b>find</b>(string, searchString, startIndex=1,
                     caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurence of "searchString" within "string"
and return the corresponding index.
Start search at index "startIndex" (default = 1).
If the optional argument "caseSensitive" is false, lower
and upper case are ignored for the search.
If "searchString" is not found, a value of "0" is returned.
</p>
<pre>
</PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String that is analyzed</TD></TR>
<TR><TD>String</TD><TD>searchString</TD><TD>&nbsp;</TD><TD>String that is searched for in string</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start search at index startIndex</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if lower and upper case are ignored for the search</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>index</TD><TD>Index of the beginning of the first occurrence of &#39;searchString&#39; within &#39;string&#39;, or zero if not present</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> find <font color="darkgreen">
  &quot;Find first occurrence of a string within another string&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String that is analyzed&quot;</font>;
  <font color="blue">input </font>String searchString <font color="darkgreen">&quot;String that is searched for in string&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">&quot;Start search at index startIndex&quot;</font>;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">
    &quot;= false, if lower and upper case are ignored for the search&quot;</font>;
   <font color="blue">output </font>Integer index <font color="darkgreen">
    &quot;Index of the beginning of the first occurrence of &#39;searchString&#39; within &#39;string&#39;, or zero if not present&quot;</font>;
<font color="blue">protected </font>
  Integer lengthSearchString =<font color="red"> length</font>(searchString);
  Integer len = lengthSearchString-1;
  Integer i = startIndex;
  Integer i_max =<font color="red"> length</font>(string) - lengthSearchString + 1;
<font color="blue">algorithm </font>
  index := 0;
  <font color="blue">while </font>i &lt;= i_max<font color="blue"> loop</font>
     <font color="blue">if </font><font color="red">isEqual</font>(<font color="red">substring</font>(string,i,i+len),
                searchString, caseSensitive)<font color="blue"> then</font>
        index := i;
        i := i_max + 1;
     <font color="blue">else</font>
        i := i+1;
     <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>find;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE findLast<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.findLast" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.findLast"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.findLast</H2>
<B>Find last occurrence of a string within another string</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
index = Strings.<b>findLast</b>(string, searchString);
index = Strings.<b>findLast</b>(string, searchString,
                         startIndex=length(string), caseSensitive=true,
</pre></blockquote>
<h4>Description</h4>
<p>
Finds first occurence of "searchString" within "string"
when searching from the last character of "string"
backwards, and return the corresponding index.
Start search at index "startIndex" (default = length(string)).
If the optional argument "caseSensitive" is false, lower
and upper case are ignored for the search.
If "searchString" is not found, a value of "0" is returned.
</p>
<pre>
</PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String that is analyzed</TD></TR>
<TR><TD>String</TD><TD>searchString</TD><TD>&nbsp;</TD><TD>String that is searched for in string</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>0</TD><TD>Start search at index startIndex. If startIndex = 0, start at length(string)</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if lower and upper case are ignored for the search</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>index</TD><TD>Index of the beginning of the last occurrence of &#39;searchString&#39; within &#39;string&#39;, or zero if not present</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> findLast <font color="darkgreen">
  &quot;Find last occurrence of a string within another string&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String that is analyzed&quot;</font>;
  <font color="blue">input </font>String searchString <font color="darkgreen">&quot;String that is searched for in string&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=0)=0 <font color="darkgreen">
    &quot;Start search at index startIndex. If startIndex = 0, start at length(string)&quot;</font>;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">
    &quot;= false, if lower and upper case are ignored for the search&quot;</font>;
  <font color="blue">output </font>Integer index <font color="darkgreen">
    &quot;Index of the beginning of the last occurrence of &#39;searchString&#39; within &#39;string&#39;, or zero if not present&quot;</font>;
<font color="blue">protected </font>
  Integer lenString =<font color="red"> length</font>(string);
  Integer lenSearchString =<font color="red"> length</font>(searchString);
  Integer i;
<font color="blue">algorithm </font>
  i := <font color="blue">if </font>startIndex == 0<font color="blue"> then </font>lenString-lenSearchString+1<font color="blue"> else </font>startIndex;
  index := 0;
  <font color="blue">while </font>i &gt;= 1<font color="blue"> loop</font>
     <font color="blue">if </font><font color="red">isEqual</font>(<font color="red">substring</font>(string,i,i+lenSearchString-1),
                searchString, caseSensitive)<font color="blue"> then</font>
        index := i;
        i := 0;
     <font color="blue">else</font>
        i := i-1;
     <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>findLast;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE replace<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.replace" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.replace"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.replace</H2>
<B>Replace non-overlapping occurrences of a string from left to right</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>replace</b>(string, searchString, replaceString);
Strings.<b>replace</b>(string, searchString, replaceString,
                startIndex=1, replaceAll=true, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Search in "string" for "searchString" and replace the found
substring by "replaceString".
<p>
<ul>
<li> The search starts at the first character of "string",
     or at character position "startIndex",
     if this optional argument is provided.</li>
<li> If the optional argument "replaceAll" is <b>true</b> (default),
     all occurrences of "searchString" are replaced.
     If the argument is <b>false</b>, only the first occurrence
     is replaced. </li>
<li> The search for "searchString" distinguishes upper and lower
     case letters. If the optional argument "caseSensitive" is
     <b>false</b>,
     the search ignores whether letters are upper
     or lower case. </li>
</ul>
<p>
The function returns the "string" with the
performed replacements.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be modified</TD></TR>
<TR><TD>String</TD><TD>searchString</TD><TD>&nbsp;</TD><TD>Replace non-overlapping occurrences of &#39;searchString&#39; in &#39;string&#39; with &#39;replaceString&#39;</TD></TR>
<TR><TD>String</TD><TD>replaceString</TD><TD>&nbsp;</TD><TD>String that replaces &#39;searchString&#39; in &#39;string&#39;</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start search at index startIndex</TD></TR>
<TR><TD>Boolean</TD><TD>replaceAll</TD><TD>true</TD><TD>if false, replace only the first occurrence, otherwise all occurrences</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if lower and upper case are ignored when searching for searchString</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>result</TD><TD>Resultant string of replacement operation</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> replace <font color="darkgreen">
  &quot;Replace non-overlapping occurrences of a string from left to right&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be modified&quot;</font>;
  <font color="blue">input </font>String searchString <font color="darkgreen">
    &quot;Replace non-overlapping occurrences of &#39;searchString&#39; in &#39;string&#39; with &#39;replaceString&#39;&quot;</font>;
  <font color="blue">input </font>String replaceString <font color="darkgreen">&quot;String that replaces &#39;searchString&#39; in &#39;string&#39;&quot;</font>;
  <font color="blue">input </font>Integer startIndex=1 <font color="darkgreen">&quot;Start search at index startIndex&quot;</font>;
  <font color="blue">input </font>Boolean replaceAll=true <font color="darkgreen">
    &quot;if false, replace only the first occurrence, otherwise all occurrences&quot;</font>;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">
    &quot;= false, if lower and upper case are ignored when searching for searchString&quot;</font>;
  <font color="blue">output </font>String result <font color="darkgreen">&quot;Resultant string of replacement operation&quot;</font>;
<font color="blue">protected </font>
  Integer lenString =<font color="red"> length</font>(string);
  Integer lenSearchString =<font color="red"> length</font>(searchString);
  Integer i = startIndex;
  Integer i_found;
<font color="blue">algorithm </font>
  result := <font color="blue">if </font>startIndex == 1<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font><font color="red">substring</font>(string,1,startIndex-1);
  <font color="blue">while </font>i &gt; 0<font color="blue"> loop</font>
     i_found :=<font color="red"> find</font>(string, searchString, i, caseSensitive);
     <font color="blue">if </font>i_found &gt; 0<font color="blue"> then</font>
        result := <font color="blue">if </font>i_found == 1<font color="blue"> then </font>
                     replaceString<font color="blue"> else </font>
                     result + (<font color="blue">if </font>i_found-1&lt;i<font color="blue"> then </font>&quot;&quot;<font color="blue"> else </font><font color="red">substring</font>(string, i, i_found-1)) + replaceString;
        i := i_found + lenSearchString;
        <font color="blue">if </font>i &gt; lenString<font color="blue"> then</font>
           i := 0;
        <font color="blue">elseif </font><font color="blue">not </font>replaceAll<font color="blue"> then</font>
           result := result +<font color="red"> substring</font>(string, i, lenString);
           i := 0;
        <font color="blue">end if</font>;
     <font color="blue">elseif </font>lenString&lt;i<font color="blue"> then</font>
        i := 0;
     <font color="blue">else</font>
        result := result +<font color="red"> substring</font>(string, i, lenString);
        i := 0;
     <font color="blue">end if</font>;
  <font color="blue">end while</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>replace;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE sort<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.sort" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.sort"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.sort</H2>
<B>Sort vector of strings in alphabetic order</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
stringVector2 = Streams.<b>sort</b>(stringVector1);
stringVector2 = Streams.<b>sort</b>(stringVector1, caseSensitive=true);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>sort</b>(..) sorts a string vector stringVector1
in lexicographical order and returns the result in stringVector2.
If the optional argument "caseSensitive" is <b>false</b>, lower
and upper case letters are not distinguished.
</p>
<h4>Example</h4>
<blockquote><pre>
  s1 = {"force", "angle", "pressure"};
  s2 = Strings.sort(s1);
       -> s2 = {"angle", "force", "pressure"};
</pre></blockquote>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>stringVector1[:]</TD><TD>&nbsp;</TD><TD>vector of strings</TD></TR>
<TR><TD>Boolean</TD><TD>caseSensitive</TD><TD>true</TD><TD>= false, if lower and upper case are ignored when comparing elements of stringVector1</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>stringVector2[size(stringVector1, 1)]</TD><TD>string1 sorted in alphabetical order</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> sort <font color="darkgreen">&quot;Sort vector of strings in alphabetic order&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String stringVector1[:] <font color="darkgreen">&quot;vector of strings&quot;</font>;
  <font color="blue">input </font>Boolean caseSensitive=true <font color="darkgreen">
    &quot;= false, if lower and upper case are ignored when comparing elements of stringVector1&quot;</font>;
  <font color="blue">output </font>String stringVector2[<font color="red">size</font>(stringVector1,1)] <font color="darkgreen">
    &quot;string1 sorted in alphabetical order&quot;</font>;
  <font color="darkgreen">/* shellsort algorithm; should be improved later */</font>
<font color="blue">protected </font>
  Integer gap;
  Integer i;
  Integer j;
  String tempString;
  Integer nStringVector1 =<font color="red"> size</font>(stringVector1,1);
  Boolean swap;
<font color="blue">algorithm </font>
  stringVector2 := stringVector1;
  gap :=<font color="red"> div</font>(nStringVector1,2);

  <font color="blue">while </font>gap &gt; 0<font color="blue"> loop</font>
     i := gap;
     <font color="blue">while </font>i &lt; nStringVector1<font color="blue"> loop</font>
        j := i-gap;
        <font color="blue">if </font>j &gt;= 0<font color="blue"> then</font>
           swap :=<font color="red"> compare</font>(stringVector2[j+1], stringVector2[j+gap+1], caseSensitive)
                   == Modelica.Utilities.Types.Compare.Greater;
        <font color="blue">else</font>
           swap := false;
        <font color="blue">end if</font>;

        <font color="blue">while </font>swap<font color="blue"> loop</font>
           tempString := stringVector2[j+1];
           stringVector2[j+1] := stringVector2[j+gap+1];
           stringVector2[j+gap+1] := tempString;
           j := j - gap;
           <font color="blue">if </font>j &gt;= 0<font color="blue"> then</font>
              swap :=<font color="red"> compare</font>(stringVector2[j+1], stringVector2[j+gap+1], caseSensitive)
                      == Modelica.Utilities.Types.Compare.Greater;
           <font color="blue">else</font>
              swap := false;
           <font color="blue">end if</font>;
        <font color="blue">end while</font>;
        i := i + 1;
     <font color="blue">end while</font>;
     gap :=<font color="red"> div</font>(gap,2);
  <font color="blue">end while</font>;

<textblock type="annotcomp" expanded="false"><font color="blue">end </font>sort;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanToken<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanToken" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanToken"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanToken</H2>
<B>Scan for the next token and return it</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
(token, nextIndex) = Strings.<b>scanToken</b>(string, startIndex, unsigned=false);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanToken</b> scans the string starting at index
"startIndex" and returns the next token, as well as the
index directly after the token. The returned token is a record
that holds the type of the token and the value of the token:
</p>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign="top">token.tokenType</td>
      <td valign="top">Type of the token, see below</td></tr>
  <tr><td valign="top">token.real</td>
      <td valign="top">Real value if tokenType == TokenType.RealToken</td></tr>
  <tr><td valign="top">token.integer</td>
      <td valign="top">Integer value if tokenType == TokenType.IntegerToken</td></tr>
  <tr><td valign="top">token.boolean</td>
      <td valign="top">Boolean value if tokenType == TokenType.BooleanToken</td></tr>
  <tr><td valign="top">token.string</td>
      <td valign="top">String value if tokenType == TokenType.StringToken/IdentifierToken/DelimiterToken</td></tr>
</table>
<p>
Variable token.tokenType is an enumeration (emulated as a package
with constants) that can have the following values:
</p>
<pre>
   import T = Modelica.Utilities.Types.TokenType;
</pre>
<table border=1 cellspacing=0 cellpadding=2>
  <tr><td valign="top">T.RealToken</td>
      <td valign="top">Modelica Real literal (e.g., 1.23e-4)</td></tr>
  <tr><td valign="top">T.IntegerToken</td>
      <td valign="top">Modelica Integer literal (e.g., 123)</td></tr>
  <tr><td valign="top">T.BooleanToken</td>
      <td valign="top">Modelica Boolean literal (e.g., false)</td></tr>
  <tr><td valign="top">T.StringToken</td>
      <td valign="top">Modelica String literal (e.g., "string 123")</td></tr>
  <tr><td valign="top">T.IdentifierToken</td>
      <td valign="top">Modelica identifier (e.g., "force_a")</td></tr>
  <tr><td valign="top">T.DelimiterToken</td>
      <td valign="top">any character without white space that does not appear<br>
          as first character in the tokens above (e.g., "&")</td></tr>
  <tr><td valign="top">T.NoToken</td>
      <td valign="top">White space, line comments and no other token<br>
          until the end of the string</td></tr>
</table>
<p>
Modelica line comments ("// ... end-of-line/end-of-string")
as well as white space is ignored.
If "unsigned=true", a Real or Integer literal
is not allowed to start with a "+" or "-" sign.
</p>
<h4>Example</h4>
<blockquote><pre>
  import Modelica.Utilities.Strings.*;
  import T = Modelica.Utilities.Types.TokenType;
  (token, index) := scanToken(string);
  <b>if</b> token.tokenType == T.RealToken <b>then</b>
     realValue := token.real;
  <b>elseif</b> token.tokenType == T.IntegerToken <b>then</b>
     integerValue := token.integer;
  <b>elseif</b> token.tokenType == T.BooleanToken<b> then</b>
     booleanValue := token.boolean;
  <b>elseif</b> token.tokenType == T.Identifier <b>then</b>
     name := token.string;
  <b>else</b>
     syntaxError(string,index,"Expected Real, Integer, Boolean or identifier token");
  <b>end if</b>;
</pre></blockquote>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of string at character startIndex</TD></TR>
<TR><TD>Boolean</TD><TD>unsigned</TD><TD>false</TD><TD>= true, if Real and Integer tokens shall not start with a sign</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD><A HREF="Modelica_Utilities_Types.html#Modelica.Utilities.Types.TokenValue"
>TokenValue</A></TD><TD>token</TD><TD>Scanned token</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>Index of character after the found token; = 0, if NoToken</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanToken <font color="darkgreen">&quot;Scan for the next token and return it&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1) = 1 <font color="darkgreen">
    &quot;Start scanning of string at character startIndex&quot;</font>;
  <font color="blue">input </font>Boolean unsigned=false <font color="darkgreen">
    &quot;= true, if Real and Integer tokens shall not start with a sign&quot;</font>;
  <font color="blue">output </font><A HREF="Modelica_Utilities_Types.html#Modelica.Utilities.Types.TokenValue"
>Types.TokenValue</A> token <font color="darkgreen">&quot;Scanned token&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">
    &quot;Index of character after the found token; = 0, if NoToken&quot;</font>;
<font color="blue">protected </font>
  Integer startTokenIndex;
<font color="blue">algorithm </font>
  <font color="darkgreen">// Initialize token</font>
  token.real :=0.0;
  token.integer :=0;
  token.boolean :=false;
  token.string :=&quot;&quot;;

  <font color="darkgreen">// skip white space and line comments</font>
  startTokenIndex :=<font color="red"> Advanced.skipLineComments</font>(string, startIndex);
  <font color="blue">if </font>startTokenIndex &gt;<font color="red"> length</font>(string)<font color="blue"> then</font>
    token.tokenType := Modelica.Utilities.Types.TokenType.NoToken;
    nextIndex := startTokenIndex;
  <font color="blue">else</font>
    <font color="darkgreen">// scan Integer number</font>
      (nextIndex, token.integer) :=<font color="red"> Advanced.scanInteger</font>(string, startTokenIndex, unsigned);
       token.tokenType := Types.TokenType.IntegerToken;

    <font color="darkgreen">// scan Real number</font>
    <font color="blue">if </font>nextIndex == startTokenIndex<font color="blue"> then</font>
      (nextIndex, token.real) :=<font color="red">Advanced.scanReal</font>(string, startTokenIndex, unsigned);
       token.tokenType := Types.TokenType.RealToken;
    <font color="blue">end if</font>;

    <font color="darkgreen">// scan String</font>
    <font color="blue">if </font>nextIndex == startTokenIndex<font color="blue"> then</font>
       (nextIndex,token.string) :=<font color="red"> Advanced.scanString</font>(string, startTokenIndex);
        token.tokenType:= Types.TokenType.StringToken;
    <font color="blue">end if</font>;

    <font color="darkgreen">// scan Identifier or Boolean</font>
    <font color="blue">if </font>nextIndex == startTokenIndex<font color="blue"> then</font>
       (nextIndex,token.string) :=<font color="red"> Advanced.scanIdentifier</font>(string, startTokenIndex);
       <font color="blue">if </font>nextIndex &gt; startTokenIndex<font color="blue"> then</font>
          <font color="blue">if </font>token.string == &quot;false&quot;<font color="blue"> then</font>
             token.string := &quot;&quot;;
             token.boolean :=false;
             token.tokenType := Types.TokenType.BooleanToken;
          <font color="blue">elseif </font>token.string == &quot;true&quot;<font color="blue"> then</font>
             token.string := &quot;&quot;;
             token.boolean := true;
             token.tokenType := Types.TokenType.BooleanToken;
          <font color="blue">else</font>
             token.tokenType := Types.TokenType.IdentifierToken;
          <font color="blue">end if</font>;
       <font color="blue">end if</font>;
    <font color="blue">end if</font>;

    <font color="darkgreen">// scan Delimiter</font>
    <font color="blue">if </font>nextIndex == startTokenIndex<font color="blue"> then</font>
       token.string :=<font color="red">substring</font>(string, startTokenIndex, startTokenIndex);
       token.tokenType := Types.TokenType.DelimiterToken;
       nextIndex := startTokenIndex + 1;
    <font color="blue">end if</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanToken;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanReal<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanReal" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanReal"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanReal</H2>
<B>Scan for the next Real number and trigger an assert if not present</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
             number = Strings.<b>scanReal</b>(string);
(number, nextIndex) = Strings.<b>scanReal</b>(string, startIndex=1,
                                            unsigned=false, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
The first form, "scanReal(string)", scans "string" for a
Real number with leading white space and returns the value.
</p>
<p>
The second form, "scanReal(string,startIndex,unsigned)",
scans the string starting at index
"startIndex", checks whether the next token is a Real literal
and returns its value as a Real number, as well as the
index directly after the Real number.
If the optional argument "unsigned" is <b>true</b>,
the real number shall not have a leading "+" or "-" sign.
</p>
<p>
If the required Real number with leading white space
is not present in "string",  an assert is triggered.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of string at character startIndex</TD></TR>
<TR><TD>Boolean</TD><TD>unsigned</TD><TD>false</TD><TD>= true, if Real token shall not start with a sign</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Real</TD><TD>number</TD><TD>Value of real number</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>index of character after the found number</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanReal <font color="darkgreen">
  &quot;Scan for the next Real number and trigger an assert if not present&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of string at character startIndex&quot;</font>;
  <font color="blue">input </font>Boolean unsigned=false <font color="darkgreen">
    &quot;= true, if Real token shall not start with a sign&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
  <font color="blue">output </font>Real number <font color="darkgreen">&quot;Value of real number&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">&quot;index of character after the found number&quot;</font>;
<font color="blue">algorithm </font>
  (nextIndex, number) :=<font color="red">Advanced.scanReal</font>(string, startIndex, unsigned);
  <font color="blue">if </font>nextIndex == startIndex<font color="blue"> then</font>
     nextIndex :=<font color="red">Advanced.skipWhiteSpace</font>(string, startIndex);
     <font color="blue">if </font>unsigned<font color="blue"> then</font>
      <font color="red">  syntaxError</font>(string, nextIndex, &quot;Expected a Real number without a sign &quot; + message);
     <font color="blue">else</font>
      <font color="red">  syntaxError</font>(string, nextIndex, &quot;Expected a Real number &quot; + message);
     <font color="blue">end if</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanReal;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanInteger<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanInteger" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanInteger"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanInteger</H2>
<B>Scan for the next Integer number and trigger an assert if not present</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
             number = Strings.<b>scanInteger</b>(string);
(number, nextIndex) = Strings.<b>scanInteger</b>(string, startIndex=1,
                                               unsigned=false, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanInteger</b> scans the string starting at index
"startIndex", checks whether the next token is an Integer literal
and returns its value as an Integer number, as well as the
index directly after the Integer number. An assert is triggered,
if the scanned string does not contain an Integer literal with optional
leading white space.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of string at character startIndex</TD></TR>
<TR><TD>Boolean</TD><TD>unsigned</TD><TD>false</TD><TD>= true, if Integer token shall not start with a sign</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Integer</TD><TD>number</TD><TD>Value of Integer number</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>Index of character after the found number</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanInteger <font color="darkgreen">
  &quot;Scan for the next Integer number and trigger an assert if not present&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of string at character startIndex&quot;</font>;
  <font color="blue">input </font>Boolean unsigned=false <font color="darkgreen">
    &quot;= true, if Integer token shall not start with a sign&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
  <font color="blue">output </font>Integer number <font color="darkgreen">&quot;Value of Integer number&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">&quot;Index of character after the found number&quot;</font>;
<font color="blue">algorithm </font>
  (nextIndex, number) :=<font color="red">Advanced.scanInteger</font>(string, startIndex, unsigned);
  <font color="blue">if </font>nextIndex == startIndex<font color="blue"> then</font>
     nextIndex :=<font color="red">Advanced.skipWhiteSpace</font>(string, startIndex);
     <font color="blue">if </font>unsigned<font color="blue"> then</font>
      <font color="red">  syntaxError</font>(string, nextIndex, &quot;Expected an Integer number without a sign &quot; + message);
     <font color="blue">else</font>
      <font color="red">  syntaxError</font>(string, nextIndex, &quot;Expected an Integer number &quot; + message);
     <font color="blue">end if</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanInteger;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanBoolean<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanBoolean" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanBoolean"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanBoolean</H2>
<B>Scan for the next Boolean number and trigger an assert if not present</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
             number = Strings.<b>scanBoolean</b>(string);
(number, nextIndex) = Strings.<b>scanBoolean</b>(string, startIndex=1, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanBoolean</b> scans the string starting at index
"startIndex", checks whether the next token is a Boolean literal
(i.e., is either the string "false" or "true", if converted to lower case letters)
and returns its value as a Boolean number, as well as the
index directly after the Boolean number. An assert is triggered,
if the scanned string does not contain a Boolean literal with optional
leading white space.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of string at character startIndex</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>Boolean</TD><TD>number</TD><TD>Value of Boolean</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>Index of character after the found number</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanBoolean <font color="darkgreen">
  &quot;Scan for the next Boolean number and trigger an assert if not present&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of string at character startIndex&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
  <font color="blue">output </font>Boolean number <font color="darkgreen">&quot;Value of Boolean&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">&quot;Index of character after the found number&quot;</font>;
<font color="blue">protected </font>
  String identifier;
<font color="blue">algorithm </font>
  (nextIndex, identifier) :=<font color="red">Advanced.scanIdentifier</font>(string, startIndex);

  <font color="blue">if </font>nextIndex &gt; startIndex<font color="blue"> then</font>
     <font color="blue">if </font>identifier == &quot;false&quot;<font color="blue"> then</font>
        number := false;
     <font color="blue">elseif </font>identifier == &quot;true&quot;<font color="blue"> then</font>
        number := true;
     <font color="blue">else</font>
        nextIndex := startIndex;
     <font color="blue">end if</font>;
  <font color="blue">end if</font>;

  <font color="blue">if </font>nextIndex == startIndex<font color="blue"> then</font>
     nextIndex :=<font color="red">Advanced.skipWhiteSpace</font>(string, startIndex);
    <font color="red"> syntaxError</font>(string, nextIndex,
       &quot;Expected a Boolean constant, i.e., \&quot;false\&quot; or \&quot;true\&quot; &quot; + message);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanBoolean;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanString<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanString" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanString"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanString</H2>
<B>Scan for the next Modelica string and trigger an assert if not present</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
             string2 = Strings.<b>scanString</b>(string);
(string2, nextIndex) = Strings.<b>scanString</b>(string, startIndex=1, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanString</b> scans the string starting at index
"startIndex", checks whether the next token is a String literal
and returns its value as a String, as well as the
index directly after the String. An assert is triggered,
if the scanned string does not contain a String literal with optional
leading white space.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of string at character startIndex</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>result</TD><TD>Value of string</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>Index of character after the found string</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanString <font color="darkgreen">
  &quot;Scan for the next Modelica string and trigger an assert if not present&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of string at character startIndex&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
  <font color="blue">output </font>String result <font color="darkgreen">&quot;Value of string&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">&quot;Index of character after the found string&quot;</font>;
<font color="blue">algorithm </font>
  (nextIndex, result) :=<font color="red">Advanced.scanString</font>(string, startIndex);
  <font color="blue">if </font>nextIndex == startIndex<font color="blue"> then</font>
     nextIndex :=<font color="red">Advanced.skipWhiteSpace</font>(string, startIndex);
    <font color="red"> syntaxError</font>(string, nextIndex, &quot;Expected a string enclosed in double quotes &quot; + message);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanString;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanIdentifier<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanIdentifier" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanIdentifier"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanIdentifier</H2>
<B>Scan for the next Identifier and trigger an assert if not present</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
             identifier = Strings.<b>scanIdentifier</b>(string);
(identifier, nextIndex) = Strings.<b>scanIdentifier</b>(string, startIndex=1, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanIdentifier</b> scans the string starting at index
"startIndex", checks whether the next token is an Identifier
and returns its value as a string, as well as the
index directly after the Identifier. An assert is triggered,
if the scanned string does not contain an Identifier with optional
leading white space.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of identifier at character startIndex</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>identifier</TD><TD>Value of Identifier</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>Index of character after the found identifier</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanIdentifier <font color="darkgreen">
  &quot;Scan for the next Identifier and trigger an assert if not present&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of identifier at character startIndex&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
  <font color="blue">output </font>String identifier <font color="darkgreen">&quot;Value of Identifier&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">&quot;Index of character after the found identifier&quot;</font>;
<font color="blue">algorithm </font>
  (nextIndex, identifier) :=<font color="red">Advanced.scanIdentifier</font>(string, startIndex);
  <font color="blue">if </font>nextIndex == startIndex<font color="blue"> then</font>
     nextIndex :=<font color="red">Advanced.skipWhiteSpace</font>(string, startIndex);
    <font color="red"> syntaxError</font>(string, nextIndex, &quot;Expected an identifier &quot; + message);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanIdentifier;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanDelimiter<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanDelimiter" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanDelimiter"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanDelimiter</H2>
<B>Scan for the next delimiter and trigger an assert if not present</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
             delimiter = Strings.<b>scanDelimiter</b>(string);
(delimiter, nextIndex) = Strings.<b>scanDelimiter</b>(string, startIndex=1,
                                 requiredDelimiters={","}, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanDelimiter</b> scans the string starting at index
"startIndex", checks whether the next token is a delimiter string
and returns its value as a string, as well as the
index directly after the delimiter. An assert is triggered,
if the scanned string does not contain a delimiter out of the
list of requiredDelimiters. Input argument requiredDelimiters is a vector
of strings. The elements may have any length, including length 0.
If an element of the requiredDelimiters is zero, white space
is treated as delimiter. The function returns delimiter="" and nextIndex
is the index of the first non white space character.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of delimiters at character startIndex</TD></TR>
<TR><TD>String</TD><TD>requiredDelimiters[:]</TD><TD>{&quot;,&quot;}</TD><TD>Delimiters that are searched</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Outputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>delimiter</TD><TD>Found delimiter</TD></TR>
<TR><TD>Integer</TD><TD>nextIndex</TD><TD>Index of character after the found delimiter</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanDelimiter <font color="darkgreen">
  &quot;Scan for the next delimiter and trigger an assert if not present&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of delimiters at character startIndex&quot;</font>;
  <font color="blue">input </font>String requiredDelimiters[:]={&quot;,&quot;} <font color="darkgreen">&quot;Delimiters that are searched&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
  <font color="blue">output </font>String delimiter <font color="darkgreen">&quot;Found delimiter&quot;</font>;
  <font color="blue">output </font>Integer nextIndex <font color="darkgreen">&quot;Index of character after the found delimiter&quot;</font>;
<font color="blue">protected </font>
  Integer lenString =<font color="red"> length</font>(string);
  Integer lenDelimiter;
  Integer nDelimiters =<font color="red"> size</font>(requiredDelimiters,1);
  Integer endIndex;
  Boolean found;
  Integer i;

  <textblock type="model" expanded="false" path="Modelica.Utilities.Strings.scanDelimiter.concatenate"><font color="blue">encapsulated </font><font color="blue">function</font> concatenate <font color="darkgreen">&quot;Concatenate strings together&quot;</font>
     <font color="blue">input </font>String strings[:];
     <font color="blue">output </font>String string;
  <font color="blue">algorithm </font>
     string := &quot;{\&quot;&quot;;
     <font color="blue">for </font>i<font color="blue"> in </font>1:<font color="red">size</font>(strings,1)<font color="blue"> loop</font>
        <font color="blue">if </font>i == 1<font color="blue"> then</font>
           string := &quot;{\&quot;&quot; + strings[1] + &quot;\&quot;&quot;;
        <font color="blue">else</font>
           string := string + &quot;, \&quot;&quot; + strings[i] + &quot;\&quot;&quot;;
        <font color="blue">end if</font>;
     <font color="blue">end for</font>;
     string := string + &quot;}&quot;;
  <font color="blue">end </font>concatenate</textblock>;
<font color="blue">algorithm </font>
  nextIndex :=<font color="red"> Advanced.skipLineComments</font>(string,startIndex);
  found := false;
  i := 1;
  <font color="blue">while </font><font color="blue">not </font>found<font color="blue"> and </font>i &lt;= nDelimiters<font color="blue"> loop</font>
     lenDelimiter :=<font color="red">length</font>(requiredDelimiters[i]);
     <font color="blue">if </font>lenDelimiter == 0<font color="blue"> then</font>
        found := true;
        delimiter := &quot;&quot;;
     <font color="blue">else</font>
        endIndex :=nextIndex + lenDelimiter - 1;
        <font color="blue">if </font>endIndex &lt;= lenString<font color="blue"> then</font>
           <font color="blue">if </font><font color="red">substring</font>(string,nextIndex,endIndex) == requiredDelimiters[i]<font color="blue"> then</font>
              found := true;
              delimiter := requiredDelimiters[i];
           <font color="blue">end if</font>;
        <font color="blue">end if</font>;
        i := i + 1;
     <font color="blue">end if</font>;
  <font color="blue">end while</font>;

  <font color="blue">if </font>found<font color="blue"> then</font>
      nextIndex := nextIndex + lenDelimiter;
  <font color="blue">else</font>
     <font color="blue">if </font><font color="red">size</font>(requiredDelimiters,1) == 1<font color="blue"> then</font>
      <font color="red">  syntaxError</font>(string, nextIndex, &quot;Expected delimiter \&quot;&quot; + requiredDelimiters[1] + &quot;\&quot;\n&quot; + message);
     <font color="blue">else</font>
      <font color="red">  syntaxError</font>(string, nextIndex, &quot;Expected a delimiter out of &quot; +
                    <font color="red">concatenate</font>(requiredDelimiters) + &quot;\n&quot; + message);
     <font color="blue">end if</font>;
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanDelimiter;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE scanNoToken<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.scanNoToken" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.scanNoToken"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.scanNoToken</H2>
<B>Scan string and check that it contains no more token</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>scanNoToken</b>(string, startIndex=1, message="");
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>scanNoToken</b> scans the string starting at index
"startIndex" and checks whether there is no more token in the
string. An assert is triggered if this is not the case,
using the "message" argument as additional explanation in
the error text.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String to be scanned</TD></TR>
<TR><TD>Integer</TD><TD>startIndex</TD><TD>1</TD><TD>Start scanning of string at character startIndex</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>Message used in error message if scan is not successful</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> scanNoToken <font color="darkgreen">
  &quot;Scan string and check that it contains no more token&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String to be scanned&quot;</font>;
  <font color="blue">input </font>Integer startIndex(min=1)=1 <font color="darkgreen">
    &quot;Start scanning of string at character startIndex&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">
    &quot;Message used in error message if scan is not successful&quot;</font>;
<font color="blue">protected </font>
  Integer nextIndex;
<font color="blue">algorithm </font>
  nextIndex :=<font color="red">Advanced.skipLineComments</font>(string, startIndex);
  <font color="blue">if </font>nextIndex &lt;=<font color="red"> length</font>(string)<font color="blue"> then</font>
    <font color="red"> syntaxError</font>(string, nextIndex, &quot;Expected no more token &quot; + message);
  <font color="blue">end if</font>;
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>scanNoToken;
</PRE>
<HR>
<!--[if supportFields]><span style='mso-element:field-begin'></span>
<span style='mso-spacerun:yes'></span>XE syntaxError<![endif]-->
<!--[if supportFields]><span style='mso-element:field-end'></span><![endif]-->
<H2><IMG SRC="Modelica.Utilities.Strings.lengthI.png" ALT="Modelica.Utilities.Strings.syntaxError" ALIGN=RIGHT BORDER=1 WIDTH=80  HEIGHT=80 >
<A NAME="Modelica.Utilities.Strings.syntaxError"></A><A HREF="Modelica_Utilities_Strings.html#Modelica.Utilities.Strings"
>Modelica.Utilities.Strings</A>.syntaxError</H2>
<B>Print an error message, a string and the index at which scanning detected an error</B><p>
<P><H3>Information</H3></P>
<PRE></pre>
<h4>Syntax</h4>
<blockquote><pre>
Strings.<b>syntaxError</b>(string, index, message);
</pre></blockquote>
<h4>Description</h4>
<p>
Function <b>syntaxError</b> prints an error message in the
following form:
</p>
<pre>
   Syntax error at column &lt;index&gt; of
   &lt;string&gt;
       ^       // shows character that is wrong
   &lt;message&gt;
</pre>
<p>
where the strings withing &lt;..&gt; are the actual values of the
input arguments of the function.
</p>
<p>
If the given string is too long, only a relevant
part of the string is printed.
</p>
<pre></PRE><P>
Extends from <A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A> (Icon for a function).
<P><H3>Inputs</H3><P>
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=2>
<TR><TH>Type</TH><TH>Name</TH><TH>Default</TH><TH>Description</TH></TR>
<TR><TD>String</TD><TD>string</TD><TD>&nbsp;</TD><TD>String that has an error at position index</TD></TR>
<TR><TD>Integer</TD><TD>index</TD><TD>&nbsp;</TD><TD>Index of string at which scanning detected an error</TD></TR>
<TR><TD>String</TD><TD>message</TD><TD>&quot;&quot;</TD><TD>String printed at end of error message</TD></TR>
</TABLE>
<P><H3>Modelica definition</H3>
<PRE>
<font color="blue">function</font> syntaxError <font color="darkgreen">
  &quot;Print an error message, a string and the index at which scanning detected an error&quot;</font>
  <font color="blue">extends </font><A HREF="Modelica_Icons.html#Modelica.Icons.Function"
>Modelica.Icons.Function</A>;
  <font color="blue">input </font>String string <font color="darkgreen">&quot;String that has an error at position index&quot;</font>;
  <font color="blue">input </font>Integer index <font color="darkgreen">&quot;Index of string at which scanning detected an error&quot;</font>;
  <font color="blue">input </font>String message=&quot;&quot; <font color="darkgreen">&quot;String printed at end of error message&quot;</font>;

<font color="blue">protected </font>
  Integer maxIndex = 40;
  Integer maxLenString = 60;
  Integer lenString =<font color="red"> length</font>(string);
  String errString;
  Integer index2 = <font color="blue">if </font>index &lt; 1<font color="blue"> then </font>1<font color="blue"> else </font><font color="blue">if </font>index &gt; lenString<font color="blue"> then </font>lenString<font color="blue"> else </font>index;
<font color="blue">algorithm </font>
<font color="darkgreen">// if &quot;string&quot; is too long, skip part of the string when printing it</font>
   <font color="blue">if </font>index2 &lt;= maxIndex<font color="blue"> then</font>
     errString := string;
   <font color="blue">else</font>
     errString := &quot;... &quot; +<font color="red"> substring</font>(string, index2-maxIndex, lenString);
     index2 := maxIndex + 5;<font color="darkgreen"> // To mark right position</font>
   <font color="blue">end if</font>;

   <font color="blue">if </font><font color="red">length</font>(errString) &gt; maxLenString<font color="blue"> then</font>
      errString :=<font color="red"> substring</font>(errString, 1, maxLenString) + &quot; ...&quot;;
   <font color="blue">end if</font>;

<font color="darkgreen">// Print error message</font>
  <font color="red"> Streams.error</font>(&quot;Syntax error at character &quot; +<font color="red"> String</font>(index) + &quot; of\n&quot; +
                 errString + &quot;\n&quot; +
                 <font color="red">repeat</font>(index2-1, &quot; &quot;) + &quot;*&quot; + &quot;\n&quot; +
                 message);
<textblock type="annotcomp" expanded="false"><font color="blue">end </font>syntaxError;
</PRE>
<HR>
<address>HTML-documentation generated by <a href="http://www.Dymola.com/">Dymola</a> Sun Jan 17 21:12:46 2010.
</address></BODY>
</HTML>
