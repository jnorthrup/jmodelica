/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * \mainpage API documentation of the JModelica.org Modelica Front-end
 *
 * The API documentation of the Modelica %compiler front-end is yet rudimentary. 
 * Also, the APIs for the Java classes contains several methods that are 
 * part of the internal JastAdd run-time system - these methods are not intended
 * to be used by the user.
 * 
 * We are currently working together with the JastAdd team to develop a 
 * documentation system where internal methods are hidden and where the user
 * API is exposed.
 *
 * The Modelica %compiler is organized into a number of different packages:
 * <ul>
 *   <li> org.jmodelica.modelica.parser containing parsers for Modelica
 *   and Flat Modelica code.</li>
 *   <li> org.jmodelica.modelica.compiler contains the actual %compiler, including
 *   the classes used to construct the Abstract Syntax Trees (ASTs) and the
 *   %compiler driver class ModelicaCompiler.</li>
 *   <li> org.jmodelica.util contains some helper classes which are independent
 *   of the AST classes.</li>
 * </ul>
 * 
 * Notice that the Java classes are not intended to be edited manually (with
 * the exception of the classes in org.jmodelica.util), but are rather 
 * automatically generated by the JastAdd tool. In order to extend or 
 * modify the functionality of the %compiler, edit the .%ast, .jrag and .jadd
 * files.
 *
 */


// Modelica abstract grammar




/**
 * \package org.jmodelica.ast Package containing all AST classes.
 */

abstract SourceBaseNode : BaseNode;

/**
 * A class representing the root node of a source AST.
 */
SourceRoot : Root ::= Program;
 

Program : SourceBaseNode ::= 
            UnstructuredEntity:StoredDefinition* 
            /UnknownClassDecl/
            /UnknownComponent:ComponentClause/
            /EnumBaseDecl:EnumClassDecl/
            /PredefinedType:BaseClassDecl*/ 
            /BuiltInType:ClassDecl*/   
            /BuiltInFunction:BaseClassDecl*/
            /LibNode*/
            /AnonymousClass:BaseClassDecl*/
            /InstProgramRoot/;

StoredDefinition : SourceBaseNode ::= [Within] ClassDecl*;

Within : SourceBaseNode ::= [PackageName:Access];

abstract ClassDecl : Element       ::= Name:IdDecl;
abstract BaseClassDecl : ClassDecl ::= <Encapsulated:boolean>
                                       <Partial:boolean>
                                       Restriction 
                                       <Redeclare:boolean>
                                       <Final:boolean>
                                       <Inner:boolean>
                                       <Outer:boolean>
                                       <Replaceable:boolean>
                                       [ConstrainingClause]
                                       [ConstrainingClauseComment:Comment];

UnknownClassDecl : FullClassDecl;

FullClassDecl : BaseClassDecl ::= [StringComment] 
                                  Clause*
                                  [ExternalClause] 
                                  [Annotation]
                                  EndDecl;

LibClassDecl : FullClassDecl ::= LibNode*;
LibNode : ClassDecl ::= <FileName:String>
                        <Structured:boolean> 
                        <Version:String> 
                        <Reason:LibNode.LoadReason> 
                        /StoredDefinition/;

ShortClassDecl : BaseClassDecl ::= ExtendsClauseShortClass;

ExtendsClauseShortClass : ExtendsClause ::= [TypePrefixFlow] 
                                            [TypePrefixVariability]
                                            [TypePrefixInputOutput] 
                                            [ArraySubscripts] 
                                            Comment; 
                            
ExtendClassDecl : FullClassDecl ::= InlineExtendsClause;
                                   
PrimitiveClassDecl : FullClassDecl;
RealClassDecl      : PrimitiveClassDecl;
IntegerClassDecl   : PrimitiveClassDecl;
BooleanClassDecl   : PrimitiveClassDecl;
StringClassDecl    : PrimitiveClassDecl;
EnumClassDecl      : PrimitiveClassDecl ::= <Symbol:Symbol>; // <Symbol> is necessary to achieve formatted pretty print.

EnumLiteralDecl : ComponentDecl;

BuiltInClassDecl : ClassDecl;

ConstrainingClause : SourceBaseNode ::= Access [ClassModification];

abstract Restriction : SourceBaseNode;
Model               : Restriction;
Block               : Restriction;
MClass              : Restriction;
Connector           : Restriction;
ExpandableConnector : Connector;
MType               : Restriction;
MPackage            : Restriction;
Function            : Restriction;
Record              : Restriction;
OperatorRecord      : Record;
Operator            : Restriction;
OperatorFunction    : Function;

ExternalClause : SourceBaseNode ::= [ExternalLanguage] 
                                    [ExternalFunctionCall] 
                                    [Annotation];
                   
ExternalFunctionCall : SourceBaseNode ::= [ReturnVar:Access] FunctionName:IdDecl Arg:Exp*;

ExternalLanguage : SourceBaseNode ::= <Language>;

abstract Clause : SourceBaseNode;

abstract ElementList  : Clause ::= Element*;
PublicElementList     : ElementList;
DefaultElementList    : PublicElementList;
ProtectedElementList  : ElementList;
EquationClause        : Clause ::= AbstractEquation*;
InitialEquationClause : EquationClause;
Algorithm             : Clause ::= Statement*;
InitialAlgorithm      : Algorithm;

abstract Element : SourceBaseNode;
ExtendsClause           : Element ::= Super:Access [ClassModification] [Annotation];
InlineExtendsClause     : ExtendsClause;
abstract ImportClause   : Element ::= PackageName:Access Comment;
ImportClauseQualified   : ImportClause;
ImportClauseUnqualified : ImportClause;
ImportClauseRename      : ImportClause ::= IdDecl;

ComponentClause : Element ::= <Redeclare:boolean> 
                              <Final:boolean> 
                              <Inner:boolean> 
                              <Outer:boolean> 
                              <Replaceable:boolean> 
                              [TypePrefixFlow] 
                              [TypePrefixVariability] 
                              [TypePrefixInputOutput] 
                              ClassName:Access 
                              [TypeArraySubscripts:ArraySubscripts]
                              ComponentDecl*
                              [ConstrainingClause] 
                              Comment;

ComponentDecl : SourceBaseNode ::= Name:IdDecl 
                                   [VarArraySubscripts:ArraySubscripts] 
                                   [Modification] 
                                   [ConditionalAttribute]
                                   Comment;

UnknownComponentDecl : ComponentDecl;

abstract TypePrefix     : SourceBaseNode;
abstract TypePrefixFlow : TypePrefix;
Flow       : TypePrefixFlow;
Stream     : TypePrefixFlow;
abstract TypePrefixVariability : TypePrefix;
Continuous : TypePrefixVariability;
Discrete   : TypePrefixVariability;
Parameter  : TypePrefixVariability;
IndexParameter : Parameter;
Constant   : TypePrefixVariability;
abstract TypePrefixInputOutput : TypePrefix;
Input      : TypePrefixInputOutput;
Output     : TypePrefixInputOutput;

Comment       : SourceBaseNode ::= [StringComment] [Annotation];
StringComment : SourceBaseNode ::= <Comment:String>;

// Annotations and modifications
ConditionalAttribute : SourceBaseNode ::= Exp;

abstract Modification : SourceBaseNode;
CompleteModification  : Modification ::= ClassModification [ValueModification];
ValueModification     : Modification ::= Exp;
//AssignModification    : Modification ::= Exp;
DummyModification     : ValueModification;

ClassModification : Modification ::= Argument*;
abstract Argument : Modification ::= <Each:boolean> <Final:boolean>;

abstract NamedModification   : Argument ::= Name:Access;
abstract ElementModification : NamedModification ::= [Modification] Comment;
ComponentModification : ElementModification; 
abstract ElementRedeclare    : NamedModification;
ClassRedeclare        : ElementRedeclare ::= BaseClassDecl;
ComponentRedeclare    : ElementRedeclare ::= ComponentClause;

abstract Annotation : SourceBaseNode;

ParseAnnotation : Annotation ::= ClassModification;

abstract AbstractExp : SourceBaseNode;
abstract Exp : AbstractExp;

abstract AbstractEquation         : SourceBaseNode ::= Comment;
Equation             : AbstractEquation ::= Left:Exp Right:Exp;
ConnectClause        : AbstractEquation ::= Connector1:Access Connector2:Access;
abstract IfWhenElseEquation       : AbstractEquation ::= AbstractEquation*;
abstract IfWhenEquation           : IfWhenElseEquation ::= Test:Exp [Else:IfWhenElseEquation];
IfEquation           : IfWhenEquation;
WhenEquation         : IfWhenEquation; 
ElseEquation         : IfWhenElseEquation;
ForClauseE           : AbstractEquation ::= ForIndex* AbstractEquation*;
FunctionCallEquation : AbstractEquation ::= Left:FunctionCallLeft* Call:FunctionCall;

FunctionCallLeft : SourceBaseNode ::= [Access];
ForIndex : ComponentClause ::= [Exp];
ForIndexDecl : ComponentDecl;
         
abstract Statement    : SourceBaseNode  ::= Comment;
AssignStmt          : Statement ::= Left:Access Right:Exp;
FunctionCallStmt    : Statement ::= Left:FunctionCallLeft* FunctionCall;
BreakStmt           : Statement;
ReturnStmt          : Statement;
abstract IfWhenStmt   : Statement ::= IfWhenClause*;
IfStmt              : IfWhenStmt ::= [ElseClause];
WhenStmt            : IfWhenStmt;
ElseClause          : SourceBaseNode ::= Stmt:Statement*;
abstract IfWhenClause : SourceBaseNode  ::= Test:Exp Statement*;
IfClause            : IfWhenClause;
WhenClause          : IfWhenClause;
ForStmt             : Statement ::= ForIndex* ForStmtList;
ForStmtList         : SourceBaseNode ::= Stmt:Statement*;
WhileStmt           : Statement ::= Test:Exp WhileStmt:Statement*;
AlgorithmAnnotation : Statement ::= Annotation;

IfExp     : Exp ::= IfExp:Exp ThenExp:Exp ElseExp:Exp;

abstract BinExp : Exp ::= Left:Exp Right:Exp;

abstract ArtmBinExp : BinExp;
DotAddExp : ArtmBinExp;
DotSubExp : ArtmBinExp;
DotMulExp : ArtmBinExp;
DotDivExp : ArtmBinExp;
DotPowExp : ArtmBinExp; // Easy to make parser take care of this: should be a Primary
AddExp : DotAddExp;
SubExp : DotSubExp;
MulExp : DotMulExp;
DivExp : DotDivExp;
PowExp : DotPowExp; // Easy to make parser take care of this: should be a Primary
NegExp : Exp ::= Exp;

RealLitExp    : Exp ::= <UNSIGNED_NUMBER>;
IntegerLitExp : Exp ::= <UNSIGNED_INTEGER>;
StringLitExp  : Exp ::= <STRING>;
abstract BooleanLitExp : Exp;
BooleanLitExpTrue  : BooleanLitExp;
BooleanLitExpFalse : BooleanLitExp;

FunctionCall : Exp ::= Name:Access [FunctionArguments];
PartialFunctionCall : FunctionCall;

FunctionArguments : SourceBaseNode::= Exp* NamedArgument*;
NamedArgument     : SourceBaseNode::= Name:Access Exp;

IterExp  : Exp ::= Exp ForIndex*;
RangeExp : Exp ::= Exp*;

abstract LogBinExp : BinExp;
LtExp  : LogBinExp;
LeqExp : LogBinExp;
GtExp  : LogBinExp;
GeqExp : LogBinExp;
EqExp  : LogBinExp;
NeqExp : LogBinExp;
NotExp : Exp ::= Exp;
OrExp  : LogBinExp;
AndExp : LogBinExp;

IdDecl : SourceBaseNode ::= <ID>;

DerExp : Exp ::= Exp;

AccessExp : Exp ::= Access;

abstract Access : SourceBaseNode;
Dot             : Access      ::= Access*;
GlobalAccess    : Access      ::= Access;
NamedAccess     : Access      ::= <ID>;
ArrayAccess     : NamedAccess ::= ArraySubscripts;

ArrayConstructor : Exp ::= FunctionArguments;
Matrix           : Exp ::= Row:MatrixRow*;
MatrixRow        : Exp ::= Exp*;

ArraySubscripts : SourceBaseNode ::= Subscript*;
abstract Subscript : SourceBaseNode;
ColonSubscript : Subscript::=;
ExpSubscript   : Subscript ::= Exp;

TimeExp : Exp;
EndExp  : Exp;

EndDecl : SourceBaseNode ::= <EndID:String>;
