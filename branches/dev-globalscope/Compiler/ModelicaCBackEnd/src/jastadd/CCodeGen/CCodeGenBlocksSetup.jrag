/*
Copyright (C) 2009-2017 Modelon AB
This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect BlockSetup {

    public String AbstractEquationBlock.genBlockResidualSetUpFunctionName_C(CodePrinter p) {
        return genBlockResidualFunctionName_C(p) + "_set_up";
    }

    public void AbstractEquationBlock.genBlockResidualSetUpFunctionCall_C(CodePrinter p, CodeStream str, String outerIndent) {
        if (setupNodes().size() > 0) {
            str.formatln("%s%s(jmi);", outerIndent, genBlockResidualSetUpFunctionName_C(p));
        }
    }
    
    public void AbstractEquationBlock.genBlockResidualSetUpFunctionDecl_C(CodePrinter p, CodeStream str, String outerIndent) {
        if (setupNodes().size() > 0) {
            String indent = p.indent(outerIndent);
            for (FFunctionCall call : setupNodes()) {
                call.genStaticVarDecls_C(p, str, outerIndent);
            }
            str.format("%sstatic void %s(jmi_t* jmi) {\n", outerIndent, genBlockResidualSetUpFunctionName_C(p));
            for (FFunctionCall call : setupNodes()) {
                call.genStaticTempVars_C(p, str, indent);
            }
            str.format("%s}\n\n", outerIndent);
        }
    }
    
    private Collection<FFunctionCall> AbstractEquationBlock.setupNodes = null;
    public Collection<FFunctionCall> AbstractEquationBlock.setupNodes() {
        if (setupNodes == null) {
            setupNodes = new LinkedHashSet<FFunctionCall>();
            for (AbstractEquationBlock b : blockResidualBlocks()) {
                for (ASTNode n : b.blockResidualNodes()) {
                    n.gatherBlockSetupNodes(blockPrinter(), setupNodes);
                }
            }
        }
        return setupNodes;
    }
    
    public void ASTNode.gatherBlockSetupNodes(CodePrinter p, Collection<FFunctionCall> res) {
        for (ASTNode n : this) {
            n.gatherBlockSetupNodes(p, res);
        }
    }

    public void FFunctionCall.gatherBlockSetupNodes(CodePrinter p, Collection<FFunctionCall> res) {
        super.gatherBlockSetupNodes(p, res);
        if (impureCodeGen(p)) {
            res.add(this);
        }
    }
}