/*
Copyright (C) 2016-2018 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect CCodeGenExpressionsReinit {

    /*=========================================================================
     * Reinit Expression
     ========================================================================*/

    @Override
    public void FReinit.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.format("%s%s = ", indent, globalTemp_C());
        p.print(getFExp(), str, indent);
        str.println(";");
    }

    @Override
    public void FReinit.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        super.genTempVars_C(p, str, indent);
        p.print(this, str, indent);
    }
    
    /*=========================================================================
     * Reinit Expression Globals
     ========================================================================*/

    public String FReinit.globalTemp_C() {
        return "JMI_GLOBAL(" + tempName_C() + ")";
    }
    
    class CGenerator {
        /**
         * Generates temporary variables for reinit writebacks
         */
        /**
         * C: C temporary variables for reinit writebacks
         */
        public class DAETag_C_reinit_writeback_temps extends DAETag {
            
            public DAETag_C_reinit_writeback_temps(AbstractGenerator myGenerator, FClass fclass) {
                super("C_reinit_temp_decls", myGenerator, fclass);
                addOptions("generate_ode");
            }
            
            public void generate(CodeStream str) {
                CodePrinter p = ASTNode.printer_C;
                String indent = "";
                String next = p.indent(indent);
                for (AbstractEquationBlock block : fclass.getDAEInitBLT().getAllBlocks()) {
                    block.genReinitTempDecls_C(p, str, next);
                }
                for (AbstractEquationBlock block : fclass.getDAEStructuredBLT().getAllBlocks()) {
                    block.genReinitTempDecls_C(p, str, next);
                }
            }
        }
    }

    /**
     * Generates temporary variable declarations for storing reinit values.
     */
    public void AbstractEquationBlock.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {
        for (FReinit r : collectReinits_C(p)) {
            str.print(indent, "jmi_real_t ", r.tempName_C(), ";\n");
        }
    }

    /**
     * Generates temporary variable initializaions for storing reinit values.
     * This should be done in the begining of ode-derivatives and sets the
     * value to current value.
     */
    public void AbstractEquationBlock.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        for (FReinit r : collectReinits_C(p)) {
            str.print(indent, r.globalTemp_C(), " = ");
            p.print(r.getVar(), str, indent);
            str.print(";\n");
        }
    }

    /**
     * Generates code that writes back the reinit values to the state. There is
     * no if guard here, that is controlled from the actual reinit statement.
     */
    public void AbstractEquationBlock.genReinitWritebacks_C(CodePrinter p, String indent, CodeStream str) {
        Map<String, ArrayList<FReinit>> map = new LinkedHashMap<>();
        for (FReinit r : collectReinits_C(p)) {
            String key = r.getVar().toString();
            ArrayList<FReinit> list = map.get(key);
            if (list == null) {
                list = new ArrayList<>();
                map.put(key, list);
            }
            list.add(r);
        }
        for (ArrayList<FReinit> list : map.values()) {
            for (int i = 0, n = list.size(); i < n; i++) {
                list.get(i).genReinitWritebacks_C(p, str, indent, i == 0, i == n - 1);
            }
        }
    }
    
    public void FReinit.genReinitWritebacks_C(
            CodePrinter p, CodeStream str, String indent, boolean first, boolean last) {
        //TODO: This is TEMPORARY, will need a better solution later!
        str.format("%sif (%s != ", (first ? indent : " else "), globalTemp_C());
        p.print(getVar(), str, indent);
        str.println(") {");
        str.print(p.indent(indent));
        p.print(getVar(), str, indent);
        str.formatln(" = %s;", globalTemp_C());
        str.formatln("%sjmi->reinit_triggered = 1;", p.indent(indent));
        str.format("%s}", indent);
        if (last)
            str.println();
    }

    /**
     * Helper, used for finding reinits
     */
    public Iterable<FReinit> AbstractEquationBlock.collectReinits_C(CodePrinter p) {
        ArrayList<FReinit> res = new ArrayList<>();
        for (FAbstractEquation eqn : allEquations()) {
            eqn.collectReinits_C(p, res);
        }
        return res;
    }
    
    /**
     * Helper, used for finding reinits
     */
    public void FAbstractEquation.collectReinits_C(CodePrinter p, Collection<FReinit> res) {}

    @Override
    public void FFunctionCallEquation.collectReinits_C(CodePrinter p, Collection<FReinit> res) {
        getCall().collectReinits_C(p, res);
    }

    @Override
    public void FIfWhenElseEquation.collectReinits_C(CodePrinter p, Collection<FReinit> res) {
        for (FAbstractEquation e : getFAbstractEquations()) {
            e.collectReinits_C(p, res);
        }
    }

    @Override
    public void FIfWhenEquation.collectReinits_C(CodePrinter p, Collection<FReinit> res) {
        if (!p.inInitialSystem() || getTest().isInitialGuard()) {
            super.collectReinits_C(p, res);
        }
        if (hasElse()) {
            getElse().collectReinits_C(p, res);
        }
    }

    /**
     * Helper, used for finding reinits
     */
    public void FAbstractFunctionCall.collectReinits_C(CodePrinter p, Collection<FReinit> res) {
        
    }

    @Override
    public void FReinit.collectReinits_C(CodePrinter p, Collection<FReinit> res) {
        res.add(this);
    }
}