/*
Copyright (C) 2016-2018 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect CCodeGenExpressionsReinit {

    /*=========================================================================
     * Reinit Expression
     ========================================================================*/

    @Override
    public void FReinit.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        str.format("%s%s = ", indent, tempName_C());
        p.print(getFExp(), str, indent);
        str.println(";");
    }

    @Override
    public void FReinit.genTempVars_C(CodePrinter p, CodeStream str, String indent) {
        super.genTempVars_C(p, str, indent);
        p.print(this, str, indent);
    }
    
    /*=========================================================================
     * Reinit Expression Globals
     ========================================================================*/

    class CGenerator {
        /**
         * Generates temporary variables for reinit writebacks
         */
        /**
         * C: C temporary variables for reinit writebacks
         */
        public class DAETag_C_reinit_writeback_temps extends DAETag {
            
            public DAETag_C_reinit_writeback_temps(AbstractGenerator myGenerator, FClass fclass) {
                super("C_reinit_temp_decls", myGenerator, fclass);
                addOptions("generate_ode");
            }
    
            public void generate(CodeStream genPrinter) {
                for (AbstractEquationBlock block : fclass.getDAEStructuredBLT().getAllBlocks())
                    block.genReinitTempDecls_C(ASTNode.printer_C, genPrinter, "");
            }
        }
    
        /**
         * Generates temporary variables for reinit writebacks in the initial system
         */
        /**
         * C: C temporary variables for reinit writebacks in the initial system
         */
        public class DAETag_C_reinit_writeback_temps_initial extends DAETag {
            
            public DAETag_C_reinit_writeback_temps_initial(AbstractGenerator myGenerator, FClass fclass) {
                super("C_reinit_temp_decls_initial", myGenerator, fclass);
                addOptions("generate_ode");
            }
            
            public void generate(CodeStream genPrinter) {
                for (AbstractEquationBlock block : fclass.getDAEInitBLT().getAllBlocks())
                    block.genReinitTempDecls_C(ASTNode.printer_C.initialSystemPrinter(), genPrinter, "");
            }
        }
    
    }

    /**
     * Generates temporary variable declarations for storing reinit values.
     */
    public void AbstractEquationBlock.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {
        for (FAbstractEquation eqn : allEquations()) {
            eqn.genReinitTempDecls_C(p, str, indent);
        }
    }

    /**
     * Helper, used for writing temp decl for reinits
     */
    public void FAbstractEquation.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {}

    @Override
    public void FFunctionCallEquation.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {
        getCall().genReinitTempDecls_C(p, str, indent);
    }

    @Override
    public void FIfWhenElseEquation.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {
        for (FAbstractEquation e : getFAbstractEquations()) {
            e.genReinitTempDecls_C(p, str, indent);
        }
    }

    @Override
    public void FIfWhenEquation.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {
        if (!isWhen() || !p.inInitialSystem() || getTest().isInitialGuard()) {
            super.genReinitTempDecls_C(p, str, indent);
        }
        if (hasElse()) {
            getElse().genReinitTempDecls_C(p, str, indent);
        }
    }

    /**
     * Helper, used for writing temp decl for reinits
     */
    public void FAbstractFunctionCall.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {}

    @Override
    public void FReinit.genReinitTempDecls_C(CodePrinter p, CodeStream str, String indent) {
        str.formatln("%sstatic jmi_real_t %s;", indent, tempName_C());
    }

    /**
     * Generates temporary variable initializaions for storing reinit values.
     * This should be done in the begining of ode-derivatives and sets the
     * value to current value.
     */
    public void AbstractEquationBlock.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        for (FAbstractEquation eqn : allEquations()) {
            eqn.genReinitTempInits_C(p, str, indent);
        }
    }

    /**
     * Helper, used for writing temp init for reinits
     */
    public void FAbstractEquation.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {}

    @Override
    public void FFunctionCallEquation.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        getCall().genReinitTempInits_C(p, str, indent);
    }

    @Override
    public void FIfWhenElseEquation.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        for (FAbstractEquation e : getFAbstractEquations()) {
            e.genReinitTempInits_C(p, str, indent);
        }
    }

    @Override
    public void FIfWhenEquation.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        if (!p.inInitialSystem() || getTest().isInitialGuard()) {
            super.genReinitTempInits_C(p, str, indent);
        }
        if (hasElse()) {
            getElse().genReinitTempInits_C(p, str, indent);
        }
    }

    /**
     * Helper, used for writing temp init for reinits
     */
    public void FAbstractFunctionCall.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        
    }

    @Override
    public void FReinit.genReinitTempInits_C(CodePrinter p, CodeStream str, String indent) {
        str.format("%s%s = ", indent, tempName_C());
        p.print(getVar(), str, indent);
        str.println(";");
    }

    /**
     * Generates code that writes back the reinit values to the state. There is
     * no if guard here, that is controlled from the actual reinit statement.
     */
    public void AbstractEquationBlock.genReinitWritebacks_C(CodePrinter p, String indent, CodeStream str) {
        Map<String, ArrayList<FReinit>> map = new LinkedHashMap<String, ArrayList<FReinit>>();
        for (FAbstractEquation eqn : allEquations()) {
            eqn.collectReinits_C(map, p.inInitialSystem());
        }
        for (ArrayList<FReinit> list : map.values()) {
            for (int i = 0, n = list.size(); i < n; i++) {
                list.get(i).genReinitWritebacks_C(p, str, indent, i == 0, i == n - 1);
            }
        }
    }
    
    public void FReinit.genReinitWritebacks_C(
            CodePrinter p, CodeStream str, String indent, boolean first, boolean last) {
        //TODO: This is TEMPORARY, will need a better solution later!
        str.format("%sif (%s != ", (first ? indent : " else "), tempName_C());
        p.print(getVar(), str, indent);
        str.println(") {");
        str.print(p.indent(indent));
        p.print(getVar(), str, indent);
        str.formatln(" = %s;", tempName_C());
        str.formatln("%sjmi->reinit_triggered = 1;", p.indent(indent));
        str.format("%s}", indent);
        if (last)
            str.println();
    }

    /**
     * Helper, used for finding reinits
     */
    public void FAbstractEquation.collectReinits_C(Map<String, ArrayList<FReinit>> map, boolean initial) {}

    @Override
    public void FFunctionCallEquation.collectReinits_C(Map<String, ArrayList<FReinit>> map, boolean initial) {
        getCall().collectReinits_C(map, initial);
    }

    @Override
    public void FIfWhenElseEquation.collectReinits_C(Map<String, ArrayList<FReinit>> map, boolean initial) {
        for (FAbstractEquation e : getFAbstractEquations()) {
            e.collectReinits_C(map, initial);
        }
    }

    @Override
    public void FIfWhenEquation.collectReinits_C(Map<String, ArrayList<FReinit>> map, boolean initial) {
        if (!initial || getTest().isInitialGuard()) {
            super.collectReinits_C(map, initial);
        }
        if (hasElse()) {
            getElse().collectReinits_C(map, initial);
        }
    }

    /**
     * Helper, used for finding reinits
     */
    public void FAbstractFunctionCall.collectReinits_C(Map<String, ArrayList<FReinit>> map, boolean initial) {}

    @Override
    public void FReinit.collectReinits_C(Map<String, ArrayList<FReinit>> map, boolean initial) {
        String key = getVar().toString();
        ArrayList<FReinit> list = map.get(key);
        if (list == null) {
            list = new ArrayList<FReinit>();
            map.put(key, list);
        }
        list.add(this);
    }
}