/*
    Copyright (C) 2017 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import org.jmodelica.util.collections.SubClassIterator;
import org.jmodelica.util.collections.SingleIterable;
import org.jmodelica.util.collections.ChainedIterable;
import org.jmodelica.util.collections.FilteredIterator;
import org.jmodelica.util.collections.FilteredIterable;
import org.jmodelica.util.collections.NestledIterator;
import org.jmodelica.util.collections.NestledIterable;
import org.jmodelica.util.Criteria;

aspect SourceTraversal {


    syn Iterable<AbstractEquation> ClassDecl.equations();
    eq ClassDecl.equations()     = Collections.<AbstractEquation>emptyList();
    eq LibNode.equations()       = myClass().equations();
    eq FullClassDecl.equations() = new Iterable<AbstractEquation>() {
        public Iterator<AbstractEquation> iterator() {
            return new ClauseElementIterator<AbstractEquation>() {
                protected Iterator<AbstractEquation> subIterator(Clause c) {
                    return c.equationIterator();
                }
            };
        }
    };

    syn Iterable<Algorithm> ClassDecl.algorithms();
    eq ClassDecl.algorithms()     = Collections.<Algorithm>emptyList();
    eq LibNode.algorithms()       = myClass().algorithms();
    eq FullClassDecl.algorithms() = new Iterable<Algorithm>() {
        public Iterator<Algorithm> iterator() {
            return new ClauseElementIterator<Algorithm>() {
                protected Iterator<Algorithm> subIterator(Clause c) {
                    return c.algorithmIterator();
                }
            };
        }
    };
    
    syn Iterable<ExtendsClause> ClassDecl.superClasses();
    eq ClassDecl.superClasses()       = Collections.<ExtendsClause>emptyList();
    eq ShortClassDecl.superClasses()  = 
        Collections.<ExtendsClause>singletonList(getExtendsClauseShortClass());
    eq LibNode.superClasses()         = myClass().superClasses();
    eq ExtendClassDecl.superClasses() = new ChainedIterable(
            new SingleIterable(getInlineExtendsClause()), super.superClasses());
    eq FullClassDecl.superClasses()   = new Iterable<ExtendsClause>() {
        public Iterator<ExtendsClause> iterator() {
            return new ClauseElementIterator<ExtendsClause>() {
                protected Iterator<ExtendsClause> subIterator(Clause c) {
                    return c.extendsIterator();
                }
            };
        }
    };
    
    syn Iterable<ComponentClause> ClassDecl.componentClauses();
    eq ClassDecl.componentClauses()     = Collections.<ComponentClause>emptyList();
    eq LibNode.componentClauses()       = myClass().componentClauses();
    eq FullClassDecl.componentClauses() = new Iterable<ComponentClause>() {
        public Iterator<ComponentClause> iterator() {
            return new ClauseElementIterator<ComponentClause>() {
                protected Iterator<ComponentClause> subIterator(Clause c) {
                    return c.componentClauseIterator();
                }
            };
        }
    };
    
    syn Iterable<ComponentDecl> ClassDecl.components() = 
        new NestledIterable<ComponentDecl,ComponentClause>(componentClauses()) {
            protected Iterable<ComponentDecl> subIterable(ComponentClause c) {
                return c.getComponentDecls();
            }
        };
    eq EnumClassDecl.components() = 
        new ChainedIterable(componentsIterable(), enumBase().componentsIterable());
    
    syn Iterable<ComponentDecl> EnumClassDecl.componentsIterable() = super.components();
    syn EnumClassDecl EnumClassDecl.enumBase() = 
        ((SourceRoot) root()).getProgram().getEnumBaseDecl();
    
    syn Iterable<SrcModificationOrRedeclareElement> ClassDecl.elementModifications();
    eq ClassDecl.elementModifications()     = 
        Collections.<SrcModificationOrRedeclareElement>emptyList();
    eq LibNode.elementModifications()       = myClass().elementModifications();
    eq FullClassDecl.elementModifications() = 
        new FilteredIterable(
            components(),
            new Criteria<SrcModificationOrRedeclareElement>() {
                public boolean test(SrcModificationOrRedeclareElement elem) {
                    return elem.hasRedeclare();
                }
            });

    syn Iterable<ImportClause> ClassDecl.imports();
    eq ClassDecl.imports()     = Collections.<ImportClause>emptyList();
    eq FullClassDecl.imports() = new Iterable<ImportClause>() {
        public Iterator<ImportClause> iterator() {
            return new ClauseElementIterator<ImportClause>() {
                protected Iterator<ImportClause> subIterator(Clause c) {
                    return c.importIterator();
                }
            };
        }
    };

    syn Iterable<ClassDecl> ClassDecl.classes();
    eq ClassDecl.classes()     = Collections.<ClassDecl>emptyList();
    eq LibNode.classes()       = myClass().classes();
    eq FullClassDecl.classes() = new Iterable<ClassDecl>() {
        public Iterator<ClassDecl> iterator() {
            return new ClauseElementIterator<ClassDecl>() {
                protected Iterator<ClassDecl> subIterator(Clause c) {
                    return c.classIterator();
                }
            };
        }
    };
    syn lazy Iterable<ClassDecl> LibClassDecl.classes() {
        // Imposes ordering specified in LibClassDecl.order
        Map<String,ClassDecl> map = new LinkedHashMap<String,ClassDecl>();
        for (ClassDecl cd : super.classes())
            map.put(cd.name(), cd);
        for (LibNode ln : getLibNodes()) {
            map.put(ln.name(), ln);
        }
        
        ArrayList<ClassDecl> l = new ArrayList<ClassDecl>();
        for (String name : order) {
            ClassDecl cd = map.get(name);
            if (cd != null) {
                l.add(cd);
                map.remove(name);
            }
        }
        for (ClassDecl cd : map.values())
            l.add(cd);

        return l;
    }
    syn Iterable<ClassDecl> Program.classes() {
        ArrayList<ClassDecl> l = new ArrayList<ClassDecl>();
        for (StoredDefinition sd : getUnstructuredEntitys()) {
            for (ClassDecl cd : sd.getClassDecls()) {
                if (!cd.isError()) {
                    l.add(cd);
                }
            }
        }
        // Libraries are loaded when needed in instance lookup instead
        return l;
    } 

    public class FullClassDecl {

        protected abstract class ClauseElementIterator<T> extends NestledIterator<T,Clause> {
            public ClauseElementIterator() {
                super(getClauses().iterator());
            }
        }

    }

    syn Iterator<AbstractEquation> Clause.equationIterator() = null;
    eq EquationClause.equationIterator()                     = getAbstractEquations().iterator();

    syn Iterator<Algorithm> Clause.algorithmIterator() = null;
    eq Algorithm.algorithmIterator()                   = new SingleIterator(this);

    syn Iterator<ExtendsClause> Clause.extendsIterator() = null;
    eq ElementList.extendsIterator()                     = 
        new SubClassIterator(ExtendsClause.class, getElements().iterator());

    syn Iterator<ComponentClause> Clause.componentClauseIterator() = null;
    eq ElementList.componentClauseIterator()                       = 
        new SubClassIterator(ComponentClause.class, getElements().iterator());

    syn Iterator<ImportClause> Clause.importIterator() = null;
    eq ElementList.importIterator()                     = 
        new SubClassIterator(ImportClause.class, getElements().iterator());

    syn Iterator<ClassDecl> Clause.classIterator() = null;
    eq ElementList.classIterator()                     = 
        new FilteredIterator(
            new SubClassIterator(ClassDecl.class, getElements().iterator()), 
            NOT_ERROR_NODE_CRITERIA);


    public interface SrcModificationOrRedeclareElement {
        public InstModification newInstModification();
        public boolean hasRedeclare();
    }

    Modification  implements SrcModificationOrRedeclareElement;
    ComponentDecl implements SrcModificationOrRedeclareElement;
// TODO: Handle class redeclares through this interface as well
//       (will need to update FullClassDecl.elementModifications() then)
//    BaseClassDecl implements SrcModificationOrRedeclareElement;

    syn ForIndexDecl ForIndex.getForIndexDecl() = (ForIndexDecl) getComponentDecl(0);

    syn ComponentDecl ComponentRedeclare.getComponentDecl() = 
        getComponentClause().getComponentDecl(0);

    syn boolean Modification.hasRedeclare() = false;
    eq ElementRedeclare.hasRedeclare()      = true;

    inh ComponentClause ComponentDecl.myComponentClause();
    eq ComponentClause.getComponentDecl().myComponentClause() = this;

    syn ComponentClause InstComponentDecl.myComponentClause() = 
        getComponentDecl().myComponentClause();

    /**
     * Get the string comment a.k.a. description string that applies to this element, 
     * or null if there is none.
     */
    syn StringComment ClassDecl.myStringComment()               = null;
    eq BaseClassDecl.myStringComment()                          = 
        selectStringComment(getConstrainingClauseComment());
    eq FullClassDecl.myStringComment()                          = 
        selectStringComment(getConstrainingClauseComment(), this);
    syn StringComment ExtendsClauseShortClass.myStringComment() = 
        selectStringComment(getComment());
    syn StringComment ImportClause.myStringComment()            = 
        selectStringComment(getComment());
    syn StringComment ComponentClause.myStringComment()         = 
        selectStringComment(getComment());
    syn StringComment ComponentDecl.myStringComment()           = 
        selectStringComment(myComponentClause().getComment(), getComment());
    syn StringComment ElementModification.myStringComment()     = 
        selectStringComment(getComment());
    syn StringComment AbstractEquation.myStringComment()        = 
        selectStringComment(getComment());
    syn StringComment Statement.myStringComment()               = 
        selectStringComment(getComment());

    syn StringComment InstClassDecl.myStringComment()     = getClassDecl().myStringComment();
    syn StringComment InstComponentDecl.myStringComment() = getComponentDecl().myStringComment();

    public interface StringCommentSource {
        public boolean hasStringComment();
        public StringComment getStringComment();
    }
    Comment implements StringCommentSource;
    FullClassDecl implements StringCommentSource;

    /**
     * Helper method for myStringComment() methods. 
     * Selects the first found among the arguments.
     */
    protected static StringComment ASTNode.selectStringComment(StringCommentSource... sources) {
        for (StringCommentSource src : sources) {
            if (src != null && src.hasStringComment()) {
                return src.getStringComment();
            }
        }
        return null;
    }

    /**
     * Iterable over each part of a qualified name.
     */
    syn Iterable<Access> Access.nameParts();
    eq Access.nameParts()       = new SingleIterable(this);
    eq GlobalAccess.nameParts() = getAccess().nameParts();
    eq Dot.nameParts()          = getAccesss();

}