/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/**
 * InitialTransformation contains rewrites that transforms the original
 * source AST into a canonical form. For example, multiple component
 * declarations are split into individual ones and visibility is set
 * for each individual declaration.
 */
 
 aspect InitialTransformations {
    /** 
     * This attribute is used to set the visibility of each element
     * as protected or public. All classes that can have a parent with
     * associated visibility must inherit this attribute. (At least if
     * makes sense for that particular class).
     */
    inh VisibilityType ClassDecl.visibility(); 
    inh VisibilityType PN_ComponentClause.visibility();
    
    // Added for proxy solution in JModelica IDE
    public VisibilityType SourceRoot.computeVisibility() {
        return new PublicVisibilityType();
    }

    /**
     *  Equations defining public or protected visibility of elements 
     */
    eq PublicElementList.getElement().visibility()    = new PublicVisibilityType();
    eq ProtectedElementList.getElement().visibility() = new ProtectedVisibilityType();
    eq SourceRoot.getProgram().visibility()           = computeVisibility(); 
    eq Root.getChild().visibility()                   = new PublicVisibilityType(); 
    
    eq ClassRedeclare.getBaseClassDecl().visibility() = new PublicVisibilityType();
    eq ComponentRedeclare.getComponentDecl().visibility() = new PublicVisibilityType();

    /**
     * Rewrite the {@link PN_ComponentClause} to a {@link ComponentClause} including visibility information. 
     */
    rewrite PN_ComponentClause {
        to ComponentClause {
            List l = new List();

            for(int i=0;i<getNumName();i++) {
                if (getName(i)!=null) l.add(getName(i));
            }

            ComponentClause c = new ComponentClause(getRedeclare(),
                                                    getFinal(),
                                                    getInner(),
                                                    getOuter(),
                                                    getReplaceable(),
                                                    getTypePrefixFlowOpt(),
                                                    getTypePrefixVariabilityOpt(),
                                                    getTypePrefixInputOutputOpt(),
                                                    getClassName(),
                                                    getTypeArraySubscriptsOpt(),
                                                    visibility(),
                                                    l,
                                                    getConstrainingClauseOpt(),
                                                    getComment());
            c.setLocationNoTree(this);
            // log.debug("PN_ComponentClause->ComponentClause.getStart() = " + c.getStart());
            return c;
        }
    }

    /**
     * Rewrite a component clause to a source component declaration.
     */
    rewrite ComponentClause {
             when (getNumName() == 1) 
             to ComponentDecl {
                     ComponentDecl cd = asComponentDecl(getName(0), null);
                     cd.setLocationNoTree(this);
                     return cd;
             }
     }

    /**
     * Transform ComponentClauses to ComponentDecls
     */
    rewrite ComponentClause in ElementList.getElement() {
        when (getNumName() > 1) 
        to List {
            List l = new List();
            java.util.List<SiblingComponentDecl> siblings = new ArrayList();
            for (PN_ComponentDecl name : getNames()) {
                ComponentDecl c = asComponentDecl(name, siblings);
                if (l.getNumChild() == 0)
                    c.setLocationNoTree(this);
                else
                    c.setLocationNoTree(name);
                l.add(c);
            }
            return l;
        }
    }

    /**
     * Rewrite a parsed component redeclaration to a source component redeclaration.
     */
     rewrite PN_ComponentRedeclare {
        to ComponentRedeclare {
           ComponentRedeclare c = new ComponentRedeclare(getEach(), getFinal(), getName(),
                   (ComponentDecl) getBaseComponentDecl());
           c.setLocationNoTree(this);
           return c;
        }
    }   

    /**
     * Returns a component declaration instance corresponding to the parsed component clause.
     * 
     * @param name
     *          The parsed declaration of the component.
     * @param siblings
     *          The component's sibling components.
     */
    public ComponentDecl ComponentClause.asComponentDecl(PN_ComponentDecl name,
            java.util.List<SiblingComponentDecl> siblings) {

        List<Subscript> as = name.hasVarArraySubscripts() ? name.getVarArraySubscripts().getSubscriptList() :
                new List<Subscript>();

        if (hasTypeArraySubscripts()) {
            for (int i = 0; i < getTypeArraySubscripts().getNumSubscript(); i++) {
                as.add(getTypeArraySubscripts().getSubscript(i));
            }
        }

        ComponentDecl c = null;
        if (siblings == null) {
            c = new ComponentDecl();
        } else {
            SiblingComponentDecl sc = new SiblingComponentDecl();
            sc.setSiblings(siblings);
            siblings.add(sc);
            c = sc;
        }

        if (as.getNumChild() > 0) {
            c.setVarArraySubscripts(new ArraySubscripts(as));
        }

        c.setRedeclare(getRedeclare());
        c.setFinal(getFinal());
        c.setInner(getInner());
        c.setOuter(getOuter());
        c.setReplaceable(getReplaceable());
        c.setTypePrefixFlowOpt(getTypePrefixFlowOpt().fullCopy());
        c.setTypePrefixVariabilityOpt(getTypePrefixVariabilityOpt().fullCopy());
        c.setTypePrefixInputOutputOpt(getTypePrefixInputOutputOpt().fullCopy());
        c.setClassName(getClassName().fullCopy());
        c.setVisibilityType(getVisibilityType().fullCopy());
        c.setName(name.getName());
        c.setModificationOpt(name.getModificationOpt());
        c.setConditionalAttributeOpt(name.getConditionalAttributeOpt());
        c.setComment(name.getComment());
        c.setConstrainingClauseOpt( getConstrainingClauseOpt().fullCopy());
        c.setCCComment(getComment());
        c.setLocationNoTree(this, this, name);

        return c;
    }

    rewrite ComponentModification {
        when (getName().isQualified())
        to ComponentModification{
            log.debug("ComponentModification -> ComponentModification: " + getName().qualifiedName());
            ComponentModification e = new ComponentModification(
                                           false,
                                           false,
                                           getName().getFirstAccess(),
                                           //getModificationOpt(),
                                           new Opt(new CompleteModification(
                                                    new ClassModification(
                                                     new List().add(
                                                      new ComponentModification(
                                                       getEach(),
                                                       getFinal(),
                                                       getName().stripFirstAccess(),
                                                       getModificationOpt(),
                                                    getComment()))),
                                                   new Opt())),
                                           new Comment(new Opt(), new Opt()));
            e.getModification().setLocationNoTree(this);
            ((CompleteModification)e.getModification()).getClassModification().setLocationNoTree(this);
            ClassModification cm = ((CompleteModification)e.getModification()).getClassModification();
            ((ComponentModification)cm.getArgument(0)).getName().setLocationNoTree(this);
            e.setLocationNoTree(this);
            return e;
        }
    
    }

    rewrite PN_ShortClassDecl {
        to ShortClassDecl {
            ExtendsClauseShortClass ecsc = 
               new ExtendsClauseShortClass(getClassName(),
                                      getClassModificationOpt(),
                                      new Opt<Annotation>(),
                                      getTypePrefixFlowOpt(),
                                      getTypePrefixVariabilityOpt(),
                                      getTypePrefixInputOutputOpt(),
                                      getArraySubscriptsOpt(),
                                      getComment());
            ecsc.setLocationNoTree(this);
            ShortClassDecl scd = new ShortClassDecl(
                    getName(),
                    getEncapsulated(),
                    getPartial(),
                    getRestriction(),
                    getRedeclare(),
                    getFinal(),
                    getInner(),
                    getOuter(),
                    getReplaceable(),
                    getConstrainingClauseOpt(),
                    getConstrainingClauseCommentOpt(),
                    ecsc); 
           scd.setLocationNoTree(this);
           return scd;
        }
    }
    
    rewrite PN_Dot {
    	to Dot copyLocationTo(buildDot(new Dot()));
    }

    public Dot Access.buildDot(Dot dot) {
    	dot.addAccessNoTransform(this);
    	return dot;
    }
    

    public Dot PN_Dot.buildDot(Dot dot) {
    	getLeftNoTransform().buildDot(dot);
    	getRightNoTransform().buildDot(dot);
    	return dot;
    }

}
