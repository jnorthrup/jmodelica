/*
    Copyright (C) 2009-2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

%goal source_root;
%goal anonymous_short_class;
%goal exp;
%goal element;
%goal abstract_equation;
%goal argument;

%header {:
 package $PARSER_PACKAGE$;
 import $AST_PACKAGE$.*;
 import org.jmodelica.util.AdjustableSymbol;
 import org.jmodelica.util.AbstractAdjustableSymbol;
 import org.jmodelica.util.formatting.FormattingRecorder;
 import org.jmodelica.util.formatting.FormattingType;
 import org.jmodelica.api.problemHandling.Problem;
 import org.jmodelica.api.problemHandling.ProblemSeverity;
 import org.jmodelica.api.problemHandling.ProblemKind;
 import beaver.Parser.Events;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
:};

%embed {:

    /**
     * Error reporting class that creates an error message and delegates reporting the 
     * message to a subclass.
     */
    public abstract static class Report extends Events {

        /**
         * Report an error with error message <code>msg</code>.
         */
        protected abstract void report(Problem P);

        /**
         * Creates an error message for when <code>token</code> is found unexpectedly. 
         * Passes the error message to {@link #report(Problem)}.
         * @param token     the unexpected symbol.
         */
        public void syntaxError(Symbol token) {
            
            StringBuilder s = new StringBuilder();
            //s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
            if (token.getId() == Terminals.EOF) {
                s.append("  Unexpected end of file");
            } else if (token.value != null) {
                s.append("   Unexpected token: \"" + token.value + "\"");
            } else if (token.getId()<Terminals.NAMES.length)
                s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
            else 
                s.append("  Syntactic error");
            Problem p = new Problem(fileName, s.toString(), ProblemSeverity.ERROR, ProblemKind.SYNTACTIC, Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
            
            report(p);
        }

        /**
         * Creates an error message for when the scanner throws an exception.
         * Passes the error message to {@link #report(Problem)}.
         * @param e     the exception.
         */
        public void scannerError(Scanner.Exception e) {
            /*
            StringBuilder s = new StringBuilder(e.getMessage());
            s.append(" at line ");
            s.append(e.line);
            s.append(", column ");
            s.append(e.column);
            */
            Problem p = new Problem(fileName, e.getMessage(), ProblemSeverity.ERROR, ProblemKind.LEXICAL, e.line, e.column);
            
            report(p);
        }

        private String fileName = "";

        public void setFileName(String fn) {
            fileName = fn;
        }

    }
    
    /**
     * Error reporting class that throws a {@link ParserException} on an error.
     * Uses error message created by {@link Report}.
     */
    public class AbortingReport extends Report {

        /**
         * Throws a <code>ParserException</code> with <code>msg</code> as the message.
         */
        @Override
        protected void report(Problem p) {
          throw new ParserException(p);
        }

    }

    /**
     * Error reporting class that collects error messages for later retrieval.
     * Uses error message created by {@link Report}.
     */
    public static class CollectingReport extends Report {

        private ArrayList<Problem> errors = new ArrayList<Problem>();

        /**
         * Adds error message <code>msg</code> to list.
         */ 
        @Override
        protected void report(Problem p) {
            errors.add(p);          
        }

        /**
         * Get the list of errors. Returns a reference to the internal list, not a copy.
         * @return a {@link java.util.Collection} with the reported error messages.
         */
        public Collection<Problem> getErrors() {
            return errors;
        }

        /**
         * Reset the list of errors.
         */
        public void resetErrors() {
            errors = new ArrayList<Problem>();
        }

        /**
         * Checks if any errors has been reported.
         * @return <code>true</code> if the list contains any errors.
         */
        public boolean hasErrors() {
            return !errors.isEmpty();
        }

    }

    { report = new AbortingReport(); }  // As default, throw exception on errors.

    /**
     * Set the error reporting class to use.
     * @param report    a subclass of {@link Events} to use for reporting errors.
     */
    public void setReport(Events report) {
        this.report = report;
    }

    public Events getReport() {
        return report;
    }

    private int[] lineBreakMap;

    public void setLineBreakMap(int[] map) {
        lineBreakMap = map;
    }

    private FormattingRecorder<ASTNode<?>> formattingRecorder;

    public void setFormattingRecorder(FormattingRecorder<ASTNode<?>> formattingRecorder) {
        this.formattingRecorder = formattingRecorder;
    }

    public void setFileName(String fn) {
        if (report instanceof Report)
            ((Report) report).setFileName(fn);
    }
    
    Symbol annotationTok = null;
    
    private void adjustStart(Symbol... syms) {
        AdjustableSymbol[] aSyms = new AdjustableSymbol[syms.length];
        for (int i = 0; i < syms.length; i++) {
            /* All symbols involved implements AdjustableSymbol, but since we can't change 
             * Beaver, the Java compiler can't verify that. If any Symbol used doesn't then
             * we want to know that - thus the raw cast. */
            aSyms[i] = (AdjustableSymbol) syms[i];
        }
        if (aSyms.length > 0) {
            aSyms[0].adjustStartOfEmptySymbols(aSyms, 1, 0);
        }
    }
    
    private static class Bool extends AbstractAdjustableSymbol {
        public final boolean value;
        
        public Bool(boolean val) {
            value = val;
        }
    }
    
    private static Bool newTrue() {
        return new Bool(true);
    }
    
    private static Bool newFalse() {
        return new Bool(false);
    }
    
    private static class RedeclareReplaceableHeader extends AbstractAdjustableSymbol {
        public final boolean has_redeclare;
        public final boolean has_each;
        public final boolean has_final;
        
        public RedeclareReplaceableHeader(boolean has_redeclare,
                                          boolean has_each,
                                          boolean has_final) {
            this.has_redeclare = has_redeclare;
            this.has_each = has_each;
            this.has_final = has_final;
        }
    }
    
    private static class TypePrefixes extends AbstractAdjustableSymbol {
        public final Opt<TypePrefixFlow> flow;
        public final Opt<TypePrefixVariability> variability;
        public final Opt<TypePrefixInputOutput> input_output;
        
        public TypePrefixes(Opt<TypePrefixFlow> flow, 
                            Opt<TypePrefixVariability> variability, 
                            Opt<TypePrefixInputOutput> input_output) {
            super(flow, variability, input_output);
            this.flow = flow;
            this.variability = variability;
            this.input_output = input_output;
        }
    }
    
    private static class ConstrClauseAndComment extends AbstractAdjustableSymbol {
        public final Opt<ConstrainingClause> constr;
        public final Comment comment;
        
        public ConstrClauseAndComment(ConstrainingClause constr, 
                                      Comment comment) {
            super(constr, comment);
            this.constr = new Opt(constr);
            this.comment = comment;
        }
        
        public ConstrClauseAndComment() {
            this.constr = new Opt();
            this.comment = new Comment();
        }
    }
:};
 
SourceRoot source_root
    = /* blank */ 
    {: 
        SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr; 
    :}
    | program 
    {: 
       SourceRoot sr = new SourceRoot(program); 
       return sr; 
    :};

Program program
    = stored_definition 
    {: 
        return new Program(new List().add(stored_definition)); 
    :};
  
StoredDefinition stored_definition
    = within? base_class_decl_list 
    {:
        StoredDefinition def = new StoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
        formattingRecorder.postParsing(def);
        return def; 
    :}
    | error 
    {: 
        return new BadDefinition(); 
    :};

Within within
    = WITHIN access? SEMICOLON 
    {: 
        return new Within(access); 
    :};
  
List base_class_decl_list
    = base_class_decl SEMICOLON 
    {: 
        return new List().add(base_class_decl); 
    :}
    | base_class_decl_list base_class_decl SEMICOLON 
    {: 
        base_class_decl_list.add(base_class_decl);
        return base_class_decl_list; 
    :};

BaseClassDecl anonymous_short_class 
    = extends_clause_short_class
    {:
        return new ShortClassDecl(
            new IdDecl("'Anonymous Class'"),
            false, false, 
            new MClass(), 
            false, false, false, false, false, 
            new Opt(), new Opt(), 
            extends_clause_short_class); 
    :};

BaseClassDecl base_class_decl 
    = has_encapsulated 
      has_partial 
      restriction  
      id_decl.start 
      string_comment? 
      clause_star
      external_clause?
      class_annotation?
      end_decl
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        return new FullClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl); 
    :}
    | has_encapsulated 
      has_partial 
      restriction  
      id_decl.class_name EQUALS
      extends_clause_short_class 
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        return new ShortClassDecl(
            class_name, 
            has_encapsulated.value, 
            has_partial.value, 
            restriction, 
            false, false, false, false, false, 
            new Opt(), new Opt(),
            extends_clause_short_class);
    :}
    | has_encapsulated 
      has_partial 
      restriction 
      EXTENDS 
      id_decl.start 
      class_modification?
      string_comment? 
      clause_star
      external_clause?
      class_annotation?
      end_decl 
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        InlineExtendsClause ext = new InlineExtendsClause(
            new NamedAccess(start.getID()),
            class_modification,
            new Opt());
        return new ExtendClassDecl(
            start,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            string_comment,
            clause_star,
            external_clause,
            class_annotation,
            end_decl, 
            ext); 
    :}
    | has_encapsulated
      has_partial
      restriction
      id_decl.enum_name
      EQUALS
      ENUMERATION
      LPAREN
      enum_specification
      RPAREN
      comment
    {:
        adjustStart(has_encapsulated, has_partial, restriction);
        return new EnumClassDecl(
            enum_name,
            has_encapsulated.value,
            has_partial.value,
            restriction,
            false, false, false, false, false, 
            new Opt(), new Opt(),
            comment.getStringCommentOpt(),
            new List(new DefaultElementList(new List(enum_specification))),
            new Opt(),
            comment.getAnnotationOpt(),
            new EndDecl(enum_name.getID()),
            ENUMERATION);
    :}
    | error 
    {: 
      return new BadClassDecl();
    :};

ExtendsClauseShortClass extends_clause_short_class
    = type_prefixes
      access_scalar
      array_subscripts?
      class_modification?
      comment 
    {:
        adjustStart(type_prefixes, access_scalar);
        return new ExtendsClauseShortClass(
            access_scalar,
            class_modification, 
            new Opt<Annotation>(),
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            array_subscripts, 
            comment);
    :}
    ;

ComponentClause enum_specification
    = enum_contents
    {:
        return new ComponentClause(
                false, false, false, false, false,
                new Opt(),
                new Opt(new Constant()),
                new Opt(),
                new NamedAccess("EnumType"),
                new Opt(),
                enum_contents,
                new Opt(),
                new Comment());
    :}
    ;

List enum_contents
    = COLON                {: return new List(); :}
    | enum_literal_list    {: return enum_literal_list; :}
    ;
  
List enum_literal_list
    = enum_literal
    {:
        return new List(enum_literal);
    :}
    | enum_literal_list
      COMMA
      enum_literal
    {:
        enum_literal_list.add(enum_literal); 
        return enum_literal_list;
    :}
    ;

EnumLiteralDecl enum_literal
    = id_decl
      comment
    {:
        return new EnumLiteralDecl(
                id_decl,
                new Opt(),
                new Opt(),
                new Opt(),
                comment);
    :}
    ;

TypePrefixFlow type_prefix_flow 
    = FLOW      {: return new Flow();   :}
    | STREAM    {: return new Stream(); :}
    ;

TypePrefixVariability type_prefix_variability 
    = DISCRETE    {: return new Discrete();  :}
    | PARAMETER   {: return new Parameter(); :}
    | CONSTANT    {: return new Constant();  :}
    ;

TypePrefixInputOutput type_prefix_input_output
    = INPUT     {: return new Input();  :}
    | OUTPUT    {: return new Output(); :}
    ;

TypePrefixes type_prefixes 
    = type_prefix_flow?
      type_prefix_variability?
      type_prefix_input_output?
    {:
        adjustStart(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
        return new TypePrefixes(type_prefix_flow, type_prefix_variability, type_prefix_input_output);
    :}
    ;


Restriction restriction
    = CLASS                   {: return new MClass();              :}
    | MODEL                   {: return new Model();               :}
    | BLOCK                   {: return new Block();               :}
    | CONNECTOR               {: return new Connector();           :}
    | EXPANDABLE CONNECTOR    {: return new ExpandableConnector(); :}
    | TYPE                    {: return new MType();               :}
    | PACKAGE                 {: return new MPackage();            :}
    | FUNCTION                {: return new Function();            :}
    | RECORD                  {: return new Record();              :}
    | OPERATOR RECORD         {: return new OperatorRecord();      :}
    | OPERATOR FUNCTION       {: return new OperatorFunction();    :}
    | OPERATOR                {: return new Operator();            :}
    ;

Bool has_partial
    = PARTIAL     {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_encapsulated 
    = ENCAPSULATED {: return newTrue();  :}
    | /* blank */  {: return newFalse(); :}
    ;

Bool has_inner
    = INNER       {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_outer
    = OUTER       {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_redeclare
    = REDECLARE   {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_each
    = EACH        {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

Bool has_final
    = FINAL       {: return newTrue();  :}
    | /* blank */ {: return newFalse(); :}
    ;

RedeclareReplaceableHeader redeclare_replaceable_header
    = REDECLARE 
      has_each
      has_final 
      REPLACEABLE 
    {:
        return new RedeclareReplaceableHeader(true, has_each.value, has_final.value);
    :}
    | has_each
      has_final 
      REPLACEABLE 
    {:
        adjustStart(has_each, has_final, REPLACEABLE);
        return new RedeclareReplaceableHeader(false, has_each.value, has_final.value);
    :}
    ;


List clause_star
    = default_element_list
    {:
        return new List(default_element_list);
    :}
    | /* blank */
    {: 
        return new List();
    :}
    | clause_star
      clause
    {:
        return clause_star.add(clause);
    :}
    ;

DefaultElementList default_element_list
    = element_plus
    {:
        return new DefaultElementList(element_plus);
    :}
    ;

List element_plus
    = element
    {:
        return new List(element); 
    :} 
    | element_plus 
      element
    {: 
        return element_plus.add(element);
    :}
    ;


Clause clause
    = PUBLIC
      element*
    {:
        return new PublicElementList(element);
    :}
    | PROTECTED
      element*
    {:
        return new ProtectedElementList(element);
    :}
    | EQUATION
      abstract_equation*
    {:
        return new EquationClause(abstract_equation);
    :}
    | INITIAL_EQUATION
      abstract_equation*
    {:
        return new InitialEquationClause(abstract_equation);
    :}
    | ALGORITHM
      statement*
    {:
        return new Algorithm(statement);
    :}
    | INITIAL_ALGORITHM
      statement*
    {:
        return new InitialAlgorithm(statement);
    :}
    ;


ExternalClause external_clause 
    = EXTERNAL
      external_language?
      external_function_call?
      annotation?
      SEMICOLON
    {:
        return new ExternalClause(external_language, external_function_call, annotation);
    :}
    ;

ExternalLanguage external_language
    = STRING.s    {: return new ExternalLanguage(s); :}
    ;

Annotation class_annotation 
    = annotation 
      SEMICOLON 
    {:
        formattingRecorder.addItem(FormattingType.VISIBILITY_INFO, ";", SEMICOLON);
        return annotation;
    :}
    ;

ExternalFunctionCall external_function_call
    = access
      EQUALS
      id_decl
      LPAREN
      arg_list
      RPAREN
    {:
        return new ExternalFunctionCall(new Opt(access), id_decl, arg_list);
    :}
    | id_decl
      LPAREN
      arg_list
      RPAREN
    {:
        return new ExternalFunctionCall(new Opt(), id_decl, arg_list);
    :}
    ;


Element element 
    = has_redeclare
      has_final 
      has_inner 
      has_outer 
      base_class_decl 
      SEMICOLON 
    {: 
        adjustStart(has_redeclare, has_final, has_inner, has_outer, base_class_decl);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        return base_class_decl;
    :}
    | has_redeclare
      has_final 
      has_inner 
      has_outer 
      REPLACEABLE
      base_class_decl
      constraining_clause_and_comment 
      SEMICOLON 
    {: 
        adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        base_class_decl.setRedeclare(has_redeclare.value);
        base_class_decl.setFinal(has_final.value);
        base_class_decl.setInner(has_inner.value);
        base_class_decl.setOuter(has_outer.value);
        base_class_decl.setReplaceable(true);
        base_class_decl.setConstrainingClauseOpt(constraining_clause_and_comment.constr);
        base_class_decl.setConstrainingClauseComment(constraining_clause_and_comment.comment);
        return base_class_decl;
    :}  
    | extends_clause SEMICOLON 
    {: 
        return extends_clause;
    :}
    | import_clause SEMICOLON 
    {: 
        return import_clause;
    :}
    | has_redeclare
      has_final 
      has_inner 
      has_outer 
      type_prefixes 
      access_scalar 
      array_subscripts? 
      component_list 
      SEMICOLON 
    {:
        adjustStart(has_redeclare, has_final, has_inner, has_outer, type_prefixes, access_scalar);
        return new ComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            false,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            new Opt(),
            new Comment());
    :}
    | has_redeclare 
      has_final 
      has_inner 
      has_outer 
      REPLACEABLE 
      type_prefixes 
      access_scalar 
      array_subscripts? 
      component_list 
      constraining_clause_and_comment 
      SEMICOLON 
    {: 
        adjustStart(has_redeclare, has_final, has_inner, has_outer, REPLACEABLE);
        return new ComponentClause(
            has_redeclare.value,
            has_final.value,
            has_inner.value,
            has_outer.value,
            true,
            type_prefixes.flow,
            type_prefixes.variability,
            type_prefixes.input_output,
            access_scalar,
            array_subscripts,
            component_list,
            constraining_clause_and_comment.constr,
            constraining_clause_and_comment.comment);
    :}
    | error SEMICOLON
    {: 
        return new BadElement();
    :}
    ;

ConstrClauseAndComment constraining_clause_and_comment
    = constraining_clause
      comment
    {:
        return new ConstrClauseAndComment(constraining_clause, comment);
    :}
    | /* blank */
    {:
        return new ConstrClauseAndComment();
    :}
    ;

ConstrainingClause constraining_clause 
    = CONSTRAINEDBY 
      access 
      class_modification?
    {: 
        return new ConstrainingClause(access, class_modification);
    :}
    ;

ExtendsClause extends_clause 
    = EXTENDS 
      access 
      class_modification? 
      annotation?
    {: 
        return new ExtendsClause(access, class_modification, annotation);
    :}
  ;

ImportClause import_clause
    = IMPORT
      access_scalar
      comment
    {:
        return new ImportClauseQualified(access_scalar, comment);
    :}
    | IMPORT
      access_scalar
      DOTMULT
      comment
    {:
        return new ImportClauseUnqualified(access_scalar, comment);
    :}
    | IMPORT
      id_decl.alias
      EQUALS
      access_scalar
      comment
    {:
        return new ImportClauseRename(access_scalar, comment, alias);
    :}
    ;


ArraySubscripts array_subscripts
    = LBRACK
      subscript_list
      RBRACK
    {:
        return new ArraySubscripts(subscript_list);
    :}
    ;

List subscript_list
    = subscript
    {:
        return new List().add(subscript);
    :}
    | subscript_list
      COMMA
      subscript
    {:
        subscript_list.add(subscript);
        return subscript_list;
    :}
    ;

Subscript subscript 
    = COLON   {: return new ColonSubscript();  :}
    | exp     {: return new ExpSubscript(exp); :}
    ;


List component_list
    = component_decl
    {:
        return new List(component_decl);
    :}
    | component_list
      COMMA
      component_decl
    {:
        component_list.add(component_decl);
        return component_list;
    :}
    ;

ComponentDecl component_decl
    = id_decl.comp_name
      array_subscripts?
      modification?
      conditional_attribute?
      comment
    {:
        return new ComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 conditional_attribute, 
                                 comment);
    :}
    ;

ComponentDecl component_decl_no_conditional
    = id_decl.comp_name
      array_subscripts?
      modification?
      comment
    {:
        return new ComponentDecl(comp_name, 
                                 array_subscripts, 
                                 modification, 
                                 new Opt(), 
                                 comment);
    :}
    ;

ConditionalAttribute conditional_attribute
    = IF exp    {: return new ConditionalAttribute(exp); :}
    ;

Modification modification 
    = complete_modification   {: return complete_modification; :}
    | value_modification      {: return value_modification;    :}
// Assign modification for binding equations in functions - enable after figuring out 
// a good way to make it an error outside of functions. Preferably parse error, but that 
// likely requires much more code duplication then we want to accept.
//  | assign_modification     {: return assign_modification;   :}
    ;


CompleteModification complete_modification
    = class_modification
      value_modification?
    {:
        return new CompleteModification(class_modification, value_modification);
    :}
    ;
  
ValueModification value_modification
    = EQUALS exp          {: return new ValueModification(exp); :}
    | COLON EQUALS exp    {: return new ValueModification(exp); :}
    ;

/*  
// Assign modification for binding equations in functions - enable after figuring out 
// a good way to make it an error outside of functions. Preferably parse error, but that 
// likely requires much more code duplication then we want to accept.
AssignModification assign_modification
    = COLON EQUALS exp    {: return new AssignModification(exp); :}
    ;
*/

ClassModification class_modification
    = LPAREN
      RPAREN
    {:
        return new ClassModification();
    :}
    | LPAREN
      argument_list
      RPAREN
    {:
        return new ClassModification(argument_list);
    :}
    ;

List argument_list
    = argument
    {:
        return new List().add(argument);
    :}
    | argument_list
      COMMA
      argument
    {:
        argument_list.add(argument);
        return argument_list;
    :}
    ;

Argument argument
    = has_each 
      has_final 
      access 
      modification? 
      comment
    {: 
        adjustStart(has_each, has_final, access);
        return new ComponentModification(
            has_each.value, 
            has_final.value, 
            access, 
            modification, 
            comment);
    :}
    | redeclare_replaceable_header 
      base_class_decl 
      constraining_clause?
    {:
        adjustStart(redeclare_replaceable_header, base_class_decl);
        NamedAccess name = new NamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setConstrainingClauseOpt(constraining_clause);
        base_class_decl.setReplaceable(true);
        base_class_decl.setRedeclare(redeclare_replaceable_header.has_redeclare);
        return new ClassRedeclare(
            redeclare_replaceable_header.has_each, 
            redeclare_replaceable_header.has_final, 
            name, 
            base_class_decl);
    :} 
    | REDECLARE 
      has_each 
      has_final  
      base_class_decl 
    {: 
        NamedAccess name = new NamedAccess(base_class_decl.getName().getID());
        name.setLocationNoTree(base_class_decl.getName());
        base_class_decl.setRedeclare(true);
        return new ClassRedeclare(
            has_each.value,
            has_final.value,
            name,
            base_class_decl);
    :}
    | redeclare_replaceable_header.header 
      component_clause_in_argument.cc
      constraining_clause.constr? 
    {:
        adjustStart(header, cc);
        cc.setConstrainingClauseOpt(constr);
        cc.setLocationNoTree(header, (constr.hasChild() ? constr : cc));
        cc.setRedeclare(header.has_redeclare);
        return new ComponentRedeclare(
            header.has_each, 
            header.has_final, 
            cc.createAccessForRedeclareNode(),
            cc); 
    :}
    | REDECLARE 
      has_each 
      has_final 
      component_clause_in_argument.cc
    {: 
        cc.setReplaceable(false);
        cc.setLocationNoTree(REDECLARE, cc);
        return new ComponentRedeclare(
            has_each.value, 
            has_final.value, 
            cc.createAccessForRedeclareNode(),
            cc); 
    :}
    | error 
    {: 
        return new BadArgument();
    :}
    ;

ComponentClause component_clause_in_argument
    = type_prefixes 
      access_scalar 
      component_decl_no_conditional
    {:
        adjustStart(type_prefixes, access_scalar);
        return new ComponentClause(
            true,   // Changed in argument rule for case without "redeclare"
            false, 
            false, 
            false, 
            true,   // Changed in argument rule for case without "replaceable"
            type_prefixes.flow, 
            type_prefixes.variability, 
            type_prefixes.input_output, 
            access_scalar, 
            new Opt(), 
            new List(component_decl_no_conditional), 
            new Opt(), 
            new Comment());
    :}
    ;

Annotation annotation
    = annotation_tok
      class_modification
    {:
        annotationTok = null;
        return new ParseAnnotation(class_modification);
    :}
    ;

Symbol annotation_tok
    = ANNOTATION
    {:
        if (annotationTok != null) {
            getReport().syntaxError(ANNOTATION);
        }
        annotationTok = ANNOTATION;
        return new Symbol(ANNOTATION);
    :}
    ;

AbstractEquation abstract_equation
    = exp.left
      EQUALS 
      exp.right 
      comment 
      SEMICOLON
    {: 
        return new Equation(comment, left, right);
    :}
    | if_equation 
      SEMICOLON
    {:
        return if_equation;
    :}
    | for_clause_e 
      SEMICOLON
    {:
        return for_clause_e;
    :}
    | when_equation 
      SEMICOLON
    {:
        return when_equation;
    :}
    | CONNECT
      LPAREN
      access.a
      COMMA
      access.b
      RPAREN
      comment
      SEMICOLON
    {:
        return new ConnectClause(comment, a, b);
    :}
    | LPAREN 
      function_call_left_list
      RPAREN
      EQUALS
      function_call
      comment
      SEMICOLON
    {:
        return new FunctionCallEquation(comment, function_call_left_list, function_call);
    :}
    | function_call
      comment
      SEMICOLON
    {:
        return new FunctionCallEquation(comment, new List(), function_call);
    :}
    ;

List function_call_left_list
    = function_call_left.a
      COMMA
      function_call_left.b
    {: 
        return new List().add(a).add(b);
    :}
    | function_call_left_list
      COMMA
      function_call_left
    {:
        return function_call_left_list.add(function_call_left);
    :}
    ;

FunctionCallLeft function_call_left
    = /* blank */  {: return new FunctionCallLeft(); :}
    | access       {: return new FunctionCallLeft(new Opt(access)); :}
    ;

ForClauseE for_clause_e
    = FOR
      for_indices
      LOOP
      abstract_equation*
      END_FOR
      comment
    {:
        return new ForClauseE(comment, for_indices,abstract_equation);
    :}
    ;


List for_indices
    = for_index
    {:
        return new List().add(for_index);
    :}
    | for_indices
      COMMA
      for_index
    {:
        for_indices.add(for_index);
        return for_indices;
    :}
    ;

ForIndex for_index
    = for_index_decl for_in_exp?
    {: 
        ForIndex f = new ForIndex(
            false,
            false,
            false,
            false,
            false,
            new Opt(),
            new Opt(new IndexParameter()),
            new Opt(),
            new NamedAccess("Integer"),
            new Opt(),
            new List(for_index_decl),
            new Opt(),
            new Comment(),
            for_in_exp); 
        return f; 
    :}
    ;

ForIndexDecl for_index_decl
    = id_decl
    {:
        return new ForIndexDecl(
            id_decl,
            new Opt(),
            new Opt(),
            new Opt(),
            new Comment());
    :}
    ;

Exp for_in_exp
    = IN exp.e    {: return e; :}
    ;

WhenEquation when_equation
    = WHEN
      exp.test
      THEN
      abstract_equation*
      else_when_equation?
      END_WHEN
      comment
    {: 
        return new WhenEquation(comment,
                                abstract_equation,
                                test, 
                                else_when_equation); 
    :}
    ;

WhenEquation else_when_equation
    = ELSEWHEN
      exp.test
      THEN
      abstract_equation*
      else_when_equation?
    {: 
        return new WhenEquation(new Comment(),
                                abstract_equation, 
                                test, 
                                else_when_equation); 
    :}
  ;

IfEquation if_equation
    = IF
      exp.test
      THEN
      abstract_equation*
      else_if_equation?
      END_IF
      comment
    {:
        return new IfEquation(comment, 
                              abstract_equation, 
                              test, 
                              else_if_equation);
    :}
    ;

IfWhenElseEquation else_if_equation
    = ELSEIF
      exp.test
      THEN
      abstract_equation*
      else_if_equation?
    {:
        return new IfEquation(new Comment(),
                              abstract_equation, 
                              test, 
                              else_if_equation);
    :}
    | ELSE
      abstract_equation*
    {:
        return new ElseEquation(new Comment(), 
                                abstract_equation); 
    :}
    ;


Statement statement
    = access.left ASSIGN exp.right comment SEMICOLON
                                      {: return new AssignStmt(comment, left, right); :}
    | function_call_stmt SEMICOLON    {: return function_call_stmt; :}
    | BREAK comment SEMICOLON         {: return new BreakStmt(comment); :} 
    | RETURN comment SEMICOLON        {: return new ReturnStmt(comment); :}
    | if_stmt SEMICOLON               {: return if_stmt; :}
    | when_stmt SEMICOLON             {: return when_stmt; :}
    | for_stmt SEMICOLON              {: return for_stmt; :}
    | while_stmt SEMICOLON            {: return while_stmt; :}
    | error                           {: return new BadStatement(); :}
    ;

FunctionCallStmt function_call_stmt =
    LPAREN function_call_stmt_left_list RPAREN ASSIGN function_call comment  
                           {: return new FunctionCallStmt(comment, function_call_stmt_left_list, function_call); :}
  | function_call comment  {: return new FunctionCallStmt(comment, new List(), function_call); :}
  ;

List function_call_stmt_left_list
    = function_call_left
    {:
        return new List().add(function_call_left);
    :}
    | function_call_stmt_left_list
      COMMA
      function_call_left
    {:
        return function_call_stmt_left_list.add(function_call_left);
    :}
    ;

IfStmt if_stmt =
    IF if_clause_list else_stmts END_IF comment {: return new IfStmt(comment, if_clause_list, new Opt(else_stmts)); :}
  | IF if_clause_list END_IF comment {: return new IfStmt(comment, if_clause_list, new Opt()); :}
  ;  

List if_clause_list =
    if_clause                        {: return new List().add(if_clause); :}
  | if_clause_list ELSEIF if_clause  {: return if_clause_list.add(if_clause); :}
  ;

IfClause if_clause =
  exp THEN statement*  {: return new IfClause(exp, statement); :}
  ;

ElseClause else_stmts =
  ELSE statement*  {: return new ElseClause(statement); :}
  ;

WhenStmt when_stmt =
  WHEN when_clause_list END_WHEN comment {: return new WhenStmt(comment, when_clause_list); :}
  ;  

List when_clause_list =
    when_clause                            {: return new List().add(when_clause); :}
  | when_clause_list ELSEWHEN when_clause  {: return when_clause_list.add(when_clause); :}
  ;

WhenClause when_clause =
  exp THEN statement*  {: return new WhenClause(exp, statement); :}
  ;

ForStmt for_stmt =
  FOR for_indices LOOP for_stmt_list END_FOR comment  
                         {: return new ForStmt(comment, for_indices, for_stmt_list); :}
  ;
  
ForStmtList for_stmt_list =
  statement* {: return new ForStmtList(statement); :}
  ;

WhileStmt while_stmt = 
  WHILE exp LOOP statement* END_WHILE comment  {: return new WhileStmt(comment, exp, statement); :}
  ;
  
Exp exp =
  simple_expression {: return simple_expression; :}
  | if_exp           {: return if_exp; :}
  ;

IfExp if_exp =
  IF exp.ifexp THEN exp.thenexp else_if_exp 
  		{: return new IfExp(ifexp, thenexp, else_if_exp); :}
  ;  

Exp else_if_exp =
   ELSEIF exp.ifexp THEN exp.thenexp else_if_exp 
		{: return new IfExp(ifexp, thenexp, else_if_exp); :}
 | ELSE exp   {: return exp; :}
  ;

Exp simple_expression = 
    log_exp 
        {: return log_exp; :}
  | log_exp.l1 COLON log_exp.l2
        {: RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           return r; :}
  | log_exp.l1 COLON log_exp.l2 COLON log_exp.l3
        {: RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           r.addExp(l3);
           return r; :}
  ;

Exp log_exp = 
  log_exp.a OR log_exp.b {: return new OrExp(a,b); :}  
  | log_exp.a AND log_exp.b {: return new AndExp(a,b); :}  
  | NOT relation.a {: return new NotExp(a); :}  
  | relation {: return relation; :}
;

Exp relation =
  artm_exp.a LT artm_exp.b {: return new LtExp(a,b); :}
  | artm_exp.a LEQ artm_exp.b {: return new LeqExp(a,b); :}
  | artm_exp.a GT artm_exp.b {: return new GtExp(a,b); :}
  | artm_exp.a GEQ artm_exp.b {: return new GeqExp(a,b); :}
  | artm_exp.a EQ artm_exp.b {: return new EqExp(a,b); :}
  | artm_exp.a NEQ artm_exp.b {: return new NeqExp(a,b); :}
  | artm_exp.a {: return a; :}	
  ;
  
  
  Exp artm_exp =
   additive_exp {: return additive_exp; :}
   ;

  Exp additive_exp =
     multiplicative_exp.e    {: return e; :}
   | additive_exp.e1 PLUS multiplicative_exp.e2      {: return new AddExp(e1, e2); :}
   | additive_exp.e1 MINUS multiplicative_exp.e2     {: return new SubExp(e1, e2); :}
   | additive_exp.e1 DOTPLUS multiplicative_exp.e2   {: return new DotAddExp(e1, e2); :}
   | additive_exp.e1 DOTMINUS multiplicative_exp.e2  {: return new DotSubExp(e1, e2); :}
   ;

  Exp multiplicative_exp =
     unary_exp.e                                     {: return e; :}
   | multiplicative_exp.e1 MULT unary_exp.e2     {: return new MulExp(e1, e2); :}
   | multiplicative_exp.e1 DIV unary_exp.e2      {: return new DivExp(e1, e2); :}
   | multiplicative_exp.e1 DOTMULT unary_exp.e2  {: return new DotMulExp(e1, e2); :}
   | multiplicative_exp.e1 DOTDIV unary_exp.e2   {: return new DotDivExp(e1, e2); :} 
   ;


Exp unary_exp =
   pow_exp          {: return pow_exp; :}
   | MINUS unary_exp       {: return new NegExp(unary_exp); :}
   | PLUS unary_exp        {: formattingRecorder.addItem(FormattingType.NON_BREAKING_WHITESPACE, "+", PLUS);
                              return unary_exp; :}
   ;

Exp pow_exp =
    primary {:return primary; :}
    | primary.a POW primary.e    {: return new PowExp(a,e); :}
    | primary.a DOTPOW primary.e {: return new DotPowExp(a,e); :}
    ;

Exp primary =        
   UNSIGNED_NUMBER.n    {: return new RealLitExp(n); :}
  | UNSIGNED_INTEGER.n    {: return new IntegerLitExp(n); :}
  | TRUE                {: return new BooleanLitExpTrue(); :}
  | FALSE                {: return new BooleanLitExpFalse(); :}
  | STRING.s               {: return new StringLitExp(s); :}
  | access_expression   {: return access_expression; :}
  | der_expression      {: return der_expression; :}
  | LPAREN exp.a RPAREN {: formattingRecorder.addItem(FormattingType.PARENTHESIS, "(", LPAREN);
                           formattingRecorder.addItem(FormattingType.PARENTHESIS, ")", RPAREN);
                           return a; :}
  | function_call        {: return function_call; :}
  | LBRACK matrix RBRACK {: return matrix; :}
  | LBRACE function_arguments RBRACE {: return new ArrayConstructor(function_arguments); :}
  | TIME                {: return new TimeExp(); :}
  | END                 {: return new EndExp(); :} 
  ;

FunctionCall function_call 
    = access
      LPAREN
      function_arguments?
      RPAREN
    {:
        return new FunctionCall(access, function_arguments);
    :}
    ;

PartialFunctionCall partial_function_call
    = FUNCTION
      access
      LPAREN
      function_arguments_named?
      RPAREN
    {:
        return new PartialFunctionCall(access, function_arguments_named);
    :}
    | FUNCTION
      access
    {:
        return new PartialFunctionCall(access, new Opt());
    :}
    ;

FunctionArguments function_arguments =
    exp FOR for_indices               {: List arg_list_f = new List().add(new IterExp(exp, for_indices));
                                         return new FunctionArguments(arg_list_f, new List()); :} 
  | arg_list_p                        {: return new FunctionArguments(arg_list_p, new List()); :}  
  | arg_list_p COMMA named_arguments  {: return new FunctionArguments(arg_list_p, named_arguments); :}
  | function_arguments_named
  ;
  
FunctionArguments function_arguments_named =
  named_arguments {: return new FunctionArguments(new List(), named_arguments); :}
  ;
  
List named_arguments =
    named_argument                       {: return new List().add(named_argument); :}
  | named_arguments COMMA named_argument {: return named_arguments.add(named_argument); :}
  ;
  
Exp function_argument_exp =
 exp                               {: return exp; :}
 | partial_function_call          {: return partial_function_call; :}  
 ;
  
NamedArgument named_argument =
  named_argument_id EQUALS function_argument_exp {: return new NamedArgument(named_argument_id,function_argument_exp); :}
  ;

Access named_argument_id = 
  ID.id {: return new NamedAccess(id); :}
  ;

Matrix matrix = 
    matrix_row                   {: return new Matrix(new List().add(matrix_row)); :}
  | matrix SEMICOLON matrix_row  {: matrix.addRow(matrix_row); 
                                    return matrix; :}      
  ;  
  
MatrixRow matrix_row = 
    exp                   {: return new MatrixRow(new List().add(exp)); :}
  | matrix_row COMMA exp  {: matrix_row.addExp(exp); 
                             return matrix_row; :}
  ; 
  
List arg_list = 
                        {: return new List(); :}
  | exp                 {: return new List().add(exp); :}
  | arg_list COMMA exp  {: arg_list.add(exp); 
                           return arg_list; :}
  ;
  
List arg_list_p = 
  function_argument_exp                   {: return new List().add(function_argument_exp); :}
  | arg_list_p COMMA function_argument_exp  {: return arg_list_p.add(function_argument_exp); :}
  ;
  
Comment comment = 
  string_comment?  annotation?     {: return new Comment(string_comment,annotation); :}
  ;
  
StringComment string_comment =
  STRING.s      {: return new StringComment(s); :}
  | string_comment PLUS STRING.s {: string_comment.setComment(string_comment.getComment().concat(s));
                                    return string_comment; :}
  
  ;
 
 IdDecl id_decl = 
   ID.id   {: return new IdDecl(id); :}
 ;

AccessExp access_expression
    = access {: return new AccessExp(access); :}
    ;

DerExp der_expression
    = DER LPAREN exp RPAREN  {: return new DerExp(exp); :}
    ;

Access access
    = access_loc      {: return access_loc; :}
    | DOT access_loc  {: return new GlobalAccess(access_loc); :}
    ;

Access access_loc
    = access_single
    | access_dot
    ;

Dot access_dot
    = access_single.a
      DOT
      access_single.b
    {:
        return new Dot(new List(a, b));
    :}
    | access_dot
      DOT
      access_single
    {:
        access_dot.addAccess(access_single);
        return access_dot;
    :}
    ;

NamedAccess access_single
    = access_single_array
    | access_single_scalar
    ;

ArrayAccess access_single_array
    = ID.id array_subscripts  {: return new ArrayAccess(id, array_subscripts); :}
    ;

NamedAccess access_single_scalar
    = ID.id  {: return new NamedAccess(id); :}
    ;


Access access_scalar
    = access_scalar_loc      {: return access_scalar_loc; :}
    | DOT access_scalar_loc  {: return new GlobalAccess(access_scalar_loc); :}
    ;

Access access_scalar_loc
    = access_scalar_dot
    | access_single_scalar
    ;

Dot access_scalar_dot
    = access_single_scalar.a
      DOT
      access_single_scalar.b
    {:
        return new Dot(new List(a, b));
    :}
    | access_scalar_dot
      DOT
      access_single_scalar
    {:
        access_scalar_dot.addAccess(access_single_scalar);
        return access_scalar_dot;
    :}
    ;

EndDecl end_decl
    = END_ID
    {:
        String value = (String) END_ID.value;
        String id = value.substring(3, value.length()).trim();
        return new EndDecl(id);
    :}
    ;