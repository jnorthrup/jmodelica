aspect ASTDocument {
	public String ASTNode.printPart(int startLine, int startColumn, int endLine, int endColumn, int length) {
		BaseNode match = matchSourcePosition(null, startLine, startColumn, endLine, endColumn);

		if (match == null) {
			return null;
		}

		return match.stripOverflow(startLine, startColumn, endLine, endColumn, length);
	}

	syn BaseNode ASTNode.matchSourcePosition(BaseNode bestMatch, int startLine, int startColumn, int endLine, int endColumn) {
		for (ASTNode node : this) {
			bestMatch = node.matchSourcePosition(bestMatch, startLine, startColumn, endLine, endColumn);
		}
		return bestMatch;
	}
	
	eq BaseNode.matchSourcePosition(BaseNode bestMatch, int startLine, int startColumn, int endLine, int endColumn) {
		bestMatch = BaseNode.bestMatch(bestMatch, this, startLine, startColumn, endLine, endColumn);
		
		for (ASTNode node : this) {
			BaseNode childBestMatch = node.matchSourcePosition(bestMatch, startLine, startColumn, endLine, endColumn);
			bestMatch = BaseNode.bestMatch(childBestMatch, bestMatch, startLine, startColumn, endLine, endColumn);
		}

		return bestMatch;
	}
	
	syn boolean BaseNode.spansRegion(int startLine, int startColumn, int endLine, int endColumn) {
		if (getStartLineWithFormatting() > startLine) {
			return false;
		}
		if (getStartLineWithFormatting() == startLine && getStartColumnWithFormatting() > startColumn) {
			return false;
		}
		if (getEndLineWithFormatting() < endLine) {
			return false;
		}
		if (getEndLineWithFormatting() == endLine && getEndColumnWithFormatting() < endColumn) {
			return false;
		}
		return true;
	}
	
	static BaseNode BaseNode.bestMatch(BaseNode match1, BaseNode match2, int startLine, int startColumn, int endLine, int endColumn) {
		if (match1 == null || !match1.spansRegion(startLine, startColumn, endLine, endColumn)) {
			return match2;
		} else if (match2 == null || !match2.spansRegion(startLine, startColumn, endLine, endColumn)) {
			return match1;
		}

		int score = match2.getStartLineWithFormatting() - match1.getStartLineWithFormatting();
		score += match1.getEndLineWithFormatting() - match2.getEndLineWithFormatting();
		if (score < 0) {
			return match1;
		} else if (score > 0) {
			return match2;
		} else if (match1.getStartLineWithFormatting() > match2.getStartLineWithFormatting()) {
			return match1;
		} else if (match1.getStartLineWithFormatting() < match2.getStartLineWithFormatting()) {
			return match2;
		}

		// If this code is reached, both matches start on the same line and end on the same line.
		score = match2.getStartColumnWithFormatting() - match1.getStartColumnWithFormatting();
		score += match1.getEndLineWithFormatting() - match2.getEndLineWithFormatting();
		if (score < 0) {
			return match1;
		} else if (score > 0) {
			return match2;
		}

		return match1;
	}
	
	syn int BaseNode.getStartLineWithFormatting() = (preFormatting.isScanned() ? ((ScannedFormattingItem) preFormatting).getStartLine() : Symbol.getLine(getStart()));
	syn int BaseNode.getStartColumnWithFormatting() = (preFormatting.isScanned() ? ((ScannedFormattingItem) preFormatting).getStartColumn() : Symbol.getColumn(getStart()));
	syn int BaseNode.getEndLineWithFormatting() = (postFormatting.isScanned() ? ((ScannedFormattingItem) postFormatting).getEndLine() : Symbol.getLine(getEnd()));
	syn int BaseNode.getEndColumnWithFormatting() = (postFormatting.isScanned() ? ((ScannedFormattingItem) postFormatting).getEndColumn() : Symbol.getColumn(getEnd()));
	
	syn String BaseNode.stripOverflow(int startLine, int startColumn, int endLine, int endColumn, int length) {
		String result = prettyPrintFormatted();
		int currentLine = getStartLineWithFormatting();
		int currentColumn = getStartColumnWithFormatting();
		if (currentLine == 0) ++currentLine; if (currentColumn == 0) ++currentColumn;
		int offset = 0;
		
		while (currentLine < startLine) {
			if (offset >= result.length()) {
				System.err.println("Incorrect match (overflow): " + getClass().getName() + " (" + getStartLineWithFormatting() + ", " + getStartColumnWithFormatting() + "; " + getEndLineWithFormatting() + ", " + getEndColumnWithFormatting() + ")" + " is best match for (" + startLine + ", " + startColumn + "; " + endLine + ", " + endColumn + ").");
				return null;
			}
			switch (result.charAt(offset++)) {
			case '\r':
				if (result.charAt(offset) == '\n') {
					++offset;
				}
			case '\n':
				++currentLine;
				currentColumn = 1;
				break;
			default:
				++currentColumn;
			}
		}

		int substringStart = offset + (startColumn - currentColumn);
		int substringEnd = substringStart + length;
		if (substringEnd > result.length()) {
			System.err.println("Incorrect match: " + getClass().getName() + " (" + getStartLineWithFormatting() + ", " + getStartColumnWithFormatting() + "; " + getEndLineWithFormatting() + ", " + getEndColumnWithFormatting() + ")" + " is best match for (" + startLine + ", " + startColumn + "; " + endLine + ", " + endColumn + "). It should be " + length + " characters long. [" + substringStart + ", " + substringEnd + "], " + result.length() + ". Result was [" + result + "].");
			return null;
		}

		return result.substring(substringStart, substringEnd);		
	}
	
	public BaseNode ASTNode.insertMoreFormatting(ScannedFormattingItem addedFormattingItem) {
		for (ASTNode node : this) {
			BaseNode result = node.insertMoreFormatting(addedFormattingItem);
			if (result != null) {
				return result;
			}
		}

		return null;
	}
	
	@Override
	public BaseNode BaseNode.insertMoreFormatting(ScannedFormattingItem addedFormattingItem) {
		int line = addedFormattingItem.getStartLine();
		int column = addedFormattingItem.getStartColumn();

		if (preFormatting.inside(line, column) || preFormatting.getAdjacency(addedFormattingItem) != FormattingItem.Adjacency.NONE) {
			preFormatting = preFormatting.combineItems(addedFormattingItem);
			return this;
		}
		if (insideFormatting.inside(line, column) || insideFormatting.getAdjacency(addedFormattingItem) != FormattingItem.Adjacency.NONE) {
			insideFormatting = insideFormatting.combineItems(addedFormattingItem);
			return this;
		}
		if (postFormatting.inside(line, column) || postFormatting.getAdjacency(addedFormattingItem) != FormattingItem.Adjacency.NONE) {
			postFormatting = postFormatting.combineItems(addedFormattingItem);
			return this;
		}
		
		for (ASTNode node : this) {
			BaseNode result = node.insertMoreFormatting(addedFormattingItem);
			if (result != null) {
				return result;
			}
		}
		
		return null; // Unable to find matching formatting item.
	}
	
	public void ASTNode.offsetNodesAfter(int line, int column, int byLines, int byColumnsOnLastLine) {
		for (ASTNode node : this) {
			node.offsetNodesAfter(line, column, byLines, byColumnsOnLastLine);
		}
	}
	
	public void BaseNode.offsetNodesAfter(int line, int column, int byLines, int byColumnsOnLastLine) {
		if (getStartLineWithFormatting() > line || (getStartLineWithFormatting() == line && getStartColumnWithFormatting() >= column)) {
			preFormatting.offsetItemAfter(line, column, byLines, byColumnsOnLastLine);
			insideFormatting.offsetItemAfter(line, column, byLines, byColumnsOnLastLine);
			postFormatting.offsetItemAfter(line, column, byLines, byColumnsOnLastLine);

			if (Symbol.getLine(getStart()) > line || (Symbol.getLine(getStart()) == line && Symbol.getColumn(getStart()) >= column)) {
				int newStartColumn = Symbol.getColumn(getStart());
				int newEndColumn = Symbol.getColumn(getEnd());
				if (Symbol.getLine(getStart()) == line) {
					newStartColumn += byColumnsOnLastLine;
					if (Symbol.getLine(getStart()) == Symbol.getLine(getEnd())) {
						newEndColumn += byColumnsOnLastLine;
					}
				}
				start = Symbol.makePosition(Symbol.getLine(getStart()) + byLines, newStartColumn);
				end = Symbol.makePosition(Symbol.getLine(getEnd()) + byLines, newEndColumn);
			}
		}
		
		for (ASTNode node : this) {
			node.offsetNodesAfter(line, column , byLines, byColumnsOnLastLine);
		}
	}
	
	public void ASTNode.addNewElement(Element element, int offset, IDocument document) throws BadLocationException {
		Maybe<ClassDecl> maybeClassDecl = getClassDeclAt(document, offset);
		if (maybeClassDecl.isNothing()) {
			System.err.println("Unable to find a class declaration to put the new element in.");
			return;
		}

		int startLine = document.getLineOfOffset(offset) + 1;
		int startColumn = offset - document.getLineInformationOfOffset(offset).getOffset() + 1;
		element.offsetNodesAfter(0, 0, startLine - 1, startColumn - 1);
		for (FormattingItem item : element.formatting) {
			item.offsetItemAfter(0, 0, startLine - 1, startColumn - 1);
		}
		maybeClassDecl.value().insertNewElement(element, startLine, startColumn);
	}
	
	void ClassDecl.insertNewElement(Element element, int line, int column) {
		System.err.println("This method (ClassDecl.insertNewElement(...) in the ASTDocument aspect) has only been implemented for FullClassDecl. This object instantiates the class " + getClass().getSimpleName() + ".");
	}
	
	@Override
	void FullClassDecl.insertNewElement(Element element, int line, int column) {
		int clauseNumber = originalComposition.clauseAt(line, column);
		// TODO: offsetNodesAfter(...) in ASTNode.addNewElement(...) instead.
		offsetNodesAfter(line, column, 1, 0);
		if (clauseNumber < 0) {
			originalComposition.addClause(element);
		} else {
			originalComposition.getClauses().insertChild(element, clauseNumber);
		}
		originalComposition.extractElementsTo(this);
	}
	
	syn int Composition.clauseAt(int line, int column);
	syn boolean Clause.clauseAt(int line, int column);
	
	eq Composition.clauseAt(int line, int column) {
		int i = 0;
		for (Clause clause : getClauses()) {
			if (clause.clauseAt(line, column)) {
				return i;
			}
			++i;
		}
		
		return -1;
	}
	
	eq Clause.clauseAt(int line, int column) {
		return ((getStartLineWithFormatting() < line || (getStartLineWithFormatting() == line && getStartColumnWithFormatting() <= column)) &&
				(getEndLineWithFormatting() > line || (getEndLineWithFormatting() == line && getEndColumnWithFormatting() >= column)));
	}
}