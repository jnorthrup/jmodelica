aspect ASTDocument {
	public String ASTNode.printPart(int startLine, int startColumn, int endLine, int endColumn, int length) {
		BaseNode match = matchSourcePosition(null, startLine, startColumn, endLine, endColumn);

		if (match == null) {
			return null;
		}

		return match.stripOverflow(startLine, startColumn, endLine, endColumn, length);
	}

	syn BaseNode ASTNode.matchSourcePosition(BaseNode bestMatch, int startLine, int startColumn, int endLine, int endColumn) {
		for (ASTNode node : this) {
			bestMatch = node.matchSourcePosition(bestMatch, startLine, startColumn, endLine, endColumn);
		}
		return bestMatch;
	}
	
	eq BaseNode.matchSourcePosition(BaseNode bestMatch, int startLine, int startColumn, int endLine, int endColumn) {
		bestMatch = BaseNode.bestMatch(bestMatch, this, startLine, startColumn, endLine, endColumn);
		
		for (ASTNode node : this) {
			BaseNode childBestMatch = node.matchSourcePosition(bestMatch, startLine, startColumn, endLine, endColumn);
			bestMatch = BaseNode.bestMatch(childBestMatch, bestMatch, startLine, startColumn, endLine, endColumn);
		}

		return bestMatch;
	}
	
	syn boolean BaseNode.spansRegion(int startLine, int startColumn, int endLine, int endColumn) {
		if (getStartLineWithFormatting() > startLine) {
			return false;
		}
		if (getStartLineWithFormatting() == startLine && getStartColumnWithFormatting() > startColumn) {
			return false;
		}
		if (getEndLineWithFormatting() < endLine) {
			return false;
		}
		if (getEndLineWithFormatting() == endLine && getEndColumnWithFormatting() < endColumn) {
			return false;
		}
		return true;
	}
	
	static BaseNode BaseNode.bestMatch(BaseNode match1, BaseNode match2, int startLine, int startColumn, int endLine, int endColumn) {
		if (match1 == null || !match1.spansRegion(startLine, startColumn, endLine, endColumn)) {
			return match2;
		} else if (match2 == null || !match2.spansRegion(startLine, startColumn, endLine, endColumn)) {
			return match1;
		}

		int score = match2.getStartLineWithFormatting() - match1.getStartLineWithFormatting();
		score += match1.getEndLineWithFormatting() - match2.getEndLineWithFormatting();
		if (score < 0) {
			return match1;
		} else if (score > 0) {
			return match2;
		} else if (match1.getStartLineWithFormatting() > match2.getStartLineWithFormatting()) {
			return match1;
		} else if (match1.getStartLineWithFormatting() < match2.getStartLineWithFormatting()) {
			return match2;
		}

		// If this code is reached, both matches start on the same line and end on the same line.
		score = match2.getStartColumnWithFormatting() - match1.getStartColumnWithFormatting();
		score += match1.getEndLineWithFormatting() - match2.getEndLineWithFormatting();
		if (score < 0) {
			return match1;
		} else if (score > 0) {
			return match2;
		}

		return match1;
	}
	
	syn int BaseNode.getStartLineWithFormatting() = (preFormatting.isScanned() ? ((ScannedFormattingItem) preFormatting).getStartLine() : Symbol.getLine(getStart()));
	syn int BaseNode.getStartColumnWithFormatting() = (preFormatting.isScanned() ? ((ScannedFormattingItem) preFormatting).getStartColumn() : Symbol.getColumn(getStart()));
	syn int BaseNode.getEndLineWithFormatting() = (postFormatting.isScanned() ? ((ScannedFormattingItem) postFormatting).getEndLine() : Symbol.getLine(getEnd()));
	syn int BaseNode.getEndColumnWithFormatting() = (postFormatting.isScanned() ? ((ScannedFormattingItem) postFormatting).getEndColumn() : Symbol.getColumn(getEnd()));
	
	syn String BaseNode.stripOverflow(int startLine, int startColumn, int endLine, int endColumn, int length) {
		String result = prettyPrintFormatted();
		int currentLine = getStartLineWithFormatting();
		int currentColumn = getStartColumnWithFormatting();
		if (currentLine == 0) ++currentLine; if (currentColumn == 0) ++currentColumn;
		int offset = 0;
		
		while (currentLine < startLine) {
			if (offset >= result.length()) {
				System.err.println("Incorrect match (overflow): " + getClass().getName() + " (" + getStartLineWithFormatting() + ", " + getStartColumnWithFormatting() + "; " + getEndLineWithFormatting() + ", " + getEndColumnWithFormatting() + ")" + " is best match for (" + startLine + ", " + startColumn + "; " + endLine + ", " + endColumn + ").");
				return null;
			}
			switch (result.charAt(offset++)) {
			case '\r':
				if (result.charAt(offset) == '\n') {
					++offset;
				}
			case '\n':
				++currentLine;
				currentColumn = 1;
				break;
			default:
				++currentColumn;
			}
		}

		int substringStart = offset + (startColumn - currentColumn);
		int substringEnd = substringStart + length;
		if (substringEnd > result.length()) {
			System.err.println("Incorrect match: " + getClass().getName() + " (" + getStartLineWithFormatting() + ", " + getStartColumnWithFormatting() + "; " + getEndLineWithFormatting() + ", " + getEndColumnWithFormatting() + ")" + " is best match for (" + startLine + ", " + startColumn + "; " + endLine + ", " + endColumn + "). It should be " + length + " characters long. [" + substringStart + ", " + substringEnd + "], " + result.length() + ". Result was [" + result + "].");
			return null;
		}

		return result.substring(substringStart, substringEnd);		
	}
	
	public BaseNode ASTNode.insertMoreFormatting(ScannedFormattingItem addedFormattingItem) {
		for (ASTNode node : this) {
			BaseNode result = node.insertMoreFormatting(addedFormattingItem);
			if (result != null) {
				return result;
			}
		}

		return null;
	}
	
	@Override
	public BaseNode BaseNode.insertMoreFormatting(ScannedFormattingItem addedFormattingItem) {
		int line = addedFormattingItem.getStartLine();
		int column = addedFormattingItem.getStartColumn();

		if (preFormatting.inside(line, column) || preFormatting.getAdjacency(addedFormattingItem) != FormattingItem.Adjacency.NONE) {
			preFormatting = preFormatting.combineItems(addedFormattingItem);
			return this;
		}
		if (insideFormatting.inside(line, column) || insideFormatting.getAdjacency(addedFormattingItem) != FormattingItem.Adjacency.NONE) {
			insideFormatting = insideFormatting.combineItems(addedFormattingItem);
			return this;
		}
		if (postFormatting.inside(line, column) || postFormatting.getAdjacency(addedFormattingItem) != FormattingItem.Adjacency.NONE) {
			postFormatting = postFormatting.combineItems(addedFormattingItem);
			return this;
		}
		
		for (ASTNode node : this) {
			BaseNode result = node.insertMoreFormatting(addedFormattingItem);
			if (result != null) {
				return result;
			}
		}
		
		return null; // Unable to find matching formatting item.
	}
	
	public void ASTNode.offsetNodesAfter(int line, int column, int byLines, int byColumnsOnLastLine) {
		offsetNodesAfter(line, column, byLines, byColumnsOnLastLine, BaseNode.NO_FORMATTING);
	}
	
	public void ASTNode.offsetNodesAfter(int line, int column, int byLines, int byColumnsOnLastLine, FormattingItem excludedFormattingItem) {
		for (ASTNode node : this) {
			node.offsetNodesAfter(line, column, byLines, byColumnsOnLastLine, excludedFormattingItem);
		}
	}

	@Override
	public void BaseNode.offsetNodesAfter(int line, int column, int byLines, int byColumnsOnLastLine, FormattingItem excludedFormattingItem) {
		if (line < getEndLineWithFormatting() || (line == getEndLineWithFormatting() && column <= getEndColumnWithFormatting())) {
			if (preFormatting != excludedFormattingItem) {
				preFormatting.offsetItemAfter(line, column, byLines, byColumnsOnLastLine);
			}
			if (insideFormatting != excludedFormattingItem) {
				insideFormatting.offsetItemAfter(line, column, byLines, byColumnsOnLastLine);
			}
			if (postFormatting != excludedFormattingItem) {
				postFormatting.offsetItemAfter(line, column, byLines, byColumnsOnLastLine);
			}

			if (Symbol.getLine(getStart()) > line || (Symbol.getLine(getStart()) == line && Symbol.getColumn(getStart()) >= column)) {
				int newStartColumn = Symbol.getColumn(getStart());
				int newEndColumn = Symbol.getColumn(getEnd());
				if (Symbol.getLine(getStart()) == line) {
					newStartColumn += byColumnsOnLastLine;
					if (Symbol.getLine(getStart()) == Symbol.getLine(getEnd())) {
						newEndColumn += byColumnsOnLastLine;
					}
				}
				start = Symbol.makePosition(Symbol.getLine(getStart()) + byLines, newStartColumn);
				end = Symbol.makePosition(Symbol.getLine(getEnd()) + byLines, newEndColumn);
			} else if (line < Symbol.getLine(getEnd()) || (line == Symbol.getLine(getEnd()) && column <= Symbol.getColumn(getEnd()))) {
				int newEndColumn = Symbol.getColumn(getEnd());
				end = Symbol.makePosition(Symbol.getLine(getEnd()) + byLines, newEndColumn);
			}
		}
		
		for (ASTNode node : this) {
			node.offsetNodesAfter(line, column , byLines, byColumnsOnLastLine, excludedFormattingItem);
		}
	}
	
	public void ASTNode.addNewText(String text, int offset, IDocument document) throws BadLocationException {
		int line = document.getLineOfOffset(offset) + 1;
		int column = offset - document.getLineInformationOfOffset(offset).getOffset() + 1;
		BaseNode node = classDeclAt(line, column);
		if (node == null) {
			node = getStoredDefinitionAt(line, column);
		}
		if (node == null) {
			node = getStoredDefinitionAt(line, column - 1);
			ScannedFormattingItem formattingItemFromText = new ScannedFormattingItem(FormattingItem.Type.UNKNOWN, text, line, column);
			node.postFormatting = node.postFormatting.combineItems(formattingItemFromText);
			offsetNodesAfter(line, column, formattingItemFromText.spanningLines(), formattingItemFromText.spanningColumnsOnLastLine(),
					node.postFormatting);
			return;
		}
		if (node == null) {
			System.err.println("Unable to find a proper place to put the text in.");
			return;
		}

		ScannedFormattingItem formattingItemFromText = new ScannedFormattingItem(FormattingItem.Type.UNKNOWN, text, line, column);
		FormattingItem formattingNotToOffset = node.addTextAtAppropriateNode(formattingItemFromText, line, column);
		offsetNodesAfter(line, column, formattingItemFromText.spanningLines(), formattingItemFromText.spanningColumnsOnLastLine(),
				formattingNotToOffset);
	}
	
	FormattingItem BaseNode.addTextAtAppropriateNode(ScannedFormattingItem formattingItemFromText, int line, int column) throws BadLocationException {
		System.err.println("addTextAtAppropriateNode only works for FullClassDecl and StoredDefinition. Current object instantiates the class " + getClass().getSimpleName() + ".");
		return BaseNode.NO_FORMATTING;
	}
	
	@Override
	FormattingItem StoredDefinition.addTextAtAppropriateNode(ScannedFormattingItem formattingItemFromText, int line, int column) throws BadLocationException {
		return addTextHere(formattingItemFromText, line, column);
	}
	
	@Override
	FormattingItem FullClassDecl.addTextAtAppropriateNode(ScannedFormattingItem formattingItemFromText, int line, int column) throws BadLocationException {
		BaseNode node = null;
		int clauseNumber = originalComposition.clauseAt(line, column);
		
		if (clauseNumber >= 0) {
			node = originalComposition.getClause(clauseNumber);
		} else if (getEndDecl().pointIsInside(line, column)) {
			node = getEndDecl();
		}
		
		if (node == null) {
			System.err.println("A class definition was found here, but still no proper node to put the data in.");
			return BaseNode.NO_FORMATTING;
		 }
		
		FormattingItem result = node.addTextHere(formattingItemFromText, line, column);
		//System.out.println("The resulting string [" + result.toString() + "] should be parsed and the AST should be modified.");
		return result;
	}
	
	FormattingItem BaseNode.addTextHere(ScannedFormattingItem formattingItemFromText, int line, int column) {
		if (preFormatting.inside(line, column) || line == Symbol.getLine(getStart()) && column == Symbol.getColumn(getStart())) {
			preFormatting = preFormatting.combineItems(formattingItemFromText);
			return preFormatting;
		} else if (postFormatting.inside(line, column) || line == Symbol.getLine(getEnd()) && column == Symbol.getColumn(getEnd())) {
			postFormatting = postFormatting.combineItems(formattingItemFromText);
			return postFormatting;
		} else {
			//System.out.println("Should add text to " + getClass().getSimpleName() + ":=[" + prettyPrintFormatted() + "] @ (" + line + ", " + column + "). My prefix formatting is [" + preFormatting + "] and my suffix formatting is [" + postFormatting + "].");
			FormattingItem tempFormattingItem = new ScannedFormattingItem(FormattingItem.Type.UNKNOWN, prettyPrintFormatted(),
					getStartLineWithFormatting(), getStartColumnWithFormatting(), getEndLineWithFormatting(), getEndColumnWithFormatting());
			tempFormattingItem = tempFormattingItem.combineItems(formattingItemFromText);
			return tempFormattingItem;
		}
	}
	
	public void ASTNode.addNewElement(Element element, int offset, IDocument document) throws BadLocationException {
		Maybe<ClassDecl> maybeClassDecl = getClassDeclAt(document, offset);
		if (maybeClassDecl.isNothing()) {
			System.err.println("Unable to find a class declaration to put the new element in.");
			return;
		}

		int startLine = document.getLineOfOffset(offset) + 1;
		int startColumn = offset - document.getLineInformationOfOffset(offset).getOffset() + 1;
		element.offsetNodesAfter(0, 0, startLine - 1, startColumn - 1);
		for (FormattingItem item : element.formatting) {
			item.offsetItemAfter(0, 0, startLine - 1, startColumn - 1);
		}
		maybeClassDecl.value().insertNewElement(element, startLine, startColumn);
	}
	
	void ClassDecl.insertNewElement(Element element, int line, int column) {
		System.err.println("This method (ClassDecl.insertNewElement(...) in the ASTDocument aspect) has only been implemented for FullClassDecl. This object instantiates the class " + getClass().getSimpleName() + ".");
	}
	
	@Override
	void FullClassDecl.insertNewElement(Element element, int line, int column) {
		int clauseNumber = originalComposition.clauseAt(line, column);
		// TODO: offsetNodesAfter(...) in ASTNode.addNewElement(...) instead.
		offsetNodesAfter(line, column, 1, 0);
		if (clauseNumber < 0) {
			originalComposition.addClause(element);
		} else {
			originalComposition.getClauses().insertChild(element, clauseNumber);
		}
		originalComposition.extractElementsTo(this);
	}
	
	syn ClassDecl ASTNode.classDeclAt(int line, int column);

	eq ASTNode.classDeclAt(int line, int column) {
		for (ASTNode<?> node : this) {
			ClassDecl result = node.classDeclAt(line, column);
			if (result != null) {
				return result;
			}
		}

		return null;
	}

	eq ClassDecl.classDeclAt(int line, int column) {
		ClassDecl result = super.classDeclAt(line, column);
		if (result != null) {
			return result;
		} else if (pointIsInside(line, column)) {
			return this;
		}
		return null;
	}
	
	syn int Composition.clauseAt(int line, int column);
	syn boolean Clause.clauseAt(int line, int column);
	
	eq Composition.clauseAt(int line, int column) {
		int i = 0;
		for (Clause clause : getClauses()) {
			if (clause.clauseAt(line, column)) {
				return i;
			}
			++i;
		}
		
		return -1;
	}
	
	eq Clause.clauseAt(int line, int column) {
		return pointIsInside(line, column);
	}
	
	syn boolean BaseNode.pointIsInside(int line, int column);
	
	eq BaseNode.pointIsInside(int line, int column) {
		return ((getStartLineWithFormatting() < line || (getStartLineWithFormatting() == line && getStartColumnWithFormatting() <= column)) &&
				(getEndLineWithFormatting() > line || (getEndLineWithFormatting() == line && getEndColumnWithFormatting() >= column)));
	}
	
	syn StoredDefinition ASTNode.getStoredDefinitionAt(int line, int column);
	
	eq ASTNode.getStoredDefinitionAt(int line, int column) {
		for (ASTNode<?> node : this) {
			StoredDefinition result = node.getStoredDefinitionAt(line, column);
			if (result != null) {
				return result;
			}
		}
		return null;
	}
	
	eq StoredDefinition.getStoredDefinitionAt(int line, int column) {
		if (pointIsInside(line, column)) {
			return this;
		}
		return super.getStoredDefinitionAt(line, column);
	}
}