/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


import java.util.HashSet;
import java.util.Map;
import java.util.ArrayList;
import java.util.LinkedHashSet;
import java.util.logging.Level;

aspect RootAccess {
    
    syn String SourceRoot.language() = "Modelica";
    
    inh lazy Root ASTNode.retrieveRoot();
    eq SourceRoot.getChild().retrieveRoot() = this;
    eq FlatRoot.getChild().retrieveRoot()   = this;
    syn lazy Root ASTNode.root() = retrieveRoot();
    eq Root.root() = this;
    
    syn lazy List ASTNode.emptyList() = root().emptyList();
    eq Root.emptyList() = getEmptyList();
    syn lazy List Root.getEmptyList() = new List();
    
    syn lazy HashSet ASTNode.emptyHashSet() = root().emptyHashSet();
    eq Root.emptyHashSet() = getEmptyHashSet();
    syn lazy HashSet Root.getEmptyHashSet() = new HashSet(4);
    
    syn lazy ArrayList ASTNode.emptyArrayList() = root().emptyArrayList();
    eq Root.emptyArrayList() = getEmptyArrayList();
    syn lazy ArrayList Root.getEmptyArrayList() = new ArrayList();
    
    public boolean ASTNode.hasRoot() { return (getParent() == null) ? false : getParent().hasRoot(); }
    public boolean Root.hasRoot()    { return true; }
    
    public FClass ParserHandler.newFClass() {
        return new FClass();
    }
    
    /*
     * The Parser methods are introduced here so that they can be refined in
     * extensions where other parsers are used.
     */
    
    public SourceRoot ParserHandler.parseFile(String fileName) 
       throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
        return parseModelicaFile(fileName);
    }
    
    public SourceRoot ParserHandler.parseString(String str, String fileName) 
       throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
        return parseModelicaString(str,fileName);
    }
    
    public Exp ParserHandler.parseExpString(String str)
       throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
        return parseModelicaExpString(str);
    }
    
    public SourceRoot ParserHandler.parseModelicaFile(String fileName) 
       throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
        SourceRoot sr = null;
        Reader reader = new FileReader(fileName);
        org.jmodelica.modelica.parser.ModelicaScanner scanner = 
            new org.jmodelica.modelica.parser.ModelicaScanner(new BufferedReader(reader));
        org.jmodelica.modelica.parser.ModelicaParser parser = new org.jmodelica.modelica.parser.ModelicaParser();
        parser.setLineBreakMap(scanner.getLineBreakMap());
        sr = (SourceRoot)parser.parse(scanner);
        sr.setFileName(fileName);
        return sr;
    }
    
    public SourceRoot ParserHandler.parseModelicaString(String str, String fileName) 
       throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
        SourceRoot sr = null;
        org.jmodelica.modelica.parser.ModelicaScanner scanner = 
            new org.jmodelica.modelica.parser.ModelicaScanner(new StringReader(str));
        org.jmodelica.modelica.parser.ModelicaParser parser = 
            new org.jmodelica.modelica.parser.ModelicaParser();
        parser.setLineBreakMap(scanner.getLineBreakMap());
        sr = (SourceRoot)parser.parse(scanner);
        sr.setFileName(fileName);
        return sr;
    }
    
    public Exp ParserHandler.parseModelicaExpString(String str)
       throws ParserException, beaver.Parser.Exception, FileNotFoundException, IOException{
        Exp exp = null;
        org.jmodelica.modelica.parser.ModelicaScanner scanner = 
            new org.jmodelica.modelica.parser.ModelicaScanner(new StringReader(str));
        org.jmodelica.modelica.parser.ModelicaParser parser = 
            new org.jmodelica.modelica.parser.ModelicaParser();
        exp = (Exp)parser.parse(scanner,org.jmodelica.modelica.parser.ModelicaParser.AltGoals.exp);
        //log.debug("ModelicaParser.parseExpString: "+str);
        //exp.dumpTreeBasic("");
        return exp;
    }
    
}

aspect Logging {

    /**
     * \brief Base class for logging messages from the tree.
     * 
     * This implementation discards all messages.
     */
    public class ModelicaLogger {
        /**
         * \brief Log <code>message</code> on log level <code>level</code>.
         * 
         * This implementation discards all messages.
         * 
         * Override this method to provide log facilities.
         */
        public void log(Level level, String message) {}
        
        /**
         * \brief Get the current log level.
         * 
         * This implementation returns null.
         * 
         * Override this method to provide log facilities.
         */
        public Level getLevel() { return null; }
        
        /**
         * \brief Set the current log level.
         * 
         * This implementation does nothing.
         * 
         * Override this method to provide log facilities.
         */
        public void setLevel(Level lv) { }

        public void debug(String message)   { log(Level.FINE,    message); }
        public void info(String message)    { log(Level.INFO,    message); }
        public void warning(String message) { log(Level.WARNING, message); }
        public void error(String message)   { log(Level.SEVERE,   message); }
    }

    public static ModelicaLogger ASTNode.log = new ModelicaLogger();
    
}

aspect NodeMethods {

  public void ASTNode.setStart(int start) {
    this.start = start;
  } 

  public void ASTNode.setEnd(int end) {
    this.end = end;
  }
  
  public class ASTNode{
      /**
       * \brief Copies the <code>start</code> and <code>end</code> members to 
       *        another node.
       *        
       * @param n  the node to copy the location to.
       * @return  the node given as <code>n</code>.
       */
      public <N extends ASTNode> N copyLocationTo(N n) {
          n.start = this.start;
          n.end = this.end;
          return n;
      }
  }
  
  /**
   * \brief Sets the <code>start</code> and <code>end</code> members of the node.
   */
  public void ASTNode.setLocation(int start, int end) {
    this.start = start;
    this.end = end;
  }
  
  /**
   * \brief Sets the <code>start</code> and <code>end</code> members of the node
   * to values copied from two other nodes.
   * 
   * @param start  the node to copy the <code>start</code> member from.
   * @param end    the node to copy the <code>end</code> member from.
   */
  public void ASTNode.setLocation(ASTNode start, ASTNode end) {
    this.start = start.start;
    this.end = end.end;
  }
  
  /**
   * \brief Sets the <code>start</code> and <code>end</code> members of the node
   * to values copied another node.
   */
  public void ASTNode.setLocation(ASTNode node) {
    start = node.start;
    end = node.end;
  }
 
  public int ASTNode.beginLine() { return getLine(getStart()); }
  public int ASTNode.beginColumn() { return getColumn(getStart()); }

    public String ASTNode.getNodeName() {
        return dump();
    }
    
    public String IdDecl.getNodeName() {
        return dump() + ": '" + getID() + "'";
    }

    public String Access.getNodeName() {
        return dump() + ": '" + getID() + "'";
    }
    
    public String RealLitExp.getNodeName() {
        return dump() + ": " + getUNSIGNED_NUMBER();
    }
    
    public String InstComponentDecl.getNodeName() {
        return dump() + ": '" + getComponentDecl().getClassName().qualifiedName() + " " + getComponentDecl().getName().getID() + "'";
    }
    
    /**
     * \brief Creates a new ArrayList containing all the elements in this list, in the same order.
     */
    public ArrayList<T> List.toArrayList() {
        ArrayList<T> l = new ArrayList<T>();
        for (T e : this)
            l.add(e);
        return l;
    }
    
    /**
     * \brief Replace <code>from</code> with <code>to</code>.
     * 
     * Search through children after <code>from</code>. If it is found, 
     * replace it with <code>to</code> and return <code>true</code>.
     * Comparisons are done with ==, not with equals().
     */
    public boolean List.replaceChild(T oldNode, T newNode) {
        for (int i = 0; i < getNumChild(); i++) {
            if (getChild(i) == oldNode) {
                setChild(newNode, i);
                return true;
            }
        }
        return false;
    }
    
    /**
     * \brief Return a copy of node that is not in any tree.
     * 
     * Returns <code>this</code> if node has no parent, <code>fullCopy()</code> otherwise.
     */
    public ASTNode ASTNode.unboundCopy() {
        return (parent == null) ? this : fullCopy();
    }
    
    /**
     * \brief Returns an iterable, that has an iterator that iterates over all direct FExp children.
     * 
     * The iterator passes through Lists and Opts.
     */
    public Iterable<FExp> FExp.childFExps() {
        return new ChildFExpIterable();
    }
    
    public class FExp {
        
        private class ChildFExpIterable implements Iterable<FExp> {
            public Iterator<FExp> iterator() {
                return new ChildFExpIterator();
            }
        }
        
        
        private class ChildFExpIterator implements Iterator<FExp> {
            
            Iterator<ASTNode> it1;
            Iterator<ASTNode> it2;
            FExp next = null;

            public ChildFExpIterator() {
                it1 = iterator();
                it2 = null;
                update();
            }
            
            private void update() {
                boolean cont = true;
                ASTNode node = null;
                while (cont) {
                    node = null;
                    if (it2 == null) {
                        if (it1.hasNext())
                            node = it1.next();
                        else 
                            cont = false;
                        if (node instanceof List || node instanceof Opt)
                            it2 = node.iterator();
                    } else {
                        if (it2.hasNext()) 
                            node = it2.next();
                        else 
                            it2 = null;
                    }
                    if (node instanceof FExp) 
                        cont = false;
                }
                next = (FExp) node;
            }

            public boolean hasNext() {
                return next != null;
            }

            public FExp next() {
                FExp res = next;
                update();
                return res;
            }

            public void remove() {
                throw new UnsupportedOperationException();
            }
            
        }
        
    }

}

aspect FileNames {

    syn lazy String ASTNode.fileName() = retrieveFileName();
    eq StoredDefinition.fileName() = getFileName().equals("")? retrieveFileName(): getFileName();
    
    eq Root.fileName() = getFileName();
    
    inh lazy String ASTNode.retrieveFileName();
    eq SourceRoot.getProgram().retrieveFileName() = getFileName();
    eq FlatRoot.getFClass().retrieveFileName() = getFileName();
    
    eq StoredDefinition.getChild().retrieveFileName() = getFileName().equals("")? retrieveFileName(): getFileName();
    eq FullClassDecl.getChild().retrieveFileName() =  retrieveFileName();
    eq InstNode.getInstClassDecl(int i).retrieveFileName() = getInstClassDecl(i).getClassDecl().fileName(); 
    eq InstFullClassDecl.getChild().retrieveFileName() = getClassDecl().fileName();
    eq InstComponentDecl.getChild().retrieveFileName() = getComponentDecl().fileName();
    eq InstExtends.getChild().retrieveFileName() = getExtendsClause().fileName();
    eq InstImport.getChild().retrieveFileName() = getImportClause().fileName();
    eq InstModification.getChild().retrieveFileName() = getModification().fileName();
    
    private String Root.fName = "";
    public void Root.setFileName(String fName) { this.fName = fName; }
    public String Root.getFileName() {return fName; }

    private String StoredDefinition.fName = "";
    public void StoredDefinition.setFileName(String fName) { this.fName = fName; }
    public String StoredDefinition.getFileName() {return fName; }
}
    
aspect Names {
  // simple names
  syn String Access.name() = getID();
  syn String ParseAccess.name() = getID();
  syn String ClassAccess.name() = getID();
  syn String AmbiguousAccess.name() = getID();
  syn String ComponentAccess.name() = getID();
  syn String IdDecl.name() = getID();
  syn String Dot.name() = getLeft().name() + "." + getRight().name();
  
   // simple names of InstAccess:es
  syn String InstAccess.name() = getID();
  syn String InstParseAccess.name() = getID();
  syn String InstClassAccess.name() = getID();
  syn String InstAmbiguousAccess.name() = getID();
  syn String InstComponentAccess.name() = getID();
  syn String InstDot.name() = getLeftNoTransform().name() + "." + getRightNoTransform().name(); 
  
  syn String InstNamedModification.name() = getName().name();
  
  syn lazy String Access.qualifiedName() = getID();
  eq Dot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn lazy String InstAccess.qualifiedName() = getID();
  eq InstDot.qualifiedName() = getLeft().qualifiedName() + "." + getRight().qualifiedName();
  
  syn String ClassDecl.name();
  eq BaseClassDecl.name() = getName().getID();
  eq BuiltInClassDecl.name() = getName().getID();
  //eq LibNode.name() = getName();
  
  syn String ComponentDecl.name() = getName().getID();
  
  syn String FunctionCall.name() = getName().name();
  
  syn String InstImport.name();
  eq InstImportQualified.name()   = getPackageName().getLastInstAccess().name();
  eq InstImportRename.name()      = ((ImportClauseRename) getImportClause()).getIdDecl().getID();
  eq InstImportUnqualified.name() = "*";    // To avoid returning null
  
  
  syn String ClassDecl.qualifiedName();
  eq BaseClassDecl.qualifiedName() = classNamePrefix().equals("")? 
                                                  name(): classNamePrefix() + "." + name();
  inh String BaseClassDecl.classNamePrefix();
  eq FullClassDecl.getClassDecl().classNamePrefix() = classNamePrefix().equals("")?
                                                      name(): classNamePrefix() + "." + name();
  eq BuiltInClassDecl.qualifiedName() = getName().getID();
  
  // For proxy
  public String SourceRoot.computeClassNamePrefix() {
      return "";
  }
  
  eq SourceRoot.getProgram().classNamePrefix() = computeClassNamePrefix();
  eq Root.getChild().classNamePrefix() = "";
    
  syn String InstClassDecl.qualifiedName();
  eq InstBaseClassDecl.qualifiedName() = instClassNamePrefix().equals("")? 
                                                  name(): instClassNamePrefix() + "." + name();
  inh String InstBaseClassDecl.instClassNamePrefix();
  eq InstFullClassDecl.getInstClassDecl().instClassNamePrefix() = instClassNamePrefix().equals("")?
                                                      name(): instClassNamePrefix() + "." + name();

  eq InstBuiltInClassDecl.qualifiedName() = name();
  
  eq SourceRoot.getChild().instClassNamePrefix() = "";
  eq FlatRoot.getChild().instClassNamePrefix() = "";
  eq InstRoot.getChild().instClassNamePrefix() = "";
  
  syn String InstClassDecl.primitiveName();
  eq InstBaseClassDecl.primitiveName() = name();
  eq InstBuiltInClassDecl.primitiveName() = name();
  
  eq InstFullClassDecl.primitiveName() {
    if (extendsPrimitive())
        return getInstExtends(0).getClassName().myInstClassDecl().finalClass().primitiveName();
    else 
        return name();
  }
  
  syn String InstForIndex.name() = getInstPrimitive().name();
  syn String FForIndex.name()    = getFVariable().name();
 
  syn String InstAccess.enclosingName() = "";
  eq InstDot.enclosingName() = name().substring(0, name().lastIndexOf('.'));
  
  
  inh InstClassDecl ASTNode.enclosingInstClassDecl();
  eq SourceRoot.getProgram().enclosingInstClassDecl() = null;
  eq FlatRoot.getChild().enclosingInstClassDecl() = null;
  eq InstBaseClassDecl.getChild().enclosingInstClassDecl() = this;
  eq InstComponentDecl.getChild().enclosingInstClassDecl() = myInstClass();
  
  inh BaseClassDecl ASTNode.enclosingClassDecl();
  eq SourceRoot.getProgram().enclosingClassDecl() = null;

  eq FullClassDecl.getEquation().enclosingClassDecl() = this; 
  eq FullClassDecl.getAlgorithm().enclosingClassDecl() = this; 
  eq FullClassDecl.getSuper().enclosingClassDecl() = this;  
  eq FullClassDecl.getImport().enclosingClassDecl() = this; 
  eq FullClassDecl.getClassDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getComponentDecl().enclosingClassDecl() = this; 
  eq FullClassDecl.getAnnotation().enclosingClassDecl() = this; 
  eq FullClassDecl.getExternalClause().enclosingClassDecl() = this;     

  eq ShortClassDecl.getExtendsClauseShortClass().enclosingClassDecl() = this;
  
  eq ExtendClassDecl.getClassModification().enclosingClassDecl() = this;
  eq ExtendClassDecl.getComposition().enclosingClassDecl() = this;
  
  
    /**
     * Access method for the last Access of a qualified or
     * unqualified name.
     */ 
    syn Access Access.getLastAccess() = this;
    eq Dot.getLastAccess() = getRight().getLastAccess();
    
    syn InstAccess InstAccess.getLastInstAccess() = this;
    eq InstDot.getLastInstAccess() = getRight().getLastInstAccess();
    
    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn Access Access.getFirstAccess() = this;
    eq Dot.getFirstAccess() = getLeft().getFirstAccess();

    // For proxy
    public Access SourceRoot.computeNextAccess() {
        return null;
    }
    
    inh Access Access.getNextAccess();
    eq Dot.getLeft().getNextAccess() = getRight().getFirstAccess();
    eq SourceRoot.getProgram().getNextAccess() = computeNextAccess();
    eq Root.getChild().getNextAccess() = null;

    /**
     * Access method for the first Access of a qualified or
     * unqualified name.
     */
    syn InstAccess InstAccess.getFirstInstAccess() = this;
    eq InstDot.getFirstInstAccess() = getLeft().getFirstInstAccess();
   
    inh InstAccess InstAccess.getNextInstAccess();
    eq InstDot.getLeft().getNextInstAccess() = getRight().getFirstInstAccess();
    eq ASTNode.getChild().getNextInstAccess() = null;

    
    /**
     * stripFirstAccess removes the first access in a qualified
     * name. If the name is not qualified, null is returned. 
     */
    public Access Access.stripFirstAccess() {
        return null;
    }
    
    public Access Dot.stripFirstAccess() {
        // A right skewed Dot three is stipped by
        //getRight().myDecl();
        return (Access)getRight().fullCopy();
    }
    
    syn boolean Access.isQualified() = false;
    eq Dot.isQualified() = true;
    
    /**
     * \brief Get the top node in an access (possibly qualified).
     */
    syn Access Access.getTopAccess() {
        // This can be done with inherited attributes, but is much simpler with getParent()
        if (getParent() instanceof Dot)
            return ((Dot) getParent()).getTopAccess();
        return this;
    }
    
    /**
     * \brief Get the top node in an access (possibly qualified).
     */
    syn InstAccess InstAccess.getTopAccess() {
        // This can be done with inherited attributes, but is much simpler with getParent()
        if (getParent() instanceof InstDot)
            return ((InstDot) getParent()).getTopAccess();
        return this;
    }
    
    /**
     * \brief Get the array subscripts of the last name part.
     */
    syn FArraySubscripts InstAccess.getLastFArraySubscripts() = 
        getLastInstAccess().getFArraySubscripts();
    
    syn FArraySubscripts InstAccess.getFArraySubscripts() = null;

    syn boolean InstAccess.hasFArraySubscripts() = false;
    
    /**
     * \brief Set the array subscripts of the last name part.
     */
    public void InstAccess.setLastFArraySubscripts(FArraySubscripts fas) {
        Opt o = (fas == null) ? new Opt() : new Opt(fas);
        ((InstArrayAccess) getLastInstAccess()).setFArraySubscriptsOpt(o);
    }
}

aspect FlatNames {
    
    syn String FVariable.varKind() {
        if (isIndependentConstant()) {
            return "ci";
        } else if (isDependentConstant()) {
            return "cd";
        } else if (isIndependentParameter()) {
            return "pi";
        } else if (isDependentParameter()) {
            return "pd";
        } else if (isDifferentiatedVariable()) {
            return "x";
        } else if (isDerivativeVariable()) {
            return "dx";
        } else if (isAlgebraicVariable()) {
            return "w";
        } else if (isInput()) {
            return "u";
        } else {
            return "unknown";
        }
    }
    
    public FQName.FQName(String name) {
        this(new List());
        for (String part : name.split("\\."))
            addFQNamePart(new FQNamePart(part, new Opt()));
    }

    public FQName.FQName(FQName fqname) {
        this((List)fqname.getFQNamePartList().fullCopy());
    }

    public FQName FQName.append(String name) {
        addFQNamePart(new FQNamePart(name, new Opt()));
        return this;
    }

    public FQName FQName.append(FQName fqname) {
        for (int i=0;i<fqname.getNumFQNamePart();i++)
            addFQNamePart((FQNamePart)fqname.getFQNamePart(i).fullCopy());
        return this;
    }
    
    syn FQNamePart FQName.lastFQNamePart() = getFQNamePart(getNumFQNamePart()-1);

    syn boolean FQName.hasFArraySubscripts() = isScalarized()? false:
        lastFQNamePart().hasFArraySubscripts();
    syn FArraySubscripts FQName.getFArraySubscripts() = isScalarized()? null:
        lastFQNamePart().getFArraySubscripts();

    syn boolean FIdUse.hasFArraySubscripts() = 
        getFQName().hasFArraySubscripts();
    syn FArraySubscripts FIdUse.getFArraySubscripts() = 
        getFQName().getFArraySubscripts();

    syn boolean FIdUseInstAccess.hasFArraySubscripts() = 
        getInstAccess().hasFArraySubscripts();
    syn FArraySubscripts FIdUseInstAccess.getFArraySubscripts() = 
        getInstAccess().getFArraySubscripts();

    syn boolean FIdUseExp.hasFArraySubscripts() = 
        getFIdUse().hasFArraySubscripts();
    syn FArraySubscripts FIdUseExp.getFArraySubscripts() = 
        getFIdUse().getFArraySubscripts();
    
    
    /**
     * \brief Get the array subscripts of the last name part.
     */
    syn FArraySubscripts FQName.getLastFArraySubscripts() =
        hasFArraySubscripts() ? lastFQNamePart().getFArraySubscripts() : null;
    
    /**
     * \brief Set the array subscripts of the last name part.
     */
    public void FQName.setLastFArraySubscripts(FArraySubscripts fas) {
        Opt o = (fas == null) ? new Opt() : new Opt(fas);
        lastFQNamePart().setFArraySubscriptsOpt(o);
    }
    
    syn lazy FQName InstNode.getFQNamePrefix() {
        FQName prefix = retrieveFQName();
        FQName myName = prefix!=null? new FQName(prefix):
                                      new FQName();
        return myName;  
    }
    
    syn lazy FQName InstNode.getFQName() = getFQNamePrefix();
    
    eq InstComponentDecl.getFQName() {
        
        FQName prefix = retrieveFQName();
        FQName myName = prefix!=null? new FQName(prefix):
                                      new FQName();
    
        Opt array_subscr = new Opt();
        if (isPrimitive() && isArrayDecl() ) {
            array_subscr.setChild((FArraySubscripts)getFArraySubscripts().flatten(myName),0);
        }
        
        myName.addFQNamePart(new FQNamePart(name(),array_subscr));
        return myName;
    }
    
    eq InstArrayComponentDecl.getFQName() {
        FQName prefix = retrieveFQName();

        FQName myName = prefix!=null? new FQName(prefix):
                                      new FQName();
        
        FArraySubscripts fas = new FArraySubscripts(
                new List().add(new FExpSubscript(new FIntegerLitExp(getIndex()+""))));

        if (myName.hasFArraySubscripts()) {
            myName.getFArraySubscripts().addFSubscript(fas.getFSubscript(0));
        } else {
            myName.lastFQNamePart().setFArraySubscripts(fas);
        }
        return myName;
    }   

    eq InstClassDecl.getFQName() = new FQName();
    inh lazy FQName InstNode.retrieveFQName();
    eq InstComponentDecl.getChild().retrieveFQName() = getFQName();
    eq InstComponentDecl.getInstModification().retrieveFQName() = retrieveFQName();
    eq InstReplacingComposite.getOriginalInstComponent().retrieveFQName() = retrieveFQName();
    eq InstReplacingPrimitive.getOriginalInstComponent().retrieveFQName() = retrieveFQName();
    eq InstReplacingShortClassDecl.getChild().retrieveFQName() = retrieveFQName();
    eq InstClassDecl.getChild().retrieveFQName() = null; //getFQName();
    eq InstForIndex.getChild().retrieveFQName() = null;
    
    eq InstRoot.getChild().retrieveFQName() = null;
    eq SourceRoot.getProgram().retrieveFQName() = null;

    syn String FQName.prefixName(int n) {
        StringBuilder str = new StringBuilder();
        for (int i = 0; i < n; i++) {
            FQNamePart part = getFQNamePart(i);
            str.append(part.getName());
            if (i < n-1 || isScalarized()) {
                if (part.hasFArraySubscripts()) 
                    str.append(part.getFArraySubscripts());
                if (i < n-1) 
                    str.append(".");
            }
        }
        return str.toString();
    }

    syn lazy String FQName.name() = prefixName(getNumFQNamePart());
    
    syn String FQNamePart.name() = getName();

    syn String FIdUse.name() = getFQName().name();
    syn String FIdUseExp.name() = getFIdUse().name();
    eq FDerExp.name() = derName();
    syn String FInstAccessExp.name() = getInstAccess().name();
    syn String FIdUseInstAccess.name() = getInstAccess().name();
    
    syn String FIdDecl.name() = getFQName().name();

    syn String FClass.name()        = getFQName().name();
    syn String FFunctionDecl.name() = getFQName().name();
    syn String FRecordDecl.name()   = getFQName().name();
    
    syn String FAbstractFunctionCall.name();
    eq InstFunctionCall.name()     = getName().name();
    eq FFunctionCall.name()        = getName().name();
    eq FBuiltInFunctionCall.name() = builtInName();
    
    syn String AbstractFVariable.name() = null;
    eq FVariable.name()         = getFQName().name();
    eq FFunctionVariable.name() = getFQName().name();

//  syn lazy String FQName.derName() = "der(" + name() + ")";
    
    eq FDerivativeVariable.name() = getFQName().derName();
    syn String FIdUse.derName() = getFQName().derName();
    syn String FIdUseExp.derName() = getFIdUse().derName();

    syn lazy String FQName.derName() {
        StringBuilder str = new StringBuilder();
        for (int i=0;i<getNumFQNamePart();i++) {
            if (i==getNumFQNamePart()-1) {
                str.append("der(");
            }           
            str.append(getFQNamePart(i).getName());
            //if (i<getNumFQNamePart()-1 || isScalarized()) {
                if (getFQNamePart(i).hasFArraySubscripts()) {
                    str.append(getFQNamePart(i).getFArraySubscripts().prettyPrint(""));
                }
                if (i<getNumFQNamePart()-1) {
                    str.append(".");
                }
            //}
        }
        str.append(")");
        return str.toString();
    }
    
    //syn String FIdUse.derName2() = getFQName().derName2();
    //syn String FIdUseExp.derName2() = getFIdUse().derName2();
    
    syn lazy String FQName.nameUnderscore() {
        StringBuilder str = new StringBuilder();
        for (int i=0;i<getNumFQNamePart();i++) {
            str.append(getFQNamePart(i).getName());
            if (i<getNumFQNamePart()-1 || isScalarized()) {
                if (getFQNamePart(i).hasFArraySubscripts()) {
                    for (FSubscript fs : 
                        getFQNamePart(i).getFArraySubscripts().getFSubscripts()) {
                        str.append("_");
                        str.append(fs.prettyPrint(""));
                    }
                }
                if (i<getNumFQNamePart()-1) {
                    str.append("_");
                }
            }
        }
        return str.toString();
    }

    syn String FQNamePart.nameUnderscore() = getName();

    syn String FIdUse.nameUnderscore() = getFQName().nameUnderscore();
    syn String FIdUseExp.nameUnderscore() = getFIdUse().nameUnderscore();
    eq FDerExp.nameUnderscore() = "der_" + getFIdUse().nameUnderscore();
    //syn String FInstAccessExp.nameUnderscore() = getInstAccess().nameUnderscore();
    //syn String FIdUseInstAccess.nameUnderscore() = getInstAccess().nameUnderscore();
    
    syn String FIdDecl.nameUnderscore() = getFQName().nameUnderscore();

    syn String FClass.nameUnderscore() = getFQName().nameUnderscore();
    
    syn String AbstractFVariable.nameUnderscore() = null;
    eq FVariable.nameUnderscore()           = getFQName().nameUnderscore();
    eq FDerivativeVariable.nameUnderscore() = "der_" + getFQName().nameUnderscore();
    eq FFunctionVariable.nameUnderscore()   = getFQName().nameUnderscore();
    
    syn String FQName.funcNameUnderscore(String suffix) = "func_" + nameUnderscore() + "_" + suffix;
    syn String FIdUse.funcNameUnderscore(String suffix) = getFQName().funcNameUnderscore(suffix);

    inh int FVariable.variableIndex();
    eq FClass.getFVariable(int i).variableIndex()     = i;
    eq FClass.getAliasVariable(int i).variableIndex() = getNumFVariable() + i;
    eq FForIndex.getFVariable().variableIndex()       = -1;
    eq FRecordDecl.getFVariable().variableIndex()     = -1;

    inh int FRecordDecl.recordIndex();
    eq FClass.getFRecordDecl(int i).recordIndex() = i;
    
    /**
     * \brief Copy this FQName, append a String to the copy and return the copy.
     */
    public FQName FQName.copyAndAppend(String name) {
        return fullCopy().append(name);
    }
    
    /**
     * \brief Copy this FQName, append another FQName to the copy and return the copy.
     */
    public FQName FQName.copyAndAppend(FQName name) {
        return fullCopy().append(name);
    }
    
    /**
     * \brief Create a copy of all parts but the first of this name.
     */
    public FQName FQName.copySuffix() {
        FQName res = new FQName();
        for (int i = 1; i < getNumFQNamePart(); i++)
            res.addFQNamePart(getFQNamePart(i).fullCopy());
        return res;
    }
    
    /**
     * \brief Create a copy of the first part of this name.
     */
    public FQName FQName.copyPrefix() {
        FQName res = new FQName();
        if (getNumFQNamePart() > 0)
            res.addFQNamePart(getFQNamePart(0).fullCopy());
        return res;
    }
    
    /**
     * \brief Create an FIdUseExp using a copy of this name.
     */
    public FIdUseExp FQName.createFIdUseExp() {
        return new FIdUseExp(createFIdUse()); 
    }
    
    /**
     * \brief Create an FIdUse using a copy of this name.
     */
    public FIdUse FQName.createFIdUse() {
        return new FIdUse(fullCopy()); 
    }
    
    syn String FType.name();
    eq FRealType.name()    = "Real";
    eq FIntegerType.name() = "Integer";
    eq FBooleanType.name() = "Boolean";
    eq FStringType.name()  = "String";
    eq FRecordType.name()  = getName();
    eq FUnknownType.name() = "(unknown type)";
    
    /**
     * \brief Add an equation to the first equation block.
     */
    public void FClass.addFEquation(FAbstractEquation feq) {
        getFEquationBlock(0).addFAbstractEquation(feq);
    }
    
}

aspect DebugHelpers {
    
    /**
     * \brief Convert to string. Primarily useful for debugging.
     * 
     * Default implementation uses prettyPrint().
     */
    public String ASTNode.toString() {
        return prettyPrint("");
    }
    
}

aspect FlatFunctionUtils {
     
     syn boolean FFunctionVariable.isInput()  = hasFTypePrefixInputOutput() && getFTypePrefixInputOutput().inputCausality();
     syn boolean FFunctionVariable.isOutput() = hasFTypePrefixInputOutput() && getFTypePrefixInputOutput().outputCausality();
     
     /**
      * \brief Returns a list of all InstComponentDecls declared as "input".
      */
     syn lazy ArrayList<InstComponentDecl> InstClassDecl.myInputs() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         for (InstComponentDecl icd : getInstComponentDecls())
             if (icd.isInput())
                 l.add(icd);
         return l;
     }
     
     /**
      * \brief Returns a list of all InstComponentDecls declared as "output".
      */
     syn lazy ArrayList<InstComponentDecl> InstClassDecl.myOutputs() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         for (InstComponentDecl icd : getInstComponentDecls())
             if (icd.isOutput())
                 l.add(icd);
         return l;
     }
     
     /**
      * \brief Returns a list of all contained InstComponentDecls that may be altered by a modification.
      */
     syn lazy ArrayList<InstComponentDecl> InstClassDecl.myModifiableComponents() {
         ArrayList<InstComponentDecl> l = new ArrayList<InstComponentDecl>();
         // TODO: Only add components that are not final or constant
         // TODO: Are there other reasons a component might not be modifiable?
         for (InstComponentDecl icd : getInstComponentDecls())
             l.add(icd);
         return l;
     }
     
     /**
      * \brief Returns a list of all FFunctionVariables declared as "input".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myInputs() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : getFFunctionVariables())
             if (var.isInput())
                 l.add(var);
         return l;
     }
     
     /**
      * \brief Returns a list of all FFunctionVariables declared as "input".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myProtected() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : myNonInputs())
             if (!var.isOutput())
                 l.add(var);
         return l;
     }
     
     /**
      * \brief Returns a list of all FFunctionVariables not declared as "input".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myNonInputs() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : getFFunctionVariables())
             if (!var.isInput())
                 l.add(var);
         return l;
     }
     
     /**
      * \brief Returns a list of all FFunctionVariables declared as "output".
      */
     syn lazy ArrayList<FFunctionVariable> FFunctionDecl.myOutputs() {
         ArrayList<FFunctionVariable> l = new ArrayList<FFunctionVariable>();
         for (FFunctionVariable var : getFFunctionVariables())
             if (var.isOutput())
                 l.add(var);
         return l;
     }
     
     syn ArrayList<InstComponentDecl> InstFunctionCall.myInputs() {
         InstClassDecl icd = getName().myInstClassDecl();
         // If class is a record, then function call is record constructor
         return icd.isRecord() ? icd.myModifiableComponents() : icd.myInputs();
     }
     syn ArrayList<InstComponentDecl> InstFunctionCall.myOutputs() = getName().myInstClassDecl().myOutputs();
     syn ArrayList<FFunctionVariable> FFunctionCall.myInputs()     = myFFunctionDecl().myInputs();
     syn ArrayList<FFunctionVariable> FFunctionCall.myOutputs()    = myFFunctionDecl().myOutputs();
     
     syn boolean InstFunctionCall.hasOutputs() = !myOutputs().isEmpty();
     syn boolean FFunctionDecl.hasOutputs()    = !myOutputs().isEmpty();
     syn boolean FFunctionCall.hasOutputs()    = myFFunctionDecl().hasOutputs();
     
     syn InstComponentDecl InstFunctionCall.expOutput() = myOutputs().get(0);
     syn FFunctionVariable FFunctionDecl.expOutput()    = myOutputs().get(0);
     syn FFunctionVariable FFunctionCall.expOutput()    = myFFunctionDecl().expOutput();
    
     syn lazy FunctionReturnDefinition FFunctionDecl.returnDefinition() = new FunctionReturnDefinition(this);
     inh FunctionReturnDefinition FReturnStmt.returnDefinition();
     eq FFunctionDecl.getFAlgorithmBlock().returnDefinition() = returnDefinition();
     eq InstProgramRoot.getChild().returnDefinition()         = null;
     eq FClass.getChild().returnDefinition()                  = null;
     
     inh String InstFunctionArgument.funcName();
     inh String FFunctionCallLeft.funcName();
     eq FAbstractFunctionCall.getChild().funcName() = name();
     eq FFunctionCallEquation.getChild().funcName() = getCall().name();
     eq FFunctionCallStmt.getChild().funcName()     = getCall().name();
     
     /**
      * \brief Check if this function returns an array when used as an expression.
      */
     syn boolean FFunctionDecl.isArray() = hasOutputs() ? expOutput().isArray() : false;
     
     /**
      * \brief Check if this function returns a record when used as an expression.
      */
     syn boolean FFunctionDecl.isRecord() = hasOutputs() ? expOutput().type().isRecord() : false;
     
     /**
      * \brief Check if this function returns a non-primitive when used as an expression.
      */
     syn boolean FFunctionDecl.isComposite() = hasOutputs() ? expOutput().isComposite() : false;
     
     /**
      * \brief Check is this node is in a function.
      */
     inh boolean FQName.inFunction();
     inh boolean InstAssignable.inFunction();
     inh boolean InstExternal.inFunction();
     inh boolean FExp.inFunction();
     inh boolean FIdUse.inFunction();
     inh boolean FStatement.inFunction();
     inh boolean FAbstractEquation.inFunction();
     inh boolean FSubscript.inFunction();
     inh boolean FFunctionCallLeft.inFunction();
     eq InstBaseClassDecl.getChild().inFunction() = isFunction();
     eq FFunctionDecl.getChild().inFunction()     = true;
     eq Root.getChild().inFunction()              = false;
     
     /**
      * \brief Check is this node is in a non-function algorithm.
      */
     inh boolean FSubscript.inAlgorithm();
     eq FAlgorithmBlock.getChild().inAlgorithm()   = !inFunction();
     eq InstNode.getChild().inAlgorithm()          = false;
     eq FAbstractEquation.getChild().inAlgorithm() = false;
     eq FClass.getChild().inAlgorithm()            = false;
     
     /**
      * \brief Check is this node is in an algorithm or a function.
      */
     syn boolean FSubscript.inAlgorithmOrFunction() = inFunction() || inAlgorithm();
     
     /**
      * \brief Check if this function call is the call of a function call equation 
      *        or function call statement.
      */
     inh boolean FAbstractFunctionCall.isFunctionCallClause();
     eq ASTNode.getChild().isFunctionCallClause()              = false;
     eq FFunctionCallEquation.getCall().isFunctionCallClause() = true;
     eq FFunctionCallStmt.getCall().isFunctionCallClause()     = true;
     
     inh boolean FWhenStmt.insideBlockStmt();
     eq FAlgorithmBlock.getChild().insideBlockStmt() = false;
     eq FIfWhenStmt.getChild().insideBlockStmt()     = true;
     eq FWhileStmt.getChild().insideBlockStmt()      = true;
     eq FForStmt.getChild().insideBlockStmt()        = true;
     eq InstForStmt.getChild().insideBlockStmt()     = true;
     
     /**
      * \brief Return the index of the variable assigned by this FFunctionCallLeft among 
      *        all those assigned by the same FFunctionCallEquation/Stmt
      */
     syn lazy int FFunctionCallLeft.myIndex() = prevIndex() + (hasFExp() ? 1 : 0);
     inh int FFunctionCallLeft.prevIndex();
     eq FFunctionCallEquation.getLeft(int i).prevIndex() = (i == 0) ? -1 : getLeft(i - 1).myLastIndex();
     eq FFunctionCallStmt.getLeft(int i).prevIndex()     = (i == 0) ? -1 : getLeft(i - 1).myLastIndex();
     
     syn int FFunctionCallLeft.myLastIndex() = myIndex() + (hasFExp() ? numScalarVars() - 1 : 0);
     
     /**
      * \brief Get the number of scalar variables assigned by this FFunctionCallLeft.
      * 
      * Only valid after scalarization.
      */
     syn int FFunctionCallLeft.numScalarVars() = (hasFExp() ? getFExp().numScalarVars() : 0);
     
     /**
      * \brief Get the number of scalar variables assigned by this a FFunctionCallLeft with this 
      *        FExp as its expression.
      * 
      * Only valid after scalarization.
      */
     syn int FExp.numScalarVars() = 1;
     eq FArray.numScalarVars()    = getNumFExp() * getFExp(0).numScalarVars();
     eq FRecordConstructor.numScalarVars() {
         int n = 0;
         for (FExp e : getArgs())
             n += e.numScalarVars();
         return n;
     }
     
     inh lazy InstComponentDecl FFunctionCallLeft.myOutput();
     eq FFunctionCallEquation.getLeft(int i).myOutput() = getCall().findOutput(i);
     eq FFunctionCallStmt.getLeft(int i).myOutput()     = getCall().findOutput(i);
     syn InstComponentDecl FAbstractFunctionCall.findOutput(int i) = unknownInstComponentDecl();
     eq InstFunctionCall.findOutput(int i)                         = 
         (i >= myOutputs().size()) ? unknownInstComponentDecl() : myOutputs().get(i);
     
     inh boolean FAbstractFunctionCall.functionCallIsExp();
     eq FExp.getChild().functionCallIsExp()                 = true;
     eq FClass.getChild().functionCallIsExp()               = true;
     eq InstNode.getChild().functionCallIsExp()             = true;
     eq FFunctionCallEquation.getCall().functionCallIsExp() = false;
     eq FFunctionCallStmt.getCall().functionCallIsExp()     = false;
     
     inh lazy ArrayList<FFunctionCallLeft> FAbstractFunctionCall.myLefts();
     eq FExp.getChild().myLefts()                 = new ArrayList<FFunctionCallLeft>();
     eq FClass.getChild().myLefts()               = new ArrayList<FFunctionCallLeft>();
     eq InstNode.getChild().myLefts()             = new ArrayList<FFunctionCallLeft>();
     eq FFunctionCallEquation.getCall().myLefts() = getLefts().toArrayList();
     eq FFunctionCallStmt.getCall().myLefts()     = getLefts().toArrayList();

     inh lazy String FExp.tempVarName();
     eq InstNode.getChild().tempVarName()      = null;
     eq FFunctionCall.getArray().tempVarName() = tempVarName();
     eq FClass.getChild().tempVarName() {
         HashMap<String,FVariable> vars = fullyQualifiedVariablesMap();
         String name;
         do {
             name = "temp_" + nextTempVarIndex++;
         } while (vars.get(name) != null);
         return name;
     }
     eq FFunctionDecl.getChild().tempVarName() {
         HashMap<String,FFunctionVariable> vars = fullyQualifiedVariablesMap();
         String name;
         do {
             name = "temp_" + nextTempVarIndex++;
         } while (vars.get(name) != null);
         return name;
     }
     
     private int FFunctionDecl.nextTempVarIndex = 1;
     private int FClass.nextTempVarIndex = 1;
}

aspect Visibility {
    
    syn boolean BaseClassDecl.isPublic() = getVisibilityType().isPublic();
    syn boolean ComponentDecl.isPublic() = getVisibilityType().isPublic();

    syn boolean BaseClassDecl.isProtected() = getVisibilityType().isProtected();
    syn boolean ComponentDecl.isProtected() = getVisibilityType().isProtected();

    syn boolean VisibilityType.isPublic() = false;
    eq PublicVisibilityType.isPublic() = true;

    syn boolean VisibilityType.isProtected() = false;
    eq ProtectedVisibilityType.isProtected() = true;

    syn boolean FVisibilityType.isPublic() = false;
    eq FPublicVisibilityType.isPublic() = true;

    syn boolean FVisibilityType.isProtected() = false;
    eq FProtectedVisibilityType.isProtected() = true;

    syn boolean FVariable.isPublic() = getFVisibilityType().isPublic();
    syn boolean FVariable.isProtected() = getFVisibilityType().isProtected();
    
}

aspect ComponentDeclMethods {
    /**
     * Check if a ComponentDecl is declared flow.
     */
    syn boolean ComponentDecl.isFlow() {
    
        if (hasTypePrefixFlow())
            return true;
    
        return false;
    }

    /**
     * Check if a ComponentDecl is declared parameter.
     */
    syn boolean ComponentDecl.isParameter() {
    
        if (hasTypePrefixVariability())
            if (getTypePrefixVariability() instanceof Parameter)
                return true;
    
        return false;
    }
      
    /**
     * Check if a ComponentDecl is declared inner.
     */
    syn boolean ComponentDecl.isInner() {
        return hasInner();
    }
    
    /**
     * Check if a ComponentDecl is declared outer.
     */
    syn boolean ComponentDecl.isOuter() {
        return hasOuter();
    }
    
    
     /**
     * Check if a ComponentDecl is declared constant.
     */
    syn boolean ComponentDecl.isConstant() {
    
        if (hasTypePrefixVariability())
            if (getTypePrefixVariability() instanceof Constant)
                return true;
    
        return false;
    }
    
    /**
     * Check if a ComponentDecl is declared discrete.
     */
    syn boolean ComponentDecl.isDiscrete() {
    
        if (hasTypePrefixVariability())
            if (getTypePrefixVariability() instanceof Discrete)
                return true;
    
        return false;
    }
    
    syn boolean InstComponentDecl.isInput() {
        
        if (getComponentDecl().hasTypePrefixInputOutput())
            if (getComponentDecl().getTypePrefixInputOutput() instanceof Input)
                return true;
        if (myInstClass().isInput())
            return true;
        
        return false;
    }
    
    
 
    syn boolean InstComponentDecl.isOutput() {
        
        if (getComponentDecl().hasTypePrefixInputOutput())
            if (getComponentDecl().getTypePrefixInputOutput() instanceof Output)
                return true;
        if (myInstClass().isOutput())
            return true;
        
        return false;
    }
    
    syn boolean AbstractEquation.isInitial() {
        if (hasAbstractEquationModifier())
            if (getAbstractEquationModifier() instanceof Initial)
                return true;
        return false;
    
    }

    /**
     * Check if a InstComponentDecl is declared flow.
     */
    syn boolean InstComponentDecl.isFlow() {
    
        if (getComponentDecl().hasTypePrefixFlow())
            return true;
    
        return false;
    }
    
}

aspect ShortClassUtil {

    syn InstClassDecl InstClassDecl.finalClass() = this;
    eq InstShortClassDecl.finalClass() = getInstExtends(0).getClassName().myInstClassDecl().finalClass();


    syn boolean ClassDecl.isInput() = false;
    eq ShortClassDecl.isInput() {
        if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
            if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Input)
                return true;
        return false;
    }
    
    syn boolean ClassDecl.isOutput() = false;
    eq ShortClassDecl.isOutput() {
        if (getExtendsClauseShortClass().hasTypePrefixInputOutput())
            if (getExtendsClauseShortClass().getTypePrefixInputOutput() instanceof Output)
                return true;
        return false;   
    }

    syn boolean InstClassDecl.isInput() = false;
    eq InstShortClassDecl.isInput() {
        if (getClassDecl().isInput()) {
            return true;
        }
        return getInstExtends(0).getClassName().myInstClassDecl().isInput();
    }

    syn boolean InstClassDecl.isOutput() = false;
    eq InstShortClassDecl.isOutput() {
        if (getClassDecl().isOutput()) {
            return true;
        }
        return getInstExtends(0).getClassName().myInstClassDecl().isOutput();
    }
    
}

aspect FlatExpressions {
    
    inh lazy boolean FExp.inEquationSection();
    eq FClass.getFEquationBlock().inEquationSection() = true;
    eq Root.getChild().inEquationSection() = false;
    inh lazy boolean FExp.inInitialEquationSection();
    eq FClass.getFInitialEquation().inInitialEquationSection() = true;
    eq Root.getChild().inInitialEquationSection() = false;

    inh lazy boolean FExp.inEquation();
    eq FAbstractEquation.getChild().inEquation() = true;
    eq Root.getChild().inEquation() = false;
    
    inh boolean FExp.inNoEventExp();
    eq FNoEventExp.getChild().inNoEventExp() = true;
    eq FAlgorithmBlock.getChild().inNoEventExp() = true;
    eq FAbstractEquation.getChild().inNoEventExp() = false;
    eq SourceRoot.getChild().inNoEventExp() = false;
    eq FlatRoot.getChild().inNoEventExp() = false;
    
    inh boolean FExp.inIfCondition();
    eq FIfExp.getChild().inIfCondition() = true;
    eq FElseIfExp.getChild().inIfCondition() = true;
    eq FAbsExp.getChild().inIfCondition() = true;
    eq FAbstractEquation.getChild().inIfCondition() = false;
    eq SourceRoot.getChild().inIfCondition() = false;
    eq FlatRoot.getChild().inIfCondition() = false;
    
}

aspect LineOffsets {
    private Map<Integer, Integer> StoredDefinition.lineBreakMap;
    
    public void StoredDefinition.setLineBreakMap(Map<Integer, Integer> map) {
        lineBreakMap = map;
    }
}

aspect ParserHelpers {

    /**
     * An exception for parser errors.
     */
    public class ParserException extends java.lang.RuntimeException {
        private Problem p;
        
        /**
         * Default constructor.
         */
        public ParserException(Problem p) {
            this.p = p;
        }
        
        /**
         * Getter for problem.
         */
         public Problem getProblem() {
            return p;
         }
        
    }
    
}

aspect NodeSearch {
    
    /**
     * \brief Does node match <code>string</code>? Override for node types that 
     * need to be searched for.
     * 
     * Base implementation always returns <code>false</code.
     * Generally, this is implemented with something like 
     * <code>str.equals(name())</code>.
     * 
     * @param str  the string to match
     * @return     <code>true</code if <code>str</code> matches this node, 
     *             <code>false</code> otherwise
     */
    syn boolean ASTNode.matches(String str) = false;
    
    public class ASTNode {
        
        /**
         * \brief Searches <code>set</code> for a node that returns <code>true</code> for 
         * <code>node.matches(str)</code>.
         * 
         * @param set  the container to search for a matching node
         * @param str  the string to match nodes to
         * @return     a matching node if one is found, <code>null</code> otherwise
         */
        public static <T extends ASTNode> T findMatching(Iterable<T> set, String str) {
            for (T node : set) 
                if (node.matches(str)) 
                    return node;
            return null;
        }
        
    }
    
}
