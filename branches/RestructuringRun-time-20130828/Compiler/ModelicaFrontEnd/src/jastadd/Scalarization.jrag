/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.HashMap;
import java.util.Map;
import java.util.Collections;

aspect Scalarization {

	/**
	 * \brief Flag indicating if a variable is scalarized.
	 */
	boolean FQName.scalarized = false;

	/**
	 * \brief Flag indicating if a flat class is scalarized.
	 */
	boolean FClass.scalarized = false;
	
	syn boolean FVariable.isScalarized() = getFQName().isScalarized();
	syn boolean FQName.isScalarized() = scalarized;
	
	/**
	 * \brief Scalarize all variables and equations in the flat model.
	 */
	public void FClass.scalarize() {
		beginStep("scalarize()");
		List<FVariable> vars = new List<FVariable>();
		List<FVariable> alias_vars = new List<FVariable>();
		scalarizeVars(vars, alias_vars);
		scalarizeAllVarDependent(vars);
		replaceScalarizedVars(vars, alias_vars);
		scalarizeFuncs();
		scalarizeTypes();
		getConnectionSetManager().scalarize();
		scalarized = true;
		scalarizationCleanup();
		endStep("scalarize()");
	}
	
	/**
	 * Scalarize variable declarations.
	 */
	protected void FClass.scalarizeVars(List<FVariable> vars, List<FVariable> alias_vars) {
		for (FVariable fv : getFVariables()) 
			fv.scalarize(vars);
		for (FVariable fv : getAliasVariables()) 
			fv.scalarize(alias_vars);
	}
	
	protected void FClass.scalarizeAllVarDependent(List<FVariable> vars) {
		scalarizeEquations(vars);
		scalarizeResidualPairs();
	}
	
	protected void FClass.scalarizeResidualPairs() {
		List<FResidualPair> newPairs = new List<FResidualPair>();
		for (FResidualPair pair : getFResidualPairs()) {
			pair.scalarize(newPairs);
		}
		setFResidualPairList(newPairs);
	}
	
	protected void FResidualPair.scalarize(List<FResidualPair> pairs) {
		if (!getResidualEquation().size().equals(getIterationVariable().size())) {
			throw new UnsupportedOperationException("Residual equation and iteration variable have different sizes.");
		}
		if (getResidualEquation().ndims() > 0) {
			Iterator<Index> resIt = getResidualEquation().indices().iterator();
			Iterator<Index> iterIt = getIterationVariable().indices().iterator();
			while (resIt.hasNext() && iterIt.hasNext()) {
				pairs.addChild(new FResidualPair(getResidualEquation().specify(resIt.next(), true), getIterationVariable().specify(iterIt.next(), true), getLevel()));
			}
			if (resIt.hasNext() || iterIt.hasNext())
				throw new UnsupportedOperationException("Residual equation and iteration variable have different sizes.");
		} else {
			Map<String,FExp> emptyMap = Collections.emptyMap();
			pairs.addChild(new FResidualPair(getResidualEquation().scalarize(emptyMap), getIterationVariable().scalarize(emptyMap), getLevel()));
		}
	}
	
	protected void FClass.scalarizeEquations(List<FVariable> vars) {
		FEquationBlock eb = getFEquationBlock(0);
		eb.setFAbstractEquationList(scalarizeEquationList(eb.getFAbstractEquations(), vars));
		setFInitialEquationList(scalarizeEquationList(getFInitialEquations(), vars));
		setFParameterEquationList(scalarizeEquationList(getFParameterEquations(), vars));
	}
	
	protected void FClass.replaceScalarizedVars(List<FVariable> vars, List<FVariable> alias_vars) {
		Map<String,FExp> im = Collections.emptyMap();
		getFVariables().createArrayTemporaries(getFParameterEquations(), vars, im, true);
		getAliasVariables().createArrayTemporaries(getFParameterEquations(), vars, im, true);
		setFVariableList(vars);
		setAliasVariableList(alias_vars);
	}
	
	protected void FClass.scalarizeFuncs() {
		List<FFunctionDecl> funcs = new List<FFunctionDecl>();
		for (FFunctionDecl f : getFFunctionDecls()) 
			funcs.add(f.scalarize());
		setFFunctionDeclList(funcs);
		funcs.clearScalarized();  // Functions need scalarized = false in FQNames
	}
	
	/**
	 * Scalarize type declarations by removing array-valued attributes. 
	 * They have been copied to the variables when the variables were scalarized. 
	 */
	protected void FClass.scalarizeTypes() {
		for (FDerivedType t : getFDerivedTypes())
			t.removeArrayValuedAttributes();
	}
	
	/**
	 * Removing all array-valued attributes. 
	 */
	public void FDerivedType.removeArrayValuedAttributes() {
		List<FAttribute> list = new List<FAttribute>();
		for (FAttribute a : getFAttributes())
			if (!a.removeArrayValuedAttributes())
				list.add(a);
		setFAttributeList(list);
	}
	
	/**
	 * Removing all array-valued attributes.
	 * 
	 * @return  true if the attribute should be removed
	 */
	public boolean FAttribute.removeArrayValuedAttributes() {
		boolean keep = false;
		List<FAttribute> list = null;
		if (getNumFAttribute() > 0) {
			list = new List<FAttribute>();
			for (FAttribute a : getFAttributes())
				if (!a.removeArrayValuedAttributes())
					list.add(a);
			keep = list.getNumChild() > 0;
		}
		if (hasValue()) {
			if (getValue().isArray()) {
				if (keep)
					setValueOpt(new Opt());
			} else {
				keep = true;
			}
		}
		if (keep && list != null)
			setFAttributeList(list);
		return !keep;
	}
	
	protected void FClass.evaluateArraySubscripts() {
		clearFlatNameBinding();
		getFEquationBlock(0).makeSubscriptsLiteral();
		getFInitialEquations().makeSubscriptsLiteral();
		getFParameterEquations().makeSubscriptsLiteral();
	}
	
	protected void FClass.scalarizationCleanup() {
		flush();  // Must flush before traversing
		evaluateArraySubscripts();
		enableStreamsRewrite();
		setDummyVariableList(new List<FVariable>());
	}
	
	protected static List<FAbstractEquation> FClass.scalarizeEquationList(
			List<FAbstractEquation> old, List<FVariable> vars) {
		return FAbstractEquation.scalarizeList(old, vars, Collections.<String,FExp>emptyMap());
	}
	
	public static List<FAbstractEquation> FAbstractEquation.scalarizeList(
			List<FAbstractEquation> old, List<FVariable> vars, Map<String,FExp> indexMap) {
		List<FAbstractEquation> eqns = new List<FAbstractEquation>();
		scalarizeList(old, eqns, vars, indexMap);
		return eqns;
	}
	
	public static void FAbstractEquation.scalarizeList(
			List<FAbstractEquation> fromList, List<FAbstractEquation> toList, 
			List<FVariable> vars, Map<String,FExp> indexMap) {
		for (FAbstractEquation ae : fromList) 
			ae.scalarize(toList, vars, indexMap);
	}
	
	/**
	 * \brief Replace all expressions in array subscripts with literals.
	 * 
	 * This method enables a rewrite that will be performed after the next flush.
	 */
	public void ASTNode.makeSubscriptsLiteral() {
		for (ASTNode child : this)
			child.makeSubscriptsLiteral();
	}
	
	public void FExpSubscript.makeSubscriptsLiteral() {
		rewriteToLiteral = true;
		is$Final = false;
	}
	
	private boolean FExpSubscript.rewriteToLiteral = false;
	
	rewrite FExpSubscript {
		when (rewriteToLiteral) to FExpSubscript {
			setFExp(getFExp().ceval().buildLiteral());
			rewriteToLiteral = false;
			return this;
		}
	}
	
	
	/**
	 * \brief Scalarize the FVariable and put all scalarized variables in the
	 * list vars.
	 */
	public void FVariable.scalarize(List<FVariable> vars) {
		// Constants and parameters still have binding expressions, 
		// they should be scalarized but can't contain any FForIndex 
		// (except in reduction-expressions, and they are handled elsewhere)
		if (isRecord()) {
			FExp bexp = hasBindingExp() ? getBindingExp() : null;
			scalarRecordFVariables(vars, new FQNameEmpty(), null, bexp, Index.NULL, false, Collections.<BindingExpSource>emptyList());
		} else if (isArray()) {
			for (Index i : indices()) 
				vars.addChild(createScalarFVariable(i));
		} else {
			vars.addChild(createScalarFVariable(Index.NULL));
		}
	}
	
	/**
	 * \brief Create a scalar FVariable for a single cell or an already scalar FVariable.
	 * 
	 * @param i  the Index of the cell to create an FVariable for. Should be Index.NULL for 
	 *           already scalar FVariables.
	 */
	protected FVariable FVariable.createScalarFVariable(Index i) {
		// Create new variable and copy fields that should be same
		FVariable fv = createEmptyNode();
		fv.setFVisibilityType((FVisibilityType) getFVisibilityType().fullCopy());
		fv.setFTypePrefixVariability(getFTypePrefixVariability().fullCopy());
		if (hasFTypePrefixInputOutput())
			fv.setFTypePrefixInputOutput((FTypePrefixInputOutput) getFTypePrefixInputOutput().fullCopy());
		if (hasFStringComment())
			fv.setFStringComment(getFStringComment().fullCopy());
		
		// Constants and parameters still have binding expressions
		if (hasBindingExp()) {
			Map<String,FExp> im = Collections.emptyMap();
			fv.setBindingExp(getBindingExp().getArray().get(i).scalarize(im));
		}
		
		// Iterate over all attributes and scalarize.
		for (FAttribute a : getFAttributes()) 
			fv.addFAttribute(a.scalarize(i));
		fv.setDerivedType(getDerivedType());
		fv.addArrayAttributesFromType(i, myFDerivedType());
		
		// Copy name and replace last array subscripts
		FQName name = (i == Index.NULL) ? 
				getFQName().fullCopy() : 
				getFQName().copyAndAddFas(i.createFArraySubscripts());
		name.scalarized = true;
		fv.setFQName(name);

		fv.setHGTType(getHGTType());
		
		return fv;
	}
	
	protected FVariable FExternalObjectVariable.createScalarFVariable(Index i) {
		Map<String, FExp> EMPTY = Collections.<String, FExp>emptyMap();
		FExternalObjectVariable fex = (FExternalObjectVariable) super.createScalarFVariable(i);
		FFunctionCall call = (FFunctionCall) getDestructorCall().getCall();
		FFunctionCall scalarCall = (FFunctionCall) call.scalarize(EMPTY);
		if (i != Index.NULL)
			scalarCall.setArg(call.getArg(0).getArray().get(i).scalarize(EMPTY), 0);
		if (hasConstructorCall(i))
		    fex.setDestructorCall(new FFunctionCallStmt(new List(), scalarCall));
		return fex;
	}
	
	protected FEnumVariable FEnumVariable.createScalarFVariable(Index i) {
		FEnumVariable fv = (FEnumVariable) super.createScalarFVariable(i);
		fv.setEnum(getEnum().fullCopy());
		return fv;
	}
	
	/**
	 * Copy any attributes with array values from type, selecting the scalar value corresponding 
	 * to the given index. 
	 */
	protected void FVariable.addArrayAttributesFromType(Index i, FDerivedType t) {
		if (t != null && i != Index.NULL)
			for (FAttribute a : t.getFAttributes())
				a.addArrayAttributesTo(i, getFAttributes());
	}
	
	/**
	 * Copy any attributes with array values to the given list, selecting the scalar value corresponding 
	 * to the given index. 
	 * 
	 * @return  true if any attribute was added to the list 
	 */
	protected boolean FAttribute.addArrayAttributesTo(Index i, List<FAttribute> list) {
		FAttribute match = findMatching(list, getName().name());
		if (match != null) {
			list = match.getFAttributes();
			for (FAttribute a : getFAttributes())
				a.addArrayAttributesTo(i, list);
			return false;
		}
		
		boolean isArray = hasValue() && getValue().isArray();
		boolean add = isArray;
		List<FAttribute> subList = null;
		if (add || getNumFAttribute() > 0) {
			subList = new List<FAttribute>();
			for (FAttribute a : getFAttributes())
				add = a.addArrayAttributesTo(i, subList) || add;
		}
		if (add) {
			FAttribute res = new FAttribute(getType().fullCopy(), getName().fullCopy(), new Opt(), 
					getAttributeSet(), getLevel(), getFEachOpt().fullCopy(), getFFinalOpt().fullCopy(), subList);
			if (hasValue()) {
				FExp val = getValue();
				if (isArray) {
					if (val.ndims() < i.ndims())
						i = i.subIndex(i.ndims() - val.ndims());
					val = val.getArray().get(i);
				}
				res.setValue(val.scalarize(Collections.<String,FExp>emptyMap()));
			}
			list.add(res);
		}
		return add;
	}
	
	/**
	 * \brief Generate scalar FVariables for this record or record component.
	 * 
	 * @param vars     the list of FVariables to add the variables to
	 * @param prefix   add this as a prefix to the name
	 * @param last     an FVariable containing the attributes, variability, 
	 *                 etc inherited from the surrounding record
	 * @param bexp     binding expression inherited from surrounding record
	 * @param bi       index of part of binding expression to use
	 * @param inParam  this variable is within a constant or parameter record
	 * @param attrs    attributes to search for modifications, before searching in this variable
	 */
	public void FVariable.scalarRecordFVariables(
			List<FVariable> vars, FQName prefix, FVariable last, FExp bexp, Index bi, 
			boolean inParam, java.util.List<BindingExpSource> attrs) {
		inParam = (inParam || isConstant() || isParameter()) && !isDependentParameter();
		if (bexp == null && hasBindingExp() && inParam && getBindingExp().isConstantExp()) {
			bexp = getBindingExp();
			bi = Index.NULL;
		}
		if (isArray()) {
			FExp nbexp = null;
			for (Index i : scalarizationIndices(last)) {
				if (bexp != null) {
					Index nbi = bi.expand(i);
					nbi = nbi.subIndex(nbi.ndims() - bexp.ndims());
					nbexp = bexp.getArray().get(nbi);
				}
				FQName name = prefix.copyAndAppend(getFQName(), i.createFArraySubscripts());
				scalarRecordCellFVariables(vars, name, last, nbexp, i, inParam, attrs);
			}
		} else {
			FQName name = prefix.copyAndAppend(getFQName());
			if (bexp != null && bexp.isArray())
				bexp = bexp.getArray().get(bi);
			scalarRecordCellFVariables(vars, name, last, bexp, Index.NULL, inParam, attrs);
		}
	}
	
	/**
	 * \brief Generate scalar FVariables for a single array cell of this record or record component.
	 * 
	 * @param vars     the list of FVariables to add the variables to
	 * @param name     the name of the new variable
	 * @param last     an FVariable containing the attributes, variability, etc inherited from surrounding record
	 * @param bexp     binding expression inherited from surrounding record or array
	 * @param i        the index of this scalar variable in an array, or Index.NULL for scalar components
	 * @param inParam  this variable is within a constant or parameter record
	 * @param attrs    attributes to search for modifications, before searching in this variable
	 */
	public void FVariable.scalarRecordCellFVariables(
			List<FVariable> vars, FQName name, FVariable last, FExp bexp, Index i, 
			boolean inParam, java.util.List<BindingExpSource> attrs) {
		FVariable fv = copyForName(name);
		Map<String,FExp> im = Collections.emptyMap();
		if (bexp != null)
			fv.setBindingExp(bexp.scalarizeExp(im));
		else
			fv.setBindingExpOpt(new Opt());
		fv.inheritFrom(last);
		fv.addArrayAttributesFromType(i, myFDerivedType());
		vars.add(fv);
	}
	
	public void FRecordVariable.scalarRecordCellFVariables(
			List<FVariable> vars, FQName name, FVariable last, FExp bexp, Index i, 
			boolean inParam, java.util.List<BindingExpSource> attrs) {
		FVariable tmp = (FVariable) fullCopy();
		myFClass().addDummyVariable(tmp);
		tmp.inheritFrom(last);
		Map<String, FExp> emptyIndexMap = Collections.emptyMap();
		for (FVariable comp : myFRecordDecl().getFVariables()) {
			java.util.List<BindingExpSource> nAttrs = Collections.emptyList();
			FExp nbexp = null;
			Index nbi = Index.NULL;
			if (bexp != null) {
				nbexp = bexp.scalarRecordFExp(emptyIndexMap, new FQNameString(comp.name()));
			} else {
				ArrayList<BindingExpSource> foundAttr = new ArrayList<BindingExpSource>();
				String cName = comp.name();
				for (BindingExpSource bes : attrs)
					bes.addIfMatching(foundAttr, cName, i);
				BindingExpSource.addIfMatching(foundAttr, this, cName, i);
				for (int j = 0; nbexp == null && j < foundAttr.size(); j++) {
					nbexp = foundAttr.get(j).getFExp();
					if (nbexp != null)
						nbi = foundAttr.get(j).getI();
				}
				if (nbexp == null)
					nAttrs = foundAttr;
			}
			comp.scalarRecordFVariables(vars, name, tmp, nbexp, nbi, inParam, nAttrs);
		}
	}
	
	/**
	 * Used to hold information on available candidates for binding expression when scalarizing 
	 * records.
	 */
	public class BindingExpSource {
		
		private FAttribute attr;
		private Index index;
		
		private BindingExpSource(FAttribute a, Index i) {
			attr = a;
			index = i;
		}
		
		private static void addIfExists(
				java.util.List<BindingExpSource> attrs, FAttribute a, Index i) {
			if (a != null)
				attrs.add(new BindingExpSource(a, i));
		}
		
		public static void addIfMatching(
				java.util.List<BindingExpSource> attrs, FVariable fv, String name, Index i) {
			addIfExists(attrs, fv.findAttribute(name), i);
		}
		
		public void addIfMatching(
				java.util.List<BindingExpSource> attrs, String name, Index i) {
			addIfExists(attrs, attr.findAttribute(name), index.expand(i));
		}
		
		public FExp getFExp() {
			return attr.hasValue() ? attr.getValue() : null;
		}
		
		public Index getI() {
			return index;
		}
		
	}
	
	/**
	 * \brief The Indices object to use when scalarizing records.
	 * 
	 * Either returns indices() or calculates from "size()" attribute.
	 * 
	 * @param outer  the enclosing FVariable, used to get "size()" attribute 
	 */
	syn Indices FVariable.scalarizationIndices(FVariable outer) {
		if (outer != null && outer.attributeSet(name())) {
			FAttribute attr = outer.findAttribute(name()).findAttribute(FAttribute.SIZE);
			if (attr != null && attr.hasValue())
				return Indices.create(new MutableSize(attr.getValue()));
		}
		return indices();
	}
	
	/**
	 * \brief Inherit prefixes and attributes from the FVariable representing the surrounding record.
	 */
	public void FVariable.inheritFrom(FVariable other) {
		if (other == null)
			return;

		// Prefixes
		setFVisibilityType(other.getFVisibilityType());
		setFTypePrefixVariability(getFTypePrefixVariability().combineDown(other.getFTypePrefixVariability()));
		if (other.hasFTypePrefixInputOutput())
			setFTypePrefixInputOutput(other.getFTypePrefixInputOutput());

		// Attributes
		FQName name = getFQName();
		String myName = name.lastActualPartName();
		Index myCell = null;
		if (name.hasFArraySubscripts()) 
			myCell = name.getFArraySubscripts().asIndex();
		for (FAttribute a : other.getFAttributes()) {
			// TODO: support attributes on single cell in array (#599)
			// TODO: don't these need scalarizing as well?
			String attrName = a.getName().getFQName().partName(0);
			if (myName.equals(attrName)) {
				FAttribute na = a.copyForCell(myCell);
				if (a.getName().getFQName().numParts() > 1) {
					na.getName().setFQName(a.getName().getFQName().copySuffix());
					addFAttribute(na);
				} else {
					for (FAttribute ia : na.getFAttributes()) 
						if (!ia.isInternal())
							addFAttribute(ia);
				}
			}
		}
	}
	
	/**
	 * Create a copy of the variable with a specific name.
	 * 
	 * The new variable is marked as scalarized, and if it refers to a specific cell in an array, 
	 * then attributes are updated accordingly.
	 */
	public FVariable FVariable.copyForName(FQName name) {
		FVariable fv = createEmptyNode();
		fv.setFQName(name.fullCopy());
		fv.getFQName().scalarized = true;
		fv.setFVisibilityType(getFVisibilityType().fullCopy());
		fv.setFTypePrefixVariability(getFTypePrefixVariability().fullCopy());
		if (hasFTypePrefixInputOutput())
			fv.setFTypePrefixInputOutput(getFTypePrefixInputOutput().fullCopy());
		fv.setDerivedType(getDerivedType());
		if (hasBindingExp())
			fv.setBindingExp(getBindingExp().fullCopy());
		if (hasFStringComment())
			fv.setFStringComment(getFStringComment().fullCopy());
		
		Index myCell = null;
		if (name.hasFArraySubscripts()) 
			myCell = name.getFArraySubscripts().asIndex();
		for (FAttribute a : getFAttributes())
			if (!a.isInternal())
				fv.addFAttribute(a.copyForCell(myCell));
		return fv;
	}

	public FEnumVariable FEnumVariable.copyForName(FQName name) {
		FEnumVariable fv = (FEnumVariable) super.copyForName(name);
		fv.setEnum(getEnum().fullCopy());
		return fv;
	}

	/**
	 * Create a copy of the attibute with dimensions removed from all array expressions according 
	 * to an index.
	 */
	public FAttribute FAttribute.copyForCell(Index i) {
		if (i == null)
			return fullCopy();
		FAttribute res = createEmptyNode();
		res.setType(getType().fullCopy());
		res.setName(getName().fullCopy());
		if (hasValue()) {
			FExp val = getValue();
			if (val.ndims() < i.ndims() || isInternal())
				val = val.scalarize(Collections.<String,FExp>emptyMap());
			else
				val = val.dynamicFExp(val.splitArrayExp(i).unboundCopy()).scalarize(Collections.<String,FExp>emptyMap());
			res.setValue(val);
		}
		res.setAttributeSet(getAttributeSet());
		if (hasFEach())
			res.setFEach(getFEach().fullCopy());
		if (hasFFinal())
			res.setFFinal(getFFinal().fullCopy());
		for (FAttribute a : getFAttributes())
			res.addFAttribute(a.copyForCell(i));
		return res;
	}
	
	/**
	 * \brief Check if this is an internal generated attribute.
	 */
	syn boolean FAttribute.isInternal() = false;
	eq FInternalAttribute.isInternal()  = true;
	
	/**
	 * \brief Scalarize the attribute, picking out the specific element from an array 
	 *        expression or removing "each".
	 */
	public FAttribute FAttribute.scalarize(Index i) {
		List<FAttribute> la = new List<FAttribute>();
		for (FAttribute a : getFAttributes())  // TODO: can they be nestled at this point?
			la.add(a.scalarize(i));            // TODO: really send i here?
		FAttribute res = new FAttribute(getType().fullCopy(), getName().fullCopy(), 
				new Opt(), getAttributeSet(), getLevel(), new Opt(), getFFinalOpt().fullCopy(), la);
		if (hasValue()) 
			res.setValue(scalarizeValue(i));
		return res;
	}
	
	/**
	 * Scalarize the value of this attribute, picking out the specific element from an array 
	 * expression.
	 * 
	 * Returns null if attribute has no value.
	 */
	public FExp FAttribute.scalarizeValue(Index i) {
		if (!hasValue()) 
			return null;
		FExp v = getValue();
		if (v.isArray()) {
			i = i.subIndex(i.ndims() - v.ndims());
			v = v.getArray().get(i);
		}
		return v.scalarize(Collections.<String,FExp>emptyMap());
	}
	
	/**
	 * \brief Scalarize the function variable.
	 * 
	 * Any binding expression is added to statement list as an assignment.
	 */
	public void FFunctionVariable.scalarize(
			List<FFunctionVariable> vars, List<FStatement> stmts, Map<String,FExp> indexMap) {
		FFunctionVariable var = (FFunctionVariable) fullCopy();
		var.getType().updateFUnknownSizeExps(var);
		var.setBindingExpOpt(new Opt());
		vars.add(var);
	}
	
	/**
	 * \brief A node that can look up variable names in the flat tree.
	 */
	public interface FlatLookupNode {
		public FAbstractVariable lookupFV(FQName fqn);
	}
	FFunctionVariable implements FlatLookupNode;
	FExp implements FlatLookupNode;
	
	/**
	 * \brief Creates and organizes names of for indices for generated for loops.
	 */
	public class ForNames implements Iterable<String> {
		private ArrayList<String[]> names;
		private int last;
		private int pos;
		
		/**
		 * \brief Standard constructor.
		 */
		public ForNames() {
			names = new ArrayList<String[]>();
			last = 0;
		}
		
		/**
		 * \brief Creates a new ForNames with a single layer with space for <code>n</code> names.
		 */
		public ForNames(int n) {
			this();
			addLayer(n);
		}
		
		/**
		 * \brief Add a new layer of names, that can be filled with new names or names 
		 *        from the layer underneath.
		 * 
		 * @param n  the number of names in the new layer
		 */
		public void addLayer(int n) {
			names.add(new String[n]);
			pos = 0;
		}
		
		/**
		 * \brief Fills all empty spots in the top layer with newly created names.
		 */
		public void fillLayer(FlatLookupNode context) {
			String[] top = topLayer();
			for (int i = pos; i < top.length; i++) 
				create(context);
		}
		
		/**
		 * \brief Removes the top layer, exposing the layer underneath.
		 */
		public void removeLayer() {
			names.remove(names.size() - 1);
		}

		private String[] topLayer() {
			return names.get(names.size() - 1);
		}
		
		/**
		 * \brief Gets name with index <code>i</code> in the top layer.
		 */
		public String get(int i) {
			return topLayer()[i];
		}
		
		/**
		 * \brief Adds a name to the top layer.
		 */
		public void add(String name) {
			topLayer()[pos++] = name;
		}
		
		/**
		 * \brief Creates a new name and adds it to the top layer.
		 * 
		 * @return the created name
		 */
		public String create(FlatLookupNode context) {
			String name;
			do {
				name = "i" + (++last);
			} while (!context.lookupFV(new FQNameString(name)).isUnknown()); 
			add(name);
			return name;
		}
		
		/**
		 * \brief Adds a name from the underlying layer to the top layer.
		 * 
		 * @param i  the index in the underlying layer
		 */
		public void promote(int i) {
			add(names.get(names.size() - 2)[i]);
		}
		
		/**
		 * Checks if there are enough layers to promote a name.
		 */
		public boolean canPromote() {
			return names.size() > 1;
		}
		
		/**
		 * \brief Return the number of names in the top layer.
		 */
		public int size() {
			return topLayer().length;
		}
		
		/**
		 * \brief Iterates over the top layer.
		 */
		public Iterator<String> iterator() {
			return Arrays.asList(topLayer()).iterator();
		}
		
		/**
		 * Creates nestled for loops using the top layer of names.
		 *  
		 * Adds the outermost for loop to a list of statements.
		 * 
		 * @param stmts  list to add the created for statements to
		 * @param sizes  array of expressions describing the size of each dimension
		 * @return  the list of statements of the innermost loop
		 */
		public List<FStatement> createForLoops(List<FStatement> stmts, FExp[] sizes) {
			List<FStatement> cur = stmts;
			for (int i = 0; i < topLayer().length; i++) {
				FForIndex ffi = new FForIndex(topLayer()[i], sizes[i]);
				FForStmt fs = new FForStmt(ffi, new List());
				cur.add(fs);
				cur = fs.getForStmts();
			}
			return cur;
		}
		
		/**
		 * \brief Creates nestled for loops over a single variable, using the top layer of names.
		 *  
		 * Adds the outermost for loop to a list of statements.
		 * 
		 * @param stmts  list to add the created for statements to
		 * @param var    name of the variable to loop over
		 * @return  the list of statements of the innermost loop
		 */
		public List<FStatement> createForLoops(List<FStatement> stmts, FQName var) {
			int n = topLayer().length;
			FExp[] sizes = new FExp[n];
			for (int i = 0; i < n; i++)
				sizes[i] = new FSizeExp(var, i);
			return createForLoops(stmts, sizes);
		}
		
		/**
		 * \brief Creates nestled for loops over an expression, using the top layer of names.
		 *  
		 * Adds the outermost for loop to a list of statements.
		 * 
		 * @param stmts  list to add the created for statements to
		 * @param exp    expression to loop over
		 * @return  the list of statements of the innermost loop
		 */
		public List<FStatement> createForLoops(List<FStatement> stmts, FExp exp) {
			int n = topLayer().length;
			FExp[] sizes = new FExp[n];
			for (int i = 0; i < n; i++)
				sizes[i] = exp.size().createFExp(i);
			return createForLoops(stmts, sizes);
		}
		
		/**
		 * \brief Creates a new FArraySubscripts with uses of the names in the top layer as subscripts.
		 */
		public FArraySubscripts createFArraySubscripts() {
			FArraySubscripts fas = new FArraySubscripts();
			for (String name : this)
				fas.addFSubscript(new FExpSubscript(new FIdUseExp(name)));
			return fas;
		}
		
	}

	/**
	 * \brief Scalarize an assignment to an array of unknown size and put the resulting statements in 
	 *        the list of statements.
	 */
	public void FAbstractVariable.scalarizeUnknownArrayAssignment(List<? extends FAbstractVariable> vars, 
			List<FStatement> stmts, Map<String,FExp> indexMap, FExp exp) {}

	public void FFunctionArray.scalarizeUnknownArrayAssignment(List<? extends FAbstractVariable> vars, 
			List<FStatement> stmts, Map<String,FExp> indexMap, FExp exp) {
		ForNames names = new ForNames(ndims());
		names.fillLayer(this);
		Map<String,FExp> myIndexMap = new HashMap<String,FExp>(indexMap);
		exp.addArrayUsesToIndexMap(myIndexMap, names);
		List<FStatement> inner = names.createForLoops(stmts, getFQName());
		exp.createArrayTemporaries(inner, vars, myIndexMap, true);
		FIdUse use = createUseWithNamedSubscripts(names);
		inner.add(new FAssignStmt(use, exp.scalarize(myIndexMap)));
	}
	
	/**
	 * \brief The names of the for indices of the surrounding generated for loops, if any.
	 */
	protected ForNames FExp.indexNames = null;
	
	/**
	 * Add translations of all uses of array variables to the index map. 
	 * The translations should add array subscripts that are uses of the given names.
	 * 
  	 * Any expression node that needs it's own for loop(s) should override this method, 
  	 * save <code>names</code> and create it's for loop in createArrayTemporaries(). 
  	 * In this case, don't continue traversal here, do that in createArrayTemporaries()
  	 * instead (when we have updated names).
	 */
	public void ASTNode.addArrayUsesToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		for (ASTNode n : this)
			n.addArrayUsesToIndexMap(indexMap, names);
	}
	
	/**
	 * Add translations of all uses of array variables to the index map. 
	 * The translations should add array subscripts that are uses of the given names.
	 * 
	 * Any expression node that needs it's own for loop(s) should override scalarizesToLoop()
     * to return true in those cases. That causes this method to save <code>names</code> and 
     * stop traversal here. The node should also override createArrayTemporaries(), update 
     * <code>names</code>, call this function on its children and create it's for loop there. 
	 */
	public void FExp.addArrayUsesToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		if (scalarizesToLoop())
			indexNames = names;
		else
			super.addArrayUsesToIndexMap(indexMap, names);
	}
	
	/**
	 * Should addArrayUsesToIndexMap() stop recursion and save <code>names</code> at this point?
	 * 
	 * @see ASTNode#addArrayUsesToIndexMap(Map<String,FExp>,ForNames)
	 */
	syn boolean FExp.scalarizesToLoop() = false;
	eq FMulExp.scalarizesToLoop()       = isArray() && !isElementWise();
	eq FRangeExp.scalarizesToLoop()     = true;
	eq FReductionExp.scalarizesToLoop() = getFExp().size().isUnknown() && inFunction();
	
	public void FIdUseExp.addArrayUsesToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		if (isArray()) {
			FIdUse use = myFV().createUseWithNamedSubscripts(names);
			indexMap.put(name(), new FIdUseExp(use));
		}
	}
		
	public void FFunctionCall.addArrayUsesToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		if (isComposite() && functionCallIsExp())
			useTempVarAndAddUseToIndexMap(indexMap, names);
		else
			super.addArrayUsesToIndexMap(indexMap, names);
	}
	
	public void FArray.addArrayUsesToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		useTempVarAndAddUseToIndexMap(indexMap, names);
	}
	
	public void FExp.useTempVarAndAddUseToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		useTempVar = true;
		indexMap.put(tempVarName(), new FIdUseExp(tempVarName(), names.createFArraySubscripts()));
	}
	
	public void FIterExp.addArrayUsesToIndexMap(Map<String,FExp> indexMap, ForNames names) {
		int n = getNumForIndex();
		for (int i = 0; i < n; i++)
			indexMap.put(getForIndex(i).name(), new FIdUseExp(names.get(i)));
		super.addArrayUsesToIndexMap(indexMap, names);
	}
	
	public void FIterExp.createArrayTemporaries(List clauses, List vars, 
			Map<String,FExp> indexMap, boolean addVar) {
		if (inFunction()) {
			super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		} else {
			Indices indices = Indices.create(getForIndexs());
			Map<String,FExp> myIndexMap = new HashMap<String,FExp>();
			myIndexMap.putAll(indexMap);
			for (Index i : indices) {
				indices.fillIndexMap(myIndexMap, i, getForIndexs());
				getFExp().createArrayTemporaries(clauses, vars, myIndexMap, addVar);
				getFExp().flushAllRecursive(); // Throw calculated sizes/arrays
				addVar = false;                // Only add variable in the first iteration
			}
			for (CommonForIndex fi : getForIndexs()) 
				fi.setEvaluationValue(null);
		}
	}
	
	public void FArray.createArrayTemporaries(List clauses, List vars, 
			Map<String,FExp> indexMap, boolean addVar) {
		if (useTempVar) 
			defaultFunctionArrayTemporaries(clauses, vars, indexMap, addVar);
		else
			super.createArrayTemporaries(clauses, vars, indexMap, addVar);
	}
	
	public void FExp.defaultFunctionArrayTemporaries(List clauses, List vars, 
			Map<String,FExp> indexMap, boolean addVar) {
		if (addVar) 
			vars.add(new FFunctionArray((FType) type().unboundCopy(), tempVarName()));
		Array arr = getArray();
		for (Index i : indices()) {
			FQName name = new FQNameFull(tempVarName(), i.createFArraySubscripts());
			name.scalarized = true;
			clauses.add(new FAssignStmt(new FIdUse(name), arr.get(i).scalarize(indexMap)));
		}
	}
	
	public void FReductionExp.createArrayTemporaries(List clauses, List vars, 
			Map<String,FExp> indexMap, boolean addVar) {
		if (scalarizesToLoop()) {
			if (indexNames == null)
				indexNames = new ForNames();
			useTempVar = true;
			
			// Create temp
			FType type = (FType) type().scalarType().unboundCopy();
			if (addVar) 
				vars.add(new FFunctionVariable(type, tempVarName()));
			clauses.add(new FAssignStmt(new FIdUse(tempVarName()), reduceStartValue().buildLiteral()));
			
			// Set up names and create for loop(s)
			FExp exp = getFExp();
			indexNames.addLayer(exp.ndims());
			indexNames.fillLayer(this);
			// TODO: handle sum returning array, e.g. "sum( { i, i*i } for i in 1:3 )"
			List<FStatement> fsl = indexNames.createForLoops(clauses, exp);
			
			// Scalarize exp
			Map<String,FExp> myIndexMap = new HashMap<String,FExp>(indexMap);
			exp.addArrayUsesToIndexMap(myIndexMap, indexNames);
			exp.createArrayTemporaries(fsl, vars, myIndexMap, addVar);
			FExp scalar = exp.scalarize(myIndexMap);
			indexNames.removeLayer();
			
			// Add statement updating temp var to loop
			FBinExp scalarizedExp = scalarReduceExp();
			scalarizedExp.setLeft(new FIdUseExp(tempVarName()));
			scalarizedExp.setRight(scalar);
			fsl.add(new FAssignStmt(new FIdUse(tempVarName()), scalarizedExp));
		} else {
			super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		}
	}
	
	public void FMulExp.createArrayTemporaries(List clauses, List vars, 
			Map<String,FExp> indexMap, boolean addVar) {
		if (!isElementWise() && (getLeft().size().isUnknown() || getRight().size().isUnknown())) {
			if (indexNames == null)
				indexNames = new ForNames();
			useTempVar = true;
			
			// Create temp
			FType type = (FType) type().scalarType().unboundCopy();
			if (addVar) 
				vars.add(new FFunctionVariable(type, tempVarName()));
			clauses.add(new FAssignStmt(new FIdUse(tempVarName()), type.zeroLiteral()));
			
			// Set up indices for the left operand
			FExp exp = getLeft();
			indexNames.addLayer(exp.ndims());
			if (indexNames.size() > 1)
				indexNames.promote(0);
			String i = indexNames.create(this);
			Map<String,FExp> myIndexMap = new HashMap<String,FExp>(indexMap);
			exp.addArrayUsesToIndexMap(myIndexMap, indexNames);
			
			// Create loop
			Size rSize = getRight().size();
			FExp sizeExp = rSize.hasValue(0) ? rSize.createFExp(0) : 
				new FSizeExp(getRight().fullCopy(), 0);
			FForStmt fs = new FForStmt(new FForIndex(i, sizeExp), new List());
			clauses.add(fs);
			List<FStatement> fsl = fs.getForStmts();
			
			// Scalarize left operand
			exp.createArrayTemporaries(fsl, vars, myIndexMap, addVar);
			FExp left = exp.scalarize(myIndexMap);
			indexNames.removeLayer();
			
			// Set up indices and scalarize the right operand
			exp = getRight();
			indexNames.addLayer(exp.ndims());
			indexNames.add(i);
			if (indexNames.size() > 1)
				indexNames.promote(ndims() - 1);
			myIndexMap = new HashMap<String,FExp>(indexMap);
			exp.addArrayUsesToIndexMap(myIndexMap, indexNames);
			exp.createArrayTemporaries(fsl, vars, myIndexMap, addVar);
			FExp right = exp.scalarize(myIndexMap);
			indexNames.removeLayer();
			
			// Add statement updating temp var to loop
			FExp mul = new FMulExp(left, right);
			FExp add = new FAddExp(new FIdUseExp(tempVarName()), mul);
			fsl.add(new FAssignStmt(new FIdUse(tempVarName()), add));
		} else {
			super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		}
	}

	public void FIdUseExp.createArrayTemporaries(List clauses, List vars, 
			Map<String,FExp> indexMap, boolean addVar) {
		if (isSlice() && isArray() && canAcceptArray()) {
			useTempVar = true;
			defaultFunctionArrayTemporaries(clauses, vars, indexMap, addVar);
		}
	}

	/**
	 * \brief Create a new FIdUse of this variable with uses of <code>names</code> as array subscripts.
	 */
	public FIdUse FAbstractVariable.createUseWithNamedSubscripts(ForNames names) {
		return new FIdUse(name(), names.createFArraySubscripts());
	}
	
	/**
	 * Scalarize an assignment and put the resulting statements in the list of statements. 
	 * 
	 * This method delegates to scalarizeAssignment() for each cell in the array, 
	 * or for the entire scalar expression.
	 */
	public void FType.scalarizeArrayAssignment(
			List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap, FQName left, FExp right) {
		if (isArray()) {
			if (size().isUnknown() && right.size().isUnknown()) {
				ForNames names = new ForNames(ndims());
				names.fillLayer(right);
				List<FStatement> inner = names.createForLoops(stmts, left);
				FQName fqn = left.copyAndAddFas(names.createFArraySubscripts());
				FExp exp = right.extractUnknownArrayCell(indexMap, names);
				scalarizeAssignment(vars, inner, indexMap, fqn, exp);
			} else {
				Indices ind = size().isUnknown() ? right.indices() : indices();
				for (Index i : ind) {
					FQName fqn = left.specify(i, false);
					FExp exp = right.extractArrayCell(i);
					scalarizeAssignment(vars, stmts, indexMap, fqn, exp);
				}
			}
		} else {
			left = left.scalarize(indexMap);
			right = right.dynamicFExp(right.scalarize(indexMap));
			scalarizeAssignment(vars, stmts, indexMap, left, right);
		}
	}
	
	/**
	 * Scalarize an assignment and put the resulting statements in the list of statements.
	 */
	public void FType.scalarizeAssignment(
			List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap, FQName left, FExp right) {
		stmts.add(new FAssignStmt(new FIdUse(left.fullCopy()), right.unboundCopy()));
	}
	
	/**
	 * Scalarize an assignment and put the resulting statements in the list of statements.
	 */
	public void FRecordType.scalarizeAssignment(
			List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap, FQName left, FExp right) {
		for (FRecordComponentType comp : getComponents()) {
			FQName fqn = left.copyAsFQNameFull().append(comp.getName());
			FExp exp = right.scalarRecordFExp(indexMap, new FQNameString(comp.getName()));
			exp = right.dynamicFExp(exp);
			exp.clearScalarized();
			comp.getFType().scalarizeArrayAssignment(vars, stmts, indexMap, fqn, exp);
		}
	}
	
	/**
	 * Extract or create an expression representing a specific array cell of 
	 * this array expression.
	 * 
	 * Uses getArray() if size is known, and an expression type specific method 
	 * otherwise.
	 * 
	 * @param i   the index of the cell to extract
	 * @return    the expression for the cell
	 */
	public FExp FExp.extractArrayCell(Index i) {
		if (size().isUnknown())
			return extractUnknownArrayCell(i.createFArraySubscripts());
		else
			return getArray().get(i);
	}
	
	public FExp FIdUseExp.extractArrayCell(Index i) {
		if (getFIdUse().myFV().isUnknown())
			return new FIdUseExp(getFIdUse().specify(i));
		else
			return super.extractArrayCell(i);
	}
	
	/**
	 * \brief Create an expression describing a specific cell of an unknown array.
	 * 
	 * @param names  the names of the for indices to use as array subscripts
	 */
	public FExp FExp.extractUnknownArrayCell(Map<String,FExp> indexMap, ForNames names) {
		Map<String,FExp> myIndexMap = new HashMap<String,FExp>(indexMap);
		addArrayUsesToIndexMap(myIndexMap, names);
		return scalarize(myIndexMap);
	}
	
	/**
	 * \brief Create an expression describing a specific cell of an unknown array.
	 * 
	 * @param fas  the array subscripts to use
	 */
	public FExp FExp.extractUnknownArrayCell(FArraySubscripts fas) {
		return null; // TODO: Implement this for all possible subtypes (or replace with default impl)
	}
	
	public FExp FFunctionCall.extractUnknownArrayCell(FArraySubscripts fas) {
		return new FIdUseExp(tempVarName(), fas);
	}
	
	public FExp FIdUseExp.extractUnknownArrayCell(FArraySubscripts fas) {
		return new FIdUseExp(getFIdUse().getFQName().copyAndAddFas(fas));
	}
	
	public void FStatement.scalarizeStmt(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		int n1 = stmts.getNumChild();
		scalarize(vars, stmts, indexMap);
		if (shouldBeSorted) {
			int n2 = stmts.getNumChild();
			for (int i = n1; i < n2; i++) 
				stmts.getChild(i).shouldBeSorted = true;
		}
	}
	
	/**
	 * \brief Scalarize the statement and put all resulting statements in the
	 *        list of statements.
	 */
	public void FStatement.scalarize(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		stmts.add((FStatement) fullCopy());
	}
	
	public void FAssignStmt.scalarize(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		FIdUse left = getLeft();
		FExp right = getRight();
		if (left.type().isComposite() && right instanceof FFunctionCall) {
			FFunctionCall call = (FFunctionCall) right;
			call.getArgs().createArrayTemporaries(stmts, vars, indexMap, true);
			FFunctionCallStmt res = new FFunctionCallStmt();
			res.addLeft(new FFunctionCallLeft(new Opt(left.myFV().createUseExp())));
			res.setCall(call.scalarizeFunction(indexMap));
			stmts.add(res);
		} else if (left.type().isRecord()) {
			right.createArrayTemporaries(stmts, vars, indexMap, true);
			left.type().scalarizeArrayAssignment(vars, stmts, indexMap, left.getFQName(), right);
		} else if (right.size().isUnknown()) {
			left.myFV().scalarizeUnknownArrayAssignment(vars, stmts, indexMap, right);
		} else {
			right.createArrayTemporaries(stmts, vars, indexMap, true);
			if (left.ndims() > 0) {
				Array arr = right.getArray();
				for (Index i : arr.indices()) {
					FExp exp = arr.get(i).scalarize(indexMap);
					stmts.add(new FAssignStmt(left.specify(i, false), exp));
				}
			} else {
				FExp exp = right.scalarize(indexMap);
				stmts.add(new FAssignStmt(left.scalarize(indexMap), exp));
			}
		}
	}
	
	public void FFunctionCallStmt.scalarize(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		getCall().createArrayTemporaries(stmts, vars, indexMap, true);
		FFunctionCallStmt stmt = new FFunctionCallStmt();
		for (FFunctionCallLeft left : getLefts())
			stmt.addLeft(left.scalarize(indexMap));
		stmt.setCall((FAbstractFunctionCall) getCall().scalarizeExp(indexMap));
		stmts.add(stmt);
	}
	
	public void FIfWhenStmt.scalarize(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		for (FIfWhenClause cl : getFIfWhenClauses())
			cl.getTest().createArrayTemporaries(stmts, vars, indexMap, true);
		FIfWhenStmt stmt = createEmptyNode();
		for (FIfWhenClause cl : getFIfWhenClauses())
			stmt.addFIfWhenClause(cl.scalarize(vars, indexMap));
		scalarizeElse(vars, stmt, indexMap);
		stmts.add(stmt);
	}
	
	/**
	 * \brief Scalarize the else part of an if statement. Does nothing for when statements.
	 */
	public void FIfWhenStmt.scalarizeElse(List<? extends FAbstractVariable> vars, FIfWhenStmt stmt, 
			Map<String,FExp> indexMap) {}
	
	public void FIfStmt.scalarizeElse(List<? extends FAbstractVariable> vars, FIfWhenStmt stmt, 
			Map<String,FExp> indexMap) {
		FIfStmt ifstmt = (FIfStmt) stmt;
		for (FStatement es : getElseStmts())
			es.scalarize(vars, ifstmt.getElseStmtList(), indexMap);
	}
	
	/**
	 * \brief Scalarize the if or when clause.
	 */
	public FIfWhenClause FIfWhenClause.scalarize(List<? extends FAbstractVariable> vars, Map<String,FExp> indexMap) {
		FExp test = getTest().scalarize(indexMap);
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : getFStatements())
			stmt.scalarize(vars, stmts, indexMap);
		return createNode(test, stmts);
	}
	
	public void FForStmt.scalarize(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		getIndex().createArrayTemporaries(stmts, vars, indexMap, true);
		FForStmt stmt = new FForStmt();
		stmt.setIndex(getIndex().scalarize(indexMap));
		for (FStatement fs : getForStmts())
			fs.scalarize(vars, stmt.getForStmtList(), indexMap);
		stmts.add(stmt);
	}
	
	public void FWhileStmt.scalarize(List<? extends FAbstractVariable> vars, List<FStatement> stmts, 
			Map<String,FExp> indexMap) {
		getTest().createArrayTemporaries(stmts, vars, indexMap, true);
		FWhileStmt stmt = new FWhileStmt();
		stmt.setTest(getTest().scalarize(indexMap));
		for (FStatement ws : getWhileStmts())
			ws.scalarize(vars, stmt.getWhileStmtList(), indexMap);
		getTest().createArrayTemporaries(stmt.getWhileStmtList(), null, indexMap, false);
		stmts.add(stmt);
	}
	
	/**
	 * \brief Scalarize the function, replacing all array assignments with separate scalar 
	 *        assignments and scalarize all expressions.
	 */
	public FFunctionDecl FFunctionDecl.scalarize() {
		Map<String,FExp> emptyIndexMap = Collections.emptyMap();
		List<FFunctionVariable> vars = new List<FFunctionVariable>();
		List<FStatement> stmts = new List<FStatement>();
		
		for (FFunctionVariable var : getFFunctionVariables())
			var.scalarize(vars, stmts, emptyIndexMap);
		for (FStatement stmt : getFAlgorithm().getFStatements())
			stmt.scalarizeStmt(vars, stmts, emptyIndexMap);
		
		FFunctionDecl fd = createDecl();
		fd.setFQName(getFQName().fullCopy());
		fd.setFFunctionVariableList(vars);
		fd.setFAlgorithm(new FAlgorithm(stmts));
		if (hasFDerivativeFunction())
			fd.setFDerivativeFunction(getFDerivativeFunction().fullCopy());
		fd.inlineAnnotation = inlineAnnotation;
		return fd;
	}
	
	public FFunctionDecl FFunctionDecl.createDecl() {
		return new FFunctionDecl();
	}
	
	public FFunctionDecl FConstructorDecl.createDecl() {
		return new FConstructorDecl();
	}
	
	public FFunctionDecl FDestructorDecl.createDecl() {
		return new FDestructorDecl();
	}
	
	/**
	 * Clear the scalarized flag for all FQNames.
	 */
	public void ASTNode.clearScalarized() {
		for (ASTNode node : this)
			node.clearScalarized();
	}
	
	public void FQName.clearScalarized() {
		scalarized = false;
	}
	
	
	public void FAbstractEquation.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, Map<String,FExp> indexMap) {}
	
	/**
	 * \brief Scalarize equation and put all resulting equations in list eqns.
	 */
	public void FEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, Map<String,FExp> indexMap) {
		//log.debug("FEquation.scalarize() " + ndims());
		createArrayTemporaries(eqns, vars, indexMap, true);
		if (ndims()==0) {
			/*
			 * If the equation is of dimension 0, i.e, already scalar,
			 * the equations is "scalarized" into a simple equation where
			 * e.g. built in functions are replaced by elementary operations.
			 */
			
			FQName name = null;
			if (hasName()) {
				name = getName();
				if (!name.hasFArraySubscripts()) {
					List<FSubscript> list = extendedNameSubscript();
					name = name.copyAndAddFas(new FArraySubscripts(list));
					setName(name);
				}
				name = name.scalarize(indexMap);
			}
			FResidual residual = null;
			FNominal nominal = null;
			if (hasResidual())
				residual = getResidual().scalarize(indexMap, null);
			if (hasNominal())
				nominal = getNominal().scalarize(indexMap, null);
			createScalarFEquations(eqns, indexMap, name, residual, nominal, getLeft(), getRight());
		} else if (ndims() > 0) {
			/*
			 * If the expression is an array expression, then the FExp.getArray()
			 * element is used to generate scalar equations.
			 */
			// Iterate over array elements and create scalarized equation for each
			for (Index i : indices()) {
				FQName name = null;
				if (hasName())
					name = getName().specify(i, true);
				FResidual residual = null;
				FNominal nominal = null;
				if (hasResidual())
					residual = getResidual().scalarize(indexMap, i);
				if (hasNominal())
					nominal = getNominal().scalarize(indexMap, i);
				createScalarFEquations(eqns, indexMap, name, residual, nominal, getLeft().getArray().get(i), getRight().getArray().get(i));
			}
		} else {
			throw new UnsupportedOperationException("Bad equation: ndims() for equation '" + 
					this + "' returned " + ndims()); 
		}
	}
	
	inh List<FSubscript> FAbstractEquation.extendedNameSubscript();
	eq FForClauseE.getChild().extendedNameSubscript() {
		List<FSubscript> list = extendedNameSubscript();
		for (FForIndex fi : getFForIndexs()) 
			list.addChild(new FExpSubscript(new FIdUseExp(fi.getFVariable().name())));
		return list;
	}
	eq FlatRoot.getChild().extendedNameSubscript() = new List<FSubscript>();
	eq InstRoot.getChild().extendedNameSubscript() = new List<FSubscript>();
	
	public void FAlgorithm.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, Map<String,FExp> indexMap) {		
		List<FStatement> stmts = new List<FStatement>();
		for (FStatement stmt : getFStatements())
			stmt.scalarizeStmt(vars, stmts, indexMap);	
	    eqns.add(new FAlgorithm(stmts));	
	}
	
	/**
	 * \brief Scalarize left and right expressions and create new scalar equations.
	 */
	public void FEquation.createScalarFEquations(
			List<FAbstractEquation> eqns, Map<String,FExp> indexMap, FQName name, FResidual residual, FNominal nominal, FExp left, FExp right) {
		if (left.inferType().isRecord()) 
			left.inferType().scalarRecordFEquations(eqns, new FQNameEmpty(), indexMap, left, right);
		else
			eqns.add(new FEquation(name, residual, nominal, left.scalarize(indexMap), right.scalarize(indexMap)));
	}
	
	public FResidual FResidual.scalarize(Map<String,FExp> indexMap, Index i) {
		FResidual scalarized = new FResidual();
		scalarized.setLevel(getLevel());
		if (hasIterationVariable()) {
			FIdUse iterationVariable = getIterationVariable();
			if (i != null)
				iterationVariable = iterationVariable.specify(i, false);
			scalarized.setIterationVariable(iterationVariable.scalarize(indexMap));
		}
		return scalarized;
	}
	
	public FNominal FNominal.scalarize(Map<String,FExp> indexMap, Index i) {
		FNominal scalarized = new FNominal();
		FExp value = getValue();
		if (i != null)
			value = value.getArray().get(i);
		scalarized.setValue(value.scalarize(indexMap));
		return scalarized;
	}
	
	// TODO: Introduce parameter object?
	/**
	 * \brief Generate scalar FEquations for this record or record component.
	 * 
	 * @param eqns      the list of FEquations to add the equation to
	 * @param suffix    add this as a suffix to the name of the uppermost record in uses
	 * @param indexMap  translations for indices in the expressions
	 * @param left      the left expression from the original equation
	 * @param right     the right expression from the original equation
	 */
	public void FType.scalarRecordFEquations(
			List<FAbstractEquation> eqns, FQName suffix, 
			Map<String,FExp> indexMap, FExp left, FExp right) {
		eqns.add(new FEquation(left.scalarRecordFExp(indexMap, suffix), 
				right.scalarRecordFExp(indexMap, suffix)));
	}
	
	public void FRecordType.scalarRecordFEquations(
			List<FAbstractEquation> eqns, FQName suffix, 
			Map<String,FExp> indexMap, FExp left, FExp right) {
		for (FRecordComponentType comp : getComponents()) {
			FQName next = suffix.copyAndAppend(comp.getName());
			comp.getFType().scalarRecordComponentFEquations(eqns, next, indexMap, left, right);
		}
	}
	
	
	/**
	 * \brief Generate scalar FEquations for this record component.
	 * 
	 * @param eqns      the list of FEquations to add the equation to
	 * @param suffix    add this as a suffix to the name of the uppermost record in uses
	 * @param indexMap  translations for indices in the expressions
	 * @param left      the left expression from the original equation
	 * @param right     the right expression from the original equation
	 */
	public void FType.scalarRecordComponentFEquations(
			List<FAbstractEquation> eqns, FQName suffix, 
			Map<String,FExp> indexMap, FExp left, FExp right) {
		if (isArray()) {
			FQNameFull fullSuffix = suffix.copyAsFQNameFull();
			Indices ind = null;
			if (size().isComplete()) 
				ind = indices(); 
			else  // TODO: This is calculated each time - introduce some kind of lazy attribute?
				ind = left.dynamicFExp(left.scalarRecordFExp(indexMap, suffix)).indices();
			for (Index i : ind) {
				fullSuffix.addFArraySubscripts(i.createFArraySubscripts());
				scalarRecordFEquations(eqns, fullSuffix, indexMap, left, right);
			}
		} else {
			scalarRecordFEquations(eqns, suffix, indexMap, left, right);
		}
	}
	
	/**
	 * \brief Create an FExp that represents a specific scalar component of this record.
	 * 
	 * If <code>suffix</code> denotes a record expression, not a scalar, then the returned expression 
	 * might not be scalarized.
	 * 
	 * @param indexMap  translations for indices in the expressions
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	public FExp FExp.scalarRecordFExp(Map<String,FExp> indexMap, FQName suffix) {
		return scalarizeExp(indexMap);
	}
	
	public FExp FIdUseExp.scalarRecordFExp(Map<String,FExp> indexMap, FQName suffix) {
		return dynamicFExp(scalarizeExp(indexMap)).extractScalarRecordFExp(suffix);
	}
	
	public FExp FRecordConstructor.scalarRecordFExp(Map<String,FExp> indexMap, FQName suffix) {
		return suffix.scalarRecordFExpForCon(indexMap, this);
	}
	
	/**
	 * \brief Create an FExp that represents a specific scalar component of the given record constructor.
	 * 
	 * If <code>this</code> denotes a record expression, not a scalar, then the returned expression 
	 * might not be scalarized.
	 * 
	 * @param indexMap  translations for indices in the expressions
	 * @param con       the record constructor to extract an expression from
	 * 
	 * @see FExp#scalarRecordFExp(Map<String,FExp>, FQName)
	 */
	public FExp FQName.scalarRecordFExpForCon(Map<String,FExp> indexMap, FRecordConstructor con) {
		return con; // Not scalarized, see javadoc
		// TODO: shouldn't we throw an exception here?
	}
	
	public FExp FQNameString.scalarRecordFExpForCon(Map<String,FExp> indexMap, FRecordConstructor con) {
		FExp arg = con.getArg(con.getRecord().myFRecordDecl().indexOf(getName()));
		return arg.scalarRecordFExp(indexMap, new FQNameEmpty());
	}
	
	public FExp FQNameFull.scalarRecordFExpForCon(Map<String,FExp> indexMap, FRecordConstructor con) {
		FQNamePart first = getFQNamePart(0);
		FExp arg = con.getArg(con.getRecord().myFRecordDecl().indexOf(first.getName()));
		if (first.hasFArraySubscripts())
			arg = arg.getArray().get(first.getFArraySubscripts().asIndex());
		return arg.scalarRecordFExp(indexMap, copySuffix());
	}
	
	public FExp FFunctionCall.scalarRecordFExp(Map<String,FExp> indexMap, FQName suffix) {
		return scalarizeExp(indexMap).extractScalarRecordFExp(suffix);
	}
	
	public FExp FNoEventExp.scalarRecordFExp(Map<String,FExp> indexMap, FQName suffix) {
		return createNode(getFExp().scalarRecordFExp(indexMap, suffix));
	}
	
	/**
	 * \brief Create an FExp that represents a specific scalar component of this record.
	 * 
	 * It is assumed that this expression is already scalarized.
	 * 
	 * @param suffix    the suffix to add to a use of the record to access the specific component
	 */
	protected FExp FExp.extractScalarRecordFExp(FQName suffix) {
		return this;
	}
	
	protected FExp FIdUseExp.extractScalarRecordFExp(FQName suffix) {
		FQName name = getFIdUse().getFQName().copyAndAppend(suffix);
		name.scalarized = true;
		return new FIdUseExp(name);
	}
	
	/**
	 * \brief Scalarize equation and put all scalarized equations in list eqns.
	 */
	public void FFunctionCallEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, Map<String,FExp> indexMap) {
		List<FFunctionCallLeft> lefts = new List<FFunctionCallLeft>();
		for (FFunctionCallLeft id : getLefts())
			lefts.add(id.scalarize(indexMap));
		eqns.add(new FFunctionCallEquation(lefts, (FAbstractFunctionCall) getCall().scalarizeExp(indexMap)));
	}
	
	public void FForClauseE.scalarize(List<FAbstractEquation> eqns,
			List<FVariable> vars, Map<String,FExp> indexMap) {
		Indices indices = Indices.create(getFForIndexs());
		Map<String,FExp> myIndexMap = new HashMap<String,FExp>();
		myIndexMap.putAll(indexMap);
		for (Index i : indices) {
			indices.fillIndexMap(myIndexMap, i, getFForIndexs());
			scalarizeList(getFAbstractEquations(), eqns, vars, myIndexMap);
			getFAbstractEquations().flushAllRecursive(); // Throw calculated sizes/arrays
			getFAbstractEquations().flushTempVarNames();
		}
		for (FForIndex fi : getFForIndexs()) 
			fi.setEvaluationValue(null);
	}
	
	public void FIfWhenElseEquation.scalarize(List<FAbstractEquation> eqns, 
			List<FVariable> vars, Map<String,FExp> indexMap) {
		eqns.add(scalarize(vars, indexMap));
	}
	
	public FIfWhenElseEquation FIfWhenElseEquation.scalarize(
			List<FVariable> vars, Map<String,FExp> indexMap) {
		FIfWhenElseEquation res = createEmptyNode();
		res.setType((FEquationType) getType().fullCopy());
		res.eliminateOnParamTest = eliminateOnParamTest;
		scalarizeList(getFAbstractEquations(), res.getFAbstractEquations(), vars, indexMap);
		scalarizeTestAndElse(res, vars, indexMap);
		return res;
	}
	
	public void FIfWhenElseEquation.scalarizeTestAndElse(FIfWhenElseEquation res, 
			List<FVariable> vars, Map<String,FExp> indexMap) {}
	
	public void FIfWhenEquation.scalarizeTestAndElse(FIfWhenElseEquation res, 
			List<FVariable> vars, Map<String,FExp> indexMap) {
		FIfWhenEquation res2 = (FIfWhenEquation) res;
		res2.setTest(getTest().scalarize(indexMap));
		if (hasElse())
			res2.setElse(getElse().scalarize(vars, indexMap));
	}
	
	
	public FFunctionCallLeft FFunctionCallLeft.scalarize(Map<String,FExp> indexMap) {
		return new FFunctionCallLeft(hasFExp() ? new Opt(getFExp().scalarize(indexMap)) : new Opt());
	}
	
	/**
	 * \brief Add temporary variables and an equation/statement giving them values for each function 
	 *        call returning an array. Also add temporary variables and for loops for expressions 
	 *        (not assignments) of unknown array sizes. 
	 * 
	 * Creates statement if in function, equation otherwise.
	 * 
	 * @param clauses   the list to add the new equation or statement to
	 * @param vars      the list to add the new variables to
	 * @param indexMap  map of for indices to replace with literals
	 * @param addVar    if <code>true</code>, create and add temporary variable(s)
	 */
	// TODO: remove addVar, can be replaced with (vars != null)
	public void ASTNode.createArrayTemporaries(List clauses, 
			List vars, Map<String,FExp> indexMap, boolean addVar) {
		for (ASTNode node : this)
			node.createArrayTemporaries(clauses, vars, indexMap, addVar);
	}
	
	public void FFunctionCall.createArrayTemporaries(List clauses, 
			List vars, Map<String,FExp> indexMap, boolean addVar) {
		super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		if (!isFunctionCallClause()) {
			boolean equation = !inFunction();
			FExp temp = createTemporaryExp(indexMap, equation);
			if (temp != null) {
				List lefts = new List().add(new FFunctionCallLeft(new Opt(temp)));
				ASTNode clause = equation ? 
						new FFunctionCallEquation(lefts, scalarizeFunction(indexMap)) :
						new FFunctionCallStmt(lefts, scalarizeFunction(indexMap));
				clauses.add(clause);
				if (addVar)
					addTemporaryVars(vars, equation);
			}
		}
	}
	
	public void FVectorFunctionCall.createArrayTemporaries(List clauses, 
			List vars, Map<String,FExp> indexMap, boolean addVar) {
		getArray().createArrayTemporaries(clauses, vars, indexMap, addVar);
	}
	
	public void FSubscriptedExp.createArrayTemporaries(List clauses, 
			List vars, Map<String,FExp> indexMap, boolean addVar) {
		super.createArrayTemporaries(clauses, vars, indexMap, addVar);
		if (getFArraySubscripts().hasUnknownIndices() && inFunction()) {
			String name = tempVarName();
			if (addVar) {
				FType type = (FType) getFExp().type().fullCopy();
				vars.add(new FFunctionVariable(type, name));
			}
			
			Array arr = getFExp().getArray();
			for (Index i : arr.indices()) {
				FExp exp = arr.get(i).scalarize(indexMap);
				FIdUse use = new FIdUse(name, i.createFArraySubscripts());
				clauses.add(new FAssignStmt(use, exp));
			}
		}
	}
	
	/**
	 * \brief Creates temporary variable(s) for this expression.
	 * 
	 * This applies to expressions that may need temporaries anywhere, not only in 
	 * expressions with unknown array sizes. Should be used from createArrayTemporaries().
	 * 
	 * @param vars      list of variable to add the new variables to
	 * @param equation  if <code>true</code>, generate FVariables, otherwise a FFunctionVariable
	 */
	protected void FExp.addTemporaryVars(List vars, boolean equation) {
		boolean param = inParameterEquation() || inAttributeValue();
		FType type = type();
		if (inIterExp())
			type = type.sizedType(expandSizeForIterExp(type.size()));
		if (type.isRecord()) {
			type.createRecordTemporaries(vars, equation, tempVarName(), param);
		} else {
			if (equation) 
				type.createTempFVariables(vars, new FQNameString(tempVarName()), param);
			else 
				vars.add(new FFunctionArray(type.fullCopy(), tempVarName()));
		}
	}
	
	/**
	 * \brief Creates an expression for using the temporary variables of this expression.
	 * 
	 * If this expression is neither an array nor a record, then <code>null</code> is returned.
	 * 
	 * This applies to expressions that may need temporaries anywhere, not only in 
	 * expressions with unknown array sizes. Should be used from createArrayTemporaries().
	 * 
	 * @param indexMap  map of for indices to replace with literals
	 * @param equation  if <code>true</code>, generate FVariables, otherwise a FFunctionVariable
	 */
	protected FExp FExp.createTemporaryExp(Map<String,FExp> indexMap, boolean equation) {
		if (type().isRecord()) {
			if (equation)
				return type().createRecordConstructor(new FQNameString(tempVarName()));
			else
				return new FIdUseExp(tempVarName());
		} else if (isArray()) {
			if (equation) 
				return getArray().buildScalarized(indexMap, this);
			else 
				return new FIdUseExp(tempVarName());
		}
		return null;
	}
	
	/**
	 * \brief Creates temporary variables for a record with the given name.
	 * 
	 * @param vars      list of variable to add the new variables to
	 * @param equation  if <code>true</code>, generate FVariables, otherwise a FFunctionVariable
	 * @param name      the name of the record variable
	 * @param param     if <code>true</code>, generate parameters
	 */
	public void FType.createRecordTemporaries(List vars, boolean equation, String name, boolean param) {}	
	
	public void FRecordType.createRecordTemporaries(List vars, boolean equation, String name, boolean param) {
		if (equation) {
			createTempFVariables(vars, new FQNameString(name), param);
		} else {
			FFunctionVariable var = isArray() ? new FFunctionArray() : new FFunctionVariable();
			var.setType(fullCopy());
			var.setFQName(new FQNameString(name));
			vars.add(var);
		}
	}	
	
	/**
	 * \brief Create a record constructor (or FArray of record constructors),  
	 *        with the arguments taken from a record variable with the given name.
	 */
	public FExp FType.createRecordConstructor(FQName name) {
		if (isArray()) 
			return createRecordConstructorArray(name, indices().iterator(), 0);
		else 
			return createRecordConstructorCell(name);
	}
	
	/**
	 * Create an FArray of expressions, with the arguments taken from a record 
	 * variable or member with the given name.
	 */
	public FExp FType.createRecordConstructorArray(FQName name, Iterator<Index> it, int dim) {
		FArray arr = new FArray();
		boolean last = dim == ndims() - 1;
		for (int i = 0, n = size().get(dim); i < n; i++) {
			FExp exp;
			if (last)
				exp = createRecordConstructorCell(name.copyAndAddFas(it.next().createFArraySubscripts()));
			else
				exp = createRecordConstructorArray(name, it, dim + 1);
			arr.addFExp(exp);
		}
		return arr;
	}
	
	/**
	 * \brief Create a record constructor with the arguments taken from a record 
	 *        variable with the given name.
	 * 
	 * Assumes that <code>name</code> refers to a non-array variable 
	 * (or a specific cell in an array variable).
	 */
	public FExp FType.createRecordConstructorCell(FQName name) {
		FQName fqn = (FQName) name.unboundCopy();
		fqn.scalarized = true;
		return new FIdUseExp(fqn);
	}
	
	public FExp FRecordType.createRecordConstructorCell(FQName name) {
		FRecordConstructor rc = new FRecordConstructor(new FIdUse(getName()), new List());
		for (FRecordComponentType comp : getComponents()) {
			FQName next = name.copyAndAppend(comp.getName());
			rc.addArg(comp.getFType().createRecordConstructor(next));
		}
		return rc;
	}
	
	/**
	 * \brief Creates a new temporary varable with the given name.
	 *        If this is an array, variables are created for each cell.
	 * 
	 * @param vars   list of variable to add the new variable to
	 * @param name   the name of the new variable
	 * @param param  if <code>true</code>, create parameters instead of variables
	 */
	public void FType.createTempFVariables(List vars, FQName name, boolean param) {
		if (isArray()) {
			FQNameFull fqn = name.copyAsFQNameFull();
			for (Index i : indices()) {
				fqn.addFArraySubscripts(i.createFArraySubscripts());
				createTempCellFVariables(vars, fqn, param);
			}
		} else {
			createTempCellFVariables(vars, name, param);
		}
	}
	
	/**
	 * Creates a new temporary variable with the given name.
	 * 
	 * @param vars   list of variable to add the new variable to
	 * @param name   the name of the new variable
	 * @param param  if <code>true</code>, create parameters instead of variables
	 */
	public void FType.createTempCellFVariables(List vars, FQName name, boolean param) {
		FQName fqn = name.fullCopy();
		fqn.scalarized = true;
		
		FAbstractVariable var = createTempFVariable(fqn, param);
		vars.add(var);
	}
	
	/**
	 * \brief Creates temporary variables for a record with the given name.
	 * 
	 * @param vars   list of variable to add the new variable to
	 * @param name   the name of the new variable
	 * @param param  if <code>true</code>, create parameters instead of variables
	 */
	public void FRecordType.createTempCellFVariables(List vars, FQName name, boolean param) {
		for (FRecordComponentType comp : getComponents()) {
			FQName next = name.copyAndAppend(comp.getName());
			comp.getFType().createTempFVariables(vars, next, param);
		}
	}
	
	
	/**
	 * \brief Creates a new temporary variable with the given name.
	 * 
	 * All optional children in the new variable are empty.
	 * If param is true, then variability is parameter, otherwise continous.
	 */
	public FVariable FType.createTempFVariable(FQName name, boolean param) {
		return createFVariable(new FTemporaryVisibilityType(), name, param);
	}
	
	/**
	 * \brief Creates a new variable with the given visibility and name.
	 * 
	 * All optional children in the new variable are empty.
	 * If param is true, then variability is parameter, otherwise continous.
	 */
	public FVariable FType.createFVariable(FVisibilityType fvt, FQName name, boolean param) {
		return createFVariable(fvt, name, param ? new FParameter() : new FContinuous());
	}
	
	/**
	 * \brief Creates a new temporary variable with the given visibility, name and visibility.
	 * 
	 * All optional children in the new variable are empty.
	 * 
	 * Default implementation returns <code>null</code>.
	 */
	public FVariable FType.createTempFVariable(FQName name, FTypePrefixVariability variability) {
		return createFVariable(new FTemporaryVisibilityType(), name, variability);
	}
	
	/**
	 * \brief Creates a new variable with the given visibility, name and visibility.
	 * 
	 * All optional children in the new variable are empty.
	 * 
	 * Default implementation returns <code>null</code>.
	 */
	public FVariable FType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		throw new UnsupportedOperationException();
	}
		
	public FVariable FRealType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		return new FRealVariable(fvt, variability, name);
	}	
	
	public FVariable FIntegerType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		return new FIntegerVariable(fvt, variability, name);
	}	
	
	public FVariable FBooleanType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		return new FBooleanVariable(fvt, variability, name);
	}	
	
	public FVariable FStringType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		return new FStringVariable(fvt, variability, name);
	}	
	
	public FVariable FRecordType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		return new FRecordVariable(fvt, variability, name, new FQNameString(getName()));
	}	
	
	public FVariable FEnumType.createFVariable(FVisibilityType fvt, FQName name, 
			FTypePrefixVariability variability) {
		return new FEnumVariable(fvt, variability, name, new FQNameString(getName()));
	}	
	
	
	/* Scalarization of expressions is needed in order to compute a simple
	 * scalar expression from an expression with ndims==0. For example, an
	 * FIdUse 'x[2]' needs to be marked as scalarized, and the expression
	 * scalar(x*A*x) needs to be replaced by a double sum.
	 */
	
	/**
	 * \brief Create an FArray containing scalarized subexpressions.
	 */
	public FExp Array.buildScalarized(Map<String,FExp> indexMap, FExp context) {
    	return buildFArray(new ScalarizedBuilder(indexMap, context));
    }
    
	public static class Array {
	    /**
	     * Helper object for {@link #buildScalarized(java.util.Map<String,FExp>)}.
	     */
	    protected class ScalarizedBuilder implements ElementBuilder {
	    	private Map<String,FExp> indexMap;
	    	private FExp context;
	    	
	    	public ScalarizedBuilder(Map<String,FExp> indexMap, FExp context) {
	    		this.indexMap = indexMap;
	    		this.context = context;
	    	}
	    	
			public FExp build(FExp e) {
				return context.dynamicFExp(e).scalarize(indexMap);
			}
	    }
	}
	
	/**
	 * \brief Flag that signals that this expression should be replaced with a use of a temporary variable.
	 */
	protected boolean FExp.useTempVar = false;

	/**
	 * \brief Scalarize expressions, replacing array expressions with FArrays of scalarized subexpressions.
	 * 
	 * The FArrays are needed because function calls need arrays to be passed as arrays.
	 */
	public FExp FExp.scalarize(Map<String,FExp> indexMap) {
		FExp res;
		if (useTempVar) 
			res = indexMap.containsKey(tempVarName()) ? 
					indexMap.get(tempVarName()).fullCopy() : 
					new FIdUseExp(tempVarName());
		else if (type().isRecord() && wantsRecordCon())
			res = buildRecordConstructor(indexMap);
 		else if (buildScalarArray()) 
 			res = getArray().buildScalarized(indexMap, this);
		else
			res = scalarizeExp(indexMap);
		return res;
	}
	
	/**
	 * \brief Create a record constructor (or FArray of record constructors) 
	 *        describing this record expression.
	 */
	public FExp FExp.buildRecordConstructor(Map<String,FExp> indexMap) {
		return type().createRecordConstructor(new FQNameString(tempVarName()));
	}
	
	public FExp FIdUseExp.buildRecordConstructor(Map<String,FExp> indexMap) {
		return type().createRecordConstructor(getFIdUse().getFQName().scalarize(indexMap));
	}
	
	public FExp FRecordConstructor.buildRecordConstructor(Map<String,FExp> indexMap) {
		return scalarizeExp(indexMap);
	}
	
	public FExp FArray.buildRecordConstructor(Map<String,FExp> indexMap) {
		if (isIterArray())
			return getFExp(0).buildRecordConstructor(indexMap);
		FArray res = new FArray();
		for (FExp e : getFExps())
			res.addFExpNoTransform(e.buildRecordConstructor(indexMap));
		return res;
	}
	
	syn boolean FExp.buildScalarArray() = isArray() && !keepAsArray();
	eq FArray.buildScalarArray() = false;
	
	syn boolean FExp.keepAsArray() = canKeepAsArray() && canAcceptArray() || size().isUnknown();

	syn boolean FExp.canKeepAsArray() = false;
	eq FIdUseExp.canKeepAsArray()     = true;
	eq FFunctionCall.canKeepAsArray() = true;
	
	inh boolean FExp.canAcceptArray();
	eq BaseNode.getChild().canAcceptArray()         = false;
	eq FFunctionCallLeft.getFExp().canAcceptArray() = inFunction();
	eq FFunctionCall.getArg().canAcceptArray()      = inFunction();
	eq FSizeExp.getFExp().canAcceptArray()          = inFunction();
	
	/**
	 * \brief Scalarize expressions.
	 */
	public FExp FExp.scalarizeExp(Map<String,FExp> indexMap) {
		return fullCopy();
	}

	public FExp FArray.scalarizeExp(Map<String,FExp> indexMap) {
		if (isIterArray())
			return getFExp(0).scalarize(indexMap);
		FArray res = new FArray();
		for (FExp e : getFExps())
			res.addFExpNoTransform(e.scalarize(indexMap));
		return res;
	}

	public FSubscript FSubscript.scalarize(Map<String,FExp> indexMap) {
		return (FSubscript) fullCopy();
	}
	
	public FSubscript FExpSubscript.scalarize(Map<String,FExp> indexMap) {
		return new FExpSubscript(getFExp().scalarize(indexMap));
	}
	
	public FArraySubscripts FArraySubscripts.scalarize(Map<String,FExp> indexMap) {
		FArraySubscripts fas = new FArraySubscripts();
		for (FSubscript fs : getFSubscripts()) {
			fas.addFSubscript(fs.scalarize(indexMap));
		}
		return fas;
	}
	
	public FQNamePart FQNamePart.scalarize(Map<String,FExp> indexMap) {
		return new FQNamePart(getName());
	}
	
	public FQNamePartArray FQNamePartArray.scalarize(Map<String,FExp> indexMap) {
		return new FQNamePartArray(getName(), getFArraySubscripts().scalarize(indexMap));
	}
	
	public abstract FQName FQName.scalarize(Map<String,FExp> indexMap);
	
	public FQName FQNameEmpty.scalarize(Map<String,FExp> indexMap) {
		return new FQNameEmpty();
	}
	
	public FQName FQNameString.scalarize(Map<String,FExp> indexMap) {
		return new FQNameString(getName());
	}
	
	public FQName FQNameFull.scalarize(Map<String,FExp> indexMap) {
		FQNameFull fqn = new FQNameFullScalarize(new List());
		for (FQNamePart fqnp : getFQNameParts()) 
			fqn.addFQNamePart(fqnp.scalarize(indexMap));
		fqn.scalarized = true;
		return fqn;
	}
	
	rewrite FQNameFullScalarize {
		to FQName inFunction() ? new FQNameFull(getFQNamePartList()) : new FQNameString(scalarName());
	}
	
    public FIdUse FIdUse.scalarize(Map<String,FExp> indexMap) {
    	return new FIdUse(getFQName().scalarize(indexMap));
    }

    public FExp FIdUseExp.scalarizeExp(Map<String,FExp> indexMap) {
    	if (indexMap.containsKey(name()) && !shouldKeepArrayDuringScalarization()) 
    		return indexMap.get(name()).fullCopy();
    	return new FIdUseExp(getFIdUse().scalarize(indexMap));
    }
    
    inh boolean FIdUseExp.shouldKeepArrayDuringScalarization();
    eq BaseNode.getChild().shouldKeepArrayDuringScalarization() = false;
    eq FFunctionCall.getArg(int i).shouldKeepArrayDuringScalarization() = 
    	getArg(i).isArray() && myInputs().get(i).ndims() == getArg(i).ndims();
    
	inh boolean FExp.wantsRecordCon();
	eq BaseNode.getChild().wantsRecordCon()         = false;
	eq FFunctionCall.getArg().wantsRecordCon()      = !inFunction();
	eq FRecordConstructor.getArg().wantsRecordCon() = wantsRecordCon();
	eq FArray.getFExp().wantsRecordCon()            = wantsRecordCon();
 
    public FExp FIfExp.scalarizeExp(Map<String,FExp> indexMap) {
		return new FIfExp(getIfExp().scalarize(indexMap),
		                  getThenExp().scalarize(indexMap),
		                  getElseExp().scalarize(indexMap));
	}
	
	public FExp FMulExp.scalarizeExp(Map<String,FExp> indexMap) {
		if (getLeft().isArray() && !isArray()) 
			return dynamicFExp(composeMulScalarCellExp(Index.NULL)).scalarize(indexMap);
		else
			return super.scalarizeExp(indexMap);
	}
	
	public FExp FRangeExp.scalarizeExp(Map<String,FExp> indexMap) {
		FExp res = new FIdUseExp(indexNames.get(0));
		boolean startIsOne = getFExp(0).isIntegerLiteral(1);
		if (!startIsOne || hasStep()) {
			res = new FSubExp(res, new FIntegerLitExp(1));
			if (hasStep())
				res = new FMulExp(res, getFExp(1).fullCopy());
			res = new FAddExp(getFExp(0).fullCopy(), res);
		}
		return res;
	}

	
	public FExp FSizeExp.scalarizeExp(Map<String,FExp> indexMap) {
		// Only the form with dim can be in the tree at this point
		FExp exp = getFExp();
		if (exp instanceof FIdUseExp && exp.size().isUnknown())
			return fullCopy();
		else
			return dynamicFExp(getFExp().size().createFExp(dimension())).scalarize(indexMap);
	}
	
	public FExp FNdimsExp.scalarizeExp(Map<String,FExp> indexMap) {
		return ceval().buildLiteral();
	}
	
	public FExp FSubscriptedExp.scalarizeExp(Map<String,FExp> indexMap) {
		FArraySubscripts fas = getFArraySubscripts().scalarize(indexMap);
		if (getFArraySubscripts().hasUnknownIndices() && inFunction()) {
			return new FIdUseExp(tempVarName(), fas);
		} else {
			Index i = fas.asIndex();
			return getFExp().getArray().get(i).scalarize(indexMap);
		}
	}
	
	public FExp FMinMaxExp.scalarizeExp(Map<String,FExp> indexMap) {
		if (hasY())
			return createNode(getX().scalarize(indexMap), getY().scalarize(indexMap));
		else
			return getX().reduceToScalarized(this, indexMap);
	}
	
	public FExp FReductionExp.scalarizeExp(Map<String,FExp> indexMap) {
		if (getFExp().size().numElements() == 0)
			return reduceStartValue().buildLiteral();
		else
			return getFExp().reduceToScalarized(scalarReduceExp(), indexMap);
	}
	
	syn FBinExp FReductionExp.scalarReduceExp();
	eq FSumExp.scalarReduceExp()     = new FAddExp();
	eq FProductExp.scalarReduceExp() = new FMulExp();
	
	public FExp FIterExp.scalarizeExp(Map<String,FExp> indexMap) {
		return getFExp().scalarize(indexMap);
	}
	
	/**
	 * \brief Scalarize an expression by recursively scalarizing and combining the contents in its Array.
	 * 
	 * New nodes are created with <code>template.createNodeBinary()</code>.
	 */
	public FExp FExp.reduceToScalarized(FExp template, Map<String,FExp> indexMap) {
		if (isArray()) {
			Iterator<FExp> it = getArray().iteratorFExp();
			FExp res = it.next().scalarize(indexMap);
			while (it.hasNext())
				res = template.createNodeBinary(res, it.next().scalarize(indexMap));
			return res;
		} else {
			return scalarize(indexMap);
		}
	}
	
	public FExp FBinExp.scalarizeExp(Map<String,FExp> indexMap) { return createNode(getLeft().scalarize(indexMap), getRight().scalarize(indexMap)); }
	public FExp FUnaryExp.scalarizeExp(Map<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FMathematicalFunctionCall.scalarizeExp(Map<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FAtan2Exp.scalarizeExp(Map<String,FExp> indexMap) { return new FAtan2Exp(getFExp().scalarize(indexMap), getY().scalarize(indexMap)); }
	public FExp FUnaryBuiltIn.scalarizeExp(Map<String,FExp> indexMap) { return createNode(getFExp().scalarize(indexMap)); }
	public FExp FNoArgBuiltIn.scalarizeExp(Map<String,FExp> indexMap) { return createEmptyNode(); }
	public FExp FEventGenExp.scalarizeExp(Map<String,FExp> indexMap) { return createNode(getX().scalarize(indexMap)); }
	public FExp FBinEventGenExp.scalarizeExp(Map<String,FExp> indexMap) { return createNode(getX().scalarize(indexMap),getY().scalarize(indexMap)); }
	
	public FExp FLitExp.scalarizeExp(Map<String,FExp> indexMap) { return (FLitExp) fullCopy(); }
	public FExp FDerExp.scalarizeExp(Map<String,FExp> indexMap) { return new FDerExp(getFIdUse().scalarize(indexMap)); }
	
	public FExp FSmoothExp.scalarizeExp(Map<String,FExp> indexMap)  { return new FSmoothExp(getOrder().scalarize(indexMap), getFExp().scalarize(indexMap)); }
	public FExp FSampleExp.scalarizeExp(Map<String,FExp> indexMap)  { return new FSampleExp(getOffset().scalarize(indexMap), getInterval().scalarize(indexMap)); }
	
	public FExp FStringExp.scalarizeExp(Map<String,FExp> indexMap)  { return new FStringExp(new List(), getValue().scalarize(indexMap)); }
	
	public FExp FFunctionCall.scalarizeExp(Map<String,FExp> indexMap) {
		if (isComposite() && functionCallIsExp())
			return new FIdUseExp(tempVarName());
		else
			return scalarizeFunction(indexMap);
	}
	
	public FExp FRecordConstructor.scalarizeExp(Map<String,FExp> indexMap) {
		FRecordConstructor rc = new FRecordConstructor(getRecord().scalarize(indexMap), new List());
		for (FExp arg : getArgs())
			rc.addArg(arg.scalarize(indexMap));
		return rc;
	}
	
	public FExp FZeros.scalarizeExp(Map<String,FExp> indexMap) {
		return new FIntegerLitExp(0);
	}
	
	public FExp FOnes.scalarizeExp(Map<String,FExp> indexMap) {
		return new FIntegerLitExp(1);
	}
	
	public FExp FScalarExp.scalarizeExp(Map<String,FExp> indexMap) {
		return getFExp().getArray().getFExp(0).scalarize(indexMap);
	}
	
	public FExp FFillExp.scalarizeExp(Map<String,FExp> indexMap) {
		return getFillExp().fullCopy();
	}
	
	public FFunctionCall FFunctionCall.scalarizeFunction(Map<String,FExp> indexMap) {
		List<FExp> args = new List<FExp>();
		for (FExp arg : getArgs())
			args.add(arg.scalarize(indexMap));
		return new FFunctionCall(getName().fullCopy(), args, getSizes()); 
	}
	
	public FAssert FAssert.scalarizeExp(Map<String,FExp> indexMap) {
		Opt level = hasLevel() ? new Opt(getLevel().scalarize(indexMap)) : new Opt();
		return new FAssert(getTest().scalarize(indexMap), getMsg().scalarize(indexMap), level);
	}
	
	public FExp FEndExp.scalarizeExp(Map<String,FExp> indexMap) {
		return mySize().isUnknown() ? createFSizeExp() : mySize().createFExp(0);
	}
	
	inh FSizeExp FEndExp.createFSizeExp();
	eq FArraySubscripts.getFSubscript(int i).createFSizeExp() = createFSizeExp(i);
	eq FlatRoot.getChild().createFSizeExp()                   = null;
	eq InstRoot.getChild().createFSizeExp()                   = null;
	
	inh FSizeExp FArraySubscripts.createFSizeExp(int dim);
	eq FlatRoot.getChild().createFSizeExp(int dim) = null;
	eq InstRoot.getChild().createFSizeExp(int dim) = null;
	eq FQName.getChild().createFSizeExp(int dim) {
		FQName fqn = fullCopy();
		fqn.removeFArraySubscripts();
		FExp dimExp = new FIntegerLitExp(dim + 1);
		return new FSizeExp(new FIdUseExp(fqn), new Opt(dimExp));
	}

	
	public FForIndex FForIndex.scalarize(Map<String,FExp> indexMap) {
		return new FForIndex(hasFExp() ? new Opt(getFExp().scalarizeIndexExp(indexMap)) : new Opt(), 
				(FVariable) getFVariable().fullCopy());
	}
	
	/**
	 * \brief Scalarize the expression of an FForIndex. 
	 */
	public FExp FExp.scalarizeIndexExp(Map<String,FExp> indexMap) {
		return scalarize(indexMap);
	}
	
	public FRangeExp FRangeExp.scalarizeIndexExp(Map<String,FExp> indexMap) {
		List<FExp> exps = new List<FExp>();
		for (FExp e : getFExps())
			exps.add(e.scalarize(indexMap));
		return new FRangeExp(exps);
	}
	
	public void ConnectionSetManager.scalarize() {
		for (ConnectionSet set : list)
			set.scalarize();
	}
	
	public void ConnectionSet.scalarize() {
		for (ConnectionSetEntry e : this)
			e.scalarize();
	}
	
	public void ConnectionSetEntry.scalarize() {
		if (fqName.accessNdims() == 0) {
			// Can't use FQName.scalarize(), since it relies on rewrites
			fqName = new FQNameString(fqName.scalarName());
		} else {
			Indices ind = Indices.createFromFas(fqName.getFArraySubscripts());
			scalarNames = new String[ind.numElements()];
			int j = 0;
			for (Index i : ind)
				scalarNames[j++] = fqName.copyAndAddFas(i.createFArraySubscripts()).scalarName();
		}
	}

}
