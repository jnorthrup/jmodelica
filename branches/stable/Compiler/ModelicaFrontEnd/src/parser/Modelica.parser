/*
    Copyright (C) 2009-2014 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

%goal source_root;
%goal anonymous_short_class;
%goal exp;
%goal element;
%goal abstract_equation

%header {:
 package $PARSER_PACKAGE$;
 import $AST_PACKAGE$.*;
 import org.jmodelica.util.formatting.FormattingRecorder;
 import org.jmodelica.util.formatting.FormattingType;
 import org.jmodelica.api.problemHandling.Problem;
 import org.jmodelica.api.problemHandling.ProblemSeverity;
 import org.jmodelica.api.problemHandling.ProblemKind;
 import beaver.Parser.Events;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
:};

%embed {:

    /**
     * Error reporting class that creates an error message and delegates reporting the 
     * message to a subclass.
     */
    public abstract static class Report extends Events {

        /**
         * Report an error with error message <code>msg</code>.
         */
        protected abstract void report(Problem P);

        /**
         * Creates an error message for when <code>token</code> is found unexpectedly. 
         * Passes the error message to {@link #report(Problem)}.
         * @param token     the unexpected symbol.
         */
        public void syntaxError(Symbol token) {
            
            StringBuilder s = new StringBuilder();
            //s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
            if (token.getId() == Terminals.EOF) {
                s.append("  Unexpected end of file");
            } else if (token.value != null) {
                s.append("   Unexpected token: \"" + token.value + "\"");
            } else if (token.getId()<Terminals.NAMES.length)
                s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
            else 
                s.append("  Syntactic error");
            Problem p = new Problem(fileName, s.toString(), ProblemSeverity.ERROR, ProblemKind.SYNTACTIC, Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
            
            report(p);
        }

        /**
         * Creates an error message for when the scanner throws an exception.
         * Passes the error message to {@link #report(Problem)}.
         * @param e     the exception.
         */
        public void scannerError(Scanner.Exception e) {
            /*
            StringBuilder s = new StringBuilder(e.getMessage());
            s.append(" at line ");
            s.append(e.line);
            s.append(", column ");
            s.append(e.column);
            */
            Problem p = new Problem(fileName, e.getMessage(), ProblemSeverity.ERROR, ProblemKind.LEXICAL, e.line, e.column);
            
            report(p);
        }

        private String fileName = "";

        public void setFileName(String fn) {
            fileName = fn;
        }

    }
    
    /**
     * Error reporting class that throws a {@link ParserException} on an error.
     * Uses error message created by {@link Report}.
     */
    public class AbortingReport extends Report {

        /**
         * Throws a <code>ParserException</code> with <code>msg</code> as the message.
         */
        @Override
        protected void report(Problem p) {
          throw new ParserException(p);
        }

    }

    /**
     * Error reporting class that collects error messages for later retrieval.
     * Uses error message created by {@link Report}.
     */
    public static class CollectingReport extends Report {

        private ArrayList<Problem> errors = new ArrayList<Problem>();

        /**
         * Adds error message <code>msg</code> to list.
         */ 
        @Override
        protected void report(Problem p) {
            errors.add(p);          
        }

        /**
         * Get the list of errors. Returns a reference to the internal list, not a copy.
         * @return a {@link java.util.Collection} with the reported error messages.
         */
        public Collection<Problem> getErrors() {
            return errors;
        }

        /**
         * Reset the list of errors.
         */
        public void resetErrors() {
            errors = new ArrayList<Problem>();
        }

        /**
         * Checks if any errors has been reported.
         * @return <code>true</code> if the list contains any errors.
         */
        public boolean hasErrors() {
            return !errors.isEmpty();
        }

    }

    { report = new AbortingReport(); }  // As default, throw exception on errors.

    /**
     * Set the error reporting class to use.
     * @param report    a subclass of {@link Events} to use for reporting errors.
     */
    public void setReport(Events report) {
        this.report = report;
    }

    public Events getReport() {
        return report;
    }

    private int[] lineBreakMap;

    public void setLineBreakMap(int[] map) {
        lineBreakMap = map;
    }

    private FormattingRecorder<ASTNode<?>> formattingRecorder;

    public void setFormattingRecorder(FormattingRecorder<ASTNode<?>> formattingRecorder) {
        this.formattingRecorder = formattingRecorder;
    }

    public void setFileName(String fn) {
        if (report instanceof Report)
            ((Report) report).setFileName(fn);
    }
    
    Symbol annotationTok = null;
    
:};
 
SourceRoot source_root
    = /* nothing */ {: 
        SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr; 
      :}
   | program {: 
       SourceRoot sr = new SourceRoot(program); 
       return sr; 
   :};

Program program
    = stored_definition   {: 
        return new Program(new List().add(stored_definition)); 
    :};
  
StoredDefinition stored_definition
    = within? base_class_decl_list {:
        StoredDefinition def = new StoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
        formattingRecorder.postParsing(def);
    	return def; 
    :}
    | error {: 
        return new BadDefinition(); 
    :};

Within within
    = WITHIN parse_access? SEMICOLON {: 
        return new Within(parse_access); 
    :};
  
List base_class_decl_list  
    = base_class_decl SEMICOLON {: 
        return new List().add(base_class_decl); 
    :}
    | base_class_decl_list base_class_decl SEMICOLON {: 
        base_class_decl_list.add(base_class_decl);
        return base_class_decl_list; 
    :};

BaseClassDecl anonymous_short_class = class_access class_modification?
        {: return new PN_ShortClassDecl(
                   new IdDecl("'Anonymous Class'"),
                   new UnknownVisibilityType(),
                   new Opt(), new Opt(), 
                   new MClass(), 
                   new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), 
                   new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), 
                   class_access,
                   new Opt(), 
                   class_modification, 
                   new Comment()); 
        :};

BaseClassDecl base_class_decl 
    =               
    encapsulated? 
    partial? 
    restriction  
    id_decl.start 
    string_comment? 
    composition 
    annotation_sc?
    end_decl   {:   
        return new PN_FullClassDecl(
            start,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            annotation_sc,
            end_decl); 
    :}
    |
    encapsulated? 
    partial? 
    restriction  
    id_decl.class_name EQUALS
    type_prefix_flow?
    type_prefix_variability?
    type_prefix_input_output?
    class_access /*name*/
    array_subscripts?
    class_modification?
    comment {:
        return new PN_ShortClassDecl(
            class_name, 
            new UnknownVisibilityType(),
            encapsulated, 
            partial, 
            restriction, 
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            type_prefix_flow, 
            type_prefix_variability, 
            type_prefix_input_output, 
            class_access,
            array_subscripts, 
            class_modification, 
            comment); 
    :}
    |
    encapsulated? 
    partial? 
    restriction 
    EXTENDS 
    id_decl.start 
    class_modification?
    string_comment? 
    composition 
    annotation_sc?
    end_decl {:
        return new PN_ExtendClassDecl(
            start,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            annotation_sc,
            end_decl, 
            class_modification); 
  :}  
   |
    encapsulated? 
    partial? 
    restriction  
    id_decl.enum_name EQUALS
    ENUMERATION LPAREN enum_specification RPAREN
    comment {:
    return new PN_EnumDecl(
            enum_name,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            ENUMERATION,
            enum_specification,
            comment); 
    
    :}
  | error {: 
      return new BadClassDecl();
  :};

EnumSpecification enum_specification =
  COLON {: return new EnumUnspecified(); :}
  | enum_literal_list {: return new EnumLiteralList(enum_literal_list); :}
  ;
  
List enum_literal_list =
  enum_literal                          {: return new List().add(enum_literal); :}
  | enum_literal_list COMMA enum_literal    {: enum_literal_list.add(enum_literal); 
                                       return enum_literal_list; :}
  ;

EnumLiteral enum_literal = 
  id_decl comment {: return new EnumLiteral(id_decl,comment); :}
  ;

Partial partial = 
  PARTIAL {: return new Partial(); :}
  ;

Encapsulated encapsulated = 
  ENCAPSULATED {: return new Encapsulated(); :}
  ;

TypePrefix type_prefix_variability = 
   DISCRETE         {: return new Discrete(); :}
  | PARAMETER       {: return new Parameter(); :}
  | CONSTANT        {: return new Constant(); :}
  ;
  
TypePrefix type_prefix_input_output = 
    INPUT           {: return new Input(); :}
  | OUTPUT          {: return new Output(); :}
  ;


Restriction restriction = 
  CLASS                    {: return new MClass(); :}
  | MODEL                  {: return new Model(); :}
  | BLOCK                  {: return new Block(); :}
  | CONNECTOR              {: return new Connector(); :}
  | EXPANDABLE CONNECTOR   {: return new ExpandableConnector(); :}
  | TYPE                   {: return new MType(); :}
  | PACKAGE                {: return new MPackage(); :}
  | FUNCTION               {: return new Function(); :}
  | RECORD                 {: return new Record(); :}  
  | OPERATOR RECORD        {: return new OperatorRecord(); :}  
  | OPERATOR FUNCTION      {: return new OperatorFunction(); :}
  | OPERATOR               {: return new Operator(); :}
  ;

Final final_ = 
  FINAL {: return new Final(); :}
  ;
  
Inner inner = 
  INNER {: return new Inner(); :}
  ;
  
 Outer outer = 
  OUTER {: return new Outer(); :}
  ;
   
Replaceable replaceable = 
  REPLACEABLE  {: return new Replaceable(); :}
  ;
    
Redeclare redeclare = 
  REDECLARE  {: return new Redeclare(); :}
  ;  
  
Each each =
  EACH  {: return new Each(); :}
  ;  

    
Composition composition = 
  composition_clauses  external_clause?
               {: return new Composition(composition_clauses,external_clause); :}
  | elements composition_clauses external_clause?
               {: composition_clauses.insertChild(new PublicElementList(elements), 0);
                  return new Composition(composition_clauses, external_clause); :}                             
  ;


List composition_clauses = 
             {: return new List(); :}
  | composition_clause {: return new List().add(composition_clause); :}
  | composition_clauses composition_clause {: return composition_clauses.add(composition_clause); :}
  ;


List elements
    = element {:
        return new List().add(element); 
    :} 
    | elements element {: 
        return elements.add(element);
    :};

Clause composition_clause =  
   PUBLIC                    {: return new PublicElementList(new List()); :}
   | PROTECTED               {: return new ProtectedElementList(new List()); :}
   | PUBLIC elements         {: return new PublicElementList(elements); :}
   | PROTECTED elements      {: return new ProtectedElementList(elements); :}
   | equation_clause         {: return equation_clause; :}
   | algorithm               {: return algorithm; :}
   ;
   
ExternalClause external_clause =
	EXTERNAL
	external_language?
	external_function_call?
	annotation.a1?
	SEMICOLON   {:  return new ExternalClause(external_language, external_function_call, a1); :}
	;

	
ExternalLanguage external_language =
	STRING.s {: return new ExternalLanguage(s); :}
	;	
	
Annotation annotation_sc =
	annotation SEMICOLON {: return annotation; :}
   	;

ExternalFunctionCall external_function_call =
	parse_access EQUALS id_decl LPAREN arg_list RPAREN  
	            {: return new ExternalFunctionCall(new Opt(parse_access), id_decl, arg_list); :}
  | id_decl LPAREN arg_list RPAREN  
                {: return new ExternalFunctionCall(new Opt(), id_decl, arg_list); :}
  ;   	 	
   	  	

	
Element element 
    = 
    redeclare? 
    final_? 
    inner? 
    outer? 
    base_class_decl SEMICOLON {: 
        base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        return base_class_decl;
    :}
    |
    redeclare? 
    final_? 
    inner? 
    outer? 
    replaceable
    base_class_decl
    constraining_clause? 
    comment SEMICOLON {: 
        base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        base_class_decl.setReplaceableOpt(new Opt(replaceable));
        base_class_decl.setConstrainingClauseOpt(constraining_clause);
        base_class_decl.setConstrainingClauseComment(comment);
        return base_class_decl;  
    :}  
    | extends_clause SEMICOLON {: 
        return extends_clause;
    :}
    | import_clause SEMICOLON {: 
        return import_clause;
    :}
    |
    redeclare? 
    final_? 
    inner? 
    outer? 
    type_prefix_flow? 
    type_prefix_variability? 
    type_prefix_input_output? 
    class_access/*name*/ 
    array_subscripts? 
    component_list 
    SEMICOLON {:
        return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            new Opt(),
            new Comment(new Opt(), new Opt()));
  :}
  | redeclare? 
    final_? 
    inner? 
    outer? 
    replaceable 
    type_prefix_flow? 
    type_prefix_variability? 
    type_prefix_input_output? 
    class_access/*name*/ 
    array_subscripts? 
    component_list 
    constraining_clause? 
    comment 
    SEMICOLON {: 
        return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(replaceable),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            constraining_clause,comment); 
  :}
  | error SEMICOLON						  {: return new BadElement(); :}
  ;
  
ConstrainingClause constraining_clause = 
  CONSTRAINEDBY class_access/*name*/ class_modification?{: return new ConstrainingClause(class_access,class_modification); :}
  ;
  
PN_ExtendsClause extends_clause = 
   EXTENDS  class_access/*name*/ class_modification? annotation?    {: return new PN_ExtendsClause(class_access,class_modification,annotation); :}
  ;

ImportClause import_clause = 
  IMPORT 
  qualified_import_access 
  comment {: return new ImportClauseQualified(qualified_import_access,comment); :}
  | IMPORT 
  unqualified_import_access
  comment {: return new ImportClauseUnqualified(unqualified_import_access,comment); :}
  | IMPORT 
  id_decl.alias 
  EQUALS 
  qualified_import_access 
  comment {: return new ImportClauseRename(qualified_import_access,comment,alias); :}
  ;




ArraySubscripts array_subscripts = 
  LBRACK subscript_list RBRACK {: return new ArraySubscripts(subscript_list); :}
  ;
  
List subscript_list =
  subscript               {: return new List().add(subscript); :}
  | subscript_list COMMA subscript {: subscript_list.add(subscript);
                                      return subscript_list; :}
  ;
  
Subscript subscript =
  COLON                 {: return new ColonSubscript(); :}
  | exp                 {: return new ExpSubscript(exp); :}                                                                           
  ;


List component_list = 
  pn_component_decl                    {: return new List().add(pn_component_decl); :}
  | component_list COMMA pn_component_decl           {: component_list.add(pn_component_decl);
                                                      return component_list; :}
  ;
  
PN_ComponentDecl pn_component_decl = 
  id_decl.comp_name array_subscripts? modification? conditional_attribute? comment                   {: return new PN_ComponentDecl(comp_name,array_subscripts,modification,conditional_attribute,comment); :} 
  ;
  
ConditionalAttribute conditional_attribute = 
  IF exp {: return new ConditionalAttribute(exp); :}
  ;  
  
TypePrefix type_prefix_flow = 
    FLOW     {: return new Flow(); :}
  | STREAM   {: return new Stream(); :}
  ;
  
EquationClause equation_clause =
  EQUATION abstract_equation*  {:  return new EquationClause(abstract_equation); :}
  | INITIAL_EQUATION abstract_equation*  {:  //System.out.println("equation_clause"); 
  					     for (int i=0;i<abstract_equation.getNumChild();i++)
  					     	((AbstractEquation)abstract_equation.getChild(i)).setAbstractEquationModifier(new Initial()); 
  					     return new InitialEquationClause(abstract_equation); :}
  ;  

Algorithm algorithm =
  ALGORITHM statement_list            {: return new Algorithm(new Opt(), statement_list); :}
  | INITIAL_ALGORITHM statement_list  {: return new Algorithm(new Opt(new Initial()), 
                                                              statement_list); :}
  ;  

/*
List abstract_equation_list =
                                  {: return new List(); :}
  |abstract_equation                           {: return new List().add(abstract_equation); :}
  | abstract_equation_list abstract_equation  {: abstract_equation_list.add(abstract_equation); 
                                                 return abstract_equation_list; :}
  ;  
*/

List statement_list =
                              {: return new List(); :}
  | statement                 {: return new List().add(statement); :}
  | statement_list statement  {: statement_list.add(statement); 
                                 return statement_list; :}
  ;  

Modification modification =
  complete_modification               {: return complete_modification; :}
  |value_modification               {: return value_modification; :}
//  |assign_modification                 {: return assign_modification; :}  
  ;
  

CompleteModification complete_modification =
  class_modification value_modification?  {: return new CompleteModification(class_modification,value_modification); :}
  ;
  
ValueModification value_modification =
  EQUALS exp  {: return new ValueModification(exp); :}
  | COLON EQUALS exp  {: return new ValueModification(exp); :}
  ;

/*  
AssignModification assign_modification =
  COLON EQUALS exp  {: return new AssignModification(exp); :}
  ;  
  */
  
ClassModification class_modification = 
    LPAREN RPAREN {: return new ClassModification(); :}
  | LPAREN argument_list RPAREN {: return new ClassModification(argument_list); :}
  ;

List argument_list =
    argument                          {: return new List().add(argument); :}
  | argument_list COMMA argument    {: argument_list.add(argument); 
                                       return argument_list; :}
  ;

Argument argument = 
  each? 
  final_? 
  parse_access 
  modification? 
  comment {: return new ComponentModification(each, 
                                                    final_,
                                                    parse_access,
                                                    modification,
                                                    comment); :}
  |each? 
   final_? 
   replaceable 
   base_class_decl 
   constraining_clause? {:  ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
   							pa.setLocationNoTree(base_class_decl.getName());
   							base_class_decl.setConstrainingClauseOpt(constraining_clause);
   							base_class_decl.setReplaceable(replaceable);
   							ClassRedeclare cdr = new ClassRedeclare(each,
                                                         final_,
                                                         pa,
                                                         base_class_decl); 
                            return cdr; :} 
  |each? 
   final_? 
   replaceable 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   constraining_clause? 
   {: 			ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name);
       			PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       			cd.setLocationNoTree(comp_name, comment);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
                                         return cdr; :}
  |REDECLARE 
   each? 
   final_?  
   base_class_decl {: ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
                      pa.setLocationNoTree(base_class_decl.getName());       
                      base_class_decl.setRedeclare(new Redeclare());
                      ClassRedeclare cdr = new ClassRedeclare(each,
                                                              final_,
                                                              pa,
                                                              base_class_decl);
                      return cdr; :}
  |REDECLARE
   each? 
   final_? 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   {: ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name, array_subscripts);
           		PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       			cd.setLocationNoTree(comp_name, comment);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               new Opt(),
                                                               new Comment(new Opt(),new Opt()))); 
                 return cdr; :}
                                                 
  |REDECLARE
   each? 
   final_? 
   replaceable 
   base_class_decl 
   constraining_clause? {:  base_class_decl.setConstrainingClauseOpt(constraining_clause);
                            base_class_decl.setReplaceable(replaceable);
                            base_class_decl.setRedeclare(new Redeclare());
                            ClassAccess ca = new ClassAccess(base_class_decl.getName().getID());
                            ca.setLocationNoTree(base_class_decl.getName());
                             return new  ClassRedeclare(each,
                                                         final_,
                                                         ca,
                                                         base_class_decl); :} 
  |REDECLARE
   each? 
   final_? 
   replaceable 
   type_prefix_flow?
   type_prefix_variability? 
   type_prefix_input_output? 
   class_access 
   id_decl.comp_name 
   array_subscripts? 
   modification? 
   comment
   constraining_clause? 
   {:  ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
       pa.setLocationNoTree(comp_name);
       PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       cd.setLocationNoTree(comp_name, comment);
       PN_ComponentRedeclare cr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
        return cr;                                                       
                                                               :}
   | error				{: return new BadArgument(); :}                                              
   ;

Annotation annotation = 
  annotation_tok class_modification {: annotationTok = null; return new ParseAnnotation(class_modification); :}
  ;  
Symbol annotation_tok =
  ANNOTATION {:
    if (annotationTok != null) {
        getReport().syntaxError(ANNOTATION);
    }
    annotationTok = ANNOTATION;
    return new Symbol(ANNOTATION);
    :}
  ;
   
AbstractEquation abstract_equation =
  exp.left EQUALS exp.right comment SEMICOLON
                                      {: return new Equation(new Opt(),comment,left,right); :}
  | if_equation SEMICOLON             {: return if_equation; :}
  | for_clause_e SEMICOLON            {: return for_clause_e; :}
  | when_equation SEMICOLON           {: return when_equation; :}
  | CONNECT LPAREN parse_access.a COMMA parse_access.b RPAREN comment SEMICOLON
                                      {: return new ConnectClause(new Opt(), comment,a,b); :}
  | LPAREN function_call_left_list RPAREN EQUALS function_call comment SEMICOLON
                                      {: return new FunctionCallEquation(new Opt(),comment,function_call_left_list,function_call); :}
  | function_call comment SEMICOLON   {: return new FunctionCallEquation(new Opt(),comment,new List(),function_call); :}
  ;

List function_call_left_list =
    function_call_left.a COMMA function_call_left.b   {: return new List().add(a).add(b); :}
  | function_call_left_list COMMA function_call_left  {: return function_call_left_list.add(function_call_left); :}
  ;

FunctionCallLeft function_call_left =
                   {: return new FunctionCallLeft(new Opt()); :}
  | parse_access   {: return new FunctionCallLeft(new Opt(parse_access)); :}
  ;

ForClauseE for_clause_e =
  FOR for_indices LOOP
  abstract_equation*
  END_FOR comment   {: return new ForClauseE(new Opt(), comment, for_indices,abstract_equation); :}
  ;


List for_indices = 
  for_index        {: return new List().add(for_index); :}
  | for_indices COMMA for_index {: for_indices.add(for_index);
                                     return for_indices; :}
  ;
  
ForIndex for_index = 
  id_decl for_in_exp? {: ForIndex f = new ForIndex(new ForIndexDecl(new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(new IndexParameter()),
                                                              new Opt(),
                                                              new ParseAccess("Integer",new Opt()),
                                                              new Opt(),
                                                              new PublicVisibilityType(),
                                                              id_decl,
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt()),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt())),
                                                   for_in_exp); 
                          f.setLocationNoTree(id_decl, for_in_exp); 
                          return f; :}
  ;

Exp for_in_exp =
  IN exp.e {: return e; :}
  ;

WhenEquation when_equation =
  WHEN exp.test THEN
  abstract_equation*
  else_when_equation?
  END_WHEN comment     {: return new WhenEquation(new Opt(), 
                                                  comment, 
                                                  abstract_equation,
                                                  test, 
                                                  else_when_equation); 
                       :}
  ;  

WhenEquation else_when_equation =
  ELSEWHEN exp.test THEN
  abstract_equation* 
  else_when_equation?     {: return new WhenEquation(new Opt(), 
                                                     new Comment(), 
                                                     abstract_equation, 
                                                     test, 
                                                     else_when_equation); 
                          :}
  ;

IfEquation if_equation =
  IF exp.test THEN
  abstract_equation*
  else_if_equation?
  END_IF comment      {: return new IfEquation(new Opt(), 
                                               comment, 
                                               abstract_equation, 
                                               test, 
                                               else_if_equation); 
                      :}
  ;  

IfWhenElseEquation else_if_equation =
    ELSEIF exp.test THEN
    abstract_equation* 
    else_if_equation?        {: return new IfEquation(new Opt(), 
                                                      new Comment(), 
                                                      abstract_equation, 
                                                      test, 
                                                      else_if_equation); 
                             :}
  | ELSE abstract_equation*  {: return new ElseEquation(new Opt(), 
                                                        new Comment(), 
                                                        abstract_equation); 
                             :}
  ;


Statement statement =
  parse_access.left ASSIGN exp.right comment SEMICOLON                  
                                     {: return new AssignStmt(comment, left, right); :}
  | function_call_stmt SEMICOLON     {: return function_call_stmt; :}
  | BREAK comment SEMICOLON          {: return new BreakStmt(comment); :} 
  | RETURN comment SEMICOLON         {: return new ReturnStmt(comment); :}
  | if_stmt SEMICOLON                {: return if_stmt; :}
  | when_stmt SEMICOLON              {: return when_stmt; :}
  | for_stmt SEMICOLON               {: return for_stmt; :}
  | while_stmt SEMICOLON             {: return while_stmt; :}
  | error                            {: return new BadStatement(); :}
  ;
  
FunctionCallStmt function_call_stmt =
    LPAREN function_call_stmt_left_list RPAREN ASSIGN function_call comment  
                           {: return new FunctionCallStmt(comment, function_call_stmt_left_list, function_call); :}
  | function_call comment  {: return new FunctionCallStmt(comment, new List(), function_call); :}
  ;

List function_call_stmt_left_list =
    function_call_stmt_left   {: return new List().add(function_call_stmt_left); :}
  | function_call_stmt_left_list COMMA function_call_stmt_left  {: return function_call_stmt_left_list.add(function_call_stmt_left); :}
  ;

FunctionCallLeft function_call_stmt_left =
                   {: return new FunctionCallLeft(new Opt()); :}
  | parse_access   {: return new FunctionCallLeft(new Opt(parse_access)); :}
  ;

IfStmt if_stmt =
    IF if_clause_list else_stmts END_IF comment {: return new IfStmt(comment, if_clause_list, new Opt(else_stmts)); :}
  | IF if_clause_list END_IF comment {: return new IfStmt(comment, if_clause_list, new Opt()); :}
  ;  

List if_clause_list =
    if_clause                        {: return new List().add(if_clause); :}
  | if_clause_list ELSEIF if_clause  {: return if_clause_list.add(if_clause); :}
  ;

IfClause if_clause =
  exp THEN statement_list  {: return new IfClause(exp, statement_list); :}
  ;

ElseClause else_stmts =
  ELSE statement_list  {: return new ElseClause(statement_list); :}
  ;

WhenStmt when_stmt =
  WHEN when_clause_list END_WHEN comment {: return new WhenStmt(comment, when_clause_list); :}
  ;  

List when_clause_list =
    when_clause                            {: return new List().add(when_clause); :}
  | when_clause_list ELSEWHEN when_clause  {: return when_clause_list.add(when_clause); :}
  ;

WhenClause when_clause =
  exp THEN statement_list  {: return new WhenClause(exp, statement_list); :}
  ;

ForStmt for_stmt =
  FOR for_indices LOOP for_stmt_list END_FOR comment  
                         {: return new ForStmt(comment, for_indices, for_stmt_list); :}
  ;
  
ForStmtList for_stmt_list =
  statement_list {: return new ForStmtList(statement_list); :}
  ;

WhileStmt while_stmt = 
  WHILE exp LOOP statement_list END_WHILE comment  {: return new WhileStmt(comment, exp, statement_list); :}
  ;
  
Exp exp =
  simple_expression {: return simple_expression; :}
  | if_exp           {: return if_exp; :}
  ;

IfExp if_exp =
  IF exp.ifexp THEN exp.thenexp else_if_exp 
  		{: return new IfExp(ifexp, thenexp, else_if_exp); :}
  ;  

Exp else_if_exp =
   ELSEIF exp.ifexp THEN exp.thenexp else_if_exp 
		{: return new IfExp(ifexp, thenexp, else_if_exp); :}
 | ELSE exp   {: return exp; :}
  ;

Exp simple_expression = 
    log_exp 
        {: return log_exp; :}
  | log_exp.l1 COLON log_exp.l2
        {: RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           return r; :}
  | log_exp.l1 COLON log_exp.l2 COLON log_exp.l3
        {: RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           r.addExp(l3);
           return r; :}
  ;

Exp log_exp = 
  log_exp.a OR log_exp.b {: return new OrExp(a,b); :}  
  | log_exp.a AND log_exp.b {: return new AndExp(a,b); :}  
  | NOT relation.a {: return new NotExp(a); :}  
  | relation {: return relation; :}
;

Exp relation =
  artm_exp.a LT artm_exp.b {: return new LtExp(a,b); :}
  | artm_exp.a LEQ artm_exp.b {: return new LeqExp(a,b); :}
  | artm_exp.a GT artm_exp.b {: return new GtExp(a,b); :}
  | artm_exp.a GEQ artm_exp.b {: return new GeqExp(a,b); :}
  | artm_exp.a EQ artm_exp.b {: return new EqExp(a,b); :}
  | artm_exp.a NEQ artm_exp.b {: return new NeqExp(a,b); :}
  | artm_exp.a {: return a; :}	
  ;
  
  
  Exp artm_exp =
   additive_exp {: return additive_exp; :}
   ;

  Exp additive_exp =
     multiplicative_exp.e    {: return e; :}
   | additive_exp.e1 PLUS multiplicative_exp.e2      {: return new AddExp(e1, e2); :}
   | additive_exp.e1 MINUS multiplicative_exp.e2     {: return new SubExp(e1, e2); :}
   | additive_exp.e1 DOTPLUS multiplicative_exp.e2   {: return new DotAddExp(e1, e2); :}
   | additive_exp.e1 DOTMINUS multiplicative_exp.e2  {: return new DotSubExp(e1, e2); :}
   ;

  Exp multiplicative_exp =
     unary_exp.e                                     {: return e; :}
   | multiplicative_exp.e1 MULT unary_exp.e2     {: return new MulExp(e1, e2); :}
   | multiplicative_exp.e1 DIV unary_exp.e2      {: return new DivExp(e1, e2); :}
   | multiplicative_exp.e1 DOTMULT unary_exp.e2  {: return new DotMulExp(e1, e2); :}
   | multiplicative_exp.e1 DOTDIV unary_exp.e2   {: return new DotDivExp(e1, e2); :} 
   ;


Exp unary_exp =
   pow_exp          {: return pow_exp; :}
   | MINUS unary_exp       {: return new NegExp(unary_exp); :}
   | PLUS unary_exp        {: return unary_exp; :}
   ;

Exp pow_exp =
    primary {:return primary; :}
    | primary.a POW primary.e    {: return new PowExp(a,e); :}
    | primary.a DOTPOW primary.e {: return new DotPowExp(a,e); :}
    ;

Exp primary =        
   UNSIGNED_NUMBER.n    {: return new RealLitExp(n); :}
  | UNSIGNED_INTEGER.n    {: return new IntegerLitExp(n); :}
  | TRUE                {: return new BooleanLitExpTrue(); :}
  | FALSE                {: return new BooleanLitExpFalse(); :}
  | STRING.s               {: return new StringLitExp(s); :}
  | access_expression   {: return access_expression; :}
  | der_expression      {: return der_expression; :}
  | LPAREN exp.a RPAREN {: formattingRecorder.addItem(FormattingType.PARENTHESIS, "(", LPAREN);
                           formattingRecorder.addItem(FormattingType.PARENTHESIS, ")", RPAREN);
                           return a; :}
  | function_call        {: return function_call; :}
  | LBRACK matrix RBRACK {: return matrix; :}
  | LBRACE function_arguments RBRACE {: return new ArrayConstructor(function_arguments); :}
  | TIME                {: return new TimeExp(); :}
  | END                 {: return new EndExp(); :} 
  ;
 
 FunctionCall function_call =
    parse_access LPAREN function_arguments? RPAREN 
                                      {: return new FunctionCall(parse_access, function_arguments); :}
  ;
  
 PartialFunctionCall partial_function_call =
    FUNCTION parse_access LPAREN function_arguments_named? RPAREN
                                      {: return new PartialFunctionCall(parse_access, function_arguments_named); :}
    | FUNCTION parse_access
                                      {: return new PartialFunctionCall(parse_access, new Opt()); :}
  ;
  
FunctionArguments function_arguments =
    exp FOR for_indices               {: List arg_list_f = new List().add(new IterExp(exp, for_indices));
                                         return new FunctionArguments(arg_list_f, new List()); :} 
  | arg_list_p                        {: return new FunctionArguments(arg_list_p, new List()); :}  
  | arg_list_p COMMA named_arguments  {: return new FunctionArguments(arg_list_p, named_arguments); :}
  | function_arguments_named
  ;
  
FunctionArguments function_arguments_named =
  named_arguments {: return new FunctionArguments(new List(), named_arguments); :}
  ;
  
List named_arguments =
    named_argument                       {: return new List().add(named_argument); :}
  | named_arguments COMMA named_argument {: return named_arguments.add(named_argument); :}
  ;
  
Exp function_argument_exp =
 exp                               {: return exp; :}
 | partial_function_call          {: return partial_function_call; :}  
 ;
  
NamedArgument named_argument =
  named_argument_id EQUALS function_argument_exp {: return new NamedArgument(named_argument_id,function_argument_exp); :}
  ;

Access named_argument_id = 
  ID.id {: return new ParseAccess(id, new Opt()); :}
  ;

Matrix matrix = 
    matrix_row                   {: return new Matrix(new List().add(matrix_row)); :}
  | matrix SEMICOLON matrix_row  {: matrix.addRow(matrix_row); 
                                    return matrix; :}      
  ;  
  
MatrixRow matrix_row = 
    exp                   {: return new MatrixRow(new List().add(exp)); :}
  | matrix_row COMMA exp  {: matrix_row.addExp(exp); 
                             return matrix_row; :}
  ; 
  
List arg_list = 
                        {: return new List(); :}
  | exp                 {: return new List().add(exp); :}
  | arg_list COMMA exp  {: arg_list.add(exp); 
                           return arg_list; :}
  ;
  
List arg_list_p = 
  function_argument_exp                   {: return new List().add(function_argument_exp); :}
  | arg_list_p COMMA function_argument_exp  {: return arg_list_p.add(function_argument_exp); :}
  ;
  
Comment comment = 
  string_comment?  annotation?     {: return new Comment(string_comment,annotation); :}
  ;
  
StringComment string_comment =
  STRING.s      {: return new StringComment(s); :}
  | string_comment PLUS STRING.s {: string_comment.setComment(string_comment.getComment().concat(s));
                                    return string_comment; :}
  
  ;
 
 IdDecl id_decl = 
   ID.id   {: return new IdDecl(id); :}
 ;

 AccessExp access_expression =
   parse_access {: return new AccessExp(parse_access); :}
 ;

 DerExp der_expression = 
   DER LPAREN exp RPAREN  {: return new DerExp(exp); :}
 ;

 Access parse_access = 
   parse_access_loc        {: return parse_access_loc; :}
 | DOT first_class_access  {: return new GlobalAccess(first_class_access); :}
 ;
 
 Access parse_access_loc = 
   parse_access_single   {: return parse_access_single; :}
 | parse_access_single DOT parse_access_loc 
   			             {: return new PN_Dot(parse_access_single, parse_access_loc); :}
 ;
 
 Access first_class_access =
   class_access_single  {: return class_access_single; :}
 | class_access_single DOT parse_access_loc  
 						{: return new PN_Dot(class_access_single, parse_access_loc); :}
 ;
 
 ParseAccess parse_access_single = 
   ID.id  array_subscripts? {: return new ParseAccess(id, array_subscripts); :}
 ;   
 
 ParseAccess parse_access_single_simple = 
   ID.id  {: return new ParseAccess(id, new Opt()); :}
 ;      

   
 Access qualified_import_access = 
   qualified_import_access_loc      {: return qualified_import_access_loc; :}
 | DOT qualified_import_access_loc  {: return new GlobalAccess(qualified_import_access_loc); :}
 ;
 
 Access qualified_import_access_loc = 
   qualified_import_access_rec
            {: return qualified_import_access_rec; :}
 | class_access_single
            {: return class_access_single; :}
 ;
 
 Access qualified_import_access_rec = 
   class_access_single DOT parse_access_single_simple  
   			{: return new PN_Dot(class_access_single, parse_access_single_simple); :}
 | class_access_single DOT qualified_import_access_rec 
   			{: return new PN_Dot(class_access_single, qualified_import_access_rec); :}
 ;

 
 Access unqualified_import_access =
   class_access DOTMULT   {: return class_access; :}
 ;
 
 
 Access class_access = 
   class_access_loc      {: return class_access_loc; :}
 | DOT class_access_loc  {: return new GlobalAccess(class_access_loc); :}
 ;
 
 Access class_access_loc = 
   class_access_single                      {: return class_access_single; :}
 | class_access_single DOT class_access_loc {: return new PN_Dot(class_access_single, class_access_loc); :}
 ;    
  
 ClassAccess class_access_single = 
   ID.id  {: return new ClassAccess(id); :}
 ;
   
 EndDecl end_decl =
   END_ID {: String value = (String) END_ID.value;
             String id = value.substring(3, value.length()).trim();
             return new EndDecl(id); :}
 ;