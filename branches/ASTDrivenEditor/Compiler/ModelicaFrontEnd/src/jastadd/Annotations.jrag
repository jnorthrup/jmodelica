/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.NoSuchElementException;

import org.jmodelica.util.ChainedIterator;

aspect AnnotationAPI {
	
	/**
	 * \brief Get the annotation node for this AST node's annotation, if any.
	 * 
	 * This should be overridden for all nodes that can have annotations.
	 */
	syn AnnotationNode ASTNode.annotation() = AnnotationNode.NO_ANNOTATION;
	
	/**
	 * \brief Get the annotation node for a sub-node of this AST node's annotation, if any.
	 * 
	 * Path is interpreted as a "/"-separated list of names of nested annotations.
	 * 
	 * Example:
	 * <code>annotation(A(B(C = "foo")));</code>
	 * Here the annotation given by the path <code>"A/B/C"</code> has the value <code>"foo"</code>.
	 */
	syn AnnotationNode ASTNode.annotation(String path) = annotation().forPath(path);
	
	eq Opt.annotation()  = (getNumChild() > 0) ? getChild(0).annotation() : AnnotationNode.createNullAnnotationNodeFor(this);
	eq List.annotation() = (getNumChild() > 0) ? getChild(0).annotation() : AnnotationNode.createNullAnnotationNodeFor(this);
	
	eq Comment.annotation()         = getAnnotationOpt().annotation();
	eq ParseAnnotation.annotation() = getClassModification().annotationNode();
	
	eq ExternalClause.annotation() = getAnnotation1Opt().annotation();
	eq InstExternal.annotation()   = getExternalClause().annotation();
	
	eq FullClassDecl.annotation()           = getAnnotations().annotation();
	eq InstClassDecl.annotation()           = getClassDecl().annotation();
	eq ShortClassDecl.annotation()          = getExtendsClauseShortClass().annotation();
	eq ExtendsClauseShortClass.annotation() = getComment().annotation();
	eq InstShortClassDecl.annotation()      = getClassDecl().annotation();

	eq ConnectClause.annotation() = getComment().annotation();

	eq ComponentDecl.annotation()     = getComment().annotation();
	eq InstComponentDecl.annotation() = getComponentDecl().annotation();
	
	
	/**
	 * Get the annotation node that represents this node when used as an annotation, if 
	 * applicable.
	 */
	syn AnnotationNode ASTNode.annotationNode()            = AnnotationNode.createNullAnnotationNodeFor(this);
	syn lazy AnnotationNode Modification.annotationNode()  = AnnotationNode.createNullAnnotationNodeFor(this);
	eq ClassModification.annotationNode()                  = new CMAnnotationNode(this);
	eq ValueModification.annotationNode()                  = new VMAnnotationNode(this);
	eq CompleteModification.annotationNode()               = getClassModification().annotationNode();
	eq ComponentModification.annotationNode()              = 
		hasModification() ? getModification().annotationNode() : AnnotationNode.createNullAnnotationNodeFor(this);
	syn lazy AnnotationNode Exp.annotationNode()           = new EAnnotationNode(this);
	eq FunctionCall.annotationNode()                       = new FCAnnotationNode(this);
	syn lazy AnnotationNode NamedArgument.annotationNode() = new NAAnnotationNode(this);
	
	/**
	 * \brief Describes a node in the tree formed by an annotation.
	 */
	public abstract class AnnotationNode implements Iterable<AnnotationNode> {
		
		/**
		 * \brief Represents an annotation that does not exist.
		 */
		public static final AnnotationNode NO_ANNOTATION = new NullAnnotationNode();
		
		/**
		 * \brief Finds an annotation node at the given path below this one.
		 */
		public AnnotationNode forPath(String path) {
			return forPath(path.split("/"), 0);
		}
		
		/**
		 * \brief Internal definition of {@link #forPath(String)}.
		 * 
		 * @param path  the path elements to find
		 * @param i     the first index in <code>path</code> to use
		 */
		protected AnnotationNode forPath(String[] path, int i) {
			if (i >= path.length)
				return this;
			return NO_ANNOTATION;
		}
		
		/**
		 * Check if this annotation node represents a value node.
		 */
		public boolean isValue() {
			return false;
		}
		
		/**
		 * \brief Checks if this annotation node represents an existing annotation.
		 */
		public boolean exists() {
			return true;
		}
		
		/**
		 * Get the name associated with this annotation node, if any.
		 * 
		 * In general, any node reachable with a call to forPath() will have a name.
		 * 
		 * @return the name or <code>null</code>, if no name is available
		 */
		public String name() {
			return null;
		}
		
		/**
		 * Iterate over this node's child annotation nodes.
		 */
		public Iterator<AnnotationNode> iterator() {
			return NO_ANNOTATION.iterator();
		}
		
		/**
		 * \brief Returns the value for a node that represents a string value.
		 */
		public String string() {
			return null;
		}
		
		/**
		 * Returns the value for a node that represents a string value, interpreted as 
		 * a path of an URI (with protocol file or modelica). A simple path is also 
		 * supported, and is interpreted relative to the top containing package, or if 
		 * that does not exist, relative to the directory containing the current file.
		 */
		public String path() {
			return ast().uri2path(string());
		}
		
		/**
		 * \brief Returns the value for a node that represents a list of strings.
		 */
		public ArrayList<String> stringList() {
			return null;
		}
		
		/**
		 * \brief Returns the value for a node that represents a list of strings, 
		 *        or a single string value.
		 */
		public ArrayList<String> asStringList() {
			ArrayList<String> res = stringList();
			if (res == null) {
				String str = string();
				if (str != null) {
					res = new ArrayList(1);
					res.add(str);
				}
			}
			return res;
		}
		
		/**
		 * \brief Returns the value for a node that represents a real value.
		 */
		public double real() {
			return 0.0;
		}
		
		/**
		 * \brief Returns the value for a node that represents a vector of real values.
		 */
		public double[] realVector() {
			return null;
		}
		
		/**
		 * \brief Returns the value for a node that represents a matrix of real values.
		 */
		public double[][] realMatrix() {
			return null;
		}
		
		/**
		 * Returns the value for a node that represents a boolean value.
		 */
		public boolean bool() {
			return false;
		}
		
		/**
		 * Returns the ast node that this annotation node is connected to.
		 */
		protected abstract ASTNode ast();
		
		/**
		 * Set the expression <code>exp</code> of the node if possible.
		 * 
		 * @param exp Expresion to add.
		 */
		public void setValue(Exp exp) {
			throw new AnnotationEditException("Set value is not supported on this type of annotation node");
		}
		
		/**
		 * Adds a node with the name <code>name</code> to this node if possible.
		 * 
		 * @param name Name of the new node.
		 * @return An annotation node representation of the new node.
		 */
		public AnnotationNode addNode(String name) {
			throw new AnnotationEditException("Add node is not supported on this type of annotation node");
		}
		
		/**
		 * A helper method that creates the corrent null annotation node depending on
		 * the class of AST node <code>node</node>.
		 * 
		 * @param node The ast node that need a null annotation node.
		 * @return A null annotation node for <code>node</code>.
		 */
		public static AnnotationNode createNullAnnotationNodeFor(ASTNode node) {
			if (node.getParent() instanceof Comment)
				return new NullCommentAnnotationNode((Comment)node.getParent());
			return NO_ANNOTATION;
		}
		
		/**
		 * A helper method that creatse a list of editable null annotation nodes
		 * from a path <code>path</code> starting at position <code>i</code> 
		 * with the root parent <code>parent</code>.
		 * 
		 * @param parent The root annotation node
		 * @param path The string path
		 * @param i The position from where to start creating the list
		 * @return The tail child in the list
		 */
		protected static AnnotationNode createSetableNullPath(AnnotationNode parent, String[] path, int i) {
			AlmostNullAnnotationNode node = new AlmostNullAnnotationNode(parent, path[i]);
			if (i + 1 == path.length)
				return node;
			else
				return createSetableNullPath(node, path, i + 1);
		}
		/**
		 * Iterates over the annotation nodes representing the nodes in the list.
		 */
		protected static class AnnotationIterator implements Iterator<AnnotationNode> {
			private Iterator<? extends ASTNode> it;
			private AnnotationNode next;
			
			public AnnotationIterator(Iterator<? extends ASTNode> it) {
				this.it = it;
				update();
			}
			
			public AnnotationIterator(Iterable<? extends ASTNode> list) {
				this(list.iterator());
			}
			
			public boolean hasNext() {
				return next.exists();
			}
			
			public AnnotationNode next() {
				if (!hasNext())
					throw new NoSuchElementException();
				AnnotationNode res = next;
				update();
				return res;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
			private void update() {
				next = NO_ANNOTATION;
				while (it.hasNext() && !next.exists()) 
					next = it.next().annotationNode();
			}
		}
		
		/**
		 * \brief Represents a non-existing annotation.
		 */
		private static class NullAnnotationNode extends AnnotationNode {
			private static final Iterator<AnnotationNode> EMPTY_ITERATOR = 
				new ArrayList<AnnotationNode>().iterator();
			
			public Iterator<AnnotationNode> iterator() {
				return EMPTY_ITERATOR;
			}
			
			public boolean exists() {
				return false;
			}
			
			public String path() {
				return null;
			}

			protected ASTNode ast() {
				return null;
			}
			
		}
		
		/**
		 * Representation a non-existing annotation but with the possibility to add content.
		 */
		private static class AlmostNullAnnotationNode extends AnnotationNode {
			
			private AnnotationNode parent;
			protected AnnotationNode realNode;
			private String name;
			
			/**
			 * Creates an instance form a parent annotation node <code>parent</code> and
			 * the path name <code>name</code> of this instance. 
			 */
			protected AlmostNullAnnotationNode(AnnotationNode parent, String name) {
				this.parent = parent;
				this.name = name;
			}
			
			@Override
			public void setValue(Exp exp) {
				AnnotationNode parentNode = getRealParent();
				if (parentNode instanceof CMAnnotationNode) {
					for (Argument arg : ((CMAnnotationNode) parentNode).ast().getArguments()) {
						if (!arg.matches(name))
							continue;
						AnnotationNode realNode = arg.annotation();
						if (realNode instanceof VMAnnotationNode)
							realNode.setValue(exp);
						else
							throw new AnnotationEditException("The node with name " + name + " is already set and is not an assignment.");
						return;
					}
					
					ValueModification vm = new ValueModification(exp);
					((CMAnnotationNode) parentNode).ast().addArgument(new ComponentModification(new ParseAccess(name), vm));
					realNode = new VMAnnotationNode(vm);
					return;
				} else {
					throw new AnnotationEditException("Unable to set node value.");
				}
			}
			
			/**
			 * Creates the real annotation node representation of this node including the
			 * underlying modifications or expressions.
			 */
			protected void createRealNode() {
				if (realNode != null)
					return;
				
				AnnotationNode parentNode = getRealParent();
				
				if (parentNode instanceof CMAnnotationNode) {
					for (Argument arg : ((CMAnnotationNode) parentNode).ast().getArguments()) {
						if (!arg.matches(name))
							continue;
						realNode = arg.annotation();
						return;
					}
					
					ClassModification cm = new ClassModification();
					((CMAnnotationNode) parentNode).ast().addArgument(new ComponentModification(new ParseAccess(name), new CompleteModification(cm)));
					realNode = new CMAnnotationNode(cm);
					return;
				} else {
					throw new AnnotationEditException("Unable to create node.");
				}
			}
			
			/**
			 * Retreives the real parent annotation node for this instance.
			 * 
			 * @return The real annotation node.
			 */
			private AnnotationNode getRealParent() {
				AnnotationNode parentRealNode = parent;
				if (parentRealNode instanceof AlmostNullAnnotationNode) {
					((AlmostNullAnnotationNode) parent).createRealNode();
					parentRealNode = ((AlmostNullAnnotationNode) parent).realNode;
				}
				return parentRealNode;
			}
			
			@Override
			protected AnnotationNode forPath(String[] path, int i) {
				if (realNode != null)
					return realNode.forPath(path, i);
				
				if (i >= path.length)
					return this;
				return createSetableNullPath(this, path, i);
			}
			
			@Override
			protected ASTNode ast() {
				if (realNode != null)
					return realNode.ast();
				else
					return null;
			}
			
		}
		
		/**
		 * A null annotation node for a comment, it adds the possibility to add annotation.
		 */
		private static class NullCommentAnnotationNode extends AlmostNullAnnotationNode {
			
			private Comment comment;
			
			/**
			 * Constructs an instance with the comment <code>comment</code>.
			 */
			protected NullCommentAnnotationNode(Comment comment) {
				super(null, null);
				this.comment = comment;
			}
			
			@Override
			public void setValue(Exp exp) {
				throw new AnnotationEditException("Set value is not supported on this type of annotation node");
			}
		
			@Override
			protected void createRealNode() {
				ClassModification cm = new ClassModification();
				comment.setAnnotation(new ParseAnnotation(cm));
				realNode = new CMAnnotationNode(cm);
			}
		
		}
		
	}
	
	/**
	 * \brief Represents an annotation that is represented in the source tree by a ClassModification.
	 */
	public class CMAnnotationNode extends AnnotationNode {
		
		private ClassModification mod;
		
		public CMAnnotationNode(ClassModification cm) {
			mod = cm;
		}

		public Iterator<AnnotationNode> iterator() {
			return new AnnotationIterator(mod.getArguments());
		}
		
		public String name() {
			return mod.annotationName();
		}
		
		protected AnnotationNode forPath(String[] path, int i) {
			if (i >= path.length)
				return this;
			for (Argument arg : mod.getArguments()) 
				if (arg.matches(path[i])) 
					return arg.annotationNode().forPath(path, i+1);
			return createSetableNullPath(this, path, i);
		}

		protected ClassModification ast() {
			return mod;
		}

	}
	
	/**
	 * \brief Represents an annotation that is represented in the source tree by a FunctionCall.
	 */
	public class FCAnnotationNode extends AnnotationNode {
		
		private FunctionCall call;
		
		public FCAnnotationNode(FunctionCall fc) {
			call = fc;
		}

		public Iterator<AnnotationNode> iterator() {
			return new AnnotationIterator(new ChainedIterator(
					call.getFunctionArguments().getExps().iterator(), 
					call.getFunctionArguments().getNamedArguments().iterator()));
		}
		
		public String name() {
			return call.getName().name();
		}
		
		protected AnnotationNode forPath(String[] path, int i) {
			if (i >= path.length)
				return this;
			for (NamedArgument arg : call.getFunctionArguments().getNamedArguments()) 
				if (arg.matches(path[i])) 
					return arg.annotationNode().forPath(path, i+1);
			return NO_ANNOTATION;
		}
		
		protected ASTNode ast() {
			return call;
		}
		
	}
	
	abstract class ExpAnnotationNode extends AnnotationNode {
		
		protected abstract Exp exp();
		
		public String string() {
			return exp().avalueString();
		}

		public boolean isValue() {
			return !exp().isAnnotationExp();
		}
		
		public ArrayList<String> stringList() {
			return exp().avalueStringList();
		}

		public Iterator<AnnotationNode> iterator() {
			return isValue() ? super.iterator() : new AnnotationIterator(exp().annotationList());
		}
		
		public double real() {
			return exp().avalueReal();
		}
		
		public double[] realVector() {
			return exp().avalueRealVector();
		}
		
		public double[][] realMatrix() {
			return exp().avalueRealMatrix();
		}

		public boolean bool() {
			return exp().avalueBool();
		}
		
		protected ASTNode ast() {
			return exp();
		}

	}
	
	/**
	 * \brief Represents an annotation that is represented in the source tree by a ValueModification.
	 */
	public class VMAnnotationNode extends ExpAnnotationNode {
		
		private ValueModification mod;
		
		public VMAnnotationNode(ValueModification vm) {
			mod = vm;
		}
		
		protected Exp exp() {
			return mod.getExp();
		}
		
		public String name() {
			return mod.annotationName();
		}
		
		public void setValue(Exp exp) {
			mod.setExp(exp);
		}
		
	}
	
	/**
	 * \brief Represents an annotation that is represented in the source tree by a NamedArgument.
	 */
	public class NAAnnotationNode extends ExpAnnotationNode {
		
		private NamedArgument arg;
		
		public NAAnnotationNode(NamedArgument na) {
			arg = na;
		}
		
		protected Exp exp() {
			return arg.getExp();
		}
		
		public String name() {
			return arg.getName().name();
		}
		
	}
	
	/**
	 * \brief Represents an annotation that is represented in the source tree by an Exp.
	 */
	public class EAnnotationNode extends ExpAnnotationNode {
		
		private Exp e;
		
		public EAnnotationNode(Exp exp) {
			e = exp;
		}
		
		protected Exp exp() {
			return e;
		}
		
	}
	
	/**
	 * A runtime exception that is thrown when an action fail while trying
	 * to alter an annotation node and it's underlying structure.
	 */
	public class AnnotationEditException extends RuntimeException {
		
		/**
		 * Constructs an instance from a string <code>s</code>.
		 * 
		 * @param s A string explaining the exception
		 */
		public AnnotationEditException(String s) {
			super(s);
		}
		
		/**
		 * Constructs an instance from a string <code>s</code> and exception
		 * <code>e</code>.
		 * 
		 * @param s A string explaining the exception
		 * @param e An exception that caused this exception
		 */
		public AnnotationEditException(String s, Exception e) {
			super(s, e);
		}
	}
	
	syn boolean Argument.matches(String str) = false;
	eq NamedModification.matches(String str) = getName().name().equals(str);
	
	syn boolean NamedArgument.matches(String str) = getName().name().equals(str);
	
	inh String Modification.annotationName();
	eq NamedModification.getChild().annotationName()    = getName().name();
	eq CompleteModification.getChild().annotationName() = annotationName();
	eq BaseNode.getChild().annotationName()             = null;
	
	syn String Exp.avalueString()  = null;
	eq StringLitExp.avalueString() = unEscape();
	eq AccessExp.avalueString()    = getAccess().name();
	
	syn ArrayList<String> Exp.avalueStringList() = null;
	eq ArrayConstructor.avalueStringList() {
		ArrayList<String> l = new ArrayList<String>(getFunctionArguments().getNumExp());
		for (Exp e : getFunctionArguments().getExps())
			l.add(e.avalueString());
		return l.contains(null) ? null : l;
	}
	
	syn boolean Exp.avalueBool()      = false;
	eq BooleanLitExpTrue.avalueBool() = true;
	
	syn double Exp.avalueReal()   = 0.0;
	eq IntegerLitExp.avalueReal() = (double) Integer.parseInt(getUNSIGNED_INTEGER());
	eq RealLitExp.avalueReal()    = Double.parseDouble(getUNSIGNED_NUMBER());
	eq NegExp.avalueReal()        = -getExp().avalueReal();
	
	syn double[] Exp.avalueRealVector() = null;
	eq ArrayConstructor.avalueRealVector() {
		if (adim() != 1)
			return null;
		double[] res = new double[getFunctionArguments().getNumExp()];
		int i = 0;
		for (Exp e : getFunctionArguments().getExps())
			res[i++] = e.avalueReal();
		return res;
	}
	
	syn double[][] Exp.avalueRealMatrix() = null;
	eq ArrayConstructor.avalueRealMatrix() {
		if (adim() != 2)
			return null;
		double[][] res = new double[getFunctionArguments().getNumExp()][];
		int i = 0;
		for (Exp e : getFunctionArguments().getExps())
			res[i++] = e.avalueRealVector();
		return res;
	}
	
	syn int Exp.adim()         = 0;
	eq ArrayConstructor.adim() = 
		getFunctionArguments().getNumExp() > 0 ? getFunctionArguments().getExp(0).adim() + 1 : 1;
		
	syn boolean Exp.isFunctionCall() = false;
	eq FunctionCall.isFunctionCall() = true;
	
	syn boolean Exp.isAnnotationExp()     = false;
	eq FunctionCall.isAnnotationExp()     = true;
	eq ArrayConstructor.isAnnotationExp() = 
		getFunctionArguments().getNumExp() > 0 && getFunctionArguments().getExp(0).isFunctionCall();
		
	syn Iterable<? extends ASTNode> Exp.annotationList() = new ArrayList<ASTNode>(0);
	eq ArrayConstructor.annotationList()                 = getFunctionArguments().getExps();
	eq FunctionCall.annotationList()                     = Collections.singletonList(this);
	
}

