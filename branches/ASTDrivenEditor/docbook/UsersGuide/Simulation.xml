<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch_simulation"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Simulation</title>

  <section>
    <title>Introduction</title>

    <para>JModelica.org supports simulation of models described in the
    Modelica language and models following the FMI standard see <xref
    linkend="ch_fmi" />. The simulation environment uses <link
    linkend="???"><link
    xlink:href="http://www.jmodelica.org/assimulo">Assimulo</link></link> as
    standard which is a standalone Python package for solving ordinary
    differential and differential algebraic equations.</para>
  </section>

  <section>
    <title xml:id="sim_sec_first">A first example</title>

    <para>This example focuses on how to use JModelica.org's simulation
    functionality in the most basic way. The model which is to be simulated is
    the Van der Pol problem described in the code below. The model is also
    available from the examples in JModelica.org in the file VDP.mop.</para>

    <programlisting language="modelica" xml:id="sim_list_vdp">model VDP
    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0);
    Real x2(start = x2_0);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
  end VDP;
</programlisting>

    <para>Create a new file in your working directory called
    <literal>VDP.mo</literal> and save the model.</para>

    <para>Next, create a Python script file and write or (copy paste) the
    commands for compiling and loading a model:</para>

    <programlisting language="python"># Import the function for compilation of models and the FMUModel class
from jmodelica import compile_fmu
from pyfmi import FMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

    <para>Next, we compile and load the model:</para>

    <programlisting language="python"># Compile model
fmu_name = compile_fmu("VDP","VDP.mo")

# Load model
vdp = FMUModel(fmu_name)
</programlisting>

    <para>The function <literal>compile_fmu</literal> compiles the model into
    a binary, which is then loaded when the <literal>vdp</literal> object is
    created. This object represents the compiled model, an FMU, and is used to
    invoke the simulation algorithm (for more information about model
    creations and options, see <xref linkend="ch_models" />):</para>

    <programlisting language="python">res = vdp.simulate(final_time=10)
</programlisting>

    <para>In this case we use the default simulation algorithm together with
    default options, except for the final time which we set to 10. The result
    object can now be used to access in a dictionary-like way the simulation
    result:</para>

    <programlisting language="python">x1 = res['x1']
x2 = res['x2']
t  = res['time']
</programlisting>

    <para>The variable trajectories are returned as numpy arrays and can be
    used for further analysis of the simulation result or for
    visualization:</para>

    <programlisting language="python">plt.figure(1)
plt.plot(t, x1, t, x2)
plt.legend(('x1','x2'))
plt.title('Van der Pol oscillator.')
plt.ylabel('Angle (rad)')
plt.xlabel('Time (s)')
plt.show()
</programlisting>

    <para>In <xref linkend="sim_fig_vdp_res" /> the simulation result is
    shown.</para>

    <figure xml:id="sim_fig_vdp_res">
      <title>Simulation result of the Van der Pol oscillator.</title>

      <mediaobject>
        <imageobject>
          <imagedata fileref="images/vdp_result.svg" scale="70"></imagedata>
        </imageobject>
      </mediaobject>
    </figure>
  </section>

  <section>
    <title>Simulation of Models</title>

    <para>Simulation of models in JModelica.org is preformed via the simulate
    method of a model object. The model objects in JModelica.org are:</para>

    <itemizedlist>
      <listitem>
        <para><literal>JMUModel (located in pyjmi)</literal></para>
      </listitem>

      <listitem>
        <para><literal>FMUModel (located in pyfmi)</literal></para>
      </listitem>
    </itemizedlist>

    <para>The difference between the two are that <literal>JMUModel</literal>
    supports compiled models from JModelica.org (extension .jmu) while the
    <literal>FMUModel</literal> supports compiled models from other
    simulation/modelling tools that follow the FMI standard (extension .fmu).
    For more information about compiling a model in JModelica.org see <xref
    linkend="ch_models" />.</para>

    <para>The simulation method is the preferred method for simulation of
    models and which by default is connected to the Assimulo simulation
    package but can also be connected to other simulation platforms. The
    simulation method for <literal>FMUModel</literal> is defined as:</para>

    <programlisting language="python">class FMUModel(...)
    ...
    def simulate(self,
             start_time=0.0,
             final_time=1.0,
             input=(),
             algorithm='AssimuloFMIAlg', 
             options={}):
</programlisting>

    <para>And used in the following way:</para>

    <programlisting language="python">res = FMUModel.simulate() #Using default values
</programlisting>

    <para>The only difference between the simulation method in
    <literal>JMUModel</literal> compared to <literal>FMUModel</literal> is
    that the algorithm is <literal>AssimuloAlg</literal>. They are although
    both connected to the Assimulo package and able to use its solvers.</para>

    <section>
      <title>Arguments</title>

      <para>The start and final time attributes are simply the time where the
      solver should start the integration and stop the integration. The input
      however is a bit more complex and is described in more detail in the
      following section. The algorithm attribute is where the different
      simulation package can be specified, however currently only a connection
      to Assimulo is supported and connected through the algorithm
      <literal>AssimuloAlg</literal> for <literal>JMUModel</literal> and
      <literal>AssimuloFMIAlg</literal> for
      <literal>FMUModel</literal>.</para>

      <section>
        <title>Input</title>

        <para>The input defines the input trajectories to the model and should
        be a 2-tuple consisting of the name(s) of the input variables and the
        second argument should be either a data matrix or a function. If the
        argument is a data matrix it should contain a time vector as the first
        column and the second column should correspond to the first name in
        the first argument and so forth. If instead the second argument is a
        function it should be defined to take the time as input and return the
        number of inputs in the order defined by the first argument.</para>

        <para>For example, consider that we have a model with an input
        variable <literal>u1 </literal>and that the model should be driven by
        a sinus wave as input. Also we are interested in the interval 0 to
        10.</para>

        <programlisting language="python">t = N.linspace(0.,10.,100) #Create one hundred evenly spaced points
u = N.sin(t) #Create the input vector
u_traj = N.transpose(N.hstack((t,u))) #Create the data matrix and transpose 
                                      #it to the correct form
</programlisting>

        <para>The above code have created the data matrix that we are
        interested in giving to the model as input, we just need to connect
        the data to a specific input variable, <literal>u1</literal>:</para>

        <programlisting language="python">input_object = ('u1', u_traj)
</programlisting>

        <para>Now we are ready to simulate using the input and simulate 10
        seconds.</para>

        <programlisting language="python">res = model.simulate(final_time=10, input=input_object)
</programlisting>

        <para>If we on the other hand would have two input variables, u1 and
        u2 the script would instead look like:</para>

        <programlisting language="python">t = N.linspace(0.,10.,100) #Create one hundred evenly spaced points
u1 = N.sin(t) #Create the first input vector
u2 = N.cos(t) #Create the second input vector
u_traj = N.transpose(N.hstack((t,u1,u2))) #Create the data matrix and 
                                          #transpose it to the correct form

input_object = (['u1','u2'], u_traj)

res = model.simulate(final_time=10, input=input_object)
</programlisting>

        <para>Note that the variables are now a List of variables.</para>

        <para>If we were to do the same example using input functions instead,
        the code would like for the single input case:</para>

        <programlisting language="python">input_object = ('u1', N.sin)</programlisting>

        <para>and for the double input case:</para>

        <programlisting language="python">def input_function(t):
    return N.array([N.sin(t),N.cos(t)])

input_object = (['u1','u2'],input_function)
</programlisting>
      </section>

      <section>
        <title>Options for JMUModel</title>

        <para>The options attribute are where options to the specified
        algorithm are stored and are preferably used together with:</para>

        <programlisting language="python">opts = JMUModel.simulate_options()
</programlisting>

        <para>which returns the default options for the default algorithm.
        Information about the available options can be viewed by typing help
        on the <literal>opts</literal> variable:</para>

        <programlisting>&gt;&gt;&gt; help(opts)
   Options for simulation of a JMU model using the Assimulo simulation package.
   The Assimulo package contain both explicit solvers (CVode) for ODEs and 
   implicit solvers (IDA) for DAEs. The ODE solvers require that the problem
   is written on the form, ydot = f(t,y).
   
   ...
</programlisting>

        <para>In <xref linkend="sim_table_gen_Jalg" /> the general options for
        the AssimuloAlg algorithm are described while in <xref
        linkend="sim_table_ida" /> a selection of the different solver
        arguments for the DAE solver IDA is shown. In <xref
        linkend="sim_table_cvode" /> a selection of solver arguments for the
        ODE solver CVode is shown. More information regarding the solver
        options can be found here, http://www.jmodelica.org/assimulo.</para>

        <table xml:id="sim_table_gen_Jalg">
          <title>General options for AssimuloAlg.</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>solver</entry>

                <entry>'IDA'</entry>

                <entry>Specifies the simulation method that is to be
                used.</entry>
              </row>

              <row>
                <entry>ncp</entry>

                <entry>0</entry>

                <entry>Number of communication points. If ncp is zero, the
                solver will return the internal steps taken.</entry>
              </row>

              <row>
                <entry>initialize</entry>

                <entry>True</entry>

                <entry>If set to True, an algorithm for initializing the
                differential equation is invoked, otherwise the differential
                equation is assumed to have consistent initial
                conditions.</entry>
              </row>

              <row>
                <entry>write_scaled_result</entry>

                <entry>False</entry>

                <entry>Set this parameter to True to write the result to file
                without taking scaling into account. If the value of scaled is
                False, then the variable scaling factors of the model are used
                to reproduced the unscaled variable values.</entry>
              </row>

              <row>
                <entry>result_file_name</entry>

                <entry>Empty string (default generated file name will be
                used)</entry>

                <entry>Specifies the name of the file where the simulation
                result is written. Setting this option to an empty string
                results in a default file name that is based on the name of
                the model class.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Lets look at an example, consider that you want to simulate a
        JMU model using the solver CVode together with changing the
        discretization method (discr) from BDF to Adams:</para>

        <programlisting language="python">...
opts = model.simulate_options() #Retrieve the default options

opts['solver'] = 'CVode' #Change the solver from IDA to CVode

opts['CVode_options']['discr'] = 'Adams' #Change from using BDF to Adams

model.simulate(options=opts) #Pass in the options to simulate and simulate
</programlisting>

        <para>It should also be noted from the above example the options
        regarding a specific solver, say the tolerances for
        <literal>CVode</literal> or <literal>IDA</literal>, should be stored
        in a double dictionary where the first is named after the solver
        concatenated with <literal>_options</literal>:</para>

        <programlisting language="python">opts['CVode_options']['atol'] = 1.0e-6 #Options specific for CVode

#or

opts['IDA_options']['atol']  = 1.0e-6 #Options specific for IDA
</programlisting>

        <para>For the general options, as changing the solver, they are
        accessed as a single dictionary:</para>

        <programlisting language="python">opts['solver'] = 'CVode' #Changing the solver
opts['ncp'] = 1000 #Changing the number of communication points.
</programlisting>

        <table xml:id="sim_table_cvode">
          <title>Selection of solver arguments for CVode</title>

          <tgroup cols="3" xml:id="sim_table_cvode">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>discr</entry>

                <entry>'BDF'</entry>

                <entry>The discretization method. Can be either 'BDF' or
                'Adams'</entry>
              </row>

              <row>
                <entry>iter</entry>

                <entry>'Newton'</entry>

                <entry>The iteration method. Can be either 'Newton' or
                'FixedPoint'.</entry>
              </row>

              <row>
                <entry>maxord</entry>

                <entry>5</entry>

                <entry>The maximum order used. Maximum for 'BDF' is 5 while
                for the 'Adams' method the maximum is 12</entry>
              </row>

              <row>
                <entry>maxh</entry>

                <entry>Inf</entry>

                <entry>Maximum step-size. Positive float.</entry>
              </row>

              <row>
                <entry>atol</entry>

                <entry>1.0e-6</entry>

                <entry>Absolute Tolerance. Can be an array of floats where
                each value corresponds to the absolute tolerance for the
                corresponding variable. Can also be a single positive
                float.</entry>
              </row>

              <row>
                <entry>rtol</entry>

                <entry>1.0e-6</entry>

                <entry>Relative Tolerance. Positive float.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table xml:id="sim_table_ida">
          <title>Selection of solver arguments for IDA</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>maxord</entry>

                <entry>5</entry>

                <entry>The maximum order used. Positive integer.</entry>
              </row>

              <row>
                <entry>maxh</entry>

                <entry>Inf</entry>

                <entry>Maximum step-size. Positive float.</entry>
              </row>

              <row>
                <entry>atol</entry>

                <entry>1.0e-6</entry>

                <entry>Absolute Tolerance. Can be an array of floats where
                each value corresponds to the absolute tolerance for the
                corresponding variable. Can also be a single positive
                float.</entry>
              </row>

              <row>
                <entry>rtol</entry>

                <entry>1.0e-6</entry>

                <entry>Relative Tolerance. Positive float.</entry>
              </row>

              <row>
                <entry>suppress_alg</entry>

                <entry>False</entry>

                <entry>Suppress the algebraic variables on the error test. Can
                be either False or True.</entry>
              </row>

              <row>
                <entry>sensitivity</entry>

                <entry>False</entry>

                <entry>If set to True, sensitivities for the states with
                respect to parameters set to free in the model will be
                calculated.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Options for FMUModel</title>

        <para>The options attribute are where options to the specified
        algorithm are stored and are preferably used together with:</para>

        <programlisting language="python">opts = FMUModel.simulate_options()
</programlisting>

        <para>which returns the default options for the default algorithm.
        Information about the available options can be viewed by typing help
        on the <literal>opts</literal> variable:</para>

        <programlisting>&gt;&gt;&gt; help(opts)
   Options for the solving the FMU using the Assimulo simulation package.
   Currently, the only solver in the Assimulo package that fully supports
   simulation of FMUs is the solver CVode.
   
   ...
</programlisting>

        <para>In <xref linkend="sim_table_gen_Falg" /> the general options for
        the AssimuloFMIAlg algorithm are described while in <xref
        linkend="sim_table_cvodeFMI" /> a selection of the different solver
        arguments for the ODE solver CVode is shown. Note that there are minor
        differences in the tolerances compared to the options described in
        <xref linkend="sim_table_cvode" />. More information regarding the
        solver options can be found here,
        http://www.jmodelica.org/assimulo.</para>

        <table xml:id="sim_table_gen_Falg">
          <title>General options for AssimuloFMIAlg.</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>solver</entry>

                <entry>'CVode'</entry>

                <entry>Specifies the simulation method that is to be
                used.</entry>
              </row>

              <row>
                <entry>ncp</entry>

                <entry>0</entry>

                <entry>Number of communication points. If ncp is zero, the
                solver will return the internal steps taken.</entry>
              </row>

              <row>
                <entry>initialize</entry>

                <entry>True</entry>

                <entry>If set to True, the initializing algorithm defined in
                the FMU model is invoked, otherwise it is assumed the user
                have manually invoked model.initialize()</entry>
              </row>

              <row>
                <entry>write_scaled_result</entry>

                <entry>False</entry>

                <entry>Set this parameter to True to write the result to file
                without taking scaling into account. If the value of scaled is
                False, then the variable scaling factors of the model are used
                to reproduced the unscaled variable values.</entry>
              </row>

              <row>
                <entry>result_file_name</entry>

                <entry>Empty string (default generated file name will be
                used)</entry>

                <entry>Specifies the name of the file where the simulation
                result is written. Setting this option to an empty string
                results in a default file name that is based on the name of
                the model class.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Lets look at an example, consider that you want to simulate a
        FMU model using the solver CVode together with changing the
        discretization method (<literal>discr</literal>) from BDF to
        Adams:</para>

        <programlisting language="python">...
opts = model.simulate_options() #Retrieve the default options

#opts['solver'] = 'CVode' #Not necessary, default solver is CVode

opts['CVode_options']['discr'] = 'Adams' #Change from using BDF to Adams

opts['initialize'] = False #Dont initialize the model

model.simulate(options=opts) #Pass in the options to simulate and simulate
</programlisting>

        <para>It should also be noted from the above example the options
        regarding a specific solver, say the tolerances for
        <literal>CVode</literal>, should be stored in a double dictionary
        where the first is named after the solver concatenated with
        <literal>_options</literal>:</para>

        <programlisting language="python">opts['CVode_options']['atol'] = 1.0e-6 #Options specific for CVode
</programlisting>

        <para>For the general options, as changing the solver, they are
        accessed as a single dictionary:</para>

        <programlisting language="python">opts['solver'] = 'CVode' #Changing the solver
opts['ncp'] = 1000 #Changing the number of communication points.
</programlisting>

        <table xml:id="sim_table_cvodeFMI">
          <title>Selection of solver arguments for CVode</title>

          <tgroup cols="3" xml:id="sim_table_cvode">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry>discr</entry>

                <entry>'BDF'</entry>

                <entry>The discretization method. Can be either 'BDF' or
                'Adams'</entry>
              </row>

              <row>
                <entry>iter</entry>

                <entry>'Newton'</entry>

                <entry>The iteration method. Can be either 'Newton' or
                'FixedPoint'.</entry>
              </row>

              <row>
                <entry>maxord</entry>

                <entry>5</entry>

                <entry>The maximum order used. Maximum for 'BDF' is 5 while
                for the 'Adams' method the maximum is 12</entry>
              </row>

              <row>
                <entry>maxh</entry>

                <entry>Inf</entry>

                <entry>Maximum step-size. Positive float.</entry>
              </row>

              <row>
                <entry>atol</entry>

                <entry>rtol*0.01*(nominal values of the continuous
                states)</entry>

                <entry>Absolute Tolerance. Can be an array of floats where
                each value corresponds to the absolute tolerance for the
                corresponding variable. Can also be a single positive
                float.</entry>
              </row>

              <row>
                <entry>rtol</entry>

                <entry>1.0e-4</entry>

                <entry>The relative tolerance. The relative tolerance are
                retrieved from the 'default experiment' section in the
                XML-file and if not found are set to 1.0e-4</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>Return argument</title>

      <para>The return argument from the simulate method is an object derived
      from a common result object <literal>ResultBase</literal> in
      algorithm_drivers.py with a few extra convenience methods for retrieving
      the result of a variable. The result object can be accessed in the same
      way as a dictionary type in Python with the name of the variable as
      key.</para>

      <programlisting language="python">res = model.simulate()

y = res['y'] #Return the result for the variable/parameter/constant y
dery = res['der(y)'] #Return the result for the variable/parameter/constant der(y)
</programlisting>

      <para>This can be done for all the variables, parameters and constants
      defined in the model and is the preferred way of retrieving the result.
      There are however some more options available in the result object, see
      <xref linkend="sim_table_result" />.</para>

      <table xml:id="sim_table_result">
        <title>Result Object</title>

        <tgroup cols="3">
          <thead>
            <row>
              <entry align="center">Option</entry>

              <entry align="center">Type</entry>

              <entry align="center">Description</entry>
            </row>
          </thead>

          <tbody>
            <row>
              <entry>options</entry>

              <entry>Property</entry>

              <entry>Gets the options object that was used during the
              simulation.</entry>
            </row>

            <row>
              <entry>solver</entry>

              <entry>Property</entry>

              <entry>Gets the solver that was used during the
              integration.</entry>
            </row>

            <row>
              <entry>result_file</entry>

              <entry>Property</entry>

              <entry>Gets the name of the generated result file.</entry>
            </row>

            <row>
              <entry>is_variable(name)</entry>

              <entry>Method</entry>

              <entry>Returns True if the given name is a time-varying
              variable.</entry>
            </row>

            <row>
              <entry>data_matrix</entry>

              <entry>Property</entry>

              <entry>Gets the raw data matrix.</entry>
            </row>

            <row>
              <entry>is_negated(name)</entry>

              <entry>Method</entry>

              <entry>Returns True if the given name is negated in the result
              matrix.</entry>
            </row>

            <row>
              <entry>get_column(name)</entry>

              <entry>Method</entry>

              <entry>Returns the column number in the data matrix which
              corresponds to the given variable.</entry>
            </row>
          </tbody>
        </tgroup>
      </table>
    </section>
  </section>

  <section>
    <title>Examples</title>

    <para>In the next sections, it will be shown how to use the JModelica.org
    platform for simulation of various JMUs and FMUs.</para>

    <para>The Python commands in these examples may be copied and pasted
    directly into a Python shell, in some cases with minor modifications.
    Alternatively, they may be copied into a text file, which also is the
    recommended way.</para>

    <section>
      <title>Simulation with inputs</title>

      <para>This example will demonstrate how a model with two inputs with
      data from a matlab-file can be simulated. The model to be simulated is a
      quadruple tank connected to two pumps, which is also the inputs to the
      model. The model is depicted in <xref linkend="sim_fig_quadtank" /> and
      in the code below the corresponding Modelica code is listed.</para>

      <figure xml:id="sim_fig_quadtank">
        <title>A schematic picture of the quadruple tank process.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/qt_schematic.png" scalefit="1"
                       width="40%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <programlisting language="modelica" xml:id="sim_list_qt">model QuadTank
    // Process parameters
  parameter Modelica.SIunits.Area A1=4.9e-4, A2=4.9e-4, A3=4.9e-4, A4=4.9e-4;
  parameter Modelica.SIunits.Area a1=0.03e-4, a2=0.03e-4, a3=0.03e-4, a4=0.03e-4;
  parameter Modelica.SIunits.Acceleration g=9.81;
  parameter Real k1_nmp(unit="m3^/s/V") = 0.56e-6, k2_nmp(unit="m^3/s/V") = 0.56e-6;
  parameter Real g1_nmp=0.30, g2_nmp=0.30;

   // Initial tank levels
  parameter Modelica.SIunits.Length x1_0 = 0.06270;
  parameter Modelica.SIunits.Length x2_0 = 0.06044;
  parameter Modelica.SIunits.Length x3_0 = 0.02400;
  parameter Modelica.SIunits.Length x4_0 = 0.02300;

   // Tank levels
  Modelica.SIunits.Length x1(start=x1_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x2(start=x2_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x3(start=x3_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x4(start=x4_0,min=0.0001/*,max=0.20*/);

  // Inputs
  input Modelica.SIunits.Voltage u1;
  input Modelica.SIunits.Voltage u2;

 equation
   der(x1) = -a1/A1*sqrt(2*g*x1) + a3/A1*sqrt(2*g*x3) +
                                   g1_nmp*k1_nmp/A1*u1;
   der(x2) = -a2/A2*sqrt(2*g*x2) + a4/A2*sqrt(2*g*x4) +
                                   g2_nmp*k2_nmp/A2*u2;
   der(x3) = -a3/A3*sqrt(2*g*x3) + (1-g2_nmp)*k2_nmp/A3*u2;
   der(x4) = -a4/A4*sqrt(2*g*x4) + (1-g1_nmp)*k1_nmp/A4*u1;

end QuadTank;
</programlisting>

      <para>Lets begin with the the example, copy and paste the Modelica code
      and save it into <literal>QuadTank.mo</literal> and open a python script
      file. We start by importing the necessary objects:</para>

      <programlisting language="python">from scipy.io.matlab.mio import loadmat
import matplotlib.pyplot as plt
import numpy as N

from jmodelica import compile_jmu
from pyjmi import JMUModel
</programlisting>

      <para>The input data is stored in <literal>qt_par_est_data.mat</literal>
      which can be found in the <literal>examples/files</literal> catalogue in
      JModelica.org. Copy it into your working directory and paste the
      following commands to load the data-file and extract the data
      trajectories:</para>

      <programlisting language="python">data = loadmat('qt_par_est_data.mat',appendmat=False)

# Extract data series  
t_meas = data['t'][6000::100,0]-60  
u1 = data['u1_d'][6000::100,0]
u2 = data['u2_d'][6000::100,0]
</programlisting>

      <para>The trajectories have now been extracted and needs to be stacked
      into a data matrix with the first column as the time vector and the
      following columns the input of <literal>u1</literal> and
      <literal>u2</literal>. The names of the variables needs also be
      connected in the input object:</para>

      <programlisting language="python"># Build input trajectory matrix for use in simulation
u_data = N.transpose(N.vstack((t_meas,u1,u2)))
input_object = (['u1','u2'], u_data)
</programlisting>

      <para>Next, we compile and load the model:</para>

      <programlisting language="python"># compile JMU
jmu_name = compile_jmu('QuadTank', 'QuadTank.mo')

# Load model
model = JMUModel(jmu_name)
</programlisting>

      <para>Now, that the model is compiled and the input have been adapted,
      lets give the information to the simulate method and simulate:</para>

      <programlisting language="python"># Simulate model with input trajectories
res = model.simulate(final_time=60, input=input_object)
</programlisting>

      <para>The result is retrieved by accessing the <literal>res</literal>
      variable as a dictionary with the variable name as key:</para>

      <programlisting language="python">x1_sim = res['x1']
x2_sim = res['x2']
x3_sim = res['x3']
x4_sim = res['x4']
u1_sim = res['u1']
u2_sim = res['u2']
t_sim  = res['time']
</programlisting>

      <para>And then plotted with the help from
      <literal>matplotlib</literal>:</para>

      <programlisting language="python">plt.figure(1)
plt.subplot(2,2,1)
plt.plot(t_sim,x3_sim)
plt.title('x3')
plt.subplot(2,2,2)
plt.plot(t_sim,x4_sim)
plt.title('x4')
plt.subplot(2,2,3)
plt.plot(t_sim,x1_sim)
plt.title('x1')
plt.xlabel('t[s]')
plt.subplot(2,2,4)
plt.plot(t_sim,x2_sim)
plt.title('x2')
plt.xlabel('t[s]')
plt.show()

plt.figure(2)
plt.subplot(2,1,1)
plt.plot(t_sim,u1_sim,'r')
plt.title('u1')
plt.subplot(2,1,2)
plt.plot(t_sim,u2_sim,'r')
plt.title('u2')
plt.xlabel('t[s]')
plt.show()
</programlisting>

      <para>In <xref linkend="sim_fig_qt_x" /> the result of the tank levels
      are shown and in <xref linkend="sim_fig_qt_u" /> the input signals are
      shown.</para>

      <figure xml:id="sim_fig_qt_x">
        <title>Tank levels</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/quadtank_x.svg" scale="70"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure xml:id="sim_fig_qt_u">
        <title>Input trajectories</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/quadtank_u.svg" scale="70"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation of a discontinuous system</title>

      <para>The model which is to be simulated is an electric circuit. The
      model is depicted in <xref linkend="sim_fig_rlc" /> and consists of
      resistances, inductors and a capacitor. The circuit is connected to a
      voltage source which generates a square-wave with an amplitude of 1.0
      and a frequency of 0.6 Hz. The model is also available from the examples
      in the file RLC_Circuit.mo.</para>

      <figure xml:id="sim_fig_rlc">
        <title>Electric Circuit</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/RLC.png" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This examples assumes that the file
      <literal>RLC_Circuit.mo</literal> is located in the working
      directory.</para>

      <para>Start by creating a Python script file and write or (copy paste)
      the command for importing the model object and for compiling a model
      together with the library used for plotting:</para>

      <programlisting language="python"># Import the function for compilation of models and the JMUModel class
from jmodelica import compile_jmu
from pyjmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

      <para>Next, we compile and load the model:</para>

      <programlisting language="python"># Compile model
jmu_name = compile_jmu("RLC_Circuit_Square","RLC_Circuit.mo")

# Load model
rlc = JMUModel(jmu_name)
</programlisting>

      <para>Now we are ready to simulate our model. We are interested in
      simulating the model from 0.0 to 20.0 seconds. The start time is default
      to 0.0 so no need to change that, but the final time needs to be
      changed:</para>

      <programlisting language="python">res = rlc.simulate(final_time=20.0) #Simulate the model from 0.0 to 20.0 seconds
</programlisting>

      <para>After a successful simulation the statistics are printed in the
      prompt and the results are stored in the variable 'res'. To view the
      result, we have to retrieve information about the variables we are
      interested of which is easily done in the following way:</para>

      <programlisting language="python">square_y    = res['square.y']
resistor_v  = res['resistor.v']
inductor1_i = res['inductor1.i']
time        = res['time']
</programlisting>

      <para>And then plotted with the help from
      <literal>matplotlib</literal>,</para>

      <programlisting language="python">plt.figure(1)
plt.plot(time, square_y, time, resistor_v, time, inductor1_i)    
plt.legend(('square.y','resistor.v','inductor1.i'))
plt.show()
</programlisting>

      <para>The simulation result is shown in <xref
      linkend="sim_fig_rlc_res" />.</para>

      <figure xml:id="sim_fig_rlc_res">
        <title>Simulation result</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/Result_RLC.svg" scalefit="1"
                       width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation of a high-index model</title>

      <para>Mechanical component-based models often result in high-index DAEs.
      In order to efficiently integrate such models, Modelica tools typically
      employs an index reduction scheme, where some equations are
      differentiated, and dummy derivatives are selected. In order to
      demonstrate this feature, we consider the model
      Modelica.Mechanics.Rotational.Examples.First from the Modelica Standard
      library, see <xref linkend="rotational_first_diagram" />. The model is
      of high index since there are two rotating inertias connected with a
      rigid gear.</para>

      <figure xml:id="rotational_first_diagram">
        <title>Modelica.Mechanics.Rotational.First connection diagram</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/rotational_first_diagram.png"
                       scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>First create a Python script file and enter the usual
      imports:</para>

      <programlisting language="python">import matplotlib.pyplot as plt
from jmodelica import compile_fmu
from pyfmi import FMUModel
</programlisting>

      <para>Next, the model is compiled and loaded:</para>

      <programlisting language="python"># Compile model
fmu_name = compile_fmu("Modelica.Mechanics.Rotational.Examples.First",())

# Load model
model = FMUModel(fmu_name)
</programlisting>

      <para>Notice that no file name, just an empty tuple, is provided to the
      function <literal>compile_fmu</literal>, since in this case the model
      that is compiled resides in the Modelica standard library. In the
      compilation process, the index reduction algorithm is invoked. Next, the
      model is simulated for 3 seconds:</para>

      <programlisting language="python"># Load result file
res = model.simulate(final_time=3.)
</programlisting>

      <para>Finally, the simulation results are retrieved and plotted:</para>

      <programlisting language="python">w1 = res['inertia1.w']
w2 = res['inertia2.w']
w3 = res['inertia3.w']
tau = res['torque.tau']
t = res['time']

plt.figure(1)
plt.subplot(2,1,1)
plt.plot(t,w1,t,w2,t,w3)
plt.grid(True)
plt.legend(['inertia1.w','inertia2.w','inertia3.w'])
plt.subplot(2,1,2)
plt.plot(t,tau)
plt.grid(True)
plt.legend(['tau'])
plt.xlabel('time [s]')
plt.show()
</programlisting>

      <para>You should now see a plot as shown below.</para>

      <figure xml:id="rotational_first">
        <title>Simulation result for
        Mecahnics.Rotational.Examples.First</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/rotational_first.svg" scalefit="1"
                       width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation and parameter sweeps</title>

      <para>This example demonstrates how to run multiple simulations with
      different parameter values. Sweeping parameters is a useful technique
      for analysing model sensitivity with respect to uncertainty in physical
      parameters or initial conditions. Consider the following model of the
      Van der Pol oscillator:</para>

      <programlisting language="modelica">  model VDP
    // State start values
    parameter Real x1_0 = 0;
    parameter Real x2_0 = 1;

    // The states
    Real x1(start = x1_0);
    Real x2(start = x2_0);

    // The control signal
    input Real u;

  equation
    der(x1) = (1 - x2^2) * x1 - x2 + u;
    der(x2) = x1;
  end VDP;
</programlisting>

      <para>Notice that the initial values of the states are parametrized by
      the parameters <literal>x1_0</literal> and <literal>x2_0</literal>.
      Next, copy the Modelica code above into a file VDP.mo and save it in
      your working directory. Also, create a Python script file and name it
      vdp_pp.py. Start by copying the commands:</para>

      <programlisting language="python">import numpy as N
import pylab as P
from jmodelica import compile_fmu
from pyfmi import FMUModel
</programlisting>

      <para>into the Python file. Compile and load the model:</para>

      <programlisting language="python"># Define model file name and class name
model_name = 'VDP'
mofile = 'VDP.mo'

# Compile model
fmu_name = compile_fmu(model_name,mofile)

# Load model
vdp = FMUModel(fmu_name)
</programlisting>

      <para>Next, we define the initial conditions for which the parameter
      sweep will be done. The state <literal>x2</literal> starts at 0, whereas
      the initial condition for <literal>x1</literal> is swept between -3 and
      3:</para>

      <programlisting language="python"># Define initial conditions
N_points = 11
x1_0 = N.linspace(-3.,3.,N_points)
x2_0 = N.zeros(N_points)
</programlisting>

      <para>In order to visualize the results of the simulations, we open a
      plot window:</para>

      <programlisting language="python">fig = P.figure()
P.clf()
P.hold(True)
P.xlabel('x1')
P.ylabel('x2')
</programlisting>

      <para>The actual parameter sweep is done by looping over the initial
      condition vectors and in each iteration set the parameter values into
      the model, simulate and plot:</para>

      <programlisting language="python">for i in range(N_points):
    # Set initial conditions in model
    vdp.set('x1_0',x1_0[i])
    vdp.set('x2_0',x2_0[i])
    # Simulate 
    res = vdp.simulate(final_time=20)
    # Get simulation result
    x1=res['x1']
    x2=res['x2']
    # Plot simulation result in phase plane plot
    P.plot(x1, x2,'b')
P.grid()
P.show()
</programlisting>

      <para>You should now see a plot similar to that in <xref
      linkend="sim_fig_psweep" />.</para>

      <figure xml:id="sim_fig_psweep">
        <title>Simulation result-phase plane</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/vdp_pp.svg" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation with sensitivities</title>

      <para>This example will show how to use JModelica.org to simulate an
      Optimica model and calculate sensitivities of the state variables with
      respect to a number of free parameters.</para>

      <para>The model equations is taken from the Robertson example in the
      Sundials suite (https://computation.llnl.gov/casc/sundials/main.html)
      and the model is shown in the code below.</para>

      <programlisting language="optimica">optimization Robertson
    parameter Real p1(free=true)=0.040;
    parameter Real p2(free=true)=1.0e4;
    parameter Real p3(free=true)=3.0e7;
    
    Real y1(start=1.0, fixed=true);
    Real y2(start=0.0, fixed=true);
    Real y3(start=0.0);
  equation
    der(y1) = -p1*y1 + p2*y2*y3;
    der(y2) =  p1*y1 - p2*y2*y3 - p3*(y2*y2);
    0.0 = y1 + y2 + y3 - 1;
end Robertson;
</programlisting>

      <para>In the model we have set the parameters to free which means that
      we want to calculate sensitivities of the states with respect to the
      free parameters.</para>

      <para>Lets begin with the the example, copy and paste the Optimica code
      and save it into <literal>Robertson.mop</literal> and open a python
      script file. We start by importing the necessary objects:</para>

      <programlisting language="python"># Import the function for compilation of models and the JMUModel class
from jmodelica import compile_jmu
from pyjmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

      <para>Next, we compile and load the model:</para>

      <programlisting language="python"># Compile model
jmu_name = compile_jmu("Robertson","Robertson.mop")

# Load model
model = JMUModel(jmu_name)
</programlisting>

      <para>Notice that sensitivity computations are only supported for
      JMUModels currently. Now that the model is loaded, we have to change the
      option to activate the sensitivity calculations and also the absolute
      tolerances:</para>

      <programlisting language="python"># Get and set the options
opts = model.simulate_options() #Get the options
opts['IDA_options']['atol'] = [1.0e-8, 1.0e-14, 1.0e-6] #Change the tolerance
opts['IDA_options']['sensitivity'] = True #Activate the sensitivity calculations
opts['ncp'] = 400 #Change the number of communication points
</programlisting>

      <para>Now lets simulate the model:</para>

      <programlisting language="python">res = model.simulate(final_time=4, options=opts)
</programlisting>

      <para>The sensitivity results are stored as <literal>d{variable
      name}/d{parameter name}</literal> in the result object. We are
      interested in the following sensitivities:</para>

      <programlisting language="python">dy1dp1 = res['dy1/dp1']
dy2dp1 = res['dy2/dp1']
dy3dp1 = res['dy3/dp1']
time = res['time']
</programlisting>

      <para>To plot the trajectories using <literal>matplotlib</literal>, use
      the following commands:</para>

      <programlisting language="python">plt.plot(time, dy1dp1, time, dy2dp1, time, dy3dp1)
plt.legend(('dy1/dp1', 'dy2/dp1', 'dy3/dp1'))
plt.show()
</programlisting>

      <para>In <xref linkend="sim_fig_sens" /> the sensitivities are
      plotted.</para>

      <figure xml:id="sim_fig_sens">
        <title>Sensitivity results.</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/robertson_sens.svg" scale="70"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>

    <section>
      <title>Simulation of an FMU</title>

      <para>This example will show how to use the JModelica.org's
      FMI-interface together with its simulation package, Assimulo. The FMU to
      be simulated is the full Robot from the Modelica standard library (3.1)
      where it is located in
      <literal>Mechanics.MultiBody.Examples.Systems.RobotR3</literal>. It
      consists of brakes, motors, gears and path planning. The model consists
      of 36 continuous states and around 700 algebraic variables together with
      98 event functions and also a few thousand constants/parameters. The FMU
      was generated using Dymola 7.4.</para>

      <figure xml:id="sim_fig_rob">
        <title>Full Robot</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/fullRobot.png" scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <para>This examples assumes that an FMU of the robot named:</para>

      <para><literal>Modelica_Mechanics_MultiBody_Examples_Systems_RobotR3_fullRobot.fmu</literal></para>

      <para>exists in the working folder.</para>

      <para>Start by creating a Python script file and write or (copy paste)
      the command for importing the model object and the library used for
      plotting:</para>

      <programlisting language="python"># Import the FMUModel class
from pyfmi import FMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

      <para>Next, we load the FMU into the model object:</para>

      <programlisting language="python">robot = FMUModel('Modelica_Mechanics_MultiBody_Examples_Systems_RobotR3_fullRobot.fmu')
</programlisting>

      <para>We are interested in simulating the Robot from time 0.0 to 1.8
      using 1000 communication points and using tolerances specified in the
      FMU. This information is specified to the simulate method:</para>

      <programlisting language="python">res = robot.simulate(start_time=0.0, final_time=1.8, options={'ncp':1000})
</programlisting>

      <para>This preforms the simulation and the statistics will be printed in
      the prompt.</para>

      <para>To retrieve data about a variable from the result data, access it
      as a dictionary with the name of the variable as key:</para>

      <programlisting language="python">dq1  = res['der(mechanics.q[1])']
dq6  = res['der(mechanics.q[6])']
time = res['time']
</programlisting>

      <para>Now we have loaded and retrieved the variables of interest. So
      lets plot them.</para>

      <programlisting language="python">plt.plot(time,dq1,time,dq6)
plt.legend(['der(mechanics.q[1])','der(mechanics.q[6])'])
plt.xlabel('Time (s)')
plt.ylabel('Joint Velocity (rad/s)')
plt.title('Full Robot')
plt.show()
</programlisting>

      <para>In <xref linkend="sim_fig_rob_res" /> the result is shown and in
      <xref linkend="sim_fig_rob_dym" /> a comparison between Dymola and
      JModelica.org is plotted.</para>

      <figure xml:id="sim_fig_rob_res">
        <title>Robot Results</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/robot_result.svg" scalefit="1"
                       width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>

      <figure xml:id="sim_fig_rob_dym">
        <title>Comparison with Dymola</title>

        <mediaobject>
          <imageobject>
            <imagedata fileref="images/DymolaFullRobotComparison.png"
                       scalefit="1" width="60%"></imagedata>
          </imageobject>
        </mediaobject>
      </figure>
    </section>
  </section>
</chapter>
