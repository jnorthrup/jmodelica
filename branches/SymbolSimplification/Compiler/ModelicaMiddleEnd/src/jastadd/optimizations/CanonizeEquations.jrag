/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 *  An algorithm re-representing equations on canonical form.<p>
 *  The canonical form currently supports the following features:<p>
 *  <ul>
 *      <li>Transforming an equation f(x) = g(x) to the form h(x) = 0,
 *          where h(x) = f(x) - g(x) or h(x) = g(x) - f(x). </li>
        <li>Multiplication of all factors with the equation's GCD,
 *          thus removing all division expressions.</li>
 *      <li>Restructuring of the equation's tree-form to a form where the
 *          bottom of the tree consists of multiplication expressions joined
 *          together by a top consisting of addition expressions.</li>
 *      <li>Transformation of negations to a form using only variables and literal -1s.</li>
 *      <li>Reordering of expressions and variables.
 *          <ul>
 *          <li>Multiplication expressions and variables are ordered by the below rules:
 *              <ol>
 *                  <li>Positive expressions before negative expressions.</li>
 *                  <li>Multiplication expressions before variable uses.</li>
 *                  <li>Multiplication expressions using more variables
 *                      before expressions with less variables.</li>
 *                  <li>Multiplication expressions with the same number of
 *                      variables are ordered according to the lexical order
 *                      of their first non-equal variable.</li>
 *              </ol>
 *          </li>
 *          </ul>
 *      </li>
 *  </ul>
 *  The canonical form is planned to include more features as listed below:<p>
 *  <ul>
 *      <li>None currently.</li>
 *  </ul>
 * 
 * @author  Johan Calv√©n, Zimon Kuhs.
 * @date    2016-02-08.
 * @version 0.
 */
aspect CanonizeEquations {
    public class symbolicTransformationFramework {
        public class Canonizer extends SymbolicTransformationAlgorithm {
            // Specifies whether the LHS or RHS should be zero.
            private FactorComparator factorComparator = new FactorComparator();
            private static final boolean LEFT_SIDE = false;

            /*
             *  DivToMul data.
             */
            private FExp denominator = FExp.ZERO_EXP;
            private boolean continueMultiplying = false;
            
            public Canonizer(FClass fclass, WorkData workData) {
                super(fclass, workData);
            }
    
            @Override
            public boolean isUsed() {
               return fclass.myOptions().getBooleanOption("canonize_equations");
            }
            
            @Override
            public boolean run(FAbstractEquation feq) {
                if (!feq.isFEquation()) {
                    return false;
                }
                
                FEquation equation = feq.asFEquation();
                feq.moveToOneSide(LEFT_SIDE);
                eliminateDivision(equation);    // TODO: Extract to attribute as with the others.
                feq.convertNegations();
                feq.toAddMulTree(factorComparator);
                
                return true;
            }
            
            @Override
            public void preRun() {
                for (FAbstractEquation equation : fclass.getFAbstractEquations()) {
                    run(equation);
                }
            }
            
            @Override
            public void postRun() {
                // NOP
            }
            
            /*
             *  Eliminates all divisions in an equation.<p>
             *  By recursively multiplying all division expressions with their denominators
             *  and propagating them upwards for multiplication with other nodes.
             *  
             *  @param  feq the equation from which to remove divisions.
             */
            private void eliminateDivision(FEquation feq) {
               FExp exp = feq.nonZeroSide();
    
                // If the expression is only a variable, return.
                if (!exp.isFBinExp()) {
                   return;
                }
    
                // If RHS is a FDivExp, we only have to replace it with its numerator.
                if (exp.isFDivExp()) {
                   FExp num = (FExp) exp.getChild(0);
                   if (num.isFExp()) {
                       if (LEFT_SIDE) {
                           feq.setRight(num);
                       } else {
                           feq.setLeft(num);
                       }
                   }
                   return;
                 }
                
                boolean foundDiv = false;
                
                // Continue searching through the tree untill no more FDivExps are found
                do {
                    foundDiv = divToMul(exp, exp);
                    continueMultiplying = false;
                } while (foundDiv);
            }
    
            /*
             *  Translates all division expressions of an equation to new multiplication expressions.<p>
             *  Since the assumption that no expressions exists on one side of an equation all divisions
             *  can be removed, i.e. every fraction can be multiplied by the equation's GCD.
             *  
             *  The transformation is performed by recursively traversing the tree DFS style.
             *  
             *  @param  exp the expression which denominator should be evaluated.
             *  @param  rootParent the root expression, i.e. the lhs or rhs depending on <code>LEFT_SIDE</code>.
             *          set to true if should continue propagate upwards.
             *  @return {@code true} if a FDivExp was found, {@code false} otherwise.
             *  @see    LEFT_SIDE (CanonizeEquations.jrag).
             *  
             *  TODO: Not optimized atm. The algorithm is traversing the whole tree everytime this method is called.
             *        This could be improved by tracking which paths we have already found and removed an FDivExp.
             */
            private boolean divToMul(FExp exp, FExp rootParent) {
                boolean foundDivLeft = false;   // If found a FDivExp searching on left child
                boolean foundDivRight = false;  // If found a FDivExp searching on right child
                boolean foundDiv = false;       // If found a FDivExp
    
                // Stop searching down the tree if this node is not an FBinExp
                if (!exp.isFBinExp()) {
                    return false;
                }
    
                FBinExp bin = exp.asFBinExp();
                FExp leftChild = bin.getLeft();
                FExp rightChild = bin.getRight();
    
                // Continue recursively searching down the left child as long as its an FBinExp.
                if (leftChild.isFBinExp()) {
                    foundDivLeft = divToMul(leftChild, rootParent);
                }
    
                // Continue recursively searching down the right child as long as
                // it's an FBinExp and no FDivExp was found in left child.
                if (rightChild.isFBinExp() && !foundDivLeft) {
                    foundDivRight = divToMul(rightChild, rootParent);
                }
    
                foundDiv = foundDivLeft || foundDivRight;
                
                // Check if at a bottom FDivExp node (foundDiv==false) and its not the rootParent.
                if (!foundDiv && exp.isFDivExp() && exp != rootParent) {
                    foundDiv = true;            // Found an FDivExp
                    continueMultiplying = true; // Continue multiplying upwards in tree
                    denominator = rightChild;   // Fetch denominator of FDivExp
    
                    // Check if this node is left or right child of its parent,
                    // then replace the FDivExp with its left child (numerator).
                    if (exp.parentFExp().getChild(0) == exp) {
                        exp.parentFExp().setChild(leftChild, 0);
                    } else {
                        exp.parentFExp().setChild(leftChild, 1);
                    }
                // Check if should continuing multiplying upwards in tree and the node is an FAddExp or FSubExp.
                // After checking at which child the FDivExp was found, an FMulExp is inserted that multiplies
                // the other child with the denominator of the FDivExp.
                } else if (continueMultiplying && (exp.isFAddExp() || exp.isFSubExp())) {
                    if (foundDivLeft) {
                        exp.setChild(new FMulExp(rightChild, denominator), 1);
                    } else {
                        exp.setChild(new FMulExp(leftChild, denominator), 0);
                    }
                // Check if should continuing multiplying upwards in tree, the FDivExp was found at
                // the right child of this node and the node is an FDivExp.
                // Time to stop multiplying upwards and an FMulExp is inserted that multiplies
                // the left child with the denominator of the FDivExp.
                } else if (continueMultiplying && foundDivRight && exp.isFDivExp()) {
                    continueMultiplying = false;
                    exp.setChild(new FMulExp(leftChild, denominator), 0);
                }
    
                return foundDiv;
            }
        }
    }
    
    // Null avoidance (sort of Null-object).
    public static final FExp FExp.ZERO_EXP = new FIntegerLitExp(0);
    
    syn boolean FAbstractEquation.moveToOneSide(boolean leftSide) { return false; }
    syn boolean FAbstractEquation.eliminateDivision() { return false; }
    syn boolean FAbstractEquation.convertNegations() { return false; }
    syn boolean FAbstractEquation.toAddMulTree(FactorComparator comparator) { return false; }
    
    /*
     * Priority order.
     *  0.  Positive multiplications.
     *  1.  Variables.
     *  2.  Positive literals.
     *  3.  Negative multiplications.
     *  4.  Negative literals.
     *  5.  Anything else.
     */
    syn int FExp.orderPriority() = Integer.MAX_VALUE;
    eq FMulExp.orderPriority() = isNegative() ? 3 : 0;
    eq FIdUseExp.orderPriority() = 1;
    eq FIntegerLitExp.orderPriority() = getValue() < 0 ? 4 : 2;
    
    syn boolean FExp.isNegative() = false;
    eq FMulExp.isNegative() {
        int result = 0;
        for (FExp exp : factors()) {
            if (exp.isNegative()) {
                ++result;
            }
        }
        return result % 2 != 0;
    }
    eq FIntegerLitExp.isNegative() = getValue() < 0;
    
    /**
     *  Subtracts one side of an equation from both sides.<p>
     *  Transforms f(x) = g(x) to 0 = g(x) - f(x), or the opposite
     *  if <code>LEFT_SIDE</code> is true.
     *  
     *  @param  leftSide specifies if the r.h.s. should be zero or
     *          if true the l.h.s.
     *  @see    LEFT_SIDE
     */
     eq FEquation.moveToOneSide(boolean leftSide) {
        FExp left = getLeft();
        FExp right = getRight();
        FExp lhs;
        FExp rhs;
        
        if (leftSide) {
            lhs = left.isZeroLiteral() ? right : new FSubExp(left, right);
            rhs = new FIntegerLitExp(0);
        } else {
            lhs = new FIntegerLitExp(0);
            rhs = right.isZeroLiteral() ? left : new FSubExp(left, right);
        }
        
        setLeft(lhs);
        setRight(rhs);
        
        return true;
     }

    /*
     *  --------------- Eliminate division goes here. --------------- *
     */

    /**
     *  Converts all negations and subtractions in an equation.<p>
     *  Initial call of recurisve method traversing an equation-tree,
     *  performing the following translations:<p>
     *  <ul>
     *      <li>Subtraction expressions to additions of the LHS and the
     *          RHS expression multiplied by -1.</li>
     *      <li>Negation expressions to multiplications of the un-negated
     *          expression and -1.</li>
     *  </ul>
     */
     
    syn boolean FEquation.convertNegations() {
        // Remove FNegExps and FSubExps.
        setNonZeroSide(nonZeroSide().convertNegativeExpressions());
        return true;
    }

    syn FExp FExp.convertNegativeExpressions() { return this; }
    
    eq FSubExp.convertNegativeExpressions() {
        FMulExp newMulExp = new FMulExp(getRight(), new FIntegerLitExp(-1));
        return new FAddExp(getLeft(), newMulExp);
    }
    
    eq FBinExp.convertNegativeExpressions() {
        setLeft(getLeft().convertNegativeExpressions());
        setRight(getRight().convertNegativeExpressions());
        return this;
    }

    /**
     *  Refactors and equation to only <code>FAddExp</code>s and <code>FMulExp</code>s.<p>
     *  Collects all of the multiplication factors of an equation and
     *  transforms it to a summation of them. E.g. [a(b - c)(d - e)] will
     *  be [abd + ace - abe - acd].
     *
     *  @param  comparator the comparator instance used to sort expressions.
     */
     
    eq FEquation.toAddMulTree(FactorComparator comparator) {
        FExp exp = nonZeroSide();
        HashSet<FactorSet> factors = exp.getFactors();
        FExp newExp = createAddTree(factors, comparator);
        setNonZeroSide(newExp);
        return true;
    }
    
    /**
     *  Collects all multiplication terms in an expression.<p>
     *  A recursive method that starts with the entire equation (the exp argument
     *  should be the f(x) side of an equation on the form f(x) = 0) and continues
     *  to collect terms from both sides of a binary expression. If the expression
     *  argument is an <code>FIdUseExp</code> or <code>FIntegerLitExp</code> it is
     *  put in a new <code>FactorSet </code> which is then returned.<p>
     *  If the equation    is an <code>FAddExp</code> or an <code>FSubExp</code> the
     *  <code>FactorSet</code>s are returned separated (within a <code>HashSet</code>).<p>
     *  If the expression is an <code>FMulExp</code> the LHS and RHS factors are joined
     *  together (representing multiplying the factors) in a new <code>FactorSet</code>.
     */
    
    // If the expression is a non-binary expression it constitutes
    // a new set of factors; a leaf is reached in the tree.
    syn HashSet<FactorSet> FExp.getFactors() {
        HashSet<FactorSet> set = new HashSet<FactorSet>();
        set.add(new FactorSet(this));
        return set;
    }
    
    // For general binary expressions, simply (recursively)
    // collect the factor sets from both children. 
    eq FBinExp.getFactors() {
        HashSet<FactorSet> set = new HashSet<FactorSet>();
    
        // Collect factors from left and right children.
        HashSet<FactorSet> leftFactors = getLeft().getFactors();
        HashSet<FactorSet> rightFactors = getRight().getFactors();
        
        set.addAll(leftFactors);
        set.addAll(rightFactors);
        
        return set;
    }
    
    // If the expression is a multiplication, the l.h.s.
    // and r.h.s. factor sets should be merged.
    eq FMulExp.getFactors() {
        HashSet<FactorSet> set = new HashSet<FactorSet>();
    
        // Collect factors from left and right children.
        HashSet<FactorSet> leftFactors = getLeft().getFactors();
        HashSet<FactorSet> rightFactors = getRight().getFactors();
        
        for (FactorSet leftSet : leftFactors) {
            for (FactorSet rightSet : rightFactors) {
                FactorSet factorSet = new FactorSet();
                factorSet.merge(leftSet);
                factorSet.merge(rightSet);
                set.add(factorSet);
            }
        }
        
        return set;
    }
    
    syn FExp FEquation.createAddTree(HashSet<FactorSet> factors, FactorComparator comparator) {
        ArrayList<FExp> list = new ArrayList<FExp>();

        // Gather all factors from the FactorSets.
        for (FactorSet fs : factors) {
            list.add(fs.multiply());
        }
        
        Collections.sort(list, comparator);
        
        int length = list.size();
        
        // If there is only one expression, return it.
        if (length == 1) {
            return list.remove(0);
        }
        
        // If there are two expressions we can create a binary expression from them.
        if (length == 2) {
            return new FAddExp(list.remove(0), list.remove(0));
        }
        
        // If there are numerous expressions build an FAddExp-tree joining them together.
        return FExp.createBalancedBinaryTree(new FAddExp(), list);
    }
    
    /*
     *  Retrieves the side of an equation which isn't zero.<p>
     *  Defaults to the left side in case neither is zero.
     *
     *  @return the side of an equation which isn't zero, i.e. the
     *          "working" side of the equation.
     */
    public FExp FEquation.nonZeroSide() {
        if (getLeft().isZeroLiteral()) {
            return getRight();
        }
        return getLeft();
    }
    
    /**
     *  Sets a non-zero side of an equation to an <code>FExp</code>.<p>
     *  Defaults to setting the left side in case both are non-zero.
     * 
     *  @param  exp the expression to set as the equation's new one.
     */
    public void FEquation.setNonZeroSide(FExp exp) {
           if (getLeft().isZeroLiteral()) {
               setRight(exp);
           } else {
               setLeft(exp);
           }
    }
    
        /**
     *  A set class for constants and variables which are joined in multiplication.<p>
     *  By building sets of terms the structure of the original equation
     *  can be maintained until the point where it should be re-organized,
     *  avoiding creating new expressions until members of the old equation
     *  (parents) are no longer needed.
     */
    public class FactorSet {
        private FactorComparator comparator = new FactorComparator();
        private ArrayList<FExp> factors;

        public FactorSet() {
           factors = new ArrayList<FExp>();
        }

        public FactorSet(FExp exp) {
            factors = new ArrayList<FExp>();
            add(exp);
        }

        /**
         *  Creates an FMulExp of the current factors.<p>
         *  
         *  @return an FMulExp-tree containing all factors.
         */ 
        public FExp multiply() {
            FExp mulExp = FExp.ZERO_EXP;
            setEvenOrOdd();

            if (factors.size() == 1) {
                mulExp = factors.remove(0);
            } else {
                ArrayList<FExp> list = new ArrayList<FExp>();
                list.addAll(factors);
                Collections.sort(list, comparator);
                mulExp = FExp.createBalancedBinaryTree(new FMulExp(), list);
            }
            return mulExp;
        }
        
        /*
         *  Removes unnecessary literal -1s from the <code>FactorSet</code><p>.
         *  If an even number of -1 exists, all are removed. If an odd number
         *  exists, all but one are removed. Since <code>FactorSet</code>s
         *  concerns factors in a multiplication, only zero or one -1s will
         *  determine whether or not the resulting expression is negative or not.
         */
        private void setEvenOrOdd() {
            int result = 0;
            ArrayList<FExp> literalOnes = new ArrayList<FExp>();

            for (FExp exp : factors) {
                if (exp.isLiteralMinusOne()) {
                    ++result;
                    literalOnes.add(exp);
                }
            }

            if (result % 2 != 0) {
                literalOnes.remove(0);
            }
            
            for (FExp exp : literalOnes) {
                factors.remove(exp);
            }
        }

        public void merge(FactorSet fs) {
            for (FExp f : fs.factors) {
                factors.add(f);
            }
        }

        public void add(FExp exp) {
            factors.add(symbolicTransformationFramework.copyFExp(exp));
        }
    }
    
    /**
     *  Comparator class for <code>FExp</code>s.<p>
     *  Governs the ordering rules used for the canonical form. Used for arranging
     *  <code>FMulExp</code>s, <code>FIdUseExp</code>s, and <code>FIntegerLitExp</code>s
     *  in accordance with the specified rules.
     */
    public class FactorComparator implements Comparator<FExp> {
        /**
         *  Compares two <code>FExp</code>-instances.<p>
         *  Used by <code>FactorSet</code> to order <code>FMulExp</code>s,
         *  <code>FIdUseExp</code>s, and <code>FIntegerLitExp</code>s.<p>
         *  Performs comparison by collecting a list of comparator integers
         *  from each parameter and finding the first non-equal one. This way
         *  several criteria for each type can be specified.
         *  
         *  @param  exp1 an <code>FExp</code>.
         *  @param  exp2 an <code>FExp</code>.
         *  @return less than 0 if exp1 should be ordered first,
         *          more than 0 if exp2 should be ordered first,
         *          and 0 if they have the same ordering.
         */
        public int compare(FExp exp1, FExp exp2) {
            int cmp = exp1.orderPriority() - exp2.orderPriority();
            if (cmp == 0) {
                ArrayList<Integer> cmp1 = exp1.comparisonValues();
                ArrayList<Integer> cmp2 = exp2.comparisonValues();
                for (int i = 0; i < cmp1.size() && i < cmp2.size(); ++i) {
                    if ((cmp = cmp1.get(i) - cmp2.get(i)) != 0) {
                        break;
                    }
                }
            }
            return cmp;
        }
    }
    
    syn ArrayList<Integer> FExp.comparisonValues() {
        return new ArrayList<Integer>(Integer.MAX_VALUE);
    }
    
    eq FMulExp.comparisonValues() {
        ArrayList<Integer> cmp = new ArrayList<Integer>();
        
        // Rule: More ids have priority.
        ArrayList<FIdUseExp> ids = getFIdUseExps();
        cmp.add(- ids.size());

        // Rule: First non-equal id determines order.
        for (FIdUseExp exp : ids) {
            cmp.addAll(exp.comparisonValues());
        } 

        return cmp;
    }
    
    eq FIdUseExp.comparisonValues() {
        ArrayList<Integer> cmp = new ArrayList<Integer>();
        String name = name();
        // Rule: lexical ordering.
        for (int i = 0; i < name.length(); ++i) {
            cmp.add((int) name.charAt(i));
        }
        // Rule: shorter ids before longer ids.
        cmp.add((int) Short.MIN_VALUE);
        return cmp;
    }
    
    eq FIntegerLitExp.comparisonValues() {
        return new ArrayList<Integer>(getValue());
    }
    
    syn ArrayList<FIdUseExp> FExp.getFIdUseExps() {
        ArrayList<FIdUseExp> ids = new ArrayList<FIdUseExp>();
        ArrayList<FExp> factors = factors();
        
        for (FExp exp : factors) {
            if (exp.isFIdUseExp()) {
                ids.add(exp.asFIdUseExp());
            }
        }
        return ids;
    }
    
    /*
     *  Class identity attributes.
     */

    syn boolean FExp.isFExp() = true;
    syn boolean ASTNode.isFExp() = false;

    syn boolean FBinExp.isFBinExp() = true;
    syn boolean FExp.isFBinExp() = false;

    syn boolean FAddExp.isFAddExp() = true;
    syn boolean FExp.isFAddExp() = false;

    syn boolean FSubExp.isFSubExp() = true;
    syn boolean FExp.isFSubExp() = false;

    syn boolean FMulExp.isFMulExp() = true;
    syn boolean FExp.isFMulExp() = false;

    syn boolean FDivExp.isFDivExp() = true;
    syn boolean FExp.isFDivExp() = false;

    syn boolean FIdUseExp.isFIdUseExp() = true;
    syn boolean FExp.isFIdUseExp() = false;

    syn boolean FAbstractEquation.isFEquation() = false;
    syn boolean FEquation.isFEquation() = true;

    /*
     *  Casts.
     */
    
    syn FBinExp FExp.asFBinExp() = (FBinExp) this;
    syn FMulExp FExp.asFMulExp() = (FMulExp) this;
    syn FEquation FAbstractEquation.asFEquation() = (FEquation) this;
    syn FIntegerLitExp FExp.asFIntegerLitExp() = (FIntegerLitExp) this;

    /*
     *  Attributes used by divToMul.
     */

    syn boolean FExp.isLeftChildOfMul() { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }

    syn boolean FExp.lookupLeft(FExp child) { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }

    syn boolean FMulExp.lookupLeft(FExp child) {
        return child == getChild(0);
    }
}