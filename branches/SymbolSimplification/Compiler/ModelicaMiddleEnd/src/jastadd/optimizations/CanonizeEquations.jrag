/**
 * An algorithm re-representing equations on canonical form.<p>
 * The canonical form currently supports the following features:<p>
 * <ul>
 *  <li>Transforming an equation f(x) = g(x) to the form h(x) = 0.</li>
 *  <li>Multiplication of all factors with the equation's GCD.</li>
 *  <ul>
 *      <li>Division expressions do not exist in the canonical form.</li>
 *  </ul>
 * </ul>
 * The canonical form is planned to include more features as listed below:<p>
 * <ul>
 *  <li>Parentheses removal.</li>
 *  <li>Re-ordering of the remaining terms in accordance to the following rules:</li>
 *  <ol>
 *      <li>Terms in multiplication are ordered alphabetically.</li>
 *      <ul>
 *          <li>Numerals are put lastly, regardless of the case of the other characters.</li>
 *      </ul>
 *      <li>Terms in addition are ordered according to their number of factors in descending order.</li>
 *  </ol>
 * </ul>
 * 
 * @author  Johan Calvén, Zimon Kuhs
 * @date    2016-02-0?
 * @version 0?
 */
aspect CanonizeEquations {
    
    public class CE extends OptimizingAlgorithm {
    	// Specifies whether the LHS or RHS should be zero.
    	public static final boolean ZERO_LEFT = false;
    	
    	// We only need one comparator instance.
    	private static FactorComparator factorComparator
            = new FactorComparator();
    	
        public CE(FClass fclass, FClass.WorkData workData) {
            super(fclass, workData);
        }
        
        @Override
        public boolean isUsed() {
           return fclass.myOptions().getBooleanOption("canonize_equations");
        }
        
        @Override
        public boolean run(FAbstractEquation feq) {
            canonizeEquations(new DivToMul());
            return true;
        }
        
        /**
		 * Nested class that stores variables needed when replacing FDivExps with FMulexps.
		 */
	    private class DivToMul {
	    	private FExp denominator;
        	private boolean continueMultiplying;
        	
        	public DivToMul() {
        		denominator = FExp.ZERO_EXP;
        		continueMultiplying = false;
        	}
			
        	public FExp getDenom() {
        		return denominator;
        	}
        	
        	public void setDenom(FExp denom) {
        		denominator = denom;
        	}
        	
        	public boolean continueMultiplying() {
        		return continueMultiplying;
        	}
        	
        	public void setContinueMultiplying(boolean b) {
        		continueMultiplying = b;
        	}
	    }
	    
	    /**
         * Transforms all equations in a model to canonical form.<p>
         * 
         * @param dToM	Object to store variables needed when performing eliminateDivision().
         */
        private void canonizeEquations(DivToMul dToM) {
            for (FAbstractEquation equation: fclass.getFAbstractEquations()) {
	    	    if (!equation.isFEquation())
	    	      continue;
	    	    
	    	    FEquation feq = equation.asFEquation();
	    	    
	    	    fclass.debugPrintLn("Working on equation:\n" + equation.toString() + "\n");
	            
	    	    // Step 1. Move all expressions to RHS.
	    	    moveToOneSide(feq);
	    	    fclass.debugPrintLn("Moved to one side. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 2: Remove all DivExp.
	    	    eliminateDivision(feq, dToM);
	    	    fclass.debugPrintLn("Removed division. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 3: Translate all negations to x * -1.
	    	    convertNegations(feq);
	    	    fclass.debugPrintLn("Translated negative expressions. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 4: Build a tree of only FAddExps and FMulExps.
	    	    toAddMulTree(feq);
	    	    fclass.debugPrintLn("Built add-mul tree and reordered. Eq:\n" + equation.toString() + "\n");
	        	
	        	// Step 5: ...
            }
            fclass.debugPrintLn("Done canonizing equations.");
        }
        
        /**
	     * Subtracts one side of an equation from both sides.<p>
	     * Transforms f(x) = g(x) to 0 = g(x) - f(x), or the opposite
	     * if <code>FClass.ZERO_LEFT</code> is true.
	     * 
	     * @param  feq The equation to transform.
	     * @see    FClass.ZERO_LEFT
	     */
	    private void moveToOneSide(FEquation feq) {
	        FExp left = feq.getLeft(), right = feq.getRight();
	        FExp newLHS = new FIntegerLitExp(0),
	        	newRHS = new FIntegerLitExp(0);
	        
	        if (ZERO_LEFT)
               newRHS = right.isZeroLiteral() ? left : new FSubExp(left, right);
	        else
	           newLHS = left.isZeroLiteral() ? right : new FSubExp(left, right);
	        
	        feq.setLeft(newLHS);
	        feq.setRight(newRHS);
	    }
	    
	    /*
	     * Eliminates all divisions in an equation.<p>
	     * By recursively multiplying all division expressions with their denominators
	     * and propagating them upwards for multiplication with other nodes.
	     * 
	     * @param  feq The equation from which to remove divisions.
	     */
	    private void eliminateDivision(FEquation feq, DivToMul dToM) {
	       FExp fexp = feq.nonZeroSide();
	        
	        // If the expression is only a variable, return.
	        if (!fexp.isFBinExp()) {
	           return;
	        }
	        
	        // If RHS is a FDivExp, we only have to replace it
	        // with its numerator.
	        if (fexp.isFDivExp()) {
	           FExp num = (FExp) fexp.getChild(0);
	           if (num.isFExp()) {
	               if (ZERO_LEFT) {
	                   feq.setRight(num);
	               } else {
	                   feq.setLeft(num);
	               }
	           }
	           return;
	         }
	        
	        boolean foundDiv = false;
	        
	        // Continue searching through the tree untill no more FDivExps are found
	        do {
	            foundDiv = divToMul(fexp, fexp, dToM);
	            dToM.setContinueMultiplying(false);
	        } while (foundDiv);
	    }
    
	    /*
	     * Translates all division expressions of an equation to new multiplication expressions.<p>
	     * Since the assumption that no expressions exists on one side of an equation all divisions
	     * can be removed, i.e. every fraction can be multiplied by the equation's GCD.
	     * 
	     * The transformation is performed by recursively traversing the tree DFS style.
	     * 
	     * @param fexp			The expression which denominator should be evaluated.
	     * @param rootParent	The root expression, i.e. the lhs or rhs depending on <code>FClass.ZERO_LEFT</code>.
	     * @param dToM			A class containing the denominator FExp to multiply with and a boolean flag
	     * 						set to true if should continue propagate upwards.
	     * @return {@code true} if a FDivExp was found, {@code false} otherwise.
	     * @see		FClass.ZERO_LEFT (CanonizeEquations.jrag).
	     * 
	     * TODO: Not optimized atm. The algorithm is traversing the whole tree everytime this method is called.
	     *       This could be improved by tracking which paths we have already found and removed an FDivExp.
	     */
	    private boolean divToMul(FExp fexp, FExp rootParent, DivToMul dToM) {
	        boolean foundDivLeft = false;		// If found a FDivExp searching on left child
	        boolean foundDivRight = false;		// If found a FDivExp searching on right child
	        boolean foundDiv = false;			// If found a FDivExp
	        
	        if (!fexp.isFBinExp())				// Stop searching down the tree if this node is not an FBinExp
	        	return false;
	        
	        FBinExp bin = fexp.asFBinExp();		// The FBinExp node currently at
	        FExp leftChild = bin.getLeft(),		// Left child of this node
	        	rightChild = bin.getRight();	// Right Child of this node
	    
	    	// Continue recursively searching down the left child as long as its an FBinExp
	        if (leftChild.isFBinExp()) 
	            foundDivLeft = divToMul(leftChild, rootParent, dToM);

			// Continue recursively searching down the right child as long as its an FBinExp and no FDivExp was
			// found in left child.
	        if (rightChild.isFBinExp() && !foundDivLeft)
	            foundDivRight = divToMul(rightChild, rootParent, dToM);
	        
	        foundDiv = foundDivLeft || foundDivRight;
	        
            if (!foundDiv && fexp.isFDivExp() && fexp != rootParent) {
            // Check if at a bottom FDivExp node (foundDiv==false) and its not the rootParent.
                foundDiv = true; 					// Found an FDivExp
                dToM.setContinueMultiplying(true); 	// Continue multiplying upwards in tree
                dToM.setDenom(rightChild);			// Fetch denominator of FDivExp
                
                // Check if this node is left or right child of its parent.
                // Then replace the FDivExp with its left child (numerator).
                if (fexp.parentFExp().getChild(0) == fexp) {	
                    fexp.parentFExp().setChild(leftChild, 0);	
                } else {										
                    fexp.parentFExp().setChild(leftChild, 1);
                }
            } else if (dToM.continueMultiplying() && (fexp.isFAddExp() || fexp.isFSubExp())) {
            // Check if should continuing multiplying upwards in tree and the node is an FAddExp or FSubExp.
            // After checking at which child the FDivExp was found, an FMulExp is inserted that multiplies
            // the other child with the denominator of the FDivExp.
                if (foundDivLeft) {
                	fexp.setChild(new FMulExp(rightChild, dToM.getDenom()), 1);
                    //fexp.setChild(new FMulExp(rightChild, denominator), 1);
                } else {
                	fexp.setChild(new FMulExp(leftChild, dToM.getDenom()), 0);
                    //fexp.setChild(new FMulExp(leftChild, denominator), 0);
                }
            } else if (dToM.continueMultiplying() && foundDivRight && fexp.isFDivExp()) {
            // Check if should continuing multiplying upwards in tree, the FDivExp was found at
            // the right child of this node and the node is an FDivExp.
            // Time to stop multiplying upwards and an FMulExp is inserted that multiplies
            // the left child with the denominator of the FDivExp.
                dToM.setContinueMultiplying(false);
                //continueUp = false;
                fexp.setChild(new FMulExp(leftChild, dToM.getDenom()), 0);
                //fexp.setChild(new FMulExp(leftChild, denominator), 0);
            }
	        
	        return foundDiv;
	    }
	
	/**
	 * Converts all negations and subtractions in an equation.<p>
	 * Initial call of recurisve method traversing an equation-tree,
	 * performing the following translations:<p>
	 * <ul>
	 * 	<li>Subtraction expressions to additions of the LHS and the
	 * 		RHS expression multiplied by -1.</li>
	 * 	<li>Negation expressions to multiplications of the expression
	 * 		and -1.</li>
	 * </ul>
	 * 
	 * @param feq	The equation with expressions to convert.
	 * @see			<code>convertNegativeExpressions</code>
	 */ 
	private void convertNegations(FEquation feq) {
		// Copy to avoid parental issues.
		FExp newExp = feq.nonZeroSide().fullCopy();
		
		// Remove FNegExps and FSubExps.
		newExp = convertNegativeExpressions(newExp);
		
		// Update the equation.
		feq.setNonZeroSide(newExp);
	}
	
	/**
	 * Recursively translates all negations and subtractions.<p>
	 * Recursive method, intial call is made with <code>convertNegations</code>.
	 * 
	 * @param exp	The parent expression with children to convert.
	 * @return		The converted expression.
	 * @see			<code>convertNegations</code>
	 */ 
	private FExp convertNegativeExpressions(FExp exp) {
		FExp returnExp = exp;
		if (exp.isFSubExp()) {
			FSubExp sub = exp.asFSubExp();
			returnExp = new FAddExp(sub.getLeft(),
				new FMulExp(sub.getRight(), new FIntegerLitExp(-1)));;
		} else if (exp.isFBinExp()) {
			FBinExp bin = exp.asFBinExp();
			bin.setLeft(convertNegativeExpressions(bin.getLeft()));
			bin.setRight(convertNegativeExpressions(bin.getRight()));
			returnExp = bin;
		}
		return returnExp;
	}
	    
	    /**
         * A set class for constants and variables which are joined in multiplication.<p>
         * By building sets of terms the structure of the original equation
         * can be maintained until the point where it should be re-organized,
         * avoiding creating new expressions until members of the old equation
         * (parents) are no longer needed.
         */ 
	private class FactorSet {
            private FactorComparator comparator = CE.factorComparator;
        	private PriorityQueue<FExp> factors;
			
			/**
			 *	Creates a new factor set using the standard comparator.
			 */        
        	public FactorSet() {
        	   factors = new PriorityQueue<FExp>(comparator);
        	}
        
        	/**
			 *	Creates a new factor set using the standard comparator,
			 *	with an initial set member.<p>
			 *
			 *	@param exp	The initial FExp set member.
			 */
        	public FactorSet(FExp exp) {
        		factors = new PriorityQueue<FExp>(comparator);
       			add(exp);
        	}
        	
        	/**
        	 * Creates an FMulExp of the current factors.<p>
        	 * 
        	 * @return	an FMulExp-tree containing all factors.
        	 */ 
        	public FExp multiply() {
				FExp mulExp = FExp.ZERO_EXP;

				if (factors.size() == 1) {
					mulExp = factors.poll();
				} else {
				    ArrayList<FExp> list = new ArrayList<FExp>();
				    
				    for (FExp factor : factors)
				        list.add(factor);
				    
				    setEvenOrOdd();
				    
					mulExp = FExp.createBalancedBinaryTree(new FMulExp(), list);
                }
                
                return mulExp;					
        	}
        	
        	private void setEvenOrOdd() {
        		int result = 0;
        		ArrayList<FExp> literalOnes = new ArrayList<FExp>();
        		
        		for (FExp exp : factors) {
        			if (exp.isLiteralMinusOne()) {
						++result;
						literalOnes.add(exp);
					}
				}
				
				if (result % 2 != 0)
					literalOnes.remove(0);
				
				for (FExp exp : literalOnes)
					factors.remove(exp);
        	}
        	
        	/**
        	 * Conjoins two <code>FactorSet</code>s.<p>
        	 * 
        	 * @param fs	The <code>FactorSet</code> to join with this.
        	 */ 
        	public void merge(FactorSet fs) {
        		for (FExp f : fs.factors)
        			factors.add(f);
        	}
        	
        	/**
			 *	Adds a new expression to the factor set.<p>
			 *	
			 *	@param exp	The expression to be added.
			 */
        	public void add(FExp exp) {
        		factors.add(exp);
        	}
        }
        
        /**
         *  Refactors and equation to only <code>FAddExp</code>s and <code>FMulExp</code>s.<p>
         *  Collects all of the multiplication factors of an equation and
		 *	transforms it to a summation of them. E.g. [a(b - c)(d - e)] will
		 *	be [abd + ace - abe - acd]. 
         *  
         *  @param feq  The equation to transform.
         */
         private void toAddMulTree(FEquation feq) {
	     	FExp fexp = feq.nonZeroSide();
	       
	       	// Collect all multiplied factors.
	       	HashSet<FactorSet> factors = getFactors(fexp);
			
			// Build a tree of FAddExps and FMulExps.
	       	FExp newFExp = createAddTree(factors);
	       
	       	// Update the equation.
	       	feq.setNonZeroSide(newFExp);
	    }
	    
	    /**
         *  Collects all multiplication terms in an expression.<p>
         *  A recursive method that starts with the entire equation (the exp argument
         *  should be the f(x) side of an equation on the form f(x) = 0) and continues
         *  to collect terms from both sides of a binary expression. If the expression
         *  argument is an <code>FIdUseExp</code> or <code>FIntegerLitExp</code> it is
		 *	put in a new <code>FactorSet </code> which is then returned.<p>
		 *	If the equation	is an <code>FAddExp</code> or an <code>FSubExp</code> the
		 *	<code>FactorSet</code>s are returned separated (within a <code>HashSet</code>).<p>
		 *	If the expression is an <code>FMulExp</code> the LHS and RHS factors are joined
		 *	together (representing multiplying the factors) in a new <code>FactorSet</code>.
         *
         *  @param exp  The expression from which to collect products.
         *  @return     A set containing all multiplied factors from lower in the recursion.
		 *	@see		FClass.FactorSet (CanonizeEquations.jrag).
         */
        private HashSet<FactorSet> getFactors(FExp exp) {
            HashSet<FactorSet> newSet = new HashSet<FactorSet>();
            
            // If the expression is a literal or a variable it constitutes a
            // new set of factors; a leaf is reached in the tree.
            if (!exp.isFBinExp()) {
            	FactorSet fs = new FactorSet(exp);
            	newSet.add(fs);
                return newSet;
            }
            
          	// Collect factors from LHS and RHS.
            FBinExp fbe = exp.asFBinExp();
            HashSet<FactorSet> leftFactors = getFactors(fbe.getLeft()),
                rightFactors = getFactors(fbe.getRight());
            
            // If the expression is a multiplication, join the FactorSets together.
            if (exp.isFMulExp()) {
            	HashSet<FactorSet> factors = new HashSet<FactorSet>();
                for (FactorSet leftSet : leftFactors) {
                    for (FactorSet rightSet : rightFactors) {
                    	FactorSet fs = new FactorSet();
                    	fs.merge(leftSet);
                    	fs.merge(rightSet);
                    	newSet.add(fs);
                    }
                }
                
            // Getting here the expression is FAddExp, as FSubExps
            // are removed in the previous canonization step.
            } else {
                newSet.addAll(leftFactors);
            	newSet.addAll(rightFactors);
            }
             
            return newSet;
		}
	    
	    /**
         *  Builds an <code>FAddExp</code>-tree with <code>FMulExp</code>s at the bottom.
         *
         *  @param factors  The set of <code>FactorSet</code>s with the multiplied terms
		 *						to build the tree with.
         *  @return     The top level addition or subtraction.
         */
	    private FExp createAddTree(HashSet<FactorSet> factors) {
	    	PriorityQueue<FExp> queue =
	    		new PriorityQueue<FExp>(factorComparator);
	    		
	    	// Gather all factors from the FactorSets.
	    	for (FactorSet fs : factors)
	    		queue.add(fs.multiply());
	    	
	    	FExp exp = FExp.ZERO_EXP;
	       	int length = queue.size();
	       
	       	// If there is only one expression, return it.
	       	if (length == 1)
	        	exp = queue.poll();
	        	
	        // If there is two expressions add them together.
	       	else if (length == 2)
	           	exp = new FAddExp(queue.poll(), queue.poll());
	            	
	        // If there are numerous expressions, build an FAddExp-tree
	        // joining them all together.
	       	else
	        	exp = FExp.createBalancedBinaryTree(new FAddExp(),
	        		new ArrayList<FExp>(queue));
	        	
	        return exp; 
	    }
         
         /**
          * Comparator class for <code>FIdUse</code>s.<p>
          * Refers to the <code>String</code> comparator in order to sort
          * terms alphabetically.
          */
         private static class FactorComparator implements Comparator<FExp> {
            public int compare(FExp exp1, FExp exp2) {
                int result = 0;
                
                // For ids, we compare the strings.
                if (exp1.isFIdUseExp() && exp2.isFIdUseExp()) {
                    String id1 = exp1.asFIdUseExp().name(),
                        id2 = exp2.asFIdUseExp().name();
                    
                    result = id1.compareTo(id2);
                    
                // For constants, we order them from lowest to greatest.
                } else if (exp1.isLiteralExp() && exp2.isLiteralExp()) {
                    FIntegerLitExp lit1 = exp1.asFIntegerLitExp(),
                        lit2 = exp2.asFIntegerLitExp();
                        
                    result = lit1.getValue() - lit2.getValue();
                    
                // MulExps are ordered according to their first id.
                } else if (exp1.isFMulExp() && exp2.isFMulExp()) {
                    ArrayList<FExp> ids1 = exp1.factors(),
                    	ids2 = exp2.factors();
                    
                    // Positive expressions before negative expressions.
					if (hasNegative(ids1) && !hasNegative(ids2))
						return 1;
					else if (!hasNegative(ids1) && hasNegative(ids2))
						return -1;
					
					// More IDs mean greater priority.
					if (ids1.size() > ids2.size())
						return -1;
					else if (ids1.size() < ids2.size())
						return 1;
                    
                    // The first lexically greater id-use in
                    // either expression has priority.
                    while (!(ids1.isEmpty() || ids2.isEmpty())) {
                    	FExp f1 = ids1.remove(0),
                    		f2 = ids2.remove(0);
                    	if ((result = compare(f1, f2)) != 0)
                    		break;
                    } 
                
                // Ids are ordered before constants.
                } else if (exp1.isFIdUseExp() && exp2.isLiteralExp()) {
                    result = -1;
                } else if (exp1.isLiteralExp() && exp2.isFIdUseExp()) {
                    result = 1;
                } else {
                    return 0;
                }
                
                return result;
            }
            
            private boolean hasNegative(ArrayList<FExp> ids) {
            	FExp last = ids.get(ids.size() - 1);
            	if (!last.isLiteralExp())
            		return false;
            	return last.asFIntegerLitExp().getValue() < 0;
            }
         }
    }
    
	/**
     *  Sets a non-zero side of an equation to an <code>FExp</code>.<p>
     *  Since all equations in canonic form are on the form f(x) = 0,
     *  only one side of the equation should be managed. This method
     *  enables setting the relevant side of the equation to a new
     *  FExp irrespective of whether or not the left or right side
     *  is the "working" side.
     * 
     *  @param fexp  The expression to set as the equation's new one.
     */
    public void FEquation.setNonZeroSide(FExp fexp) {
    	   if (!getLeft().isZeroLiteral())
	           setLeft(fexp);
	       else
	           setRight(fexp);
    }
    
    /*
     * Retrieves the side of an equation which isn't zero.<p>
     * Null in case both sides are actually defined.
     * 
     * @return      The side of an equation which isn't zero, i.e. the
     *                  "working" side of the equation. If the equation
     *                  is on the form (0 = 0), 0 is returned.
     */
    public FExp FEquation.nonZeroSide() {
        if (getLeft().isZeroLiteral())
            return getRight();
        return getLeft();
    }
    
    /* ---------------- FEquation entries end here. ---------------- */
    
    // Null avoidance (sort of Null-object).
    public static final FExp FExp.ZERO_EXP = new FIntegerLitExp(0);
    
    /* ---------------- Attribute list. ---------------- */
    
    /*
     *  Class identity attributes.
     */
    
    syn boolean FExp.isFExp() = true;
    syn boolean ASTNode.isFExp() = false;
    
    syn boolean FBinExp.isFBinExp() = true;
    syn boolean FExp.isFBinExp() = false;   
 
    syn boolean FExp.isFNegExp() = false;
    syn boolean FNegExp.isFNegExp() = true;

    syn boolean FAddExp.isFAddExp() = true;
    syn boolean FExp.isFAddExp() = false;
    
    syn boolean FSubExp.isFSubExp() = true;
    syn boolean FExp.isFSubExp() = false;

    syn boolean FMulExp.isFMulExp() = true;
    syn boolean FExp.isFMulExp() = false;

    syn boolean FDivExp.isFDivExp() = true;
    syn boolean FExp.isFDivExp() = false;
    
    syn boolean FAbstractEquation.isFEquation() = false;
    syn boolean FEquation.isFEquation() = true;
      
    syn boolean FExp.isFIdUseExp() = false;
    syn boolean FIdUseExp.isFIdUseExp() = true;

    /*
     * Casts.
     */
     
    syn FBinExp FExp.asFBinExp() = (FBinExp) this;
    syn FSubExp FExp.asFSubExp() = (FSubExp) this;
    syn FNegExp FExp.asFNegExp() = (FNegExp) this;
    syn FEquation FAbstractEquation.asFEquation() = (FEquation) this;
	syn FIntegerLitExp FExp.asFIntegerLitExp() = (FIntegerLitExp) this;
    
    /*
     * Attributes used by divToMul.
     */

    syn boolean FExp.isLeftChildOfMul() { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FExp.lookupLeft(FExp child) { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FMulExp.lookupLeft(FExp child) {
        return child == getChild(0);
    }
    
    /* ---------------- Attribute list end. ---------------- */
}