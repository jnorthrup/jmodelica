/**
 * An algorithm re-representing equations on canonical form.<p>
 * The canonical form currently supports the following features:<p>
 * <ul>
 *  <li>Transforming an equation f(x) = g(x) to the form h(x) = 0.</li>
 *  <li>Multiplication of all factors with the equation's GCD.</li>
 *  <ul>
 *      <li>Division expressions do not exist in the canonical form.</li>
 *  </ul>
 * </ul>
 * The canonical form is planned to include more features as listed below:<p>
 * <ul>
 *  <li>Parentheses removal.</li>
 *  <li>Re-ordering of the remaining terms in accordance to the following rules:</li>
 *  <ol>
 *      <li>Terms in multiplication are ordered alphabetically.</li>
 *      <ul>
 *          <li>Numerals are put lastly, regardless of the case of the other characters.</li>
 *      </ul>
 *      <li>Terms in addition are ordered according to their number of factors in descending order.</li>
 *  </ol>
 * </ul>
 * 
 * @author  Johan Calvï¿½n, Zimon Kuhs
 * @date    2016-02-0?
 * @version 0?
 */
aspect CanonizeEquations {
    
    public class Canonizer extends OptimizingAlgorithm {
    	// Specifies whether the LHS or RHS should be zero.
    	public static final boolean ZERO_LEFT = false;
    	
    	// We only need one comparator instance.
    	private static FactorComparator factorComparator
            = new FactorComparator();
            
        /*
         * DivToMul data.
         */
		private static FExp denominator = FExp.ZERO_EXP;
		private static boolean continueMultiplying = false;
    	
        public Canonizer(FClass fclass, FClass.WorkData workData) {
            super(fclass, workData);
        }
        
        @Override
        public boolean isUsed() {
           return fclass.myOptions().getBooleanOption("canonize_equations");
        }
        
        @Override
        public boolean run(FAbstractEquation feq) {
            if (!feq.isFEquation())
            	return false;
            	
            FEquation equation = feq.asFEquation();
            moveToOneSide(equation);
            eliminateDivision(equation);
            convertNegations(equation);
            toAddMulTree(equation);
            
            return true;
        }
        
        /**
	     * Subtracts one side of an equation from both sides.<p>
	     * Transforms f(x) = g(x) to 0 = g(x) - f(x), or the opposite
	     * if <code>FClass.ZERO_LEFT</code> is true.
	     * 
	     * @param  feq The equation to transform.
	     * @see    FClass.ZERO_LEFT
	     */
	    private void moveToOneSide(FEquation feq) {
	        FExp left = feq.getLeft(), right = feq.getRight();
	        FExp newLHS = new FIntegerLitExp(0),
	        	newRHS = new FIntegerLitExp(0);
	        
	        if (ZERO_LEFT)
               newRHS = right.isZeroLiteral() ? left : new FSubExp(left, right);
	        else
	           newLHS = left.isZeroLiteral() ? right : new FSubExp(left, right);
	        
	        feq.setLeft(newLHS);
	        feq.setRight(newRHS);
	    }
	    
	    /*
	     * Eliminates all divisions in an equation.<p>
	     * By recursively multiplying all division expressions with their denominators
	     * and propagating them upwards for multiplication with other nodes.
	     * 
	     * @param  feq The equation from which to remove divisions.
	     */
	    private void eliminateDivision(FEquation feq) {
	       FExp fexp = feq.nonZeroSide();
	        
	        // If the expression is only a variable, return.
	        if (!fexp.isFBinExp()) {
	           return;
	        }
	        
	        // If RHS is a FDivExp, we only have to replace it
	        // with its numerator.
	        if (fexp.isFDivExp()) {
	           FExp num = (FExp) fexp.getChild(0);
	           if (num.isFExp()) {
	               if (ZERO_LEFT) {
	                   feq.setRight(num);
	               } else {
	                   feq.setLeft(num);
	               }
	           }
	           return;
	         }
	        
	        boolean foundDiv = false;
	        
	        // Continue searching through the tree untill no more FDivExps are found
	        do {
	            foundDiv = divToMul(fexp, fexp);
	            continueMultiplying = false;
	        } while (foundDiv);
	    }
    
	    /*
	     * Translates all division expressions of an equation to new multiplication expressions.<p>
	     * Since the assumption that no expressions exists on one side of an equation all divisions
	     * can be removed, i.e. every fraction can be multiplied by the equation's GCD.
	     * 
	     * The transformation is performed by recursively traversing the tree DFS style.
	     * 
	     * @param fexp			The expression which denominator should be evaluated.
	     * @param rootParent	The root expression, i.e. the lhs or rhs depending on <code>FClass.ZERO_LEFT</code>.
	     * 						set to true if should continue propagate upwards.
	     * @return {@code true} if a FDivExp was found, {@code false} otherwise.
	     * @see		FClass.ZERO_LEFT (CanonizeEquations.jrag).
	     * 
	     * TODO: Not optimized atm. The algorithm is traversing the whole tree everytime this method is called.
	     *       This could be improved by tracking which paths we have already found and removed an FDivExp.
	     */
	    private boolean divToMul(FExp fexp, FExp rootParent) {
	        boolean foundDivLeft = false;		// If found a FDivExp searching on left child
	        boolean foundDivRight = false;		// If found a FDivExp searching on right child
	        boolean foundDiv = false;			// If found a FDivExp
	        
	        if (!fexp.isFBinExp())				// Stop searching down the tree if this node is not an FBinExp
	        	return false;
	        
	        FBinExp bin = fexp.asFBinExp();		// The FBinExp node currently at
	        FExp leftChild = bin.getLeft(),		// Left child of this node
	        	rightChild = bin.getRight();	// Right Child of this node
	    
	    	// Continue recursively searching down the left child as long as its an FBinExp
	        if (leftChild.isFBinExp()) 
	            foundDivLeft = divToMul(leftChild, rootParent);

			// Continue recursively searching down the right child as long as its an FBinExp and no FDivExp was
			// found in left child.
	        if (rightChild.isFBinExp() && !foundDivLeft)
	            foundDivRight = divToMul(rightChild, rootParent);
	        
	        foundDiv = foundDivLeft || foundDivRight;
	        
            if (!foundDiv && fexp.isFDivExp() && fexp != rootParent) {
            // Check if at a bottom FDivExp node (foundDiv==false) and its not the rootParent.
                foundDiv = true; 					// Found an FDivExp
                continueMultiplying = true;		 	// Continue multiplying upwards in tree
                denominator = rightChild;			// Fetch denominator of FDivExp
                
                // Check if this node is left or right child of its parent.
                // Then replace the FDivExp with its left child (numerator).
                if (fexp.parentFExp().getChild(0) == fexp) {	
                    fexp.parentFExp().setChild(leftChild, 0);	
                } else {										
                    fexp.parentFExp().setChild(leftChild, 1);
                }
            } else if (continueMultiplying && (fexp.isFAddExp() || fexp.isFSubExp())) {
            // Check if should continuing multiplying upwards in tree and the node is an FAddExp or FSubExp.
            // After checking at which child the FDivExp was found, an FMulExp is inserted that multiplies
            // the other child with the denominator of the FDivExp.
                if (foundDivLeft) {
                	fexp.setChild(new FMulExp(rightChild, denominator), 1);
                } else {
                	fexp.setChild(new FMulExp(leftChild, denominator), 0);
                }
            } else if (continueMultiplying && foundDivRight && fexp.isFDivExp()) {
            // Check if should continuing multiplying upwards in tree, the FDivExp was found at
            // the right child of this node and the node is an FDivExp.
            // Time to stop multiplying upwards and an FMulExp is inserted that multiplies
            // the left child with the denominator of the FDivExp.
                continueMultiplying = false;
                fexp.setChild(new FMulExp(leftChild, denominator), 0);
            }
	        
	        return foundDiv;
	    }
	
		/**
		 * Converts all negations and subtractions in an equation.<p>
		 * Initial call of recurisve method traversing an equation-tree,
		 * performing the following translations:<p>
		 * <ul>
		 * 	<li>Subtraction expressions to additions of the LHS and the
		 * 		RHS expression multiplied by -1.</li>
		 * 	<li>Negation expressions to multiplications of the expression
		 * 		and -1.</li>
		 * </ul>
		 * 
		 * @param feq	The equation with expressions to convert.
		 * @see			<code>convertNegativeExpressions</code>
		 */ 
		private void convertNegations(FEquation feq) {
			// Copy to avoid parental issues.
			FExp newExp = feq.nonZeroSide().fullCopy();
		
			// Remove FNegExps and FSubExps.
			newExp = convertNegativeExpressions(newExp);
		
			// Update the equation.
			feq.setNonZeroSide(newExp);
		}
	
		/**
		 * Recursively translates all negations and subtractions.<p>
	 	* Recursive method, intial call is made with <code>convertNegations</code>.
		 * 
		 * @param exp	The parent expression with children to convert.
	 	* @return		The converted expression.
		 * @see			<code>convertNegations</code>
		 */ 
		private FExp convertNegativeExpressions(FExp exp) {
			FExp returnExp = exp;
			if (exp.isFSubExp()) {
				FSubExp sub = exp.asFSubExp();
				returnExp = new FAddExp(sub.getLeft(),
					new FMulExp(sub.getRight(), new FIntegerLitExp(-1)));;
			} else if (exp.isFBinExp()) {
				FBinExp bin = exp.asFBinExp();
				bin.setLeft(convertNegativeExpressions(bin.getLeft()));
				bin.setRight(convertNegativeExpressions(bin.getRight()));
				returnExp = bin;
			}
			return returnExp;
		}
	    
	    /**
         * A set class for constants and variables which are joined in multiplication.<p>
         * By building sets of terms the structure of the original equation
         * can be maintained until the point where it should be re-organized,
         * avoiding creating new expressions until members of the old equation
         * (parents) are no longer needed.
         */ 
		private class FactorSet {
            private FactorComparator comparator = Canonizer.factorComparator;
        	private ArrayList<FExp> factors;

			/**
			 *	Creates a new factor set using the standard comparator.
			 */        
        	public FactorSet() {
        	   factors = new ArrayList<FExp>();
        	}
        
        	/**
			 *	Creates a new factor set using the standard comparator,
			 *	with an initial set member.<p>
			 *
			 *	@param exp	The initial FExp set member.
			 */
        	public FactorSet(FExp exp) {
        		factors = new ArrayList<FExp>();
       			add(exp);
        	}
        	
        	/**
        	 * Creates an FMulExp of the current factors.<p>
        	 * 
        	 * @return	an FMulExp-tree containing all factors.
        	 */ 
        	public FExp multiply() {
				FExp mulExp = FExp.ZERO_EXP;

                setEvenOrOdd();

				if (factors.size() == 1) {
					mulExp = factors.remove(0);
				} else {
				    ArrayList<FExp> list = new ArrayList<FExp>();
				    
				    list.addAll(factors);
				    Collections.sort(list, comparator);
				    
					mulExp = FExp.createBalancedBinaryTree(new FMulExp(), list);
                }
                
                return mulExp;					
        	}
        	
        	/*
        	 *	Removes unnecessary literal -1 from the <code>FactorSet</code><p>.
        	 * 	If an even number of -1 exists, all are removed. If an odd number
        	 * 	exists, all but one are removed. Since <code>FactorSet</code>s
        	 * 	concerns factors in a multiplication, only zero or one -1s will
        	 *  determine whether or not the resulting expression is negative or not.
        	 */
        	private void setEvenOrOdd() {
        		int result = 0;
        		ArrayList<FExp> literalOnes = new ArrayList<FExp>();
        		
        		for (FExp exp : factors) {
        			if (exp.isLiteralMinusOne()) {
						++result;
						literalOnes.add(exp);
					}
				}
				
				if (result % 2 != 0)
					literalOnes.remove(0);
				
				for (FExp exp : literalOnes)
					factors.remove(exp);
        	}
        	
        	/**
        	 * Conjoins two <code>FactorSet</code>s.<p>
        	 * 
        	 * @param fs	The <code>FactorSet</code> to join with this.
        	 */ 
        	public void merge(FactorSet fs) {
        		for (FExp f : fs.factors)
        			factors.add(f);
        	}
        	
        	/**
			 *	Adds a new expression to the factor set.<p>
			 *	
			 *	@param exp	The expression to be added.
			 */
        	public void add(FExp exp) {
        		factors.add(exp);
        	}
        }
        
        /**
         *  Refactors and equation to only <code>FAddExp</code>s and <code>FMulExp</code>s.<p>
         *  Collects all of the multiplication factors of an equation and
		 *	transforms it to a summation of them. E.g. [a(b - c)(d - e)] will
		 *	be [abd + ace - abe - acd]. 
         *  
         *  @param feq  The equation to transform.
         */
         private void toAddMulTree(FEquation feq) {
	     	FExp fexp = feq.nonZeroSide();
	       
	       	// Collect all multiplied factors.
	       	HashSet<FactorSet> factors = getFactors(fexp);
			
			// Build a tree of FAddExps and FMulExps.
	       	FExp newFExp = createAddTree(factors);
	       
	       	// Update the equation.
	       	feq.setNonZeroSide(newFExp);
	    }
	    
	    /**
         *  Collects all multiplication terms in an expression.<p>
         *  A recursive method that starts with the entire equation (the exp argument
         *  should be the f(x) side of an equation on the form f(x) = 0) and continues
         *  to collect terms from both sides of a binary expression. If the expression
         *  argument is an <code>FIdUseExp</code> or <code>FIntegerLitExp</code> it is
		 *	put in a new <code>FactorSet </code> which is then returned.<p>
		 *	If the equation	is an <code>FAddExp</code> or an <code>FSubExp</code> the
		 *	<code>FactorSet</code>s are returned separated (within a <code>HashSet</code>).<p>
		 *	If the expression is an <code>FMulExp</code> the LHS and RHS factors are joined
		 *	together (representing multiplying the factors) in a new <code>FactorSet</code>.
         *
         *  @param exp  The expression from which to collect products.
         *  @return     A set containing all multiplied factors from lower in the recursion.
		 *	@see		FClass.FactorSet (CanonizeEquations.jrag).
         */
        private HashSet<FactorSet> getFactors(FExp exp) {
            HashSet<FactorSet> newSet = new HashSet<FactorSet>();
            
            // If the expression is a literal or a variable it constitutes a
            // new set of factors; a leaf is reached in the tree.
            if (!exp.isFBinExp()) {
            	FactorSet fs = new FactorSet(exp);
            	newSet.add(fs);
                return newSet;
            }
            
          	// Collect factors from LHS and RHS.
            FBinExp fbe = exp.asFBinExp();
            HashSet<FactorSet> leftFactors = getFactors(fbe.getLeft()),
                rightFactors = getFactors(fbe.getRight());
            
            // If the expression is a multiplication, join the FactorSets together.
            if (exp.isFMulExp()) {
            	HashSet<FactorSet> factors = new HashSet<FactorSet>();
                for (FactorSet leftSet : leftFactors) {
                    for (FactorSet rightSet : rightFactors) {
                    	FactorSet fs = new FactorSet();
                    	fs.merge(leftSet);
                    	fs.merge(rightSet);
                    	newSet.add(fs);
                    }
                }
                
            // Getting here the expression is FAddExp, as FSubExps
            // are removed in the previous canonization step.
            } else {
                newSet.addAll(leftFactors);
            	newSet.addAll(rightFactors);
            }
             
            return newSet;
		}
	    
	    /**
         *  Builds an <code>FAddExp</code>-tree with <code>FMulExp</code>s at the bottom.
         *
         *  @param factors  The set of <code>FactorSet</code>s with the multiplied terms
		 *						to build the tree with.
         *  @return     The top level addition or subtraction.
         */
	    private FExp createAddTree(HashSet<FactorSet> factors) {
	    	ArrayList<FExp> list = new ArrayList<FExp>();
	    		
	    	// Gather all factors from the FactorSets.
	    	for (FactorSet fs : factors)
	    		list.add(fs.multiply());
	    	Collections.sort(list, factorComparator);
	    	
	    	FExp exp = FExp.ZERO_EXP;
	       	int length = list.size();
	       
	       	// If there is only one expression, return it.
	       	if (length == 1)
	        	exp = list.remove(0);
	        	
	        // If there is two expressions add them together.
	       	else if (length == 2)
	           	exp = new FAddExp(list.remove(0), list.remove(0));
	            	
	        // If there are numerous expressions, build an FAddExp-tree
	        // joining them all together.
	       	else
	        	exp = FExp.createBalancedBinaryTree(new FAddExp(),
	        		new ArrayList<FExp>(list));
	        	
	        return exp; 
	    }
         
         /**
          * Comparator class for <code>FIdUse</code>s.<p>
          * Refers to the <code>String</code> comparator in order to sort
          * terms alphabetically.
          */
        private static class FactorComparator implements Comparator<FExp> {
			/**
			 *	Compares two <code>FExp</code>-instances.<p>
			 *	Used by <code>FactorSet</code> to order <code>FMulExp</code>s,
			 *	<code>FIdUseExp</code>s, and <code>FIntegerLitExp</code>s.
			 *	
			 *	@param	exp1	An <code>FExp</code>.
			 *	@param	exp2	An <code>FExp</code>.
			 *	@return	Less than 0 if exp1 should be ordered first,
			 *				more than 0 if exp2 should be ordered first,
			 *				and 0 if they have the same priority.
			 */
            public int compare(FExp exp1, FExp exp2) {
                if (exp1 == exp2)
                    return 0;
                
                if (exp1.isFMulExp()) {
                	if (exp2.isFMulExp()) {
                		// FMulExp and FMulExp.
                        return compare(exp1.asFMulExp(), exp2.asFMulExp());
                    } else if (exp2.isFIdUseExp()) {
                    	// FMulExp and FIdUseExp.
                    	return compare(exp1.asFMulExp(), exp2.asFIdUseExp());
                    }
                } else if (exp1.isFIdUseExp()) {
                	if (exp2.isFMulExp()) {
                		// FIdUseExp and FMulExp.
                        return compare(exp1.asFIdUseExp(), exp2.asFMulExp());
                    } else if (exp2.isFIdUseExp()) {
                    	// FIdUseExp and FIdUseExp.
                    	return compare(exp1.asFIdUseExp(), exp2.asFIdUseExp());
                    }
                } else if (exp1.isLiteralExp() && exp2.isLiteralExp()) {
                		// FIntegerLitExp and FIntegerLitExp.
                        return compare(exp1.asFIntegerLitExp(), exp2.asFIntegerLitExp());
                }
                
                // The remaining comparisons only concern type priority.
                return exp1.orderPriority() - exp2.orderPriority();
            }
            
            /*
			 *	Comparator method for FMulExps.
			 */
            private int compare(FMulExp exp1, FMulExp exp2) {
                // Rule #1: Positives before negatives.
                boolean neg1 = exp1.isNegative(), neg2 = exp2.isNegative();
                if (neg1 != neg2)
                    return neg1 ? 1 : -1;
                    
                // Rule #2: More ids have priority.
                ArrayList<FExp> ids1 = exp1.factors(),
                    ids2 = exp2.factors();
                int size1 = ids1.size(), size2 = ids2.size();
                int cmp = size1 - size2;
                
                if (cmp != 0)
                    return cmp;    
                
                // Rule #3: First non-equal id determines order.
                for (int i = 0; i < size1; ++i)
                    if ((cmp = compare(ids1.get(i), ids2.get(i))) != 0)
                        return cmp;
                
                return 0;
            }
            
            /*
			 *	Comparator method for FMulExps and FIdUseExps.
			 */
            private int compare(FMulExp exp1, FIdUseExp exp2) {
                return exp1.isNegative() ? 1 : -1;
            }
            
            private int compare(FIdUseExp exp1, FMulExp exp2) {
                return -compare(exp2, exp1);
            }
            
			/*
			 *	Comparator method for FIdUseExps.
			 */
            private int compare(FIdUseExp exp1, FIdUseExp exp2) {
                // Rule: Lexical ordering.
                return exp1.name().compareTo(exp2.name());
            }
            
			/*
			 *	Comparator method for FIntegerLitExps.
			 */
            private int compare(FIntegerLitExp exp1, FIntegerLitExp exp2) {
                // Rule: Greatest value first.
                return exp1.getValue() - exp2.getValue();
            }
        }
    }
    
	/**
     *  Sets a non-zero side of an equation to an <code>FExp</code>.<p>
     *  Since all equations in canonic form are on the form f(x) = 0,
     *  only one side of the equation should be managed. This method
     *  enables setting the relevant side of the equation to a new
     *  FExp irrespective of whether or not the left or right side
     *  is the "working" side.
     * 
     *  @param fexp  The expression to set as the equation's new one.
     */
    public void FEquation.setNonZeroSide(FExp fexp) {
    	   if (!getLeft().isZeroLiteral())
	           setLeft(fexp);
	       else
	           setRight(fexp);
    }
    
    /*
     * Retrieves the side of an equation which isn't zero.<p>
     * Null in case both sides are actually defined.
     * 
     * @return      The side of an equation which isn't zero, i.e. the
     *                  "working" side of the equation. If the equation
     *                  is on the form (0 = 0), 0 is returned.
     */
    public FExp FEquation.nonZeroSide() {
        if (getLeft().isZeroLiteral())
            return getRight();
        return getLeft();
    }
    
    /* ---------------- FEquation entries end here. ---------------- */
    
    // Null avoidance (sort of Null-object).
    public static final FExp FExp.ZERO_EXP = new FIntegerLitExp(0);
    
    /* ---------------- Attribute list. ---------------- */
    
    /*
     *  Class identity attributes.
     */
    
    syn boolean FExp.isFExp() = true;
    syn boolean ASTNode.isFExp() = false;
    
    syn boolean FBinExp.isFBinExp() = true;
    syn boolean FExp.isFBinExp() = false;   
 
    syn boolean FExp.isFNegExp() = false;
    syn boolean FNegExp.isFNegExp() = true;

    syn boolean FAddExp.isFAddExp() = true;
    syn boolean FExp.isFAddExp() = false;
    
    syn boolean FSubExp.isFSubExp() = true;
    syn boolean FExp.isFSubExp() = false;

    syn boolean FMulExp.isFMulExp() = true;
    syn boolean FExp.isFMulExp() = false;

    syn boolean FDivExp.isFDivExp() = true;
    syn boolean FExp.isFDivExp() = false;
    
    syn boolean FAbstractEquation.isFEquation() = false;
    syn boolean FEquation.isFEquation() = true;
      
    syn boolean FExp.isFIdUseExp() = false;
    syn boolean FIdUseExp.isFIdUseExp() = true;

    /*
     * Casts.
     */
    
    syn FBinExp FExp.asFBinExp() = (FBinExp) this;
    syn FMulExp FExp.asFMulExp() = (FMulExp) this;
    syn FSubExp FExp.asFSubExp() = (FSubExp) this;
    syn FNegExp FExp.asFNegExp() = (FNegExp) this;
    syn FEquation FAbstractEquation.asFEquation() = (FEquation) this;
	syn FIntegerLitExp FExp.asFIntegerLitExp() = (FIntegerLitExp) this;
    
    /*
     *  Ordering priorities.
     */
    
    syn int FExp.orderPriority() = Integer.MAX_VALUE;
    syn int FMulExp.orderPriority() = 0;
    syn int FIdUseExp.orderPriority() = 1;
    syn int FIntegerLitExp.orderPriority() = 2;
    
    /*
     * Attributes used by divToMul.
     */

    syn boolean FExp.isLeftChildOfMul() { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FExp.lookupLeft(FExp child) { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FMulExp.lookupLeft(FExp child) {
        return child == getChild(0);
    }
    
    /*
     *  Negation identity.
     */
     
     syn boolean FExp.isNegative() = false;
     syn boolean FMulExp.isNegative() {
        int result = 0;
        for (FExp exp : factors())
            if (exp.isNegative())
                ++result;
        return result % 2 != 0;
     }
     syn boolean FIntegerLitExp.isNegative() = getValue() < 0;
    
    /* ---------------- Attribute list end. ---------------- */
}