/**
 * An algorithm re-representing equations on canonical form.<p>
 * The canonical form currently supports the following features:<p>
 * <ul>
 *  <li>Transforming an equation f(x) = g(x) to the form h(x) = 0.</li>
 *  <li>Multiplication of all factors with the equation's GCD.</li>
 *  <ul>
 *      <li>Division expressions do not exist in the canonical form.</li>
 *  </ul>
 * </ul>
 * The canonical form is planned to include more features as listed below:<p>
 * <ul>
 *  <li>Parentheses removal.</li>
 *  <li>Re-ordering of the remaining terms in accordance to the following rules:</li>
 *  <ol>
 *      <li>Terms in multiplication are ordered alphabetically.</li>
 *      <ul>
 *          <li>Numerals are put lastly, regardless of the case of the other characters.</li>
 *      </ul>
 *      <li>Terms in addition are ordered according to their number of factors in descending order.</li>
 *  </ol>
 * </ul>
 * 
 * @author  Johan Calv√©n, Zimon Kuhs
 * @date    2016-02-0?
 * @version 0?
 */
 

 
aspect CanonizeEquations {
    // Specifies whether the LHS or RHS should be zero.
    public static final boolean FClass.ZERO_LEFT = false;
    
	public class FClass {
        /**
         * Perform canonization on equations if it is activated.
         */
        public class canonizeEquationsIfSet extends Transformation {
            public canonizeEquationsIfSet() {
                super("canonize_equations");
            }
            
            public void perform() {
                canonizeEquations();
            }
        }
        
        public canonizeEquationsIfSet canonizeEquations = new canonizeEquationsIfSet();
    }
    
    /* ---------------- Attribute list. ---------------- */
    
    /*
     *  Class identity attributes.
     */
    
    syn boolean FDivExp.isDivExp() = true;
    syn boolean FExp.isDivExp() = false;

    syn boolean FMulExp.isMulExp() = true;
    syn boolean FExp.isMulExp() = false;
    
    syn boolean FBinExp.isBinExp() = true;
    syn boolean FExp.isBinExp() = false;
    
    syn boolean FAddExp.isAddExp() = true;
    syn boolean FExp.isAddExp() = false;
    
    syn boolean FSubExp.isSubExp() = true;
    syn boolean FExp.isSubExp() = false;
    
    syn boolean FExp.isFExp() = true;
    syn boolean ASTNode.isFExp() = false;
    
    syn boolean FExp.isNegExp() = false;
    syn boolean FNegExp.isNegExp() = true;
    
    /*
     * Within negative context.
     */
    
    // Top-level catchers.
    eq Root.getChild().withinNegativeContext() = false;
    eq FEquation.getChild().withinNegativeContext() = false;
    syn boolean ASTNode.withinNegativeContext() = false;

    eq FSubExp.getRight().withinNegativeContext() =
    	getParent() == null || !withinNegativeContext();
    eq FNegExp.getChild().withinNegativeContext() =
    	getParent() == null || !withinNegativeContext();
    
    inh boolean FExp.withinNegativeContext();
    inh boolean FIdUseExp.withinNegativeContext();
    inh boolean FIntegerLitExp.withinNegativeContext();
    
    /*
     * Descriptive tag.
     */

    syn boolean FExp.isLeftChildOfMul() { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FExp.lookupLeft(FExp child) { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FMulExp.lookupLeft(FExp child) {
        return child == getChild(0);
    }
    
    // Cast avoidance.
    syn FBinExp FExp.asFBinExp() = (FBinExp) this;
    
    /*
     * Retrieves the side of an equation which isn't zero.<p>
     * Null in case both sides are actually defined.
     * 
     * @return      The side of an equation which isn't zero, i.e. the
     *                  "working" side of the equation. If the equation
     *                  is on the form (0 = 0), null is returned.
     */
    syn FExp FEquation.nonZeroSide() {
        if (getLeft().isZeroLiteral())
            return getRight();
        if (getRight().isZeroLiteral())
            return getLeft();
        return null;
    }
    
    /* ---------------- Attribute list end. ---------------- */
    
    public class FClass {
        private FExp denominator = null;
        private boolean continueUp = false;
        
        /* FactorSet */
        
        private class FactorSet {
        	HashSet<FExp> factors;
        	private boolean negated = false;
        
        	public FactorSet() {
        		factors = new HashSet<FExp>();
        	}
        
        	public FactorSet(FExp exp) {
        		factors = new HashSet<FExp>();
       			factors.add(exp);
       			this.negated = exp.withinNegativeContext();
        	}
        	
        	public FExp multiply() {
				FExp mulExp = null;

				if (factors.size() == 1)
					for (FExp exp : factors)
						mulExp = exp;
				else
					mulExp = FExp.createBalancedBinaryTree(
						new FMulExp(), new ArrayList<FExp>(factors));
					
        		return negated ? new FNegExp(mulExp) : mulExp;
        	}
        	
        	public void addAll(FactorSet fs) {
        		for (FExp f : fs.factors)
        			factors.add(f);
        		negated = negated || fs.negated;
        	}
        	
        	public void add(FIdUseExp exp) {
        		factors.add(exp);
        		negated = negated || exp.withinNegativeContext();
        	}
        }
        
        /* ----- ----- */
        
        public void canonizeEquations() {
            for (FAbstractEquation equation: getFAbstractEquations()) {
	    	    if (!equation.isFEquation())
	    	      continue;
	    	    
	    	    debugPrintLn("Working on equation:\n" + equation.toString() + "\n");
	    	      
	    	    FEquation feq  = (FEquation) equation;
	            
	    	    // Step 1. Move all expressions to RHS.
	    	    moveToOneSide(feq);
	    	    debugPrintLn("Moved to one side. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 2: Remove all DivExp.
	    	    elimDiv(feq);
	    	    debugPrintLn("Removed division. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 3: Expand parentheses.
	    	    expandParentheses(feq);
	    	    debugPrintLn("Removed parentheses. Eq:\n" + equation.toString() + "\n");
	    	    
	        	// Step 4: Re-order terms.
	        	//reorderTerms(feq);
	        	debugPrintLn("Re-ordered terms. Eq:\n" + equation.toString() + "\n");
            }
            debugPrintLn("Done canonizing equations.");
        }
    
	    /**
	     * Subtracts one side of an equation from both sides.<p>
	     * Transforms f(x) = g(x) to 0 = g(x) - f(x), or the opposite
	     * if FClass.ZERO_LEFT is true.
	     * 
	     * @param  feq The equation to transform.
	     * @see    FClass.ZERO_LEFT
	     */
	    public void moveToOneSide(FEquation feq) {
	        FExp left = feq.getLeft(), right = feq.getRight();
	        FExp zero = new FIntegerLitExp(0);
	        FExp newLHS = zero, newRHS = zero;
	        
	        // "Move" one side of the equation to the other,
	        // and set it to zero.
	        if (ZERO_LEFT)
               newRHS = right.isZeroLiteral() ? left : new FSubExp(left, right);
	        else
	           newLHS = left.isZeroLiteral() ? right : new FSubExp(left, right);
	        
	        feq.setLeft(newLHS);
	        feq.setRight(newRHS);	        
	    }
    
	    /*
	     * Eliminates all divisions in an equation.<p>
	     * By recursively multiplying all division expressions with their denominators
	     * and propagating them upwards for multiplication with other nodes.
	     * 
	     * @param  feq The equation from which to remove divisions.
	     */
	    public void elimDiv(FEquation feq) {
	       FExp fexp = feq.nonZeroSide();
	        
	        // If the expression is only a variable, return.
	        if (!fexp.isBinExp()) {
	           return;
	        }
	        
	        // If RHS is a FDivExp, we only have to replace it
	        // with its numerator.
	        if (fexp.isDivExp()) {
	           FExp num = (FExp) fexp.getChild(0);
	           if (num.isFExp()) {
	               if (ZERO_LEFT) {
	                   feq.setRight(num);
	               } else {
	                   feq.setLeft(num);
	               }
	           }
	           return;
	         }
	        
	        boolean foundDiv = false;
	        
	        do {
	            foundDiv = divToMul(fexp, fexp);
	            continueUp = false;
	        } while (foundDiv);
	    }
    
	    /*
	     * Translates all division expressions of an equation to multiplication expressions.<p>
	     * Since the assumption that no expressions exists on one side of an equation all divisions
	     * can be removed, i.e. every fraction can be multiplied by the equation's GCD.
	     * 
	     * @param  fexp
	     * @param  rootParent  The root expression, i.e. the lhs or rhs depending on FClass.ZERO_LEFT.
	     * @return true if the current expression should propagate multiplication higher in the tree.
	     * @see    FClass.ZERO_LEFT.
	     * 
	     * TODO: Not optimized atm. The algorithm is traversing the whole tree everytime this method is called.
	     *       This could be improved by tracking which paths we have already found and removed an FDivExp.
	     */
	    public boolean divToMul(FExp fexp, FExp rootParent) {
	        boolean foundDivLeft = false;
	        boolean foundDivRight = false;
	        boolean foundDiv = false;
	        
	        FExp leftChild = fexp.getChild(0).isFExp() ? (FExp) fexp.getChild(0) : null;
            FExp rightChild = fexp.getChild(1).isFExp() ? (FExp) fexp.getChild(1) : null;
	    
	        // Recursive call if a child is a FBinExp (then we know its not a leaf).
	        if (leftChild.isBinExp()) {
	            foundDivLeft = divToMul(leftChild, rootParent);
	        }
	        if (rightChild.isBinExp() && !foundDivLeft) {
	            foundDivRight = divToMul(rightChild, rootParent);
	        }
	        
	        foundDiv = foundDivLeft || foundDivRight;
	        
	        // Remove bottom FDivExp and insert FMulExps at correct places.
            if (!foundDiv && fexp.isDivExp() && fexp != rootParent) {
                foundDiv = true;
                continueUp = true;
                denominator = rightChild;
                
                if (fexp.parentFExp().getChild(0) == fexp) {
                    fexp.parentFExp().setChild(leftChild, 0);
                } else {
                    fexp.parentFExp().setChild(leftChild, 1);
                }
            } else if (continueUp && (fexp.isAddExp() || fexp.isSubExp())) {
                if (foundDivLeft) {
                    fexp.setChild(new FMulExp(rightChild, denominator), 1);
                } else {
                    fexp.setChild(new FMulExp(leftChild, denominator), 0);
                }
            } else if (continueUp && foundDivRight && fexp.isDivExp()) {
                continueUp = false;
                fexp.setChild(new FMulExp(leftChild, denominator), 0);
            }
	        
	        return foundDiv;
	    }
	    
	    /**
         *  Expands (removes) all parentheses.<p>
         *  By collecting all multiplied factors and building an equation using
         *  only summation of them, the necessity of using parentheses to describe
         *  an equation is redundant.
         *  
         *  @param feq  The equation that may or may not contain parentheses.
         */
	    public void expandParentheses(FEquation feq) {
	       FExp fexp = feq.nonZeroSide();
	       
	       // Build factors (recursive method).
	       HashSet<FactorSet> factors = getFactors(fexp);
	       
	       // If only one term exists we need not build any tree.
	       FExp newFExp = createTree(factors);
	       
	       // Update the equation.
	       feq.setNonZeroSide(newFExp);
	    }
	    
	    /**
         *  Collects all multiplication terms in an expression.<p>
         *  A recursive method that starts with the entire equation (the exp argument
         *  should be the f(x) side of an equation on the form f(x) = 0) and continues
         *  to collect terms from both sides of a binary expression. If the expression
         *  argument is a variable it is simply returned. If it is an addition or
         *  subtraction, terms are collected from both sides.<p>
         *  Should the expression be a multiplication, however, all terms in the l.h.s.
         *  must be multiplied once by each term in the r.h.s. (this denotes the expansion
         *  from e.g. ((a + b) * (c + d)) to (ac + ad + bc + bd) before all the products
         *  are returned.
         *
         *  @param exp  The expression to expand.
         *  @return     All products collected from either side of the expression.
         */
        private HashSet<FactorSet> getFactors(FExp exp) {
            HashSet<FactorSet> newSet = new HashSet<FactorSet>();
            if (!exp.isBinExp()) {
            	FactorSet fs = new FactorSet(exp);
            	newSet.add(fs);
                return newSet;
            }
            
            FBinExp fbe = exp.asFBinExp();
            HashSet<FactorSet> leftFactors = getFactors(fbe.getLeft()),
                rightFactors = getFactors(fbe.getRight());
            
            if (exp.isMulExp()) {
            	HashSet<FactorSet> factors = new HashSet<FactorSet>();
                for (FactorSet leftSet : leftFactors) {
                    for (FactorSet rightSet : rightFactors) {
                    	FactorSet fs = new FactorSet();
                    	fs.addAll(leftSet);
                    	fs.addAll(rightSet);
                    	newSet.add(fs);
                    }
                }
             } else {
                newSet.addAll(leftFactors);
                newSet.addAll(rightFactors);
             }
             
             return newSet;
        }
	    
	    /**
         *  Recursively builds a summation.<p>
         *  All multiplied terms are added together in a consecutive summation
         *  (or subtraction) in a tree built recursively. The tree will have
         *  FAddExp or FSubExp nodes in the majority of the top level;
         *  at the 1-2 lowest levels will be only FMulExps and FIdUseExps.<p>
         *  This is the initial call to the recursive method <code>buildAddTree</code>.
         *
         *  @param factors  A list of all multiplication factors.
         *  @return     The top level addition or subtraction.
         */
	    private FExp createTree(HashSet<FactorSet> factors) {
	    	ArrayList<FExp> list = multiplyFactors(factors);
	       int length = list.size();
	       
	       if (length == 1)
	           return list.remove(0);
	       else if (length == 2)
	           return new FAddExp(list.remove(0),
	               list.remove(0));
	       else
	           return FExp.createBalancedBinaryTree(new FAddExp(), list);   
	    }
	    
	    private ArrayList<FExp> multiplyFactors(HashSet<FactorSet> factors) {
	    	ArrayList<FExp> list = new ArrayList<FExp>();
	    	for (FactorSet fs : factors)
	    		list.add(fs.multiply());
	    	return list;
	    }
   
        /**
         *  Re-orders all multiplied terms.<p>
         *
         *  @param feq  The equation containing multiplied terms.
         */
         
         public void reorderTerms(FEquation fe) {
            FExp exp = fe.nonZeroSide();
            
            if (!exp.isBinExp())
                return;
                
            recursiveReorder((FBinExp) exp);
         }
         
         private void recursiveReorder(FBinExp exp) { 
            FExp left = exp.getLeft(), right = exp.getRight();
            
            if (exp.isAddExp() || exp.isSubExp()) {
                if (left.isBinExp())
                    recursiveReorder((FBinExp) left);
                if (right.isBinExp())    
                    recursiveReorder((FBinExp) right);
            } else if (exp.isMulExp()) {
                reorderTerm((FMulExp) exp);
            }
         }
        
        /**
         *  Re-orders the factors in a multiplication term in alphabetical order.<p>
         *  
         *  @param exp  The parent node of a multiplication chain to re-order.
         */
         
         public void reorderTerm(FMulExp fme) {
            PriorityQueue<FIdUseExp> ids = new PriorityQueue<FIdUseExp>(
                0, new NameComparator());
                
            ArrayList<FIdUseExp> list = new ArrayList<FIdUseExp>();
            getFIdUses(fme, list);
            
            for (FIdUseExp fiue : list)
                ids.add(fiue);
                
            if (ids.size() <= 1)
                return;
                
            if (ids.size() == 2) {
                fme.setLeft(ids.poll());
                fme.setRight(ids.poll());
            } else {
                fme.setLeft(ids.poll());
                fme.setRight(buildProduct(ids));
            }
         }
         
         private void getFIdUses(FExp exp, ArrayList<FIdUseExp> list) {
            if (exp.isFIdUseExp()) {
                list.add((FIdUseExp) exp);
                return;
            }
            
            if (!exp.isBinExp())
                return;
            
            FBinExp fexp = exp.asFBinExp();
            getFIdUses(fexp.getLeft(), list);
            getFIdUses(fexp.getRight(), list);    
         }
         
         private FExp buildProduct(PriorityQueue<FIdUseExp> list) {
            if (list.size() == 1)
                return list.poll();
            return new FMulExp(list.poll(), buildProduct(list));
         }
         
         /**
          * Comparator class for FIdUses.<p>
          * Refers to the <code>String</code> comparator in order to sort
          * terms alphabetically.
          */
         private class NameComparator implements Comparator<FIdUseExp> {
            public int compare(FIdUseExp f1, FIdUseExp f2) {
                return (f1.name()).compareTo(f2.name());
            }
         }
        
        /* --------------- FClass entries end here. --------------- */
	}
	
	public class FEquation {
	   /**
        *  Sets a non-zero side of an equation to an FExp.<p>
        *  Since all equations in canonic form are on the form f(x) = 0,
        *  only one side of the equation should be managed. This method
        *  enables setting the relevant side of the equation to a new
        *  FExp irrespective of whether or not the left or right side
        *  is the "working" side.
        *
        *  @param fexp  The expression to set as the equation's new one.
        */
	   public void setNonZeroSide(FExp fexp) {
	       if (!getLeft().isZeroLiteral())
	           setLeft(fexp);
	       else
	           setRight(fexp);
	   }
	   /* --------------- FEquation entries end here. --------------- */
	}
}