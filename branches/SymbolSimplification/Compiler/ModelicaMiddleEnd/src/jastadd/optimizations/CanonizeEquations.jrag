/**
 * An algorithm re-representing equations on canonical form.<p>
 * The canonical form currently supports the following features:<p>
 * <ul>
 *  <li>Transforming an equation f(x) = g(x) to the form h(x) = 0.</li>
 *  <li>Multiplication of all factors with the equation's GCD.</li>
 *  <ul>
 *      <li>Division expressions do not exist in the canonical form.</li>
 *  </ul>
 * </ul>
 * The canonical form is planned to include more features as listed below:<p>
 * <ul>
 *  <li>Parentheses removal.</li>
 *  <li>Re-ordering of the remaining terms in accordance to the following rules:</li>
 *  <ol>
 *      <li>Terms in multiplication are ordered alphabetically.</li>
 *      <ul>
 *          <li>Numerals are put lastly, regardless of the case of the other characters.</li>
 *      </ul>
 *      <li>Terms in addition are ordered according to their number of factors in descending order.</li>
 *  </ol>
 * </ul>
 * 
 * @author  Johan Calv√©n, Zimon Kuhs
 * @date    2016-02-0?
 * @version 0?
 */
 

 
aspect CanonizeEquations {
    
    public class CE extends OptimizingAlgorithm {
        public CE(FClass fclass) {
            super(fclass);
        }
        
        public boolean isUsed() {
           return fclass.myOptions().getBooleanOption("canonize_equations");
        }
        
        public boolean run(FAbstractEquation feq, FClass.WorkData workData) {
            fclass.canonizeEquations();
            return true;
        }
    }



    // Specifies whether the LHS or RHS should be zero.
    public static final boolean FClass.ZERO_LEFT = false;
    
    // Null avoidance (sort of Null-object).
    public static final FExp FExp.ZERO_EXP = new FIntegerLitExp(0);
    
    /* ---------------- Attribute list. ---------------- */
    
    /*
     *  Class identity attributes.
     */
    
    syn boolean FExp.isFExp() = true;
    syn boolean ASTNode.isFExp() = false;
    
    syn boolean FBinExp.isFBinExp() = true;
    syn boolean FExp.isFBinExp() = false;   
 
    syn boolean FExp.isFNegExp() = false;
    syn boolean FNegExp.isFNegExp() = true;

    syn boolean FAddExp.isFAddExp() = true;
    syn boolean FExp.isFAddExp() = false;
    
    syn boolean FSubExp.isFSubExp() = true;
    syn boolean FExp.isFSubExp() = false;

    syn boolean FMulExp.isFMulExp() = true;
    syn boolean FExp.isFMulExp() = false;

    syn boolean FDivExp.isFDivExp() = true;
    syn boolean FExp.isFDivExp() = false;

    /*
     * Casts.
     */
     
    syn FBinExp FExp.asFBinExp() = (FBinExp) this;
    syn FEquation FAbstractEquation.asFEquation() = (FEquation) this;
    
    /*
     * Within negative context.<p>
     * Tells whether or not the current expression's position
     * in an equation means it is negative or not.
     */
    
    // Top-level catchers.
    eq Root.getChild().withinNegativeContext() = false;
    eq FEquation.getChild().withinNegativeContext() = false;
    syn boolean ASTNode.withinNegativeContext() = false;

    eq FSubExp.getRight().withinNegativeContext() =
    	getParent() == null || !withinNegativeContext();
    eq FNegExp.getChild().withinNegativeContext() =
    	getParent() == null || !withinNegativeContext();
    
    inh boolean FExp.withinNegativeContext();
    inh boolean FIdUseExp.withinNegativeContext();
    inh boolean FIntegerLitExp.withinNegativeContext();
    
    /*
     * Descriptive tag.
     */

    syn boolean FExp.isLeftChildOfMul() { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FExp.lookupLeft(FExp child) { 
        if (parentFExp() == null) {
            return false;
        }
        return parentFExp().lookupLeft(this);
    }
    
    syn boolean FMulExp.lookupLeft(FExp child) {
        return child == getChild(0);
    }
    
    /*
     * Retrieves the side of an equation which isn't zero.<p>
     * Null in case both sides are actually defined.
     * 
     * @return      The side of an equation which isn't zero, i.e. the
     *                  "working" side of the equation. If the equation
     *                  is on the form (0 = 0), null is returned.
     */
    syn FExp FEquation.nonZeroSide() {
        if (getLeft().isZeroLiteral())
            return getRight();
        if (getRight().isZeroLiteral())
            return getLeft();
        return null;
    }
    
    /* ---------------- Attribute list end. ---------------- */
    
    public class FClass {
        private FExp denominator = FExp.ZERO_EXP;
        private boolean continueUp = false;
        
        /* ---------- FactorSet ---------- */
        
        /**
         * A set class for constants and variables which are joined in multiplication.<p>
         * By building sets of terms the structure of the original equation
         * can be maintained until the point where it should be re-organized,
         * avoiding creating new expressions until members of the old equation
         * (parents) are no longer needed.
         */ 
        private class FactorSet {
        	private HashSet<FExp> factors;
        	private boolean negated = false;
        
        	public FactorSet() {
        		factors = new HashSet<FExp>();
        	}
        
        	public FactorSet(FExp exp) {
        		factors = new HashSet<FExp>();
       			add(exp);
        	}
        	
        	/**
        	 * Creates an FMulExp of the current factors.<p>
        	 * 
        	 * @return	an FMulExp-tree containing all factors.
        	 */ 
        	public FExp multiply() {
				FExp mulExp = FExp.ZERO_EXP;

				// HashSet.get() doesn't exist so iteration is required.
				if (factors.size() == 1)
					for (FExp exp : factors)
						mulExp = exp;
				else
					mulExp = FExp.createBalancedBinaryTree(
						new FMulExp(), new ArrayList<FExp>(factors));
					
        		return negated ? new FNegExp(mulExp) : mulExp;
        	}
        	
        	/**
        	 * Conjoins two <code>FactorSet</code>s.<p>
        	 * 
        	 * @param fs	The <code>FactorSet</code> to join with this.
        	 */ 
        	public void merge(FactorSet fs) {
        		for (FExp f : fs.factors)
        			factors.add(f);
        		negated = negated || fs.negated;
        	}
        	
        	public void add(FExp exp) {
        		factors.add(exp);
        		negated = negated || exp.withinNegativeContext();
        	}
        }
        
        /* ---------- FactorSet End ---------- */
        
        /**
         * 	Transforms all equations in a model to canonical form.<p>
         */
        public void canonizeEquations() {
            for (FAbstractEquation equation: getFAbstractEquations()) {
	    	    if (!equation.isFEquation())
	    	      continue;
	    	    
	    	    FEquation feq = equation.asFEquation();
	    	    
	    	    debugPrintLn("Working on equation:\n" + equation.toString() + "\n");
	            
	    	    // Step 1. Move all expressions to RHS.
	    	    moveToOneSide(feq);
	    	    debugPrintLn("Moved to one side. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 2: Remove all DivExp.
	    	    eliminateDivision(feq);
	    	    debugPrintLn("Removed division. Eq:\n" + equation.toString() + "\n");
	    	    
	    	    // Step 3: Build a tree of only FAddExps and FMulExps.
	    	    toAddMulTree(feq);
	    	    debugPrintLn("Removed parentheses. Eq:\n" + equation.toString() + "\n");
	    	    
	        	// Step 4: Re-order terms.
	        	//reorderTerms(feq);
	        	//debugPrintLn("Re-ordered terms. Eq:\n" + equation.toString() + "\n");
	        	
	        	// Step 5: ...
            }
            debugPrintLn("Done canonizing equations.");
        }
    
	    /**
	     * Subtracts one side of an equation from both sides.<p>
	     * Transforms f(x) = g(x) to 0 = g(x) - f(x), or the opposite
	     * if <code>FClass.ZERO_LEFT</code> is true.
	     * 
	     * @param  feq The equation to transform.
	     * @see    FClass.ZERO_LEFT
	     */
	    private void moveToOneSide(FEquation feq) {
	        FExp left = feq.getLeft(), right = feq.getRight();
	        FExp newLHS = new FIntegerLitExp(0),
	        	newRHS = new FIntegerLitExp(0);
	        
	        if (ZERO_LEFT)
               newRHS = right.isZeroLiteral() ? left : new FSubExp(left, right);
	        else
	           newLHS = left.isZeroLiteral() ? right : new FSubExp(left, right);
	        
	        feq.setLeft(newLHS);
	        feq.setRight(newRHS);
	    }
    
	    /*
	     * Eliminates all divisions in an equation.<p>
	     * By recursively multiplying all division expressions with their denominators
	     * and propagating them upwards for multiplication with other nodes.
	     * 
	     * @param  feq The equation from which to remove divisions.
	     */
	    private void eliminateDivision(FEquation feq) {
	       FExp fexp = feq.nonZeroSide();
	        
	        // If the expression is only a variable, return.
	        if (!fexp.isFBinExp()) {
	           return;
	        }
	        
	        // If RHS is a FDivExp, we only have to replace it
	        // with its numerator.
	        if (fexp.isFDivExp()) {
	           FExp num = (FExp) fexp.getChild(0);
	           if (num.isFExp()) {
	               if (ZERO_LEFT) {
	                   feq.setRight(num);
	               } else {
	                   feq.setLeft(num);
	               }
	           }
	           return;
	         }
	        
	        boolean foundDiv = false;
	        
	        do {
	            foundDiv = divToMul(fexp, fexp);
	            continueUp = false;
	        } while (foundDiv);
	    }
    
	    /*
	     * Translates all division expressions of an equation to multiplication expressions.<p>
	     * Since the assumption that no expressions exists on one side of an equation all divisions
	     * can be removed, i.e. every fraction can be multiplied by the equation's GCD.
	     * 
	     * @param fexp			The expression which denominator should be evaluated.
	     * @param rootParent	The root expression, i.e. the lhs or rhs depending on <code>FClass.ZERO_LEFT</code>.
	     * @return	true if the current expression should propagate multiplication higher in the tree.
	     * @see		FClass.ZERO_LEFT (CanonizeEquations.jrag).
	     * 
	     * TODO: Not optimized atm. The algorithm is traversing the whole tree everytime this method is called.
	     *       This could be improved by tracking which paths we have already found and removed an FDivExp.
	     */
	    private boolean divToMul(FExp fexp, FExp rootParent) {
	        boolean foundDivLeft = false;
	        boolean foundDivRight = false;
	        boolean foundDiv = false;
	        
	        if (!fexp.isFBinExp())
	        	return false;
	        	
	        FBinExp bin = fexp.asFBinExp();
	        FExp leftChild = bin.getLeft(),
	        	rightChild = bin.getRight();
	    
	        if (leftChild.isFBinExp())
	            foundDivLeft = divToMul(leftChild, rootParent);

	        if (rightChild.isFBinExp() && !foundDivLeft)
	            foundDivRight = divToMul(rightChild, rootParent);
	        
	        foundDiv = foundDivLeft || foundDivRight;
	        
	        // Remove bottom FDivExp and insert FMulExps at correct places.
            if (!foundDiv && fexp.isFDivExp() && fexp != rootParent) {
                foundDiv = true;
                continueUp = true;
                denominator = rightChild;
                
                if (fexp.parentFExp().getChild(0) == fexp) {
                    fexp.parentFExp().setChild(leftChild, 0);
                } else {
                    fexp.parentFExp().setChild(leftChild, 1);
                }
            } else if (continueUp && (fexp.isFAddExp() || fexp.isFSubExp())) {
                if (foundDivLeft) {
                    fexp.setChild(new FMulExp(rightChild, denominator), 1);
                } else {
                    fexp.setChild(new FMulExp(leftChild, denominator), 0);
                }
            } else if (continueUp && foundDivRight && fexp.isFDivExp()) {
                continueUp = false;
                fexp.setChild(new FMulExp(leftChild, denominator), 0);
            }
	        
	        return foundDiv;
	    }
	    
	    /**
         *  Refactors and equation to only <code>FAddExp</code>s and <code>FMulExp</code>s.<p>
         *  Collects all of the multiplication factors of an equation and
		 *	transforms it to a summation of them. E.g. [a(b - c)(d - e)] will
		 *	be [abd + ace - abe - acd]. 
         *  
         *  @param feq  The equation to transform.
         */
         public void toAddMulTree(FEquation feq) {
	     	FExp fexp = feq.nonZeroSide();
	       
	       	// Collect all multiplied factors.
	       	HashSet<FactorSet> factors = getFactors(fexp);
			
			// Build a tree of FAddExps and FMulExps.
	       	FExp newFExp = createAddTree(factors);
	       
	       	// Update the equation.
	       	feq.setNonZeroSide(newFExp);
	    }
	    
	    /**
         *  Collects all multiplication terms in an expression.<p>
         *  A recursive method that starts with the entire equation (the exp argument
         *  should be the f(x) side of an equation on the form f(x) = 0) and continues
         *  to collect terms from both sides of a binary expression. If the expression
         *  argument is an <code>FIdUseExp</code> or <code>FIntegerLitExp</code> it is
		 *	put in a new <code>FactorSet </code> which is then returned.<p>
		 *	If the equation	is an <code>FAddExp</code> or an <code>FSubExp</code> the
		 *	<code>FactorSet</code>s are returned separated (within a <code>HashSet</code>).<p>
		 *	If the expression is an <code>FMulExp</code> the LHS and RHS factors are joined
		 *	together (representing multiplying the factors) in a new <code>FactorSet</code>.
         *
         *  @param exp  The expression from which to collect products.
         *  @return     A set containing all multiplied factors from lower in the recursion.
		 *	@see		FClass.FactorSet (CanonizeEquations.jrag).
         */
        private HashSet<FactorSet> getFactors(FExp exp) {
            HashSet<FactorSet> newSet = new HashSet<FactorSet>();
            
            // If the expression is a literal or a variable it constitutes a
            // new set of factors; a leaf is reached in the tree.
            if (!exp.isFBinExp()) {
            	FactorSet fs = new FactorSet(exp);
            	newSet.add(fs);
                return newSet;
            }
            
          	// Collect factors from LHS and RHS.
            FBinExp fbe = exp.asFBinExp();
            HashSet<FactorSet> leftFactors = getFactors(fbe.getLeft()),
                rightFactors = getFactors(fbe.getRight());
            
            // If the expression is a multiplication, join the FactorSets together.
            if (exp.isFMulExp()) {
            	HashSet<FactorSet> factors = new HashSet<FactorSet>();
                for (FactorSet leftSet : leftFactors) {
                    for (FactorSet rightSet : rightFactors) {
                    	FactorSet fs = new FactorSet();
                    	fs.merge(leftSet);
                    	fs.merge(rightSet);
                    	newSet.add(fs);
                    }
                }
                
            // Getting here the expression is either FAddExp or FSubExp.
            } else {
                newSet.addAll(leftFactors);
            	newSet.addAll(rightFactors);
            }
             
            return newSet;
		}
	    
	    /**
         *  Builds an <code>FAddExp</code>-tree with <code>FMulExp</code>s at the bottom.
         *
         *  @param factors  The set of <code>FactorSet</code>s with the multiplied terms
		 *						to build the tree with.
         *  @return     The top level addition or subtraction.
         */
	    private FExp createAddTree(HashSet<FactorSet> factors) {
	    	ArrayList<FExp> list = new ArrayList<FExp>();
	    	// Gather all factors from the FactorSets.
	    	for (FactorSet fs : factors)
	    		list.add(fs.multiply());
	    	
	    	FExp exp = FExp.ZERO_EXP;
	       	int length = list.size();
	       
	       	// If there is only one expression, return it.
	       	if (length == 1)
	        	exp = list.remove(0);
	        	
	        // If there is two expressions add them together.
	       	else if (length == 2)
	           	exp = new FAddExp(list.remove(0),
	            	list.remove(0));
	            	
	        // If there are numerous expressions, build an FAddExp-tree
	        // joining them all together.
	       	else
	        	exp = FExp.createBalancedBinaryTree(new FAddExp(), list);
	        	
	        return exp; 
	    }
	    
	    // TODO: Below.

        /**
         *  Re-orders all multiplied terms.<p>
         *
         *  @param feq  The equation containing multiplied terms.
         */
         public void reorderTerms(FEquation fe) {
            FExp exp = fe.nonZeroSide();
            
            if (!exp.isFBinExp())
                return;
                
            recursiveReorder((FBinExp) exp);
         }
         
         private void recursiveReorder(FBinExp exp) { 
            FExp left = exp.getLeft(), right = exp.getRight();
            
            if (exp.isFAddExp() || exp.isFSubExp()) {
                if (left.isFBinExp())
                    recursiveReorder((FBinExp) left);
                if (right.isFBinExp())    
                    recursiveReorder((FBinExp) right);
            } else if (exp.isFMulExp()) {
                reorderTerm((FMulExp) exp);
            }
         }
        
        /**
         *  Re-orders the factors in a multiplication term in alphabetical order.<p>
         *  
         *  @param exp  The parent node of a multiplication chain to re-order.
         */
         public void reorderTerm(FMulExp fme) {
            PriorityQueue<FIdUseExp> ids = new PriorityQueue<FIdUseExp>(
                0, new NameComparator());
                
            ArrayList<FIdUseExp> list = new ArrayList<FIdUseExp>();
            getFIdUses(fme, list);
            
            for (FIdUseExp fiue : list)
                ids.add(fiue);
                
            if (ids.size() <= 1)
                return;
                
            if (ids.size() == 2) {
                fme.setLeft(ids.poll());
                fme.setRight(ids.poll());
            } else {
                fme.setLeft(ids.poll());
                fme.setRight(buildProduct(ids));
            }
         }
         
         private void getFIdUses(FExp exp, ArrayList<FIdUseExp> list) {
            if (exp.isFIdUseExp()) {
                list.add((FIdUseExp) exp);
                return;
            }
            
            if (!exp.isFBinExp())
                return;
            
            FBinExp fexp = exp.asFBinExp();
            getFIdUses(fexp.getLeft(), list);
            getFIdUses(fexp.getRight(), list);    
         }
         
         private FExp buildProduct(PriorityQueue<FIdUseExp> list) {
            if (list.size() == 1)
                return list.poll();
            return new FMulExp(list.poll(), buildProduct(list));
         }
         
         /**
          * Comparator class for <code>FIdUse</code>s.<p>
          * Refers to the <code>String</code> comparator in order to sort
          * terms alphabetically.
          */
         private class NameComparator implements Comparator<FIdUseExp> {
            public int compare(FIdUseExp f1, FIdUseExp f2) {
                return (f1.name()).compareTo(f2.name());
            }
         }
        
        /* --------------- FClass entries end here. --------------- */
	}
	
	public class FEquation {
	   /**
        *  Sets a non-zero side of an equation to an <code>FExp</code>.<p>
        *  Since all equations in canonic form are on the form f(x) = 0,
        *  only one side of the equation should be managed. This method
        *  enables setting the relevant side of the equation to a new
        *  FExp irrespective of whether or not the left or right side
        *  is the "working" side.
        *
        *  @param fexp  The expression to set as the equation's new one.
        */
	   public void setNonZeroSide(FExp fexp) {
	       if (!getLeft().isZeroLiteral())
	           setLeft(fexp);
	       else
	           setRight(fexp);
	   }
	   /* --------------- FEquation entries end here. --------------- */
	}
}