/**
 *  Extremely good documentation in development!
 */

aspect OptimizingFramework {
    /**
     * Framework for optimizing algorithms.
     * 
     * Current added algorithms are:
     * 	- Alias Elimination
     *  - Variability Propagation
     * 
     * @author  Johan Calven, Zimon Kuhs
     * @date    2016-02-08
     * @version 0?
     */
    public class FClass {
    	// TODO: Debug data, remove later on:
        public static final boolean VERBOSE = true;
        public static String defaultIndent = "";
        public static boolean defaultShowFEq = false;
    	// ---------------------------------------------
    	
    	
        public class optimizingFrameworkIfSet extends Transformation {
            public optimizingFrameworkIfSet() {
                super("optimizing_framework");
            }
            
            public void perform() {
                runOptimizations();
            }
        }
    }
    
    /**
     * Optimizing algorithms that are added to the Optimizing Framework will have to
     * extend this class.
     */ 
    public abstract class OptimizingAlgorithm {
    	protected FClass fclass;
    	protected FClass.WorkData workData;
    	public OptimizingAlgorithm(FClass fclass, FClass.WorkData workData) {
    		this.fclass = fclass;
    		this.workData = workData;
    	}
    	
    	/*
    	 * Checks if the optimizing algorithm is enabled. The algorithm must have an option added
    	 * to the enum Default in {JModelica/Compiler/ModelicaFrontEnd/src/java/org/jmodelica/util/OptionRegistry.java}.
    	 * Use {fclass.myOptions().getBooleanOption("algorithm_name")} to check if its enabled.
    	 * @return {code true} if it is enabled, {code false} otherwise.
    	 */
    	public abstract boolean isUsed();
    	
    	/*
    	 * Starts the optimizing algorithm.
    	 * @param feq The equation to optimize.
    	 */
    	public abstract boolean run(FAbstractEquation feq);
    }
    
    public class FClass {
    	ArrayList<OptimizingAlgorithm> optimizeAlgorithmsInFramework = new ArrayList();
    	
    	/**
    	 * Optimizing algorithms that are used by the framework are added here.
    	 * @param workData	Data that is shared and updated in and between optimizing algorithms.
    	 */ 
    	public void addOptimizingAlgorithmsToFramework(WorkData workData) {
    		optimizeAlgorithmsInFramework.add(new AE(this, workData));
    		optimizeAlgorithmsInFramework.add(new VP(this, workData));
    	}
    	
	    /**
	     *  Main method for running the algorithms.<p>
		 *  
		 *  If an algorithm optimizes an equation, its caller method should return true and the
		 *  while loop will then continue with the next equation in worklist.
		 * 
		 *  A class called WorkData is kept for storing essential data needed in and shared between
		 *  the algorithms. This should be expanded if needed when adding a new algorithm to the framework.
	     */
	    public void runOptimizations() {
	    	LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet<FAbstractEquation>(); // all
	    	WorkData workData = new WorkData(worklist); // VP
	    	ArrayList<OptimizingAlgorithm> optList = new ArrayList();
			addOptimizingAlgorithmsToFramework(workData);
			CE canonizeEquations = new CE(this, workData);
				
	    	for (OptimizingAlgorithm optAlg: optimizeAlgorithmsInFramework)
	    		if (optAlg.isUsed())
	    			optList.add(optAlg);
	    	
	    	for (FAbstractEquation feq : getFAbstractEquations())
	    		workData.addToWorklist(feq);
	    	
	    	System.out.println("\n\n----------- NEW TEST --------------\n");  // TODO: Remove later
	    	
	    	if (canonizeEquations.isUsed())
	    		canonizeEquations.run(null);
	    	
	    	while (!worklist.isEmpty()) {
	    		FAbstractEquation feq = worklist.iterator().next();
	    		worklist.remove(feq);
	    		System.out.println("Equation: "+feq.toString()); // TODO: Remove later
	    		
	    		for (OptimizingAlgorithm optAlg : optList)
	    			if (optAlg.run(feq))
	    				continue;
	        }
	        
	        fixStructure();
	    }
	    
	    /**
		 * Class that contains data that is shared and updated in and between optimizing algorithms.
		 *
		 * When adding a new algorithm to the framework, update this class with needed methods 
		 * and variables.
		 */
	    public class WorkData {
	    	private LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();	// Used by AE, VP
	        private ArrayList<FAbstractEquation> parameterEquations = new ArrayList(); 	// Used by VP
	        private HashSet<FAbstractEquation> removedEquations = new HashSet();		// Used by AE, VP
	        
	        /**
	         * Constructs a class containing data needed throughout the execution time 
	         * of the optimizing algorithms, that are added to the framework. 
	         */
	        public WorkData(LinkedHashSet<FAbstractEquation> worklist) {
	            this.worklist = worklist;
	            for (FAbstractEquation feq : getFParameterEquations())
	            	parameterEquations.add(feq);
	        }
	        
	        /**
			 * If an equation is switched to a parameter equation it should be
			 * added to this list.
			 * @param feq The equation that is added to the parameter equations list.
			 */
	        public void addParameterEquation(FAbstractEquation feq) {
	            parameterEquations.add(feq);
	        }
	        
	        /**
			 * Method to add an equation to the worklist.
			 */
	        public void addToWorklist(FAbstractEquation feq) {
	            worklist.add(feq);
	        }
	        
	        /**
			 * Checks if an equation has been removed by one of
			 * the optimizing algorithms.
			 * @param feq The equation that is checked. 
			 * @return {@code true} if it has been removed, {@code false} otherwise.
			 */
	        public boolean hasRemovedEquation(FAbstractEquation feq) {
	        	return removedEquations.contains(feq);
	        }
	        
	        /**
			 * Adds an equation to the list of removed equations.
			 * @param feq The equation that is added to the list of removed equations.
			 */
	        public void removeEquation(FAbstractEquation feq) {
	        	removedEquations.add(feq);
	        }
	        
	        /**
			 * Returns a list containing the parameter equations.
			 * @return The list containing all parameter equations. 
			 */
	        public List<FAbstractEquation> getparameterEquations() {
	        	return new List<FAbstractEquation>(parameterEquations);
	        }
	    }
	    
	    /**
		 * TODO: Does nothing atm. In future implementation, we could probably perform some
		 * rewrites after performing all the optimization. Atm, a rewrite is performed if an 
		 * algorithm changes the structure.
		 */
	    public void fixStructure() {
	    }
    }
    /**
     *  Utility method for learning the AST structure.
     *  <p>Prints the tree of all equations in the current model.
     *
     *  @param showFEq  If true, will display the equation string
     *                      before dumping the AST.
     *  @param indent   Base indentation of the dumped tree.
     */
     public void FClass.showTree(boolean showFEq, String indent) {
        for (FAbstractEquation fae : getFAbstractEquations()) {
            if (showFEq)
                System.out.println("<" + fae.toString() + ">");
            fae.dumpTree(indent);
        }
     }
     
     /**
     *  Utility method for learning the AST structure.
     *  <p>A No argument version of printTree() not printing the equation
     *  and using no identation. A "default" version of printTree(),
     */
     public void FClass.showTree() {
        showTree(defaultShowFEq, defaultIndent);
     }
     
     /**
      * Debug printing, will print message if VERBOSE is set.
      *
      * @param  msg The message to print.
      */
     public void FClass.debugPrintLn(String message) {
        if (VERBOSE)
            System.out.println(message);
     }
}