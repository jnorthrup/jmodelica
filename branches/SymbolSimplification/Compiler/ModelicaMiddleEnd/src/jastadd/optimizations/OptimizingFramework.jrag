/**
 * Framework for optimizing algorithms.<p>
 * 
 * Current added algorithms are:
 * <ul>
 * 	<li>Alias Elimination</li>
 *  <li>Variability Propagation</li>
 * </ul>
 *  
 * @author  Johan Calvén, Zimon Kuhs
 * @date	2016-02-08
 * @version 0?
 */
aspect OptimizingFramework {
    public class FClass {
        public class optimizingFrameworkIfSet extends Transformation {
            public optimizingFrameworkIfSet() {
                super("optimizing_framework");
            }
            
            public void perform() {
                runOptimizations();
            }
        }
    }
    
    /**
     * Optimizing algorithms that are added to the Optimizing Framework will have to
     * extend this class.
     */ 
    public abstract class OptimizingAlgorithm {
    	protected FClass fclass;
    	protected FClass.WorkData workData;
    	public OptimizingAlgorithm(FClass fclass, FClass.WorkData workData) {
    		this.fclass = fclass;
    		this.workData = workData;
    	}
    	
    	/*
    	 * Checks if the optimizing algorithm is enabled. The algorithm must have an option added
    	 * to the enum Default in {JModelica/Compiler/ModelicaFrontEnd/src/java/org/jmodelica/util/OptionRegistry.java}.
    	 * Use {fclass.myOptions().getBooleanOption("algorithm_name")} to check if its enabled.
    	 * 
    	 * @return {code true} if it is enabled, {code false} otherwise.
    	 */
    	public abstract boolean isUsed();
    	
    	/*
    	 * Starts the optimizing algorithm.<p>
    	 * 
    	 * @param feq	The equation to optimize.
    	 * @return	{@code true} if the equation was updated, {@code false} otherwise.
    	 */
    	public abstract boolean run(FAbstractEquation feq);
    }
    
    public class FClass {
    	ArrayList<OptimizingAlgorithm> optimizeAlgorithmsInFramework = new ArrayList();
    	
    	/**
    	 * Optimizing algorithms that are used by the framework are added here.
    	 * 
    	 * @param workData	Data that is shared and updated in and between optimizing algorithms.
    	 */ 
    	public void addOptimizingAlgorithmsToFramework(WorkData workData) {
    	 	optimizeAlgorithmsInFramework.add(new AliasEliminator(this, workData));
    		optimizeAlgorithmsInFramework.add(new VariabilityPropagator(this, workData));
    	}
    	
	    /**
	     *  Main method for running the algorithms.<p>
		 *  If an algorithm optimizes an equation, its caller method should return true and the
		 *  while loop will then continue with the next equation in worklist.<p>
		 *  A class called WorkData is kept for storing essential data needed in and shared between
		 *  the algorithms. This should be expanded if needed when adding a new algorithm to the framework.
	     */
	    public void runOptimizations() {
	    	LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet<FAbstractEquation>(); // all
	    	WorkData workData = new WorkData(worklist); // VP
	    	ArrayList<OptimizingAlgorithm> optList = new ArrayList();
			addOptimizingAlgorithmsToFramework(workData);
			Canonizer canonizer = new Canonizer(this, workData);
				
	    	for (OptimizingAlgorithm optAlg: optimizeAlgorithmsInFramework)
	    		if (optAlg.isUsed())
	    			optList.add(optAlg);
	    	
	    	for (FAbstractEquation feq : getFAbstractEquations())
	    		workData.addToWorklist(feq);
	    	
	    	System.out.println("\n\n----------- NEW TEST --------------\n");  // TODO: Remove later
	    	
	    	// If canonization is enabled it is performed before any algorithm.
	    	if (canonizer.isUsed())
	    		for (FAbstractEquation feq : getFAbstractEquations())
	    		canonizer.run(feq);
	    	
	    	while (!worklist.isEmpty()) {
	    		/* --- Felsökning --- */
	    		/*
	    		System.out.println("\tEquations in system:");
	    		for (FAbstractEquation feq : getFAbstractEquations())
	    			System.out.println("\t* " + feq.toString());
	    		System.out.println("\tEquations in worklist:");
		    	Iterator itr = worklist.iterator();
		    	while (itr.hasNext())
	    			System.out.println("\t* " + itr.next().toString());
	    		*/
	    		/* ------------------ */
	    			
	    		FAbstractEquation feq = worklist.iterator().next();
	    		worklist.remove(feq);
	    		System.out.println("Next equation to optimize: "+feq.toString()); // TODO: Remove later
	    		
	    		for (OptimizingAlgorithm optAlg : optList)
	    			if (optAlg.run(feq))
	    				break;
	        }
	        
	        fixStructure();
	    }
	    
	    /**
		 * Class that contains data that is shared and updated in and between optimizing algorithms.
		 *
		 * When adding a new algorithm to the framework, update this class with needed methods 
		 * and variables.
		 */
	    public class WorkData {
	    	// Used by AE, VP, VariabilityPropagator
	    	private LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();
	    	// Used by VP
	        private ArrayList<FAbstractEquation> parameterEquations = new ArrayList();
	        // Used by AE, VP, VariabilityPropagator
	        private HashSet<FAbstractEquation> removedEquations = new HashSet();
	        // Used by VariabilityPropagator
	        private boolean splitAliasParameters = !(myOptions().getBooleanOption("eliminate_alias_variables") 
                    && myOptions().getBooleanOption("eliminate_alias_parameters"));
            // Used by VariabilityPropagator
            private boolean splitAliasConstants  = !(myOptions().getBooleanOption("eliminate_alias_variables") 
                    && myOptions().getBooleanOption("eliminate_alias_constants"));
            
	        /**
	         * Constructs a class containing data needed throughout the execution time 
	         * of the optimizing algorithms, that are added to the framework.
			 *
			 * @param worklist	The working list of equations to modify with the algorithms.
	         */
	        public WorkData(LinkedHashSet<FAbstractEquation> worklist) {
	            this.worklist = worklist;
	            for (FAbstractEquation feq : getFParameterEquations())
	            	parameterEquations.add(feq);
	        }
			
			/*
			 * Getter for the <code>splitAliasParameters</code> boolean.
			 *
			 * @return	the constant.
			 */
			public boolean splitAliasParameters() {
                return splitAliasParameters;
            }
            
            /*
			 * Getter for the <code>splitAliasConstants</code> boolean.
			 *
			 * @return	the constant.
			 */
            public boolean splitAliasConstants() {
                return splitAliasConstants;
            }
				        
	        /**
			 * If an equation is switched to a parameter equation it should be
			 * added to this list.
			 *
			 * @param feq The equation that is added to the parameter equations list.
			 */
	        public void addParameterEquation(FAbstractEquation feq) {
	            parameterEquations.add(feq);
	        }
	        
	        /**
			 * Method to add an equation to the worklist.
			 *
			 * @param feq	The equation to be added.
			 */
	        public void addToWorklist(FAbstractEquation feq) {
	            worklist.add(feq);
	        }
	        
	        /**
			 * Checks if an equation has been removed by one of
			 * the optimizing algorithms.
			 *
			 * @param feq The equation that is checked. 
			 * @return {@code true} if it has been removed, {@code false} otherwise.
			 */
	        public boolean hasRemovedEquation(FAbstractEquation feq) {
	        	return removedEquations.contains(feq);
	        }
	        
	        /**
			 * Adds an equation to the list of removed equations.
			 *
			 * @param feq The equation that is added to the list of removed equations.
			 */
	        public void removeEquation(FAbstractEquation feq) {
	        	removedEquations.add(feq);
	        }
	        
	        /**
			 * Returns a list containing the parameter equations.
			 *
			 * @return The list containing all parameter equations. 
			 */
	        public List<FAbstractEquation> getparameterEquations() {
	        	return new List<FAbstractEquation>(parameterEquations);
	        }
	    }
	    
	    /**
		 * TODO: Does nothing atm. In future implementation, we could probably perform some
		 * rewrites after performing all the optimization. Atm, a rewrite is performed if an 
		 * algorithm changes the structure.
		 */
	    public void fixStructure() {}
    }
}