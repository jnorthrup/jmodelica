     /**
     * Simple implementation of the Variable Propatation Algorithm.
     * 
     * @author  Johan Calven, Zimon Kuhs
     * @date    2016-02-16
     * @version 0?
     */
aspect VP {
    //public boolean FAbstractVariable.removeEquationBySimpleVP	= false; // Not implemented
    //public boolean FFunctionCallLeft.removeEquationBySimpleVP = false; // Not implemented
    //public boolean FExp.removeEquationBySimpleVP              = false; // Not implemented

    syn boolean FAbstractEquation.canSimplePropagateEquation() = false;
    syn boolean FEquation.canSimplePropagateEquation() {
        return variables().size() == 1; 
    }
    
    syn boolean FAbstractVariable.canSimplePropagateVariable() = false;
    syn boolean FVariable.canSimplePropagateVariable() {
        return !isDerivativeVariable();
    }
    
    public class VP extends OptimizingAlgorithm {
    	public VP(FClass fclass) {
    		super(fclass);
    	}
    	
    	public boolean isUsed() {
    		return fclass.myOptions().getBooleanOption("simple_vp");
    	}
    	
    	public boolean run(FAbstractEquation feq, FClass.WorkData workData) {
            return doVP(feq, workData);
    	}
    	
        /**
         * Performs the simple Variability Propagation (VP) algorithm.
         * @param feq The equation to perform VP on.
         * @param workData Data that has to be stored and updated by VP.
         * @return {@code true} if VP could be performed, {@code false} otherwise.
         */
        public boolean doVP(FAbstractEquation feq, FClass.WorkData workData) {
            if (feq.canSimplePropagateEquation() && feq.simpleVariabilityPropagation(workData)) {
            	fixVP(workData);
            	return true;
            }
            return false;
        }
        
        /**
         * Fixes the structure that has been altered after performing VP. Also performs 
         * Constant Folding to the equations and do rewrites.
         * @param workData Data that is updated by VP.
         */
        public void fixVP(FClass.WorkData workData) {
	        fixStructure(workData);
	    	fclass.simpleConstantFolding();
	        fclass.forceRewrites();
	        fclass.root().flushAllRecursiveClearFinal();
        }
        
        /**
         * Updates the structure of different lists in FClass.
         * @param workData Data that is updated by VP.
         */
        public void fixStructure(FClass.WorkData workData) {
            //ArrayList<FVariable> newVariables = new ArrayList(); 		// not implemented in this version
            //ArrayList<FVariable> newAliases = new ArrayList(); 		// not implemented in this version
            ArrayList<FAbstractEquation> newEquations = new ArrayList();
            
            // Only equations not flagged for removal should be kept.
            for (FAbstractEquation feq : fclass.getFAbstractEquations()) {
                if (!workData.hasRemovedEquation(feq)) {
                    newEquations.add(feq);
                }
            }
            fclass.setFAbstractEquationList(new List<FAbstractEquation>(newEquations));
            fclass.setFParameterEquationList(workData.getparameterEquations());
        }
        
    }
    
    /**
     * Implemented in the subclass FEquation.
     * @return {@code true} if VP could be performed, {@code false} otherwise.
     */
    public boolean FAbstractEquation.simpleVariabilityPropagation(FClass.WorkData workData) {
    	return false;
    }
    
    /**
     * Checks if the solution for the variable can be found at compile time. If so, the 
     * variable is a constant. If not, the variable is a parameter(?).
     * @param workData Data that is stored and updated by VP.
     * @return {@code true} if VP be performed, {@code false} otherwise.
     */
    public boolean FEquation.simpleVariabilityPropagation(FClass.WorkData workData) {
        FVariable fvar = variables().iterator().next();
        if (fvar.canSimplePropagateVariable()) {
            FExp solution = solution(fvar);
            solution.resetOriginalReferences();
            FTypePrefixVariability solutionVariability = solution.variability();
            
            // Check if our variable is a constant or parameter
            if (solutionVariability.constantVariability()) {
            	System.out.println("constant variable");
                solution = solution.ceval().buildLiteral();
                fvar.setBindingExp(solution);
            } else if (solutionVariability.parameterVariability()) {
            	System.out.println("parameter variable");
                solutionVariability = fParameter();
                workData.addParameterEquation(new FEquation(fvar.createUseExp(), solution));
            } else {
                return false;
            }
            
            fvar.simpleVariabilityPropagation(solution, solutionVariability, workData);
            return true;
        }
        return false;
    }
    
    /**
     * All the uses of a variable is checked to see if it belongs to an equation. If so, the 
     * variable is removed from the list of variables in the equation. If the number of variables 
	 * left in the list are 0, the equation is removed. Otherwise, the equation is added to the worklist.
	 * @param solutionVariability The variability of the variable.
	 * @param workData Data that is stored and updated by VP.
     */
    public void FVariable.simpleVariabilityPropagation(FExp solution, FTypePrefixVariability solutionVariability,
                                                        FClass.WorkData workData) {
        FAbstractEquation feq;
        setFTypePrefixVariability(solution.variability());
        
        for (FIdUseExp use : uses()) {
            if (use.inFEquation()) {
                feq = use.myFEquation();
                if (workData.hasRemovedEquation(feq)) {
                	continue;
                }
                
                feq.variables().remove(this);
                if (feq.variables().size() == 0) { // tag equation to be removed further ahead.
                	System.out.println("Equation was flagged to be removed: "+feq.toString());  // TODO: Remove later
                    workData.removeEquation(feq);
                } else {
	                System.out.println("Equation was added to worklist: "+feq.toString());  // TODO: Remove later
    	            workData.addToWorklist(feq);
                }
            }
        }
    }
}

// Content below is copied from VariabilityPropagation.jrag
aspect ConstFold {
    public boolean FAbstractExp.simpleConstantFoldingEnabled = false;
    
    public void ASTNode.simpleConstantFolding() {
        for (ASTNode n : this)
            n.simpleConstantFolding();
    }

    public void FAbstractExp.simpleConstantFolding() {
        if (variability().knownParameterOrLess()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }
    
    public void FIdUseExp.simpleConstantFolding() {
        if (type().isString()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }
    
    public void FFunctionDecl.simpleConstantFolding() {
        
    }
    
    public void FFunctionCallEquation.simpleConstantFolding() {
        for (FExp childExp : getCall().childFExps()) {
            childExp.simpleConstantFolding();
        }
    }
    
    public void FPartialFunctionCall.simpleConstantFolding() {
        for (ASTNode n : this)
            n.simpleConstantFolding();
    }

    public void FPreExp.simpleConstantFolding() {
        if (variability().parameterOrLess()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
    }
    
    rewrite FAbstractExp {
        when (simpleConstantFoldingEnabled && variability().knownParameterOrLess()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }

    rewrite FIdUseExp {
        when (simpleConstantFoldingEnabled && type().isString()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
                compliance("Could not evaluate string variable " + name());
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }
}