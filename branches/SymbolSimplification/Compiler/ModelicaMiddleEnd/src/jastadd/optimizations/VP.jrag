     /**
     * Simple implementation of the Variable Propatation Algorithm.
     * 
     * @author  Johan Calven, Zimon Kuhs
     * @date    2016-02-16
     * @version 0?
     */
aspect VP {
    public boolean FFunctionCallEquation.shouldCleanUp              = false;
    public boolean FAbstractEquation.usedInVariabilityPropagation   = false;
    public boolean FAbstractVariable.usedInVariabilityPropagation   = false;
    public boolean FFunctionCallLeft.usedInVariabilityPropagation   = false;
    public boolean FExp.usedInVariabilityPropagation                = false;


    public void FClass.VP() {
            System.out.println("VP being implemented.");
            simpleVariablityPropagation();
            simpleConstantFolding();
            //forceRewrites();
            root().flushAllRecursiveClearFinal();
    }
    
    syn boolean FAbstractEquation.canSimplePropagateEquation() = false;
    syn boolean FEquation.canSimplePropagateEquation() {
        return variables().size() == 1; 
    }
    
    syn boolean FAbstractVariable.canSimplePropagateVariable() = false;
    syn boolean FVariable.canSimplePropagateVariable() {
        return !isDerivativeVariable();
    }
    
    public class FClass {
        /**
         * Starts the constant propagation algorithm and continues as long as there are
         * equations left in the worklist.
         */
        public void simpleVariablityPropagation() {
            LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();   
            List<FAbstractEquation> parameterEquations = getFParameterEquations();
            FClass.SimpleVariabilityPropagator prop = new FClass.SimpleVariabilityPropagator(worklist, parameterEquations);
            
            initWorklist(prop);
            
            // Start propagating
            while (!worklist.isEmpty()) {
                FAbstractEquation feq = worklist.iterator().next();
                try {
                    feq.simpleVariabilityPropagation(prop);
                } catch (CantSimplePropagateException e) {
                    worklist.clear();
                    System.out.println("Error caught:\n\t"+e.getMessage());
                }
                worklist.remove(feq);
            }
            
            // Fix Hybrid DAE
            cleanUp();            
        }
        
        
        public void cleanUp() {
            System.out.println("Step into cleanUp()");
            ArrayList<FVariable> newVariables = new ArrayList();
            ArrayList<FVariable> newAliases = new ArrayList();
            ArrayList<FAbstractEquation> newEquations = new ArrayList();
            
            /*
            for (FVariable fVariable: getFVariables()) {
                if (!fVariable.taggedByVProp) {
                    newVariables.add(fVariable);
                }
            }
            setFVariableList(new List<FVariable>(newVariables));
            */
            System.out.println("\tGoing through equation list");
            for (FAbstractEquation feq : getFAbstractEquations()) {
                System.out.print("\t\tequation: "+feq.toString());
                if (!feq.usedInVariabilityPropagation) {
                    System.out.println(" was kept");
                    newEquations.add(feq);
                } else {
                    System.out.println(" was NOT kept");
                }
            }
            setFAbstractEquationList(new List<FAbstractEquation>(newEquations));
        }
        
        
        /**
         * Sets up the worklist at the beginning of the algorithm. All equations that 
         * only contains one variable are added to the worklist.
         */
        public void initWorklist(FClass.SimpleVariabilityPropagator prop) {
            for (FAbstractEquation feq : getFAbstractEquations())
            if (feq.canSimplePropagateEquation()) {
                prop.addWorkEq(feq);
                System.out.println("Equation added to worklist:\n\t" + feq.toString());
            }
        }
        
        /**
         * A class that contains the list of equations that can be propagate and a list of
         * equations that are found to be parameter equations. 
         */
        public class SimpleVariabilityPropagator {
            LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();
            List<FAbstractEquation> parameterEquations = new List();
            
            public SimpleVariabilityPropagator(LinkedHashSet<FAbstractEquation> worklist,
                                    List<FAbstractEquation> parameterEquations) {
                this.worklist = worklist;
                this.parameterEquations = parameterEquations;
            }
            
            public void addParamEq(FAbstractEquation fae) {
                parameterEquations.add(fae);
            }
            
            public void addWorkEq(FAbstractEquation fae) {
                worklist.add(fae);
            }
        }
    }
    
    /**
     * Implemented in the subclass FEquation.
     */
    public void FAbstractEquation.simpleVariabilityPropagation(FClass.SimpleVariabilityPropagator prop) 
        throws CantSimplePropagateException {}
    
    /**
     * Continuation of the simpleVariabilityPropagation method in FClass, taken to the level of FEquation.
     * Used in the simplified version of Variability Propagation algorithm.
     *
     * The equations that uses this method has only one variable, since it is picked from the
     * worklist with this requirement. 
     */
    public void FEquation.simpleVariabilityPropagation(FClass.SimpleVariabilityPropagator prop) 
            throws CantSimplePropagateException {
        System.out.println("Step into FEquation.simpleVariabilityPropagation(...)");
        FVariable fvar = variables().iterator().next();
        FExp solution = solution(fvar);
        solution.resetOriginalReferences();
        FTypePrefixVariability solutionVariability = solution.variability();
        System.out.println("\tvariability = "+solutionVariability.toString());
        
        if (fvar.canSimplePropagateVariable()) {
            System.out.println("\tcan propagate variable");
            if (solutionVariability.parameterVariability()) {
                try {
                    solution = solution.ceval().buildLiteral();
                } catch (ConstantEvaluationException e) {
                    solutionVariability = fParameter();
                }
                System.out.println("\t\tvariable is parameter");
                
                prop.addParamEq(new FEquation(fvar.createUseExp(), solution));
            }
        
            if (solutionVariability.constantVariability()) {
                System.out.println("\t\tvariable is constant");
                System.out.println("\t\t\tvar before adding binding exp: "+fvar.toString());
                fvar.setBindingExp(solution);
                System.out.println("\t\t\tvar after adding binding exp: "+fvar.toString());
            } else {
                throw new CantSimplePropagateException("Only functionality to handle constants " +
                                                       "is yet implemented.");
            }
            
            fvar.simpleVariabilityPropagation(solution, prop);
            
            //vd
        }
    }
    
    /**
     * Continuation of the simpleVariabilityPropagation method in FEquation, taken to the level of FVariable.
     * Used in the simplified version of Variability Propagation algorithm.
     */
    public void FVariable.simpleVariabilityPropagation(FExp solution, FClass.SimpleVariabilityPropagator prop) {
        System.out.println("step into FVariable.simpleVariabilityPropagation(...)");
        FAbstractEquation equation;
        System.out.println("\tvariable before variability change: " + this.toString());
        setFTypePrefixVariability(solution.variability());
        System.out.println("\tvariable after variability change: " + this.toString());
        
        for (FIdUseExp use : uses()) {
            if (use.inFEquation()) {
                System.out.println("\tvariable is in an eq");
                equation = use.myFEquation();
                System.out.println("\t\teq before: "+equation);
                equation.variables().remove(this);
                System.out.println("\t\teq after: "+equation);
                if (equation.canSimplePropagateEquation()) {
                    System.out.println("\t\tadded eq to worklist: "+equation);
                    prop.addWorkEq(equation);
                } else if (equation.variables().size() == 0) {
                    System.out.println("\t\ttagged eq for cleanup: "+equation);
                    equation.usedInVariabilityPropagation = true;
                }
            }
        }
    }
    
    /**
     * Exception that should be throwned when using this simplified version of Variability Propagation
     * on equations that is not supported yet.
     */
    public class CantSimplePropagateException extends Exception {
        public CantSimplePropagateException(String message, Throwable throwable) {
            super(message, throwable);
        }
        
        public CantSimplePropagateException(String message) {
            super(message);
        }
    }
}

aspect ConstFold {
    public boolean FAbstractExp.simpleConstantFoldingEnabled = false;
    
    public void ASTNode.simpleConstantFolding() {
        for (ASTNode n : this)
            n.simpleConstantFolding();
    }

    public void FAbstractExp.simpleConstantFolding() {
        if (variability().knownParameterOrLess()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }
    public void FIdUseExp.simpleConstantFolding() {
        if (type().isString()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }

    rewrite FAbstractExp {
        when (simpleConstantFoldingEnabled && variability().knownParameterOrLess()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }

    rewrite FIdUseExp {
        when (constantFoldingEnabled && type().isString()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
                compliance("Could not evaluate string variable " + name());
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }
}