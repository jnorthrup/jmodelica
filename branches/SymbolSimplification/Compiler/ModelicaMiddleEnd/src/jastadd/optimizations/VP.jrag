     /**
     * Simple implementation of the Variable Propatation Algorithm.
     * 
     * @author  Johan Calven, Zimon Kuhs
     * @date    2016-02-16
     * @version 0?
     */
aspect VP {
    public boolean FFunctionCallEquation.shouldCleanUp              = false;
    public boolean FAbstractEquation.removeEquationBySimpleVP       = false;
    public boolean FAbstractVariable.usedInVariabilityPropagation   = false;
    public boolean FFunctionCallLeft.usedInVariabilityPropagation   = false;
    public boolean FExp.usedInVariabilityPropagation                = false;


    public void FClass.VP() {
            simpleVariablityPropagation();
            simpleConstantFolding();
            forceRewrites();
            root().flushAllRecursiveClearFinal();
    }
    
    syn boolean FAbstractEquation.canSimplePropagateEquation() = false;
    syn boolean FEquation.canSimplePropagateEquation() {
        return variables().size() == 1; 
    }
    
    syn boolean FAbstractVariable.canSimplePropagateVariable() = false;
    syn boolean FVariable.canSimplePropagateVariable() {
        return !isDerivativeVariable();
    }
    
    public class FClass {
        /**
         * Starts the constant propagation algorithm and continues as long as there are
         * equations left in the worklist.
         */
        public void simpleVariablityPropagation() {
            LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();   
            List<FAbstractEquation> parameterEquations = getFParameterEquations();
            FClass.SimpleVariabilityPropagator prop = new FClass.SimpleVariabilityPropagator(worklist, parameterEquations);
            
            initWorklist(prop);
            
            // Start variability propagation.
            while (!worklist.isEmpty()) {
                FAbstractEquation feq = worklist.iterator().next();
                try {
                    feq.simpleVariabilityPropagation(prop);
                } catch (CantSimplePropagateException e) {
                    worklist.clear();
                    System.out.println("Error caught:\n\t"+e.getMessage());
                }
                worklist.remove(feq);
            }
            
            // Remove unnessecary equations
            fixEquations();
        }
        
        
        public void fixEquations() {
            ArrayList<FVariable> newVariables = new ArrayList();
            ArrayList<FVariable> newAliases = new ArrayList();
            ArrayList<FAbstractEquation> newEquations = new ArrayList();
            
            // Only equations not flagged for removal should be kept.
            for (FAbstractEquation feq : getFAbstractEquations()) {
                if (!feq.removeEquationBySimpleVP) {
                    newEquations.add(feq);
                }
            }
            setFAbstractEquationList(new List<FAbstractEquation>(newEquations));
        }
        
        
        /**
         * Sets up the worklist at the beginning of the algorithm. All equations that 
         * only contains one variable are added to the worklist.
         */
        public void initWorklist(FClass.SimpleVariabilityPropagator prop) {
            for (FAbstractEquation feq : getFAbstractEquations())
            if (feq.canSimplePropagateEquation()) {
                prop.addToWorklist(feq);
            }
        }
        
        /**
         * A class that contains the list of equations that can be propagate and a list of
         * equations that are found to be parameter equations. 
         */
        public class SimpleVariabilityPropagator {
            LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();
            List<FAbstractEquation> parameterEquations = getFParameterEquations();
            
            public SimpleVariabilityPropagator(LinkedHashSet<FAbstractEquation> worklist,
                                    List<FAbstractEquation> parameterEquations) {
                this.worklist = worklist;
                this.parameterEquations = parameterEquations;
            }
            
            public void addParameterEquation(FAbstractEquation feq) {
                parameterEquations.add(feq);
            }
            
            public void addToWorklist(FAbstractEquation feq) {
                worklist.add(feq);
            }
        }
    }
    
    /**
     * Implemented in the subclass FEquation.
     */
    public void FAbstractEquation.simpleVariabilityPropagation(FClass.SimpleVariabilityPropagator prop) 
                                                                throws CantSimplePropagateException {}
    
    /**
     * Continuation of the simpleVariabilityPropagation method in FClass, taken to the level of FEquation.
     * Used in the simplified version of Variability Propagation algorithm.
     *
     * Here we check if we can find the solution for the variable at compile time. If we can, our 
     * variable is a constant. If we can not, our variable is a parameter(?).
     */
    public void FEquation.simpleVariabilityPropagation(FClass.SimpleVariabilityPropagator prop) 
                                                        throws CantSimplePropagateException {
        FVariable fvar = variables().iterator().next();
        if (fvar.canSimplePropagateVariable()) {
            FExp solution = solution(fvar);
            solution.resetOriginalReferences();
            FTypePrefixVariability solutionVariability = solution.variability();
            
            // Check if our variable is a constant or variable
            if (solutionVariability.constantVariability()) {
                solution = solution.ceval().buildLiteral();
                fvar.setBindingExp(solution);
            } else if (solutionVariability.parameterVariability()) {
                solutionVariability = fParameter();
                prop.addParameterEquation(new FEquation(fvar.createUseExp(), solution));
            } else {
                throw new CantSimplePropagateException("Only functionality to handle constants " +
                                                       "is yet implemented.");
            }
            
            fvar.simpleVariabilityPropagation(solution, solutionVariability, prop);
        }
    }
    
    /**
     * Continuation of the simpleVariabilityPropagation method in FEquation, taken to the level of FVariable.
     * Used in the simplified version of Variability Propagation algorithm.
     * 
     * Here we go through all the uses of our variable and see if it belongs to an equation. If so, the 
     * variable is removed from the variables list of the equation. Then we check the number of 
     * variables that are still left in the variables list of the equation.
     * 1 variable = send equation to worklist.
     * 0 variables = flag equation for removal.
     */
    public void FVariable.simpleVariabilityPropagation(FExp solution, FTypePrefixVariability solutionVariability,
                                                        FClass.SimpleVariabilityPropagator prop) {
        FAbstractEquation equation;
        setFTypePrefixVariability(solution.variability());
        
        for (FIdUseExp use : uses()) {
            if (use.inFEquation()) {
                equation = use.myFEquation();
                equation.variables().remove(this);
                if (equation.canSimplePropagateEquation()) { // add to worklist if #variables has been reduced to 1.
                    prop.addToWorklist(equation);
                } else if (equation.variables().size() == 0) { // tag equation to be removed further ahead.
                    equation.removeEquationBySimpleVP = true;
                }
            }
        }
    }
    
    /**
     * Exception that should be throwned when using this simplified version of Variability Propagation
     * on equations that is not supported yet.
     */
    public class CantSimplePropagateException extends Exception {
        public CantSimplePropagateException(String message, Throwable throwable) {
            super(message, throwable);
        }
        
        public CantSimplePropagateException(String message) {
            super(message);
        }
    }
}

// Content below is copied from VariabilityPropagation.jrag
aspect ConstFold {
    public boolean FAbstractExp.simpleConstantFoldingEnabled = false;
    
    public void ASTNode.simpleConstantFolding() {
        for (ASTNode n : this)
            n.simpleConstantFolding();
    }

    public void FAbstractExp.simpleConstantFolding() {
        if (variability().knownParameterOrLess()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }
    
    public void FIdUseExp.simpleConstantFolding() {
        if (type().isString()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }

    rewrite FAbstractExp {
        when (simpleConstantFoldingEnabled && variability().knownParameterOrLess()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }

    rewrite FIdUseExp {
        when (constantFoldingEnabled && type().isString()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
                compliance("Could not evaluate string variable " + name());
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }
}