     /**
     * Simple implementation of the Variable Propatation Algorithm.
     * 
     * @author  Johan Calven, Zimon Kuhs
     * @date    2016-02-16
     * @version 0?
     */
aspect VP {
    //public boolean FAbstractVariable.removeEquationBySimpleVP	= false;
    //public boolean FFunctionCallLeft.removeEquationBySimpleVP = false;
    //public boolean FExp.removeEquationBySimpleVP              = false;

    syn boolean FAbstractEquation.canSimplePropagateEquation() = false;
    syn boolean FEquation.canSimplePropagateEquation() {
        return variables().size() == 1; 
    }
    
    syn boolean FAbstractVariable.canSimplePropagateVariable() = false;
    syn boolean FVariable.canSimplePropagateVariable() {
        return !isDerivativeVariable();
    }
    
    public class FClass {
        /**
         * Starts the constant propagation algorithm and continues as long as there are
         * equations left in the worklist.
         */
        public boolean VP(FAbstractEquation feq, WorkData workData) {
            if (feq.canSimplePropagateEquation()) {
            	return feq.simpleVariabilityPropagation(workData);
            }
            return false;
        }
        
        public void fixEquations(WorkData workData) {
            //ArrayList<FVariable> newVariables = new ArrayList(); 		// not implemented in this version
            //ArrayList<FVariable> newAliases = new ArrayList(); 		// not implemented in this version
            ArrayList<FAbstractEquation> newEquations = new ArrayList();
            
            // Only equations not flagged for removal should be kept.
            for (FAbstractEquation feq : getFAbstractEquations()) {
                if (!workData.hasRemovedEquation(feq)) {
                    newEquations.add(feq);
                }
            }
            setFAbstractEquationList(new List<FAbstractEquation>(newEquations));
            setFParameterEquationList(workData.getparameterEquations());
        }
        
        public void fixVP(WorkData workData) {
	        fixEquations(workData);
	    	simpleConstantFolding();
	        forceRewrites();
	        root().flushAllRecursiveClearFinal();
        }
    }
    
    /**
     * Implemented in the subclass FEquation.
     */
    public boolean FAbstractEquation.simpleVariabilityPropagation(FClass.WorkData workData) {
    	return false;
    }
    
    /**
     * Continuation of the simpleVariabilityPropagation method in FClass, taken to the level of FEquation.
     * Used in the simplified version of Variability Propagation algorithm.
     *
     * Here we check if we can find the solution for the variable at compile time. If we can, our 
     * variable is a constant. If we can not, our variable is a parameter(?).
     */
    public boolean FEquation.simpleVariabilityPropagation(FClass.WorkData workData) {
        FVariable fvar = variables().iterator().next();
        if (fvar.canSimplePropagateVariable()) {
            FExp solution = solution(fvar);
            solution.resetOriginalReferences();
            FTypePrefixVariability solutionVariability = solution.variability();
            
            // Check if our variable is a constant or parameter
            if (solutionVariability.constantVariability()) {
            	System.out.println("constant variable");
                solution = solution.ceval().buildLiteral();
                fvar.setBindingExp(solution);
            } else if (solutionVariability.parameterVariability()) {
            	System.out.println("parameter variable");
                solutionVariability = fParameter();
                workData.addParameterEquation(new FEquation(fvar.createUseExp(), solution));
            } else {
                return false;
            }
            
            fvar.simpleVariabilityPropagation(solution, solutionVariability, workData);
            return true;
        }
        return false;
    }
    
    /**
     * Continuation of the simpleVariabilityPropagation method in FEquation, taken to the level of FVariable.
     * Used in the simplified version of Variability Propagation algorithm.
     * 
     * Here we go through all the uses of our variable and see if it belongs to an equation. If so, the 
     * variable is removed from the variables list of the equation. Then we check the number of 
     * variables that are still left in the variables list of the equation.
     * 1 variable = send equation to worklist.
     * 0 variables = flag equation for removal.
     */
    public void FVariable.simpleVariabilityPropagation(FExp solution, FTypePrefixVariability solutionVariability,
                                                        FClass.WorkData workData) {
        FAbstractEquation feq;
        setFTypePrefixVariability(solution.variability());
        
        for (FIdUseExp use : uses()) {
            if (use.inFEquation()) {
                feq = use.myFEquation();
                if (workData.hasRemovedEquation(feq)) {
                	continue;
                }
                
                feq.variables().remove(this);
                if (feq.canSimplePropagateEquation()) { // add to worklist if #variables has been reduced to 1.
                	System.out.println("Equation was added to worklist: "+feq.toString());  // TODO: Remove later
                    workData.addToWorklist(feq);
                } else if (feq.variables().size() == 0) { // tag equation to be removed further ahead.
                	System.out.println("Equation was flagged to be removed: "+feq.toString());  // TODO: Remove later
                    workData.removeEquation(feq);
                }
            }
        }
    }
}

// Content below is copied from VariabilityPropagation.jrag
aspect ConstFold {
    public boolean FAbstractExp.simpleConstantFoldingEnabled = false;
    
    public void ASTNode.simpleConstantFolding() {
        for (ASTNode n : this)
            n.simpleConstantFolding();
    }

    public void FAbstractExp.simpleConstantFolding() {
        if (variability().knownParameterOrLess()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }
    
    public void FIdUseExp.simpleConstantFolding() {
        if (type().isString()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
        super.simpleConstantFolding();
    }
    
    public void FFunctionDecl.simpleConstantFolding() {
        
    }
    
    public void FFunctionCallEquation.simpleConstantFolding() {
        for (FExp childExp : getCall().childFExps()) {
            childExp.simpleConstantFolding();
        }
    }
    
    public void FPartialFunctionCall.simpleConstantFolding() {
        for (ASTNode n : this)
            n.simpleConstantFolding();
    }

    public void FPreExp.simpleConstantFolding() {
        if (variability().parameterOrLess()) {
            simpleConstantFoldingEnabled = true;
            is$Final = false;
            return;
        }
    }
    
    rewrite FAbstractExp {
        when (simpleConstantFoldingEnabled && variability().knownParameterOrLess()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }

    rewrite FIdUseExp {
        when (simpleConstantFoldingEnabled && type().isString()) to FExp {
            try {
                CValue value = ceval();
                if (!value.size().isEmpty()) 
                    return value.buildLiteral();
            } catch (ConstantEvaluationException e) {
                compliance("Could not evaluate string variable " + name());
            }
            simpleConstantFoldingEnabled = false;
            return this;
        }
    }
}