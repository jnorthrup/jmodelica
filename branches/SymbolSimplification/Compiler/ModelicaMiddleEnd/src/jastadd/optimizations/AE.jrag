    /**
     * Simple implementation of the Alias Elimination algorithm.
     * 
     * @author  Johan Calv√©n, Zimon Kuhs
     * @date    2016-02-08
     * @version 0?
     */
aspect AE {
    /**
     *  A simplified version of the alias elimination algorithm.
     */
    public void FClass.AE() {
            buildAliasSets();
            setupNewLists();
            doRewrites();
            flush();
    }

    public class FClass {
        Set<AliasSet> aliasSets = new HashSet<AliasSet>();
        HashMap<FVariable, Integer> scores = new HashMap<FVariable, Integer>();

        Set<FAbstractEquation> keepEquations = new HashSet<FAbstractEquation>();
        Set<FVariable> keepVariables = new HashSet<FVariable>();
        Set<FVariable> markedVariables = new HashSet<FVariable>();
        Set<FAbstractEquation> markedEquations = new HashSet<FAbstractEquation>();
        
        /**
         * An alias set. Any FVariables within (at least two) are
         * semantically equivalent in the current program.
         */
        public class AliasSet implements Iterable<FVariable> {
            private HashSet<FVariable> set;
            private FVariable bestVariable = null;

            /**
             * Creates a new alias set.
             */    
            public AliasSet(FVariable f1, FVariable f2) {
                set = new HashSet<FVariable>();
                scores = new HashMap<FVariable, Integer>();
                bestVariable = f1;
                add(f1);
                add(f2);
            }

            /**
             *  Adds a new variable to the alias set, also updating
             *  its score (use frequency).
             * 
             *  @param f    The variable to be added.
             */
            public void add(FVariable f) {
                set.add(f);
                
                if (f.occurances() > bestVariable.occurances())
                    bestVariable = f;
                else if (f.occurances() == bestVariable.occurances())
                    bestVariable = firstByName(f, bestVariable);
            }
            
            /**
             *  For a given set of aliases, calculates the
             *  best FVariable to replace the other ones.
             * 
             *  @return     The most fitting FVariable to
             *                  replace the aliases.
             */
             public FVariable bestVariable() {
                return bestVariable;
             } 
             
             /*
              * Returns the FVariable with the longest name,
              * or the alphabetical precedent if names are
              * equally long.
              */
             private FVariable firstByName(FVariable f1, FVariable f2) {
                if (f1 == f2)
                    return f1;
                    
                String name1 = f1.getName(), name2 = f2.getName();
                if (name1.length() > name2.length())
                    return f1;
                else if (name1.length() < name2.length())
                    return f2;
                
                for (int i = 0; i < name1.length(); ++i)
                    if (name1.charAt(i) < name2.charAt(i))
                        return f1;
                 return f1;
             }

            /**
             *  Returns true if the alias set already contains the variable.
             *  Used in AE to check whether or not new sets should be created
             *  or perhaps two sets should be merged.
             * 
             *  @return True if the alias set contains the variable.
             */
            public boolean contains(FVariable f) {
                return set.contains(f);
            }
            
            /**
             *  Returns an iterator over the FVariables within
             *  the alias set.
             * 
             *  @return     The iterator of the set containaing
             *                  the FVariables.
             */
            public Iterator<FVariable> iterator() {
                return set.iterator();
            }
            
            /**
             *  Returns a String representation of the alias set.
             *  Illustrated as an array.
             * 
             *  @return     A String that displays all elements in
             *                  the alias set as an array.
             */ 
            public String toString() {
                StringBuilder sb = new StringBuilder("[");
                
                for (FVariable f : set)
                        sb.append(f.getFQName().toString() + ", ");
                        
                return sb.delete(sb.length() - 2, sb.length())
                         .append("]").toString();
            }
            /* --------------- AliasSet ends here. --------------- */
        }
        
        /**
         *  Constructs all alias sets.
         */ 
        public void buildAliasSets() {
            for (FAbstractEquation fae : getFAbstractEquations()) {
                    if (!fae.isFEquation() || fae.variables().size() != 2)
                        continue;
            
                    FEquation fe = (FEquation) fae;
                    FExp left = fe.getLeft();
                    FExp right = fe.getRight();
                
                    if (!right.isFIdUseExp() || !left.isFIdUseExp())
                        continue;

                    FAbstractVariable lVar = ((FIdUseExp) left).myFV();
                    FAbstractVariable rVar = ((FIdUseExp) right).myFV();
                            
                    if (lVar.isFVariable() && rVar.isFVariable()) {
                            newAliasPair((FVariable) lVar, (FVariable) rVar);
                            markedEquations.add(fae);
                    }
                }
        }
        
        /**
         *  Returns the alias set that a variable belongs to.
         * 
         *  @param f    The variable which set is being sought.
         *  @return     The set if it was found, null otherwise.
         */
        public AliasSet getAliasSet(FVariable f) {
            for (AliasSet as : aliasSets)
                if (as.contains(f))
                    return as;
            return null;
        }
        
        /**
         * Returns whether or not a variable is an alias
         * to another, i.e. if it should be replaced by
         * another variable.
         * 
         * @param fv    The variable subject to the query.
         * @return      True if there exists a more suitable
         *                  name for the variable.
         */
         public boolean hasBetter(FVariable fvar) {
            AliasSet as = getAliasSet(fvar);
            if (as == null)
                return false;
            return as.bestVariable() != fvar;
         } 
                
        /**
         *  Merges two existing alias sets with each other.
         *
         *  @param a1   One of the alias sets.
         *  @param a2   The other alias set.
         */
        public void mergeAliasSets(AliasSet a1, AliasSet a2) {
            for (FVariable f : a2)
                a1.add(f);
            aliasSets.remove(a2);
        }
        
        /**
         *  Creates a new alias pair. If any of the variables is currently
         *  part of an alias set, the other one is added to it. If not,
         *  a new alias set is created.
         *  
         *  @param f1   One of the two alias variables.
         *  @param f2   The other alias variable.
         */
        public void newAliasPair(FVariable f1, FVariable f2) {
            AliasSet a1 = getAliasSet(f1), a2 = getAliasSet(f2);
        
            if (a1 != null)
                if (a2 != null)
                    // Both variables have an alias set, merge them.
                    mergeAliasSets(a1, a2);
                else
                    a1.add(f2);
            else
                if (a2 != null)
                    a2.add(f1);
                else
                    // Both variables have no alias set, make a new one.
                    aliasSets.add(new AliasSet(f1, f2));
        }
        
        /**
         *  Sets the new working equation and variables lists
         *  to represent the restructured system of equations.
         * 
         *  N.B. it is mandatory to update the alias variable
         *  list in the current implementation.
         */
        public void setupNewLists() {
            for (FVariable fv : getFVariables())
                if (hasBetter(fv))
                    markedVariables.add(fv);
                else
                    keepVariables.add(fv);
                    
            for (FAbstractEquation fae : getFAbstractEquations())
                if (!markedEquations.contains(fae))
                    keepEquations.add(fae);
        
            setFVariableList(new List(keepVariables));
            setAliasVariableList(new List(markedVariables));
            setFAbstractEquationList(new List(keepEquations));
        }
         
        /**
         * Returns whether or not an equation is marked
         * for removal due to being an alias equation.
         * 
         * @param fe    The equation subject to the query.
         * @return      True if the equation should be removed.
         */
         public boolean shouldBeRemoved(FEquation fe) {
            return markedEquations.contains(fe);
         }
         
         /* --------------- FClass entries end here. --------------- */
    }
    
    /* ---------------- Attribute list. ---------------- */
    
    /*
     *  Alias identity attributes.
     */
    eq Root.getChild().isAliasEquation(FAbstractEquation fae) = false;
    eq Root.getChild().isAliasVariable(FAbstractVariable fav) = false; 
    
    syn boolean FAbstractEquation.shouldBeRemoved() = isAliasEquation(this);
    syn boolean FAbstractVariable.hasReplacement() = isAliasVariable(this);
    inh boolean FAbstractEquation.isAliasEquation(FAbstractEquation fae);
    inh boolean FAbstractVariable.isAliasVariable(FAbstractVariable fav);

    eq FClass.getChild().isAliasEquation(FAbstractEquation fae) =
        fae.isFEquation() ? shouldBeRemoved((FEquation) fae) : false;

    eq FClass.getChild().isAliasVariable(FAbstractVariable fav) =
        fav.isFVariable() ? hasBetter((FVariable) fav) : false;

    /*
     *  Alias replacement attributes.
     */
    eq Root.getChild().fetchReplacement(FVariable fv) = null;
    eq FClass.getChild().fetchReplacement(FVariable fv) = getAliasSet(fv).bestVariable();
    syn FVariable FVariable.getReplacement() = fetchReplacement(this);
    inh FVariable FVariable.fetchReplacement(FVariable fv);

    /*
     *  Class identity attributes.
     */
    syn boolean ASTNode.isFEquation() = false;
    syn boolean FEquation.isFEquation() = true;
    syn boolean FExp.isFIdUseExp() = false;
    syn boolean FIdUseExp.isFIdUseExp() = true;
    
    /*
     *  Score calculation attributes.
     */
    eq Root.getChild().occurances(FVariable f) = 0;
    eq FClass.getChild().occurances(FVariable f) {
        int sum = 0;
        for (FAbstractEquation fae : getFAbstractEquations())
            for (FVariable fv : fae.variables())
                if (fv == f)
                    ++sum;
         return sum;
    }
    inh int FVariable.occurances(FVariable f);
    syn int FVariable.occurances() = occurances(this);
    
    /*
     *  QoL attributes.
     */
    syn String FVariable.getName() = getFQName().toString();
    
    /* ---------------- Attribute list end. ---------------- */
    
    /*
     *  Rewrite methods.
     */
     
    private boolean FIdUseExp.aliasRewrite = false;
    
    // Recursively call everything to rewrite.
    public void ASTNode.doRewrites() {
        for (ASTNode n : this)
            n.doRewrites();
    }
    
    // Only FIdUseExps are rewritten in the current implementation.
    public void FIdUseExp.doRewrites() {
        super.doRewrites();
        aliasRewrite = true;
        is$Final = false;
    }
    
    /*
     *  Rewrites a FIdUseExp to use a better alias
     *  if one exists.
     */
    rewrite FIdUseExp {
        when (aliasRewrite) to FExp {
            if (myFV().isFVariable() && myFV().hasReplacement()) {
                FVariable fv = (FVariable) myFV();
                FIdUseExp newFExp = fv.getReplacement().createUseExp();
                newFExp.setOriginalVariable(this, fv); 
                
                // The newly built expression needs to be further checked
                // in case other things should be re-written.
                newFExp.aliasRewrite = true;
                return newFExp.isNegated() ? new FNegExp(newFExp) : newFExp;
            }
            aliasRewrite = false;
            return this;
        }
    }
    
    /*
     *  Debug methods.
     */
     
    /**
     *  Prints all equations.
     */
    public void FClass.printAllEquations() {
        for (FAbstractEquation fae : getFAbstractEquations())
            System.out.println(fae.toString());
    }
    
    /**
     *  Prints all alias sets.
     */
    public void FClass.printAliasSets() {
        for (AliasSet as : aliasSets)
            System.out.println(as.toString());
    }
}