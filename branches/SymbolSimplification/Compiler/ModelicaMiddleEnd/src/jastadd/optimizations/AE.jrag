    /**
     * Simple implementation of the Alias Elimination algorithm.
     * 
     * @author  Johan Calv√©n, Zimon Kuhs
     * @date    2016-02-08
     * @version 0?
     */
aspect AE {
    /* ---------------- Attribute list. ---------------- */
    
    /*
     *  Alias identity attributes.
     */
    eq Root.getChild().isAliasVariable(FAbstractVariable fav) = false; 
    
    syn boolean FAbstractVariable.hasReplacement() = isAliasVariable(this);
    inh boolean FAbstractVariable.isAliasVariable(FAbstractVariable fav);

    eq FClass.getChild().isAliasVariable(FAbstractVariable fav) =
        fav.isFVariable() ? hasBetter(fav.asFVariable()) : false;

    /*
     *  Refined equations; required for rewrites to work.
     *  // TODO: Check if they are still needed. 
     */

    refine AliasVariables eq FVariable.isAlias() = refined() || isInAliasList();
    refine AliasVariables eq FVariable.alias() = refined() == null ? getReplacement() :
        refined();

    // Below are required for refinement to work.
    inh boolean FVariable.isInAliasList();
    eq FClass.getChild().isInAliasList()         = false;
    eq FForIndex.getChild().isInAliasList()      = false;
    eq FClass.getAliasVariable().isInAliasList() = true;
    eq FClass.getAliasConstant().isInAliasList() = true; 

    /*
     *  Alias replacement attributes.
     */
    eq Root.getChild().fetchReplacement(FVariable fv) = null;
    eq FClass.getChild().fetchReplacement(FVariable fv) = getAliasSet(fv).bestVariable();
    syn FVariable FVariable.getReplacement() = fetchReplacement(this);
    inh FVariable FVariable.fetchReplacement(FVariable fv);

    /*
     *  Class identity attributes.
     */
    syn boolean ASTNode.isFEquation() = false;
    syn boolean FEquation.isFEquation() = true;
    syn boolean FExp.isFIdUseExp() = false;
    syn boolean FIdUseExp.isFIdUseExp() = true;
    
    /*
     *  Score calculation attributes.
     */
    eq Root.getChild().occurances(FVariable f) = 0;
    eq FClass.getChild().occurances(FVariable f) {
        int sum = 0;
        for (FAbstractEquation fae : getFAbstractEquations())
            for (FVariable fv : fae.variables())
                if (fv == f)
                    ++sum;
         return sum;
    }
    inh int FVariable.occurances(FVariable f);
    syn int FVariable.occurances() = occurances(this);

    /* ---------------- Attribute list end. ---------------- */

	public class FClass {
		Set<AliasSet> aliasSets = new HashSet<AliasSet>();
        HashMap<FVariable, Integer> scores = new HashMap<FVariable, Integer>();

        Set<FAbstractEquation> keepEquations = new HashSet<FAbstractEquation>();
        Set<FVariable> keepVariables = new HashSet<FVariable>();
        Set<FVariable> markedVariables = new HashSet<FVariable>();
        Set<FAbstractEquation> markedEquations = new HashSet<FAbstractEquation>();
	}

    public class AE extends OptimizingAlgorithm {
		public AE(FClass fclass) {
    		super(fclass);
    	}
		
    	public boolean isUsed() {
    	   return fclass.myOptions().getBooleanOption("simple_ae");
    	}
    	
    	public boolean run(FAbstractEquation feq, FClass.WorkData workData) {
            return doAE(feq, workData);
    	}
        
        
        public boolean doAE(FAbstractEquation fae, FClass.WorkData workData) {
        	if (fclass.buildAliasSets(fae, workData)) {
        		fixAE(workData);
        		return true;
        	}
			return false;
	    }
		
		public void fixAE(FClass.WorkData workData) {
			fclass.setupNewLists(workData);
	        fclass.doRewrites();
	        fclass.flush();
		}
	}
        
    public class FClass {   
        /**
         * An alias set. Any FVariables within (at least two) are
         * semantically equivalent in the current program.
         */
        public class AliasSet implements Iterable<FVariable> {
            private HashSet<FVariable> set;
            private FVariable bestVariable = null;

            /**
             * Creates a new alias set.
             */
            public AliasSet(FVariable f1, FVariable f2) {
                set = new HashSet<FVariable>();
                scores = new HashMap<FVariable, Integer>();
                bestVariable = f1;
                add(f1);
                add(f2);
            }

            /**
             *  Adds a new variable to the alias set, also updating
             *  its score (use frequency).
             * 
             *  @param f    The variable to be added.
             */
            public void add(FVariable f) {
                set.add(f);
                
                if (f.occurances() > bestVariable.occurances())
                    bestVariable = f;
                else if (f.occurances() == bestVariable.occurances())
                    bestVariable = firstByName(f, bestVariable);
            }
            
            /**
             *  For a given set of aliases, calculates the
             *  best FVariable to replace the other ones.
             * 
             *  @return     The most fitting FVariable to
             *                  replace the aliases.
             */
             public FVariable bestVariable() {
                return bestVariable;
             } 
             
             /*
              * Returns the FVariable with the longest name,
              * or the alphabetical precedent if names are
              * equally long.
              */
             private FVariable firstByName(FVariable f1, FVariable f2) {
                if (f1 == f2)
                    return f1;
                    
                String name1 = f1.name(), name2 = f2.name();
                if (name1.length() > name2.length())
                    return f1;
                else if (name1.length() < name2.length())
                    return f2;
                
                for (int i = 0; i < name1.length(); ++i) {
                    char c1 = name1.charAt(i),
                        c2 = name2.charAt(i);
                    if (c1 < c2)
                        return f1;
                    else if (c1 > c2)
                        return f2;
                }
                
                return f1;
             }

            /**
             *  Returns true if the alias set already contains the variable.
             *  Used in AE to check whether or not new sets should be created
             *  or perhaps two sets should be merged.
             * 
             *  @return True if the alias set contains the variable.
             */
            public boolean contains(FVariable f) {
                return set.contains(f);
            }
            
            /**
             *  Returns an iterator over the FVariables within
             *  the alias set.
             * 
             *  @return     The iterator of the set containaing
             *                  the FVariables.
             */
            public Iterator<FVariable> iterator() {
                return set.iterator();
            }
            
            /**
             *  Returns a String representation of the alias set.
             *  Illustrated as an array.
             * 
             *  @return     A String that displays all elements in
             *                  the alias set as an array.
             */ 
            public String toString() {
                StringBuilder sb = new StringBuilder("[");
                
                for (FVariable f : set)
                        sb.append(f.getFQName().toString() + ", ");
                        
                return sb.delete(sb.length() - 2, sb.length())
                         .append("]").toString();
            }
            /* --------------- AliasSet end. --------------- */
        }
        
        /**
         *  Constructs all alias sets.
         */
         
        // TODO: Commentary.
        public boolean buildAliasSets(FAbstractEquation fae, WorkData workData) {
            if (!fae.isFEquation() || fae.variables().size() != 2)
                return false;
    
            FEquation fe = fae.asFEquation();
            FExp left = fe.getLeft();
            FExp right = fe.getRight();
        
            if (!right.isFIdUseExp() || !left.isFIdUseExp())
                return false;
			System.out.println("--- Performing AE ---");
            FAbstractVariable lVar = left.asFIdUseExp().myFV();
            FAbstractVariable rVar = right.asFIdUseExp().myFV();
                    
            if (lVar.isFVariable() && rVar.isFVariable()) {
                newAliasPair(lVar.asFVariable(), rVar.asFVariable());
                workData.removeEquation(fae);
                System.out.println("Equation was flagged to be removed: "+fae.toString());  // TODO: Remove later
	            return true;
            }
            return false;
        }
        
        /**
         *  Returns the alias set that a variable belongs to.
         * 
         *  @param f    The variable which set is being sought.
         *  @return     The set if it was found, null otherwise.
         */
        public AliasSet getAliasSet(FVariable f) {
            for (AliasSet as : aliasSets)
                if (as.contains(f))
                    return as;
            return null;
        }
        
        /**
         * Returns whether or not a variable is an alias
         * to another, i.e. if it should be replaced by
         * another variable.
         * 
         * @param fv    The variable subject to the query.
         * @return      True if there exists a more suitable
         *                  name for the variable.
         */
         public boolean hasBetter(FVariable fvar) {
            AliasSet as = getAliasSet(fvar);
            if (as == null)
                return false;
            return as.bestVariable() != fvar;
         } 
                
        /**
         *  Merges two existing alias sets with each other.
         *
         *  @param a1   One of the alias sets.
         *  @param a2   The other alias set.
         */
        public void mergeAliasSets(AliasSet a1, AliasSet a2) {
            for (FVariable f : a2)
                a1.add(f);
            aliasSets.remove(a2);
        }
        
        /**
         *  Creates a new alias pair. If any of the variables is currently
         *  part of an alias set, the other one is added to it. If not,
         *  a new alias set is created.
         *  
         *  @param f1   One of the two alias variables.
         *  @param f2   The other alias variable.
         */
        public void newAliasPair(FVariable f1, FVariable f2) {
            AliasSet a1 = getAliasSet(f1), a2 = getAliasSet(f2);
        
            if (a1 != null)
                if (a2 != null)
                    // Both variables have an alias set, merge them.
                    mergeAliasSets(a1, a2);
                else
                    a1.add(f2);
            else
                if (a2 != null)
                    a2.add(f1);
                else
                    // Both variables have no alias set, make a new one.
                    aliasSets.add(new AliasSet(f1, f2));
        }
        
        /**
         *  Sets the new working equation and variables lists
         *  to represent the restructured system of equations.
         */
         
        // TODO: Commentary.
        public void setupNewLists(WorkData workData) {
            // Clear sets since AE (FClass currently) holds them
            // (they will not be re-instantiated).
        	keepEquations.clear();
        	keepVariables.clear();
        	
            for (FVariable fv : getFVariables())
                if (hasBetter(fv)) {
                    markedVariables.add(fv);

                    // If AE removes a variable, all equations it exists in should be re-examined.
                    for (FIdUseExp use : fv.uses()) {
                    	FAbstractEquation fae;
           				if (use.inFEquation()) {
                			fae = use.myFEquation();
                			if (workData.hasRemovedEquation(fae)) {
                				continue;
                			}
                			System.out.println("Equation was added to worklist: "+fae.toString());
                			workData.addToWorklist(fae);
                		}
               		}
                } else {
                    keepVariables.add(fv);
                }                    
            for (FAbstractEquation fae : getFAbstractEquations()) {
                if (!workData.hasRemovedEquation(fae))
                    keepEquations.add(fae);
			}                
        
            setFVariableList(new List(keepVariables));
            setAliasVariableList(new List(markedVariables));
            setFAbstractEquationList(new List(keepEquations));
        }
         
         /* --------------- FClass entries end here. --------------- */
    }
    
    /*
     *  Rewrite methods.
     *
     *  The methods in the original AE has corresponding methods in this simple AE:
     *  
     *  isAlias         ->  hasReplacement
     *  alias           ->  getReplacement
     *  rewriteAlias    ->  aliasRewrite
     *
     *  All rewrites are simplified versions of the ones used in TransformCanonical.jrag.
     *  Negation is <i>not</i> in operation since <code>isNegated()</code> requires
     *  code used in the original AE, and thus will not work here.
     */
     
    public boolean FIdUseExp.aliasRewrite = false;
    public boolean FAssignStmt.aliasRewrite = false;
    
    // Recursively call everything to rewrite.
    public void ASTNode.doRewrites() {
        for (ASTNode n : this)
            n.doRewrites();
    }
    
    public void FIdUseExp.doRewrites() {
        super.doRewrites();
        aliasRewrite = true;
        is$Final = false;
    }
    
    // TODO: Commentary for all rewrites.    
    rewrite FIdUseExp {
        when (aliasRewrite) to FExp {
            if (myFV().isFVariable() && myFV().hasReplacement()) {
                FVariable fv = myFV().asFVariable();
                FIdUseExp newFExp = fv.getReplacement().createUseExp();
                newFExp.setOriginalVariable(this, fv); 
                newFExp.aliasRewrite = true;
                
                return newFExp;
            }
            aliasRewrite = false;
            return this;
        }
    }
    
    rewrite FPreExp {
        when (aliasRewrite) to FExp {
            if (myNonPreFV().isFVariable() && myNonPreFV().hasReplacement()) {
                FVariable fv = (FVariable) myNonPreFV();
                FIdUseExp new_exp = fv.getReplacement().createFPreExp();
                new_exp.setOriginalVariable(this, fv);
                
                return new_exp;
            } else {
                aliasRewrite = false;
                return this;
            }
        }
    }
    
    rewrite FAssignStmt {
        when (aliasRewrite && getLeft() instanceof FIdUseExp) to FAssignStmt {
            FIdUseExp left = (FIdUseExp) getLeft();
            if (left.myFV().isFVariable() && left.myFV().hasReplacement()) {
                FVariable fv = (FVariable) left.myFV();
                FIdUseExp exp = fv.getReplacement().createUseExp();
                setLeft(exp);
                exp.setOriginalVariable(left, fv);

                return this;
            } else {
                aliasRewrite = false;
                return this;
            }
        }
    }
    
    rewrite FAbstractDerExp {
        when (aliasRewrite && getFIdUse().myFV().isFVariable() && (myFV().hasReplacement() || getFIdUse().myFV().hasReplacement())) to FExp {
            if (myFV().hasReplacement()) {
                FVariable fv = (FVariable) myFV();
                FIdUseExp new_exp = fv.getReplacement().createUseExp();
                new_exp.setOriginalVariable(this, fv);
                
                return new_exp;
            } else {
                FQName new_name = (FQName)((FVariable)getFIdUse().myFV()).getReplacement().getFQName().fullCopy();
                FAbstractDerExp new_exp = createEmptyNode();
                new_exp.setFIdUse(new FIdUse(new_name));
                new_exp.setOrder(order());
                new_exp.setOriginalVariable(this, getFIdUse().myFV());
                
                return new_exp;
            }
        }
    }
}