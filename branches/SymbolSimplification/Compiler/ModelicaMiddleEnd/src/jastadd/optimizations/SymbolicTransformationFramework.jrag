/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
aspect SymbolicTransformationFramework {
    public class symbolicTransformationFramework extends FClass.Transformation {
        private static FClass fclass = null;
        private static ArrayList<Algorithm> algorithmsInFramework;
        private static Canonizer canonizer;
        
        public symbolicTransformationFramework(FClass fclass) {
            fclass.super("symbolic_transformation_framework");
            this.fclass = fclass;
            algorithmsInFramework = new ArrayList();
        }
        
        public void perform() {
            LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet<FAbstractEquation>();
            WorkData workData = new WorkData(worklist);
            ArrayList<Algorithm> algorithmList = new ArrayList();
            canonizer = new Canonizer(fclass, workData);
            addAlgorithmsToFramework(workData);
            
            // Collect algorithms that are enabled.
            for (Algorithm algorithm: algorithmsInFramework) {
                if (algorithm.isUsed()) {
                    algorithmList.add(algorithm);
                }
            }
            
            // Worklist will contain all equations at the beginning.
            workData.addAllToWorklist(fclass.getFAbstractEquations());
            
            preConfiguration(algorithmList);
            
            // Start using algorithms on the equations.
            while (!worklist.isEmpty()) {
                FAbstractEquation equation = worklist.iterator().next();
                worklist.remove(equation);
                
                for (Algorithm algorithm : algorithmList) {
                    if (algorithm.run(equation)) {
                        break;
                    }
                }
            }
            
            postConfiguration(algorithmList);
            change();
        }
        
        /**
         * Separate perform method for only running Alias Elimination. It is used in reduceIndex method
         * in FClass. 
         */ 
        public void performAliasElimination() {
            LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet<FAbstractEquation>();
            WorkData workData = new WorkData(worklist);
            AliasEliminator ae = new AliasEliminator(fclass, workData);
            
            workData.addAllToWorklist(fclass.getFAbstractEquations());
            
            ae.preRun();
            
            while (!worklist.isEmpty()) {
                FAbstractEquation equation = worklist.iterator().next();
                worklist.remove(equation);
                ae.run(equation);
            }
            
            ae.postRun();
            change();
        }
        
        /**
         *  Returns a copy of an FExp.<p>
         * 
         *  @param  exp the expression to copy.
         */
         public static FExp symbolicCopy(FExp exp) {
            return exp.treeCopy();
        }
        
        /**
         * Algorithms that are used by the framework are added here.
         * 
         * @param workData Data that is shared and updated in and between algorithms.
         */ 
        private void addAlgorithmsToFramework(WorkData workData) {
            algorithmsInFramework.add(new AliasEliminator(fclass, workData));
            algorithmsInFramework.add(new VariabilityPropagator(fclass, workData));
            algorithmsInFramework.add(canonizer);
        }
        
        /*
         *  Performs methods that are required before all algorithms have run.<p>
         */
        private void preConfiguration(ArrayList<Algorithm> algorithms) {
            for (Algorithm alg : algorithms) {
                    alg.preRun();
            }
        }
        
        /*
         *  Performs methods that are required after all algorithms have run.<p>
         */
        private void postConfiguration(ArrayList<Algorithm> algorithms) {
            for (Algorithm alg : algorithms) {
                alg.postRun();
            }
        }
        
        /*
         * Abstract class that algorithms in the framework will implement. 
         */
        public abstract class Algorithm {
            protected FClass fclass;
            protected WorkData workData;
            public Algorithm(FClass fclass, WorkData workData) {
                this.fclass = fclass;
                this.workData = workData;
            }
            
            /**
             * Checks if the algorithm is enabled. The algorithm must have an option added
             * to the enum Default in 
             * {code JModelica/Compiler/ModelicaFrontEnd/src/java/org/jmodelica/util/OptionRegistry.java}.
             * Use {code fclass.myOptions().getBooleanOption("algorithm_name")} to check if its enabled.
             * 
             * @return {code true} if it is enabled, {code false} otherwise.
             */
            public abstract boolean isUsed();
            
            /**
             * Starts the algorithm.<p>
             * 
             * @param equation The equation to optimize.
             * @return {@code true} if the equation was updated, {@code false} otherwise.
             */
            public abstract boolean run(FAbstractEquation equation);
            
            /**
             * Performs methods that are to be performed after all algorithms have run.
             */
            public abstract void postRun();
            
            /**
             * Algorithms can perform work on the equations independently before
             * the framework moves on with iterating over the worklist.
             */
            public abstract void preRun();
        }
        
        /**
         * Class that contains data that is shared and updated in and between algorithms.
         *
         * When adding a new algorithm to the framework, update this class with needed methods 
         * and variables.
         */
        public class WorkData {
            // Used by all
            private LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();
            // Used by VariabilityPropagation
            private ArrayList<FAbstractEquation> parameterEquations = new ArrayList();
            // Used by all
            private HashSet<FAbstractEquation> removedEquations = new HashSet();
            // Used by VariabilityPropagator
            private boolean splitAliasParameters = !(fclass.myOptions().getBooleanOption("eliminate_alias_variables") 
                    && fclass.myOptions().getBooleanOption("eliminate_alias_parameters"));
            // Used by VariabilityPropagator
            private boolean splitAliasConstants  = !(fclass.myOptions().getBooleanOption("eliminate_alias_variables") 
                    && fclass.myOptions().getBooleanOption("eliminate_alias_constants"));
            
            /**
             * Constructs a class containing data needed throughout the execution time 
             * of the algorithms, that are added to the framework.
             *
             * @param worklist The working list of equations to modify with the algorithms.
             */
            public WorkData(LinkedHashSet<FAbstractEquation> worklist) {
                this.worklist = worklist;
                for (FAbstractEquation equation : fclass.getFParameterEquations())
                    parameterEquations.add(equation);
            }
            
            /*
             * Getter for the <code>splitAliasParameters</code> boolean.
             *
             * @return the constant.
             */
            public boolean splitAliasParameters() {
                return splitAliasParameters;
            }
            
            /*
             * Getter for the <code>splitAliasConstants</code> boolean.
             *
             * @return the constant.
             */
            public boolean splitAliasConstants() {
                return splitAliasConstants;
            }
                        
            /**
             * If an equation is switched to a parameter equation it should be
             * added to this list.
             *
             * @param equation The equation that is added to the parameter equations list.
             */
            public void addParameterEquation(FAbstractEquation equation) {
                parameterEquations.add(equation);
            }
            
            /**
             * Method to add an equation to the worklist.
             *
             * @param equation The equation to be added.
             */
            public void addToWorklist(FAbstractEquation equation) {
                worklist.add(equation);
            }
            
            /**
             * Method to add many equations to the worklist.
             *
             * @param   equations the equations to be added.
             */
            public void addAllToWorklist(List<FAbstractEquation> equations) {
                for (FAbstractEquation eqn : equations) {
                    worklist.add(eqn);
                }
            }
            
            /**
             * Checks if an equation has been removed by one of
             * the algorithms.
             *
             * @param equation The equation that is checked. 
             * @return {@code true} if it has been removed, {@code false} otherwise.
             */
            public boolean hasRemovedEquation(FAbstractEquation equation) {
                return removedEquations.contains(equation);
            }
            
            /**
             * Adds an equation to the list of removed equations.
             *
             * @param equation The equation that is added to the list of removed equations.
             */
            public void removeEquation(FAbstractEquation equation) {
                removedEquations.add(equation);
            }
            
            /**
             * Returns a list containing the parameter equations.
             *
             * @return The list containing all parameter equations. 
             */
            public List<FAbstractEquation> getparameterEquations() {
                return new List<FAbstractEquation>(parameterEquations);
            }
        }
    }
}