/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
aspect SymbolicTransformationFramework {
    public class FClass {
        protected symbolicTransformationFramework framework =
            new symbolicTransformationFramework(this);
            
        // Needed for debugging.
        protected static HashMap<String, Integer> modifications =
            new HashMap<String, Integer>();

        /*
         *  IfSets in case the pre-framework algorithms are needed.
         */
        public class aliasEliminationIfSet extends Transformation {
            public aliasEliminationIfSet() {
                super("eliminate_alias_variables");
            }
            
            public void perform() {
                framework.reset();
                framework.disableDebugging();
                framework.performAliasElimination();
                framework.restoreDebugging();
            }
        }
        
        public class variabilityPropagationIfSet extends Transformation {
            public variabilityPropagationIfSet() {
                super("variability_propagation");
            }
            
            public void perform() {
                framework.reset();
                framework.disableDebugging();
                framework.performVariabilityPropagation();
                framework.restoreDebugging();
            }
        }
    }

    /**
     *  A framework class for a collection of transformation algorithms to use
     *  upon the equations in an <code>FClass</code>.
     */
    public class symbolicTransformationFramework extends FClass.Transformation {
        
        private static WorkData workData;
        private static ModelicaLogger log = ASTNode.log;
        private static FClass fclass = null;
        private static ArrayList<SymbolicTransformationAlgorithm> algorithms;
        
        public symbolicTransformationFramework(FClass fclass) {
            fclass.super("symbolic_transformation_framework");
            this.fclass = fclass;
            algorithms = new ArrayList<SymbolicTransformationAlgorithm>();
        }
        
        public void perform() {
            workData = new WorkData(fclass);
            addAlgorithms();
            runAlgorithms();
        }
        
        /**
         *  Runs the algorithm framework.<p>
         *  The Framework iterates over all algorithms in its algorithm-list,
         *  transforming an equation from the worklist. If an algorithm changes the structure
         *  of the equation, the iteration breaks and restarts from the first algorithm.
         *  Transformations are performed until there are no equations left in the worklist.
         */ 
        public void runAlgorithms() {
            ArrayList<SymbolicTransformationAlgorithm> activeAlgorithms = new ArrayList();
            
            // Collect algorithms that are enabled.
            for (SymbolicTransformationAlgorithm algorithm: algorithms) {
                if (algorithm.isUsed()) {
                    activeAlgorithms.add(algorithm);
                    log.info("%s added to the algorithm list.", algorithm.name());
                }
            }
            
            workData.addAllToWorklist(fclass.getFAbstractEquations());
            
            preConfiguration(activeAlgorithms);
            
            addAlgorithmsToModifications();
            
            log.info("Algorithm loop starting.");
            // Start using algorithms on the equations.
            while (!workData.emptyWorklist()) {
                FAbstractEquation equation = workData.pollWorklist();
                for (SymbolicTransformationAlgorithm algorithm : activeAlgorithms) {
                    log.info("\twith %s.", algorithm.name());
                    if (algorithm.run(equation)) {
                        // Debug.
                        algorithmPerformedChanges(algorithm);
                        log.info("Algorithm performed changes, tracing back to first " +
                            "equation in the worklist.");
                        break;
                    }
                }
            }
            
            log.info("Running first change().");
            changesPerformed();
            
            postConfiguration(activeAlgorithms);
            
            log.info("Running second change().");
            changesPerformed();
            
            // Debug.
            if (DEBUG) {
                printModifications(RESULT_PATH);
                printModificationsSingleFile(RESULT_PATH);
                FClass.modifications.clear();
            }
            log.info("Symbolic transformation framework is done.");
        }
        
        public void reset() {
            workData = new WorkData(fclass);
            algorithms.clear();
        }
        
        private void changesPerformed() {
            change();
        }
        
        /**
         *  Performs only alias elimination.<p>
         *  
         *  //TODO: Refactor to use one method for all specific algorithm runs.
         */ 
        public void performAliasElimination() {
            algorithms.add(new AliasEliminator(fclass, workData));
            runAlgorithms();
        }
        
        /**
         *  Performs only variability propagation.<p>
         *  
         *  //TODO: Refactor to use one method for all specific algorithm runs.
         */ 
        public void performVariabilityPropagation() {
            algorithms.add(new VariabilityPropagator(fclass, workData));
            runAlgorithms();
        }
        
        /**
         *  Returns a copy of an FExp.<p>
         * 
         *  @param  exp the expression to copy.
         */
        public static FExp copyFExp(FExp exp) {
            return exp.treeCopy();
        }
        
        /**
         *  Returns a copy of an FAbstractVariable.<p>
         * 
         *  @param  exp the expression to copy.
         */
        public static FAbstractVariable copyFAbstractVariable(FAbstractVariable var) {
            return var.treeCopy();
        }
        
        /**
         *  Algorithms that are used by the framework are added here.
         * 
         *  @param  workData Data that is shared and updated in and between algorithms.
         */ 
        private void addAlgorithms() {
            algorithms.add(new AliasEliminator(fclass, workData));
            algorithms.add(new VariabilityPropagator(fclass, workData));
            algorithms.add(new Canonizer(fclass, workData));
        }
        
        /*
         *  Performs methods that are required before all algorithms have run.<p>
         *
         *  @param  algorithms a collection of <code>SymbolicTransformationAlgorithm</code>s
         *          which specify what transformation algorithms should be used.
         */
        private void preConfiguration(ArrayList<SymbolicTransformationAlgorithm> algorithms) {
            log.info("Running pre-configuration.");
            for (SymbolicTransformationAlgorithm alg : algorithms) {
                alg.preRun();
            }
            log.info("Pre-configuration done.");
        }
        
        /*
         *  Performs methods that are required after all algorithms have run.<p>
         *
         *  @param  algorithms a collection of <code>SymbolicTransformationAlgorithm</code>s
         *          which specify what transformation algorithms should be used.
         */
        private void postConfiguration(ArrayList<SymbolicTransformationAlgorithm> algorithms) {
            log.info("Running post-configuration.");
            for (SymbolicTransformationAlgorithm alg : algorithms) {
                alg.postRun();
            }
            log.info("Post-configuration done.");
        }
        
        /**
         *  Abstract class that algorithms in the framework must implement. 
         */
        public abstract class SymbolicTransformationAlgorithm {
            protected String name;
            protected FClass fclass;
            protected WorkData workData;
            
            public SymbolicTransformationAlgorithm(FClass fclass, WorkData workData) {
                this.fclass = fclass;
                this.workData = workData;
                this.name = getName();
            }
            
            /*
             *  Returns the name of the algorithm.<p>
             *  Primarily used for debugging.
             * 
             *  @return the name of the algorithm.
             */
            public String name() {
                return name;
            }
            
            /*
             *  Ensures that the algorithm has a name.<p>
             * 
             *  @return the name of the algorithm.
             */
            protected abstract String getName();
            
            /**
             *  Checks if the algorithm is enabled.<p>
             *  The algorithm must have an option added to the enum Default in 
             *  {code JModelica/Compiler/ModelicaFrontEnd/src/java/org/jmodelica/util/OptionRegistry.java}.
             *  Use {code fclass.myOptions().getBooleanOption("algorithm_name")} to check if its enabled.
             * 
             *  @return {code true} if it is enabled, {code false} otherwise.
             */
            public abstract boolean isUsed();
            
            /**
             *  Starts the algorithm.<p>
             * 
             *  @param  equation The equation to optimize.
             *  @return {@code true} if the equation was updated, {@code false} otherwise.
             */
            public abstract boolean run(FAbstractEquation equation);
            /**
             *  Performs methods that are to be performed before all algorithms have run.
             */
            public abstract void preRun();
            
            /**
             *  Performs methods that are to be performed after all algorithms have run.
             */
            public abstract void postRun();
        }
        
        /**
         *  Data class for the framework, also used for data required by algorithms.<p>
         */
        public class WorkData {
            private FAbstractEquation currentEquation = null;
            private LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet();
            private HashSet<FAbstractEquation> removedEquations = new HashSet();
            
            /*
             *  Data required for the <code>AliasEliminator</code> algorithm.
             */
            private boolean splitAliasParameters = !(
                fclass.myOptions().getBooleanOption("eliminate_alias_variables") &&
                fclass.myOptions().getBooleanOption("eliminate_alias_parameters"));
            private boolean splitAliasConstants  = !(
                fclass.myOptions().getBooleanOption("eliminate_alias_variables") &&
                fclass.myOptions().getBooleanOption("eliminate_alias_constants"));
            
            /*
             *  Data required for the <code>VariabilityPropagator</code> algorithm.
             */
            private List<FAbstractEquation> parameterEquations;
            
            /**
             *  Default constructor for <code>WorkData</code>.<p>
             *  A <code>WorkData</code> instance contains data required for some algorithms,
             *  but is used by them and the framework to keep track of equations.
             *
             *  @param  worklist The working list of equations to modify with the algorithms.
             */
            public WorkData(FClass fclass) {
                parameterEquations = fclass.getFParameterEquations();
            }
            
            /*
             *  Getter for the <code>splitAliasParameters</code> boolean.
             *
             *  @return the constant.
             */
            public boolean splitAliasParameters() {
                return splitAliasParameters;
            }
            
            /*
             *  Getter for the <code>splitAliasConstants</code> boolean.
             *
             *  @return the constant.
             */
            public boolean splitAliasConstants() {
                return splitAliasConstants;
            }
            
            /**
             *  If an equation is switched to a parameter equation it should be
             *  added to this list.
             *
             *  @param  equation The equation that is added to the parameter equations list.
             */
            public void addParameterEquation(FAbstractEquation equation) {
                parameterEquations.add(equation);
            }
            
            /**
             *  Method to add an equation to the worklist.
             *
             *  @param  equation The equation to be added.
             */
            public boolean addToWorklist(FAbstractEquation equation) {
                // IF-check for debug OK.
                if (!equation.equalSides() &&
                        !hasRemovedEquation(equation) &&
                        equation != currentEquation &&
                        equation.canSymbolicTransformContext()) {
                    log.info("\tAdded equation <%s> to the worklist.", equation);
                    worklist.add(equation);
                    return true;
                }
                return false;
            }
            
            /**
             *  Method to add many equations to the worklist.
             *
             *  @param  equations the equations to be added.
             */
            public void addAllToWorklist(List<FAbstractEquation> equations) {
                for (FAbstractEquation eqn : equations) {
                    addToWorklist(eqn);
                }
                log.info("Constructed worklist of %d equations:\n%s",
                    worklist.size(), worklist);
            }
            
            /**
             *  Checks if an equation has been removed by one of
             *  the algorithms.
             *
             *  @param  equation the equation that is checked. 
             *  @return {@code true} if it has been removed, {@code false} otherwise.
             */
            public boolean hasRemovedEquation(FAbstractEquation equation) {
                return removedEquations.contains(equation);
            }
            
            /**
             *  Adds an equation to the list of removed equations.
             *
             *  @param  equation The equation that is added to the list of removed equations.
             */
            public void removeEquation(FAbstractEquation equation) {
                removedEquations.add(equation);
                worklist.remove(equation);
                log.info("Equation <%s> marked for removal.", equation);
            }
            
            /**
             *  Inserts a new FIdUseExp into the tree.<p>
             *  The use-list of the variable corresponding to the id-use
             *  is updated with a new entry.
             * 
             *  @param  n the new id-use expression (<code>FIdUseExp</code>).
             */
            public void registerNode(ASTNode n) {
                Set<FIdUseExp> idUsesInTree = n.findFIdUseExpsInTree();
                
                for (FIdUseExp id : idUsesInTree) {
                    if (id.myFEquation() != currentEquation) {
                        FAbstractVariable var = id.myFV();
                        var.addUse(n);
                        id.myFEquation().addVariable(var);
                        log.info("\t\tAdded id use <%s> to variable <%s>," +
                            " variable added to equation [%s].",
                            id, var, id.myFEquation());
                    }
                }
            }
            
            /**
             *  Removes an FIdUseExp from the tree.<p>
             *  The use-list of the variable corresponding to the id-use
             *  is updated to not contain the argument entry.
             * 
             *  @param  n the id-use expression to remove.
             */
            public void disposeNode(ASTNode n) {
                Set<FIdUseExp> idUsesInTree = n.findFIdUseExpsInTree();
                
                for (FIdUseExp id : idUsesInTree) {
                    FAbstractVariable var = id.myFV();
                    FAbstractEquation eqn = id.myFEquation();
                    var.removeUse(n);
                    eqn.removeVariable(var);
                    log.info("\t\tRemoved id use <%s> from variable <%s>," +
                        " variable removed from equation [%s].", id, var, eqn);
                }
            }
            
            /**
             *  Checks whether or not the worklist is empty.
             * 
             *  @return <code>false</code> if the worklist is empty,
             *          <code>true</code> otherwise.
             */
            public boolean emptyWorklist() {
                boolean empty = worklist.isEmpty();
                if (empty) {
                    log.info("Worklist empty, algorithm loop done.");
                }
                return empty;
            }
            
            /**
             *  Returns the next item in the worklist.<p>
             *
             *  @return the next equation in the worklist.
             */
            public FAbstractEquation pollWorklist() {
                currentEquation = worklist.iterator().next();
                worklist.remove(currentEquation);
                log.info("Working on equation [%s], ", currentEquation);
                return currentEquation;
            }
        }
    }
    
    /**
     *  Replaces all <code>FIdUseExps</code> with a new <code>FExp</code>.<p>
     *  
     *  @param  workData the <code>WorkData</code> instance used by the
     *          transformation algorithms.
     *  @param  newExp the expression to replace the id-use expression.
     *  @param  negated specifies whether or not the replacing expression
     *          should be negated.
     */
    public void FIdUseExp.replaceUses(
            symbolicTransformationFramework.WorkData workData, 
            FExp newExp,
            boolean negated) {
        // Disconnect this id use from the tree.
        workData.disposeNode(this);
        // Replace all occurances of the old id use.
        replaceMe(negated ? new FNegExp(newExp) : newExp);
        // Insert the new id use into the tree.
        workData.registerNode(newExp);
        // Flush children of the equation.
        myFEquation().flushChildren();
    }
    
    public void FAbstractVariable.addUse(ASTNode n) {
        uses().add(n.asFIdUseExp());
    }
    public void FAbstractVariable.removeUse(ASTNode n) {
        uses().remove(n);
    }
    
    public void FAbstractEquation.removeVariable(FAbstractVariable var) {
        variables().remove(var);
    }
    
    public void FAbstractEquation.addVariable(FAbstractVariable var) {
        if (var.isFVariable() && !var.isParameter() && !var.isConstant()) {
            variables().add(var.asFVariable());
        }
    }
    
    syn boolean FAbstractEquation.hasUse(FIdUseExp id) { return false; }
    eq FEquation.hasUse(FIdUseExp id) {
        for (FIdUseExp use : collectUses()) {
            if (id.name().equals(use.name())) {
                return true;
            }
        }
        return false;
    }
    
    eq FEquation.equalSides() = getLeft().equals(getRight());
    syn boolean FAbstractEquation.equalSides() = false;

    /*
     *  Methods for debugging and bench-marking.
     */
    public class symbolicTransformationFramework {
        private static HashMap<String, Integer> modifications = FClass.modifications;
        private static boolean DEBUG = false;
        private static boolean OLD_DEBUG = DEBUG;
        private static final String RESULT_PATH = "C:\\Test_Results\\modifications\\";
        
        public void disableDebugging() {
            OLD_DEBUG = DEBUG;
            DEBUG = false;
        }
        
        public void restoreDebugging() {
            DEBUG = OLD_DEBUG;
        }
        
        private void algorithmPerformedChanges(SymbolicTransformationAlgorithm algorithm) {
            if (!DEBUG) {
                return;
            }
            String name = algorithm.name();
            modifications.put(name, algorithmChanges(name) + 1);
        }
        
        private void addAlgorithmsToModifications() {
            if (!DEBUG) {
                return;
            }
            modifications.put("Variability_Propagation", 0);
            modifications.put("Alias_Elimination", 0);
        }
        
        private void printModificationsSingleFile(String filePath) {
            if (!DEBUG) {
                return;
            }
            File resultFile = new File(RESULT_PATH + "_dataToCopyIntoExcel" + ".txt");
            String testFile = fclass.toString().split("\n")[0].split(" ")[1];
            StringBuilder sb = new StringBuilder();
            sb.append(testFile);
            for (String algorithm : modifications.keySet()) {
                String name = algorithm;
                if (name == "Variability_Propagation") {
                    sb.append("\t"+algorithmChanges(name));
                } else if (name == "Alias_Elimination") {
                    sb.append("\t"+algorithmChanges(name));
                }
            }
            sb.append("\n");
            
            try{
                if (resultFile.exists() == false) {
                    resultFile.createNewFile();
                    FileWriter fileWriter = new FileWriter(resultFile, true);
                    BufferedWriter writer = new BufferedWriter(fileWriter);
                    writer.write("Model\tVariabilityPropagation\tAliasElimination\n");
                    writer.close();
                }
                FileWriter fileWriter = new FileWriter(resultFile, true);
                BufferedWriter writer = new BufferedWriter(fileWriter);
                writer.write(sb.toString());
                writer.close();
            } catch (IOException e) {
                    System.out.println("Error writing to file <" + resultFile + ">.");
            }
        }
        
        private void printModifications(String filePath) {
            if (!DEBUG) {
                return;
            }
            String resultFile = RESULT_PATH + fclass.toString().split("\n")[0].split(" ")[1].replaceAll("\\.","") + ".txt";
            StringBuilder sb = new StringBuilder("< ----- Algorithm Modifications ----- >\n");
            for (String algorithm : modifications.keySet()) {
                sb.append("[" + algorithm + "]:\t" + algorithmChanges(algorithm) + ".\n");
            }
            sb.append("< ----- ----------------------- ----- >\n");
            
            BufferedWriter writer;
            try {
                writer = new BufferedWriter(new FileWriter(resultFile));
                writer.write(sb.toString());
                writer.flush();
                writer.close();
            } catch (IOException e) {
                System.out.println("Error writing to file <" + resultFile + ">.");
            }
        }
        
        private int algorithmChanges(String algorithm) {
            int res = 0;
            if (modifications.containsKey(algorithm)) {
                res = modifications.get(algorithm);
            }
            return res;
        }
        
    }
}