/*
    Copyright (C) 2011 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/
import org.jmodelica.util.QualifiedName;
aspect SimpleClassLookup {
    /**
      * Warning: This is only a prototype and is currently not well tested.
      *          Use with care.
      */

     /**
      * Interface implemented by nodes for which the SrcClassDecl can be resolved.
      */
    interface ClassLookupable {
        /**
         * Find the SrcClassDecl for this clause or component.
         * A unknown class is obtained in the case the SrcClassDecl can't be found.
         */
        public Access findClass();
        public SrcClassDecl findClassDecl();
    }
    SrcExtendsClause implements ClassLookupable;
    SrcComponentDecl implements ClassLookupable;
    SrcComponentClause implements ClassLookupable;
    SrcImportClause implements ClassLookupable;

    syn SrcClassDecl SrcExtendsClause.findClassDecl()   = getSuper().findClassDecl();
    syn SrcClassDecl SrcComponentDecl.findClassDecl()   = myComponentClause().findClassDecl();
    syn SrcClassDecl SrcComponentClause.findClassDecl() = getClassName().findClassDecl();
    syn SrcClassDecl SrcImportClause.findClassDecl()    = getPackageName().findClassDecl();

    syn Access SrcExtendsClause.findClass()   = getSuper().findClass();
    syn Access SrcComponentDecl.findClass()   = myComponentClause().findClass();
    syn Access SrcComponentClause.findClass() = getClassName().findClass();
    syn Access SrcImportClause.findClass()    = getPackageName().findClass();

    // Used to prevent circular lookups without the repetitions imposed by declaring attributes circular.
    protected boolean SrcAccess.duringFindClassDecl = false;
    protected int SrcClassDecl.duringFindClassDeclRevisits = 0;
    protected static final int SrcClassDecl.MAX_FIND_CLASS_DECL_REVISITS = 20;

    /**
    * Find the SrcClassDecl referenced by this access.
    */
    syn SrcClassDecl SrcAccess.findClassDecl() = findClass().getSrcClassDecl();
    
    syn Access SrcAccess.findClass();
    syn lazy Access SrcNamedAccess.findClass() {
        if (duringFindClassDecl) {
            return unknownClassAccess();
        }
        duringFindClassDecl = true;
        try {
            return simpleLookupClassHelper(getID());
        } finally {
            duringFindClassDecl = false;
        }
    }
    eq SrcDot.findClass()          = getLastAccess().findClass();
    eq SrcGlobalAccess.findClass() = getSrcAccess().findClass();

    /**
     * Lookup SrcClassDecl indicated by the provided name. 
     * Support lookup of both global and relative qualified names. 
     * Returns null when the class isn't found.
     */
    public SrcClassDecl SrcClassDecl.simpleLookupClass(String name) {
        return simpleLookupClass(new QualifiedName(name));
    }

    /**
     * legacy support needed for old programs. Delegates to the new method which handles all the cases.
     */
    syn SrcClassDecl SrcClassDecl.simpleLookupClassDotted(String name) = simpleLookupClass(name);
    /**
     * legacy support needed for old programs. Delegates to the new method which handles all the cases.
     */
    syn SrcClassDecl Program.simpleLookupClassDotted(String name) = simpleLookupClass(name);

    /**
     * Lookup the class referenced by the QualifiedName. The QualifiedName
     * determines if the lookup is in relative or global scope.
     *
     */
    public SrcClassDecl SrcClassDecl.simpleLookupClass(QualifiedName qName) {
        SrcClassDecl cd = this;
        if (qName.isGlobal()) {
            cd = simpleLookupClassGlobalScope(qName.next()).getSrcClassDecl();
        }else {
            cd = simpleLookupClassIncludeImports(qName.next()).getSrcClassDecl();
        }

        while (cd != null && qName.hasNext()) {
            cd = cd.simpleLookupClassMemberScope(qName.next()).getSrcClassDecl();
            if (cd == null) {
                return null;
            }
        }
        return cd;
    }

   /**
    * Lookup SrcClassDecl indicated by the provided name.
    * Support lookup of both global and relative qualified names.
    * Returns null when the class isn't found.
    */
    public SrcClassDecl Program.simpleLookupClass(String name) {
        QualifiedName qName = new QualifiedName(name);
        SrcClassDecl cd = simpleLookupClassDefaultScope(qName.next()).getSrcClassDecl();
        if (!qName.hasNext()) {
            return cd;
        }
        while (cd != null && qName.hasNext()) {
            cd = cd.simpleLookupClassMemberScope(qName.next()).getSrcClassDecl();
            if (cd == null) {
                return null;
            }
        }
        return cd;
    }

    public abstract class Access {
        public abstract SrcClassDecl getSrcClassDecl();
        public abstract SrcComponentDecl getSrcComponentDecl();
        public abstract String name();
        public abstract String qualifiedName();
        public abstract boolean isUnknown();
        public String globalAccess() {
            return "." + qualifiedName();
        }
        public String toString() {
            return qualifiedName();
        }
    }

    syn Access ASTNode.unknownClassAccess()             = root().unknownClassAccess();
    syn lazy Access SourceRoot.unknownClassAccess()     = new ClassAccess(unknownClassDecl(), null);
    syn Access ASTNode.unknownComponentAccess()         = root().unknownComponentAccess();
    syn lazy Access SourceRoot.unknownComponentAccess() = new ComponentAccess(unknownComponentDecl(), null);

    public class ClassAccess extends Access {
        private SrcClassDecl classDecl;
        private String enclosingClass;
        
        public ClassAccess(SrcClassDecl classDecl, String enclosingClass) {
            this.classDecl = classDecl;
            this.enclosingClass = enclosingClass;
        }
        
        public SrcClassDecl getSrcClassDecl() {
            return classDecl;
        }
        
        public SrcComponentDecl getSrcComponentDecl() {
            throw new UnsupportedOperationException();
        }
        
        @Override
        public String name() {
            return classDecl.name();
        }
        
        public String qualifiedName() {
            if (isUnknown()) {
                return "Unknown";
            }
            return (enclosingClass != null ? enclosingClass + "." : "") + classDecl.name();
        }
        
        @Override
        public boolean isUnknown() {
            return classDecl.isUnknown();
        }
    }

    public class ComponentAccess extends Access {
        private SrcComponentDecl component;
        private String enclosingClass;
        
        public ComponentAccess(SrcComponentDecl component, String enclosingClass) {
            this.component = component;
            this.enclosingClass = enclosingClass;
        }
        
        public SrcClassDecl getSrcClassDecl() {
            throw new UnsupportedOperationException();
        }
        
        public SrcComponentDecl getSrcComponentDecl() {
            return component;
        }
        
        @Override
        public String name() {
            return component.name();
        }
        
        public String qualifiedName() {
            if (isUnknown()) {
                return "Unknown";
            }
            return enclosingClass + "." + component.name();
        }
        
        @Override
        public boolean isUnknown() {
            return component.isUnknown();
        }
    }

    /**
    * Lookup helper method for SrcAccess and SrcClassDecl. Obtain the SrcClassDecl
    * by looking after the target class one "name" piece at a time in the correct scope.
    */
    inh Access ASTNode.simpleLookupClassHelper(String name);
    eq SrcDot.getSrcAccess(int i).simpleLookupClassHelper(String name)             =
        (i == 0) ? simpleLookupClassHelper(name) : getSrcAccess(i - 1).findClassDecl().simpleLookupClassMemberScope(name);
    eq SrcGlobalAccess.getSrcAccess().simpleLookupClassHelper(String name)         = simpleLookupClassGlobalScope(name);
    eq SrcArrayAccess.getSrcArraySubscripts().simpleLookupClassHelper(String name) = simpleLookupClassBypassDot(name);
    eq SrcImportClause.getPackageName().simpleLookupClassHelper(String name)       = simpleLookupClassGlobalScope(name);
    eq SrcExtendsClause.getChild().simpleLookupClassHelper(String name)            = simpleLookupClassFromExtends(name);
    eq SrcFullClassDecl.getChild().simpleLookupClassHelper(String name)            = simpleLookupClassDefaultScope(name);
    eq Program.getChild().simpleLookupClassHelper(String name)                     = simpleLookupClassDefaultScope(name);

    /**
    * Lookup helper method for SrcExtendsClause. Obtain the SrcClassDecl
    * with the given name. Has to be a unqualified classname.
    */
    inh Access SrcExtendsClause.simpleLookupClassFromExtends(String name);
    eq SrcFullClassDecl.getChild().simpleLookupClassFromExtends(String name) = simpleLookupClassLocalScope(name);
    eq Program.getChild().simpleLookupClassFromExtends(String name)       = simpleLookupClassDefaultScope(name);

    /**
    * Lookup simple name in global scope. Has to be a unqualified classname.
    */
    inh Access SrcAccess.simpleLookupClassGlobalScope(String name);
    inh Access SrcClassDecl.simpleLookupClassGlobalScope(String name);
    inh Access SrcImportClause.simpleLookupClassGlobalScope(String name);
    eq Program.getChild().simpleLookupClassGlobalScope(String name) = simpleLookupClassDefaultScope(name);

    /**
    * Lookup simple name in global scope. Has to be a unqualified classname.
    */
    syn lazy Access Program.simpleLookupClassDefaultScope(String name) {
        for (SrcStoredDefinition sd : getUnstructuredEntitys()) {
            for (SrcClassDecl cd : sd.getSrcClassDecls()) {
                if (cd.matches(name)) {
                    return new ClassAccess(cd, null);
                }
            }
        }
        
        Access res = simpleLookupInClassList(getPredefinedTypes(), name, null);
        if (res != null) {
            return res;
        }

        res = simpleLookupInClassList(getBuiltInTypes(), name, null);
        if (res != null) {
            return res;
        }

        res = simpleLookupInClassList(getBuiltInFunctions(), name, null);
        if (res != null) {
            return res;
        }
        res = simpleLookupInLibNodeList(getSrcLibNodes(), name);
        return (res != null) ? res : unknownClassAccess();
    }

    /**
     * Lookup simple name in contained classes, extends and imports but not in surrounding classes.
     * Has to be an unqualified classname.
     */
    syn Access SrcClassDecl.simpleLookupClassIncludeImports(String name) = simpleLookupClassMemberScope(name);
    eq SrcFullClassDecl.simpleLookupClassIncludeImports(String name) {
        Access res = simpleLookupClassMemberScope(name);
        if (res.isUnknown()) {
            res = simpleLookupClassInImports(name);
        }
        return res;
    }

    /**
     * Lookup in contained classes, extended classes, imports and surrounding classes.
     *  Has to be an unqualified classname.
     */
    syn lazy Access SrcFullClassDecl.simpleLookupClassDefaultScope(String name) {
        Access res = simpleLookupClassIncludeImports(name);
        return res.isUnknown() ? simpleLookupClassHelper(name) : res;
    }

    /**
     * Lookup in contained classes, imports and surrounding classes. Has to be a unqualified classname.
     */
    syn lazy Access SrcFullClassDecl.simpleLookupClassLocalScope(String name) {
        if (duringFindClassDeclRevisits > MAX_FIND_CLASS_DECL_REVISITS) {
            return unknownClassAccess();
        }
        duringFindClassDeclRevisits++;

        Access res = simpleLookupInClassList(classes(), name, qualifiedName());
        if (res == null) {
            res = simpleLookupClassInImports(name);
        }
        duringFindClassDeclRevisits--;
        return res.isUnknown() ? simpleLookupClassHelper(name) : res;
    }


    /**
     * Lookup in contained classes and extended classes. Has to be a unqualified classname.
     */
    syn Access SrcClassDecl.simpleLookupClassMemberScope(String name) = unknownClassAccess();
    eq SrcUnknownClassDecl.simpleLookupClassMemberScope(String name)  = unknownClassAccess();

    /**
     * Lookup in contained classes and extended classes.
     * Has to be a unqualified classname.
     * This method returns the unknown class when the class isn't found.
     */
    syn lazy Access SrcFullClassDecl.simpleLookupClassMemberScope(String name) {
        if (duringFindClassDeclRevisits > MAX_FIND_CLASS_DECL_REVISITS) { 
            return unknownClassAccess();
        }
        duringFindClassDeclRevisits++;

        Access res = simpleLookupInClassList(classes(), name, qualifiedName());
        if (res == null) {
            res = simpleLookupClassInExtends(name);
        }
        duringFindClassDeclRevisits--;
        return res;
	}
    eq SrcLibClassDecl.simpleLookupClassMemberScope(String name) {
        if (duringFindClassDeclRevisits > MAX_FIND_CLASS_DECL_REVISITS) {
            return unknownClassAccess();
        }
        duringFindClassDeclRevisits++;


        Access res = super.simpleLookupClassMemberScope(name);
        if (res.isUnknown()) {
            Access libRes = simpleLookupInLibNodeList(getSrcLibNodes(), name);
            if (libRes != null) {
                res = libRes;
            }
        }
        duringFindClassDeclRevisits--;
        return res;
    }

    eq SrcShortClassDecl.simpleLookupClassMemberScope(String name) = 
        getSrcExtendsClauseShortClass().findClassDecl().simpleLookupClassMemberScope(name);
    eq SrcLibNode.simpleLookupClassMemberScope(String name)        = 
        myClass().simpleLookupClassMemberScope(name);

    inh Access SrcAccess.simpleLookupClassBypassDot(String name);
    eq BaseNode.getChild(int i).simpleLookupClassBypassDot(String name) = getChild(i).simpleLookupClassHelper(name);
    eq SrcDot.getSrcAccess().simpleLookupClassBypassDot(String name)    = simpleLookupClassHelper(name);


    /**
    * Helper method which search for the class in the imported class. 
    * Has to be a unqualified classname.
    */
    syn Access SrcImportClause.simpleLookupClassInImport(String name) = 
        matches(name) ? findClass() : unknownClassAccess();
    eq SrcImportClauseUnqualified.simpleLookupClassInImport(String name) = 
        findClassDecl().simpleLookupClassMemberScope(name);


    /**
     * Helper method which looks for the class with the given name among this class's imported classes.
     * Has to be a unqualified classname.
     * This method returns the unknown class when the class isn't found.
     */
    protected Access SrcFullClassDecl.simpleLookupClassInImports(String name) {
        Access res;
        for (SrcImportClause imp : imports()) {
            res = imp.simpleLookupClassInImport(name);
            if (!res.isUnknown()) {
                return res;
            }
        }
        
        return unknownClassAccess();
    }

    /**
     * Helper method which looks for the class with the given name among this class's super classes.
     * Has to be a unqualified classname.
     * This method returns the unknown class when the class isn't found.
     */
    protected Access SrcFullClassDecl.simpleLookupClassInExtends(String name) {
        Access res;
        for (SrcExtendsClause sup : superClasses()) {
            res = sup.findClassDecl().simpleLookupClassMemberScope(name);
            if (!res.isUnknown()) {
                return new ClassAccess(res.getSrcClassDecl(), qualifiedName());
            }
        }
        
        return unknownClassAccess();
    }

    /**
     * Convenience method for looking up a class in a list of SrcClassDecls.
     * Has to be a unqualified classname.
     * This method returns null when the class isn't found.
     */
    public static Access ASTNode.simpleLookupInClassList(Iterable<? extends SrcClassDecl> list, String name, String enclosingClass) {
        for (SrcClassDecl cd : list) {
            if (cd.matches(name)) {
                return new ClassAccess(cd, enclosingClass);
            }
        }
        return null;
    }

    /**
     * Convenience method for looking up a class in the given list of SrcLibNodes.
     * Has to be a unqualified classname.
     * This method returns null when the class isn't found.
     */
    public static Access ASTNode.simpleLookupInLibNodeList(List<SrcLibNode> list, String name) {
        for (SrcLibNode ln : list) {
            if (ln.matches(name)) {
                return new ClassAccess((SrcClassDecl) ln, null);
            }
        }
        return null;
    }

    /**
     * Find if the name/identifier for this node matches the provided.
     */
    eq SrcIdDecl.matches(String str)                = getID().equals(str);
    eq SrcBaseClassDecl.matches(String str)         = getName().matches(str);
    eq SrcImportClauseRename.matches(String str)    = getSrcIdDecl().matches(str);
    eq SrcImportClauseQualified.matches(String str) = 
        getPackageName().getLastAccess().matches(str);
    eq SrcLibNode.matches(String str) {
        if (name().equalsIgnoreCase(str)) {
            myClass();
        }
        return name().equals(str);
    }

    /**
    * Test the lookup of classes for classes in a model. 
    * This method is only for use by JUnit tests testing the simpleLookup functionality.
    *
    * The required input is pairs of class to start from and the class which should be search for in an array. 
    *
    * The lookup result will be returned in a string with the start class and found class pairs.
    * 
    * The classes are identified with their qualified names.
    */ 
    public String SourceRoot.testSimpleClassLookup(String[] lookupPairs) {
        Program prog = getProgram();
        StringBuilder sb=new StringBuilder();
        for (int i = 0; i < lookupPairs.length; i += 2) {
            SrcClassDecl scd = prog.simpleLookupClass(lookupPairs[i]);
            SrcClassDecl foundClass = scd.simpleLookupClass(lookupPairs[i+1]);
            sb.append(scd.qualifiedName() + "\n->\n" + foundClass.qualifiedName() + "\n\n");
        }
        return sb.toString();
    }

    /**
    * Test the lookup of all extends, imports and components which can be looked up in a given class.
    * This method is only for use by JUnit tests testing the simpleLookup functionality.
    */
    public String SourceRoot.testFindMyClassDecl(String whichClass) {
        StringBuilder sb = new StringBuilder();
        SrcClassDecl scd = getProgram().simpleLookupClass(whichClass);
        if (scd.isUnknown()) {
            throw new AssertionError("The test class " + whichClass + "can't be found using simple lookup.");
        }
        testLookupAllClassDecls(sb, scd);
        return sb.toString();
    }

    /**
    * This method is only for use by JUnit tests testing the simpleLookup functionality.
    */
    private void SourceRoot.testLookupAllClassDecls(StringBuilder sb, ASTNode node) {
        for (Object sub : node) {
            if (sub instanceof ClassLookupable) {
                sb.append(sub.toString() + " : " + ((ClassLookupable) sub).findClassDecl().qualifiedName()+ "\n\n");
            }
            testLookupAllClassDecls(sb, (ASTNode) sub);
        }
    }

    /**
     * Find the SrcComponentDecl referenced by this access, if the access references a constant.
     */
    syn SrcComponentDecl SrcAccess.findConstantDecl() = findConstant().getSrcComponentDecl();
    
    syn Access SrcAccess.findConstant() {
        Access component = simpleLookupComponentHelper();
        if (component.getSrcComponentDecl().isConstant()) {
            return component;
        }
        return new ComponentAccess(unknownComponentDecl(), "");
    }
    
    syn Access SrcAccess.simpleLookupComponentHelper();
    syn lazy Access SrcNamedAccess.simpleLookupComponentHelper() = simpleLookupComponentHelper(getID());
    eq SrcDot.simpleLookupComponentHelper()          = getLastAccess().simpleLookupComponentHelper();
    eq SrcGlobalAccess.simpleLookupComponentHelper() = getLastAccess().simpleLookupComponentHelper();
    
    inh Access SrcAccess.simpleLookupComponentHelper(String name);
    inh Access SrcForStmt.simpleLookupComponentHelper(String name);
    inh Access SrcClassDecl.simpleLookupComponentHelper(String name);
    eq Program.getChild().simpleLookupComponentHelper(String name)                     = new ComponentAccess(unknownComponentDecl(), "");
    eq SrcGlobalAccess.getSrcAccess().simpleLookupComponentHelper(String name)         = new ComponentAccess(unknownComponentDecl(), "");
    eq SrcFullClassDecl.getChild().simpleLookupComponentHelper(String name)            = simpleLookupComponentDefaultScope(name);
    eq SrcForStmt.getChild().simpleLookupComponentHelper(String name)                  = simpleLookupComponentFromForStmt(name);
    eq SrcDot.getSrcAccess(int i).simpleLookupComponentHelper(String name)             = simpleLookupComponentDot(name, i);
    eq SrcArrayAccess.getSrcArraySubscripts().simpleLookupComponentHelper(String name) = simpleLookupComponentBypassDot(name);

    syn Access SrcFullClassDecl.simpleLookupComponentDefaultScope(String name) {
        SrcComponentDecl component = getComponentIncludeExtends(name);
        if (!component.isUnknown()) {
            return new ComponentAccess(component, qualifiedName());
        }
        Access access = simpleLookupComponentInImports(name);
        if (!access.isUnknown()) {
            return access;
        }
        if (getEncapsulated()) {
            return unknownComponentAccess();
        }
        return simpleLookupComponentHelper(name);
    }

    syn Access SrcForStmt.simpleLookupComponentFromForStmt(String name) {
        for (SrcForIndex index : getSrcForIndexs()) {
            SrcForIndexDecl indexDecl = index.getSrcForIndexDecl();
            if (indexDecl.name().equals(name)) {
                return unknownComponentAccess();
            }
        }
        return simpleLookupComponentHelper(name);
    }

    syn Access SrcDot.simpleLookupComponentDot(String name, int i) {
        if (i == 0) {
            return simpleLookupComponentHelper(name);
        }
        SrcClassDecl classDecl = getSrcAccess(i - 1).findClassDecl();
        return new ComponentAccess(classDecl.getComponentIncludeExtends(name), classDecl.qualifiedName());
    }

    syn Access SrcClassDecl.simpleLookupComponentInImports(String name) = unknownComponentAccess();
    eq SrcFullClassDecl.simpleLookupComponentInImports(String name) {
        for (SrcImportClause importClause : imports()) {
            if (!importClause.isUnqualifiedImport()) {
                Access access = importClause.getPackageName().simpleLookupComponentHelper();
                if (!access.isUnknown() && access.name().equals(name)) {
                    return access;
                }
            }
        }
        Access access = null;
        for (SrcImportClause importClause : imports()) {
            if (importClause.isUnqualifiedImport()) {
                SrcClassDecl packageDecl = importClause.getPackageName().findClassDecl();
                if (packageDecl.hasComponentIncludeExtends(name)) {
                    if (access != null) {
                        return unknownComponentAccess();
                    }
                    access = new ComponentAccess(packageDecl.getComponentIncludeExtends(name), packageDecl.qualifiedName());
                }
            }
        }
        if (access == null) {
            access = unknownComponentAccess();
        }
        return access;
    }

    inh Access SrcAccess.simpleLookupComponentBypassDot(String name);
    eq BaseNode.getChild(int i).simpleLookupComponentBypassDot(String name) {
        if (getChild(i) instanceof SrcClassDecl) {
            return ((SrcClassDecl) getChild(i)).simpleLookupComponentHelper(name);
        } else if (getChild(i) instanceof SrcAccess) {
            return ((SrcAccess) getChild(i)).simpleLookupComponentHelper(name);
        } else if (getChild(i) instanceof SrcForStmt) {
            return ((SrcForStmt) getChild(i)).simpleLookupComponentHelper(name);
        }
        throw new UnsupportedOperationException();
    }
    eq SrcDot.getSrcAccess().simpleLookupComponentBypassDot(String name) = simpleLookupComponentHelper(name);
    
    syn boolean SrcClassDecl.hasComponentIncludeExtends(String name) = !getComponentIncludeExtends(name).isUnknown();
    syn SrcComponentDecl SrcClassDecl.getComponentIncludeExtends(String name) {
        for (SrcComponentDecl component : components()) {
            if (component.name().equals(name)) {
                return component;
            }
        }
        for (SrcExtendsClause extendsClause : superClasses()) {
            SrcComponentDecl component = extendsClause.findClassDecl().getComponentIncludeExtends(name);
            if (!component.isUnknown()) {
                return component;
            }
        }
        return unknownComponentDecl();
    }


    public String InstClassDecl.testFindConstant() {
        SrcClassDecl sourceClass = getSrcClassDecl();
        StringBuilder sb = new StringBuilder();
        sourceClass.testFindConstant(sb);
        return sb.toString();
    }

    public void ASTNode.testFindConstant(StringBuilder sb) {
        for (ASTNode child : this) {
            child.testFindConstant(sb);
        }
    }

    public void SrcNamedAccess.testFindConstant(StringBuilder sb) {
        SrcClassDecl classDecl = findClassDecl();
        if (classDecl.isUnknown()) {
            sb.append(getID());
            sb.append("=");
            sb.append(findConstant());
            sb.append('\n');
        }
    }

    public void SrcArrayAccess.testFindConstant(StringBuilder sb) {
        super.testFindConstant(sb);
        getSrcArraySubscripts().testFindConstant(sb);
    }

    public void SrcParseAnnotation.testFindConstant(StringBuilder sb) {
    }
}