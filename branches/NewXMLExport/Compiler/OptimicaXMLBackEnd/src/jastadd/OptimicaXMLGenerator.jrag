/*
Copyright (C) 2014 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

/**
 * Aspect for generating XML from flat Optimica model
 */
aspect OptimicaXMLCodeGenerator {
	
	public void FOptClass.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		openTagXML(str, "optimization", indent);
		for (FFunctionDecl function : getFFunctionDeclList()) {
			p.print(function, str, indentOneStep);
			str.print("\n");
		}
		
		for (FRecordDecl record : getFRecordDecls()) {
			p.print(record, str, indentOneStep);
		}
		
		for (FDerivedType ftype : getFDerivedTypes()) {
			p.print(ftype, str, indentOneStep);
		}
		
		// generate enums
		for (FEnumDecl fenum : getFEnumDecls()) {
			p.print(fenum, str, indentOneStep);
		}
		
		// generate variable declarations
		for (FVariable fv : getFVariables()) {
			p.print(fv, str, indentOneStep);
		}
		
		/*for (FVariable fv : getAliasVariables()) {
			p.print(fv, str, indentOneStep);
		}*/
		
		for (FTimedVariable timedVar : timedRealVariables()) {
			//timedVar.generateDecl(p, str, indentOneStep);
			//p.print(timedVar, str, indentOneStep);
			openTagXML(str, "timedVariable", indentOneStep);
			p.print(timedVar.getName(), str, indentTwoSteps);
			p.print(timedVar.getArg(), str, indentTwoSteps);
			closeTagXML(str, "timedVariable", indentOneStep);
		}
		
		// add a newline between sections for clearer XML
		str.print("\n");
		
		// generate xml for initial equations
		if (getNumFInitialEquation() > 0) {
			openTagXML(str, "equation", indentOneStep, "kind", "initial");
			for (FAbstractEquation initEqu : getFInitialEquations()) {
				p.print(initEqu, str, indentTwoSteps);
			}
			closeTagXML(str, "equation", indentOneStep);
			// add a newline between sections for clearer XML
			str.print("\n");
		}
		
		// generate xml for parameter equations
		if (getNumFParameterEquation() > 0) {
			openTagXML(str, "equation", indentOneStep, "kind", "parameter");
			for (FAbstractEquation paramEqu : getFParameterEquations()) {
				p.print(paramEqu, str, indentTwoSteps);
			}
			closeTagXML(str, "equation", indentOneStep);
			str.print("\n");
		}
		
		// generate xml for equations
		if (hasFAbstractEquation()) {
			ArrayList<FAbstractEquation> algorithms = new ArrayList<FAbstractEquation>();
			openTagXML(str, "equation", indentOneStep);
			for (FAbstractEquation equ : getFAbstractEquations()) {
				if (equ instanceof FAlgorithm) {
					algorithms.add(equ);
				} else {
					p.print(equ, str, indentTwoSteps);
				}
			}
			closeTagXML(str, "equation", indentOneStep);
			
			// add a newline between sections for clearer XML
			str.print("\n");
			
			for (FAbstractEquation alg : algorithms) {
				p.print(alg, str, indentOneStep);
			}
		}
		
		// transfer constraints
		if (getNumFConstraint() > 0) {
			openTagXML(str, "constraint", indentOneStep);
			for (FConstraint c : pathLeqConstraints()) {
				openTagXML(str, "lessThan", indentTwoSteps, "kind", "pathConstraint");
				p.print(c, str, indentTwoSteps);
				closeTagXML(str, "lessThan", indentTwoSteps);
			}
			for (FConstraint c : pathEqConstraints()) {
				openTagXML(str, "equal", indentTwoSteps, "kind", "pathConstraint");
				p.print(c, str, indentTwoSteps);
				closeTagXML(str, "equal", indentTwoSteps);
			}
			for (FConstraint c : pathGeqConstraints()) {
				openTagXML(str, "greaterThan", indentTwoSteps, "kind", "pathConstraint");
				p.print(c, str, indentTwoSteps);
				closeTagXML(str, "greaterThan", indentTwoSteps);
			}
			for (FConstraint c : pointLeqConstraints()) {
				openTagXML(str, "lessThan", indentTwoSteps, "kind", "pointConstraint");
				p.print(c, str, indentTwoSteps);
				closeTagXML(str, "lessThan", indentTwoSteps);
			}
			for (FConstraint c : pointEqConstraints()) {
				openTagXML(str, "equal", indentTwoSteps, "kind", "pointConstraint");
				p.print(c, str, indentTwoSteps);
				closeTagXML(str, "equal", indentTwoSteps);
			}
			for (FConstraint c : pointGeqConstraints()) {
				openTagXML(str, "greaterThan", indentTwoSteps, "kind", "pointConstraint");
				p.print(c, str, indentTwoSteps);
				closeTagXML(str, "greaterThan", indentTwoSteps);
			}
			closeTagXML(str, "constraint", indentOneStep);
		}
		
		if (startTimeAttributeSet()) {
			openTagXML(str, "startTime", indentOneStep);
			p.print(startTimeAttributeExp(), str, indentTwoSteps);
			closeTagXML(str, "startTime", indentOneStep);
		}
		
		if (finalTimeAttributeSet()) {
			openTagXML(str, "finalTime", indentOneStep);
			p.print(finalTimeAttributeExp(), str, indentTwoSteps);
			closeTagXML(str, "finalTime", indentOneStep);
		}
		
		if (objectiveExp() != null) {
			openTagXML(str, "objective", indentOneStep);
			p.print(objectiveExp(), str, indentTwoSteps);
			closeTagXML(str, "objective", indentOneStep);
		}
		
		if (objectiveIntegrandExp() != null) {
			openTagXML(str, "objectiveIntegrand", indentOneStep);
			p.print(objectiveIntegrandExp(), str, indentTwoSteps);
			closeTagXML(str, "objectiveIntegrand", indentOneStep);
		}
		closeTagXML(str, "optimization", indent);
	}
	
	syn String FRelationConstraint.getName();
	eq FConstraintEq.getName() = "equal";
	eq FConstraintLeq.getName() = "lessThan";
	eq FConstraintGeq.getName() = "greaterThan";
	
	public void FRelationConstraint.prettyPrintXML(Printer p, CodeStream str, String indent) {
		//openTagXML(str, getName(), indent);
		p.print(getLeft(), str, p.indent(indent));
		p.print(getRight(), str, p.indent(indent));
		//closeTagXML(str, getName(), indent);
	}
	
	public void FForClauseC.prettyPrintXML(Printer p, CodeStream str, String indent) {
		// is this needed?
	}
	
	public void FTimedVariable.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		openTagXML(str, "operator", indent, "name", "at");
		p.print(getName(), str, indentOneStep);
		p.print(getArg(), str, indentOneStep);
		closeTagXML(str, "operator", indent);
	}
	
	public void FTimed.prettyPrintXML(Printer p, CodeStream str, String indent) {
		
	}
	
	public void FOptParameter.prettyPrintXML(Printer p, CodeStream str, String indent) {
		
	}
}