import java.util.ArrayList;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

import org.jmodelica.util.CodeStream;
import org.jmodelica.util.NotNullCodeStream;

/**
 * Aspect that adds XML codegeneration for flat models to the compiler
 * 
 */
aspect XMLCodeGenerator {
	
	/**
	 * Printer class that is used for printing nodes in the AST to a stream
	 */
	public class XMLPrettyPrint extends Printer {
		public XMLPrettyPrint() {
			super("\t");
		}
		
		public void print(ASTNode node, CodeStream str, String indent) {
			node.prettyPrintXML(this, str, indent);
		}
	}
	
	public void ASTNode.prettyPrintXML(CodeStream str, String indent) {
		prettyPrintXML(new XMLPrettyPrint(), str, indent);
	}
	
	public void ASTNode.prettyPrintXML(Printer p, CodeStream str, String indent) {
		prettyPrint(p, str, indent);
	}
	
	//=========================================================================
	// Helpers for XML generation
	//=========================================================================
	private static final String ASTNode.OPEN_TAG = "%s<%s%s>\n";
	private static final String ASTNode.CLOSED_TAG = "%s<%s%s/>\n";
	private static final String ASTNode.CLOSE_TAG = "%s</%s>\n";
	
	public void ASTNode.generateOpenTag(CodeStream str, String tag, String indent) {
		generateOpenTag(str, tag, indent, null);
	}
	
	public void ASTNode.generateOpenTag(CodeStream str, String tag, String indent,
			String attributeName, String attributeValue) {
		String attribute = " " + attributeName + "=\"" + attributeValue + "\"";
		str.format(OPEN_TAG, indent, tag, attribute);
	}

	public void ASTNode.generateOpenTag(CodeStream str, String tag, String indent, 
			Map<String, String> attributes) {
		StringBuilder allAttributes = new StringBuilder();
		if (attributes != null) {
			for (Map.Entry<String, String> attribute : attributes.entrySet()) {
				allAttributes.append(" ").append(attribute.getKey()).append("=\"")
					.append(attribute.getValue()).append("\"");
			}
		}
		str.format(OPEN_TAG, indent, tag, allAttributes.toString());
	}

	public void ASTNode.generateClosedTag(CodeStream str, String tag, String indent) {
		generateClosedTag(str, tag, indent, null);
	}
	
	public void ASTNode.generateClosedTag(CodeStream str, String tag, String indent,
			String attributeName, String attributeValue) {
		String attribute = " " + attributeName + "=\"" + attributeValue + "\"";
		str.format(CLOSED_TAG, indent, tag, attribute);
	}
	
	public void ASTNode.generateClosedTag(CodeStream str, String tag, String indent, 
			Map<String, String> attributes) {
		StringBuilder allAttributes = new StringBuilder();
		if (attributes != null) {
			for (Map.Entry<String, String> attribute : attributes.entrySet()) {	
				allAttributes.append(" ").append(attribute.getKey()).append("=\"")
					.append(attribute.getValue()).append("\"");
			}
		}
		str.format(CLOSED_TAG, indent, tag, allAttributes.toString());
	}
	
	public void ASTNode.generateCloseTag(CodeStream str, String tag, String indent) {
		str.format(CLOSE_TAG, indent, tag);
	}
	
	/**
	 * Entry point for XML generation, generates XML for child nodes by calling
	 * their print method
	 */
	public void FClass.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		String indentThreeSteps = p.indent(indentTwoSteps);
		generateOpenTag(str, "class", indent, "kind", "model");
		
		// generate functions
		for (FFunctionDecl function : getFFunctionDeclList()) {
			p.print(function, str, indentOneStep);
			str.print("\n");
		}
		
		for (FRecordDecl record : getFRecordDecls()) {
			p.print(record, str, indentOneStep);
		}
		
		for (FDerivedType ftype : getFDerivedTypes()) {
			p.print(ftype, str, indentOneStep);
		}
		
		// generate enums
		for (FEnumDecl fenum : getFEnumDecls()) {
			p.print(fenum, str, indentOneStep);
		}
		
		// generate variable declarations
		for (FVariable fv : getFVariables()) {
			p.print(fv, str, indentOneStep);
		}
		
		// add a newline between sections for clearer XML
		str.print("\n");
		
		// generate xml for initial equations
		if (getNumFInitialEquation() > 0) {
			generateOpenTag(str, "equation", indentOneStep, "kind", "initial");
			for (FAbstractEquation initEqu : getFInitialEquations()) {
				p.print(initEqu, str, indentTwoSteps);
			}
			generateCloseTag(str, "equation", indentOneStep);
			// add a newline between sections for clearer XML
			str.print("\n");
		}
		
		// generate xml for parameter equations
		if (getNumFParameterEquation() > 0) {
			generateOpenTag(str, "equation", indentOneStep, "kind", "parameter");
			for (FAbstractEquation paramEqu : getFParameterEquations()) {
				p.print(paramEqu, str, indentTwoSteps);
			}
			generateCloseTag(str, "equation", indentOneStep);
			str.print("\n");
		}
		
		// generate xml for equations
		if (hasFAbstractEquation()) {
			ArrayList<FAbstractEquation> algorithms = new ArrayList<FAbstractEquation>();
			generateOpenTag(str, "equation", indentOneStep);
			for (FAbstractEquation equ : getFAbstractEquations()) {
				// TODO remove instanceof if possible
				if (equ instanceof FAlgorithm) {
					algorithms.add(equ);
				} else {
					p.print(equ, str, indentTwoSteps);
				}
			}
			generateCloseTag(str, "equation", indentOneStep);
			
			// add a newline between sections for clearer XML
			str.print("\n");
			
			for (FAbstractEquation alg : algorithms) {
				p.print(alg, str, indentOneStep);
			}
		}
		generateCloseTag(str, "class", indent);
	}
	
	//=========================================================================
	// Code generation for declarations
	//=========================================================================
	public void FVariable.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		if (getFVisibilityType().isRuntimeOptionVisibility()) {
			// do not generate runtime variables
			return;
		}
		
		FTypePrefixInputOutput causalityPrefix = getFTypePrefixInputOutput();
		FTypePrefixVariability variabilityPrefix = getFTypePrefixVariability();		
		Map<String, String> attributes = new LinkedHashMap<String, String>();
		attributes.put("name", displayName());
		if (!variabilityPrefix.toString().equals("")) {
			attributes.put("variability", variabilityPrefix.toString().trim());			
		}
		if (causalityPrefix != null) {
			attributes.put("causality", causalityPrefix.toString());
		}
		if (hasFStringComment()) {
			String comment = getFStringComment().toString();
			comment = comment.replace("\"", "");
			attributes.put("comment", comment.trim());
		}
		
		generateOpenTag(str, "component", indent, attributes);
		String variableType = prettyPrintType();
		if (variableType.equals("Real") || variableType.equals("Integer") || 
				variableType.equals("Boolean") || variableType.equals("String")) {
			generateClosedTag(str, "builtin", indentOneStep, "name", variableType);
		} else {
			generateClosedTag(str, "local",  indentOneStep, "name", variableType);
		}
		
		// loop through attributes and generate modifiers
		if (hasFAttribute()) {
			generateOpenTag(str, "modifier", indentOneStep);
			for (FAttribute attr : getFAttributes()) {
				p.print(attr, str, indentTwoSteps);
			}
			generateCloseTag(str, "modifier", indentOneStep);
		}
		
		// generate bindingexpression if it exists
		if (hasBindingExp()) {
			generateOpenTag(str, "bindingExpression", indentOneStep);
			p.print(getBindingExp(), str, indentTwoSteps);
			generateCloseTag(str, "bindingExpression", indentOneStep);
		}
		generateCloseTag(str, "component", indent);
	}
	
	public void FDerivativeVariable.prettyPrintXML(Printer p, CodeStream str, String indent) {
	}
	
	// generate xml for enum declaration
	public void FEnumDecl.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "classDefinition", indent, "name", getName().name());
		generateOpenTag(str, "enumeration", indentOneStep);
		for (FEnumLiteral fenum : getFEnumSpecification().enumLiterals()) {
			p.print(fenum, str, indentTwoSteps);
		}
		generateCloseTag(str, "enumeration", indentOneStep);
		generateCloseTag(str, "classDefinition", indent);
	}
	
	public void FEnumLiteral.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "item", indent, "name", getName().name());
	}
	
	// generate xml for attributes 
	public void FAttribute.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "item", indent, "name", getName().name());
		if (hasValue()) {
			p.print(getValue(), str, p.indent(indent));
		}
		generateCloseTag(str, "item", indent);
	}
	
	// generate derived types
	public void FDerivedType.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		if (!getBaseType().isEnum()) {
			generateOpenTag(str, "classDefinition", indent, "name", getName());
			generateClosedTag(str, "builtin", indentOneStep, "name", getBaseType().toString());
			if (hasFAttribute()) {
				generateOpenTag(str, "modifier", indentOneStep);
				for (FAttribute attr : getFAttributeList()) {
					p.print(attr, str, indentTwoSteps);
				}
				generateCloseTag(str, "modifier", indentOneStep);
			}
			generateCloseTag(str, "classDefinition", indent);
		}
	}
	
	// generate function variables
	public void FFunctionVariable.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		Map<String, String> attributes = new LinkedHashMap<String, String>();
		attributes.put("name", name());
		if (hasFTypePrefixInputOutput()) {
			attributes.put("causality", getFTypePrefixInputOutput().toString());
		}
		generateOpenTag(str, "component", indent, attributes);
		String variableType = getType().toString();
		if (variableType.equals("Real") || variableType.equals("Integer") || 
				variableType.equals("Boolean") || variableType.equals("String")) {
			generateClosedTag(str, "builtin", indentOneStep, "name", variableType);
		} else {
			generateClosedTag(str, "local",  indentOneStep, "name", variableType);
		}
		if (getType().isArray()) {
			for (int i=0; i < getType().size().ndims(); i++) {
				generateOpenTag(str, "dimension", indentOneStep);
				generateClosedTag(str, "integer", indentTwoSteps, "value", Integer.toString(getType().size().get(i)));
				generateCloseTag(str, "dimension", indentOneStep);
			}
		}
		
		if (hasBindingExp()) {
			generateOpenTag(str, "bindingExp", indentOneStep);
			p.print(getBindingExp(), str, indentTwoSteps);
			generateCloseTag(str, "bindingExp", indentOneStep);
		}
		generateCloseTag(str, "component", indent);
	}
	
	/*public void FFunctionArray.prettyPrintXML(Printer p, CodeStream str, String indent) {
		for (int i=0; i < size().numElements(); i++) {
			generateOpenTag(str, "component", indent, "name", (getFQName().toString() + "_" + i));
			generateCloseTag(str, "component", indent);
		}
	}*/
	
	public void FRecordDecl.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "classDefinition", indent, "name", name());
		generateOpenTag(str, "class", indentOneStep, "kind", "record");
		for (FVariable var : getFVariables()) {
			p.print(var, str, indentTwoSteps);
		}
		generateCloseTag(str, "class", indentOneStep);
		generateCloseTag(str, "classDefinition", indent);
	}
	
	public void FRecordConstructor.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "local", indent, "name", getRecord().name());
		for (FExp arg : getArgs()) {
			p.print(arg, str, p.indent(indent));
		}
	}
	
	//=========================================================================
	// Code generation for expressions
	//=========================================================================
	public void FExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		for (FExp expChild : childFExps()) {
			p.print(expChild, str, indent);
		}
	}
	
	// if expressions, nested if expression is quite ugly maybe try to fix this if possible
	public void FIfExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "if", indent);
		generateOpenTag(str, "cond", indentOneStep);
		p.print(getIfExp(), str, indentTwoSteps);
		generateCloseTag(str, "cond", indentOneStep);
		generateOpenTag(str, "then", indentOneStep);
		p.print(getThenExp(), str, indentTwoSteps);
		generateCloseTag(str, "then", indentOneStep);
		generateOpenTag(str, "else", indentOneStep);
		p.print(getElseExp(), str, indentTwoSteps);
		generateCloseTag(str, "else", indentOneStep);
		generateCloseTag(str, "if", indent);
	}
	
	// TODO implement generation for arrays
	public void FArray.prettyPrintXML(Printer p, CodeStream str, String indent) {
		if (getNumFExp() > 1) {
			generateOpenTag(str, "tuple", indent);
		}
		for (FExp exp : getFExps()) {
			p.print(exp, str, p.indent(indent));
		}
		if (getNumFExp() > 1) {
			generateCloseTag(str, "tuple", indent);
		}
	}
	
	// binary operators
	syn String ASTNode.builtinType() = null;
	// < is represented by &lt; in xml
	eq FLtExp.builtinType() = "&lt;";
	eq FLeqExp.builtinType() = "&lt;=";
	// > is represented by &gt; in xml
	eq FGtExp.builtinType() = "&gt;";
	eq FGeqExp.builtinType() = "&gt;=";
	eq FEqExp.builtinType() = "==";
	eq FNeqExp.builtinType() = "&lt;&gt;";
	eq FOrExp.builtinType() = "or";
	eq FAndExp.builtinType() = "and";
	eq FAddExp.builtinType() = "+";
	eq FSubExp.builtinType() = "-";
	eq FMulExp.builtinType() = "*";
	eq FDivExp.builtinType() = "/";
	eq FPowExp.builtinType() = "^";
	eq FDotAddExp.builtinType() = ".+";
	eq FDotSubExp.builtinType() = ".-";
	eq FDotMulExp.builtinType() = ".*";
	eq FDotDivExp.builtinType() = "./";
	eq FDotPowExp.builtinType() = ".^";
	eq FStringAddExp.builtinType() = "+";
	eq FNegExp.builtinType() = "-";
	eq FNotExp.builtinType() = "not";
	
	// binary expressions, all binary expression should be function calls not operators
	public void FBinExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "call", indent, "builtin", builtinType());
		p.print(getLeft(), str, p.indent(indent));
		p.print(getRight(), str, p.indent(indent));
		generateCloseTag(str, "call", indent);
	}
	
	// unary expressions
	public void FUnaryExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "call", indent, "builtin", builtinType());
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "call", indent);
	}
	
	// literal types
	syn String ASTNode.literalType() = null;
	eq FIntegerLitExp.literalType() = "integer";
    eq FRealLitExp.literalType()    = "real";
	eq FStringLitExp.literalType()  = "string";
	
	// literal expressions
	public void FRealLitExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, literalType(), indent, "value", Double.toString(getValue()));
	}
	
	public void FIntegerLitExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, literalType(), indent, "value", Integer.toString(getValue()));
	}
	
	public void FStringLitExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, literalType(), indent, "value", getString());
	}
	
	public void FBooleanLitExpFalse.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "false", indent);
	}
	
	public void FBooleanLitExpTrue.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "true", indent);
	}
	
	public void FEnumLitExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "local", indent, "name", (getEnum() + "." + getValue()));
	}
	
	// generate identifiers
	public void FIdUse.prettyPrintXML(Printer p, CodeStream str, String indent) {
		if (getFQName().isScalarized()) {
			generateClosedTag(str, "local", indent, "name", name());
		} else {
			p.print(getFQName(), str, indent);
		}
	}
	
	public void FIdUseExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		p.print(getFIdUse(), str, indent);	
	}
	
	public void FQName.prettyPrintXML(Printer p, CodeStream str, String indent) {
		if (isScalarized()) {
			generateClosedTag(str, "local", indent, "name", name());
		} else {
			p.print(asFQNameFull(), str, indent);
		}
	}
	
	public void FQNameString.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "local", indent, "name", getName());
	}
	
	public void FQNameFull.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "reference", indent);
		StringBuilder name = new StringBuilder();
		ArrayList<Integer> subscripts = new ArrayList<Integer>();
		for (int i=0; i < getNumFQNamePart(); i++) {
			FQNamePart part = getFQNamePart(i);
			name.append(part.getName());
			if (part.hasFArraySubscripts()) {
				FArraySubscripts sub = part.getFArraySubscripts();
				if (sub.getNumFSubscript() > 0) {
					for (int j=0; j < sub.getNumFSubscript(); j++) {
						subscripts.add(Integer.parseInt(sub.getFSubscript(j).toString()));
					}
				}
			}
			if (i < getNumFQNamePart() - 1) {
				name.append(".");
			}
		}
		generateClosedTag(str, "local", indentOneStep, "name", name.toString());
		for (int i=0; i < subscripts.size(); i++ ) {
			generateOpenTag(str, "subscripts", indentOneStep);
			generateClosedTag(str, "integer", indentTwoSteps, "value", Integer.toString(subscripts.get(i)));
			generateCloseTag(str, "subscripts", indentOneStep);
		}
		generateCloseTag(str, "reference", indent);
	}
	
	//=========================================================================
	// Code generation for function declarations, general function calls and 
	// builtin functions
	//=========================================================================
	
	public void FFunctionDecl.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "classDefinition", indent, "name", name());
		generateOpenTag(str, "class", indentOneStep, "kind", "function");
		for (FFunctionVariable var : getFFunctionVariables()) {
			p.print(var, str, indentTwoSteps);
		}
		p.print(getFAlgorithm(), str, indentTwoSteps);
		generateCloseTag(str, "class", indentOneStep);
		generateCloseTag(str, "classDefinition", indent);
	}
	
	public void FFunctionCall.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "call", indent);
		generateOpenTag(str, "function", indentOneStep);
		if (getName().getFQName().isScalarized()) {
			generateClosedTag(str, "local", indentTwoSteps, "name", name());
		} else {
			p.print(getName().getFQName(), str, indentTwoSteps);
		}
		generateCloseTag(str, "function", indentOneStep);
		for (FExp arg : getArgs()) {
			p.print(arg, str, p.indent(indent));
		}
		generateCloseTag(str, "call", indent);
	}
	
	// generate xml for builtin function calls
	public void FBuiltInFunctionCall.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "call", indent, "builtin", builtInName());
		for (FExp exp : childFExps()) {
			p.print(exp, str, p.indent(indent));
		}
		generateCloseTag(str, "call", indent);
	}
	
	// operators, if it is possible generate all these with a common entrypoint
	// instead of individual generation
	public void FAssert.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "assert");
		p.print(getTest(), str, p.indent(indent));
		p.print(getMsg(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function der
	public void FDerExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "der");
		p.print(getFIdUse(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function pre
	public void FPreExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "pre");
		p.print(getFIdUse(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin variable time
	public void FTimeExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "builtin", indent, "name", "time");
	}
	
	// builtin function reinit
	public void FReinit.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "reinit");
		p.print(getVar(), str, p.indent(indent));
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function smooth
	public void FSmoothExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "smooth");
		p.print(getOrder(), str, p.indent(indent));
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function sample
	public void FSampleExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "sample");
		p.print(getOffset(), str, p.indent(indent));
		p.print(getInterval(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function change
	public void FChangeExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "change");
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function edge
	public void FEdgeExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "edge");
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function cardinality
	public void FCardinality.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "cardinality");
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function homotopy
	public void FHomotopyExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "homotopy");
		p.print(getActual(), str, p.indent(indent));
		p.print(getSimplified(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function finstream
	public void FInStream.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "instream");
		p.print(getFExp(), str, indent);
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function fnoeventexp
	public void FNoEventExp.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "operator", indent, "name", "noevent");
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	syn String ASTNode.simulationFunction() = null;
	eq FTerminalExp.simulationFunction() = "terminal";
	eq FInitialExp.simulationFunction() = "initial";
	
	// builtin functions initial and terminal
	public void FSimulationStateBuiltIn.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "operator", indent, "name", simulationFunction());
	}
	
	
	//=========================================================================
	// Code generation for equations
	// TODO it seems like flattening is removing some equation constructs when i 
	// tried to test them, find test cases where its possible to test for and connect
	// if they are always flattened should we keep the generation for them?
	//=========================================================================
	public void FEquation.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		generateOpenTag(str, "equal", indent);
		p.print(getLeft(), str, indentOneStep);
		p.print(getRight(), str, indentOneStep);
		generateCloseTag(str, "equal", indent);
	}
	
	public void FFunctionCallEquation.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		if (getNumLeft() > 0) {
			generateOpenTag(str, "equal", indent);
			if (getNumLeft() > 1) {
				generateOpenTag(str, "tuple", indentOneStep);
				for (FFunctionCallLeft left : getLefts()) {
					p.print(left, str, indentTwoSteps);
				}
				generateCloseTag(str, "tuple", indentOneStep);
			} else {
				for (FFunctionCallLeft left : getLefts()) {
					p.print(left, str, indentOneStep);
				}
			}
		}
		p.print(getCall(), str, p.indent(indent));
		if (getNumLeft() > 0) {
			generateCloseTag(str, "equal", indent);
		}
	}
	
	// lefthand side of special function call
	public void FFunctionCallLeft.prettyPrintXML(Printer p, CodeStream str, String indent) {
		if (getFExp() != null) {
			p.print(getFExp(), str, indent);
		} else {
			generateClosedTag(str, "nothing", indent);
		}
	}
	
	// generate xml for if and when equations
	public void FIfWhenElseEquation.prettyPrintXML(Printer p, CodeStream str, String indent) {
		if (isElse()) {
			generateOpenTag(str, "else", indent);
		}
		for (FAbstractEquation equ : getFAbstractEquations()) {
			p.print(equ, str, p.indent(indent));
		}
		if (isElse()) {
			generateCloseTag(str, "else", indent);
		}
	}
	
	public void FIfWhenEquation.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, ifWhenType(), indent);
		generateOpenTag(str, "cond", indentOneStep);
		p.print(getTest(), str, indentOneStep);
		generateCloseTag(str, "cond", indentOneStep);
		generateOpenTag(str, "then", indentOneStep);
		for (FAbstractEquation equ : getFAbstractEquations()) {
			p.print(equ, str, indentTwoSteps);
		}
		generateCloseTag(str, "then", indentOneStep);
		generateCloseTag(str, ifWhenType(), indent);
	}
	
	// generate xml for connect clause
	public void FConnectClause.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "connect", indent);
		p.print(getConnector1(), str, indent);
		p.print(getConnector2(), str, indent);
		generateCloseTag(str, "connect", indent);
	}
	
	// instance tree identifier
	public void FIdUseInstAccess.prettyPrintXML(Printer p, CodeStream str, String indent) {
		p.print(getInstAccess(), str, indent);
	}
	
	public void InstAccess.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "local", indent, "name", name());
	}
	
	// loop in equation section
	// for loops are flattened in many cases? find test model where it is not flattened!
	public void FForClauseE.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		// generate xml for loop index
		generateOpenTag(str, "for", indent);
		generateOpenTag(str, "index", indentOneStep, "name", name());
		// generate local name of for index?
		generateCloseTag(str, "index", indentOneStep);
		//getFForIndexList();
		generateOpenTag(str, "loop", indentOneStep);
		for (FAbstractEquation equ : getFAbstractEquations()) {
			p.print(equ, str, indentTwoSteps);
		}
		generateCloseTag(str, "loop", indentOneStep);
		generateCloseTag(str, "for", indent);
	}
	
	//=============================================================================
	// Code generation for algorithms
	//=============================================================================
	
	public void FAlgorithm.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateOpenTag(str, "algorithm", indent);
		for (FStatement stmt : getFStatements()) {
			p.print(stmt, str, p.indent(indent));
		}
		generateCloseTag(str, "algorithm", indent);
	}
	
	public void FAssignStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "assign", indent);
		generateOpenTag(str, "to", indentOneStep);
		p.print(getLeft(), str, indentTwoSteps);
		generateCloseTag(str, "to", indentOneStep);
		generateOpenTag(str, "from", indentOneStep);
		p.print(getRight(), str, indentTwoSteps);
		generateCloseTag(str, "from", indentOneStep);
		generateCloseTag(str, "assign", indent);
	}
	
	public void FBreakStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "break", indent);
	}
	
	public void FReturnStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		generateClosedTag(str, "return", indent);
	}
	
	public void FWhenStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "when", indent);
		for (FIfWhenClause clause : getFIfWhenClauses()) {
			p.print(clause, str, indentTwoSteps);
		}
		generateCloseTag(str, "when", indent);
	}
	
	public void FIfStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "if", indent);
		for (FIfWhenClause clause : getFIfWhenClauses()) {
			p.print(clause, str, indentOneStep);
		}
		if (getNumElseStmt() > 0) {
			generateOpenTag(str, "else", indentOneStep);
			for (FStatement stmt : getElseStmts()) {
				p.print(stmt, str, indentTwoSteps);
			}
			generateCloseTag(str, "else", indentOneStep);
		}
		generateCloseTag(str, "if", indent);
	}
	
	public void FIfWhenClause.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		generateOpenTag(str, "cond", indent);
		p.print(getTest(), str, indentOneStep);
		generateCloseTag(str, "cond", indent);
		generateOpenTag(str, "then", indent);
		for (FStatement stmt : getFStatements()) {
			p.print(stmt, str, indentOneStep);
		}
		generateCloseTag(str, "then", indent);
	}
	
	public void FForStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "for", indent);
		generateOpenTag(str, "index", indentOneStep);
		p.print(getIndex(), str, indentTwoSteps);
		generateCloseTag(str, "index", indentOneStep);
		generateOpenTag(str, "loop", indentOneStep);
		p.print(getForStmts(), str, indentTwoSteps);
		generateCloseTag(str, "loop", indentOneStep);
		generateCloseTag(str, "for", indent);
	}
	
	public void FWhileStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		generateOpenTag(str, "while", indent);
		generateOpenTag(str, "cond", indentOneStep);
		p.print(getTest(), str, indentTwoSteps);
		generateCloseTag(str, "cond", indentOneStep);
		generateOpenTag(str, "then", indentOneStep);
		for (FStatement fs : getWhileStmts()) {
			p.print(fs, str, indentTwoSteps);
		}
		generateCloseTag(str, "then", indentOneStep);
		generateCloseTag(str, "while", indent);
	}
	
	public void FFunctionCallStmt.prettyPrintXML(Printer p, CodeStream str, String indent) {
		String indentOneStep = p.indent(indent);
		String indentTwoSteps = p.indent(indentOneStep);
		String indentThreeSteps = p.indent(indentTwoSteps);
		generateOpenTag(str, "assign", indent);
		generateOpenTag(str, "to", indentOneStep);
		if (getNumLeft() > 1) {
			generateOpenTag(str, "tuple", indentTwoSteps);
			for (FFunctionCallLeft left : getLefts()) {
				p.print(left, str, indentThreeSteps);
			}
			generateCloseTag(str, "tuple", indentTwoSteps);
		} else {
			for (FFunctionCallLeft left : getLefts()) {
				p.print(left, str, indentTwoSteps);
			}
		}
		generateCloseTag(str, "to", indentOneStep);
		generateOpenTag(str, "from", indentOneStep);
		p.print(getCall(), str, indentTwoSteps);
		generateCloseTag(str, "from", indentOneStep);
		generateCloseTag(str, "assign", indent);
	}
}
