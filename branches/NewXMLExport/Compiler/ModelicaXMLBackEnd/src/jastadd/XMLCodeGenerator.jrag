import java.io.PrintStream;
import java.util.HashMap;
import java.util.LinkedHashMap;
import java.util.Map;

aspect XMLCodeGenerator {
	
	// printer class
	public class XMLPrettyPrint extends Printer {
		public XMLPrettyPrint(){
			super("\t");
		}
		
		public void print(ASTNode node, PrintStream str, String indent) {
			node.prettyPrintXML(this, str, indent);
		}
	}
	
	public void ASTNode.prettyPrintXML(PrintStream str, String indent) {
		prettyPrintXML(new XMLPrettyPrint(), str, indent);
	}
	
	public void ASTNode.prettyPrintXML(Printer p, PrintStream str, String indent) {
		prettyPrint(p, str, indent);
	}
	
	
	//=========================================================================
	// Helpers for XML generation
	//=========================================================================
	private static final String ASTNode.OPEN_TAG = "%s<%s%s>\n";
	private static final String ASTNode.CLOSED_TAG = "%s<%s%s/>\n";
	private static final String ASTNode.CLOSE_TAG = "%s</%s>\n";
	
	public void ASTNode.generateOpenTag(PrintStream str, String tag, String indent) {
		generateOpenTag(str, tag, indent, null);
	}
	
	public void ASTNode.generateOpenTag(PrintStream str, String tag, String indent,
			String attributeName, String attributeValue) {
		HashMap<String, String> map = new HashMap<String, String>();
		map.put(attributeName, attributeValue);
		generateOpenTag(str, tag, indent, map);
	}

	public void ASTNode.generateOpenTag(PrintStream str, String tag, String indent, Map<String, String> attributes) {
		String allAttributes = "";
		if(attributes != null) {
			for(Map.Entry<String, String> attribute : attributes.entrySet()) {
				allAttributes += " " + attribute.getKey() + "=\"" + attribute.getValue() + "\"" ;
			}
		}
		str.format(OPEN_TAG, indent, tag, allAttributes);
	}
	
	public void ASTNode.generateClosedTag(PrintStream str, String tag, String indent) {
		generateClosedTag(str, tag, indent, null);
	}
	
	public void ASTNode.generateClosedTag(PrintStream str, String tag, String indent,
			String attributeName, String attributeValue) {
		HashMap<String, String> map = new HashMap<String, String>();
		map.put(attributeName, attributeValue);
		generateClosedTag(str, tag, indent, map);
	}
	
	public void ASTNode.generateClosedTag(PrintStream str, String tag, String indent, Map<String, String> attributes) {
		String allAttributes = "";
		if(attributes != null){
			for(Map.Entry<String, String> attribute : attributes.entrySet()) {
				allAttributes += " " + attribute.getKey() + "=\"" + attribute.getValue() + "\"" ;
			}
		}
		str.format(CLOSED_TAG, indent, tag, allAttributes);
	}
	
	public void ASTNode.generateCloseTag(PrintStream str, String tag, String indent) {
		str.format(CLOSE_TAG, indent, tag);
	}
	
	/**
	 * Entry point for XML generation, generates XML for child nodes by calling
	 * their print method
	 */
	public void FClass.prettyPrintXML(Printer p, PrintStream str, String indent) {
		// how to get what kind of FClass this is, e.g. model, class... ?
		generateOpenTag(str, "class", indent);
		
		generateOpenTag(str, "declaration", p.indent(indent));
		
		// loop fvariables and generate XML for each of them
		for(FVariable fv : getFVariables()) {
			p.print(fv, str, p.indent(indent));
		}
		
		// loop enum declarations and generate xml for them (not fully working yet)
		for(FEnumDecl fenum : getFEnumDecls()) {
			p.print(fenum, str, p.indent(indent));
		}
		
		generateCloseTag(str, "declaration", p.indent(indent));
		
		// add a newline between sections for clearer XML
		str.print("\n");
		
		// generate xml for initial equations
		if(getNumFInitialEquation() > 0) {
			HashMap<String, String> initMap = new HashMap<String, String>();
			initMap.put("initial", "true");
			generateOpenTag(str, "equation", p.indent(indent), initMap);
			for(FAbstractEquation initEqu : getFInitialEquations()) {
				p.print(initEqu, str, p.indent(indent+indent));
			}
			generateCloseTag(str, "equation", p.indent(indent));
		}
		
		if(getNumFParameterEquation() > 0) {
			// generate xml for parameter equations(dont know if this should be included)
		}
		
		// add a newline between sections for clearer XML
		str.print("\n");
		
		// generate xml for equations
		if(hasFAbstractEquation()) {
			ArrayList<FAlgorithm> algorithms = new ArrayList<FAlgorithm>();
			generateOpenTag(str, "equation", p.indent(indent));
			for(FAbstractEquation equ : getFAbstractEquations()) {
				//check if this is an algorithm section
				if(equ instanceof FAlgorithm) {
					// generate algorithm code after equations, add all FAlgorithm to a list
					//algorithms.add(equ);
				} else {
					// generate equation code
					p.print(equ, str, p.indent(indent+indent));
				}
			}
			generateCloseTag(str, "equation", p.indent(indent));
			
			// add a newline between sections for clearer XML
			str.print("\n");
			
			for(FAlgorithm alg : algorithms) {
				// generate xml for algorithm section, add this later
			}
		}
		generateCloseTag(str, "class", indent);
	}
	
	//=========================================================================
	// Code generation for declarations
	//=========================================================================
	public void FVariable.prettyPrintXML(Printer p, PrintStream str, String indent) {
		// discard runtime variables for now
		String dispn = displayName();
		if(dispn.startsWith("_")) {
			return;
		}
		
		FTypePrefixInputOutput causalityPrefix = getFTypePrefixInputOutput();
		FTypePrefixVariability variabilityPrefix = getFTypePrefixVariability();		
		Map<String, String> attributes = new LinkedHashMap<String, String>();
		attributes.put("name", displayName());
		if(!variabilityPrefix.toString().equals("")) {
			attributes.put("variability", variabilityPrefix.toString().trim());			
		}
		if(causalityPrefix != null) {
			attributes.put("causality", causalityPrefix.toString());
		}
		
		// start tag for component
		generateOpenTag(str, "component", p.indent(indent), attributes);
		
		String variableType = prettyPrintType();
		HashMap<String, String> typeAttribs = new HashMap<String, String>();
		if(variableType.equals("Real") || variableType.equals("Integer") || 
				variableType.equals("Boolean") || variableType.equals("String")) {
			typeAttribs.put("name", prettyPrintType());
			generateClosedTag(str, "builtin", p.indent(indent+indent), typeAttribs);
		} else {
			typeAttribs.put("name", variableType);
			generateClosedTag(str, "local",  p.indent(indent+indent), typeAttribs);
		}
		
		// loop through attributes and generate modifiers
		if(hasFAttribute()) {
			generateOpenTag(str, "modifier", p.indent(indent+indent));
			for(FAttribute attr : getFAttributes()) {
				p.print(attr, str, p.indent(indent+indent+indent));
			}
			generateCloseTag(str, "modifier", p.indent(indent+indent));
		}
		
		// generate bindingexpression if it exists
		if(hasBindingExp()) {
			generateOpenTag(str, "bindingExpression", p.indent(indent+indent));
			p.print(getBindingExp(), str, p.indent(indent+indent+indent));
			generateCloseTag(str, "bindingExpression", p.indent(indent+indent));
		}
		generateCloseTag(str, "component", p.indent(indent));
	}
	
	// generate xml for enum declaration
	public void FEnumDecl.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> enumMap = new HashMap<String, String>();
		enumMap.put("name", getName().name());
		generateOpenTag(str, "classDefinition", p.indent(indent), enumMap);
		generateOpenTag(str, "enumeration", p.indent(indent+indent));
		for(FEnumLiteral fenum : getFEnumSpecification().enumLiterals()) {
			p.print(fenum, str, p.indent(indent+indent+indent));
		}
		generateCloseTag(str, "enumeration", p.indent(indent+indent));
		generateCloseTag(str, "classDefinition", p.indent(indent));
	}
	
	public void FEnumLiteral.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> enumMap = new HashMap<String, String>();
		enumMap.put("name", getName().name());
		generateClosedTag(str, "item", indent, enumMap);
	}
	
	// generate xml for attributes 
	public void FAttribute.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> attributeMap = new HashMap<String, String>();
		attributeMap.put("name", getName().name());
		generateOpenTag(str, "item", indent, attributeMap);
		if(hasValue()) {
			p.print(getValue(), str, p.indent(indent));
		}
		generateCloseTag(str, "item", indent);
	}
	
	//=========================================================================
	// Code generation for expressions
	//=========================================================================
	public void FExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		for(FExp expChild : childFExps()) {
			p.print(expChild, str, indent);
		}
	}
	
	// if expressions
	public void FIfExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		generateOpenTag(str, "if", indent);
		generateOpenTag(str, "cond", indent);
		p.print(getIfExp(), str, p.indent(indent));
		generateCloseTag(str, "cond", indent);
		generateOpenTag(str, "then", indent);
		p.print(getThenExp(), str, p.indent(indent));
		generateCloseTag(str, "then", indent);
		generateOpenTag(str, "else", indent);
		p.print(getElseExp(), str, p.indent(indent));
		generateCloseTag(str, "else", indent);
		generateCloseTag(str, "if", indent);
	}
	
	// binary operators
	syn String ASTNode.builtinType() = null;
	eq FLtExp.builtinType() = "<";
	eq FLeqExp.builtinType() = "<=";
	eq FGtExp.builtinType() = ">";
	eq FGeqExp.builtinType() = ">=";
	eq FEqExp.builtinType() = "==";
	eq FNeqExp.builtinType() = "<>";
	eq FOrExp.builtinType() = "or";
	eq FAndExp.builtinType() = "and";
	eq FAddExp.builtinType() = "+";
	eq FSubExp.builtinType() = "-";
	eq FMulExp.builtinType() = "*";
	eq FDivExp.builtinType() = "/";
	eq FPowExp.builtinType() = "^";
	eq FDotAddExp.builtinType() = ".+";
	eq FDotSubExp.builtinType() = ".-";
	eq FDotMulExp.builtinType() = ".*";
	eq FDotDivExp.builtinType() = "./";
	eq FDotPowExp.builtinType() = ".^";
	eq FStringAddExp.builtinType() = "+";
	eq FNegExp.builtinType() = "-";
	eq FNotExp.builtinType() = "not";
	
	// binary expressions, all binary expression should be function calls not operators
	public void FBinExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		Map<String, String> attributes = new HashMap<String, String>();
		attributes.put("builtin", builtinType());
		generateOpenTag(str, "call", indent, attributes);
		p.print(getLeft(), str, p.indent(indent));
		p.print(getRight(), str, p.indent(indent));
		generateCloseTag(str, "call", indent);
	}
	
	// unary expressions
	public void FUnaryExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		Map<String, String> attributes = new HashMap<String, String>();
		attributes.put("builtin", builtinType());
		generateOpenTag(str, "call", indent, attributes);
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "call", indent);
	}
	
	// literal types
	syn String ASTNode.literalType() = null;
	eq FIntegerLitExp.literalType() = "integer";
    eq FRealLitExp.literalType()    = "real";
	eq FBooleanLitExp.literalType() = "boolean";
	eq FStringLitExp.literalType()  = "string";
	eq FEnumLitExp.literalType() = getType().getName();
	
	// literal expressions
	public void FLitExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		str.print(indent + "<" + literalType() + " value=\"");
		//print value of expression since prettyprint already has this functionality
		// maybe change this later
		prettyPrint(p, str, "");
		str.print("\"/>\n");
	}
	
	// generate identifier
	public void FIdUse.prettyPrintXML(Printer p, PrintStream str, String indent) {
		if(getFQName().isScalarized()) {
			HashMap<String, String> nameMap = new HashMap<String, String>();
			nameMap.put("name", name());
			generateClosedTag(str, "local", indent, nameMap);
		} else {
			p.print(getFQName(), str, indent);
		}
	}
	
	public void FIdUseExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		p.print(getFIdUse(), str, indent);	
	}
	
	// generate xml for qualified name
	public void FQName.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> map = new HashMap<String, String>();
		map.put("name", name());
		generateClosedTag(str, "local", indent, map);
	}
	
	//=========================================================================
	// Code generation for general function calls and builtin functions
	//=========================================================================
	public void FFunctionCall.prettyPrintXML(Printer p, PrintStream str, String indent) {
		generateOpenTag(str, "call", indent);
		generateOpenTag(str, "function", indent);
		if(getName().getFQName().isScalarized()) {
			HashMap<String, String> attributes = new HashMap<String, String>();
			attributes.put("name", name());
			generateClosedTag(str, "local", indent, attributes);
		} else {
			p.print(getName().getFQName(), str, indent);
		}
		generateCloseTag(str, "function", indent);
		for(FExp arg : getArgs()) {
			p.print(arg, str, indent);
		}
		generateCloseTag(str, "call", indent);
	}
	
	// generate xml for builtin function calls
	public void FBuiltInFunctionCall.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> functionMap = new HashMap<String, String>();
		functionMap.put("builtin", builtInName());
		generateOpenTag(str, "call", indent, functionMap);
		for(FExp exp : childFExps()) {
			p.print(exp, str, p.indent(indent));
		}
		generateCloseTag(str, "call", indent);
	}
	
	// operators, if it is possible generate all these with a common entrypoint
	// instead of individual generation
	// builtin function der
	public void FDerExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> nameMap = new HashMap<String, String>();
		nameMap.put("name", "der");
		generateOpenTag(str, "operator", indent, nameMap);
		p.print(getFIdUse(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function pre
	public void FPreExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> nameMap = new HashMap<String, String>();
		nameMap.put("name", "pre");
		generateOpenTag(str, "operator", indent, nameMap);
		p.print(getFIdUse(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function time
	public void FTimeExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> nameMap = new HashMap<String, String>();
		nameMap.put("name", "time");
		generateClosedTag(str, "operator", indent, nameMap);
	}
	
	// builtin function reinit
	public void FReinit.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> nameMap = new HashMap<String, String>();
		nameMap.put("name", "reinit");
		generateOpenTag(str, "operator", indent, nameMap);
		p.print(getVar(), str, p.indent(indent));
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	// builtin function smooth
	public void FSmoothExp.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> nameMap = new HashMap<String, String>();
		nameMap.put("name", "smooth");
		generateOpenTag(str, "operator", indent, nameMap);
		p.print(getOrder(), str, p.indent(indent));
		p.print(getFExp(), str, p.indent(indent));
		generateCloseTag(str, "operator", indent);
	}
	
	//=========================================================================
	// Code generation for equations
	// TODO it seems like flattening is removing some equation constructs when i 
	// tried to test them, find test cases where its possible to test for and connect
	// if they are always flattened should we keep the generation for them?
	//=========================================================================
	public void FEquation.prettyPrintXML(Printer p, PrintStream str, String indent) {
		generateOpenTag(str, "equal", p.indent(indent));
		p.print(getLeft(), str, p.indent(indent+indent));
		p.print(getRight(), str, p.indent(indent+indent));
		generateCloseTag(str, "equal", p.indent(indent));
	}
	
	public void FFunctionCallEquation.prettyPrintXML(Printer p, PrintStream str, String indent) {
		// function calls of the following type: (x, y, z) = func(a, b);
		// maybe these are flattened in some way, test this!
		if(getNumLeft() > 0) {
			// generate xml for left side of strange function call
			for(FFunctionCallLeft left : getLefts()) {
				p.print(left, str, indent);
			}
		}
		// generate right side
		p.print(getCall(), str, indent);
	}
	
	// lefthand side of special function call
	public void FFunctionCallLeft.prettyPrintXML(Printer p, PrintStream str, String indent) {
		p.print(getFExp(), str, indent);
	}
	
	// generate xml for if and when equations
	public void FIfWhenElseEquation.prettyPrintXML(Printer p, PrintStream str, String indent) {
		if(isElse()) {
			generateOpenTag(str, "else", indent);
		}
		for(FAbstractEquation equ : getFAbstractEquations()) {
			p.print(equ, str, p.indent(indent));
		}
		if(isElse()) {
			generateCloseTag(str, "else", indent);
		}
	}
	
	public void FIfWhenEquation.prettyPrintXML(Printer p, PrintStream str, String indent) {
		generateOpenTag(str, ifWhenType(), indent);
		generateOpenTag(str, "cond", p.indent(indent));
		p.print(getTest(), str, p.indent(indent+indent));
		generateCloseTag(str, "cond", p.indent(indent));
		generateOpenTag(str, "then", p.indent(indent));
		for(FAbstractEquation equ : getFAbstractEquations()) {
			p.print(equ, str, p.indent(indent+indent));
		}
		generateCloseTag(str, "then", p.indent(indent));
		generateCloseTag(str, ifWhenType(), indent);
	}
	
	public void FConnectClause.prettyPrintXML(Printer p, PrintStream str, String indent) {
		generateOpenTag(str, "connect", indent);
		p.print(getConnector1(), str, indent);
		p.print(getConnector2(), str, indent);
		generateCloseTag(str, "connect", indent);
	}
	
	// instance tree identifier
	public void FIdUseInstAccess.prettyPrintXML(Printer p, PrintStream str, String indent) {
		p.print(getInstAccess(), str, indent);
	}
	
	public void InstAccess.prettyPrintXML(Printer p, PrintStream str, String indent) {
		HashMap<String, String> nameMap = new HashMap<String, String>();
		nameMap.put("name", name());
		generateClosedTag(str, "local", indent, nameMap);
	}
	
	// loop in equation section TODO finish this
	// for loops are flattened in many cases?
	public void FForClauseE.prettyPrintXML(Printer p, PrintStream str, String indent) {
		// generate xml for loop index
		generateOpenTag(str, "for", indent);
		HashMap<String, String> forMap = new HashMap<String, String>();
		forMap.put("name", getName().name());
		generateOpenTag(str, "index", p.indent(indent), forMap);
		// generate local name of for index?
		generateCloseTag(str, "index", p.indent(indent));
		//getFForIndexList();
		generateOpenTag(str, "loop", p.indent(indent));
		for(FAbstractEquation equ : getFAbstractEquations()) {
			p.print(equ, str, p.indent(indent+indent));
		}
		generateCloseTag(str, "loop", p.indent(indent));
		generateCloseTag(str, "for", indent);
	}
	
	//=============================================================================
	// Code generation for algorithms
	// Implementation of this will wait for a bit
	//=============================================================================
	
	public void FAlgorithm.prettyPrintXML(Printer p, PrintStream str, String indent) {
		// entrypoint for algorithm block
		generateOpenTag(str, "algorithm", indent);
		for(FStatement stmt : getFStatements()) {
			// generate xml for each statement
			p.print(stmt, str, indent);
		}
		generateCloseTag(str, "algorithm", indent);
	}
	
	public void FAssignStmt.prettyPrintXML(Printer p, PrintStream str, String indent) {
	}
	
	public void FBreakStmt.prettyPrintXML(Printer p, PrintStream str, String indent) {
	}
	
	public void FReturnStmt.prettyPrintXML(Printer p, PrintStream str, String indent) {
	}
	
	public void FIfWhenStmt.prettyPrintXML(Printer p, PrintStream str, String indent) {
		// add other if and when clauses
	}
	
	public void FForStmt.prettyPrintXML(Printer p, PrintStream str, String indent) {
	}
	
	public void FWhileStmt.prettyPrintXML(Printer p, PrintStream str, String indent) {
	}
}
