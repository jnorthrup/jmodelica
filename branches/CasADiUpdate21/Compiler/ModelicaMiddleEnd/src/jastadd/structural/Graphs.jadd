/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

package org.jmodelica.util;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.LinkedList;
import java.util.ListIterator;
import java.util.Map;
import java.util.TreeMap;
import java.util.Random;
import java.util.Set;
import java.util.Stack;
import java.util.EnumSet;
import org.jmodelica.util.FilteredIterator;

aspect Graphs {

public abstract class AbstractBiPGraph<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>, C extends SCCBlock<E, V>> {

    private static final String DEFAULT_EQ_PREFIX = "eq";
    
    protected Map<String, V> variableMap = new LinkedHashMap<String, V>();
    protected Map<String, E> equationMap = new LinkedHashMap<String, E>();
    protected Map<FAbstractEquation, java.util.List<E>> equationIndexMap = new LinkedHashMap<FAbstractEquation, java.util.List<E>>();
    private boolean initialSystem = false;
    private Enumerator enumerator = new Enumerator(1);

    public AbstractBiPGraph() {
    }

    public <E_OTHER extends AbstractEq<E_OTHER, V_OTHER>, V_OTHER extends AbstractVar<E_OTHER, V_OTHER>> AbstractBiPGraph(Collection<E_OTHER> eqs, Collection<V_OTHER> vars) {
        for (E_OTHER oldE : eqs)
            addEquation(oldE.getEquation(), oldE.groupNumber(), oldE.variability(), oldE.getName());
        for (V_OTHER oldV : vars)
            addVariable(oldV.getName(), oldV.getVariable());
        for (E_OTHER oldE : eqs) {
            E e = getEquation(oldE.getName());
            for (V_OTHER oldV : oldE.getVariables()) {
                V v = getVariable(oldV.getName());
                if (v != null)
                    addInsidence(e, v);
            }
        }
    }

    public <E_OTHER extends AbstractEq<E_OTHER, V_OTHER>, V_OTHER extends AbstractVar<E_OTHER, V_OTHER>> AbstractBiPGraph(Collection<E_OTHER> block) {
        this(block, collectMatchingVariables(block));
        for (E_OTHER e : block) {
            match(getEquation(e.getName()), getVariable(e.getMatching().getName()));
        }
    }

    private static <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<V> collectMatchingVariables(Collection<E> eqns) {
        Collection<V> vars = new ArrayList<V>();
        for (E e : eqns)
            vars.add(e.getMatching());
        return vars;
    }

    public boolean isComplete() {
        return getUnmatchedVariables().size() == 0 && getUnmatchedEquations().size() == 0;
    }

    public Collection<E> getEquations() {
        return equationMap.values();
    }

    public Collection<V> getVariables() {
        return variableMap.values();
    }

    public E getEquation(String name) {
        return equationMap.get(name);
    }

    public void isInitialSystem() {
        initialSystem = true;
    }

    public java.util.List<E> getEquations(FAbstractEquation eqn) {
        java.util.List<E> list = equationIndexMap.get(eqn);
        return (list == null) ? Collections.<E>emptyList() : list;
    }

    public E addEquation(FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability) {
        return addEquation(eqn, groupNumber, variability, DEFAULT_EQ_PREFIX, enumerator);
        
    }
    
    private E addEquation(FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability, String prefix, Enumerator enumerator) {
        String name;
        prefix = prefix + "_";
        do {
            name = prefix + enumerator.next();
        } while (getEquation(name) != null);
        return addEquation(eqn, groupNumber, variability, name);
    }
    
    protected E addEquation(FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability, String name) {
        E e = equationMap.get(name);
        if (e != null)
            throw new IllegalArgumentException("Equation with the name '" + name + "' already exists:\n" + e.getEquation() + "\nNew equation:\n" + eqn);
        e = createEq(name, eqn, groupNumber, variability);
        e.addGroupMember(e);
        equationMap.put(name,e);
        insertIntoEquationIndexMap(eqn,e);
        return e;
    }

    protected abstract E createEq(String name, FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability);

    public V addVariable(String name, FVariable var) {
        V v = variableMap.get(name);
        if (v==null) {
            v = createVar(name, var);
            variableMap.put(name,v);
        }	
        return v;
    }

    protected abstract V createVar(String name, FVariable var);

    public void removeEquation(E e) {
        for (V v : e.getVariables()) {
            if (v.getMatching() == e) {
                v.setMatching(null);
            }
        }
        e.setMatching(null);
        e.getVariables().clear();
        equationMap.remove(e.getName());
        removeFromEquationIndexMap(e.getEquation(),e);
    }

    public void removeVariable(V v) {
        for (E e : getEquations()) {
            if (e.getMatching() == v) {
                e.setMatching(null);
            }
            e.getVariables().remove(v);
        }
        v.setMatching(null);
        variableMap.remove(v.getName());
    }

    public V getVariable(String name) {
        return variableMap.get(name);
    }

    public final boolean addEdge(String equationName, String variableName) {
        return addEdge(getEquation(equationName), getVariable(variableName));
    }

    public boolean addEdge(E e, V v) {
        if (v==null || e==null)
            return false;
        if (e.getVariables().contains(v))
            return false;
        e.addVariable(v);
        return true;
    }

    public enum VarType {
        DERIVATIVE_VARIABLES { 
            public Collection<? extends FVariable> variables(FClass c)            { return c.derivativeVariables(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.derivativeVariables(); }
            public boolean isOk(FTypePrefixVariability variability)               { return variability.continuousVariability(); }
        },
        DIFFERENTIATED_VARIABLES { 
            public Collection<? extends FVariable> variables(FClass c)            { return c.differentiatedRealVariables(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.differentiatedRealVariables(); }
            public boolean isOk(FTypePrefixVariability variability)               { return variability.continuousVariability(); }
        }, 
        ALGEBRAIC_VARIABLES { 
            public Collection<? extends FVariable> variables(FClass c)            { return c.algebraicVariables(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.algebraicVariables(); }
        }, 
        CONTINUOUS_ALGEBRAIC_VARIABLES { 
            public Collection<? extends FVariable> variables(FClass c)            { return c.algebraicContinousRealVariables(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.algebraicContinousRealVariables(); }
            public boolean isOk(FTypePrefixVariability variability)               { return variability.continuousVariability(); }
        }, 
        DISCRETE_ALGEBRAIC_VARIABLES { 
            public Collection<? extends FVariable> variables(FClass c)            { return c.discreteVariables(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.discreteVariables(); }
            public boolean isOk(FTypePrefixVariability variability)               { return variability.discreteVariability(); }
        }, 
        DISCRETE_PRE_VARIABLES { 
            public Collection<? extends FVariable> variables(FClass c)            { return c.discretePreVariables(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.discretePreVariables(); }
            public boolean isOk(FTypePrefixVariability variability)               { return variability.discreteVariability(); }
        },
        NON_FIXED_PARAMETERS {
            public Collection<? extends FVariable> variables(FClass c)            { return c.nonFixedParameters(); }
            public Collection<? extends FVariable> variables(FAbstractEquation e) { return e.nonFixedParameters(); }
            public boolean isOk(FTypePrefixVariability variability)               { return variability.parameterVariability(); }
        };

        public abstract Collection<? extends FVariable> variables(FClass c);
        public abstract Collection<? extends FVariable> variables(FAbstractEquation e);
        public boolean isOk(FTypePrefixVariability e) { return true; }
    }

    public void addVariables(FClass fclass, EnumSet<VarType> variableTypes) {
        for (VarType t : variableTypes)
            for (FVariable fv : t.variables(fclass))
                addVariable(fv.name(), fv);
    }

    public void addEquations(java.util.List<FAbstractEquation> eqns, EnumSet<VarType> variableTypes) {
        do_addEquations(eqns, variableTypes, DEFAULT_EQ_PREFIX, enumerator);
    }

    public void addEquations(java.util.List<FAbstractEquation> eqns, EnumSet<VarType> variableTypes, String eqNamePrefix, Enumerator enumerator) {
        if (eqNamePrefix.equals(DEFAULT_EQ_PREFIX))
            throw new IllegalArgumentException("The equation name prefix '" + eqNamePrefix + "' is reserved!");
        do_addEquations(eqns, variableTypes, eqNamePrefix, enumerator);
    }

    private void do_addEquations(java.util.List<FAbstractEquation> eqns, EnumSet<VarType> variableTypes, String eqNamePrefix, Enumerator enumerator) {
        Set<FVariable> emptySet = Collections.emptySet();
        for (FAbstractEquation e : eqns) {
            
            IncidenceMap incMap = e.createIncidenceMap(this, Collections.<V>emptySet(), variableTypes);
            int n_eq = incMap.numEqs();
            
            Collection<E> groupMembers = getEquations(e);
            int n_existing = groupMembers.size();
            if (n_existing != 0 && n_existing != n_eq)
                throw new IllegalArgumentException("Equation already exist in BiPGraph but with different number of scalars, previously " + n_existing + ", now " + n_eq + ", equation:\n" + e);
            
            if (n_existing == 0) {
                groupMembers = new ArrayList<E>();
                for (int i = n_eq - 1; 0 <= i; i--) { // During tarjan the order will be reversed,
                                                      // need to reverse here to preserve the initial order.
                    E eqn = addEquation(e, i, incMap.variability(i), eqNamePrefix, enumerator);
                    groupMembers.add(eqn);
                }
                for (E ee : groupMembers) {
                    for (E eee : groupMembers) {
                        ee.addGroupMember(eee);
                    }
                }
            }
            for (E eqn : groupMembers) {
                incMap.addEdges(eqn, false);
            }
        }
    }
    
    /**
     * Handles incidences between variables in an FAbstractEquation.
     * The base case is a scalar equation where all variables are 
     * dependent on each other.
     */
    protected class IncidenceMap {
        protected Set<V> vars;
        protected FAbstractEquation equation;
        
        public IncidenceMap(FAbstractEquation e, Set<V> additionalDeps) {
            equation = e;
            vars = lookupVarsInSet(equation.findFIdUseExpsInTree());
            vars.addAll(additionalDeps);
        }
        
        public FTypePrefixVariability variability(int i) {
            return equation.variability();
        }
        
        public void addEdges(E eqn, boolean log) {
            for (V var : vars) {
                if (log) {
                    ASTNode.log.info("*** %s", var);
                }
                addEdge(eqn, var);
            }
        }
        
        public int numEqs() {
            return equation.numScalarEquations();
        }
    }
    
    /**
     * Handles incidences between variables in a non-scalar FAbstractEquation.
     * Isolates LHS variables from each other.
     */
    protected abstract class MultiIncidenceMap extends IncidenceMap {
        protected Map<Integer, V> lhs;
        protected Set<FIdUseExp> lhsUses;
        
        public MultiIncidenceMap(FAbstractEquation e, Set<V> additionalDeps, EnumSet<VarType> variableTypes) {
            super(e, additionalDeps);
            lhsUses = equation.FIdUseExpsInLHS();
            lhs = new HashMap<Integer, V>();
        }
        
        protected void buildLhsFunction(EnumSet<VarType> variableTypes) {
            int i = 0;
            for (FIdUseExp use : lhsUses) {
                if (variableTypes != null) {
                    FAbstractVariable fv = use.myFV();
                    if (fv != null && !addLhs(fv, variableTypes)) {
                        continue;
                    }
                }
                buildLhsFunction(use, i++);
            }
        }
        
        protected void buildLhsFunction(FIdUseExp use, int i) {
            V var = getVariable(use.name());
            lhs.put(i, var);
        }
        
        protected boolean addLhs(FAbstractVariable fv, EnumSet<VarType> variableTypes) {
            for (VarType t : variableTypes) {
                if (t.isOk(variability(fv))) {
                    return true;
                }
            }
            return false;
        }
        
        @Override
        public FTypePrefixVariability variability(int i) {
            V var = lhs.get(i);
            if (var == null) {
                return super.variability(i);
            }
            return variability(var.getVariable());
        }
        
        private FTypePrefixVariability variability(FAbstractVariable fv) {
            FTypePrefixVariability v = fv.variability();
            if (v.parameterOrLess()) {
                v = fv.type().funcOutputVariability();
            }
            return v;
        }
        
        @Override
        public void addEdges(E eqn, boolean log) {
            int i = eqn.groupNumber();
            V lhsVar = lhs.get(i);
            for (V var : vars) {
                if (var == lhsVar || rhs(i).contains(var)) {
                    addEdge(eqn, var);
                }
            }
        }
        
        protected abstract Set<V> rhs(int i);
        
        @Override
        public int numEqs() {
            return lhs.size();
        }
    }
    
    /**
     * Handles incidences between variables in a non-scalar FAbstractEquation.
     * Isolates LHS variables from each other.
     * Assumes all LHS variables are dependent on all RHS variables.
     */
    protected class ManyIncidenceMap extends MultiIncidenceMap {
        
        protected Set<V> rhs;
        
        public ManyIncidenceMap(FAbstractEquation e, Set<V> additionalDeps, EnumSet<VarType> variableTypes) {
            super(e, additionalDeps, variableTypes);
            rhs = lookupVarsInSet(equation.FIdUseExpsInRHS());
            if (equation instanceof FAlgorithm) {
                rhs.removeAll(lookupVarsInSet(lhsUses));
            }
            rhs.addAll(additionalDeps);
            
            if (equation instanceof FFunctionCallEquation) {
                buildLhsFunction(variableTypes);
            } else {
                buildLhsOther(variableTypes);
            }
        }
        
        private void buildLhsOther(EnumSet<VarType> variableTypes) {
            int i = 0;
            for (FAbstractVariable fv : ASTNode.lookupFVariablesInSet(lhsUses)) {
                if (variableTypes != null) {
                    if (!addLhs(fv, variableTypes)) {
                        continue;
                    }
                }
                
                V var = getVariable(fv.name());
                lhs.put(i++, var);
            }
        }
        
        @Override
        protected Set<V> rhs(int i) {
            return rhs;
        }
    }
    
    /**
     * Handles incidences between variables in a non-scalar FAbstractEquation.
     * Isolates LHS variables from each other.
     * Computes RHS dependencies for LHS.
     */
    protected class SplitIncidenceMap extends MultiIncidenceMap {
        protected ArrayList<Set<V>> splitMap;
        protected Map<FIdUseExp, Set<FIdUseExp>> resolvedDependencies;
        protected Set<V> additionalDeps;
        
        public SplitIncidenceMap(FFunctionCallEquation e, Set<V> additionalDeps, EnumSet<VarType> variableTypes) {
            super(e, additionalDeps, variableTypes);
            splitMap = new ArrayList<Set<V>>();
            
            this.additionalDeps = additionalDeps;
            
            DependencyVariableEvaluator pve = new DependencyVariableEvaluator();
            e.getCall().evaluate(pve);
            resolvedDependencies = pve.resolveDependencies(e);
            
            buildLhsFunction(variableTypes);
        }
        
        @Override
        protected void buildLhsFunction(FIdUseExp use, int i) {
            super.buildLhsFunction(use, i);
            Set<V> s = lookupVarsInSet(resolvedDependencies.get(use));
            s.addAll(additionalDeps);
            splitMap.add(s);
        }
        
        @Override
        protected Set<V> rhs(int i) {
           return splitMap.get(i);
        }
    }
    
    
    public boolean match(E e, V v) {
        if (!canMatch(e, v))
            return false;
        if (e.getMatching() != null)
            e.getMatching().setMatching(null);
        if (v.getMatching() != null)
            v.getMatching().setMatching(null);
        v.setMatching(e);
        e.setMatching(v);
        return true;
    }

    public boolean canMatch(E e, V v) {
        if (initialSystem)
            return true;
        
        FAbstractEquation equation = e.getEquation();
        FVariable variable = v.getVariable();
        
        if (equation instanceof FAlgorithm)
            return true;
        
        // Discrete variables can only be matched to discrete equations.
        // Except discrete reals in initial system.
        return variable.isContinuous() || e.variability().discreteVariability() || equation.isInitial();
    }

    public void addInsidence(E e, V v) {
        e.addVariable(v);
    }

    public Collection<E> greedyMatching() {
        Collection<E> unmatched = new ArrayList<E>();
        for (E e : getEquations()) {
            if (e.getMatching() != null)
                continue;
            for (V v : e.getVariables()) {
                if (v.getMatching()==null) {
                    match(e, v);
                    break;
                }
            }
            if (e.getMatching() == null)
                unmatched.add(e);
        }
        return unmatched;
    }

    private static class VarMatchingComparator implements Comparator<AbstractVar<?,?>> {
        private Set<FAbstractVariable> hasExtraStartConditions;
        private VarMatchingComparator(Set<FAbstractVariable> hasExtraStartConditions) {
            if (hasExtraStartConditions == null)
                hasExtraStartConditions = Collections.emptySet();
            this.hasExtraStartConditions = hasExtraStartConditions;
        }
        @Override
        public int compare(AbstractVar<?,?> o1, AbstractVar<?,?> o2) {
            boolean b1 = o1.getVariable().startAttributeSet() || hasExtraStartConditions.contains(o1.getVariable());
            boolean b2 = o2.getVariable().startAttributeSet() || hasExtraStartConditions.contains(o2.getVariable());
            int diff = (b1 ? 1 : 0) - (b2 ? 1 : 0);
            if (diff != 0)
                return diff;
            diff = (o1.getVariable().isPreVariable() ? 1 : 0) - (o2.getVariable().isPreVariable() ? 1 : 0);
            if (diff != 0)
                return diff;
            return o1.getName().compareTo(o2.getName());
        }
    }

    public java.util.List<Map<V, Set<E>>> bfs(Collection<E> startingNodes, Comparator<? super V> varComparator) {
        java.util.List<Map<V, Set<E>>> Lv = new ArrayList<Map<V, Set<E>>>();
        Set<E> Le_current = new LinkedHashSet<E>();
        Set<E> Le_next = new LinkedHashSet<E>();
        
        Le_current.addAll(startingNodes);
        // Reset nodes
        lightReset();
        
        int layer = 0;
        boolean freeVarNodeFound = false;
        //System.out.println("************** BFS ************* starting nodes: " + startingNodes);
        
        while (Le_current.size() > 0 && !freeVarNodeFound) {
            //System.out.println("*** layer: " + layer);
            //System.out.println(Lv);
            //System.out.println(Le_current);
            Lv.add(new TreeMap<V, Set<E>>(varComparator));
            
            for (E s : Le_current) {
                //System.out.println(" eq: " + s);
                for (V t : s.getVariables()) {
                    if (!canMatch(s, t))
                        continue;
                    //System.out.println("  " + t + " layer: " + t.getLayer());
                    if (t.getLayer() >= layer) {
                        //System.out.println("    adding " + t);
                        t.setLayer(layer);
                        Set<E> h = Lv.get(layer).get(t);
                        if (h == null) {
                            h = new LinkedHashSet<E>();
                            Lv.get(layer).put(t, h);
                        }
                        h.add(s);
                        E u = t.getMatching();
                        if (u != null) {
                            //System.out.println("     " + t + "'s matching is " + u);
                            u.setLayer(layer);
                            Le_next.add(u);
                        } else {
                            //System.out.println("     " + t + "has no matching");
                            freeVarNodeFound = true;
                        }
                    }
                }
            }
            layer++;
            Le_current = Le_next;
            Le_next = new LinkedHashSet<E>();
        }
        
        java.util.List<V> delQueue = new ArrayList<V>();
        for (V v : Lv.get(Lv.size() - 1).keySet()) {
            if (v.getMatching() != null) {
                delQueue.add(v);
            }
        }
        for (V v : delQueue) {
            Lv.get(Lv.size() - 1).remove(v);
        }
        //System.out.println(Lv);
        //System.out.println("************** BFS ends *************");
        return Lv;
    }

    public java.util.List<java.util.List<Edge>> dfs(java.util.List<Map<V, Set<E>>> Lv) {
        lightReset();
        java.util.List<java.util.List<Edge>> P = new ArrayList<java.util.List<Edge>>();
        
        boolean found_path = true;
        for (V v : Lv.get(Lv.size() - 1).keySet()) {
            ArrayList<Edge> P_tmp = new ArrayList<Edge>();
            
            ListIterator<Map<V, Set<E>>> iter = Lv.listIterator(Lv.size());
            while (iter.hasPrevious()) {
                Map<V, Set<E>> l = iter.previous();
                v.setVisited(true);
                if (!found_path) {
                    break;
                }
                found_path = false;
                for (E e : l.get(v)) {
                    if (!e.isVisited() && canMatch(e, v)) {
                        e.setVisited(true);
                        P_tmp.add(new Edge(e, v));
                        v = e.getMatching();
                        found_path = true;
                        break;
                    }
                }
            }
            if (P_tmp.size() == Lv.size()) {
                P.add(P_tmp);
            }
        }
        //System.out.println(P);
        return P;
    }

    public void reassign(java.util.List<java.util.List<Edge>> P) {
        for (java.util.List<Edge> l : P) {
            for (Edge ed : l) {
                match(ed.getEquation(), ed.getVariable());
            }
        }
    }

    public void maximumMatching(boolean resetMatching) {
        maximumMatching(resetMatching, null);
    }

    public void maximumMatching(boolean resetMatching, Set<FAbstractVariable> hasExtraStartConditions) {
        if (resetMatching) {
            reset();
            greedyMatching();
        }
        
        // Initialize set of free equations
        Set<E> startingNodes = new LinkedHashSet<E>();
        for (E e : getEquations()) {
            if (e.getMatching()==null) {
                startingNodes.add(e);
            }
        }
        
        Set<E> unmatchedEquations = new LinkedHashSet<E>(getUnmatchedEquations());
        
        java.util.List<Map<V, Set<E>>> Lv = null;
        java.util.List<java.util.List<Edge>> P = null;
        Comparator<? super V> varComparator = new VarMatchingComparator(hasExtraStartConditions);
        
        while (unmatchedEquations.size()>0) {
            
            Lv = bfs(unmatchedEquations, varComparator);
            P = dfs(Lv);
            
            if (Lv.get(Lv.size()-1).size()==0) {
                break;
            }
            
            reassign(P);
            
            for (java.util.List<Edge> l : P) {
                unmatchedEquations.remove(l.get(l.size()-1).getEquation());
            }
        }
    }

    public boolean augmentPath(E e) {
        e.setVisited(true);
        for (V v : e.getVariables()) {
            if (!canMatch(e, v))
                continue;
            if (v.getMatching()==null) {
                match(e, v);
                return true;
            } else if (!v.isVisited()) {
                v.setVisited(true);
                if (augmentPath(v.getMatching())) {
                    match(e, v);
                    return true;
                }
            }
        }
        return false;
    }

    protected class UnmatchedEquationsCriteria implements Criteria<E> {
        @Override
        public boolean test(E elem) {
            return elem.getMatching() == null;
        }
    }

    public Iterator<E> unmatchedEquationsIterator() {
        return new FilteredIterator<E>(getEquations().iterator(), new UnmatchedEquationsCriteria());
    }

    public Iterable<E> unmatchedEquationsIterable() {
        return new Iterable<E>() {
            @Override
            public Iterator<E> iterator() {
                return unmatchedEquationsIterator();
            }
        };
    }

    public Collection<E> getUnmatchedEquations() {
        java.util.List<E> l = new ArrayList<E>();
        for (E e : unmatchedEquationsIterable())
            l.add(e);
        return l;
    }

    protected class UnmatchedVariablesCriteria implements Criteria<AbstractVar<?,?>> {
        @Override
        public boolean test(AbstractVar<?,?> elem) {
            return elem.getMatching() == null;
        }
    }

    public Iterator<V> unmatchedVariablesIterator() {
        return new FilteredIterator<V>(getVariables().iterator(), new UnmatchedVariablesCriteria());
    }

    public Iterable<V> unmatchedVariablesIterable() {
        return new Iterable<V>() {
            @Override
            public Iterator<V> iterator() {
                return unmatchedVariablesIterator();
            }
        };
    }

    public Collection<V> getUnmatchedVariables() {
        java.util.List<V> l = new ArrayList<V>();
        for (V v : unmatchedVariablesIterable())
            l.add(v);
        return l;
    }

    public java.util.List<E> getMatchedEquations() {
        java.util.List<E> l = new ArrayList<E>();
        for (E e : getEquations()) {
            if (e.getMatching()!=null) {
                l.add(e);
            }
        }
        return l;
    }

    public java.util.List<V> getMatchedVariables() {
        java.util.List<V> l = new ArrayList<V>();
        for (V v : getVariables()) {
            if (v.getMatching()!=null) {
                l.add(v);
            }
        }
        return l;
    }

    public Collection<E> getVisitedEquations() {
        Collection<E> l = new ArrayList<E>();
        for (E e: getEquations()) {
            if (e.isVisited())
                l.add(e);
        }
        return l;
    }

    public Collection<V> getVisitedVariables() {
        Collection<V> l = new ArrayList<V>();
        for (V v: getVariables()) {
            if (v.isVisited())
                l.add(v);
        }
        return l;
    }

    private static Collection<SCCContributor> SCCContributors;

    /**
     * Adds a new strongly connected component contributor to the list of
     * contributors.
     */
    private static <T extends SCCContributor> T addSCCContributor(T contributor) {
        if (SCCContributors == null)
            SCCContributors = new ArrayList<SCCContributor>();
        SCCContributors.add(contributor);
        return contributor;
    }

    /**
     * Retrevies the list of strongly connected component contributors.
     * This method should always be used since it ensures that the list is
     * initialized propperly.
     */
    public static Collection<SCCContributor> getSCCContributors() {
        if (SCCContributors == null)
            SCCContributors = new ArrayList<SCCContributor>();
        return SCCContributors;
    }
    
    /**
     * Abstract class for describing arc contributors to Tarjan's strongly
     * connected components algorithm.
     */
    private static abstract class SCCContributor {
        private final String option;
        
        private SCCContributor() {
            option = null;
        }

        private SCCContributor(String option) {
            this.option = option;
        }

        public boolean isActive(OptionRegistry options) {
            return option == null || options != null && options.getBooleanOption(option);
        }

        /**
         * This method returns a list of equations that the supplied equation
         * depend on. This method is implemented by the overriding class.
         * 
         * Surounding BiPGraph is provided for convenience
         */
        public abstract <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> members(E equation, AbstractBiPGraph<E, V, ?> graph);

        /**
         * This method returns a map that map an equation to a list of object
         * identifiers. All equations that are associated with the same object
         * identifier are kept in the same block.
         * 
         * Surounding BiPGraph is provided for convenience
         */
        public abstract <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Map<E, Collection<? extends Object>> memberSets(E equation, AbstractBiPGraph<E, V, ?> graph);
    }
    
    private static final GroupMemberContributor GROUP_MEMBER_CONTRIBUTOR = addSCCContributor(new GroupMemberContributor());
    
    /**
     * Contributor that describes the relationship between BiPGrah equations
     * that link to the same AST equation, for example FFunctionCallEquations.
     */
    private static class GroupMemberContributor extends SCCContributor {
        
        @Override
        public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Collection<E> members(E equation, AbstractBiPGraph<E, V, ?> graph) {
            return equation.getGroupMembers();
        }
        
        @Override
        public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> Map<E, Collection<? extends Object>> memberSets(E equation, AbstractBiPGraph<E, V, ?> graph) {
            return Collections.emptyMap();
        }
    }
    
    protected abstract C createComponentBlock();

    public Collection<C> tarjan() {
        return tarjan(null);
    }
    

    public Collection<C> tarjan(OptionRegistry options) {
        Enumerator indexer = new Enumerator();
        Stack<E> stack = new Stack<E>();
        Collection<C> components = new ArrayList<C>();
        tarjanReset();

        Collection<SCCContributor> contributors = new ArrayList<SCCContributor>();
        Map<Object, Collection<E>> memberSetsMap = new HashMap<Object, Collection<E>>();
        Map<E, Collection<Collection<E>>> keepTogetherMap = new LinkedHashMap<E, Collection<Collection<E>>>();

        for (SCCContributor contributor : getSCCContributors()) {
            if (!contributor.isActive(options))
                continue;
            contributors.add(contributor);
            for (E equation : getEquations()) {
                for (Map.Entry<E, Collection<? extends Object>> eqIdent : contributor.memberSets(equation, this).entrySet()) {
                    for (Object identifier : eqIdent.getValue()) {
                        Collection<E> memberSet = memberSetsMap.get(identifier);
                        if (memberSet == null) {
                            memberSet = new ArrayList<E>();
                            memberSetsMap.put(identifier, memberSet);
                        }
                        Collection<Collection<E>> keepTogetherLists = keepTogetherMap.get(eqIdent.getKey());
                        if (keepTogetherLists == null) {
                            keepTogetherLists = new ArrayList<Collection<E>>();
                            keepTogetherMap.put(eqIdent.getKey(), keepTogetherLists);
                        }
                        memberSet.add(eqIdent.getKey());
                        keepTogetherLists.add(memberSet);
                    }
                }
            }
        }

        Map<E, Collection<E>> eqToVisitMap = new HashMap<E, Collection<E>>();

        for (E e : getEquations()) {
            if (!e.isVisited() && e.tarjanVisit())
                tarjan(indexer, stack, components, contributors, keepTogetherMap, eqToVisitMap, e);
        }

        return components;
    }

    public void tarjan(Enumerator indexer, Stack<E> stack, Collection<C> components, Collection<SCCContributor> contributors, Map<E, Collection<Collection<E>>> keepTogetherMap, Map<E, Collection<E>> eqToVisitMap,  E e) {
        int index = indexer.next();
        e.setTarjanNbr(index);
        e.setTarjanLowLink(index);
        e.setVisited(true);
        Collection<E> eqToVisit = new ArrayList<E>();
        Collection<Collection<E>> keepTogetherLists = keepTogetherMap.get(e);
        if (keepTogetherLists != null)
            for (Collection<E> keepTogether : keepTogetherLists)
                for (E ee : keepTogether)
                    if (ee != e && ee.tarjanVisit())
                        eqToVisit.add(ee);
        for (V v : e.getVariables()) {
            E ee = v.getMatching();
            if (ee != null && e != ee && v.tarjanVisit())
                eqToVisit.add(ee);
        }
        for (SCCContributor contributor : contributors)
            for (E ee : contributor.members(e, this))
                if (e != ee && ee.tarjanVisit())
                    eqToVisit.add(ee);
        stack.add(e);
        eqToVisitMap.put(e, eqToVisit);
        for (E ee : eqToVisit) {
            if (!ee.isVisited()) {
                tarjan(indexer, stack, components, contributors, keepTogetherMap, eqToVisitMap, ee);
                e.setTarjanLowLink(Math.min(e.getTarjanLowLink(), ee.getTarjanLowLink()));
            } else if (stack.contains(ee)) { //TODO: should not be stack.contains, it's slow...
                e.setTarjanLowLink(Math.min(e.getTarjanLowLink(), ee.getTarjanNbr()));
            }
        }
        if (e.getTarjanNbr() == e.getTarjanLowLink()) {
            C component = createComponentBlock();
            E ee;
            do {
                ee = stack.pop();
                component.addMember(ee);
                component.addPredecessors(eqToVisitMap.remove(ee));
            } while (ee != e);
            components.add(component);
        }
    }

    public void reset() {
        for (E e : getEquations()) {
            e.reset();
        }
        for (V v : getVariables()) {
            v.reset();
        }
    }

    public void lightReset() {
        for (E e : getEquations()) {
            e.lightReset();
        }
        for (V v : getVariables()) {
            v.lightReset();
        }
    }

    public void tarjanReset() {
        for (E e : getEquations()) {
            e.tarjanReset();
        }
    }

    public void insertIntoEquationIndexMap(FAbstractEquation eqn, E e) {
        java.util.List<E> l = equationIndexMap.get(eqn);
        if (l==null) {
            l = new ArrayList<E>();
            equationIndexMap.put(eqn, l);
        }
        l.add(e);
    }

    public void removeFromEquationIndexMap(FAbstractEquation eqn, E e) {
        java.util.List<E> l = equationIndexMap.get(eqn);
        if (l!=null) {
            for (E ee : l) {
                if (e==ee) {
                    l.remove(e);
                    return;
                }
            }
        }
    }

    public String printMatching() {
        StringBuffer str = new StringBuffer();
        str.append("----------------------------------------\n");
        str.append("BiPGraph matching:\n");
        for (E e : getEquations()) {
            if (e.getMatching()!=null) {
                str.append(e);
                str.append(" : ");
                str.append(e.getMatching());
                str.append("\n");
            }
        }       
        str.append("Unmatched equations: {");
        for (E e : unmatchedEquationsIterable()) {
            str.append(e + " ");
        }
        str.append("}\n");
        
        str.append("Unmatched variables: {");
        for (V v : unmatchedVariablesIterable()) {
            str.append(v + " ");
        }
        str.append("}\n");
        
        str.append("----------------------------------------\n");
        return str.toString();
    }

    public Object printMatchingObj() {
        return new Object() {
            @Override
            public String toString() {
                return printMatching();
            }
        };
    }

    public String toString() {
        StringBuffer str = new StringBuffer();
        str.append("BiPGraph (" + getEquations().size() + " equations, " + variableMap.size() + " variables)\n");
        str.append("Variables: {");
        for (String vName : variableMap.keySet()) {
            V v = variableMap.get(vName);
            str.append(v);
            str.append(" ");
        }
        str.append("}\n");
        for (E e : getEquations()) {
            str.append(e);
            str.append(" : ");
            for (V v : e.getVariables()) {
                str.append(v + (canMatch(e, v) ? "@ " : "# "));
            }
            str.append("// " + e.printEquation() + "\n");
        }
        return str.toString();
    }

    public class Edge {
        private V variable;
        private E equation;

        public Edge(E e, V v) {
            this.equation = e;
            this.variable = v;
        }

        public V getVariable() {
            return variable;
        }

        public void setVariable(V variable) {
            this.variable = variable;
        }

        public E getEquation() {
            return equation;
        }

        public void setEquation(E equation) {
            this.equation = equation;
        }

        public String toString() {
            return "(" + equation + "," + variable + ")";
        }

    }
}

/**
 * This class represent a component result from Tarjan's strongly connected
 * components algorithm.
 * It is basically a list of equations that depends on eachother and a list of
 * equations that they depend upon.
 */
public class SCCBlock<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> implements Iterable<E> {
    private Collection<E> members = new LinkedHashSet<E>();
    private Collection<E> predecessors = null;

    
    public SCCBlock() {}
    
    public void addPredecessors(Collection<E> newPredecessors) {
        if (predecessors == null)
            predecessors = new LinkedHashSet<E>();
        for (E eqn : newPredecessors)
            if (!members.contains(eqn))
                predecessors.add(eqn);
    }

    public void addMember(E member) {
        // Ensure that the member isn't in the list of predecessors
        if (predecessors != null)
            predecessors.remove(member);
        members.add(member);
    }
    
    public Collection<E> getMembers() {
        return members;
    }
    
    @Override
    public Iterator<E> iterator() {
        return members.iterator();
    }
    
    public boolean hasPredecessorInfo() {
        return predecessors != null;
    }
    
    public Collection<E> getPredecessors() {
        return predecessors;
    }
    @Override
    public String toString() {
        return members.toString();
    }
}

public class BiPGraph extends AbstractBiPGraph<Eq, Var, SCCBlock<Eq, Var>> {

    public BiPGraph() {
        super();
    }

    public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> BiPGraph(Collection<E> block) {
        super(block);
    }

    public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> BiPGraph(Collection<E> eqns, Collection<V> vars) {
        super(eqns, vars);
    }

    @Override
    protected Eq createEq(String name, FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability) {
        return new Eq(name, eqn, groupNumber, variability);
    }

    @Override
    protected Var createVar(String name, FVariable var) {
        return new Var(name, var);
    }
    
    @Override
    protected SCCBlock<Eq, Var> createComponentBlock() {
        return new SCCBlock<Eq, Var>();
    }
}

public class Eq extends AbstractEq<Eq, Var> {

    public Eq(String name, FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability) {
        super(name, eqn, groupNumber, variability);
    }

}

public class Var extends AbstractVar<Eq, Var> {

    public Var(String name, FVariable v) {
        super(name, v);
    }

}


public class SolvingBiPGraph extends AbstractBiPGraph<SolvingEq, SolvingVar, SCCBlock<SolvingEq, SolvingVar>> {

    public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> SolvingBiPGraph(Collection<E> eqns, Collection<V> vars) {
        super(eqns, vars);
    }

    public <E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> SolvingBiPGraph(Collection<E> block) {
        super(block);
    }

    @Override
    public boolean canMatch(SolvingEq e, SolvingVar v) {
        return super.canMatch(e, v) && isSolved(e, v).isSolvable();
    }

    public Solvability isSolved(SolvingEq e, SolvingVar v) {
        return e.getEquation().isSolved(v.getVariable(), true);
    }

    @Override
    public void addInsidence(SolvingEq e, SolvingVar v) {
        super.addInsidence(e, v);
        v.occurrence();
        if (e.getEquation().isReal() != v.getVariable().isReal())
            return;
        e.sameTypeOccurrence();
        v.sameTypeOccurrence();
        Solvability solvability = isSolved(e, v);
        switch (solvability) {
        case ANALYTICALLY_SOLVABLE:
            e.addAnalyticallySolvableVariable(v);
            v.analyticallySolvableOccurrence();
            break;
        case NUMERICALLY_SOLVABLE:
            e.addNumericallySolvableVariable(v);
            v.numericallySolvableOccurrence();
            break;
        }
    }

    @Override
    protected SolvingEq createEq(String name, FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability) {
        return new SolvingEq(name, eqn, groupNumber, variability);
    }

    @Override
    protected SolvingVar createVar(String name, FVariable var) {
        return new SolvingVar(name, var);
    }

    @Override
    public void removeVariable(SolvingVar v) {
        for (SolvingEq e : getEquations())
            e.getSolvableVariables().remove(v);
        super.removeVariable(v);
    }

    @Override
    protected SCCBlock<SolvingEq, SolvingVar> createComponentBlock() {
        return new SCCBlock<SolvingEq, SolvingVar>();
    }
}

public class SolvingEq extends AbstractEq<SolvingEq, SolvingVar> implements Comparable<SolvingEq> {

    private java.util.List<SolvingVar> solvableVariables = new ArrayList<SolvingVar>();
    private int analyticallySolvableOccurrences = 0;
    private int numericallySolvableOccurrences = 0;
    private int sameTypeOccurrences = 0;
    private boolean isRes = false;

    public SolvingEq(String name, FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability) {
        super(name, eqn, groupNumber, variability);
    }

    public void sameTypeOccurrence(){
        sameTypeOccurrences++;
    }

    public int getNbrSameTypeOccurrences(){
        return sameTypeOccurrences;
    }

    public void addAnalyticallySolvableVariable(SolvingVar v) {
        solvableVariables.add(v);
        analyticallySolvableOccurrences++;
    }

    public void addNumericallySolvableVariable(SolvingVar v) {
        solvableVariables.add(v);
        numericallySolvableOccurrences++;
    }

    public java.util.List<SolvingVar> getSolvableVariables() {
        return solvableVariables;
    }

    public void isRes(boolean bol){
        isRes = bol;
    }

    public boolean isRes(){
        return isRes;
    }

    public boolean tarjanVisit() {
        return !isRes();
    }

    /**
     * Returns integer greather than zero if this variable sutes better as iteration
     * variable than the <code>other</code> variable. Zero is returned if they are equal
     * and <0 is returned if the <code>other</code> variable is better.
     */
    @Override
    public int compareTo(SolvingEq other) {
        int diff = (isReal() ? 1 : 0) - (other.isReal() ? 1 : 0);
        if (diff != 0)
            return diff;
        diff = getNbrSameTypeOccurrences() - other.getNbrSameTypeOccurrences();
        if (diff != 0)
            return diff;
        diff = numericallySolvableOccurrences - other.numericallySolvableOccurrences;
        if (diff != 0)
            return diff;
        diff = other.analyticallySolvableOccurrences - analyticallySolvableOccurrences;
        if (diff != 0)
            return diff;
        return 0;
    }

}

public class SolvingVar extends AbstractVar<SolvingEq, SolvingVar> implements Comparable<SolvingVar> {

    private int occurrences = 0;
    private int sameTypeOccurrences = 0;
    private int analyticallySolvableOccurrences = 0;
    private int numericallySolvableOccurrences = 0;
    private boolean isIter = false;

    public SolvingVar(String name, FVariable v) {
        super(name, v);
    }

    public void occurrence(){
        occurrences++;
    }

    public void sameTypeOccurrence(){
        sameTypeOccurrences++;
    }

    public void analyticallySolvableOccurrence(){
        analyticallySolvableOccurrences++;
    }

    public void numericallySolvableOccurrence(){
        numericallySolvableOccurrences++;
    }

    public int getNbrOccurrences(){
        return occurrences;
    }

    public int getNbrSameTypeOccurrences(){
        return sameTypeOccurrences;
    }

    public int getNbrAnalyticallySolvableOccurrences(){
        return analyticallySolvableOccurrences;
    }

    public int getNbrNumericallySolvableOccurrences(){
        return numericallySolvableOccurrences;
    }

    public void isIter(boolean bol){
        isIter = bol;
    }

    public boolean isIter(){
        return isIter;
    }

    public boolean tarjanVisit() {
        return !isIter();
    }

    /**
     * Returns integer greather than zero if this variable sutes better as iteration
     * variable than the <code>other</code> variable. Zero is returned if they are equal
     * and <0 is returned if the <code>other</code> variable is better.
     */
    @Override
    public int compareTo(SolvingVar other) {
        int diff = (isReal() ? 1 : 0) - (other.isReal() ? 1 : 0);
        if (diff != 0)
            return diff;
        diff = (other.getVariable().isTemporary() ? 1 : 0) - (getVariable().isTemporary() ? 1 : 0);
        if (diff != 0)
            return diff;
        diff = getNbrSameTypeOccurrences() - other.getNbrSameTypeOccurrences();
        if (diff != 0)
            return diff;
        diff = getNbrNumericallySolvableOccurrences() - other.getNbrNumericallySolvableOccurrences();
        if (diff != 0)
            return diff;
        diff = other.getNbrAnalyticallySolvableOccurrences() - getNbrAnalyticallySolvableOccurrences();
        if (diff != 0)
            return diff;
        diff = (getVariable().attributeSet(FAttribute.START) ? 1 : 0) - (other.getVariable().attributeSet(FAttribute.START) ? 1 : 0);
        if (diff != 0)
            return diff;
        diff = other.getVariable().getFQName().numDots() - getVariable().getFQName().numDots();
        if (diff != 0)
            return diff;
        return 0;
    }
}


public abstract class AbstractEq<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> {

    private final String name;
    private final FAbstractEquation eqn;
    private final int groupNumber;
    private final FTypePrefixVariability variability;
    private java.util.List<V> variables = new ArrayList<V>();
    private V matching = null;
    private boolean visited = false;
    private int layer = 1000000;
    private int tarjanNbr = 0;
    private int tarjanLowLink = 0;
    private int depth = 1;
    /** In some cases, equations needs to be treated as a group, e.g., in the
     * case when several equations are generated from a function call equation.
     * In this case, all the "scalar" equations generated for the function call
     * equation are members of each such equation. Note that every equation is
     * member of its own group: scalar equations therefor has one member:
     * itself. This approach makes handling of equation groups more consistent,
     * e.g., when a function call equation needs to be differentiated.
     */
    private Set<E> groupMembers = new LinkedHashSet<E>();

    public AbstractEq(String name, FAbstractEquation eqn, int groupNumber, FTypePrefixVariability variability) {
        this.name = name;
        this.eqn = eqn;
        this.groupNumber = groupNumber;
        this.variability = variability;
    }

    public void addVariable(V v) {
        variables.add(v);
    }

    public void reset() {
        setMatching(null);
        setVisited(false);
        setLayer(1000000);
    }

    public void lightReset() {
        setVisited(false);
        setLayer(1000000);
    }

    public void tarjanReset() {
        setTarjanLowLink(0);
        setTarjanNbr(0);
        setVisited(false);
    }

    public String getName() {
        return name;
    }

    public FAbstractEquation getEquation() {
        return eqn;
    }

    public int groupNumber() {
        return groupNumber;
    }

    public java.util.List<V> getVariables() {
        return variables;
    }

    public V getMatching() {
        return matching;
    }

    public void setMatching(V matching) {
        this.matching = matching;
    }

    public boolean isVisited() {
        return visited;
    }

    public void setVisited(boolean visited) {
        this.visited = visited;
    }

    public boolean tarjanVisit() {
        return true;
    }

    public int getLayer() {
        return layer;
    }

    public void setLayer(int layer) {
        this.layer = layer;
    }

    public int getTarjanNbr() {
        return tarjanNbr;
    }

    public void setTarjanNbr(int tarjanNbr) {
        this.tarjanNbr = tarjanNbr;
    }

    public int getTarjanLowLink() {
        return tarjanLowLink;
    }

    public void setTarjanLowLink(int tarjanLowLink) {
        this.tarjanLowLink = tarjanLowLink;
    }

    public String toString() {
        return getName();
    }

    public String printEquation() {
        return getEquation().toString();
    }

    public boolean isReal() {
        return getEquation().isReal();
    }

    public int getDepth(){
        return this.depth;
    }

    public void setDepth(int d){
        this.depth = d;
    }

    public void addGroupMember(E eqn) {
        groupMembers.add(eqn);
    }

    public Set<E> getGroupMembers() {
        return groupMembers;
    }

    public V getVariable(String name) {
        for (V var : variables) {
            if (var.getName().equals(name)) {
                return var;
            }
        }
        return null;
    }

    public FTypePrefixVariability variability() {
        return variability;
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof AbstractEq))
            return false;
        AbstractEq other = (AbstractEq)o;
        return getName().equals(other.getName());
    }

    @Override
    public int hashCode() {
        return getName().hashCode();
    };

}

public abstract class AbstractVar<E extends AbstractEq<E, V>, V extends AbstractVar<E, V>> {

    private final String name;
    private final FVariable v;
    private E matching = null;
    private boolean visited = false;
    private int layer = 1000000;

    public AbstractVar(String name, FVariable v) {
        this.name = name;
        this.v = v;
    }

    public void reset() {
        setMatching(null);
        setVisited(false);
        setLayer(1000000);
    }

    public void lightReset() {
        setVisited(false);
        setLayer(1000000);
    }

    public String getName() {
        return name;
    }

    public FVariable getVariable() {
        return v;
    }

    public E getMatching() {
        return matching;
    }

    public void setMatching(E matching) {
        this.matching = matching;
    }

    public boolean isVisited() {
        return visited;
    }

    public void setVisited(boolean visited) {
        this.visited = visited;
    }

    public boolean tarjanVisit() {
        return true;
    }

    public int getLayer() {
        return layer;
    }

    public void setLayer(int layer) {
        this.layer = layer;
    }

    public String toString() {
        return v.displayName();
    }

    public boolean isReal() {
        return getVariable().isReal();
    }

    @Override
    public boolean equals(Object o) {
        if (!(o instanceof AbstractVar))
            return false;
        AbstractVar other = (AbstractVar)o;
        return getName().equals(other.getName());
    }

    @Override
    public int hashCode() {
        return getName().hashCode();
    };
}

public Set<V> AbstractBiPGraph.lookupVarsInSet(Set<FIdUseExp> set) {
    Set<V> res = new LinkedHashSet<V>();
    for (FIdUseExp use : set) {
        V var = getVariable(use.name());
        if (var != null)
            res.add(var);
    }
    return res;
}
    
    public class FAbstractEquation {
        public <V> AbstractBiPGraph.IncidenceMap createIncidenceMap(AbstractBiPGraph g, Set<V> additionalDependencies, EnumSet<AbstractBiPGraph.VarType> variableTypes) {
            return g.new IncidenceMap(this, additionalDependencies);
        }
    }
    
    public class FAlgorithm {
        public <V> AbstractBiPGraph.IncidenceMap createIncidenceMap(AbstractBiPGraph g, Set<V> additionalDependencies, EnumSet<AbstractBiPGraph.VarType> variableTypes) {
            return g.new ManyIncidenceMap(this, additionalDependencies, variableTypes);
        }
    }
    
    public class FIfEquation {
        public <V> AbstractBiPGraph.IncidenceMap createIncidenceMap(AbstractBiPGraph g, Set<V> additionalDependencies, EnumSet<AbstractBiPGraph.VarType> variableTypes) {
            return g.new ManyIncidenceMap(this, additionalDependencies, variableTypes);
        }
    }
    
    public class FFunctionCallEquation {
        public <V> AbstractBiPGraph.IncidenceMap createIncidenceMap(AbstractBiPGraph g, Set<V> additionalDependencies, EnumSet<AbstractBiPGraph.VarType> variableTypes) {
            if (root().options.getStringOption("function_incidence_computation").equals("all")) {
                try {
                    return g.new SplitIncidenceMap(this, additionalDependencies, variableTypes);
                } catch (ConstantEvaluationException e) {
                    
                }
            }
            return g.new ManyIncidenceMap(this, additionalDependencies, variableTypes);
        }
    }
    


}