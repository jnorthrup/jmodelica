
/*
Copyright (C) 2009-2017 Modelon AB

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, version 3 of the License.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect CCodeGenFunctionPartial {

    /**
     * \brief Generates forward declarations for FPCL and FPCR functions used
     * by partial function calls.
     */
    public void FFunctionDecl.genHeadersPartial(CodePrinter p, CodeStream str, String indent) {
        prettyPrintHeadFPCL(p, str, indent);
        str.println(";");
        prettyPrintHeadFPCR(p, str, indent);
        str.println(";");
    }

    /**
     * \brief Generates FP and OUT structs used by partial function calls.
     */
    public void FFunctionDecl.genStructsPartial(CodePrinter p, CodeStream str, String indent) {
        String fp  = p.funcNameUnderscore(this, C_SUFFIX_FP);
        String out = p.funcNameUnderscore(this, C_SUFFIX_FPOUT);
        String next = p.indent(indent);
        
        beginStruct_C(str, indent, out);
        str.formatln("%sint n;", next);
		for (FFunctionVariable ffv : myOutputs()) {
            p.printStructDecl(ffv, str, next);
        }
        endStruct_C(str, indent);
        
        beginStruct_C(str, indent, fp);
        str.formatln("%s%s (*fpcl)(%s*, %s*, ...);", next, getDeclaredType_C(), fp, out);
        str.formatln("%s%s* (*fpcr)(%s*, %s*, ...);", next, fp, fp, fp);
		for (FFunctionVariable ffv : myInputs()) {
            p.printStructDecl(ffv, str, next);
        }
        endStruct_C(str, indent);
    }

    //TODO: this belongs in the CCodeGenFunction aspect, move it there
    public abstract String CodePrinter.funcNameUnderscore(FCallable fc, String suffix);
    
    @Override
    public String CPrettyPrinter.funcNameUnderscore(FCallable fc, String suffix) {
        return fc.funcNameUnderscore(suffix);
    }

    /**
     * \brief Generate first line of struct declaration name_ with typedef to name
     */
    public static void FFunctionDecl.beginStruct_C(CodeStream str, String indent, String name) {
        str.formatln("%stypedef struct %s_ %s;", indent, name, name);
        str.formatln("%sstruct %s_ {", indent, name);
    }

    /**
     * \brief Generate last line of struct declaration
     */
    public static void FFunctionDecl.endStruct_C(CodeStream str, String indent) {
        str.formatln("%s};", indent);
    }

    /**
    * \brief Generate variable declarations inside an FP or OUT struct
    */
    public abstract void CodePrinter.printStructDecl(FFunctionVariable ffv, CodeStream str, String indent);
    
	@Override
	public void CPrettyPrinter.printStructDecl(FFunctionVariable v, CodeStream str, String indent) {
		v.printStructDecl(ExecStep, str, indent);
	}
    
    public void FFunctionVariable.printStructDecl(CodePrinter.ExecuteCodePrinter p, CodeStream str, String indent) {
            str.println(indent, p.type(this)," ", p.name(this), ";");
            if(isInput())
                str.println(indent, "int ", p.name(this), C_SUFFIX_SETFLAG, ";");
    }

    /**
     * \brief Generate declaration for varargs
     */
    public void FFunctionDecl.genVarArgsDecl(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_list argp;");
    }

    /**
     * \brief Generate initialization for varargs
     */
    public void FFunctionDecl.genVarArgsOpen(CodeStream str, String indent, String last) {
        str.print(indent);
        str.print("va_start(argp, ");
        str.print(last);
        str.println(");");
    }

    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String indent, String dest, String type) {
        str.print(indent);
        str.print(dest);
        str.print(" = ");
        genVarArgsRead(str, type);
        str.println(";");
    }

    /**
     * \brief Generate use for varargs
     */
    public void FFunctionDecl.genVarArgsRead(CodeStream str, String type) {
        str.print("va_arg(argp, ");
        str.print(type);
        str.print(")");
    }

    /**
     * \brief Generate closing for varargs
     */
    public void FFunctionDecl.genVarArgsClose(CodeStream str, String indent) {
        str.print(indent);
        str.println("va_end(argp);");
    }

    /**
     * \brief Generate header for FPCL function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCL(CodePrinter p, CodeStream str, String indent) {
        str.format("%s%s %s(%s* fp_in, %s* out, ...)", indent, getDeclaredType_C(),p.funcNameUnderscore(this, C_SUFFIX_FPCL),
                p.funcNameUnderscore(this, C_SUFFIX_FP), p.funcNameUnderscore(this, C_SUFFIX_FPOUT));
    }

    /**
     * \brief Generate header for FPCR function.
     */
    public void FFunctionDecl.prettyPrintHeadFPCR(CodePrinter p, CodeStream str, String indent) {
        String fp = p.funcNameUnderscore(this, C_SUFFIX_FP);
        str.format("%s%s* %s(%s* fp_in, %s* fp_out, ...)", indent, fp, p.funcNameUnderscore(this, C_SUFFIX_FPCR), fp, fp);
    }

    /**
     * \brief Generates FPCL and FPCR functions used by partial function calls.
     */
    public void FFunctionDecl.prettyPrintPartial_C(CodePrinter p, CodeStream str, String indent) {
int i;
        String next = p.indent(indent);
        String next2 = p.indent(next);
        String next3 = p.indent(next2);
        String fp = p.funcNameUnderscore(this, C_SUFFIX_FP);
        ArrayList<FFunctionVariable> inputs  = myInputs();
        ArrayList<FFunctionVariable> outputs = myOutputs();
        int n = inputs.size() + outputs.size();
        //TODO generate exps instead (want to reuse HeadComputation), right now they are threaded through the whole computation
        String[] names = new String[n];
        for (i = 0; i < n; i++) {
            names[i] = "tmp_" + (i+1); 
        }
        
        // FPCL
        prettyPrintHeadFPCL(p, str, indent);
        str.print(" {\n");
        
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%s%s %s;", next, p.ExecStep.type(ffv), names[i++]);
        }
        for (FFunctionVariable ffv : outputs) {
            str.formatln("%s%s %s;", next, p.ExecStep.type(ffv), names[i++]);
        }
        
        //unpack from the input struct
        genVarArgsDecl(str, next);
        genVarArgsOpen(str, next, "out");
        i = 0;
        for (FFunctionVariable ffv : inputs) {
              str.formatln("%sif (fp_in->%s_s) {", next, p.ExecStep.name(ffv));
              str.formatln("%s%s = fp_in->%s;", next2, names[i], p.ExecStep.name(ffv));
              str.formatln("%s} else {", next);
              genVarArgsRead(str, next2, names[i], p.ExecStep.type(ffv));
              str.formatln("%s}", next);
              i++;
        }
        genVarArgsClose(str, next);
        
//        new ParameterComputation(null, "").prettyPrintHead(this, p, str, indent, C_SUFFIX_DEF, true);
        str.format("%s%s(", next, p.funcNameUnderscore(this, C_SUFFIX_DEF));
        String prefix = "";
        i = 0;
        for (FFunctionVariable ffv : inputs) {
            str.print(prefix);
            str.print(names[i++]);
            prefix = ", ";
        }
        for (FFunctionVariable ffv : outputs) {
            str.print(prefix);
            str.print("&");
            str.print(names[i++]);
        }
        str.println(");");
        
        //pack the output struct
        str.formatln("%sif (out != NULL) {",next);
        i = 0;
        for (FFunctionVariable ffv : outputs) {
              str.formatln("%sif (out->n > %d) {", next2, i);
              str.formatln("%sout->%s = %s;", next3, p.ExecStep.name(ffv), names[i + inputs.size()]);
              str.formatln("%s}", next2);
              i++;
        }
        str.formatln("%s}",next);
        if (outputs.size() > 0)
            str.formatln("%sreturn %s;", next, names[inputs.size()]);
        str.format("%s}\n\n", indent);
        
        
        // FPCR
        prettyPrintHeadFPCR(p, str, indent);
        str.print(" {\n");
        genVarArgsDecl(str, next);
        str.formatln("%sif (fp_out == NULL) {", next);
        str.formatln("%sfp_out = malloc(sizeof(%s));", next2, fp);
        str.formatln("%s}", next);
        
        str.formatln("%sfp_out->fpcl = &%s;", next, p.funcNameUnderscore(this, C_SUFFIX_FPCL));
        str.formatln("%sfp_out->fpcr = &%s;", next, p.funcNameUnderscore(this, C_SUFFIX_FPCR));
        
        str.formatln("%sif (fp_in == NULL) {", next);
        for (FFunctionVariable ffv : inputs) {
            str.formatln("%sfp_out->%s_s = 0;", next2, p.ExecStep.name(ffv));
        }
        str.formatln("%s} else {", next);
        for (FFunctionVariable ffv : inputs) {
            String name = p.ExecStep.name(ffv);
            str.formatln("%sfp_out->%s_s = fp_in->%s_s;", next2, name, name);
            str.formatln("%sfp_out->%s = fp_in->%s;", next2, name, name);
        }
        str.formatln("%s}", next);
        
        genVarArgsOpen(str, next, "fp_out");
        for (FFunctionVariable ffv : inputs) {
            String name = p.ExecStep.name(ffv);
            str.format("%sif (!fp_out->%s_s && ", next, name);
            genVarArgsRead(str, "int");
            str.println(") {");
            str.formatln("%sfp_out->%s_s = 1;", next2, name);
            genVarArgsRead(str, next2, "fp_out->" + name, p.ExecStep.type(ffv));
            str.formatln("%s}", next);
        }
        genVarArgsClose(str, next);
        
        str.formatln("%sreturn fp_out;", next);
        str.format("%s}\n\n", indent);
    }

    @Override
    public void FFunctionVariable.prettyPrintCall_C(CodePrinter p, CodeStream str, String indent, FFunctionCall call) {
        boolean exp = call.functionCallIsExp();
        String out = "NULL";
        if (!exp) {
            //pack the struct
            // assign to struct.n
            out = p.ExecStep.name(call);
            str.formatln("%s%s.n = %s;", indent, out, call.myLefts().size());
            out = "&" +out;
            str.print(indent);
        }
        // print call to fpcl 
        str.format("%s->fpcl(%s, %s", p.ExecStep.name(this), p.ExecStep.name(this), out);
        for (FExp arg : call.getArgs()) {
            p.printCastArgument(arg, str, indent);
        }
        str.print(")");
        if (!exp) {
            str.print(";\n");
        }
        if (!exp) {
            //unpack the struct
			for (FFunctionCallLeft arg : call.myLefts()) {
			    //this is one more relationship between an fexp and a functioncallleft
				String n = p.ExecStep.name(arg);
				str.formatln("%s%s = %s.%s;", indent, n, p.ExecStep.name(call), n);
            }
        }
    }

    //TODO: move this to CCodeGenFunctionIO?
    /**
    * \brief Generate cast argument
    */
    public abstract void CodePrinter.printCastArgument(FExp arg, CodeStream str, String indent);
    
	@Override
	public void CPrettyPrinter.printCastArgument(FExp arg, CodeStream str, String indent) {
		arg.printCastArgument(ExecStep, str, indent);
	}
    
    public void FExp.printCastArgument(CodePrinter.ExecuteCodePrinter p, CodeStream str, String indent) {
            // just like the normal printArgument, except sep is a constant ", ", 
            // this is by luck since we know that in the contexts where we use this method 
            // (for now), we always have a preceding argument(the function pointers). Generalize this?
            str.print(", ", "(", type().type_C(),")","(");
            genTempArg(p, str, indent);
            str.print(")");
    }

    @Override
    public void FPartialFunctionCall.prettyPrint_C(CodePrinter p, CodeStream str, String indent) {
        FCallable fc = myFCallable();

        String previous = "NULL";
        if (fc.isPartialFunction()) {
            previous = p.ExecStep.name((FFunctionVariable) fc);
            str.print(previous);
            str.print("->fpcr");
        } else {
            str.print(p.funcNameUnderscore(fc, C_SUFFIX_FPCR));
        }
        str.print("(");
        str.print(previous);
        str.print(", ");

		String result = "NULL"; 
        if(!fc.isPartialFunction()) {
            result = "&" + p.ExecStep.name(this);
         }
        str.print(result);
        
        /* Print "0" for the inputs we don't set, and "1, value" for those we do set */
        Iterator<FIdUse> it = getArgNames().iterator();
        Iterator<FFunctionVariable> it2 = fc.myInputs().iterator();
        for (FExp arg : getArgs()) {
            String name = it.next().name();
            while (!it2.next().name().equals(name)) {
                str.print(", 0");
            }
            str.print(", 1");
            p.printCastArgument(arg, str, indent);
        }
        while (it2.hasNext()) {
            str.print(", 0");
            it2.next();
        }
        
        str.print(")");
    }
}