<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch_models"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Working with Models</title>

  <section xml:id="models_sec_introduction">
    <title>Introduction to models</title>

    <para>Modelica and Optimica models can be compiled and then loaded as
    model objects using the JModelica.org Python interface. These model
    objects can be used for both simulation and optimization purposes. This
    chapter will cover how to compile Modelica and Optimica models, set
    compiler options, load the compiled model in a Python model object and use
    the model object to perform model manipulations such as setting and
    getting parameters.</para>

    <section>
      <title>The different model objects in JModelica.org</title>

      <para>There are three different kinds of model objects that can be
      created with JModelica.org: <literal>JMUModel</literal>,
      <literal>FMUModel</literal> and <literal>CasadiModel</literal>. The
      <literal>JMUModel</literal> is created by loading a
      <emphasis>JMU</emphasis>, which is a compressed file with a
      JModelica.org specific structure. The <literal>FMUModel</literal> is
      created by loading an <emphasis>FMU</emphasis> (Functional Mock-up
      Unit), which is a compressed file compliant with the FMI (Functional
      Mock-up Interface) standard. The <literal>CasadiModel</literal> is
      created by loading an <emphasis>FMUX</emphasis> which is a compressed
      file containing the XML file needed to work with <link
      xlink:href="http://sourceforge.net/apps/trac/casadi/">CasADI</link>.</para>

      <para>JMUs are created by compiling Modelica or Optimica models with
      JModelica.org. The JMU can then be loaded in a
      <literal>JMUModel</literal> object and used for simulation and
      optimization purposes.</para>

      <para>FMUs are created by compiling Modelica models with JModelica.org
      (or any other tool supporting FMU export). Optimica models can not be
      compiled into FMUs. The FMU can then be loaded in an
      <literal>FMUModel</literal> object and used for simulation
      purposes.</para>

      <para>FMUXes are created by compiling Modelica or Optimica models with
      JModelica.org. The FMUX main content is an XML file which follows the
      FMI standard with some additional JModelica.org specific elements and an
      equation section in which all equations used in the model are
      represented. The FMUX can be loaded in a <literal>CasadiModel</literal>
      and thereby use the automatic differentiation tool CasADi for
      optimization purposes. Read more about CasADi and how a
      <literal>CasadiModel</literal> object can be used for optimization in
      <xref linkend="opt_sec_pseudo-spectral"/> in <xref
      linkend="ch_optimization"/>.</para>
    </section>
  </section>

  <section xml:id="models_sec_compilation">
    <title>Compilation</title>

    <para>Compiling a model is done with just a few steps; importing a
    compiler function from the JModelica.org Python package
    <literal>pymodelica</literal>, specifying a model class and file location
    and performing the actual compilation. This will be demonstrated in <xref
    linkend="models_sec_simple_jmu_compilation"/> for the JMU, in <xref
    linkend="models_sec_simple_fmu_compilation"/> for the FMU and in <xref
    linkend="models_sec_simple_fmux_compilation"/> for the FMUX.</para>

    <para>For more advanced usage of the compiler functions, there are
    compiler options and parameters which can be modified. These will be
    explained in <xref linkend="models_sec_compiler_settings"/>.</para>

    <para><xref linkend="models_sec_compilation_in_more_detail"/>, will go
    through some parts of the compilation process and how to perform these
    steps one by one.</para>

    <section xml:id="models_sec_simple_jmu_compilation">
      <title>Simple JMU compilation example</title>

      <para>The following steps compiles a model to a JMU in the JModelica.org
      Python interface:<procedure>
          <step>
            <para>Import the JModelica.org compiler function
            <literal>compile_jmu</literal> from the package
            <literal>pymodelica</literal>.</para>
          </step>

          <step>
            <para>Specify the model and model file.</para>
          </step>

          <step>
            <para>Perform the compilation.</para>
          </step>
        </procedure></para>

      <para>This is demonstrated in the following code example.<programlisting
      language="python"># Import the compiler function
from pymodelica import compile_jmu

# Specify Modelica or Optimica model and model file (.mo or .mop)
model_name = 'myPackage.myModel'
mo_file = 'myModelFile.mo'

# Compile the model and save the return argument, which is the file name of the JMU
jmu_file = compile_jmu(model_name, mo_file)
</programlisting></para>

      <para>Once compilation has completed successfully, a JMU file will have
      been created on the file system. The JMU file is essentially a
      compressed file archive containing the files created during compilation
      that are needed when instantiating a model object. Return argument for
      <literal>compile_jmu</literal> is the full file path of the JMU that has
      just been created, this will be useful later when we want to create
      model objects. More about the JMU file and loading models can be found
      in <xref linkend="models_sec_loading_models"/>.</para>

      <para>In the above example, compilation has been performed using default
      parameters and options. The only parameters set are the model class and
      file name, which always have to be set. <literal>compile_jmu</literal>
      has several other parameters which can be modified. The different
      parameters, their default values and interpretation will be explained in
      <xref linkend="models_sec_compiler_settings"/>.</para>
    </section>

    <section xml:id="models_sec_simple_fmu_compilation">
      <title>Simple FMU compilation example</title>

      <para>The steps required to compile a model to an FMU is very similar to
      compiling a model to a JMU:<procedure>
          <step>
            <para>Import the JModelica.org compiler function
            <literal>compile_fmu</literal> from the package
            <literal>pymodelica</literal>.</para>
          </step>

          <step>
            <para>Specify the model and model file.</para>
          </step>

          <step>
            <para>Perform the compilation.</para>
          </step>
        </procedure></para>

      <para>The only difference is really the requirement on the model, it
      must be a pure Modelica model. The following code example demonstrates
      how to compile an FMU.<programlisting language="python"># Import the compiler function
from pymodelica import compile_fmu

# Specify Modelica model and model file (.mo or .mop)
model_name = 'myPackage.myModel'
mo_file = 'myModelFile.mo'

# Compile the model and save the return argument, which is the file name of the FMU
fmu_file = compile_fmu(model_name, mo_file)
</programlisting></para>

      <para>As in the JMU case, when the compilation has completed
      successfully an FMU file will have been created on the file system. The
      return argument is also the full file path of the FMU that has just been
      created, which will be useful later when we want to create model
      objects. More about the FMU file and loading models can be found in
      <xref linkend="models_sec_loading_models"/>.</para>
    </section>

    <section xml:id="models_sec_simple_fmux_compilation">
      <title>Simple FMUX compilation example</title>

      <para>Compiling an FMUX follows the same principle as compiling a JMU
      and an FMU.</para>

      <procedure>
        <step>
          <para>Import the JModelica.org compiler function
          <literal>compile_fmux</literal> from the package
          <literal>pymodelica</literal>.</para>
        </step>

        <step>
          <para>Specify the model and model file.</para>
        </step>

        <step>
          <para>Perform the compilation.</para>
        </step>
      </procedure>

      <para>The Python code example below will perform these steps.</para>

      <programlisting language="python"># Import the compiler function
from pymodelica import compile_fmux

# Specify Modelica model and model file
model_name = 'myPackage.myModel'
mo_file = 'myModelFile.mo'

# Compile the model, return argument is the file name of the FMUX
fmux_file = compile_fmux(model_name, mo_file)
</programlisting>
    </section>

    <section>
      <title>Compiling from libraries</title>

      <para>The model to be compiled might not be in a loose .mo file, but
      rather part of a library consisting of a directory structure containing
      several Modelica files. In this case, the file within the library that
      contains the model should <emphasis>not</emphasis> be given on the
      command line. Instead, the entire library should to added to the list of
      libraries the compiler searches for classes in. This can be done in
      several ways (here <emphasis>library directory</emphasis> refers to the
      top directory of the library, that should have the same name as the top
      package in the library):</para>

      <itemizedlist>
        <listitem>
          <para>Adding the directory containing the library directory to the
          environment variable <code>MODELICAPATH</code>. The compiler will
          search for classes in all libraries found in any on the directories
          in <code>MODELICAPATH</code>. In this case the
          <code>file_name</code> argument of the compilation function can be
          omitted, assuming no additional Modelica files are needed.</para>
        </listitem>

        <listitem>
          <para>Setting the <code>'extra_lib_dirs'</code> compiler option to
          the path to the directory containing the library directory. This is
          equivalent to adding it to the <code>MODELICAPATH</code>, but only
          for that compilation.</para>
        </listitem>

        <listitem>
          <para>Giving the path to the library directory in the
          <code>file_name</code> argument of the compilation function. This
          allows adding a specific library to the search list (as opposed to
          adding all libraries in a specific directory).</para>
        </listitem>
      </itemizedlist>

      <para>By default, the script starting a JModelica.org Python shell sets
      the MODELICAPATH to the directory containing the version of the Modelica
      Standard Library (MSL) that is included in the installation. Thus, all
      classes in the MSL are available without any need to specify its
      location.</para>

      <para>The Python code example below demonstrates these methods:</para>

      <programlisting># Import the compiler function
from pymodelica import compile_fmu

# Compile an example model from the MSL
fmu1 = compile_fmu('Modelica.Mechanics.Rotational.Examples.First')

# Compile a model from the library MyLibrary, located in C:\MyLibs
fmu2 = compile_fmu('MyLibrary.MyModel', compiler_options = {'extra_lib_dirs':'C:\MyLibs'})

# The same as the last command, if no other libraries in C:\MyLibs are needed
fmu3 = compile_fmu('MyLibrary.MyModel', 'C:\MyLibs\MyLibrary')
</programlisting>
    </section>

    <section xml:id="models_sec_compiler_settings">
      <title>Compiler settings</title>

      <para>The compiler function parameters can be listed with the
      interactive help in Python. The parameters are explained in the
      corresponding Python <emphasis>docstring</emphasis> which is visualized
      with the interactive help. This is demonstrated in the code examples
      below.</para>

      <para>The parameter <literal>target</literal>, is further explained in
      <xref linkend="models_sec_compiler_targets_jmu"/>, <xref
      linkend="models_sec_compiler_targets_fmu"/> and <xref
      linkend="models_sec_compiler_targets_fmux"/>.</para>

      <section xml:id="models_sec_compile_jmu_parameters">
        <title>compile_jmu parameters</title>

        <para>The <literal>compile_jmu</literal> parameters can be listed with
        the interactive help.<programlisting language="python"># Display the docstring for compile_jmu with the Python command 'help'
from pymodelica import compile_jmu
help(compile_jmu)
Help on function compile_jmu in module pymodelica.compiler:

compile_jmu(class_name, file_name=[], compiler='auto', target='ipopt', compiler_options={}, 
            compile_to='.', compiler_log_level='warning')
    Compile a Modelica or Optimica model to a JMU.

    A model class name must be passed, all other arguments have default values.
    The different scenarios are:

    * Only class_name is passed:
        - Class is assumed to be in MODELICAPATH.
        - Default compiler is ModelicaCompiler.
    
    * class_name and file_name is passed:
        - file_name can be a single path as a string or a list of paths 
          (strings). The paths can be for files or libraries
        - Default compiler setting is 'auto' which means that the appropriate
          compiler will be selected based on model file ending, i.e.
          ModelicaCompiler if .mo file and OptimicaCompiler if a .mop file is
          found in file_name list.

    Library directories can be added to MODELICAPATH by listing them in a
    special compiler option 'extra_lib_dirs', for example:

        compiler_options =
            {'extra_lib_dirs':['c:\MyLibs1','c:\MyLibs2']}

    Other options for the compiler should also be listed in the compiler_options
    dict.

    The compiler target is 'ipopt' by default which means that libraries for AD
    and optimization/initialization algortihms will be available as well as the
    JMI. The other targets are:

        'model' --
            AD and JMI is included.
        'algorithm' --
            AD and algorithm but no Ipopt linking.
        'model_noad' --
            Only JMI, that is no AD interface. (Must currently be used when
            model includes external functions.)

    Parameters::

        class_name --
            The name of the model class.

        file_name --
            A path (string) or paths (list of strings) to model files and/or 
            libraries. Supports both be .mo and .mop files.
            Default: Empty list.

        compiler --
            'auto' if a compiler should be selected automatically depending on
            file ending, 'modelica' if a ModelicaCompiler should be used or
            'optimica' if a OptimicaCompiler should be used.
            Default: 'auto' (i.e. depends on argument file_name)

        target --
            Compiler target. 'model', 'algorithm', 'ipopt' or 'model_noad'.
            Default: 'ipopt'

        compiler_options --
            Options for the compiler.
            Default: Empty dict.

        compile_to --
            Specify location of the compiled JMU. Directory will be created if
            it does not exist.
            Default: Current directory.

        compiler_log_level --
            Set the log level for the compiler. Valid options are 'warning'/'w',
            'error'/'e' or 'info'/'i'.
            Default: 'warning'

    Returns::

        Name of the JMU which has been created.

</programlisting></para>
      </section>

      <section>
        <title>compile_fmu parameters</title>

        <para>The <literal>compile_fmu</literal> parameters can be listed with
        the interactive help.</para>

        <programlisting language="python"># Display the docstring for compile_fmu with the Python command 'help'
from pymodelica import compile_fmu
help(compile_fmu)
Help on function compile_fmu in module pymodelica.compiler:

compile_fmu(class_name, file_name=[], compiler='modelica', target='model_fmume', 
            compiler_options={}, compile_to='.', compiler_log_level='warning')
    Compile a Modelica model to an FMU.

    A model class name must be passed, all other arguments have default values.
    The different scenarios are:

    * Only class_name is passed:
        - Class is assumed to be in MODELICAPATH.

    * class_name and file_name is passed:
        - file_name can be a single path as a string or a list of paths 
          (strings). The paths can be to files or libraries
    
    Library directories can be added to MODELICAPATH by listing them in a 
    special compiler option 'extra_lib_dirs', for example:
    
        compiler_options = 
            {'extra_lib_dirs':['c:\MyLibs1','c:\MyLibs2']}
        
    Other options for the compiler should also be listed in the compiler_options 
    dict.
    
    The compiler target is 'model_fmume' by default which means that the shared 
    file contains the FMI for Model Exchange API. This is currently the only 
    target that is possible to use.
    
    Parameters::
    
        class_name -- 
            The name of the model class.
            
        file_name -- 
            A path (string) or paths (list of strings) to model files and/or 
            libraries. Supports only be .mo files.
            Default: Empty list.
            
        compiler -- 
            The compiler used to compile the model. Currently, only ModelicaCompiler 
            can be used.
            Default: 'modelica'

        target --
            Compiler target.
            Default: 'model_fmume'

        compiler_options --
            Options for the compiler.
            Default: Empty dict.

        compile_to --
            Specify location of the compiled FMU. Directory will be created if
            it does not exist.
            Default: Current directory.

        compiler_log_level --
            Set the log level for the compiler. Valid options are 'warning'/'w',
            'error'/'e' or 'info'/'i'.
            Default: 'warning'

    Returns::

        Name of the FMU which has been created.
</programlisting>
      </section>

      <section>
        <title>compile_fmux parameters</title>

        <para>The <literal>compile_fmux</literal> parameters can be listed
        with the interactive help.</para>

        <programlisting language="python"># Display the docstring for compile_fmux with the Python command 'help'
from pymodelica import compile_fmux
help(compile_fmux)
Help on function compile_fmux in module pymodelica.compiler:

compile_fmux(class_name, file_name=[], compiler='auto', compiler_options={}, compile_to='.', 
             compiler_log_level='warning')
    Compile a Modelica model to an FMUX.

    A model class name must be passed, all other arguments have default values.
    The different scenarios are:

    * Only class_name is passed:
        - Class is assumed to be in MODELICAPATH.

    * class_name and file_name is passed:
        - file_name can be a single path as a string or a list of paths 
          (strings). The paths can be to files or libraries
    
    Library directories can be added to MODELICAPATH by listing them in a 
    special compiler option 'extra_lib_dirs', for example:
    
        compiler_options = 
            {'extra_lib_dirs':['c:\MyLibs1','c:\MyLibs2']}
        
    Other options for the compiler should also be listed in the compiler_options 
    dict.
    
    
    Parameters::
    
        class_name -- 
            The name of the model class.
            
        file_name -- 
            A path (string) or paths (list of strings) to model files and/or 
            libraries. Supports both be .mo and .mop files.
            Default: Empty list.

        compiler --
            The compiler used to compile the model.
            Default: 'auto'

        compiler_options --
            Options for the compiler.
            Default: Empty dict.

        compile_to --
            Specify location of the compiled FMUX. Directory will be created if
            it does not exist.
            Default: Current directory.

        compiler_log_level --
            Set the log level for the compiler. Valid options are 'warning'/'w',
            'error'/'e' or 'info'/'i'.
            Default: 'warning'

    Returns::

        Name of the FMUX which has been created.
</programlisting>
      </section>

      <section xml:id="models_sec_compiler_options">
        <title>Compiler options</title>

        <para>Compiler options are read from an XML file,
        <filename>options.xml</filename>, which can be found in the
        JModelica.org installation folder under the folder
        <filename>Options</filename>. The options are loaded from the file
        when a compiler is created, that is when
        <literal>compile_jmu</literal>, <literal>compile_fmu</literal> or
        <literal>compile_fmux</literal> is run. Options for a compiler
        instance can also be modified interactively when compiling using the
        parameter dict <literal>compiler_options</literal>. This is shown in
        an example compiling an Optimica model below.</para>

        <programlisting language="python"># Compile with the compiler option 'enable_variable_scaling' set to True

# Specify Optimica model and model file
model_name = 'myPackage.myModel'
mo_file = 'myModelFile.mop'

# Compile
my_jmu = compile_jmu(model_name, mo_file, compiler_options={"enable_variable_scaling":True})
</programlisting>

        <para>There are four type categories: <literal>string</literal>,
        <literal>real</literal>, <literal>integer</literal> and
        <literal>boolean</literal>. The available options, default values and
        description are listed in <xref
        linkend="models_tab_compiler_options"/>.<table
            xml:id="models_tab_compiler_options">
            <title>Compiler options</title>

            <tgroup cols="3">
              <colspec align="left" colname="col–para" colwidth="2.75*"/>

              <colspec align="left" colname="col–def" colwidth="1*"/>

              <colspec align="left" colname="col–descr" colwidth="3.25*"/>

              <thead>
                <row>
                  <entry align="center">Option</entry>

                  <entry align="center">Default</entry>

                  <entry align="center">Description</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry><literal>normalize_minimum_time_problems</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>When this option is set to <literal>true</literal>
                  then minimum time optimal control problems encoded in
                  Optimica are converted to fixed interval problems by scaling
                  of the derivative variables. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>enable_variable_scaling</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, then the
                  "nominal" attribute will be used to scale variables in the
                  model. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>halt_on_warning</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>false</literal> one
                  or more compiler warnings will not stop compilation of the
                  model. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>automatic_add_initial_equations</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>When this option is set to <literal>true</literal>,
                  then additional initial equations are added to the model
                  based on a the result of a matching algorithm. Initial
                  equations are added for states that are not matched to an
                  equation. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_ode_jacobian</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>,
                  code for computing ODE Jacobians are generated. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>eliminate_alias_variables</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, then alias
                  variables are eliminated from the model. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>extra_lib_dirs</literal></entry>

                  <entry><literal>""</literal></entry>

                  <entry>The value of this option is appended to the value of
                  the <literal>MODELICAPATH</literal> environment variable for
                  determining in what directories to search for libraries.
                  (String option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_xml_equations</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, then model
                  equations are generated in XML format. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>state_start_values_fixed</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>This option enables the user to specify if initial
                  equations should be generated automatically for
                  differentiated variables even though the fixed attribute is
                  equal to fixed. Setting this option to
                  <literal>true</literal> is, however, often practical in
                  optimization problems. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>equation_sorting</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, equations
                  are sorted using the BLT algorithm. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>index_reduction</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, index
                  reduction is performed. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>enable_structural_diagnosis</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>Enable this option to invoke the structural error
                  diagnosis based on the matching algorithm. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>compliance_as_warning</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>When this option is set to <literal>true</literal>,
                  then compliance errors are treated as warnings instead. This
                  can lead to the compiler or solver crashing. Use with
                  caution! (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_html_diagnostics</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>When this option is set to <literal>true</literal>
                  model diagnostics is generated in HTML format. This includes
                  the flattened model, connection sets, alias sets and BLT
                  form. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_ode</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>,
                  code for solving ODEs is generated. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>convert_free_dependent_
                  parameters_to_algebraics</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, free
                  dependent parameters are converted to algebraic variables.
                  (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_dae</literal></entry>

                  <entry><literal>true</literal></entry>

                  <entry>If this option is <literal>true</literal>, code for
                  solving DAEs is generated. (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_dae_jacobian</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, code for
                  computing DAE Jacobians is generated. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>export_functions</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>Export used Modelica functions to generated C code in
                  a manner that is compatible with the external C interface in
                  the Modelica Language Specification. (Boolean
                  option.)</entry>
                </row>

                <row>
                  <entry><literal>export_functions_vba</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal>, then
                  VBA-compatible wrappers for exported functions are created.
                  Requires <literal>export_functions = true</literal>.
                  (Boolean option.)</entry>
                </row>

                <row>
                  <entry><literal>generate_fmi_cs_xml</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal> the model
                  description part of the XML variables file will be FMI for
                  co simulation compliant. To generate an XML which will
                  validate with FMI schema the option generate_xml_equations
                  must also be false.</entry>
                </row>

                <row>
                  <entry><literal>divide_by_vars_in_tearing</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>, a
                  less restrictive strategy is used for solving equations in
                  the tearing algorithm. Specifically, division by parameters
                  and variables is permitted, by default no such divisions are
                  made during tearing.</entry>
                </row>

                <row>
                  <entry><literal>enable_tearing</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is set to <literal>true</literal>,
                  tearing of equation systems is enabled.</entry>
                </row>

                <row>
                  <entry><literal>generate_fmi_me_xml</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>If this option is <literal>true</literal> the model
                  description part of the XML variables file will be FMI for
                  model exchange compliant. To generate an XML which will
                  validate with FMI schema the option generate_xml_equations
                  must also be false.</entry>
                </row>

                <row>
                  <entry><literal>inline_functions</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>Perform function inlining on model after
                  flattening.</entry>
                </row>

                <row>
                  <entry><literal>state_initial_equations</literal></entry>

                  <entry><literal>false</literal></entry>

                  <entry>Neglect initial equations in the model and add
                  initial equations, and parameters, for the states.</entry>
                </row>

                <row>
                  <entry><literal>fmi_version</literal></entry>

                  <entry><literal>1.0</literal></entry>

                  <entry>FMI version to use in compilation.</entry>
                </row>
              </tbody>
            </tgroup>
          </table></para>
      </section>

      <section xml:id="models_sec_compiler_targets_jmu">
        <title>Compiler targets for <literal>compile_jmu</literal></title>

        <para>There are four compiler targets available for
        <literal>compile_jmu</literal>:<itemizedlist>
            <listitem>
              <para><literal>ipopt</literal>: Compiled model will include JMI
              interface, AD and linking to Ipopt libraries. There is support
              for optimization and initialization algorithm.</para>
            </listitem>

            <listitem>
              <para><literal>model</literal>: Compiled model will include
              support for JMI interface and AD.</para>
            </listitem>

            <listitem>
              <para><literal>algorithm</literal>: Compiled model will include
              support for JMI interface. AD and algorithm but not link with
              the Ipopt libraries.</para>
            </listitem>

            <listitem>
              <para><literal>model_noad</literal>: Compiled model will only
              include the JMI interface.</para>
            </listitem>
          </itemizedlist></para>

        <para>The compiler target is '<literal>ipopt</literal>' by default
        which will work for most cases. However, if JModelica.org has been
        built without Ipopt libraries the target would have to be changed to
        any other suitable target that does not include the Ipopt
        libraries.</para>

        <para>The target <literal>model_noad</literal> must be used if the
        model contains external equations since external equations do not work
        with the AD interface at the moment.</para>
      </section>

      <section xml:id="models_sec_compiler_targets_fmu">
        <title>Compiler targets for <literal>compile_fmu</literal></title>

        <para>Currently, the only possible target available for
        <literal>compile_fmu</literal> is '<literal>model_fmume</literal>'.
        With this target the compiled model will be compliant with the FMI for
        Model Exchange API.</para>
      </section>

      <section xml:id="models_sec_compiler_targets_fmux">
        <title>Compiler targets for <literal>compile_fmux</literal></title>

        <para>Compiler targets are not relevant for
        <literal>compile_fmux</literal> since no binary file is
        compiled.</para>
      </section>
    </section>

    <section xml:id="models_sec_compilation_in_more_detail">
      <title>Compilation in more detail</title>

      <para>Compiling with <literal>compile_jmu</literal>,
      <literal>compile_fmu</literal> or <literal>compile_fmux</literal>
      bundles quite a few steps required for the compilation from model file
      to JMU, FMU or FMUX. Some of these steps will be described briefly here,
      for a more detailed review on the compilation steps see <xref
      linkend="intro_sec_architecture"/> in <xref linkend="ch_intro"/>.</para>

      <section>
        <title>Create a compiler</title>

        <para>A compiler, can be either a Modelica or Optimica compiler, is
        created by importing the Python classes from the compiler module. This
        example code will create a Modelica compiler.<programlisting
        language="python"># Import the class ModelicaCompiler from the compiler module
from pymodelica.compiler import ModelicaCompiler

# Create a compiler instance
mc = ModelicaCompiler()
</programlisting></para>
      </section>

      <section>
        <title>Source tree generation and flattening</title>

        <para>In the first step of the compilation, the model is parsed and
        instantiated. Then the model is transformed into a flat representation
        which can be used to generate C and XML code. If there are errors in
        the model, for example syntax or type errors, Python exceptions will
        be thrown during these steps. <programlisting language="python"># Parse the model and get a reference to the root of the source AST
source_root = mc.parse_model('myPackage.mo')

# Generate an instance tree representation and get a reference to the model instance
model_instance = mc.instantiate_model(source_root, 'myPackage.myModel')

# Perform flattening and get a flat representation
flat_rep = mc.flatten_model(model_instance)
</programlisting></para>
      </section>

      <section>
        <title>Code generation</title>

        <para>The next step is the code generation which produces C code
        containing the model equations and a couple of XML files containing
        model meta data such as variable names and types. Note that in the
        <literal>compile_fmux</literal> case, only XML code is generated in
        this step.<programlisting language="python"># Generate code
mc.generate_code(flat_rep)
</programlisting></para>
      </section>
    </section>
  </section>

  <section xml:id="models_sec_loading_models">
    <title>Loading models</title>

    <para>Compiled models, JMUs, FMUs and FMUXes, are loaded in the
    JModelica.org Python interface with the <literal>JMUModel</literal> class
    from the <literal>pyjmi</literal> module, the <literal>FMUModel</literal>
    class from the <literal>pyfmi</literal> module and the
    <literal>CasadiModel</literal> class from the <literal>pyjmi</literal>
    module respectively. This will be demonstrated in <xref
    linkend="models_sec_loading_a_jmu"/>, <xref
    linkend="models_sec_loading_an_fmu"/> and <xref
    linkend="models_sec_loading_an_fmux"/>.</para>

    <para>The model classes contain many methods with which models can be
    manipulated after instantiation. Amongst the most important methods are
    <literal>initialize</literal>, <literal>simulate</literal> and
    <literal>optimize</literal>. (<literal>optimize</literal> is only relevant
    for JMU model instances) which are used when simulating and optimizing.
    These are explained in <xref linkend="ch_simulation"/> and <xref
    linkend="ch_optimization"/>. For more information on how to use the
    CasadiModel for optimization purposes, see <xref
    linkend="opt_sec_pseudo-spectral"/> in <xref linkend="ch_optimization"/>.
    The more basic methods for variable and parameter manipulation are
    explained in <xref
    linkend="models_sec_variable_and_parameter_manipulation"/>.</para>

    <section xml:id="models_sec_the_jmu_file">
      <title>The JMU</title>

      <para>The JMU is a compressed file which contains all files needed to
      load and work with the compiled model in JModelica.org. The JMU contains
      the shared object file, an XML file with model variable data and some
      other files created during compilation of the model. The JMU file format
      is a JModelica.org specific format but is designed to follow the FMU
      file format from the FMI standard as much as possible. A JMU is created
      when compiling a Modelica or Optimica model with
      <literal>pymodelica.compile_jmu</literal>, see <xref
      linkend="models_sec_compilation"/>.</para>
    </section>

    <section>
      <title>The FMU</title>

      <para>The FMU (Functional Mock-up Unit) is a compressed file which
      follows the FMI (Functional Mock-up Interface) standard. An FMU is
      created when compiling a Modelica model with
      <literal>pymodelica.compile_fmu</literal>.</para>

      <para>Read more about the FMI/FMU standard in <xref
      linkend="ch_fmi"/>.</para>
    </section>

    <section>
      <title>The FMUX</title>

      <para>The FMUX is a compressed file which only contains an XML file and
      a couple of resource files created during the flattening of the model.
      The XML file follows the FMI standard with some JModelica.org specific
      extra elements and a section of equations. The equations part contains
      all equations used in the model. The FMUX is created when compiling a
      Modelica or Optimica model with
      <literal>pymodelica.compile_fmux</literal>.</para>
    </section>

    <section xml:id="models_sec_loading_a_jmu">
      <title>Loading a JMU</title>

      <para>A JMU file is loaded in JModelica.org with the class
      <literal>JMUModel</literal> in the <literal>pyjmi</literal> module. The
      following simple example demonstrates how to do this in a Python shell
      or script.<programlisting language="python" xml:space="preserve"># Import JMUModel from pyjmi
from pyjmi import JMUModel
myModel = JMUModel('myPackage_myModel.jmu')
</programlisting></para>

      <para>The only parameter in the <literal>JMUModel</literal> constructor
      is the name of the JMU file, including any file path. When compiling and
      loading it is therefore practical to use the return argument from
      <literal>compile_jmu</literal>, which is the path to the JMU created.
      The following example demonstrates this.<programlisting
      language="python"># Import compile_jmu and JMUModel
from pymodelica import compile_jmu
from pyjmi import JMUModel

# Compile and load model
jmu_name = compile_jmu('myPackage.myModel','myModelFile.mo')
myModel = JMUModel(jmu_name)
</programlisting></para>
    </section>

    <section xml:id="models_sec_loading_an_fmu">
      <title>Loading an FMU</title>

      <para>The FMU file can be loaded in JModelica.org with the class
      <literal>FMUModel</literal> in the <literal>pyfmi</literal> module. The
      following short example demonstrates how to do this in a Python shell or
      script.<programlisting language="python"># Import FMUModel from pyfmi
from pyfmi import FMUModel
myModel = FMUModel('myFMU.fmu')
</programlisting></para>

      <para>The <literal>FMUModel</literal> instance can then be used to set
      parameters and used for simulations.</para>
    </section>

    <section xml:id="models_sec_loading_an_fmux">
      <title>Loading an FMUX</title>

      <para>The FMUX file can be loaded in JModelica.org with the class
      <literal>CasadiModel</literal> in the <literal>pyjmi</literal> module.
      The following short example demonstrates how to do this in a Python
      shell or script.<programlisting language="python"># Import CasadiModel from pyjmi
from pyjmi import CasadiModel
myModel = CasadiModel('myFMUX.fmux')
</programlisting></para>
    </section>
  </section>

  <section xml:id="models_sec_variable_and_parameter_manipulation">
    <title>Changing model parameters</title>

    <para>Model parameters can be altered with methods in the model classes
    once the model has been loaded. Some short examples in <xref
    linkend="models_sec_setting_and_getting_params"/> will demonstrate this.
    </para>

    <section xml:id="models_sec_setting_and_getting_params">
      <title>Setting and getting parameters</title>

      <para>The model parameters can be accessed with via the model class
      interfaces. It is possible to set and get one specific parameter at a
      time or a whole list of parameters.</para>

      <para>The following code example demonstrates how to get and set a
      specific parameter using an example JMU model from the
      <literal>pyjmi.examples</literal> package.<programlisting
      language="python"># Compile and load the model
from pymodelica import compile_jmu
from pyjmi import JMUModel
jmu_name = compile_jmu('RLC_Circuit','RLC_Circuit.mo')
rlc_circuit = JMUModel(jmu_name)

# Get the value of the parameter 'resistor.R' and save the result in a variable 'resistor_r'
resistor_r = rlc_circuit.get('resistor.R')

# Give 'resistor.R' a new value
resistor_r = 2.0
rlc_circuit.set('resistor.R', resistor_r)
</programlisting></para>

      <para>The following example demonstrates how to get and set a list of
      parameters using the same example model as above. The model is assumed
      to already be compiled and loaded.<programlisting language="python"># Create a list of parameters, get and save the corresponding values in a variable 'values'
vars = ['resistor.R', 'resistor.v', 'capacitor.C', 'capacitor.v']
values = rlc_circuit.get(vars)

# Change some of the values
values[0] = 3.0
values[3] = 1.0
rlc_circuit.set(vars, values)
</programlisting></para>
    </section>
  </section>

  <section>
    <title>Debugging models</title>

    <para>The JModelica.org compilers can generate debugging information in
    order to facilitate localization of errors. There are two mechanisms for
    generating such diagnostics: dumping of debug information to the system
    output or generation of HTML code that can be viewed with a standard web
    browser.</para>

    <para>By setting the argument <literal>compiler_log_level</literal> to
    <literal>'i'</literal>, diagnostics is printed to the standard output,
    normally the terminal window from which the compiler is invoked. The
    resulting diagnostics provides detailed information from each of the
    transformation steps in the symbolic manipulation algorithms.</para>

    <para>By setting the compiler option
    <literal>generate_html_diagnostics</literal> to true, a number of HTML
    pages containing similar diagnostics is generated. The HTML files are
    generated in the directory <literal>Model_Name_diagnostics</literal>,
    where <literal>Model_Name</literal> is the name of the compiled model. As
    compared to the diagnostics generated by the
    <literal>compiler_log_level</literal> argument, the HTML diagnostics
    contains only the most important information, but it also provides a
    better overview. Opening the file
    <literal>Model_Name_diagnostics/index.html</literal> in a web browser,
    results in a page similar to the one shown below.</para>

    <programlisting>Modelica.Mechanics.Rotational.Examples.First

Number of independent constants:              1
  Number of Real independent constants:       1
  Number of Integer independent constants:    0
  Number of Enum independent constants:       0
  Number of Boolean independent constants:    0
  Number of String independent constants:     0
Number of dependent constants:                0
  Number of Real dependent constants:         0
  Number of Integer dependent constants:      0
  Number of Enum dependent constants:         0
  Number of Boolean dependent constants:      0
  Number of String dependent constants:       0
Number of independent parameters:             20
  Number of Real independent parameters:      14
  Number of Integer independent parameters:   0
  Number of Enum independent parameters:      4
  Number of Boolean independent parameters:   2
  Number of String independent parameters:    0
Number of dependent parameters:               6
  Number of Real dependent parameters:        6
  Number of Integer dependent parameters:     0
  Number of Enum dependent parameters:        0
  Number of Boolean dependent parameters:     0
  Number of String dependent parameters:      0
Number of variables :                         33
  Number of Real variables:                   33
  Number of Integer variables:                0
  Number of Enum variables:                   0
  Number of Boolean variables:                0
  Number of String variables:                 0
Number of Real differentiated variables:      4
Number of Real derivative variables:          4
Number of Real algebraic variables:           25
Number of inputs:                             0
  Number of Real inputs:                      0
  Number of Integer inputs:                   0
  Number of Enum inputs:                      0
  Number of Boolean inputs:                   0
  Number of String inputs:                    0
Number of discrete variables :                0
  Number of Real discrete variables:          0
  Number of Integer discrete variables:       0
  Number of Enum discrete variables:          0
  Number of Boolean discrete variables:       0
  Number of String discrete variables:        0
Number of equations:                          29
Number of variables with binding expression:  0
  Number of Real variables with binding exp:  0
  Number of Integer variables binding exp:    0
  Number of Enum variables binding exp:       0
  Number of Boolean variables binding exp:    0
  Number of String variables binding exp:     0
Total number of equations:                    29
Number of initial equations:                  4
Number of relational exps in equations:       1
Number of relational exps in init equations:  0
Flattened model

Transformed model

Problems:
0 errors, 0 compliance errors, 0 warnings

Alias sets

Connection sets

BLT diagnostics
Number of unsolved equation blocks in DAE initialization system: 1: {7}
Number of unsolved equation blocks in DAE system: 1: {7}
</programlisting>

    <para>Note that some of the entries, including <literal>Flattened
    model</literal>, <literal>Transformed model</literal>, <literal>Connection
    sets</literal>, <literal>Alias sets</literal> and <literal>BLT
    diagnostics</literal> are links to sub pages containing additional
    information. For example, the BLT diagnostics page contains information
    about individual systems of equations:</para>

    <programlisting>...

--- Block 12---
Solved block of 1 variables:
Computed variable:
  torque.flange.tau
Solution:
  ( sine.offset + (if time &lt; sine.startTime then 0 else ( sine.amplitude ) * 
  ( sin(( ( ( 2 ) * ( 3.141592653589793 ) ) * ( sine.freqHz ) ) * 
  ( time - ( sine.startTime ) ) + sine.phase) )) ) / (  - ( 1 ) )

--- Block 13---
Non-solved block of 7 variables:
Unknown variables:
  idealGear.der(phi_a,2)
  idealGear.der(phi_b,2)
  inertia2.der(_der_phi)
  inertia2.a
  idealGear.flange_b.tau
  idealGear.flange_a.tau
  inertia1.a
Equations:
  der_2_idealGear_phi_a = inertia1.a - ( 0 )
  der_2_idealGear_phi_a = ( idealGear.ratio ) * ( der_2_idealGear_phi_b ) + ( 0 ) * 
                          ( der_idealGear_phi_b ) + ( 0 ) * ( der_idealGear_phi_b ) + 
                          ( 0 ) * ( idealGear.phi_b )
  der_2_idealGear_phi_b = inertia2.der(_der_phi) - ( 0 )
  inertia2.a = inertia2.der(_der_phi)
  ( inertia2.J ) * ( inertia2.a ) =  - ( idealGear.flange_b.tau ) + inertia2.flange_b.tau
  0 = ( idealGear.ratio ) * ( idealGear.flange_a.tau ) + idealGear.flange_b.tau
  ( inertia1.J ) * ( inertia1.a ) =  - ( torque.flange.tau ) - ( idealGear.flange_a.tau )

...
</programlisting>
  </section>
</chapter>
