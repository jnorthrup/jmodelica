package org.jmodelica.build.options;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintStream;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Generates a class containing all the configured options.
 */
public class OptionsAggregator {

    /** Format string for the header of generated aggregated options code. */
    public static final String HEADER = "package %s;%n"
            + "%n"
            + "import org.jmodelica.common.options.BooleanOption;%n"
            + "import org.jmodelica.common.options.IntegerOption;%n"
            + "import org.jmodelica.common.options.AbstractOptionRegistry;%n"
            + "import org.jmodelica.common.options.RealOption;%n"
            + "import org.jmodelica.common.options.StringOption;%n"
            + "%n"
            + "/**%n"
            + " * Contains all options. This class was generated by the option aggregator.%n"
            + " */%n"
            + "public class OptionRegistry extends AbstractOptionRegistry {%n";

    public static final String FOOTER = "%n"
            + "    /** Flag indicating if this option registry is used for testing (test defaults will be used). */ %n"
            + "    private final boolean isTest;%n"
            + "%n"
            + "    /** @deprecated do not use this: only present for SWIG interface! */%n"
            + "    @Deprecated public OptionRegistry() {%n" // DO NOT REMOVE: default constructor needed for SWIG interface!
            + "        this.isTest = false;%n"
            + "    }%n"
            + "%n"
            + "    private OptionRegistry(boolean isTest) {%n"
            + "        this.isTest = isTest;%n"
            + "        initializeMap();%n"
            + "        if (isTest) {%n"
            + "            setTestDefaults();%n"
            + "        }%n"
            + "    }%n"
            + "%n"
            + "    public static OptionRegistry buildOptions() {%n"
            + "        return new OptionRegistry(false);%n"
            + "    }%n"
            + "%n"
            + "    public static OptionRegistry buildTestOptions() {%n"
            + "        return new OptionRegistry(true);%n"
            + "    }%n"
            + "%n"
            + "    public OptionRegistry copy() {%n"
            + "        OptionRegistry options = new OptionRegistry(isTest);%n"
            + "        options.copyAllOptions(this);%n"
            + "        return options;%n"
            + "    }%n"
            + "}%n";

    private Map<String, OptionDeclaration> options = new LinkedHashMap<>();
    private ArrayList<OptionModification> optionsModification = new ArrayList<>();

    public static class OptionsAggregationException extends Exception {
        public OptionsAggregationException(String string) {
            super(string);
        }

        private static final long serialVersionUID = -8924212971616929776L;
    }

    public static abstract class Option {

        protected String filePath;
        protected String kind;
        protected String name;
        protected String defaultValue;

        public Option(String filePath, String kind, String name, String defaultValue) {
            this.filePath = filePath;
            this.kind = kind;
            this.name = name;
            this.defaultValue = defaultValue;
        }

        public String getFilePath() {
            return filePath;
        }
        
        public String getKind() {
            return kind;
        }
        
        public String getName() {
            return name;
        }
    }

    private abstract class OptionModification extends Option {
        public OptionModification(String filePath, String kind, String name, String defaultValue) {
            super(filePath, kind, name, defaultValue);
        }
        
        void modify() throws OptionsAggregationException {
            OptionDeclaration opt = options.get(getName());
            if (opt == null) {
                throw new OptionsAggregationException("Missing option for modification " + getKind() + " " + getName());
            }
            opt.setModified();
            modify(opt);
        }
        abstract void modify(OptionDeclaration opt) throws OptionsAggregationException;
    }
    
    private class OptionModificationSetDefault extends OptionModification {

        public OptionModificationSetDefault(String filePath, String kind, String name, String defaultValue) {
            super(filePath, kind, name, defaultValue);
        }

        @Override
        void modify(OptionDeclaration opt) {
            opt.setDefaultValue(defaultValue);
        }

    }

    private class OptionModificationRemove extends OptionModification {

        public OptionModificationRemove(String filePath, String kind, String name) {
            super(filePath, kind, name, null);
        }

        @Override
        void modify(OptionDeclaration opt) {
            opt.setRemoved();
        }
    }

    private class OptionModificationInvert extends OptionModification {

        public OptionModificationInvert(String filePath, String kind, String name, String defaultValue) {
            super(filePath, kind, name, defaultValue);
        }

        @Override
        void modify(OptionDeclaration opt) {
            opt.inverted = defaultValue;
        }
    }

    public static class OptionDeclaration extends Option {
        private String type;
        private String cat;

        private String testDefaultValue;
        private String[] args;
        private String description;
        private String[] possibleValues;
        private boolean removed = false;
        private boolean modified = false;
        public String inverted = "";

        public OptionDeclaration(String filePath, String cls, String name, String defaultValue, String type,
                String cat) {
            super(filePath, cls, name, defaultValue);
            this.testDefaultValue = defaultValue;
            this.type = type;
            this.cat = cat;
        }

        public String getType() {
            return type;
        }

        public String getCategory() {
            return cat;
        }
        
        public void setModified() throws OptionsAggregationException {
            if (modified) {
                throw new OptionsAggregationException("Option already modified " + getName());
            }
            modified = true;
        }

        public void setDefaultValue(String defaultValue) {
            this.defaultValue = defaultValue;
        }

        public void setRemoved() {
            removed = true;
        }

        public boolean getRemoved() {
            return removed;
        }

        public void setTestDefaultValue(String testDefaultValue) {
            this.testDefaultValue = testDefaultValue;
        }

        public void setArgs(String[] args) {
            this.args = args;
        }

        public void setDescription(String description) {
            this.description = description;
        }

        public void setPossibleValues(String[] possibleValues) {
            this.possibleValues = possibleValues;
        }

        public void printDeclaration(PrintStream out, String indent) {
            String defaultValueInit;
            if (inverted.isEmpty()) {
                if (defaultValue.equals(testDefaultValue)) {
                    defaultValueInit = String.format("new DefaultValue<>(%s)", defaultValue);
                } else {
                    defaultValueInit = String.format("new DefaultValue<>(%s)", defaultValue);
                }
            } else {
                defaultValueInit = String.format("new DefaultInvertBoolean(\"%s\")", inverted);
            }
            out.format("public final %sOption %s = new %sOption(\"%s\", OptionType.%s, Category.%s,%n"
                            + indent + "        %s,%n" // Description.
                            + indent + "        %s", // Default value.
                    kind, name, kind, name, type, cat, description, defaultValueInit);
            if (args != null) {
                for (String s : args) {
                    out.print(", " + s);
                }
            }
            if (possibleValues != null) {
                out.print(", new String[] {");
                for (String s : possibleValues) {
                    out.print(s + ", ");
                }
                out.print("}");
            } else if (kind.equals("String")) {
                out.print(", (String[]) null");
            }
            out.print(");");
        }

        public void printSetTestDefault(PrintStream out, String indent) {
            if (inverted.isEmpty() && !defaultValue.equals(testDefaultValue)) {
                out.format("%s%s.setDefault(new DefaultValue<>(%s));%n", indent, name, testDefaultValue);
            }
        }

        public String initializeMap() {
            return String.format("optionsMap.put(\"%s\", %s);", name, name);
        }
    }

    public void generateHeader(PrintStream out, String packageName) {
        out.format(HEADER, packageName);
    }

    public void generateDeclarations(PrintStream out, String indent) {
        for (OptionDeclaration opt : getOptions()) {
            if (!opt.removed) {
                out.print(indent);
                opt.printDeclaration(out, indent);
                out.println();
            }
        }
    }

    public void generateInitializeMap(PrintStream out, String indent) {
        for (OptionDeclaration opt : getOptions()) {
            if (!opt.removed) {
                out.print(indent);
                out.println(opt.initializeMap());
            }
        }
    }

    public void generateTestDefaults(PrintStream out, String indent) {
        for (OptionDeclaration opt : getOptions()) {
            if (!opt.removed) {
                opt.printSetTestDefault(out, indent);
            }
        }
    }

    public void generate(PrintStream out, String pack) {
        generateHeader(out, pack);
        generateDeclarations(out, "    ");
        out.println();
        out.println("    private void initializeMap() {");
        generateInitializeMap(out, "        ");
        out.println("    }");
        out.println();
        out.println("    private void setTestDefaults() {");
        generateTestDefaults(out, "        ");
        out.println("    }");
        out.format(FOOTER);
    }

    public String nextLine(BufferedReader reader) throws IOException {
        String line;
        while ((line = reader.readLine()) != null && isEmpty(line)) {
            // do nothing - just skip to next non-empty line
        }
        return line;
    }

    private static boolean isEmpty(String line) {
        return line == null || line.isEmpty() || line.startsWith("***");
    }

    private static String parseKind(String kind) {
        return kind.substring(0, 1).toUpperCase() + kind.substring(1).toLowerCase();
    }

    /**
     * Tries to parse an option modification. Whitespace and newline sensitive.
     * 
     * DEFAULT expects an option name and a value. It will change the default value
     * of that option to the value. Example line:
     * DEFAULT opt1 true
     * 
     * REMOVE expects an option name. It will remove the option from the set that is
     * included in the generated output. Example line: 
     * REMOVE opt1
     * 
     * INVERT expects two boolean option names. The default value of the first will
     * be the inverse of the value of the second. Example line:
     * INVERT opt1 opt2
     * 
     */
    private boolean parseModification(String optionsFile, String[] parts) {
        if (parts[0].equals("DEFAULT")) {
            String name = parts[1];
            String defaultValue = parts[2];
            optionsModification.add(new OptionModificationSetDefault(optionsFile, parts[0], name, defaultValue));
            return true;
        } else if (parts[0].equals("REMOVE")) {
            String name = parts[1];
            optionsModification.add(new OptionModificationRemove(optionsFile, parts[0], name));
            return true;
        } else if (parts[0].equals("INVERT")) {
            String name = parts[1];
            String defaultValue = parts[2];
            optionsModification.add(new OptionModificationInvert(optionsFile, parts[0], name, defaultValue));
            return true;
        }
        return false;
    }
    
    /**
     * Parse the first line of a declaration. Whitespace and newline sensitive.
     * Expects 
     * 1. the kind of option (BOOLEAN, STRING, etc.)
     * 2. Name
     * 3. Category
     * 4. Type
     * 5. Default value
     * 6. Either a test default value or a min and max value
     * 
     * Example lines:
     * BOOLEAN opt1 compiler user true
     * or
     * BOOLEAN opt1 compiler user true false
     * or 
     * INTEGER opt1 compiler user 1 0 100
     */
    private static OptionDeclaration parseDeclaration(String optionsFile, String[] parts) {
        String kind = parseKind(parts[0]);
        String name = parts[1];
        String category = parts[2];
        String type = parts[3];
        String defaultValue = parts[4];
        OptionDeclaration res = new OptionDeclaration(optionsFile, kind, name, defaultValue, category, type);
        if (parts.length > 6) {
            res.setArgs(Arrays.copyOfRange(parts, 5, parts.length));
        } else if (parts.length > 5) {
            res.setTestDefaultValue(parts[5]);
        }
        return res;
    }
    
    /**
     * If the next line is not empty, parse a set of possible values for the option. Whitespace and newline sensitive.
     * Example line:
     * "str1" "str2"
     * or
     * 0 1 2 5 7
     */
    private static void parsePossibleValues(OptionDeclaration res, BufferedReader reader) throws IOException {
        String line = reader.readLine();
        if (!isEmpty(line)) {
            res.setPossibleValues(line.split(" "));
        }
    }
    
    /**
     * Parse an option description. The description should start and end with
     * quotes. Will eat lines until there is an empty one. Newlines will be
     * discarded. Example lines: 
     * "This is a
     * multiline
     * description"
     * or
     * "This is a single line description"
     */
    private void parseDescription(OptionDeclaration res, BufferedReader reader) throws IOException {
        StringBuilder description = new StringBuilder();
        String line = nextLine(reader);
        do {
            description.append(line);
        } while ((line = reader.readLine()) != null && !isEmpty(line));

        res.setDescription(description.toString());
    }
    
    private void addDeclaration(OptionDeclaration res) throws OptionsAggregationException {
        Option old = options.get(res.getName());
        if (old != null) {
            throw new OptionsAggregationException(String.format(
                    "Found duplicated option declaration for %s. Old declaration from %s. New declaration from %s.",
                    res.getName(), old.getFilePath(), res.getFilePath()));
        }
        options.put(res.getName(), res);
    }
    
    /**
     * Parse a full declaration including possible values and description. Example:
     * STRING opt1 compiler user "default"
     * "default" "otherValue"
     * 
     * "A very nice option"
     * 
     */
    private void parseFullDeclaration(String optionsFile, BufferedReader reader, String[] parts) throws OptionsAggregationException, IOException {
        OptionDeclaration res = parseDeclaration(optionsFile, parts);
        parsePossibleValues(res, reader);
        parseDescription(res, reader);
        addDeclaration(res);
    }
    
    private boolean parseNextOption(String optionsFile, BufferedReader reader) throws IOException, OptionsAggregationException {
        String line = nextLine(reader);
        if (line == null) {
            return false;
        }
        String[] parts = line.split(" ");
        if (parts.length > 7) {
            throw new OptionsAggregationException("Too many parts on the line! " + optionsFile + "\n" + line);
        }

        if (parseModification(optionsFile, parts)) {
            return true;
        } else {
            if (parts.length < 5) {
                throw new OptionsAggregationException("Too few parts on the line! " + optionsFile + "\n" + line);
            }
            parseFullDeclaration(optionsFile, reader, parts);
        }

        return true;
    }

    public void parseFile(String file, BufferedReader reader) throws IOException, OptionsAggregationException {
        while (parseNextOption(file, reader)) {
            // all program logic is contained in while-condition.
        }
    }
    
    public void parseFile(File optionsFile) throws IOException, OptionsAggregationException {
        try(BufferedReader reader = new BufferedReader(
                new InputStreamReader(new FileInputStream(optionsFile), "UTF8"))) {
            parseFile(optionsFile.getAbsolutePath(), reader);
        }
    }

    public void parseFiles(String modules) throws IOException, OptionsAggregationException {
        for (String module : modules.split(",")) {
            module = module.trim();
            module = module.substring(1, module.length() - 1);
            File moduleFile = new File(module);
            if (moduleFile.exists()) {
                for (File in : moduleFile.listFiles()) {
                    if (in.getName().endsWith(".options")) {
                        parseFile(in);
                    }
                }
            }
        }
    }

    public void modify() throws OptionsAggregationException {
        for (OptionModification mod : optionsModification) {
            mod.modify();
        }
    }

    public OptionsAggregator() {
        
    }

    public OptionsAggregator(String modules) throws IOException, OptionsAggregationException {
        parseFiles(modules);
        modify();
    }

    public static void main(String[] args) throws IOException, OptionsAggregationException {
        File outDir = new File(args[0]);
        String pack = args[1];
        String modules = args[3];

        OptionsAggregator op = new OptionsAggregator(modules);
        File outFile = new File(outDir, "OptionRegistry.java");
        try (FileOutputStream fout = new FileOutputStream(outFile);
             PrintStream out = new PrintStream(fout)) {
            op.generate(out, pack);
        }
        System.out.println("Generated " + outFile.getAbsolutePath() + "...");
    }

    public Iterable<OptionDeclaration> getOptions() {
        ArrayList<OptionDeclaration> res = new ArrayList<>();
        for (OptionDeclaration opt : options.values()) {
            if (!opt.getRemoved()) {
                res.add(opt);
            }
        }
        return res;
    }
}
