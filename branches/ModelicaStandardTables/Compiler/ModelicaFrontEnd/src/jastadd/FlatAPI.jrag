/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.Collections;
import java.util.LinkedHashSet;
import java.util.HashSet;
import java.util.Set;
import java.util.ArrayList;
import java.io.File;
import java.net.URI;
import java.net.URISyntaxException;
import java.math.BigInteger;
import java.io.PipedInputStream;
import java.io.PipedOutputStream;
import java.io.PrintStream;
import java.io.FileInputStream;
import java.io.IOException;
import java.security.MessageDigest;
import java.security.DigestOutputStream;
import java.security.NoSuchAlgorithmException;

import org.jmodelica.util.StreamGobbler;

aspect FlatAPI {
	
	public class FClass {
		/**
		 * Calculates and holds value references for all variables.
		 */
		private class ValueReferenceMap {
			private int index = 0;
			private int type = 0;
			private HashMap<FVariable, Integer> map = new HashMap<FVariable, Integer>();
			
			/**
			 * Start a new variable vector, i.e. reset the index part to 0.
			 */
			public void resetIndex() {
				index = 0;
			}

			/**
			 * Increase the index counter by one.
			 */
			public void incIndex() {
				index++;
			}
			
			/**
			 * Set the value to use for the type bits.
			 */
			public void setType(int t) {
				type = t << 28;
			}
			
			/**
			 * Calculate indices for the variables in a list and add them to the map.
			 * 
			 * Indices are assigned in the order variable lists are added. Within a list, 
			 * they are assigned in iterator order.
			 */
			public void add(Iterable<? extends FVariable> list) {
				for (FVariable fv : list) {
					map.put(fv, new Integer(index + type));
					index++;
				}
			}
			
			/**
			 * Get the index for a variable.
			 * 
			 * If it is not in the map, -1 is returned.
			 */
			public int get(FVariable fv) {
				Integer i = map.get(fv);
				return (i == null) ? -1 : i.intValue();
			}
		}
	}
	
	syn lazy ValueReferenceMap FClass.valueReferenceMap() {
		ValueReferenceMap map = new ValueReferenceMap();
		map.setType(0);
		map.add(independentRealConstants());
		map.add(dependentRealConstants());
		map.add(independentRealParameters());
		map.add(dependentRealParameters());
		
		map.setType(1);
		// Handle enums as Integers
		map.add(independentIntegerConstants());
		map.add(independentEnumConstants());
		map.add(dependentIntegerConstants());
		map.add(dependentEnumConstants());
		map.add(independentIntegerParameters());
		map.add(independentEnumParameters());
		map.add(dependentIntegerParameters());
		map.add(dependentEnumParameters());
		
		map.setType(2);
		map.add(independentBooleanConstants());
		map.add(dependentBooleanConstants());
		map.add(independentBooleanParameters());
		map.add(dependentBooleanParameters());
		
		map.setType(0);
		map.add(derivativeVariables());
		map.add(differentiatedRealVariables());
		map.add(realInputs());
		map.add(algebraicContinousRealVariables());
		
		// Need to increase the index counter by one since the
		// 'time' variable is stored in this position
		map.incIndex();
		
		map.add(discreteRealVariables());
		
		map.setType(1);
		// Handle enums as Integers
		map.add(discreteIntegerVariables());
		map.add(discreteEnumVariables());
		map.add(integerInputs());
		map.add(enumInputs());
		
		map.setType(2);
		map.add(discreteBooleanVariables());
		map.add(booleanInputs());
		
		map.resetIndex();
		map.setType(3);
		map.add(independentStringConstants());
		map.add(dependentStringConstants());
		map.add(independentStringParameters());
		map.add(dependentStringParameters());
		map.add(stringInputs());
		map.add(discreteStringVariables());
		
		return map;
	}
	
	/**
	 * The value reference value is represented by a 32 bit unsigned integer 
	 * variable. The lowest 28 bits is used to represent the index of a 
	 * variable of the corresponding variable vector. Real, Integer, Boolean and 
	 * enumeration variables share a vector, while String variables has their 
	 * own vector. 
	 * Bits 29-31 represents the primitive type, where:
	 * 0: Real
	 * 1: Integer or enumeration
	 * 2: Boolean
	 * 3: String
	 * Bit 32 is left unused.
	 *
	 */
	inh lazy int FAbstractVariable.valueReference();
	eq FClass.getFVariable(int i).valueReference()     = valueReferenceMap().get(getFVariable(i));
	eq FClass.getAliasVariable(int i).valueReference() = getAliasVariable(i).aliasValueReference();
	eq FClass.getFEquationBlock().valueReference()     = -1;
	eq Root.getChild().valueReference()                = -1;
	
	syn int FVariable.aliasValueReference() = alias()!=null? 
		alias().valueReference(): -1;

	syn int FVariable.indexInZ() = valueReference() & 0x0FFFFFFF;

	syn int FClass.independentRealConstantsOffset() = 0;
	syn int FClass.independentIntegerConstantsOffset() = 
		numIndependentRealConstants();	
	syn int FClass.independentEnumConstantsOffset() =
		independentIntegerConstantsOffset() + 	  
		numIndependentIntegerConstants();	
	syn int FClass.IndependentBooleanConstantsOffset() =
		independentEnumConstantsOffset() + 	  
		numIndependentEnumConstants();	
		/*
	syn int FClass.independentBooleanConstantsOffset() = 
		numIndependentRealConstants() + 
		numIndependentIntegerConstants();	
		*/
	syn int FClass.independentStringConstantsOffset() = 
		numIndependentRealConstants() + 
		numIndependentIntegerConstants()
		+ numIndependentBooleanConstants();
		
	syn int FClass.dependentRealConstantsOffset() = 
		independentStringConstantsOffset() + 
		numIndependentStringConstants();
	syn int FClass.dependentIntegerConstantsOffset() =
		dependentRealConstantsOffset() + 	 
		numDependentRealConstants();	
	syn int FClass.dependentEnumConstantsOffset() =
		dependentIntegerConstantsOffset() + 	  
		numDependentIntegerConstants();	
	syn int FClass.dependentBooleanConstantsOffset() =
		dependentEnumConstantsOffset() + 	  
		numDependentEnumConstants();	
/*
	syn int FClass.dependentBooleanConstantsOffset() =
		dependentIntegerConstantsOffset() + 	  
		numDependentIntegerConstants();	
		*/
	syn int FClass.dependentStringConstantsOffset() = 
		dependentBooleanConstantsOffset() + 	  
		+ numDependentBooleanConstants();

	syn int FClass.independentRealParametersOffset() = 
		dependentStringConstantsOffset() + 
		numDependentStringConstants();
	syn int FClass.independentIntegerParametersOffset() =
		independentRealParametersOffset() + 	 
		numIndependentRealParameters();	
	syn int FClass.independentEnumParametersOffset() =
		independentIntegerParametersOffset() + 	  
		numIndependentIntegerParameters();	
	syn int FClass.independentBooleanParametersOffset() =
		independentEnumParametersOffset() + 	  
		numIndependentEnumParameters();	

		/*
	syn int FClass.independentBooleanParametersOffset() =
		independentIntegerParametersOffset() + 	  
		numIndependentIntegerParameters();	
		*/
	syn int FClass.independentStringParametersOffset() = 
		independentBooleanParametersOffset() + 	  
		+ numIndependentBooleanParameters();
		
	syn int FClass.dependentRealParametersOffset() = 
		independentStringParametersOffset() + 
		numIndependentStringParameters();
	syn int FClass.dependentIntegerParametersOffset() =
		dependentRealParametersOffset() + 	 
		numDependentRealParameters();	

	syn int FClass.dependentEnumParametersOffset() =
		dependentIntegerParametersOffset() + 	  
		numDependentIntegerParameters();	
	syn int FClass.dependentBooleanParametersOffset() =
		dependentEnumParametersOffset() + 	  
		numDependentEnumParameters();	
		/*
	syn int FClass.dependentBooleanParametersOffset() =
		dependentIntegerParametersOffset() + 	  
		numDependentIntegerParameters();	
		*/
	syn int FClass.dependentStringParametersOffset() = 
		dependentBooleanParametersOffset() + 	  
		+ numDependentBooleanParameters();

	syn int FClass.derivativeVariablesOffset() = 
		dependentStringParametersOffset() + 
		numDependentStringParameters();
	syn int FClass.differentiatedRealVariablesOffset() = 
		derivativeVariablesOffset() + 
		numDerivativeVariables();
	syn int FClass.realInputsOffset() = 
		differentiatedRealVariablesOffset() + 
		numDifferentiatedRealVariables();
	syn int FClass.algebraicContinousRealVariablesOffset() = 
		realInputsOffset() + 
		numRealInputs();

	syn int FClass.timeOffset() =
	    algebraicContinousRealVariablesOffset() + 
	    numAlgebraicContinousRealVariables();

	syn int FClass.discreteRealVariablesOffset() = 
		timeOffset() + 1;
		
	syn int FClass.discreteIntegerVariablesOffset() = 
		discreteRealVariablesOffset() + 
		numDiscreteRealVariables();
	syn int FClass.discreteEnumVariablesOffset() = 
		discreteIntegerVariablesOffset() + 
		numDiscreteIntegerVariables();

	syn int FClass.integerInputsOffset() = 
		discreteEnumVariablesOffset() + 
		numDiscreteEnumVariables();
	syn int FClass.enumInputsOffset() = 
		integerInputsOffset() + 
		numIntegerInputs();

	syn int FClass.discreteBooleanVariablesOffset() = 
		enumInputsOffset() + 
		numEnumInputs();
	syn int FClass.booleanInputsOffset() = 
		discreteBooleanVariablesOffset() + 
		numDiscreteBooleanVariables();

	syn boolean FVariable.shouldContribute() = !isAlias() && !inRecord() && !isForIndex();
	
	public class FClass {
		public static <T extends FVariable, C extends Collection<T>> C intersectFVColl(
				C a, Collection<? extends FVariable> b) {
			try {
				// To avoid having to have different versions for different collections
				C res = (C) a.getClass().newInstance();
				res.addAll(a);
				res.retainAll(b);
				return res;
			} catch (IllegalAccessException e) {
			} catch (InstantiationException e) {
			}
			throw new IllegalArgumentException("First argument must be of class with public default constructor.");
		}
	}

    syn int FClass.numReals() = reals().size();
	coll ArrayList<FRealVariable> FClass.reals() 
	  [new ArrayList<FRealVariable>()] with add root FlatRoot;
	FRealVariable contributes this when shouldContribute() to FClass.reals() for myFClass();
//	FDerivativeVariable contributes this to FClass.reals() for myFClass();

    syn int FClass.numIntegers() = integers().size();
	coll ArrayList<FIntegerVariable> FClass.integers() 
	  [new ArrayList<FIntegerVariable>()] with add root FlatRoot;
	FIntegerVariable contributes this when shouldContribute() to FClass.integers() for myFClass();

    syn int FClass.numEnums() = enums().size();
	coll ArrayList<FEnumVariable> FClass.enums() 
	  [new ArrayList<FEnumVariable>()] with add root FlatRoot;
	FEnumVariable contributes this when shouldContribute() to FClass.enums() for myFClass();

    syn int FClass.numBooleans() = booleans().size();
	coll ArrayList<FBooleanVariable> FClass.booleans() 
	  [new ArrayList<FBooleanVariable>()] with add root FlatRoot;
	FBooleanVariable contributes this when shouldContribute() to FClass.booleans() for myFClass();

    syn int FClass.numStrings() = strings().size();
	coll ArrayList<FStringVariable> FClass.strings() 
	  [new ArrayList<FStringVariable>()] with add root FlatRoot;
	FStringVariable contributes this when shouldContribute() to FClass.strings() for myFClass();

    syn int FClass.numIndependentConstants() = independentConstants().size();
	coll ArrayList<FVariable> FClass.independentConstants() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes this 
	  when isIndependentConstant() && shouldContribute() 
	  to FClass.independentConstants() for myFClass();

    syn int FClass.numExternalObjectVariables() = externalObjectVariables().size();
	coll ArrayList<FExternalObjectVariable> FClass.externalObjectVariables()
      [new ArrayList<FExternalObjectVariable>()] with add root FlatRoot;
	FExternalObjectVariable contributes this when shouldContribute() to FClass.externalObjectVariables() for myFClass();

	syn int FClass.numIndependentRealConstants() = independentRealConstants().size();
	syn lazy ArrayList<FRealVariable> FClass.independentRealConstants() = 
		intersectFVColl(reals(), independentConstants());
	
	syn int FClass.numIndependentIntegerConstants() = independentIntegerConstants().size();
	syn lazy ArrayList<FIntegerVariable> FClass.independentIntegerConstants() = 
		intersectFVColl(integers(), independentConstants());
	
	syn int FClass.numIndependentEnumConstants() = independentEnumConstants().size();
	syn lazy ArrayList<FEnumVariable> FClass.independentEnumConstants() = 
		intersectFVColl(enums(), independentConstants());
	
	syn int FClass.numIndependentBooleanConstants() = independentBooleanConstants().size();
	syn lazy ArrayList<FBooleanVariable> FClass.independentBooleanConstants() = 
		intersectFVColl(booleans(), independentConstants());
	
	syn int FClass.numIndependentStringConstants() = independentStringConstants().size();
	syn lazy ArrayList<FStringVariable> FClass.independentStringConstants() = 
		intersectFVColl(strings(), independentConstants());

	// TODO: Is there such a thing as a dependent constant??
    syn int FClass.numDependentConstants() = dependentConstants().size();
	syn ArrayList<FVariable> FClass.dependentConstants() = new ArrayList<FVariable>(0);
// This collection would never contain anything, replacing with just an empty list.
//	coll ArrayList<FVariable> FClass.dependentConstants() 
//	  [new ArrayList<FVariable>()] with add root FlatRoot;
//	FVariable contributes
// 		this when false
//	to FClass.dependentConstants() for myFClass();
	
	syn int FClass.numDependentRealConstants() = dependentRealConstants().size();
	syn lazy ArrayList<FRealVariable> FClass.dependentRealConstants() =
      intersectFVColl(reals(), dependentConstants());
	
	syn int FClass.numDependentIntegerConstants() = dependentIntegerConstants().size();
	syn lazy ArrayList<FIntegerVariable> FClass.dependentIntegerConstants() =
      intersectFVColl(integers(), dependentConstants());
	
	syn int FClass.numDependentEnumConstants() = dependentEnumConstants().size();
	syn lazy ArrayList<FEnumVariable> FClass.dependentEnumConstants() =
      intersectFVColl(enums(), dependentConstants());
	
	syn int FClass.numDependentBooleanConstants() = dependentBooleanConstants().size();
	syn lazy ArrayList<FBooleanVariable> FClass.dependentBooleanConstants() =
      intersectFVColl(booleans(), dependentConstants());
	
	syn int FClass.numDependentStringConstants() = dependentStringConstants().size();
	syn lazy ArrayList<FStringVariable> FClass.dependentStringConstants() =
      intersectFVColl(strings(), dependentConstants());

    syn int FClass.numIndependentParameters() = independentParameters().size();
	coll ArrayList<FVariable> FClass.independentParameters() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isIndependentParameter() && shouldContribute()
	to FClass.independentParameters() for myFClass();
	
	syn int FClass.numIndependentRealParameters() = independentRealParameters().size();
	syn lazy ArrayList<FRealVariable> FClass.independentRealParameters() =
      intersectFVColl(reals(), independentParameters());

	syn int FClass.numIndependentIntegerParameters() = independentIntegerParameters().size();
	syn lazy ArrayList<FIntegerVariable> FClass.independentIntegerParameters() =
      intersectFVColl(integers(), independentParameters());

	syn int FClass.numIndependentEnumParameters() = independentEnumParameters().size();
	syn lazy ArrayList<FEnumVariable> FClass.independentEnumParameters() =
      intersectFVColl(enums(), independentParameters());
	
	syn int FClass.numIndependentBooleanParameters() = independentBooleanParameters().size();
	syn lazy ArrayList<FBooleanVariable> FClass.independentBooleanParameters() =
      intersectFVColl(booleans(), independentParameters());

	syn int FClass.numIndependentStringParameters() = independentStringParameters().size();
	syn lazy ArrayList<FStringVariable> FClass.independentStringParameters() =
      intersectFVColl(strings(), independentParameters());

    syn int FClass.numDependentParameters() = dependentParameters().size();
	coll ArrayList<FVariable> FClass.dependentParameters() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isDependentParameter() && shouldContribute()
	to FClass.dependentParameters() for myFClass();

	syn int FClass.numDependentRealParameters() = dependentRealParameters().size();
	syn lazy ArrayList<FRealVariable> FClass.dependentRealParameters() =
      intersectFVColl(reals(), dependentParameters());

	syn int FClass.numDependentIntegerParameters() = dependentIntegerParameters().size();
	syn lazy ArrayList<FIntegerVariable> FClass.dependentIntegerParameters() =
      intersectFVColl(integers(), dependentParameters());

	syn int FClass.numDependentEnumParameters() = dependentEnumParameters().size();
	syn lazy ArrayList<FEnumVariable> FClass.dependentEnumParameters() =
      intersectFVColl(enums(), dependentParameters());
	
	syn int FClass.numDependentBooleanParameters() = dependentBooleanParameters().size();
	syn lazy ArrayList<FBooleanVariable> FClass.dependentBooleanParameters() =
      intersectFVColl(booleans(), dependentParameters());
	
	syn int FClass.numDependentStringParameters() = dependentStringParameters().size();
	syn lazy ArrayList<FStringVariable> FClass.dependentStringParameters() =
      intersectFVColl(strings(), dependentParameters());

	syn int FClass.numDiscreteRealVariables() = discreteRealVariables().size();
	syn lazy ArrayList<FRealVariable> FClass.discreteRealVariables() =
      intersectFVColl(reals(), discreteVariables());

	syn int FClass.numDiscreteIntegerVariables() = discreteIntegerVariables().size();
	syn lazy ArrayList<FIntegerVariable> FClass.discreteIntegerVariables() =
      intersectFVColl(integers(), discreteVariables());

	syn int FClass.numDiscreteEnumVariables() = discreteEnumVariables().size();
	syn lazy ArrayList<FEnumVariable> FClass.discreteEnumVariables() =
      intersectFVColl(enums(), discreteVariables());

	syn int FClass.numDiscreteBooleanVariables() = discreteBooleanVariables().size();
	syn lazy ArrayList<FBooleanVariable> FClass.discreteBooleanVariables() =
      intersectFVColl(booleans(), discreteVariables());

	syn int FClass.numDiscreteStringVariables() = discreteStringVariables().size();
	syn lazy ArrayList<FStringVariable> FClass.discreteStringVariables() =
      intersectFVColl(strings(), discreteVariables());
		
    syn int FClass.numDifferentiatedRealVariables() = differentiatedRealVariables().size();
  	syn lazy ArrayList<FRealVariable> FClass.differentiatedRealVariables() {
  		ArrayList<FRealVariable> l = new ArrayList<FRealVariable>();
  		for (FRealVariable fv : differentiatedRealVariablesSet()) {
  			l.add(fv);
  		}
  		return l;
  	}
  	// The LinkedHashSet is used here to avoid duplicates.
	coll LinkedHashSet<FRealVariable> FClass.differentiatedRealVariablesSet() 
	  [new LinkedHashSet<FRealVariable>()] with add root FlatRoot;
	FDerExp contributes
 		(FRealVariable)getFIdUse().myFV() when !getFIdUse().myFV().isUnknown()
	to FClass.differentiatedRealVariablesSet() for myFClass();
	syn int FVariable.differentiatedRealVariableIndex() =
		myFClass().differentiatedRealVariables().indexOf(this);

    syn int FClass.numDerivativeVariables() = derivativeVariables().size();
	coll ArrayList<FDerivativeVariable> FClass.derivativeVariables() 
	  [new ArrayList<FDerivativeVariable>()] with add root FlatRoot;
	FDerivativeVariable contributes
		this when (shouldContribute())
	to FClass.derivativeVariables() for myFClass();
	
    syn int FClass.numVariables() = variables().size();
	coll ArrayList<FVariable> FClass.variables() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when !isParameter() && !isConstant() && !isPreVariable() && shouldContribute()
	to FClass.variables() for myFClass();

    syn int FClass.numDiscreteVariables() = discreteVariables().size();
	coll ArrayList<FVariable> FClass.discreteVariables() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FRealVariable contributes
		this when isDiscrete() && !isInput() && !isPreVariable() && shouldContribute()
	to FClass.discreteVariables() for myFClass();	
	FIntegerVariable contributes
		this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
	to FClass.discreteVariables() for myFClass();	
	FEnumVariable contributes
		this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
	to FClass.discreteVariables() for myFClass();	
	FBooleanVariable contributes
		this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
	to FClass.discreteVariables() for myFClass();	
	FStringVariable contributes
		this when !isParameter() && !isInput() && !isPreVariable() && !isConstant() && shouldContribute()
	to FClass.discreteVariables() for myFClass();	

	syn int FClass.numDiscretePreVariables() = discretePreVariables().size();
	syn lazy ArrayList<FVariable> FClass.discretePreVariables() {
		ArrayList<FVariable> l = new ArrayList<FVariable>();
		for (FVariable fv : discreteVariables()) {
			l.add((FVariable) lookupFV(fv.getFQName().preName()));
		}
		return l;
	}
	
    syn int FClass.numAliasVariables() = aliasVariables().size();
	coll ArrayList<FVariable> FClass.aliasVariables() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when  !isParameter() && !isConstant() && isAlias()
	to FClass.aliasVariables() for myFClass();

    syn int FClass.numAllVariables() = allVariables().size();
	syn lazy ArrayList<FVariable> FClass.allVariables() {
	      ArrayList<FVariable> set = new ArrayList<FVariable>();
	      for (FVariable fv : getFVariables()) {
                  set.add(fv);
              }
	      for (FVariable fv : getAliasVariables()) {
                  set.add(fv);
              }
	      return set;
	}
	
    syn int FClass.numTempVariables() = tempVariables().size();
	coll ArrayList<FVariable> FClass.tempVariables() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isTemporary() && shouldContribute()
	to FClass.tempVariables() for myFClass();
	
	syn int FClass.numRealVariables() = realVariables().size();
	syn lazy ArrayList<FRealVariable> FClass.realVariables() =
      intersectFVColl(reals(), variables());

	syn int FClass.numIntegerVariables() = integerVariables().size();
	syn lazy ArrayList<FIntegerVariable> FClass.integerVariables() =
      intersectFVColl(integers(), variables());

	syn int FClass.numEnumVariables() = enumVariables().size();
	syn lazy ArrayList<FEnumVariable> FClass.enumVariables() =
      intersectFVColl(enums(), variables());

	syn int FClass.numBooleanVariables() = booleanVariables().size();
	syn lazy ArrayList<FBooleanVariable> FClass.booleanVariables() =
      intersectFVColl(booleans(), variables());

	syn int FClass.numStringVariables() = stringVariables().size();
	syn lazy ArrayList<FStringVariable> FClass.stringVariables() =
      intersectFVColl(strings(), variables());
	
    syn int FClass.numAlgebraicContinousRealVariables() = algebraicContinousRealVariables().size();
	syn lazy ArrayList<FRealVariable> FClass.algebraicContinousRealVariables() { 
	  ArrayList<FRealVariable> set = intersectFVColl(reals(),variables());
  	  set.removeAll(differentiatedRealVariables());
  	  set.removeAll(derivativeVariables());
  	  set.removeAll(discreteVariables());
  	  set.removeAll(inputs());
      return set;
	}
	syn int FVariable.algebraicContinousRealVariableIndex() =
		myFClass().algebraicContinousRealVariables().indexOf(this);
	
	syn lazy ArrayList<FVariable> FClass.algebraicVariables() {
		ArrayList<FVariable> set = new ArrayList<FVariable>();
		set.addAll(algebraicContinousRealVariables());
		set.addAll(discreteVariables());
		return set;
	}

	// There are no free parameters in the Modelica compiler
	// but these attributes are refined in the Optimica compiler
	syn int FClass.numFreeParameters() {
		return 0;
 	}


	/*
    syn int FClass.numAlgebraicContinousRealVariables() = algebraicContinousRealVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicContinousRealVariables() { 
	  ArrayList<FVariable> set = new ArrayList<FVariable>();
	  set.addAll(algebraicVariables());
	  set.retainAll(reals());
	  set.removeAll(discreteVariables());
      return set;
	}
	*/
	
	/*
    syn int FClass.numAlgebraicIntegerVariables() = algebraicIntegerVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicIntegerVariables() = 
	  intersectFVColl(algebraicVariables(), integers());
	
    syn int FClass.numAlgebraicEnumVariables() = algebraicEnumVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicEnumVariables() = 
	  intersectFVColl(algebraicVariables(), enums());
	
    syn int FClass.numAlgebraicBooleanVariables() = algebraicBooleanVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicBooleanVariables() = 
	  intersectFVColl(algebraicVariables(), booleans());

    syn int FClass.numAlgebraicStringVariables() = algebraicStringVariables().size();
	syn lazy ArrayList<FVariable> FClass.algebraicStringVariables() = 
	  intersectFVColl(algebraicVariables(), strings());
*/
	
    syn int FClass.numVariablesWithBindingExp() = variablesWithBindingExp().size();
	coll ArrayList<FVariable> FClass.variablesWithBindingExp() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when !isParameter() && !isConstant() &&
 		  hasBindingExp() && shouldContribute()
	to FClass.variablesWithBindingExp() for myFClass();

	syn int FClass.numRealVariablesWithBindingExp() = realVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.realVariablesWithBindingExp() =
      intersectFVColl(variablesWithBindingExp(), reals());

	syn int FClass.numIntegerVariablesWithBindingExp() = integerVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.integerVariablesWithBindingExp() =
      intersectFVColl(variablesWithBindingExp(), integers());

	syn int FClass.numEnumVariablesWithBindingExp() = enumVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.enumVariablesWithBindingExp() =
      intersectFVColl(variablesWithBindingExp(), enums());

	syn int FClass.numBooleanVariablesWithBindingExp() = booleanVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.booleanVariablesWithBindingExp() =
      intersectFVColl(variablesWithBindingExp(), booleans());

	syn int FClass.numStringVariablesWithBindingExp() = stringVariablesWithBindingExp().size();
	syn lazy ArrayList<FVariable> FClass.stringVariablesWithBindingExp() =
      intersectFVColl(variablesWithBindingExp(), strings());
     
    syn int FClass.numInputs() = inputs().size();
	coll ArrayList<FVariable> FClass.inputs() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isInput() && shouldContribute()
	to FClass.inputs() for myFClass();

	syn int FVariable.inputIndex() =
		myFClass().inputs().indexOf(this);

	syn int FClass.numRealInputs() = realInputs().size();
	syn lazy ArrayList<FVariable> FClass.realInputs() =
      intersectFVColl(inputs(), reals());
	
	syn int FClass.numIntegerInputs() = integerInputs().size();
	syn lazy ArrayList<FVariable> FClass.integerInputs() =
      intersectFVColl(inputs(), integers());
	
	syn int FClass.numEnumInputs() = enumInputs().size();
	syn lazy ArrayList<FVariable> FClass.enumInputs() =
      intersectFVColl(inputs(), enums());

	syn int FClass.numBooleanInputs() = booleanInputs().size();
	syn lazy ArrayList<FVariable> FClass.booleanInputs() =
      intersectFVColl(inputs(), booleans());

	syn int FClass.numStringInputs() = stringInputs().size();
	syn lazy ArrayList<FVariable> FClass.stringInputs() =
      intersectFVColl(inputs(), strings());

    syn int FClass.numOutputs() = outputs().size();
	coll ArrayList<FVariable> FClass.outputs() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FVariable contributes
 		this when isOutput() && shouldContribute()
	to FClass.outputs() for myFClass();

	syn int FClass.numRealOutputs() = realOutputs().size();
	syn lazy ArrayList<FVariable> FClass.realOutputs() =
      intersectFVColl(outputs(), reals());
	
	syn int FClass.numIntegerOutputs() = integerOutputs().size();
	syn lazy ArrayList<FVariable> FClass.integerOutputs() =
      intersectFVColl(outputs(), integers());
	
	syn int FClass.numEnumOutputs() = enumOutputs().size();
	syn lazy ArrayList<FVariable> FClass.enumOutputs() =
      intersectFVColl(outputs(), enums());

	syn int FClass.numBooleanOutputs() = booleanOutputs().size();
	syn lazy ArrayList<FVariable> FClass.booleanOutputs() =
      intersectFVColl(outputs(), booleans());

	syn int FClass.numStringOutputs() = stringOutputs().size();
	syn lazy ArrayList<FVariable> FClass.stringOutputs() =
      intersectFVColl(outputs(), strings());

    syn lazy int FClass.numScalarEquations() {
    	int res = 0;
    	for (FAbstractEquation e : equations())
    		res += e.numScalarEquations();
    	return res;
    }
    syn lazy int FClass.numScalarEquationsAtInitialization() {
    	int res = 0;
    	for (FAbstractEquation e : equations())
 		   	res += e.numScalarEquations();
    	return res;
    }

    syn int FClass.numEquations() = equations().size();
	syn lazy ArrayList<FAbstractEquation> FClass.equations() {
		ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
		for (FEquationBlock b : getFEquationBlocks()) {
			for (FAbstractEquation e : b.getFAbstractEquations()) {
				if (!e.isIgnored()) {
					l.add(e);
				}
			}
		}
		return l;
	}

    syn int FClass.numContinousEquations() = continuousEquations().size();
	syn lazy ArrayList<FAbstractEquation> FClass.continuousEquations() {
		ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
		for (FEquationBlock b : getFEquationBlocks()) {
			for (FAbstractEquation e : b.getFAbstractEquations()) {
				if (!e.isIgnored() && e.isContinuous()) {
					l.add(e);
				}
			}
		}
		return l;
	}

	syn int FAbstractEquation.numScalarEquations() = 1;
	eq FEquation.numScalarEquations()           = getLeft().size().numElements();
	eq FConnectClause.numScalarEquations()      = getConnector1().size().numElements();
	eq FAlgorithm.numScalarEquations() {
		ArrayList<FVariable> assignedVars = new ArrayList<FVariable>();
		for (FIdUse use : assignedFIdUses()) {
			if (!use.myFV().isUnknown() && !assignedVars.contains(use.myFV())) {
				FVariable fv = (FVariable) use.myFV();
				assignedVars.add(fv);
			}
		}
		return assignedVars.size();

	}
	eq FIfWhenElseEquation.numScalarEquations() = numScalarEqnsInList(getFAbstractEquations());
	eq FForClauseE.numScalarEquations()         = 
		numScalarEqnsInList(getFAbstractEquations()) * numForElems(getFForIndexs());
	eq InstForClauseE.numScalarEquations()      = 
		numScalarEqnsInList(getFAbstractEquations()) * numForElems(getInstForIndexs());
	eq FFunctionCallEquation.numScalarEquations() {
		 int res = 0;
		 for (FFunctionCallLeft l : getLefts())
			 res += l.numScalarVars();
		 return res;
	}
	
	protected static int FAbstractEquation.numForElems(List<? extends CommonForIndex> list) {
		int res = 1;
		for (CommonForIndex i : list)
			res *= i.size().numElements();
		return res;
	}
	
	protected static int FAbstractEquation.numScalarEqnsInList(List<FAbstractEquation> list) {
		int res = 0;
		for (FAbstractEquation e : list) 
			res += e.numScalarEquations();
		return res;
	}

	syn int FClass.numSamplers() = 
		samplers().size();

	coll ArrayList<FSampleExp> FClass.samplers() 
	  [new ArrayList<FSampleExp>()] with add root FlatRoot;
	
	FSampleExp contributes
 		this when originalFSampleExp==null
	to FClass.samplers() for myFClass();	
		
	public int FSampleExp.samplersIndex() {
		return myFClass().samplers().
			indexOf(this.originalFSampleExp==null? this: this.originalFSampleExp);
	}
	
	syn int FClass.numGuardExpInEquations() = 
		guardExpInEquations().size();

	coll ArrayList<FExp> FClass.guardExpInEquations() 
	  [new ArrayList<FExp>()] with addAll root FlatRoot;
	FWhenEquation contributes
    // Only include relational in the equation section which are 
    // not inside a noEvent operator
 		guards() when getTest().inEquationSection()
	to FClass.guardExpInEquations() for myFClass();	
		
	syn ArrayList<FExp> FWhenEquation.guards() {
		ArrayList<FExp> l = new ArrayList<FExp>();
		if (!getTest().isArray()) {
			l.add(getTest());
		} else {
			for (FExp e : getTest().getArray().iterable()) {
				l.add(e);
			}
		}
		return l;
	}
		
	public int FExp.guardExpInEquationsIndex() {
		return myFClass().guardExpInEquations().
			indexOf(this);
	}

	syn boolean FRelExp.generatesEvent() =
			!inNoEventExp() &&
			!inSmoothExp(1) &&
			isRealComparison() &&
			!inWhen() &&
			!variability().lessOrEqual(fParameter());
	
	syn int FClass.numEventIndicators() = numRelExpInEquations();
	
    syn int FClass.numRelExpInEquations() = relExpInEquations().size();
	coll ArrayList<FRelExp> FClass.relExpInEquations() 
	  [new ArrayList<FRelExp>()] with add root FlatRoot;
	FRelExp contributes
 		this when inEquationSection() && originalFRelExp==null && generatesEvent() 
	to FClass.relExpInEquations() for myFClass();	
		
	public int FRelExp.relExpInEquationsIndex() {
		return myFClass().relExpInEquations().
			indexOf(this.originalFRelExp==null? this: this.originalFRelExp);
	}
	
	syn int FClass.numInitialEquations() = initialEquations().size(); 
    syn lazy int FClass.numInitialScalarEquations() {
    	int res = 0;
    	for (FAbstractEquation e : initialEquations())
    		res += e.numScalarEquations();
    	return res;
    }
	syn lazy ArrayList<FAbstractEquation> FClass.initialEquations() {
		ArrayList<FAbstractEquation> l = new ArrayList<FAbstractEquation>();
		for (FAbstractEquation e : getFInitialEquations()) {
			l.add(e);
		}
		return l;
	}

	syn int FClass.numInitialGuessEquations() {
		int n_eq = 0;
		for (FRealVariable fv : realVariables()) {
			if (!(fv.fixedAttribute())) {
				n_eq++;
			}
		}
		return n_eq;
	}

	syn int FClass.numInitialEventIndicators() = numRelExpInInitialEquations();
    syn int FClass.numRelExpInInitialEquations() = 
    	relExpInInitialEquations().size();
	coll ArrayList<FRelExp> FClass.relExpInInitialEquations() 
	    [new ArrayList<FRelExp>()] with add root FlatRoot;
	FRelExp contributes
 		this when inInitialEquationSection() && originalFRelExp==null && generatesEvent()
	    to FClass.relExpInInitialEquations() for myFClass();	

	public int FRelExp.relExpInInitialEquationsIndex() {
		return myFClass().relExpInInitialEquations().
			indexOf(this.originalFRelExp==null? this: this.originalFRelExp);
	}
 
 	syn int FClass.numGuardExpInInitialEquations() = 
		guardExpInInitialEquations().size();

	coll ArrayList<FExp> FClass.guardExpInInitialEquations() 
	  [new ArrayList<FExp>()] with addAll root FlatRoot;
	FWhenEquation contributes
    // Only include relational in the equation section which are 
    // not inside a noEvent operator
 		guards() when getTest().inInitialEquationSection()
	to FClass.guardExpInInitialEquations() for myFClass();	
		
	public int FExp.guardExpInInitialEquationsIndex() {
		return myFClass().guardExpInInitialEquations().
			indexOf(this);
	}
 
 
/*	

	coll ArrayList<FVariable> FClass.structuralParameters() [new ArrayList<FVariable>()] with add root FlatRoot;
	FIdUseExp contributes
		(FVariable)myFV() when inArraySubscripts()
	to FClass.structuralParameters() for myFClass();

	coll ArrayList<FEquation> FVariable.variableIncidence() [new ArrayList<FEquation>()] with add root FlatRoot;
    FIdUseExp contributes
		myFEquation() when inFEquation()
	to FVariable.variableIncidence() for (FVariable)myFV();
	
	syn lazy ArrayList<ArrayList> FClass.variableIncidence() {
		ArrayList<ArrayList> l = new ArrayList<ArrayList>();
		for (FVariable fv : variables()) {
           l.add(fv.variableIncidence());
       } 
		return l;
	
	}
	
	*/
	
	inh Set<FVariable> FExp.boundParameters();
	eq FVariable.getBindingExp().boundParameters() = Collections.singleton(this);
	eq Root.getChild().boundParameters()           = Collections.emptySet();

	eq FEquation.getRight().boundParameters() {
		if (isParameterEquation()) {
			return getLeft().referencedParametersInFExp();
		} else {
			return Collections.emptySet();
		}
	}
		
	eq FFunctionCallEquation.getCall().boundParameters() { 
		if (isParameterEquation()) { 
			return referencedParametersInLHS(); 
		} else {
			return Collections.emptySet();
		}
	}
	
	inh boolean FExp.inFEquation();
	eq FAbstractEquation.getChild().inFEquation()=true;
	eq Root.getChild().inFEquation()=false;
	
	inh FAbstractEquation FExp.myFEquation();
	inh FAbstractEquation FStatement.myFEquation();
	eq FAbstractEquation.getChild().myFEquation() = this;
	eq Root.getChild().myFEquation()              = null;
	
	inh FClass FAbstractVariable.myFClass();
	inh FClass FExp.myFClass();
	inh FClass FIdUse.myFClass();
	inh FClass FQName.myFClass();
	inh FClass FFunctionDecl.myFClass();
	inh FClass FRecordDecl.myFClass();
	inh FClass FAlgorithm.myFClass();
	inh FClass FAbstractEquation.myFClass();	
	inh lazy FClass FExternalStmt.myFClass();
	eq FClass.getChild().myFClass() = this;
	eq Root.getChild().myFClass() = null; 

	syn lazy boolean FVariable.isIndependentConstant() = isConstant();
	syn lazy boolean FVariable.isDependentConstant() = false;
	
	syn lazy boolean FVariable.isDependentParameter() = 
		isParameter() && !isIndependentParameter();
	syn lazy boolean FVariable.isIndependentParameter() = isParameter() && 
		!hasParameterEquation() && (!hasBindingExp() || getBindingExp().isIndependentParameterExp());

	syn boolean FExp.isIndependentParameterExp() = isConstantExp() && !hasCompositeFunc();
	
	inh boolean FAbstractEquation.isParameterEquation();
	eq FClass.getFParameterEquation().isParameterEquation() = true;
	eq Root.getChild().isParameterEquation() = false;
	
	syn boolean FAbstractEquation.activeAtInitialization() = true;
	eq FWhenEquation.activeAtInitialization() {
		for (FExp g: guards()) {
			if (g.variability().parameterOrLess()) {
				// Set initial() to false and evaluate
				myFClass().setIsInitial(false);
				boolean before = g.ceval().booleanValue();
				// Set initial() to false and evaluate
				myFClass().setIsInitial(true);
				boolean after = g.ceval().booleanValue();
				// The when clause is considered to be active at initialization
				// if before is false and after is true.
				if (!before && after) {
					return true;
				}
			}
		}
		return false;
	}	

	syn boolean FAbstractEquation.replacedAtInitialization() = false;
	eq FWhenEquation.replacedAtInitialization() = true;
	
	syn List FAbstractEquation.getInitialEquationList() = new List();
	
	eq FWhenEquation.getInitialEquationList() {
		List<FAbstractEquation> l = new List<FAbstractEquation>();
		if (!activeAtInitialization()) {
			for (FAbstractEquation e : getFAbstractEquations()) {
				for (FIdUseExp id : e.simpleLefts()) {
					l.add(new FEquation((FIdUseExp)id.fullCopy(),
					   new FPreExp((FIdUseExp)id.fullCopy())));
				}
			}
		} else {
			for (FAbstractEquation e : getFAbstractEquations()) {
				l.add(e);
			}		
		}
		return l;
	}
	
    /**
     * \brief Check if tree contains a function call returning an array or a record.
     */
	syn boolean ASTNode.hasCompositeFunc() {
		for (ASTNode n : this)
			if (n.hasCompositeFunc())
				return true;
		return false;
	}
	eq InstFunctionCall.hasCompositeFunc() = 
		type().isArray() || type().isRecord() || super.hasCompositeFunc();
	eq FFunctionCall.hasCompositeFunc()    = 
		type().isArray() || type().isRecord() || super.hasCompositeFunc();
	
	syn boolean FVariable.hasParamValueExp() = hasBindingExp() || startAttributeSet();
	syn FExp FVariable.paramValueExp() = hasBindingExp() ? getBindingExp() : startAttributeExp();
	
	syn boolean FVariable.isVariable() = !isParameter() && !isConstant();
	
	syn boolean FAbstractVariable.isDifferentiatedVariable() = false;
	syn lazy boolean FVariable.isDifferentiatedVariable() = 
	  myFClass().differentiatedRealVariables().contains(this);
	  
	syn boolean FAbstractVariable.isDerivativeVariable() = false;
	eq FDerivativeVariable.isDerivativeVariable() = true;

	syn boolean FAbstractVariable.isDummyDerivativeVariable() = false;
	eq FDummyDerivativeVariable.isDummyDerivativeVariable() = true;

	syn boolean FAbstractVariable.isPreVariable() = false;
	eq FPreRealVariable.isPreVariable() = true;
	eq FPreIntegerVariable.isPreVariable() = true;
	eq FPreBooleanVariable.isPreVariable() = true;
	eq FPreStringVariable.isPreVariable() = true;
	eq FPreEnumVariable.isPreVariable() = true;
	
	syn boolean FAbstractVariable.isAlgebraicVariable() = false;
	syn lazy boolean FVariable.isAlgebraicVariable()    = myFClass().algebraicVariables().contains(this);

	syn boolean FAbstractVariable.isDiscreteVariable() = false;
	syn lazy boolean FVariable.isDiscreteVariable()    = myFClass().discreteVariables().contains(this);

	syn boolean FAbstractVariable.isAlgebraicContinousRealVariable() = false;
	syn lazy boolean FVariable.isAlgebraicContinousRealVariable()    =
			myFClass().algebraicContinousRealVariables().contains(this);

	inh FVariable FExp.inBindingExp();
	eq FVariable.getBindingExp().inBindingExp() = this;
	eq Root.getChild().inBindingExp() = null; 
	
	// TODO: check for uses and change to return set and use findReferencedFVariablesInTree()
	coll ArrayList<FVariable> FVariable.referencedFVariablesInBindingExp() 
	  [new ArrayList<FVariable>()] with add root FlatRoot;
	FIdUseExp contributes
		(FVariable)myFV() when !myFV().isUnknown() && myFV() instanceof FVariable
	to FVariable.referencedFVariablesInBindingExp() for inBindingExp();
	
	public static Set<FVariable> ASTNode.parametersInSet(Set<? extends FVariable> set) {
		Set<FVariable> res = new LinkedHashSet<FVariable>();
		for (FVariable fv : set)
			if (fv.isParameter())
				res.add(fv);
		return res;
	}
	
	syn Set<FVariable> FFunctionCallEquation.referencedParametersInLHS() =
		 parametersInSet(referencedFVariablesInLHS());
	
	syn Set<FVariable> FExp.referencedParametersInFExp() =
		parametersInSet(referencedFVariablesInFExp());
	
	syn Set<FVariable> FExp.referencedFVariablesInFExp() {
		Set<FVariable> res = new LinkedHashSet<FVariable>();
		findReferencedFVariablesInTree(res);
		return res;
	}
	
	syn lazy Set<FVariable> FFunctionCall.referencedFVariablesInFExp() = super.referencedFVariablesInFExp();
	
	public void ASTNode.findReferencedFVariablesInTree(Set<FVariable> set) {
		for (ASTNode n : this)
			n.findReferencedFVariablesInTree(set);
	}
	
	public void FIdUseExp.findReferencedFVariablesInTree(Set<FVariable> set) {
		if (myFV() instanceof FVariable)
			set.add((FVariable) myFV());
		super.findReferencedFVariablesInTree(set);
	}
	
	syn Set<FVariable> FAbstractEquation.referencedFVariablesInRHS() = Collections.emptySet();
	eq FEquation.referencedFVariablesInRHS()             = getRight().referencedFVariablesInFExp();
	eq FFunctionCallEquation.referencedFVariablesInRHS() = getCall().referencedFVariablesInFExp();
	eq FAlgorithm.referencedFVariablesInRHS() {
		Set<FVariable> res = new LinkedHashSet<FVariable>();
		for (FIdUse use : containedFIdUses()) 
			if (!use.useIsAssignment() && !use.myFV().isForIndex())
				res.add((FVariable) use.myFV());
		res.removeAll(referencedFVariablesInLHS());
		return res;
	}
	
	syn Set<FVariable> FAbstractEquation.referencedFVariablesInLHS() = Collections.emptySet();
	eq FEquation.referencedFVariablesInLHS()             = getLeft().referencedFVariablesInFExp();
	syn lazy Set<FVariable> FFunctionCallEquation.referencedFVariablesInLHS() {
		Set<FVariable> res = new LinkedHashSet<FVariable>();
		getLefts().findReferencedFVariablesInTree(res);
		return res;
	}
	eq FAlgorithm.referencedFVariablesInLHS() {
		Set<FVariable> res = new LinkedHashSet<FVariable>();
		for (FIdUse use : containedFIdUses()) 
			if (use.useIsAssignment() && !use.myFV().isForIndex())
				res.add((FVariable) use.myFV());
		return res;
	}
	
	syn Set<FVariable> FFunctionCallLeft.referencedFVariables() {
		Set<FVariable> res = new LinkedHashSet<FVariable>();
		findReferencedFVariablesInTree(res);
		return res;
	}
		
	syn lazy String FClass.guid() {
		try {
			PipedInputStream in = new PipedInputStream();
			PipedOutputStream out = new PipedOutputStream(in);
			
			MessageDigest md5 = MessageDigest.getInstance("MD5");
			new StreamGobbler(in).start();
			prettyPrint(new PrintStream(new DigestOutputStream(out, md5)), "");
			out.close();

			return new BigInteger(1,md5.digest()).toString(16);
			
		} catch (IOException e) {
			throw new RuntimeException(e);
		} catch (NoSuchAlgorithmException e) {
			throw new RuntimeException(e);
		}
	}
	
	private FAbstractEquation FAbstractEquation.meDifferentiated = null;
	private FAbstractEquation FAbstractEquation.meIntegrated = null;
	private FVariable FVariable.meDifferentiated = null;
	private FVariable FVariable.meIntegrated = null;

	public void FAbstractEquation.setMeDifferentiated(FAbstractEquation e) {
		this.meDifferentiated = e;
	}
	
	public FAbstractEquation FAbstractEquation.getMeDifferentiated() {
		return this.meDifferentiated;
	}

	public void FVariable.setMeDifferentiated(FVariable var) {
		this.meDifferentiated = var;
	}
	
	public FVariable FVariable.getMeDifferentiated() {
		return this.meDifferentiated;
	}

	public void FAbstractEquation.setMeIntegrated(FAbstractEquation e) {
		this.meIntegrated = e;
	}
	
	public FAbstractEquation FAbstractEquation.getMeIntegrated() {
		return this.meIntegrated;
	}

	public void FVariable.setMeIntegrated(FVariable var) {
		this.meIntegrated = var;
	}
	
	public FVariable FVariable.getMeIntegrated() {
		return this.meIntegrated;
	}
	
}

aspect FlatEnumerations {
	
	public ArrayList<FEnumLiteral> FEnumDecl.enumLiterals() {
		return getFEnumSpecification().enumLiterals();
	}

	public ArrayList<FEnumLiteral> FEnumSpecification.enumLiterals() {
		return new ArrayList<FEnumLiteral>();
	}

	public ArrayList<FEnumLiteral> FEnumLiteralList.enumLiterals() {
		ArrayList<FEnumLiteral> l = new ArrayList<FEnumLiteral>();
		for (FEnumLiteral el : getFEnumLiterals()) {
			l.add(el);
		}
		return l;
	}
	
	/**
	 * The number of enumeration literals defined in the enumeration this variable is of.
	 */
	syn int FEnumVariable.numEnumLiterals() = myFEnumDecl().numEnumLiterals();
	
	/**
	 * The number of enumeration literals defined in this enumeration.
	 */
	syn int FEnumDecl.numEnumLiterals() = getFEnumSpecification().numEnumLiterals();
	
	/**
	 * The number of enumeration literals defined in this enumeration.
	 */
	syn int FEnumSpecification.numEnumLiterals() = 0;
	eq FEnumLiteralList.numEnumLiterals() = getNumFEnumLiteral();
	
	syn FVariable FResidual.iterationVariable() {
		FVariable variable = (FVariable) getIterationVariable().myFV();
		if (variable.isAlias())
			return variable.alias();
		else
			return variable;
	}
	
}

aspect FlatCausality {

	syn boolean FTypePrefixInputOutput.inputCausality() = false;
	eq FInput.inputCausality() = true;	
	syn boolean FTypePrefixInputOutput.outputCausality() = false;
	eq FOutput.outputCausality() = true;	
	
	syn boolean FAbstractVariable.isInput() = false;
    eq FVariable.isInput() = 
      hasFTypePrefixInputOutput()? getFTypePrefixInputOutput().inputCausality(): false;    
    syn boolean FAbstractVariable.isOutput() = false;
    eq FVariable.isOutput() = 
      hasFTypePrefixInputOutput()? getFTypePrefixInputOutput().outputCausality(): false;
      
}

aspect FlatTypes {

	syn boolean FAbstractVariable.isReal()    			= type().isReal();
	syn boolean FAbstractVariable.isInteger() 			= type().isInteger();
	syn boolean FAbstractVariable.isBoolean() 			= type().isBoolean();
	syn boolean FAbstractVariable.isString()  			= type().isString();
	syn boolean FAbstractVariable.isRecord()  			= type().isRecord();
	syn boolean FAbstractVariable.isEnum()    			= type().isEnum();
	syn boolean FAbstractVariable.isExternalObject()	= type().isExternalObject();
	
	syn boolean FExp.isComposite()              = isArray() || type().isRecord();
	syn boolean FType.isComposite()             = isArray() || isRecord();
	syn boolean FAbstractVariable.isComposite() = isArray() || isRecord();
	syn boolean InstComponentDecl.isComposite() = isArray() || isRecord();
	
	inh boolean FAbstractVariable.inRecord();
	eq FRecordDecl.getChild().inRecord() = true;
	eq FClass.getChild().inRecord()      = false;
	eq FForIndex.getChild().inRecord()   = false;
	
	inh boolean InstComponentDecl.inRecord();
	eq InstNode.getInstComponentDecl().inRecord()               = false;
	eq InstForIndex.getInstPrimitive().inRecord()               = false;
	eq InstRecord.getInstComponentDecl().inRecord()             = true;
	eq InstArrayComponentDecl.getInstComponentDecl().inRecord() = inRecord();
	
	inh boolean InstComponentDecl.inRecordDecl();
	eq InstNode.getChild().inRecordDecl()                  = false;
	eq InstForIndex.getInstPrimitive().inRecordDecl()      = false;
	eq InstClassDecl.getInstComponentDecl().inRecordDecl() = isRecord();
	
	syn int FRecordDecl.indexOf(String name) {
		for (int i = 0; i < getNumFVariable(); i++)
			if (getFVariable(i).name().equals(name))
				return i;
		return -1;
	}
	
	inh FRecordDecl FAbstractVariable.containingRecordDecl();
	eq FRecordDecl.getChild().containingRecordDecl() = this;
	eq FlatRoot.getChild().containingRecordDecl()    = null;

}

/**
 * \brief Evaluation of attriubtes for primitive types.
 */
aspect Attributes {
	
	public static final String FAttribute.QUANTITY     = "quantity";
	public static final String FAttribute.UNIT         = "unit";
	public static final String FAttribute.DISPLAY_UNIT = "displayUnit";
	public static final String FAttribute.MIN          = "min";
	public static final String FAttribute.MAX          = "max";
	public static final String FAttribute.START        = "start";
	public static final String FAttribute.FIXED        = "fixed";
	public static final String FAttribute.NOMINAL      = "nominal";
	public static final String FAttribute.STATE_SELECT = "stateSelect";
	public static final String FAttribute.SIZE         = "size()";
	
	syn lazy FDerivedType FVariable.myFDerivedType() = findFDerivedType(getDerivedType());
	syn FDerivedType FEnumDecl.myFDerivedType()      = findFDerivedType(name());
	eq FRecordVariable.myFDerivedType()              = null;
	
	inh FDerivedType FVariable.findFDerivedType(String name);
	inh FDerivedType FEnumDecl.findFDerivedType(String name);
	eq FClass.getChild().findFDerivedType(String name) = findMatching(getFDerivedTypes(), name);
	eq Root.getChild().findFDerivedType(String name)   = null;
	
	eq FAttribute.matches(String str)   = getName().name().equals(str);
	eq FDerivedType.matches(String str) = getName().equals(str);
	
	syn lazy FAttribute FVariable.findAttribute(String name) {
		FAttribute res = findMatching(getFAttributes(), name);
		if (res == null && myFDerivedType() != null)
			res = myFDerivedType().findAttribute(name);
		return res;
	}
	syn FAttribute FAttribute.findAttribute(String name)   = findMatching(getFAttributes(), name);
	syn FAttribute FDerivedType.findAttribute(String name) = findMatching(getFAttributes(), name);
	syn boolean FVariable.attributeSet(FAttribute a)   = (a != null) && a.getAttributeSet();
	syn FExp    FVariable.attributeExp(FAttribute a)   = (a != null && a.hasValue()) ? a.getValue() : null;
	syn boolean FVariable.attributeSet(String name)    = attributeSet(findAttribute(name));
	syn FExp    FVariable.attributeExp(String name)    = attributeExp(findAttribute(name));
	syn String  FVariable.attributeString(String name) = attributeCValueString(name).stringValue();
	
	syn FAttribute FAbstractVariable.findHierarchicalAttribute(FQName name) = null;
	eq FVariable.findHierarchicalAttribute(FQName name) = name.findHierarchicalAttribute(getFQName(), this);
	
	syn FAttribute FQName.findHierarchicalAttribute(FQName prefix, FVariable var) = null;
	eq FQNameString.findHierarchicalAttribute(FQName prefix, FVariable var)       = var.findAttribute(getName());
	eq FQNameFull.findHierarchicalAttribute(FQName prefix, FVariable var) {
		int i = prefix.numMatchingParts(this);
		int n = getNumFQNamePart();
		if (i >= n)
			return null;
		FAttribute attr = var.findAttribute(getFQNamePart(i).getName());
		for (i++; i < n && attr != null; i++)
			attr = attr.findAttribute(getFQNamePart(i).getName());
		return attr;
	}
	
	syn CValue FVariable.attributeCValueString(String name) {
		FAttribute a = findAttribute(name);
		return (attributeSet(a) ? attributeExp(a).ceval() : new CValueString("")).expandArray(size());
	}
	syn CValue FVariable.attributeCValueBoolean(String name, boolean def) {
		FAttribute a = findAttribute(name);
		return (attributeSet(a) ? attributeExp(a).ceval() : new CValueBoolean(def)).expandArray(size());
	}
	syn CValue FVariable.attributeCValueReal(String name, double def) {
		FAttribute a = findAttribute(name);
		return (attributeSet(a) ? attributeExp(a).ceval() : new CValueReal(def)).expandArray(size());
	}
	syn CValue FVariable.attributeCValueInteger(String name, int def) {
		FAttribute a = findAttribute(name);
		return (attributeSet(a) ? attributeExp(a).ceval() : new CValueInteger(def)).expandArray(size());
	}
	syn CValue FVariable.attributeCValueEnum(String name, FType type, int def) {
		FAttribute a = findAttribute(name);
		return (attributeSet(a) ? attributeExp(a).ceval() : new CValueEnum(type, def)).expandArray(size());
	}

	// Quantity attribute
	syn boolean FVariable.quantityAttributeSet()    = attributeSet(FAttribute.QUANTITY);
	syn FExp    FVariable.quantityAttributeExp()    = attributeExp(FAttribute.QUANTITY);
	syn CValue  FVariable.quantityAttributeCValue() = attributeCValueString(FAttribute.QUANTITY);
	syn String  FVariable.quantityAttribute()       = quantityAttributeCValue().stringValue();

	// Unit attribute
	syn boolean FVariable.unitAttributeSet()    = attributeSet(FAttribute.UNIT);
	syn FExp    FVariable.unitAttributeExp()    = attributeExp(FAttribute.UNIT);
	syn CValue  FVariable.unitAttributeCValue() = attributeCValueString(FAttribute.UNIT);
	syn String  FVariable.unitAttribute()       = unitAttributeCValue().stringValue();

	// Display Unit attribute
	syn boolean FVariable.displayUnitAttributeSet()    = attributeSet(FAttribute.DISPLAY_UNIT);
	syn FExp    FVariable.displayUnitAttributeExp()    = attributeExp(FAttribute.DISPLAY_UNIT);
	syn CValue  FVariable.displayUnitAttributeCValue() = attributeCValueString(FAttribute.DISPLAY_UNIT);
	syn String  FVariable.displayUnitAttribute()       = displayUnitAttributeCValue().stringValue();

	// min attribute
	syn boolean FVariable.minAttributeSet()           = attributeSet(FAttribute.MIN);
	syn FExp    FVariable.minAttributeExp()           = attributeExp(FAttribute.MIN);
	syn CValue  FRealVariable.minAttributeCValue()    = attributeCValueReal(FAttribute.MIN, -1e20);
	syn CValue  FIntegerVariable.minAttributeCValue() = attributeCValueInteger(FAttribute.MIN, (int) -1e10);
	syn CValue  FEnumVariable.minAttributeCValue()    = attributeCValueEnum(FAttribute.MIN, type(), 1);
	syn double  FRealVariable.minAttribute()          = minAttributeCValue().realValue();
	syn int     FIntegerVariable.minAttribute()       = minAttributeCValue().intValue();
	syn int     FEnumVariable.minAttribute()          = minAttributeCValue().intValue();

	// max attribute
	syn boolean FVariable.maxAttributeSet()           = attributeSet(FAttribute.MAX);
	syn FExp    FVariable.maxAttributeExp()           = attributeExp(FAttribute.MAX);
	syn CValue  FRealVariable.maxAttributeCValue()    = attributeCValueReal(FAttribute.MAX, 1e20);
	syn CValue  FIntegerVariable.maxAttributeCValue() = attributeCValueInteger(FAttribute.MAX, (int) 1e10);
	syn CValue  FEnumVariable.maxAttributeCValue()    = attributeCValueEnum(FAttribute.MAX, type(), numEnumLiterals());
	syn double  FRealVariable.maxAttribute()          = maxAttributeCValue().realValue();
	syn int     FIntegerVariable.maxAttribute()       = maxAttributeCValue().intValue();
	syn int     FEnumVariable.maxAttribute()          = maxAttributeCValue().intValue();

	// start attribute
	syn boolean FVariable.useBindingExpAsStart()  = 
		(isIndependentParameter() && hasBindingExp()) || isIndependentConstant();
	
	syn boolean FVariable.startAttributeSet()     = attributeSet(FAttribute.START);
	syn FExp    FVariable.startAttributeExp()     = attributeExp(FAttribute.START);
	syn FExp    FVariable.createStartAttributeExp() {
		FExp e = startAttributeExp();
		return (e == null) ? startAttributeCValue().buildLiteral() : e.fullCopy();
	}
	
	syn CValue FVariable.startAttributeCValue()   = CValue.UNKNOWN;
	eq FRealVariable.startAttributeCValue()       = attributeCValueReal(FAttribute.START, 0.0);
	eq FDerivativeVariable.startAttributeCValue() = new CValueReal(0.0);
	eq FIntegerVariable.startAttributeCValue()    = attributeCValueInteger(FAttribute.START, 0);
	eq FBooleanVariable.startAttributeCValue()    = attributeCValueBoolean(FAttribute.START, false);
	eq FStringVariable.startAttributeCValue()     = attributeCValueString(FAttribute.START);
	eq FEnumVariable.startAttributeCValue()       = attributeCValueEnum(FAttribute.START, type(), 1);

	syn double  FRealVariable.startAttribute()    = startAttributeCValue().realValue();
	syn int     FIntegerVariable.startAttribute() = startAttributeCValue().intValue();
	syn boolean FBooleanVariable.startAttribute() = startAttributeCValue().booleanValue();
	syn String  FStringVariable.startAttribute()  = startAttributeCValue().stringValue();
	syn int     FEnumVariable.startAttribute()    = startAttributeCValue().intValue();

	// fixed attribute
	syn boolean FVariable.fixedAttributeSet()           = attributeSet(FAttribute.FIXED);
	syn FExp    FVariable.fixedAttributeExp()           = attributeExp(FAttribute.FIXED);
	syn CValue  FVariable.fixedAttributeCValue()        = attributeCValueBoolean(FAttribute.FIXED, isParameter() || isConstant());
	eq          FStringVariable.fixedAttributeCValue()  = CValue.UNKNOWN;
	syn boolean FVariable.fixedAttribute()              = fixedAttributeCValue().booleanValue();
		
	// Nominal attribute
	syn boolean FRealVariable.nominalAttributeSet()    = attributeSet(FAttribute.NOMINAL);
	syn FExp    FRealVariable.nominalAttributeExp()    = attributeExp(FAttribute.NOMINAL);
	syn CValue  FRealVariable.nominalAttributeCValue() = attributeCValueReal(FAttribute.NOMINAL, 1.0);
	syn double  FRealVariable.nominalAttribute()       = nominalAttributeCValue().realValue();

	syn boolean FDerivativeVariable.nominalAttributeSet()    = myDifferentiatedVariable().nominalAttributeSet();
	syn FExp    FDerivativeVariable.nominalAttributeExp()    = myDifferentiatedVariable().nominalAttributeExp();
	syn CValue  FDerivativeVariable.nominalAttributeCValue() = myDifferentiatedVariable().nominalAttributeCValue();
	
	// State Select attribute
	syn boolean     FRealVariable.stateSelectAttributeSet()    = attributeSet(FAttribute.STATE_SELECT);
	syn FExp        FRealVariable.stateSelectAttributeExp()    = attributeExp(FAttribute.STATE_SELECT);
	syn CValue      FRealVariable.stateSelectAttributeCValue() = attributeCValueEnum(FAttribute.STATE_SELECT, stateSelectType(), 3);
	syn int         FRealVariable.stateSelectAttributeInt()    = stateSelectAttributeCValue().intValue();
	syn StateSelect FRealVariable.stateSelectAttribute()       = StateSelect.values()[stateSelectAttributeInt() - 1];
	
	public class FRealVariable {
		public enum StateSelect {
			NEVER   (10L), 
			AVOID   (10000L), 
			DEFAULT (10000000L), 
			PREFER  (10000000000L), 
			ALWAYS  (10000000000000L);
			
			private long w;
			
			private StateSelect(long weight) {
				w = weight;
			}
			
			public long weight() {
				return w;
			}
		}
	}
	
	public static long FVariable.SS_UNMATCHED_WEIGHT = 10000000000000000L;
	
	syn long FVariable.stateSelectionWeight() = 0;
	eq FRealVariable.stateSelectionWeight() {
		FRealVariable frv = (FRealVariable) getMeIntegrated();
		StateSelect ss = (frv == null) ? StateSelect.DEFAULT : frv.stateSelectAttribute();
		return ss.weight();
	}
	
	public void FVariable.warnStartAttributeNotSet() {
		if (!startAttributeSet())
			warning("Iteration variable \"" + name() + "\" is missing start value!");
	}
	
	
	/**
	 * Check if this attribute is in an FVariable.
	 */
	inh boolean FAttribute.isInFV();
	eq FVariable.getChild().isInFV()    = true;
	eq FDerivedType.getChild().isInFV() = false;
	
	/**
	 * Check if this attribute is in a specific FVariable.
	 */
	inh boolean FAttribute.isInFV(FVariable fv);
	eq FVariable.getChild().isInFV(FVariable fv)    = fv == this;
	eq FDerivedType.getChild().isInFV(FVariable fv) = false;
	
	/**
	 * Check if this attribute is in an FDerivedType.
	 */
	inh boolean FAttribute.isInDerivedType();
	eq FVariable.getChild().isInDerivedType()    = false;
	eq FDerivedType.getChild().isInDerivedType() = true;
	
	/**
	 * Check if this attribute is in a specific FDerivedType.
	 */
	inh boolean FAttribute.isInDerivedType(FDerivedType t);
	eq FVariable.getChild().isInDerivedType(FDerivedType t)    = false;
	eq FDerivedType.getChild().isInDerivedType(FDerivedType t) = t == this;
	
}

aspect FVariableUses {
	
	/**
	 * \brief Collection attribute returning all variable uses in expressions.
	 */
	coll HashSet<FIdUseExp> FAbstractVariable.uses() [new LinkedHashSet<FIdUseExp>()] 
		with add root FlatRoot;
	
	FIdUseExp contributes this when !(getParent() instanceof FDerExp) to 
		FAbstractVariable.uses() for myFV();
	
	/**
	 * All uses of this variable that are not the left-hand side of an equation. 
	 * (Unless the variable has a binding expression, then this is the same as uses().)
	 */
	syn lazy Set<FIdUseExp> FAbstractVariable.nonDefiningUses() {
		Set<FIdUseExp> res = new HashSet<FIdUseExp>();
		for (FIdUseExp use : uses())
			if (hasBindingExp() || !use.isLeftHandSide())
				res.add(use);
		return res;
	}
	
	/**
	 * All uses of this variable that are the left-hand side of an equation. 
	 * (Unless the variable has a binding expression, then this is empty.)
	 */
	syn lazy Set<FIdUseExp> FAbstractVariable.definingUses() {
		if (hasBindingExp()) {
			return Collections.emptySet();
		} else {
			Set<FIdUseExp> res = new HashSet<FIdUseExp>();
			for (FIdUseExp use : uses())
				if (use.isLeftHandSide())
					res.add(use);
			return res;
		}
	}
	
	/**
	 * Check if this variable is used on the left hand side of a function call equation or statement.
	 */
	syn lazy boolean FAbstractVariable.usedAsFunctionCallLeft() {
		for (FExp e : nonDefiningUses()) 
			if (e.inFunctionCallLeft())
				return true;
		return false;
	}
	
	inh boolean FExp.inFunctionCallLeft();
	eq FFunctionCallLeft.getChild().inFunctionCallLeft() = true;
	eq FClass.getChild().inFunctionCallLeft()            = false;
	eq InstRoot.getChild().inFunctionCallLeft()          = false;
	
	/**
	 * Checks if this expression is used in a function call
	 */
	inh boolean FExp.inFunctionCall();
	eq FFunctionCall.getChild().inFunctionCall() = true;
	eq FClass.getChild().inFunctionCall()        = false;
	eq InstRoot.getChild().inFunctionCall()      = false;
	
	/**
	 * Returnes the function input that this expressions corresponds to.
	 * NOTICE, this method will throw exception if this exp does not reside in a function call.
	 */
	inh FFunctionVariable FExp.myCorrespondingInput();
	eq FFunctionCall.getArg(int i).myCorrespondingInput() = myFFunctionDecl().myInput(i);
	eq FClass.getChild().myCorrespondingInput() {
		throw new UnsupportedOperationException();
	}
	eq InstRoot.getChild().myCorrespondingInput() {
		throw new UnsupportedOperationException();
	}
	
	/**
	 * All uses of this variable that are the left-hand side of an assignment or 
	 * function call statement. 
	 */
	coll HashSet<FIdUse> FFunctionVariable.assigningUses() [new HashSet<FIdUse>()] 
		with add root FFunctionDecl;
	FIdUse contributes this when isAssignedTo() && myFuncVar() != null
		to FFunctionVariable.assigningUses() for myFuncVar();
//	syn lazy Set<FIdUse> FAbstractVariable.assigningUses() {
//		Set<FIdUseExp> res = new HashSet<FIdUseExp>();
//		for (FIdUseExp use : uses())
//			if (use.isAssignedTo())
//				res.add(use);
//		return res;
//	}
	
	/**
	 * Check if this is the left hand side of an equation.
	 */
	inh boolean FIdUseExp.isLeftHandSide();
	eq BaseNode.getChild().isLeftHandSide() = false;
	eq FEquation.getLeft().isLeftHandSide() = true;
	
	/**
	 * Check if this is the left hand side of an assignment or function call statement.
	 */
	inh boolean FIdUse.isAssignedTo();
	inh boolean FIdUseExp.isAssignedTo();
	inh boolean FFunctionCallLeft.isAssignedTo();
	eq BaseNode.getChild().isAssignedTo()         = false;
	eq FAssignStmt.getLeft().isAssignedTo()       = true;
	eq FFunctionCallStmt.getLeft().isAssignedTo() = true;
	eq FIdUseExp.getFIdUse().isAssignedTo()       = isAssignedTo();
	eq FFunctionCallLeft.getFExp().isAssignedTo() = isAssignedTo();

	/**
	 * \brief Collection attribute returning all dependent parameters which
	 * depends on the parameter.
	 */
	
	coll HashSet<FVariable> FAbstractVariable.dependentParameters() 
	  [new LinkedHashSet<FVariable>()] 
		with addAll root FlatRoot;
	
	FIdUseExp contributes boundParameters() 
		when !(getParent() instanceof FDerExp) && !myFV().isUnknown() && 
		     myFV().isParameter()
		to FAbstractVariable.dependentParameters() for myFV();
	
	syn lazy ArrayList<FRealVariable> FAbstractVariable.dependentRealParameters() =
        FClass.intersectFVColl(myFClass().reals(), dependentParameters());

	syn lazy ArrayList<FIntegerVariable> FAbstractVariable.dependentIntegerParameters() =
	    FClass.intersectFVColl(myFClass().integers(), dependentParameters());

	syn lazy ArrayList<FBooleanVariable> FAbstractVariable.dependentBooleanParameters() =
	    FClass.intersectFVColl(myFClass().booleans(), dependentParameters());

	syn lazy ArrayList<FStringVariable> FAbstractVariable.dependentStringParameters() =
	    FClass.intersectFVColl(myFClass().strings(), dependentParameters());

	/**
	 * \brief Collection attribute returning all input variables (FVariables)
	 * referenced in an equation.
	 */
	 
	coll LinkedHashSet<FVariable> FAbstractEquation.retrieveInputs() 
		[new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

	FIdUseExp contributes (FVariable)myFV() when !myFV().isUnknown() && 
		!(getParent() instanceof FDerExp) && !(getParent() instanceof FPreExp) && 
		myFV().isInput() to 
		FAbstractEquation.retrieveInputs() for myFEquation();

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.inputs() = 
	    retrieveInputs();
	
	eq FWhenEquation.inputs()  {
		LinkedHashSet<FVariable> s = new LinkedHashSet<FVariable>();
		s.addAll(retrieveInputs());
		for (FAbstractEquation e : getFAbstractEquations()) {
			s.addAll(e.inputs());
		}
		return s;
	}

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.realInputs() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().realInputs(),inputs()));

	
	/**
	 * \brief Collection attribute returning all algebraic variables (FVariables)
	 * referenced in an equation.
	 */
	coll LinkedHashSet<FVariable> FAbstractEquation.retrieveAlgebraicVariables() 
		[new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

	FIdUseExp contributes (FVariable) myFV() when isAlgebraicVariableAccess() to 
		FAbstractEquation.retrieveAlgebraicVariables() for myFEquation();
	FAssignStmt contributes (FVariable) getLeft().myFV() when getLeft().myFV().isAlgebraicVariable() to 
		FAbstractEquation.retrieveAlgebraicVariables() for myFEquation();

	syn boolean FIdUseExp.isAlgebraicVariableAccess() = inAlgebraicAccessLocation() && myFV().isAlgebraicVariable();

	inh boolean FIdUseExp.inAlgebraicAccessLocation();
	eq BaseNode.getChild().inAlgebraicAccessLocation()   = true;
	eq FDerExp.getChild().inAlgebraicAccessLocation()    = false;
	eq FPreExp.getChild().inAlgebraicAccessLocation()    = false;
	eq FResidual.getIterationVariable().inAlgebraicAccessLocation() = false;
	
	syn LinkedHashSet<FVariable> FAbstractEquation.algebraicVariables() = 
	    retrieveAlgebraicVariables();
	
	syn lazy LinkedHashSet<FVariable> FWhenEquation.algebraicVariables() {
		LinkedHashSet<FVariable> s = new LinkedHashSet<FVariable>();
		s.addAll(retrieveAlgebraicVariables());
		for (FAbstractEquation e : getFAbstractEquations()) {
			s.addAll(e.algebraicVariables());
		}
		return s;
	}

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.algebraicContinousRealVariables() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().algebraicContinousRealVariables(),algebraicVariables()));

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteRealVariables() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().discreteRealVariables(),algebraicVariables()));

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteIntegerVariables() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().discreteIntegerVariables(),algebraicVariables()));

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteBooleanVariables() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().discreteBooleanVariables(),algebraicVariables()));

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteStringVariables() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().discreteStringVariables(),algebraicVariables()));

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.discreteEnumVariables() = 
		new LinkedHashSet<FVariable>(FClass.intersectFVColl(myFClass().discreteStringVariables(),algebraicVariables()));



	/**
	 * \brief Collection attribute returning all derivative variables (FDerivativeVariables)
	 * referenced in an equation.
	 */
	coll LinkedHashSet<FDerivativeVariable> FAbstractEquation.derivativeVariables() 
		[new LinkedHashSet<FDerivativeVariable>()] with add root FAbstractEquation;

	FDerExp contributes (FDerivativeVariable)myFV() when !myFV().isUnknown() && 
		myFV().isDerivativeVariable() to 
		FAbstractEquation.derivativeVariables() for myFEquation();

	/**
	 * \brief Collection attribute returning all differentiated variables (FVariables)
	 * referenced in an equation.
	 */
	coll LinkedHashSet<FVariable> FAbstractEquation.differentiatedRealVariables() 
		[new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

	FIdUseExp contributes (FVariable)myFV() when !myFV().isUnknown() && 
	    !(getParent() instanceof FDerExp) && myFV().isDifferentiatedVariable() to 
		FAbstractEquation.differentiatedRealVariables() for myFEquation();

	/**
	 * \brief Collection attribute returning all discrete variables (FVariables)
	 * referenced in an equation.
	 */
	coll LinkedHashSet<FVariable> FAbstractEquation.discreteVariables() 
		[new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

	FIdUseExp contributes (FVariable)myFV() when !myFV().isUnknown() && 
	    !(getParent() instanceof FDerExp) && !(getParent() instanceof FPreExp) && 
	    myFV().isDiscreteVariable() to 
		FAbstractEquation.discreteVariables() for myFEquation();

	/**
	 * \brief Collection attribute returning all pre variables (FPreVariable)
	 * referenced in an equation.
	 */
	coll LinkedHashSet<FVariable> FAbstractEquation.discretePreVariables() 
		[new LinkedHashSet<FVariable>()] with add root FAbstractEquation;

	FPreExp contributes (FVariable)myFV() when !myFV().isUnknown() && 
		myFV().isPreVariable() to 
		FAbstractEquation.discretePreVariables() for myFEquation();

	syn lazy LinkedHashSet<FVariable> FAbstractEquation.variables() {
		LinkedHashSet<FVariable> l = new LinkedHashSet<FVariable>();
		l.addAll(differentiatedRealVariables());
		l.addAll(derivativeVariables());
		l.addAll(algebraicVariables());
		l.addAll(discreteVariables());
		return l;
	}

	/**
	 * \brief Get the differenetiated variabel (FVariable) corresponding to 
	 * a derivative variable (FDerivativeVariable)
	 */
	syn FRealVariable FDerivativeVariable.myDifferentiatedVariable() =
		(FRealVariable) lookupFV(getFQName());

	/**
	 * \brief Get the derivative variabel (FDerivativeVariable) corresponding to 
	 * a differentiated variable (FVariable)
	 */
	syn FDerivativeVariable FVariable.myDerivativeVariable() =
		(FDerivativeVariable) lookupDerFV(getFQName());
	
	/**
	 * Get the pre variable connected to a normal variable, if any.
	 */
	syn FAbstractVariable FAbstractVariable.myPreVariable() = lookupPreFV(getFQName());
	
	/**
	 * Get the normal variable connected to a pre variable.
	 * 
	 * Will be unknown for non-pre variables.
	 */
	syn FAbstractVariable FAbstractVariable.myNonPreVariable() = unknownFVariable();
	eq FPreBooleanVariable.myNonPreVariable() = lookupFV(getFQName());
	eq FPreIntegerVariable.myNonPreVariable() = lookupFV(getFQName());
	eq FPreRealVariable.myNonPreVariable()    = lookupFV(getFQName());
	eq FPreStringVariable.myNonPreVariable()  = lookupFV(getFQName());
	
}

aspect LinearFVariables {
	
	/**
	 * \brief Check linearity of variable.
	 * 
	 * The attribute isLinear returns true if all uses of the variable appears
	 * linearly in equations and in initial equations. Parameters and constants
	 * are assumed to be literals in the linearity computation. Accordingly,
	 * multiplication of a variable with a parameter or constant does not render
	 * the variable nonlinear. Also, parameters and constants are considered
	 * to be linear themselves.
	 */
	syn lazy boolean FVariable.isLinear() {
		if (isParameter() || isConstant()) {
			return true;
		}
		for (FIdUseExp e : uses()) {
			if (!e.isLinear()) {
				return false;
			}
		}
		return true;
	}
	
	/**
	 * \brief Check if a subexpression appears linearly.
	 * 
	 * Note that this method does not check if the expression itself is linear
	 * but wheather it apperas linearly in a composite expression. For example
	 * the sub expression 'sin(x)' appears linearly in '1+sin(x)'.
	 */
	inh boolean FExp.isLinear();
	eq FlatRoot.getChild().isLinear() = true;
	eq SourceRoot.getChild().isLinear() = true;
	
	eq FAbstractEquation.getChild().isLinear() = true;
	
	eq FMulExp.getLeft().isLinear() =
		(getRight().isConstantExp() || getRight().isLinearParameterExp())?
				isLinear() : false;
	eq FMulExp.getRight().isLinear() =
		(getLeft().isConstantExp() || getLeft().isLinearParameterExp())?
				isLinear() : false;
	eq FDivExp.getLeft().isLinear() =
		(getRight().isConstantExp() || getRight().isLinearParameterExp())?
				isLinear() : false;			
	eq FDivExp.getRight().isLinear() = false;		
    eq FPowExp.getChild().isLinear() = false;
    eq FFunctionCall.getChild().isLinear() = false;
    eq FMathematicalFunctionCall.getChild().isLinear() = false;
				
	// This definition is to avoid errors when isParameterExp is redefined
	// to include free parameters in the Optimica extension.
	syn boolean FExp.isLinearParameterExp() = isParameterExp();
    
    coll Set<FIdUseExp> FAbstractEquation.collectUses() 
		[new LinkedHashSet<FIdUseExp>()] with add root FAbstractEquation;

	FIdUseExp contributes this when !myFV().isUnknown() && 
		!(getParent() instanceof FDerExp) && !(getParent() instanceof FPreExp) to 
		FAbstractEquation.collectUses() for myFEquation();
    
    syn Set<FIdUseExp> FAbstractEquation.collectUses(Set<FVariable> vars) {
    	HashSet<FIdUseExp> set = new HashSet<FIdUseExp>();
    	for (FIdUseExp e : collectUses()) {
    		if (vars.contains(e.myFV())) {
    			set.add(e);			
    		}
    	}
    	return set;
    }
    
    syn boolean FAbstractEquation.checkLinearity(Set<FVariable> vars) {
    	for (FIdUseExp e : collectUses(vars)) {
    		if (!e.isLinear(vars)) {
    			return false;
    		}
    	}
    	return true;
    }
    eq FAlgorithm.checkLinearity(Set<FVariable> vars) = false;
    
    inh boolean FExp.isLinear(Set<FVariable> vars);
	eq FlatRoot.getChild().isLinear(Set<FVariable> vars)   = true;
	eq SourceRoot.getChild().isLinear(Set<FVariable> vars) = true;
	
	eq FAbstractEquation.getChild().isLinear(Set<FVariable> vars) = true;
	eq FStatement.getChild().isLinear(Set<FVariable> vars)        = false;
	
	eq FMulExp.getLeft().isLinear(Set<FVariable> vars)  = getRight().isIndependent(vars) && isLinear(vars);
	eq FMulExp.getRight().isLinear(Set<FVariable> vars) = getLeft().isIndependent(vars) && isLinear(vars);
	eq FDivExp.getLeft().isLinear(Set<FVariable> vars)  = getRight().isIndependent(vars) && isLinear(vars);			
	eq FDivExp.getRight().isLinear(Set<FVariable> vars) = false;
    eq FPowExp.getChild().isLinear(Set<FVariable> vars) = false;
    eq FFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FMathematicalFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FAbstractFunctionCall.getChild().isLinear(Set<FVariable> vars) = false;
    eq FIfExp.getIfExp().isLinear(Set<FVariable> vars) = true;
    
	syn boolean FExp.isIndependent(Set<FVariable> set) {
		for (FExp e : childFExps()) {
    		if (!e.isIndependent(set)) {
    			return false;
    		}
    	}
    	return true;
	}

	syn boolean FIfExp.isIndependent(Set<FVariable> set) {
		// Don't check the guard exp since it is discrete and does not affect
		// linearity.
		return getThenExp().isIndependent(set) && getElseExp().isIndependent(set);
	}

	eq FIdUseExp.isIndependent(Set<FVariable> set) {
		return !set.contains(myFV());	
	}
}

aspect FlatDiagnostics {

	syn String FClass.diagnostics() {
		StringBuilder str = new StringBuilder();
		str.append("Diagnostics for flattened class " + name() + "\n");

		str.append(modelDiagnostics());
		
		str.append("\n");
		
		str.append(variableDiagnostics());
		
		str.append("\n");  

		str.append(aliasDiagnostics());
		
		str.append("\n");  
		
		str.append(incidence());

		str.append("\n");  
		
		str.append(dependencyDiagonstics());

    	str.append("\n");
		
//		str.append(dersAndDiffs());
		
		str.append("\n");  
		
		str.append(getConnectionSetManager().printConnectionSets());
		
		return str.toString();
	}

	public String FClass.modelDiagnostics() {
		StringBuilder str = new StringBuilder();
		str.append("Number of independent constants:              " + 
				numIndependentConstants() + "\n");
		str.append("  Number of Real independent constants:       " + 
				numIndependentRealConstants() + "\n");
		str.append("  Number of Integer independent constants:    " + 
				numIndependentIntegerConstants() + "\n");
		str.append("  Number of Enum independent constants:       " + 
				numIndependentEnumConstants() + "\n");
		str.append("  Number of Boolean independent constants:    " + 
				numIndependentBooleanConstants() + "\n");
		str.append("  Number of String independent constants:     " + 
				numIndependentStringConstants() + "\n");

		str.append("Number of dependent constants:                " + 
				numDependentConstants() + "\n");
		str.append("  Number of Real dependent constants:         " + 
				numDependentRealConstants() + "\n");
		str.append("  Number of Integer dependent constants:      " + 
				numDependentIntegerConstants() + "\n");
		str.append("  Number of Enum dependent constants:         " + 
				numDependentEnumConstants() + "\n");
		str.append("  Number of Boolean dependent constants:      " + 
				numDependentBooleanConstants() + "\n");
		str.append("  Number of String dependent constants:       " + 
				numDependentStringConstants() + "\n");

		str.append("Number of independent parameters:             " + 
				numIndependentParameters() + "\n");
		str.append("  Number of Real independent parameters:      " + 
				numIndependentRealParameters() + "\n");
		str.append("  Number of Integer independent parameters:   " + 
				numIndependentIntegerParameters() + "\n");
		str.append("  Number of Enum independent parameters:      " + 
				numIndependentEnumParameters() + "\n");
		str.append("  Number of Boolean independent parameters:   " + 
				numIndependentBooleanParameters() + "\n");
		str.append("  Number of String independent parameters:    " + 
				numIndependentStringParameters() + "\n");
		  		  
		str.append("Number of dependent parameters:               " + 
				numDependentParameters() + "\n");
		str.append("  Number of Real dependent parameters:        " + 
				numDependentRealParameters() + "\n");
		str.append("  Number of Integer dependent parameters:     " + 
				numDependentIntegerParameters() + "\n");
		str.append("  Number of Enum dependent parameters:        " + 
				numDependentEnumParameters() + "\n");
		str.append("  Number of Boolean dependent parameters:     " + 
				numDependentBooleanParameters() + "\n");
		str.append("  Number of String dependent parameters:      " + 
				numDependentStringParameters() + "\n");
		
		str.append("Number of variables :                         " + 
				numVariables() + "\n");
		str.append("  Number of Real variables:                   " + 
				numRealVariables() + "\n");
		str.append("  Number of Integer variables:                " + 
				numIntegerVariables() + "\n");
		str.append("  Number of Enum variables:                   " + 
				numEnumVariables() + "\n");
		str.append("  Number of Boolean variables:                " + 
				numBooleanVariables() + "\n");
		str.append("  Number of String variables:                 " + 
				numStringVariables() + "\n");

		str.append("Number of Real differentiated variables:      " + 
				numDifferentiatedRealVariables() + "\n"); 
		str.append("Number of Real derivative variables:          " + 
				numDerivativeVariables() + "\n"); 
		str.append("Number of Real continous algebraic variables: " + 
				numAlgebraicContinousRealVariables() + "\n");

		str.append("Number of inputs:                             " + 
				numInputs() + "\n");
		str.append("  Number of Real inputs:                      " + 
				numRealInputs() + "\n");
		str.append("  Number of Integer inputs:                   " + 
				numIntegerInputs() + "\n");
		str.append("  Number of Enum inputs:                      " + 
				numEnumInputs() + "\n");
		str.append("  Number of Boolean inputs:                   " + 
				numBooleanInputs() + "\n");
		str.append("  Number of String inputs:                    " + 
				numStringInputs() + "\n");
				
		str.append("Number of discrete variables :                " + 
				numDiscreteVariables() + "\n");
		str.append("  Number of Real discrete variables:          " + 
				numDiscreteRealVariables() + "\n");
		str.append("  Number of Integer discrete variables:       " + 
				numDiscreteIntegerVariables() + "\n");
		str.append("  Number of Enum discrete variables:          " + 
				numDiscreteEnumVariables() + "\n");
		str.append("  Number of Boolean discrete variables:       " + 
				numDiscreteBooleanVariables() + "\n");
		str.append("  Number of String discrete variables:        " + 
				numDiscreteStringVariables() + "\n");
		
		str.append("Number of equations:                          " + 
				numEquations() + "\n");
		
		str.append("Number of variables with binding expression:  " + 
				numVariablesWithBindingExp() + "\n");
		str.append("  Number of Real variables with binding exp:  " + 
				numRealVariablesWithBindingExp() + "\n");
		str.append("  Number of Integer variables binding exp:    " + 
				numIntegerVariablesWithBindingExp() + "\n");
		str.append("  Number of Enum variables binding exp:       " + 
				numEnumVariablesWithBindingExp() + "\n");
		str.append("  Number of Boolean variables binding exp:    " + 
				numBooleanVariablesWithBindingExp() + "\n");
		str.append("  Number of String variables binding exp:     " + 
				numStringVariablesWithBindingExp() + "\n");
			
		str.append("Total number of equations:                    " + 
				(numEquations()+numVariablesWithBindingExp()) + "\n");
	
		str.append("Number of initial equations:                  " + 
				numInitialEquations() + "\n");

		str.append("Number of event indicators in equations:      " + 
				numRelExpInEquations() + "\n");

		str.append("Number of event indicators in init equations: " + 
				numRelExpInInitialEquations() + "\n");


		return str.toString();
	}

	public String FClass.aliasDiagnostics() {
		StringBuilder str = new StringBuilder();
		str.append("Alias sets:\n");
		if (getAliasManager()!=null) {
			str.append(getAliasManager().printAliasSets());
			int n_elim = 0;
			for (AliasManager.AliasSet aliasSet : getAliasManager().getAliasSets()) {
				n_elim += aliasSet.numAliases() - 1;
			}
			str.append(n_elim + " variables can be eliminated\n");
				
		} else {
			str.append("  Alias sets not computed.\n");
		}
		return str.toString();	
		
	}

	public String FClass.aliasDiagnosticsShort() {
		StringBuilder str = new StringBuilder();
		if (getAliasManager()!=null) {
			int n_elim = 0;
			Set<AliasManager.AliasSet> aliasSets = getAliasManager().getAliasSets();
			for (AliasManager.AliasSet aliasSet : aliasSets) {
				n_elim += aliasSet.numAliases() - 1;
			}
			str.append(aliasSets.size());
			str.append(" sets, ");
			str.append(n_elim);
			str.append(" eliminated variables");
		} else {
			str.append("Alias sets not computed");
		}
		return str.toString();	
		
	}

	public String FClass.variableDiagnostics() {
		
		StringBuilder str = new StringBuilder();
		
		str.append("Independent constants: \n");
		for (FVariable fv : independentConstants()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
				str.append("\n");
		}
		str.append("\n");
		
		str.append("Dependent constants: \n");
		for (FVariable fv : dependentConstants()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
				str.append("\n");
		}
		str.append("\n");
		
		str.append("Independent parameters: \n");
		for (FVariable fv : independentParameters()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
			if (fv.hasBindingExp()) {
				str.append(", evaluated binding exp: ");
				str.append(fv.getBindingExp().ceval());
			}
			str.append("\n");
		}
		str.append("\n");
		
		str.append("Dependent parameters: \n");
		for (FVariable fv : dependentParameters()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
				str.append("\n");
		}

		str.append("\n");  
		str.append("Differentiated variables: \n");
		for (FVariable fv : differentiatedRealVariables()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
			str.append("\n");
		}

		str.append("\n");  
		str.append("Derivative variables: \n");
		for (FVariable fv : derivativeVariables()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
				str.append("\n");
		}
		str.append("\n");  

		str.append("Discrete variables: \n");
		for (FVariable fv : discreteVariables()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
			str.append(", alias: ");
			if (!fv.isAlias()) {
				str.append("no");
			} else {
				if (fv.isNegated()) {
					str.append("-");
				}
				str.append(fv.alias().valueReference());
			}
			str.append("\n");
		}
		str.append("\n");
		
		str.append("Algebraic real variables: \n");
		for (FVariable fv : algebraicContinousRealVariables()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
			str.append(", alias: ");
			if (!fv.isAlias()) {
				str.append("no");
			} else {
				if (fv.isNegated()) {
					str.append("-");
				}
				str.append(fv.alias().valueReference());
			}
			str.append("\n");
		}
		str.append("\n");
		
		str.append("Input variables: \n");
		for (FVariable fv : inputs()) {
			str.append(" " + fv.name());
			str.append(": number of uses: " + fv.uses().size() + ", isLinear: " 
					+ fv.isLinear());
				str.append("\n");
		}

		return str.toString();
		
	}

	public String FClass.dependencyDiagonstics() {
		
		StringBuilder str = new StringBuilder();
			
		if (root().options.getBooleanOption("equation_sorting")) {
			
			str.append("Variable dependencies:\n");
			
			str.append("Derivative variables: \n");
			for (FVariable fv : derivativeVariables()) {
				str.append(" " + fv.name() + "\n");
				for (FVariable d : fv.dependsOn()) {
					str.append("    " + d.name() + "\n");
				}
			}
			str.append("\n");
			str.append("Differentiated variables: \n");
			for (FVariable fv : differentiatedRealVariables()) {
				str.append(" " + fv.name() + "\n");
				for (FVariable d : fv.dependsOn()) {
					str.append("    " + d.name() + "\n");
				}
			}
			str.append("\n");
			str.append("Algebraic real variables: \n");
			for (FVariable fv : algebraicContinousRealVariables()) {
				str.append(" " + fv.name() + "\n");
				for (FVariable d : fv.dependsOn()) {
					str.append("    " + d.name() + "\n");
				}
			}
			str.append("\n");
		}
		return str.toString();
	}

	public String FClass.incidence() {
		StringBuilder str = new StringBuilder();
		
		LinkedHashSet<FVariable> h;
		LinkedHashSet<FDerivativeVariable> dh;
		
		str.append("Incidence:\n");
		
		int i = 0;
		for (FAbstractEquation fe : equations()) {
			str.append(" eq " + i + ": ");
			dh = fe.derivativeVariables();
			for (FVariable fv : dh) {
				str.append(fv.name() + " ");
			}
			h = fe.algebraicVariables();
			for (FVariable fv : h) {
				str.append(fv.name() + " ");
			}
			str.append("\n");
//			str.append(fe.getClass().getName() + " " + fe.prettyPrint(""));
//			str.append("\n");
			i++;
		}
		
		return str.toString();
		
	}
	
	public String FClass.dersAndDiffs() {
		StringBuilder str = new StringBuilder();
		str.append("Derivatives and differentiated variables:\n");
		for (FDerivativeVariable fdv : derivativeVariables()) {
			if (fdv.myDifferentiatedVariable()!=null) {
				str.append(" " + fdv.name() + ", " + fdv.myDifferentiatedVariable().name() + "\n");
			}
		}	
		str.append("Differentiated variables and derivatives:\n");
		for (FVariable fv : differentiatedRealVariables()) {
			if (fv.myDerivativeVariable()!=null) {
				str.append(" " + fv.name() + ", " + fv.myDerivativeVariable().name() + "\n");
			}
		}
		return str.toString();
		
	}
	
	public String FClass.printDAEBLT() {
		return getDAEBLT().toString();
	}

	public String FClass.printDAEInitBLT() {
		return getDAEInitBLT().toString();
	}


	syn String FClass.attributeLevels() {
		StringBuilder str = new StringBuilder();
		str.append("Variables:\n");
		for (FVariable v : getFVariables())
			v.attributeLevels(str);
		for (FVariable v : getAliasVariables())
			v.attributeLevels(str);
		if (getNumFDerivedType() > 0) {
			str.append("\nTypes:\n");
			for (FDerivedType t : getFDerivedTypes())
				t.attributeLevels(str);
		}
		return str.toString();
	}

	public void FVariable.attributeLevels(StringBuilder str) {
		str.append("  ");
		str.append(name());
		attributeLevelsForList(getFAttributes(), str);
		str.append("\n");
	}

	public void FDerivedType.attributeLevels(StringBuilder str) {
		str.append("  ");
		str.append(getName());
		attributeLevelsForList(getFAttributes(), str);
		str.append("\n");
	}

	public void FAttribute.attributeLevels(StringBuilder str) {
		str.append(name());
		str.append(":");
		str.append(getLevel());
		attributeLevelsForList(getFAttributes(), str);
		if (hasValue()) {
			str.append("=");
			str.append(getValue());
		}
	}

	public static void ASTNode.attributeLevelsForList(List<FAttribute> l, StringBuilder str) {
		if (l.getNumChild() > 0) {
			str.append("(");
			String sep = ", ";
			String pref = "";
			for (FAttribute a : l) {
				str.append(pref);
				a.attributeLevels(str);
				pref = sep;
			}
			str.append(")");
		}
	}

}

aspect FlatAlgorithmAPI {
	
	syn boolean FIdUse.inFAlgorithm() = myFAlgorithm() != null;
	
	inh lazy FAlgorithm FIdUse.myFAlgorithm();
	eq FAlgorithm.getChild().myFAlgorithm() = this;
	eq Root.getChild().myFAlgorithm() = null;
	
	coll ArrayList<FAlgorithm> FClass.myAlgorithms()
	    [new ArrayList<FAlgorithm>()] with add root FClass;
	FAlgorithm contributes this when !inFunction()
	    to FClass.myAlgorithms() for myFClass();

	coll ArrayList<FIdUse> FAlgorithm.containedFIdUses() 
    	[new ArrayList<FIdUse>()] with add root FAlgorithm;
	FIdUse contributes this to FAlgorithm.containedFIdUses() for myFAlgorithm();
	
	syn lazy ArrayList<FIdUse> FAlgorithm.assignedFIdUses() {
		ArrayList<FIdUse> res = new ArrayList<FIdUse>();
		for (FIdUse use : containedFIdUses())
			if (use.useIsAssignment())
				res.add(use);
		return res;
	}
	
	syn lazy ArrayList<FIdUse> FAlgorithm.usedFIdUses() {
		ArrayList<FIdUse> res = new ArrayList<FIdUse>();
		for (FIdUse use : containedFIdUses())
			if (!use.useIsAssignment())
				res.add(use);
		return res;
	}
	
	inh boolean FIdUse.useIsAssignment();
	inh boolean FIdUseExp.useIsAssignment();
	eq FAssignStmt.getLeft().useIsAssignment()       = true;
	eq FFunctionCallLeft.getFExp().useIsAssignment() = true;
	eq FIdUseExp.getFIdUse().useIsAssignment()       = useIsAssignment();
	eq FExp.getChild().useIsAssignment()             = false;
	eq FStatement.getChild().useIsAssignment()       = false;
	eq FAlgorithm.getChild().useIsAssignment()       = false;
	eq Root.getChild().useIsAssignment()             = false;
	
	private String FAlgorithm.functionName = null;
	public String FAlgorithm.generateFunctionName() {
		if (functionName == null)
			functionName = myFClass().generateFunctionName();
		return functionName;
	}
	private int FClass.generatedFunctionNumber = 1;
	public String FClass.generateFunctionName() {
		String name, part;
		do {
			part = "algorithm_" + generatedFunctionNumber;
			name = name() + "." + part;
			generatedFunctionNumber++;
		} while (lookupFunc(name) != null || variablesMap().lookup(part) != null);
		return name;
	}
	
}

aspect FlatExternalFunctionAPI {
	
	/**
	 * \brief Gives the arguments to pass to gcc required by external functions.
	 */
	syn String FClass.externalCompilerArgs() {
		StringBuilder buf = new StringBuilder();
		for (String lib : externalLibraries()) {
			buf.append(" -l");
			buf.append(lib);
		}
		for (String dir : externalLibraryDirectories()) {
			buf.append(" -L");
			buf.append(dir);
		}
		for (String dir : externalIncludeDirectories()) {
			buf.append(" -I");
			buf.append(dir);
		}
		return buf.toString();
	}

	syn String FClass.externalLibArgs() {
		StringBuilder buf = new StringBuilder();
		for (String lib : externalLibraries()) {
			buf.append(" -l");
			buf.append(lib);
		}
		for (String dir : externalLibraryDirectories()) {
			buf.append(" -L");
			buf.append(dir);
		}
		return buf.toString();
	}

	syn String FClass.externalIncludeArgs() {
		StringBuilder buf = new StringBuilder();
		for (String dir : externalIncludeDirectories()) {
			buf.append(" -I");
			buf.append(dir);
		}
		return buf.toString();
	}
	
	coll HashSet<String> FClass.externalLibraries() 
	  [new HashSet<String>()] with addAll root FClass;
	FExternalStmt contributes library() when library() != null 
	  to FClass.externalLibraries() for myFClass();
	
	coll HashSet<String> FClass.externalIncludes() 
	  [new HashSet<String>()] with add root FClass;
	FExternalStmt contributes include() when include() != null 
	  to FClass.externalIncludes() for myFClass();
	
	coll HashSet<String> FClass.externalLibraryDirectories() 
	  [new HashSet<String>()] with add root FClass;
	FExternalStmt contributes libraryDirectory() when libraryDirectory() != null 
	  to FClass.externalLibraryDirectories() for myFClass();
	
	coll HashSet<String> FClass.externalIncludeDirectories() 
	  [new HashSet<String>()] with add root FClass;
	FExternalStmt contributes includeDirectory() when includeDirectory() != null 
	  to FClass.externalIncludeDirectories() for myFClass();
	
	syn ArrayList<String> FExternalStmt.library() = library;
	syn String FExternalStmt.include()            = include;
	syn String FExternalStmt.libraryDirectory()   = libraryDir;
	syn String FExternalStmt.includeDirectory()   = includeDir;

	private ArrayList<String> FExternalStmt.library;
	private String FExternalStmt.include;
	private String FExternalStmt.libraryDir;
	private String FExternalStmt.includeDir;
	
	public void FExternalStmt.extractLibrary(InstExternal n) {
		library = n.annotation("Library").asStringList();
		include = n.annotation("Include").string();
		libraryDir = n.annotation("LibraryDirectory").string();
		includeDir = n.annotation("IncludeDirectory").string();
		
		if (libraryDir == null || includeDir == null) {
			String libraryName = n.libraryName();
			if (libraryName != null) {
				String defDir = "modelica://" + libraryName + "/Resources";
				libraryDir = (libraryDir == null && library != null) ? 
						defDir + "/Library" : libraryDir;
				includeDir = (includeDir == null && include != null) ? 
						defDir + "/Include" : includeDir;
			}
		}
		
		if (includeDir != null) 
			includeDir = n.uri2path(includeDir);
		if (libraryDir != null) {
			libraryDir = n.uri2path(libraryDir);
		}
	}
	
	/**
	 * \brief Converts an URI to a file-system path.
	 * 
	 * Only modelica:// and file:// URIs are supported.
	 * 
	 * @param str  the string to interpret as an URI
	 */
	public String InstExternal.uri2path(String str) {
		try {
			URI uri = new URI(str);
			if (uri.getScheme().equals("file")) {
				return uri.getPath();
			} else if (uri.getScheme().equals("modelica")) {
				String pack = new File(packagePath(uri.getAuthority())).getAbsolutePath();
				return pack != null ? pack + uri.getPath() : null;
			}
		} catch (URISyntaxException e) {
		}
		return null;
	}
	
}

aspect Sparsity {

	// There are no free parameters in the Modelica compiler
	// but these attributes are refined in the Optimica compiler
	syn lazy int FClass.freeParametersEquationSparsity_n_nz() {
		return 0;
	}
	
	syn lazy ArrayList<Integer>[] FClass.freeParametersEquationSparsity() {
		ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numFreeParameters()];
		
		for (int i=0; i<numFreeParameters(); i++) {
			sp[i] = new ArrayList<Integer>();
		}
				
		return sp;
		
	}

	public void FAbstractEquation.calculateEquationSparsity(
			ArrayList<Integer>[] sp, int i, Set<? extends FVariable> vars, int offset) {
		for (int j = 0; j < numScalarEquations(); j++) {
			for (FVariable fv : vars) {
				sp[fv.indexInZ() - offset].add(new Integer(i)); 
			}
			i++;
		}
	}

	public void FFunctionCallEquation.calculateEquationSparsity(
			ArrayList<Integer>[] sp, int i, Set<? extends FVariable> vars, int offset) {
		Set<FVariable> rv = FClass.intersectFVColl(referencedFVariablesInRHS(), vars);
//		Set<FVariable> lv = FClass.intersectFVColl(referencedFVariablesInLHS(), vars);
		Set<FVariable> lv = referencedFVariablesInLHS();
		
		for (FVariable fv : lv) {
//			sp[fv.indexInZ() - offset].add(new Integer(i)); 
			if (vars.contains(fv))
				sp[fv.indexInZ() - offset].add(new Integer(i)); 
			for (FVariable ffv : rv) {
				if (ffv != fv) {
					sp[ffv.indexInZ() - offset].add(new Integer(i)); 
				}
			}
			i++;	 
		}
	}

	syn lazy int FClass.derivativeVariablesEquationSparsity_n_nz() {
		int n_nz = 0;
		ArrayList<Integer>[] sp = derivativeVariablesEquationSparsity();
		for (int j=0; j<numDerivativeVariables(); j++) {
			n_nz += sp[j].size();
		}
		return n_nz;		
	}

	syn lazy ArrayList<Integer>[] FClass.derivativeVariablesEquationSparsity() {
		
		ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numDerivativeVariables()];
		
		for (int i=0; i<numDerivativeVariables(); i++) {
			sp[i] = new ArrayList<Integer>();
		}
		
		int i = 0;
		for (FAbstractEquation fe : equations()) {
			fe.derivativeVariablesEquationSparsity(sp,i);
			i += fe.numScalarEquations();
		}
		return sp;		
	}

	public void FAbstractEquation.derivativeVariablesEquationSparsity(ArrayList<Integer>[] sp, int i) {
		calculateEquationSparsity(sp, i, derivativeVariables(), myFClass().derivativeVariablesOffset());
	}

	syn lazy int FClass.differentiatedRealVariablesEquationSparsity_n_nz() {
		int n_nz = 0;
		ArrayList<Integer>[] sp = differentiatedRealVariablesEquationSparsity();
		for (int j=0; j<numDifferentiatedRealVariables(); j++) {
			n_nz += sp[j].size();
		}
		return n_nz;		
	}

	syn lazy ArrayList<Integer>[] FClass.differentiatedRealVariablesEquationSparsity() {
		
		ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numDifferentiatedRealVariables()];
		
		for (int i=0; i<numDifferentiatedRealVariables(); i++) {
			sp[i] = new ArrayList<Integer>();
		}
		
		int i = 0;
		for (FAbstractEquation fe : equations()) {
			fe.differentiatedRealVariablesEquationSparsity(sp,i);
			i += fe.numScalarEquations();
		}
		return sp;		
	}

	public void FAbstractEquation.differentiatedRealVariablesEquationSparsity(ArrayList<Integer>[] sp, int i) {
		calculateEquationSparsity(sp, i, differentiatedRealVariables(), myFClass().differentiatedRealVariablesOffset());
	}
	
	syn lazy int FClass.realInputsEquationSparsity_n_nz() {
		int n_nz = 0;
		ArrayList<Integer>[] sp = realInputsEquationSparsity();
		for (int j=0; j<numRealInputs(); j++) {
			n_nz += sp[j].size();
		}
		return n_nz;		
	}

	syn lazy ArrayList<Integer>[] FClass.realInputsEquationSparsity() {
		
		ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numRealInputs()];
		
		for (int i=0; i<numRealInputs(); i++) {
			sp[i] = new ArrayList<Integer>();
		}
		
		int i = 0;
		for (FAbstractEquation fe : equations()) {
			fe.realInputsEquationSparsity(sp,i);
			i += fe.numScalarEquations();
		}
		return sp;		
	}

	public void FAbstractEquation.realInputsEquationSparsity(ArrayList<Integer>[] sp, int i) {
		calculateEquationSparsity(sp, i, realInputs(), myFClass().realInputsOffset());
	}
	
	syn lazy int FClass.algebraicRealVariablesEquationSparsity_n_nz() {
		int n_nz = 0;
		ArrayList<Integer>[] sp = algebraicRealVariablesEquationSparsity();
		for (int j=0; j<numAlgebraicContinousRealVariables(); j++) {
			n_nz += sp[j].size();
		}
		return n_nz;		
	}

	syn lazy ArrayList<Integer>[] FClass.algebraicRealVariablesEquationSparsity() {
		
		ArrayList<Integer>[] sp = (ArrayList<Integer>[]) new ArrayList[numAlgebraicContinousRealVariables()];
		
		for (int i=0; i<numAlgebraicContinousRealVariables(); i++) {
			sp[i] = new ArrayList<Integer>();
		}
		
		int i = 0;
		for (FAbstractEquation fe : equations()) {
			fe.algebraicRealVariablesEquationSparsity(sp,i);
			i += fe.numScalarEquations();
		}
		return sp;		
	}

	public void FAbstractEquation.algebraicRealVariablesEquationSparsity(ArrayList<Integer>[] sp, int i) {
		calculateEquationSparsity(sp, i, algebraicContinousRealVariables(), myFClass().algebraicContinousRealVariablesOffset());
	}

}
