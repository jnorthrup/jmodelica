/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect BlockFunctionExtraction {
	
    public class FClass {
        
        // Runs block function extraction if option is set.
        
        public class blockFunctionExtractionIfSet extends Transformation {
            public blockFunctionExtractionIfSet() {
                super("block_func_extract");
            }
            
            public void perform() {}
        }
    }
    
    public boolean FClass.blockFunctionExtraction(BLT blt, BiPGraph g) {
        ArrayList<FFunctionCall> functions = new ArrayList<FFunctionCall>();
        HashMap<String,FVariable> newVars = new HashMap<String, FVariable>();
        
        // Find functions to extract from current block
        for (AbstractEquationBlock block: blt)
            if (!block.isSimple())
                for (FAbstractEquation equation: block.allEquations())
                    equation.findBlockFunctionExtraction(block, functions);
                    
        // If no functions are found do not proceed
        if (functions.isEmpty())
            return false;
        
        // If functions are found replace them with new variables and add equations: new_var = func()
        ArrayList<FAbstractEquation> newEqs = new ArrayList<FAbstractEquation>();
        for (FFunctionCall fCall: functions) {
            FVariable funcRepVariable = null;
            if ((funcRepVariable = newVars.get(fCall.toString())) == null) { // If funcCall hasn't been processed before
                // Create new temp. variable and add it to the variable list and the BiPGraph
                String newTempName = fCall.calcTempVarName();
                funcRepVariable = fCall.type().createTempFVariable(new FQNameFull(newTempName), fCall.variability());
                addFVariable(funcRepVariable);
                g.addVariable(newTempName, funcRepVariable);
                newVars.put(fCall.toString(), funcRepVariable);
                // Create new equation "temp = funcCall()" and add it to the equation list and list for BiPGraph
                FEquation newEq = new FEquation(funcRepVariable.createUseExp(), fCall.fullCopy());
                addFEquation(newEq);
                newEqs.add(newEq);
            }
            // Replace the functionCall with a use of the corresponding temp variable
            fCall.replaceMe(funcRepVariable.createUseExp());
        }
        // Add the equations to the BiPGraph and make new matchings
        root().flushAllRecursive();
        g.addEquations(newEqs, VAR_TYPES_ALL, "eq_", g.getEquations().size() + 1);                
        g.maximumMatching(true);
            
        return true;
    }
    
    // Find non-dependant function
    
    public void FAbstractEquation.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {

    }
     
    public void FEquation.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {  
        getLeft().findBlockFunctionExtraction(block, functions); 
        getRight().findBlockFunctionExtraction(block, functions);
    }
       
    public void FExp.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {

    }
   
    public void FBinExp.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        getLeft().findBlockFunctionExtraction(block, functions);
        getRight().findBlockFunctionExtraction(block, functions);
    }
    
    public void FUnaryExp.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        getFExp().findBlockFunctionExtraction(block, functions);
    }

    public void FMathematicalFunctionCall.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        getFExp().findBlockFunctionExtraction(block, functions);
    }
    
    public void FFunctionCall.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        boolean dep = false;
        for (FExp exp: getArgs()){
            exp.findBlockFunctionExtraction(block, functions);
        }
        for (FExp exp: getArgs()){
            if (exp.dependsOnBlock(block)) {
                dep = true;
                break;
            }
        }
        if(!dep) {
            functions.add(this);
        }
    } 
    
}