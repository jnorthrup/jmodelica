/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect BlockFunctionExtraction {
	
    public class FClass {
            
        private boolean bFEFlag = false;
        
        // Runs block function extraction if option is set.
        
        public class blockFunctionExtractionIfSet extends Transformation {
            public blockFunctionExtractionIfSet() {
                super("block_func_extract");
            }
            
            public void perform() {
                blockFunctionExtractionSetFlag();
            }
        }
    }
    
    public void FClass.blockFunctionExtractionSetFlag() {
    
        bFEFlag = true;
    }
    
    public boolean FClass.blockFunctionExtraction(BLT blt) {  

        ArrayList<FFunctionCall> functions = new ArrayList<FFunctionCall>();
        HashMap<String,FVariable> newVars = new HashMap<String, FVariable>();
        
        // Find functions to extract from current block
        for (AbstractEquationBlock block: blt)
            if (!block.isSimple())
                for (FAbstractEquation equation: block.allEquations())
                    equation.findBlockFunctionExtraction(block, functions);
                    
        // If no functions are found do not proceed
        if (functions.isEmpty())
            return false;
        
        // If functions are found replace them with new variables and add equations: new_var = func()
        log.error("Found " + functions.size() + " function calls to remove");
        for (FFunctionCall fCall: functions) {
            FVariable funcRepVariable = null;
            if ((funcRepVariable = newVars.get(fCall.toString())) == null) {
                log.error("New function call!");
                funcRepVariable = fCall.type().createTempFVariable(new FQNameFull(fCall.calcTempVarName()), fCall.variability());
                addFVariable(funcRepVariable);
                newVars.put(fCall.toString(), funcRepVariable);
                addFEquation(new FEquation(funcRepVariable.createUseExp(), fCall.copy()));
            }
            fCall.replaceMe(funcRepVariable.createUseExp());
        }
        return true;        
    }
    
    // Find non-dependant function
    
    public void FAbstractEquation.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {

    }
     
    public void FEquation.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {  
        getLeft().findBlockFunctionExtraction(block, functions); 
        getRight().findBlockFunctionExtraction(block, functions);
    }
       
    public void FExp.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {

    }
   
    public void FBinExp.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        getLeft().findBlockFunctionExtraction(block, functions);
        getRight().findBlockFunctionExtraction(block, functions);
    }
    
    public void FUnaryExp.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        getFExp().findBlockFunctionExtraction(block, functions);
    }

    public void FMathematicalFunctionCall.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        getFExp().findBlockFunctionExtraction(block, functions);
    }
    
    public void FFunctionCall.findBlockFunctionExtraction(AbstractEquationBlock block, ArrayList<FFunctionCall> functions) {
        boolean dep = false;
        for (FExp exp: getArgs()){
            exp.findBlockFunctionExtraction(block, functions);
        }
        for (FExp exp: getArgs()){
            if (exp.dependsOnBlock(block)) {
                dep = true;
                break;
            }
        }
        if(!dep) {
            functions.add(this);
        }
    }
    
}