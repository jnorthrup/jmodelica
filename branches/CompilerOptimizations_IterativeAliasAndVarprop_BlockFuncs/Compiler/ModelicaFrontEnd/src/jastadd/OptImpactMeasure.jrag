/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


/*----------------------------------------------------------------------------------------------------------------*/

aspect CountPotAlias {
    
    public class FClass {
        public class countPotAliasIfSet extends Transformation {
            public countPotAliasIfSet() {
                super("count_pot_alias");
            }
            
            public void perform() {
                countPotAlias();
            }
        }
    }

    public void FClass.countPotAlias() {
        int nbrPot = 0;
        int nbrTot = getNumFAbstractEquation();

        for (FAbstractEquation equation: getFAbstractEquations()) {
            if (equation.isPotAlias()){
                //log.error("Alias equation: " + equation);
                nbrPot++;
            }
        }
            
        log.error("aspect CountPotAlias run on Model: " + getFQName());
        log.error("--------------------------------------------------------------------");
        log.error("Find variables which can be eliminated by aliasing:");
        log.error("    Total equations in model (not param): " + nbrTot);
        log.error("    Equations which are potential alias:  " + nbrPot);
        log.error("");
        log.error("    Procentage: " + (double)nbrPot/nbrTot * 100 + " %");
        log.error("--------------------------------------------------------------------\n");

    }
    
    public boolean FAbstractEquation.isPotAlias() {
        return false;
    }
     
    public boolean FEquation.isPotAlias() {
        return getLeft().isPotAlias() && getRight().isPotAlias();
    }
    
    public boolean FExp.isPotAlias() {
        return false;
    }
    
    public boolean FDerExp.isPotAlias() {
        return false;
    }
    
    public boolean FNegExp.isPotAlias() {
        return getFExp().isPotAlias();
    }
        
    public boolean FIdUseExp.isPotAlias() {
        return myFV().isPotAlias();
    }
    
    public boolean FAbstractVariable.isPotAlias() {
        return false;
    }
    
    public boolean FVariable.isPotAlias() {
        return !isDerivativeVariable() && !isDummyDerivativeVariable() && !isOutput();
    }
    
}


/*----------------------------------------------------------------------------------------------------------------*/

/*      REMOVE_FUN_BLOCK
    -----------------------------------------AUTO
    | x = y + f(time)   -BLOCK-1            |
    | y = x + 5         -BLOCK-1            |
    |___>>>__________________________       |
    | c = f(time)       -BLOCK-1            |
    | x = y + c         -BLOCK-2            |
    | y = x + 5         -BLOCK-2            |
    -----------------------------------------
 */
aspect FindFunInBlock {
    
    public class FClass {
        public class findFunInBlockIfSet extends Transformation {
            public findFunInBlockIfSet() {
                super("find_fun_in_block");
            }
            
            public void perform() {
                findFunInBlock();
            }
        }
    }
   
    public void FClass.findFunInBlock() {
        int nbrPotFun = 0;
        int nbrPot = 0;
        int nbrTot = 0;
        HashSet<String> ident = new HashSet<String>();
        
        int num = 0;
		for(AbstractEquationBlock block: getDAEInitBLT()) {
		    if(!block.isSimple()){
		        for(FAbstractEquation equation: block.allEquations()){
		            nbrTot++;
		            num = equation.findFunInBlockEq(block, ident);
		            nbrPotFun += num;
		            if(num > 0){
		                nbrPot++;
		            }
		        }
		    }
		}
        
        log.error("aspect FindFunInBlock run on Model: " + getFQName());
        log.error("--------------------------------------------------------------------");
        log.error("Find functions in blocks that don't depend on variables in that block:");
        log.error("    Total amount of equations in blocks: " + nbrTot);
        log.error("    Equations with such functions:       " + nbrPot);
        log.error("    Unique such functions in block:      " + ident.size());
        log.error("    Such function calls in block:        " + nbrPotFun);
        log.error("");
        log.error("    Procentage (equations):              " + (double)nbrPot/nbrTot * 100 + " %");
        log.error("    NonDep_FuncCalls / EquationsInBlock: " + (double)nbrPotFun/nbrTot + " calls/eq");
        log.error("--------------------------------------------------------------------\n");
        
    }
    
    /* Find non-dependant function */
    
    public int FAbstractEquation.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {
        return 0;
    }
     
    public int FEquation.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {  
        int left = getLeft().findFunInBlockEq(block, ident); 
        int right = getRight().findFunInBlockEq(block, ident);
        int count = left + right;
        //if(count > 0)
            //log.error("In equation: " + this);    
        return count;
    }
       
    public int FExp.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {
        return 0;
    }
   
    public int FBinExp.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {
        int left = getLeft().findFunInBlockEq(block, ident);
        int right = getRight().findFunInBlockEq(block, ident);
        return left + right;
    }
    
    public int FUnaryExp.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {
        return getFExp().findFunInBlockEq(block, ident);
    }

    public int FMathematicalFunctionCall.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {
        return getFExp().findFunInBlockEq(block, ident);
    }
    
    public int FFunctionCall.findFunInBlockEq(AbstractEquationBlock block, HashSet<String> ident) {
        int funcs = 1;
        for (FExp exp: getArgs()){
            if (exp.dependsOnBlock(block)) {
                funcs--;
                break;
            }
        }
        if(funcs == 1) {
            /*ASTNode parent = getParent();
            log.error("Found function call: " + this);
            log.error("Parent is ("+ parent.getNodeName() +"): " + parent);
            if(parent.getNodeName().equals("FMulExp")){
                log.error("FMulExp!");
                FMulExp mul = (FMulExp) parent;
                if(mul.getRight().toString().equals(this.toString())){
                    log.error("Right!");
                }else if(mul.getLeft().toString().equals(this.toString())){
                    log.error("Left!");
                }
            }*/
            ident.add(this.toString());
        }
        for (FExp exp: getArgs()){
            funcs += exp.findFunInBlockEq(block, ident);
        }
        return funcs;
    }

    /* Depends on block */

    public boolean FExp.dependsOnBlock(AbstractEquationBlock block) {
        return false;
    }
    
    public boolean FBinExp.dependsOnBlock(AbstractEquationBlock block) {
        boolean left = getLeft().dependsOnBlock(block);
        boolean right = getRight().dependsOnBlock(block);
        return left || right;
    }
    
    public boolean FUnaryExp.dependsOnBlock(AbstractEquationBlock block) {
        return getFExp().dependsOnBlock(block);
    }

    public boolean FMathematicalFunctionCall.dependsOnBlock(AbstractEquationBlock block) {
        return getFExp().dependsOnBlock(block);
    }
    
    public boolean FFunctionCall.dependsOnBlock(AbstractEquationBlock block) {
        for (FExp exp: getArgs()){
            if (exp.dependsOnBlock(block)) {
                return true;
            }
        }
        return false;
    }
    
    public boolean FIdUseExp.dependsOnBlock(AbstractEquationBlock block) {
        return block.allVariables().contains(myFV());
    }
}


/*----------------------------------------------------------------------------------------------------------------*/

/*       REMOVE_SAME_VAR
    ---------------------------------Delvis AUTO
    | x2*x1 - x1 = x2*x1 + 3;       |
    |___>>>________________________ |
    | x1 = -3;                      |
    ---------------------------------
*/ 
aspect RemoveSameVar {

    public class FClass {

        public class removeSameVarIfSet extends Transformation {
            public removeSameVarIfSet() {
                super("remove_same_var");
            }
            
            public void perform() {
                removeSameVar();
            }
        }
    }
    
    public void FClass.removeSameVar() {
        int nbrPot = 0;
        int nbrTot = getNumFAbstractEquation() + getNumFParameterEquation();

        for (FAbstractEquation equation: getFParameterEquations()) {
            if(equation.canRemoveVar()) {
                nbrPot++;
            }
        }
        for (FAbstractEquation equation: getFAbstractEquations()) {
            if(equation.canRemoveVar()) {
                nbrPot++;
            }
        }
        
        log.error("aspect RemoveSameVar");
        log.error("--------------------------------------------------------------------");
        log.error("Find variables within equation which take eachother out:");
        log.error("    Total equations in model:      " + nbrTot);
        log.error("    Equations with such variables: " + nbrPot);
        log.error("");
        log.error("    Procentage: " + (double)nbrPot/nbrTot * 100 + " %");
        log.error("--------------------------------------------------------------------\n");
      
    }
    
    public boolean FAbstractEquation.canRemoveVar() {
        return false;
    }
        
    public boolean FEquation.canRemoveVar() { 
        FExp solution;
        for (FVariable fv: variables()) {
            solution = solution(fv.name());
            if (solution.isValidExp()) {
                if (solution.isUnary()) {
                    solution = ((FUnaryExp)solution).getFExp();
                }
                if (solution.isDivision()) {
                    FExp divisor = ((FDivExp)solution).getRight();
                    if (divisor.variability().constantVariability() && divisor.ceval().realValue() == 0) {
                        return true;
                    }
                }
            }
        }
        return false;
    }
    
    public boolean FExp.isDivision(){
       return false;
    }
    
    public boolean FDivExp.isDivision(){
       return true;
    }
    
    public boolean FExp.isUnary(){
       return false;
    }
    
    public boolean FUnaryExp.isUnary(){
       return true;
    }
}


/*----------------------------------------------------------------------------------------------------------------*/

aspect FindIdentFun {
    
    public class FClass {
        public class findIdentFunIfSet extends Transformation {
            public findIdentFunIfSet() {
                super("find_ident_fun");
            }
            
            public void perform() {
                findIdentFun();
            }
        }
    }
   
    public void FClass.findIdentFun() {
        int nbrPotFun = 0;
        int nbrPotEq = 0;
        int nbrTotEq = getNumFAbstractEquation();
        boolean foundInEq;
        HashSet<String> potFuncs = new HashSet<String>();
        int count = 0;
            
        for(FAbstractEquation equation: getFAbstractEquations()){
            count = equation.findIdentFunEq(potFuncs);
            nbrPotFun += count;
            if(count > 0){
                nbrPotEq++;
            }
        }

        log.error("aspect FindIdentFun");
        log.error("--------------------------------------------------------------------");
        log.error("Find several identical function calls: ");
        log.error("    Total equations in model (not param):          " + nbrTotEq);
        log.error("    Equations containing such function calls:      " + nbrPotEq);
        log.error("    Duplicate function calls that can be removed:  " + nbrPotFun);
        log.error("");
        log.error("    Procentage (equations):             " + (double)nbrPotEq/nbrTotEq * 100 + " %");
        log.error("    RemovableFunCalls / TotalEquations: " + (double)nbrPotFun/nbrTotEq + " calls/eq");
        log.error("--------------------------------------------------------------------\n");
    }
 
    
    public int FAbstractEquation.findIdentFunEq(HashSet<String> potFuncs) {
        return 0;
    }
     
    public int FEquation.findIdentFunEq(HashSet<String> potFuncs) {        
        int left = getLeft().findIdentFunEq(potFuncs);
        int right = getRight().findIdentFunEq(potFuncs);
        int count = left + right;
        //if (count > 0)
            //log.error("In equation: " + this);
        return count;
    }
       
       
    public int FExp.findIdentFunEq(HashSet<String> potFuncs) {
        return 0;
    }
   
    public int FBinExp.findIdentFunEq(HashSet<String> potFuncs) {
        int left = getLeft().findIdentFunEq(potFuncs);
        int right = getRight().findIdentFunEq(potFuncs);
        return left + right;
    }
    
    public int FUnaryExp.findIdentFunEq(HashSet<String> potFuncs) {
        return getFExp().findIdentFunEq(potFuncs);
    }

    public int FMathematicalFunctionCall.findIdentFunEq(HashSet<String> potFuncs) {
        return getFExp().findIdentFunEq(potFuncs);
    }
    
    public int FFunctionCall.findIdentFunEq(HashSet<String> potFuncs) {
        String s = this.toString();
        int count = 0;
        if (potFuncs.contains(s)){
            //log.error("Found ident fun: " + this);
            count++;
        } else {
            potFuncs.add(s);
        }
        
        for (FExp exp: getArgs()){
            count += exp.findIdentFunEq(potFuncs);
        }
        return count;
    }
    
}


/*----------------------------------------------------------------------------------------------------------------*/


