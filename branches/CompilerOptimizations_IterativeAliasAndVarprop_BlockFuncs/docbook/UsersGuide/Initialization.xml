<?xml version="1.0" encoding="UTF-8"?>
<chapter version="5.0" xml:id="ch_initialization"
         xmlns="http://docbook.org/ns/docbook"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xmlns:xs="http://www.w3.org/2001/XMLSchema"
         xmlns:xlink="http://www.w3.org/1999/xlink"
         xmlns:xi="http://www.w3.org/2001/XInclude"
         xmlns:svg="http://www.w3.org/2000/svg"
         xmlns:m="http://www.w3.org/1998/Math/MathML"
         xmlns:html="http://www.w3.org/1999/xhtml"
         xmlns:db="http://docbook.org/ns/docbook">
  <title>Initialization and simulation of JMUs</title>

  <section>
    <title>Introduction</title>

    <para>There are two different means to simulate a Modelica model in
    JModelica.org: either as a Functional Mock-Up Unit (FMU) or as a
    JModelica.org Model Unit (JMU). In the former case, the model is converted
    into an Ordinary Differential Equation (ODE), whereas in the latter case,
    the model is simulated as a Differential Algebraic Equation (DAE). The
    default, and recommended, means to simulate models is to use FMUs, since
    this approach provides better performance, a more robust initialization
    mechanism, and significantly better support for hybrid systems. Simulation
    of JMUs may still be useful, however, in some optimization applications
    where simulation of the model as a DAE/JMU, is an important prerequisite
    for optimization by means of the collocation algorithms.</para>

    <para>This chapter demonstrates how to initialize and simulate a model
    which has been compiled to a JMU. To read about simulation of FMUs, see
    <xref linkend="ch_simulation"/>.</para>
  </section>

  <section>
    <title>Initialization of JMUs</title>

    <section>
      <title>Solving DAE initialization problems</title>

      <para>Before a model can be simulated it must be initialized, i.e.
      consistent initial values must be computed. To do this, JModelica.org
      supplies the JMUModel member function <literal>initialize</literal>,
      which initializes the JMUModel. The function is called after compiling
      and creating a JMUModel:</para>

      <programlisting language="python"># Compile the stationary initialization model into a JMU
from pymodelica import compile_jmu
model_name = compile_jmu("My.Model", "/path/to/MyModel.mo")

# Load the model instance into Python
from pyjmi import JMUModel
init_model = JMUModel(model_name)
    
# Solve the DAE initialization system
init_result = init_model.initialize()
</programlisting>

      <para>The JMUModel instance <literal>init_model</literal> is now
      initialized and is ready to be simulated.</para>

      <para>The interactive help for the initialize method is shown by the
      command:</para>

      <programlisting>&gt;&gt;&gt; help(init_model.initialize)   
    The initialization method depends on which algorithm is used, this can 
    be set with the function argument 'algorithm'. Options for the algorithm 
    are passed as option classes or as pure dicts. See 
    JMUModel.initialize_options for more details.
        
    The default algorithm for this function is IpoptInitializationAlg. 
        
    Parameters::
        
        algorithm --
            The algorithm which will be used for the initialization is 
            specified by passing the algorithm class as string or class 
            object in this argument. 'algorithm' can be any class which 
            implements the abstract class AlgorithmBase (found in 
            algorithm_drivers.py). In this way it is possible to write own 
            algorithms and use them with this function.
            Default: 'IpoptInitializationAlg'
            
        options -- 
            The options that should be used in the algorithm. For details on 
            the options do:
            
                &gt;&gt; myModel = JMUModel(...)
                &gt;&gt; opts = myModel.initialize_options()
                &gt;&gt; opts?
    
            Valid values are: 
                - A dict which gives IpoptInitializationAlgOptions with 
                  default values on all options except the ones listed in 
                  the dict. Empty dict will thus give all options with 
                  default values.
                - An options object.
            Default: Empty dict
    
    Returns::
        
        Result object, subclass of algorithm_drivers.ResultBase.
</programlisting>

      <para>Options for the available initialization algorithms can be set by
      first retrieving an options object using the <literal>JMUModel</literal>
      method <literal>initialize_options:</literal><programlisting>&gt;&gt;&gt; help(init_model.initialize_options)
    Get an instance of the initialize options class, prefilled with default 
    values. If called without argument then the options class for the 
    default initialization algorithm will be returned.
    
    Parameters::
    
        algorithm --
            The algorithm for which the options class should be fetched. 
            Possible values are: 'IpoptInitializationAlg', 'KInitSolveAlg'.
            Default: 'IpoptInitializationAlg'
            
    Returns::
    
        Options class for the algorithm specified with default values.
</programlisting>Having solved the initialization problem, the result of the
      initialization can be retrieved from the return result object:</para>

      <programlisting language="python">x = init_result['x']
y = init_result['y']
</programlisting>
    </section>

    <section>
      <title>How JModelica.org creates the initialization system of
      equations</title>

      <para>To find a set of consistent initial values a system of non-linear
      equations, called the system of initialization equations, is solved.
      This system is composed from the DAE equations, the initial equations,
      some resulting from start attributes with the fixed attribute set to
      true. Start attributes with the fixed attribute set to false are treated
      as initial guesses for the numerical algorithm used to solve the
      initialization problem</para>

      <para>Some initialization algorithms require the system of initial
      equations to be well defined in the sense that the number of variables
      must be equal to the number of equations. If this is not the case,
      the</para>

      <itemizedlist>
        <listitem>
          <para>If the number of equations is greater than the number of
          variables the system is overdetermined. Such a system may not have a
          solution, and will be treated as ill-defined. An exception is thrown
          in this case.</para>
        </listitem>

        <listitem>
          <para>If the number of equations is less than the number of
          variables the system is underdetermined and such a system has
          infinitely many solutions. In this case, the compiler tries to
          balance the system by setting some fixed attributes to
          <literal>true</literal>. So if the user supplies too few initial
          conditions, some variables with the attribute
          <literal>fixed</literal> set to <literal>false</literal> may be
          changed to <literal>true</literal> during initialization.</para>
        </listitem>
      </itemizedlist>
    </section>

    <section>
      <title>Initialization algorithms</title>

      <section>
        <title>Initialization using IPOPT</title>

        <para>JModelica.org provides a method for DAE initialization that is
        based on IPOPT, the mathematical formulation of the algorithm can be
        found in the <link
        xlink:href="http://www.jmodelica.org/api-docs/jmi/">JMI API
        documentation</link>. Note that this algorithm does not rely on the
        causalization procedure (in particular the BLT transformation) which
        is common. Instead, the DAE residual is introduced as an equality
        constraint when solving an optimization problem where the squared
        difference between the non-fixed start values and their corresponding
        variables are minimized. As a consequence, the algorithm relies on
        decent start values for <emphasis>all</emphasis> variables. This
        approach is generally more sensitive to lacking initial guesses for
        start values than are algorithms based on causalization.</para>

        <para>The algorithm provides the options summarized in <xref
        linkend="init-tab-collopts"/>.</para>

        <table xml:id="init-tab-collopts">
          <title>Options for the collocation-based optimization
          algorithm</title>

          <tgroup cols="3">
            <colspec align="left" colname="col–opt" colwidth="1*"/>

            <colspec align="left" colname="col–desc" colwidth="1*"/>

            <colspec align="left" colname="col–def" colwidth="2*"/>

            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>result_file_name</literal></entry>

                <entry>Empty string (default generated file name will be
                used)</entry>

                <entry>Specifies the name of the file where the optimization
                result is written. Setting this option to an empty string
                results in a default file name that is based on the name of
                the optimization class.</entry>
              </row>

              <row>
                <entry><literal>result_format</literal></entry>

                <entry><literal>'txt'</literal></entry>

                <entry>Specifies in which format to write the result.
                Currently only textual mode is supported.</entry>
              </row>

              <row>
                <entry><literal>write_scaled_result</literal></entry>

                <entry><literal>False</literal></entry>

                <entry>Write the scaled optimization result if set to
                <literal>True</literal>. This option is only applicable when
                automatic variable scaling is enabled. Only for debugging
                use.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>In addition to the options for the collocation algorithm, IPOPT
        options can also be set by modifying the dictionary
        <literal>IPOPT_options</literal> contained in the collocation
        algorithm options object. Here, all valid IPOPT options can be
        specified, see the <link
        xlink:href="http://www.coin-or.org/Ipopt/documentation/">IPOPT
        documentation</link> for further information. For example, setting the
        option <literal>max_iter</literal>:</para>

        <programlisting language="python">opts['IPOPT_options']['max_iter'] = 300
</programlisting>

        <para>makes IPOPT terminate after 300 iterations even if no optimal
        solution has been found.</para>

        <para>Some statistics from IPOPT can be obtained by issuing the
        command:</para>

        <programlisting>&gt;&gt;&gt; res_init.solver.init_opt_ipopt_get_statistics()
</programlisting>

        <para>The return argument of this function can be found by using the
        interactive help:</para>

        <programlisting>&gt;&gt;&gt; help(res_init.solver.init_opt_ipopt_get_statistics)
    Get statistics from the last optimization run.
    
    Returns::
    
        return_status -- 
            The return status from IPOPT.
            
        nbr_iter -- 
            The number of iterations. 
            
        objective -- 
            The final value of the objective function.
            
        total_exec_time -- 
            The execution time.
</programlisting>
      </section>

      <section>
        <title>Initialization using KInitSolveAlg</title>

        <para>JModelica.org also provides a method for DAE initialization
        based on the non-linear equation solver KINSOL from the SUNDIALS
        suite. KINSOL is currently comprised in the <link
        xlink:href="http://www.jmodelica.org/assimulo">Assimulo</link>
        package, included when installing JModelica.org. KINSOL is based on
        Newtons method for solving non-linear equations and is thus locally
        convergent. Attempts are made to make KInitSolveAlg as robust as
        possible but the possibility of finding a local minimum instead of the
        solution still remains. If the solution found by KInitSolveAlg is a
        local minimum a warning will be printed. The initial guesses passed to
        KINSOL are the ones supplied as start attributes in the current
        Modelica model.</para>

        <para>KInitSolveAlg also implements an improved linear solver
        connected to KINSOL. This linear solver implements Tikhonov
        regularization to handle the problems of singular Jacobians as well as
        support for SuperLU, an efficient sparse linear solver.</para>

        <para>The options providable are summarized in <xref
        linkend="tab_options"/>.</para>

        <table xml:id="tab_options">
          <title>Options for KInitSolveAlg</title>

          <tgroup cols="3" colsep="1">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>use_constraints</literal></entry>

                <entry><literal>False</literal></entry>

                <entry>A flag indicating whether constraints are to be used
                <emphasis>during</emphasis> initialization. Further explained
                in <xref linkend="sec_const_usage"/>.</entry>
              </row>

              <row>
                <entry><literal>constraints</literal></entry>

                <entry><literal>None</literal></entry>

                <entry>A <literal>numpy.array</literal> containing floats
                that, when supplied, defines the constraints on the variables.
                Further explained in <xref
                linkend="sec_const_usage"/>.</entry>
              </row>

              <row>
                <entry><literal>result_format</literal></entry>

                <entry><literal>'txt'</literal></entry>

                <entry>Specifies in which format to write the result.
                Currently only textual mode is supported.</entry>
              </row>

              <row>
                <entry><literal>result_file_name</literal></entry>

                <entry>Empty string (default generated file name will be
                used)</entry>

                <entry>Specifies the name of the file where the optimization
                result is written. Setting this option to an empty string
                results in a default file name that is based on the name of
                the optimization class.</entry>
              </row>

              <row>
                <entry><literal>KINSOL_options</literal></entry>

                <entry>A dictionary with the defalt KINSOL options</entry>

                <entry>These are the options sent to the KINSOL solver. These
                are reviewed in detail in <xref
                linkend="kinsol_options"/>.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table xml:id="kinsol_options">
          <title>Options for KINSOL contained in the
          <literal>KINSOL_options</literal> dictionary</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Options</entry>

                <entry align="center">Default</entry>

                <entry align="center">Descriptions</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>use_jac</literal></entry>

                <entry><literal>True</literal></entry>

                <entry>Flag indicating whether or not KINSOL uses the jacobian
                supplied by JModelica.org (<literal>True</literal>) or if
                KINSOL evaluates the Jacobian through finite differences
                (<literal>False</literal>). Finite differences is currently
                not available in sparse mode.</entry>
              </row>

              <row>
                <entry>sparse</entry>

                <entry><literal>False</literal></entry>

                <entry>Flag indicating whether the problem should be treated
                as sparse (<literal>True</literal>) or dense
                (<literal>False</literal>).</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <section xml:id="sec_const_usage">
          <title>The use of constraints</title>

          <para>KINSOL, and hence also <literal>KInitSolvAlg</literal>, only
          supports simple unilateral constraints, that is constraining a
          variable to being positive or negative. If the option
          <literal>use_constraints</literal> is set to
          <literal>True</literal>, constraints are used. Which constraints
          that are used depends on whether or not the user has supplied
          constraints with the <literal>constraints</literal> option. If set,
          these will be used otherwise constraints will be computed by reading
          the min and max attributes from the Modelica file. How the
          constraint array is written is summarized in <xref
          linkend="constraints_array"/>.</para>

          <table pgwide="0" xml:id="constraints_array">
            <title>Values allowed in the <literal>constraints</literal>
            array</title>

            <tgroup cols="2">
              <thead>
                <row>
                  <entry align="center">Value</entry>

                  <entry align="center">Constraint</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>0.0</entry>

                  <entry>Unconstrained.</entry>
                </row>

                <row>
                  <entry>1.0</entry>

                  <entry>Greater than, or equal to, zero.</entry>
                </row>

                <row>
                  <entry>2.0</entry>

                  <entry>Greater than zero.</entry>
                </row>

                <row>
                  <entry>-1.0</entry>

                  <entry>Less than, or equal to, zero.</entry>
                </row>

                <row>
                  <entry>-2.0</entry>

                  <entry>Less than zero.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>

          <para>When the constraints are read from the Modelica file the value
          from <xref linkend="constraints_array"/> most fitting to the min and
          max values is chosen. For example a variable with min set to 3.2 and
          max set to 5.6 is constrained to be greater than zero. When the
          algorithm is finished however the result will be compared with the
          min and max values from the model testing if the solution fulfills
          the constraints set by the Modelica file.</para>
        </section>

        <section xml:id="sec_verbosity">
          <title>Verbosity of KINSOL</title>

          <para>There are four different levels of verbosity in KINSOL with 0
          being silent and 3 being the most verbose. The verbosity level is
          controlled by the FMU log level. <xref linkend="verbosity"/>
          describes what is output.</para>

          <table xml:id="verbosity">
            <title>Verbosity levels in KINSOL</title>

            <tgroup cols="3">
              <thead>
                <row>
                  <entry align="center">FMU log level</entry>

                  <entry align="center">Verbosity level</entry>

                  <entry align="center">Output</entry>
                </row>
              </thead>

              <tbody>
                <row>
                  <entry>&lt;= 2</entry>

                  <entry>0</entry>

                  <entry>No information displayed.</entry>
                </row>

                <row>
                  <entry>3</entry>

                  <entry>1</entry>

                  <entry>In each nonlinear iteration the following information
                  is displayed: the scaled Euclidean norm of the residual at
                  the current iterate, the scaled Euclidian norm of the Newton
                  step as well as the number of function evaluations performed
                  so far.</entry>
                </row>

                <row>
                  <entry>4</entry>

                  <entry>2</entry>

                  <entry>Level 1 output as well as the Euclidian and in finity
                  norm of the <emphasis>scaled</emphasis> residual at the
                  current iterate</entry>
                </row>

                <row>
                  <entry>&gt;= 5</entry>

                  <entry>3</entry>

                  <entry>Level 2 output plus additional values used by the
                  global strategy as well as statistical information from the
                  linear solver.</entry>
                </row>
              </tbody>
            </tgroup>
          </table>
        </section>
      </section>
    </section>
  </section>

  <section>
    <title>Simulation of JMUs</title>

    <para>Simulation of JMUs in JModelica.org is performed via the simulate
    method of the JMU model object. The model object is called
    <literal>JMUModel</literal> and is located in the JModelica.org Python
    package <literal>pyjmi</literal>. <literal>JMUModel</literal> supports
    compiled models from JModelica.org which have the extension
    <filename>.jmu</filename>. <programlisting># Import JMUModel from pyjmi and load the JMU
from pyjmi import JMUModel
my_model = JMUModel('myJMU.jmu')</programlisting>The simulation method in
    <literal>JMUModel</literal> is by default connected to the Assimulo
    simulation package and thus able to use its solvers. Continuing the short
    example from above, the following code will simulate the loaded JMU using
    default values and options:<programlisting>res = my_model.simulate()</programlisting></para>

    <section>
      <title>The simulate function</title>

      <para>There are several parameters that can be set in the
      <literal>JMUModel.simulate</literal> function. <glosslist>
          <glossentry>
            <glossterm><literal>start_time</literal></glossterm>

            <glossdef>
              <para>The time when the solver should start the
              integration.</para>
            </glossdef>
          </glossentry>

          <glossentry>
            <glossterm><literal>final_time</literal></glossterm>

            <glossdef>
              <para>The time when the solver should finish the
              integration.</para>
            </glossdef>
          </glossentry>

          <glossentry>
            <glossterm><literal>input</literal></glossterm>

            <glossdef>
              <para>Input signal for the simulation. (Further explained in
              below.)</para>
            </glossdef>
          </glossentry>

          <glossentry>
            <glossterm><literal>algorithm</literal></glossterm>

            <glossdef>
              <para>The algorithm that will be used for the simulation.
              Currently only a connection to Assimulo is supported and
              connected through the algorithm
              <literal>AssimuloAlg</literal>.</para>
            </glossdef>
          </glossentry>

          <glossentry>
            <glossterm><literal>options</literal></glossterm>

            <glossdef>
              <para>The options to be used in the algorithm. (Further
              explained in below.)</para>
            </glossdef>
          </glossentry>
        </glosslist></para>

      <section>
        <title>Input</title>

        <para>The input defines the input trajectories to the model and should
        be a 2-tuple consisting of the name(s) of the input variables and the
        second argument should be either a data matrix or a function. If the
        argument is a data matrix it should contain a time vector as the first
        column and the second column should correspond to the first name in
        the first argument and so forth. If instead the second argument is a
        function it should be defined to take the time as input and return the
        number of inputs in the order defined by the first argument.</para>

        <para>For example, consider that we have a model with an input
        variable <literal>u1 </literal>and that the model should be driven by
        a sinus wave as input. Also we are interested in the interval 0 to
        10.</para>

        <programlisting language="python">import numpy as N
t = N.linspace(0.,10.,100)            # Create one hundred evenly spaced points
u = N.sin(t)                          # Create the input vector
u_traj = N.transpose(N.vstack((t,u))) # Create the data matrix and transpose 
                                      # it to the correct form
</programlisting>

        <para>The above code has created the data matrix that we are
        interested in giving to the model as input, we just need to connect
        the data to a specific input variable, <literal>u1</literal>:</para>

        <programlisting language="python">input_object = ('u1', u_traj)
</programlisting>

        <para>Now we are ready to simulate using the input and simulate 10
        seconds.</para>

        <programlisting language="python">res = model.simulate(final_time=10, input=input_object)
</programlisting>

        <para>If we on the other hand would have two input variables, u1 and
        u2 the script would instead look like:</para>

        <programlisting language="python">import numpy as N
t = N.linspace(0.,10.,100)                     # Create one hundred evenly spaced points
u1 = N.sin(t)                                  # Create the first input vector
u2 = N.cos(t)                                  # Create the second input vector
u_traj = N.transpose(N.vstack((t,u1,u2)))      # Create the data matrix and 
                                               # transpose it to the correct form
input_object = (['u1','u2'], u_traj)
res = model.simulate(final_time=10, input=input_object)
</programlisting>

        <para>Note that the variables are now a List of variables.</para>

        <para>If we were to do the same example using input functions instead,
        the code would look like for the single input case:</para>

        <programlisting language="python">input_object = ('u1', N.sin)</programlisting>

        <para>and for the double input case:</para>

        <programlisting language="python">def input_function(t):
    return N.array([N.sin(t),N.cos(t)])

input_object = (['u1','u2'],input_function)
</programlisting>
      </section>

      <section>
        <title>Options for JMUModel</title>

        <para>The options attribute are where options to the specified
        algorithm are stored and are preferably used together with:</para>

        <programlisting language="python">opts = JMUModel.simulate_options()
</programlisting>

        <para>which returns the default options for the default algorithm.
        Information about the available options can be viewed by typing help
        on the <literal>opts</literal> variable:</para>

        <programlisting>&gt;&gt;&gt; help(opts)
   Options for simulation of a JMU model using the Assimulo simulation package.
   The Assimulo package contain both explicit solvers (CVode) for ODEs and 
   implicit solvers (IDA) for DAEs. The ODE solvers require that the problem
   is written on the form, ydot = f(t,y).
   
   ...
</programlisting>

        <para>In <xref linkend="sim_table_gen_Jalg"/> the general options for
        the <literal>AssimuloAlg</literal> algorithm are described while in
        <xref linkend="sim_table_ida"/> a selection of the different solver
        arguments for the DAE solver IDA is shown. In <xref
        linkend="sim_table_cvode"/> a selection of solver arguments for the
        ODE solver CVode is shown. More information regarding the solver
        options can be found here, http://www.jmodelica.org/assimulo.</para>

        <table xml:id="sim_table_gen_Jalg">
          <title>General options for AssimuloAlg.</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>solver</literal></entry>

                <entry><literal>'IDA'</literal></entry>

                <entry>Specifies the simulation method that is to be
                used.</entry>
              </row>

              <row>
                <entry><literal>ncp</literal></entry>

                <entry><literal>0</literal></entry>

                <entry>Number of communication points. If
                <literal>ncp</literal> is zero, the solver will return the
                internal steps taken.</entry>
              </row>

              <row>
                <entry><literal>initialize</literal></entry>

                <entry><literal>True</literal></entry>

                <entry>If set to <literal>True</literal>, an algorithm for
                initializing the differential equation is invoked, otherwise
                the differential equation is assumed to have consistent
                initial conditions.</entry>
              </row>

              <row>
                <entry><literal>write_scaled_result</literal></entry>

                <entry><literal>False</literal></entry>

                <entry>Set this parameter to <literal>True</literal> to write
                the result to file without taking scaling into account. If the
                value of scaled is <literal>False</literal>, then the variable
                scaling factors of the model are used to reproduced the
                unscaled variable values.</entry>
              </row>

              <row>
                <entry><literal>result_file_name</literal></entry>

                <entry>Empty string (default generated file name will be
                used)</entry>

                <entry>Specifies the name of the file where the simulation
                result is written. Setting this option to an empty string
                results in a default file name that is based on the name of
                the model class.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <para>Lets look at an example, consider that you want to simulate a
        JMU model using the solver <literal>CVode</literal> together with
        changing the discretization method (discr) from <literal>BDF</literal>
        to <literal>Adams</literal>:</para>

        <programlisting language="python">...
opts = model.simulate_options()          # Retrieve the default options
opts['solver'] = 'CVode'                 # Change the solver from IDA to CVode
opts['CVode_options']['discr'] = 'Adams' # Change from using BDF to Adams
model.simulate(options=opts)             # Pass in the options to simulate and simulate
</programlisting>

        <para>It should also be noted from the above example the options
        regarding a specific solver, say the tolerances for
        <literal>CVode</literal> or <literal>IDA</literal>, should be stored
        in a double dictionary where the first is named after the solver
        concatenated with <literal>_options</literal>:</para>

        <programlisting language="python">opts['CVode_options']['atol'] = 1.0e-6 # Options specific for CVode
opts['IDA_options']['atol'] = 1.0e-6   # Options specific for IDA
</programlisting>

        <para>For the general options, as changing the solver, they are
        accessed as a single dictionary:</para>

        <programlisting language="python">opts['solver'] = 'CVode' # Changing the solver
opts['ncp'] = 1000       # Changing the number of communication points.
</programlisting>

        <table xml:id="sim_table_cvode">
          <title>Selection of solver arguments for CVode</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>discr</literal></entry>

                <entry><literal>'BDF'</literal></entry>

                <entry>The discretization method. Can be either
                <literal>'BDF'</literal> or <literal>'Adams'</literal></entry>
              </row>

              <row>
                <entry><literal>iter</literal></entry>

                <entry><literal>'Newton'</literal></entry>

                <entry>The iteration method. Can be either
                <literal>'Newton</literal>' or
                <literal>'FixedPoint'</literal>.</entry>
              </row>

              <row>
                <entry><literal>maxord</literal></entry>

                <entry><literal>5</literal></entry>

                <entry>The maximum order used. Maximum for
                <literal>'BDF'</literal> is 5 while for the
                <literal>'Adams'</literal> method the maximum is 12</entry>
              </row>

              <row>
                <entry><literal>maxh</literal></entry>

                <entry><literal>Inf</literal></entry>

                <entry>Maximum step-size. Positive float.</entry>
              </row>

              <row>
                <entry><literal>atol</literal></entry>

                <entry><literal>1.0e-6</literal></entry>

                <entry>Absolute Tolerance. Can be an array of floats where
                each value corresponds to the absolute tolerance for the
                corresponding variable. Can also be a single positive
                float.</entry>
              </row>

              <row>
                <entry><literal>rtol</literal></entry>

                <entry><literal>1.0e-6</literal></entry>

                <entry>Relative Tolerance. Positive float.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>

        <table xml:id="sim_table_ida">
          <title>Selection of solver arguments for IDA</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Default</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>maxord</literal></entry>

                <entry><literal>5</literal></entry>

                <entry>The maximum order used. Positive integer.</entry>
              </row>

              <row>
                <entry><literal>maxh</literal></entry>

                <entry><literal>Inf</literal></entry>

                <entry>Maximum step-size. Positive float.</entry>
              </row>

              <row>
                <entry><literal>atol</literal></entry>

                <entry><literal>1.0e-6</literal></entry>

                <entry>Absolute Tolerance. Can be an array of floats where
                each value corresponds to the absolute tolerance for the
                corresponding variable. Can also be a single positive
                float.</entry>
              </row>

              <row>
                <entry><literal>rtol</literal></entry>

                <entry><literal>1.0e-6</literal></entry>

                <entry>Relative Tolerance. Positive float.</entry>
              </row>

              <row>
                <entry><literal>suppress_alg</literal></entry>

                <entry><literal>False</literal></entry>

                <entry>Suppress the algebraic variables on the error test. Can
                be either <literal>False</literal> or
                <literal>True</literal>.</entry>
              </row>

              <row>
                <entry><literal>sensitivity</literal></entry>

                <entry><literal>False</literal></entry>

                <entry>If set to <literal>True</literal>, sensitivities for
                the states with respect to parameters set to free in the model
                will be calculated.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>

      <section>
        <title>Return argument</title>

        <para>The return argument from the simulate method is an object
        derived from a common result object <literal>ResultBase</literal> in
        <filename>algorithm_drivers.py</filename> with a few extra convenience
        methods for retrieving the result of a variable. The result object can
        be accessed in the same way as a dictionary type in Python with the
        name of the variable as key.</para>

        <programlisting language="python">res = model.simulate()
y = res['y']           # Return the result for the variable/parameter/constant y
dery = res['der(y)']   # Return the result for the variable/parameter/constant der(y)
</programlisting>

        <para>This can be done for all the variables, parameters and constants
        defined in the model and is the preferred way of retrieving the
        result. There are however some more options available in the result
        object, see <xref linkend="simjmu_table_result"/>.</para>

        <table xml:id="simjmu_table_result">
          <title>Result Object</title>

          <tgroup cols="3">
            <thead>
              <row>
                <entry align="center">Option</entry>

                <entry align="center">Type</entry>

                <entry align="center">Description</entry>
              </row>
            </thead>

            <tbody>
              <row>
                <entry><literal>options</literal></entry>

                <entry>Property</entry>

                <entry>Gets the options object that was used during the
                simulation.</entry>
              </row>

              <row>
                <entry><literal>solver</literal></entry>

                <entry>Property</entry>

                <entry>Gets the solver that was used during the
                integration.</entry>
              </row>

              <row>
                <entry><literal>result_file</literal></entry>

                <entry>Property</entry>

                <entry>Gets the name of the generated result file.</entry>
              </row>

              <row>
                <entry><literal>is_variable(name)</literal></entry>

                <entry>Method</entry>

                <entry>Returns <literal>True</literal> if the given name is a
                time-varying variable.</entry>
              </row>

              <row>
                <entry><literal>data_matrix</literal></entry>

                <entry>Property</entry>

                <entry>Gets the raw data matrix.</entry>
              </row>

              <row>
                <entry><literal>is_negated(name)</literal></entry>

                <entry>Method</entry>

                <entry>Returns <literal>True</literal> if the given name is
                negated in the result matrix.</entry>
              </row>

              <row>
                <entry><literal>get_column(name)</literal></entry>

                <entry>Method</entry>

                <entry>Returns the column number in the data matrix which
                corresponds to the given variable.</entry>
              </row>
            </tbody>
          </tgroup>
        </table>
      </section>
    </section>

    <section>
      <title>Examples</title>

      <para>In the next sections, it will be shown how to use the
      JModelica.org platform for simulation of various JMUs.</para>

      <section>
        <title>Simulation with inputs</title>

        <para>This example will demonstrate how a model with two inputs with
        data from a MATLAB-file can be simulated. The model to be simulated is
        a quadruple tank connected to two pumps, which also are the inputs to
        the model. The model is depicted in <xref linkend="sim_fig_quadtank"/>
        and in the code below the corresponding Modelica code is
        listed.</para>

        <figure xml:id="sim_fig_quadtank">
          <title>A schematic picture of the quadruple tank process.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/qt_schematic.png" scalefit="1"
                         width="40%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <programlisting language="modelica" xml:id="sim_list_qt">model QuadTank
    // Process parameters
  parameter Modelica.SIunits.Area A1=4.9e-4, A2=4.9e-4, A3=4.9e-4, A4=4.9e-4;
  parameter Modelica.SIunits.Area a1=0.03e-4, a2=0.03e-4, a3=0.03e-4, a4=0.03e-4;
  parameter Modelica.SIunits.Acceleration g=9.81;
  parameter Real k1_nmp(unit="m3^/s/V") = 0.56e-6, k2_nmp(unit="m^3/s/V") = 0.56e-6;
  parameter Real g1_nmp=0.30, g2_nmp=0.30;

   // Initial tank levels
  parameter Modelica.SIunits.Length x1_0 = 0.06270;
  parameter Modelica.SIunits.Length x2_0 = 0.06044;
  parameter Modelica.SIunits.Length x3_0 = 0.02400;
  parameter Modelica.SIunits.Length x4_0 = 0.02300;

   // Tank levels
  Modelica.SIunits.Length x1(start=x1_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x2(start=x2_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x3(start=x3_0,min=0.0001/*,max=0.20*/);
  Modelica.SIunits.Length x4(start=x4_0,min=0.0001/*,max=0.20*/);

  // Inputs
  input Modelica.SIunits.Voltage u1;
  input Modelica.SIunits.Voltage u2;

 equation
   der(x1) = -a1/A1*sqrt(2*g*x1) + a3/A1*sqrt(2*g*x3) +
                                   g1_nmp*k1_nmp/A1*u1;
   der(x2) = -a2/A2*sqrt(2*g*x2) + a4/A2*sqrt(2*g*x4) +
                                   g2_nmp*k2_nmp/A2*u2;
   der(x3) = -a3/A3*sqrt(2*g*x3) + (1-g2_nmp)*k2_nmp/A3*u2;
   der(x4) = -a4/A4*sqrt(2*g*x4) + (1-g1_nmp)*k1_nmp/A4*u1;

end QuadTank;
</programlisting>

        <para>Let's begin with the the example, copy and paste the Modelica
        code and save it into <literal>QuadTank.mo</literal> and open a Python
        script file. We start by importing the necessary objects:</para>

        <programlisting language="python">from scipy.io.matlab.mio import loadmat
import matplotlib.pyplot as plt
import numpy as N

from pymodelica import compile_jmu
from pyjmi import JMUModel
</programlisting>

        <para>The input data is stored in
        <literal>qt_par_est_data.mat</literal> which can be found in the
        <literal>Python/pyjmi/examples/files</literal> catalogue in the
        JModelica.org install folder. Copy it into your working directory and
        paste the following commands to load the data-file and extract the
        data trajectories:</para>

        <programlisting language="python">data = loadmat('qt_par_est_data.mat',appendmat=False)

# Extract data series  
t_meas = data['t'][6000::100,0]-60  
u1 = data['u1_d'][6000::100,0]
u2 = data['u2_d'][6000::100,0]
</programlisting>

        <para>The trajectories have now been extracted and needs to be stacked
        into a data matrix with the first column as the time vector and the
        following columns the input of <literal>u1</literal> and
        <literal>u2</literal>. The names of the variables needs also be
        connected in the input object:</para>

        <programlisting language="python"># Build input trajectory matrix for use in simulation
u_data = N.transpose(N.vstack((t_meas,u1,u2)))
input_object = (['u1','u2'], u_data)
</programlisting>

        <para>Next, we compile and load the model:</para>

        <programlisting language="python"># Compile JMU
jmu_name = compile_jmu('QuadTank', 'QuadTank.mo')

# Load model
model = JMUModel(jmu_name)
</programlisting>

        <para>Now that the model is compiled and the input has been adapted,
        let's give the information to the simulate method and simulate:</para>

        <programlisting language="python"># Simulate model with input trajectories
res = model.simulate(final_time=60, input=input_object)
</programlisting>

        <para>The result is retrieved by accessing the <literal>res</literal>
        variable as a dictionary with the variable name as key:</para>

        <programlisting language="python">x1_sim = res['x1']
x2_sim = res['x2']
x3_sim = res['x3']
x4_sim = res['x4']
u1_sim = res['u1']
u2_sim = res['u2']
t_sim  = res['time']
</programlisting>

        <para>And then plotted with the help from
        <literal>matplotlib</literal>:</para>

        <programlisting language="python">plt.figure(1)
plt.subplot(2,2,1)
plt.plot(t_sim,x3_sim)
plt.title('x3')
plt.subplot(2,2,2)
plt.plot(t_sim,x4_sim)
plt.title('x4')
plt.subplot(2,2,3)
plt.plot(t_sim,x1_sim)
plt.title('x1')
plt.xlabel('t[s]')
plt.subplot(2,2,4)
plt.plot(t_sim,x2_sim)
plt.title('x2')
plt.xlabel('t[s]')
plt.show()

plt.figure(2)
plt.subplot(2,1,1)
plt.plot(t_sim,u1_sim,'r')
plt.title('u1')
plt.subplot(2,1,2)
plt.plot(t_sim,u2_sim,'r')
plt.title('u2')
plt.xlabel('t[s]')
plt.show()
</programlisting>

        <para>In <xref linkend="sim_fig_qt_x"/> the result of the tank levels
        are shown and in <xref linkend="sim_fig_qt_u"/> the input signals are
        shown.</para>

        <figure xml:id="sim_fig_qt_x">
          <title>Tank levels</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/quadtank_x.svg" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>

        <figure xml:id="sim_fig_qt_u">
          <title>Input trajectories</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/quadtank_u.svg" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Simulation of a discontinuous system</title>

        <para>The model to be simulated in this example is an electric
        circuit. The model is depicted in <xref linkend="sim_fig_rlc"/> and
        consists of resistances, inductors and a capacitor. The circuit is
        connected to a voltage source which generates a square-wave with an
        amplitude of 1.0 and a frequency of 0.6 Hz. The model is also
        available from the examples in the file
        <filename>RLC_Circuit.mo</filename>.</para>

        <figure xml:id="sim_fig_rlc">
          <title>Electric Circuit</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/RLC.png" scalefit="1" width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>

        <para>This example assumes that the file
        <literal>RLC_Circuit.mo</literal> is located in the working
        directory.</para>

        <para>Start by creating a Python script file and write (or copy paste)
        the command for importing the model object and for compiling a model
        together with the library used for plotting:</para>

        <programlisting language="python"># Import the function for compilation of models and the JMUModel class
from pymodelica import compile_jmu
from pyjmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

        <para>Next, we compile and load the model:</para>

        <programlisting language="python"># Compile model
jmu_name = compile_jmu("RLC_Circuit_Square","RLC_Circuit.mo")

# Load model
rlc = JMUModel(jmu_name)
</programlisting>

        <para>Now we are ready to simulate our model. We are interested in
        simulating the model from 0.0 to 20.0 seconds. The start time is
        default to 0.0 so no need to change that, but the final time needs to
        be changed:</para>

        <programlisting language="python">res = rlc.simulate(final_time=20.0)   # Simulate the model from 0.0 to 20.0 seconds
</programlisting>

        <para>After a successful simulation the statistics are printed in the
        prompt and the results are stored in the variable
        <literal>res</literal>. To view the result, we have to retrieve
        information about the variables we are interested in which is easily
        done in the following way:</para>

        <programlisting language="python">square_y    = res['square.y']
resistor_v  = res['resistor.v']
inductor1_i = res['inductor1.i']
time        = res['time']
</programlisting>

        <para>And then plotted with <literal>matplotlib</literal>,</para>

        <programlisting language="python">plt.figure(1)
plt.plot(time, square_y, time, resistor_v, time, inductor1_i)    
plt.legend(('square.y','resistor.v','inductor1.i'))
plt.show()
</programlisting>

        <para>The simulation result is shown in <xref
        linkend="sim_fig_rlc_res"/>.</para>

        <figure xml:id="sim_fig_rlc_res">
          <title>Simulation result</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/Result_RLC.svg" scalefit="1"
                         width="60%"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>

      <section>
        <title>Simulation with sensitivities</title>

        <para>This example will show how to use JModelica.org to simulate an
        Optimica model and calculate sensitivities of the state variables with
        respect to a number of free parameters.</para>

        <para>The model equations is taken from the Robertson example in the
        Sundials suite (https://computation.llnl.gov/casc/sundials/main.html)
        and the model is shown in the code below.</para>

        <programlisting language="optimica">optimization Robertson
    parameter Real p1(free=true)=0.040;
    parameter Real p2(free=true)=1.0e4;
    parameter Real p3(free=true)=3.0e7;
    
    Real y1(start=1.0, fixed=true);
    Real y2(start=0.0, fixed=true);
    Real y3(start=0.0);
  equation
    der(y1) = -p1*y1 + p2*y2*y3;
    der(y2) =  p1*y1 - p2*y2*y3 - p3*(y2*y2);
    0.0 = y1 + y2 + y3 - 1;
end Robertson;
</programlisting>

        <para>In the model, we have set the parameters to free which means
        that we want to calculate sensitivities of the states with respect to
        the free parameters.</para>

        <para>Let's begin with the the example. Copy and paste the Optimica
        code and save it into <literal>Robertson.mop</literal>, then open a
        Python script file. We start by importing the necessary
        objects:</para>

        <programlisting language="python"># Import the function for compilation of models and the JMUModel class
from pymodelica import compile_jmu
from pyjmi import JMUModel

# Import the plotting library
import matplotlib.pyplot as plt
</programlisting>

        <para>Next, we compile and load the model:</para>

        <programlisting language="python"># Compile model
jmu_name = compile_jmu("Robertson","Robertson.mop")

# Load model
model = JMUModel(jmu_name)
</programlisting>

        <para>Note that sensitivity computations are currently only supported
        for JMUModels. Now that the model is loaded, we have to change an
        option to activate the sensitivity calculations and also set the
        absolute tolerances:</para>

        <programlisting language="python"># Get and set the options
opts = model.simulate_options()                         # Get the options
opts['IDA_options']['atol'] = [1.0e-8, 1.0e-14, 1.0e-6] # Change the tolerance
opts['IDA_options']['sensitivity'] = True               # Activate the sensitivity calculations
opts['ncp'] = 400                                       # Change the number of communication points
</programlisting>

        <para>Now simulate the model:</para>

        <programlisting language="python">res = model.simulate(final_time=4, options=opts)
</programlisting>

        <para>The sensitivity results are stored as <literal>d{variable
        name}/d{parameter name}</literal> in the result object. We are
        interested in the following sensitivities:</para>

        <programlisting language="python">dy1dp1 = res['dy1/dp1']
dy2dp1 = res['dy2/dp1']
dy3dp1 = res['dy3/dp1']
time = res['time']
</programlisting>

        <para>To plot the trajectories using <literal>matplotlib</literal>,
        use the following commands:</para>

        <programlisting language="python">plt.plot(time, dy1dp1, time, dy2dp1, time, dy3dp1)
plt.legend(('dy1/dp1', 'dy2/dp1', 'dy3/dp1'))
plt.show()
</programlisting>

        <para>In <xref linkend="sim_fig_sens"/> the sensitivities are
        plotted.</para>

        <figure xml:id="sim_fig_sens">
          <title>Sensitivity results.</title>

          <mediaobject>
            <imageobject>
              <imagedata fileref="images/robertson_sens.svg" scale="70"/>
            </imageobject>
          </mediaobject>
        </figure>
      </section>
    </section>
  </section>
</chapter>
