/*
    Copyright (C) 2016 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

aspect eliminateLinearEquations {
    public class FClass {
        public class eliminateLinearEquations extends Transformation {
            
            public eliminateLinearEquations() {
                super("eliminate_linear_equations");
            }
            
            @Override
            public void perform() {
                Map<String, Collection<FAbstractEquation>> aliasesMap = new HashMap<String, Collection<FAbstractEquation>>();
                for (FAbstractEquation eqn : getFAbstractEquations()) {
                    if (eqn.containsActiveAnnotations()) {
                        continue;
                    }
                    FExp linearExp = eqn.simpleLinearExp();
                    if (linearExp == null) {
                        continue;
                    }
                    Collection<FAbstractEquation> aliases = aliasesMap.get(linearExp.toString());
                    if (aliases == null) {
                        aliases = new ArrayList<FAbstractEquation>();
                        aliasesMap.put(linearExp.toString(), aliases);
                    }
                    aliases.add(eqn);
                }
                for (Collection<FAbstractEquation> aliases : aliasesMap.values()) {
                    if (aliases.size() <= 1) {
                        continue;
                    }
                    StringBuilder sb = new StringBuilder();
                    Iterator<FAbstractEquation> it = aliases.iterator();
                    FAbstractEquation eqnToKeep = it.next();
                    FExp firstAssignedExp = eqnToKeep.expAssignedFromSimpleLinearExp();
                    log.verbose("Rewriting %d equations that all equal %s", aliases.size() - 1, eqnToKeep.simpleLinearExp());
                    log.debug("  %s", firstAssignedExp);
                    while (it.hasNext()) {
                        FAbstractEquation eqn = it.next();
                        FExp assignedExp = eqn.expAssignedFromSimpleLinearExp();
                        log.debug("  %s", assignedExp);
                        eqn.simpleLinearExp().replaceMe(firstAssignedExp.fullCopy());
                    }
                }
                change();
            }
            
        }
    }
    
    syn FExp FAbstractEquation.simpleLinearExp() = null;
    eq FEquation.simpleLinearExp() {
        if (getLeft().isSimpleLinearExp() && getRight().shouldExtractLinearAlias()) {
            return getLeft();
        } else if (getRight().isSimpleLinearExp() && getLeft().shouldExtractLinearAlias()) {
            return getRight();
        } else {
            return null;
        }
    }
    syn FExp FAbstractEquation.expAssignedFromSimpleLinearExp() = null;
    eq FEquation.expAssignedFromSimpleLinearExp() {
        FExp linearExp = simpleLinearExp();
        if (linearExp == getLeft()) {
            return getRight();
        } else if (linearExp == getRight()) {
            return getLeft();
        } else {
            return null;
        }
    }
    
    syn boolean FExp.isSimpleLinearExp() = false;
    eq FBinExp.isSimpleLinearExp() = (getLeft().isAccess() || getLeft().isSimpleLinearExp()) && (getRight().isAccess() || getRight().isSimpleLinearExp());
    
    syn boolean FExp.shouldExtractLinearAlias() = false;
    eq FBinExp.shouldExtractLinearAlias() = getLeft().shouldExtractLinearAlias() && getRight().shouldExtractLinearAlias();
    eq FIdUseExp.shouldExtractLinearAlias() = true;
    eq FLitExp.shouldExtractLinearAlias() = true;
    
}