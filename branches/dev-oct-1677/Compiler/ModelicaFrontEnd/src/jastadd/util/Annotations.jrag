/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collection;
import java.util.Collections;
import java.util.Iterator;
import java.util.LinkedHashSet;
import java.util.NoSuchElementException;

import org.jmodelica.util.collections.ChainedIterator;
import org.jmodelica.util.collections.FilteredIterator;
import org.jmodelica.util.Criteria;

aspect AnnotationAPI {

    /**
     * Get the annotation node for this AST node's annotation, if any.
     * 
     * This should be overridden for all nodes that can have annotations.
     */
    syn AnnotationNode ASTNode.annotation() = AnnotationNode.NO_ANNOTATION;

    /**
     * Get the annotation node for a sub-node of this AST node's annotation, if any.
     * 
     * Path is interpreted as a "/"-separated list of names of nested annotations.
     * 
     * Example:
     * <code>annotation(A(B(C = "foo")));</code>
     * Here the annotation given by the path <code>"A/B/C"</code> has the value <code>"foo"</code>.
     */
    syn AnnotationNode ASTNode.annotation(String path) = annotation().forPath(path);
    
    syn AnnotationNode ASTNode.annotationOfChild(Opt n) = 
            (n.getNumChild() > 0) ? n.getChild(0).annotation() : createNullAnnotationNode();

    eq SrcComment.annotation()         = annotationOfChild(getSrcAnnotationOpt());
    eq SrcParseAnnotation.annotation() = getSrcClassModification().annotationNode();
    eq SrcModification.annotation()    = annotationNode();

    eq SrcExternalClause.annotation() = annotationOfChild(getSrcAnnotationOpt());
    eq InstExternal.annotation()   = getSrcExternalClause().annotation();

    eq SrcFullClassDecl.annotation()            = annotationOfChild(getSrcAnnotationOpt());
    eq InstClassDecl.annotation()            = getSrcClassDecl().annotation();
    eq SrcShortClassDecl.annotation()           = getSrcExtendsClauseShortClass().annotation();
    eq SrcLibNode.annotation()                  = myClass().annotation();
    eq SrcExtendsClauseShortClass.annotation()  = getSrcComment().annotation();
    eq InstShortClassDecl.annotation()       = getSrcClassDecl().annotation();
    eq InstSimpleShortClassDecl.annotation() = getSrcClassDecl().annotation();

    eq SrcAbstractEquation.annotation() = getSrcComment().annotation();

    eq SrcComponentDecl.annotation()     = getSrcComment().annotation();
    eq InstComponentDecl.annotation() = getSrcComponentDecl().annotation();

    public class FFunctionDecl     implements FAttributeListAnnotationNode.FAttributeList {}
    public class FVariable         implements FAttributeListAnnotationNode.FAttributeList {}
    public class FAbstractEquation implements FAttributeListAnnotationNode.FAttributeList {}
    public class FClass            implements FAttributeListAnnotationNode.FAttributeList {}
    public class FAttribute        implements FAttributeListAnnotationNode.FAttributeList {}
    
    eq FFunctionDecl.annotation()     = new FAttributeListAnnotationNode(this);
    eq FVariable.annotation()         = new FAttributeListAnnotationNode(this);
    eq FAbstractEquation.annotation() = new FAttributeListAnnotationNode(this);
    eq FClass.annotation()            = new FAttributeListAnnotationNode(this);

    syn AnnotationNode InstNode.classAnnotation() = myInstClass().annotation();

    /**
     * Experimental! Retreives the annotation representing the modifications.
     */

    syn AnnotationNode SrcElement.modificationAnnotation() = AnnotationNode.NO_ANNOTATION;
    syn AnnotationNode SrcComponentDecl.modificationAnnotation() = annotationOfChild(getSrcModificationOpt());
    eq SrcExtendsClause.modificationAnnotation() = annotationOfChild(getSrcClassModificationOpt());

    syn AnnotationNode ASTNode.createNullAnnotationNode() = AnnotationNode.NO_ANNOTATION;
    eq SrcComment.createNullAnnotationNode()                 = new CommentAnnotationNode(this);
    eq SrcFullClassDecl.createNullAnnotationNode()           = new FullClassDeclAnnotationNode(this);

    /**
     * Get the annotation node that represents this node when used as an annotation, if 
     * applicable.
     */
    syn AnnotationNode ASTNode.annotationNode()            = createNullAnnotationNode();
    syn lazy AnnotationNode SrcModification.annotationNode()  = createNullAnnotationNode();
    eq SrcClassModification.annotationNode()                  = new ClassModAnnotationNode(this);
    eq SrcValueModification.annotationNode()                  = new ValueModAnnotationNode(this);
    eq SrcCompleteModification.annotationNode()               = new CompleteModAnnotationNode(this);
    eq SrcComponentModification.annotationNode()              = new ComponentModAnnotationNode(this);
    syn lazy AnnotationNode SrcExp.annotationNode()           = new EAnnotationNode(this);
    eq SrcFunctionCall.annotationNode()                       = new FCAnnotationNode(this);
    syn lazy AnnotationNode SrcNamedArgument.annotationNode() = new NAAnnotationNode(this);
    eq FAttribute.annotationNode()                         = new FAttributeAnnotationNode(this);

    /**
     * Describes a node in the tree formed by an annotation.
     */
    public abstract class AnnotationNode implements Iterable<AnnotationNode> {

		/**
		 * Returns the value for a node that represents a list of strings.
		 */
		public ArrayList<String> stringList() {
			return null;
		}

        /**
         * Represents an annotation that does not exist.
         */
        public static final AnnotationNode NO_ANNOTATION = new NullAnnotationNode();

        /**
         * Finds an annotation node at the given path below this one.
         */
        public final AnnotationNode forPath(String path) {
            return forPath(path.split("/"), 0);
        }

        /**
         * Finds all annotation nodes of the given name that are direct children to this one.
         */
        public final Iterable<AnnotationNode> allFor(final String name) {
            return new Iterable<AnnotationNode>() {
                public Iterator<AnnotationNode> iterator() {
                    return iteratorFor(name);
                };
            };
        }

        /**
         * Iterates over all annotation nodes of the given name that are direct children to this one.
         */
        public Iterator<AnnotationNode> iteratorFor(final String name) {
            Criteria<AnnotationNode> crit = new Criteria<AnnotationNode>() {
                public boolean test(AnnotationNode elem) {
                    return name.equals(elem.name());
                }
            };
            return new FilteredIterator<AnnotationNode>(iterator(), crit);
        }

        /**
         * Creates a new empty annotation node, that if written to adds a new child 
         * of this annotation.
         * 
         * Can be used even if there is already a child with that name, 
         * then the new node will be beside the existing node.
         */
        public AnnotationNode emptyNode(String name) {
            return new AssignableNullAnnotationNode(this, name);
        }

        /**
         * Internal definition of {@link #forPath(String)}.
         * 
         * @param path   the path elements to find
         * @param i      the first index in <code>path</code> to use
         */
        private final AnnotationNode forPath(String[] path, int i) {
            if (i >= path.length)
                return this;
            AnnotationNode node = lookup(path[i]);
            if (node == null)
                node = emptyNode(path[i]);
            return node.forPath(path, i + 1);
        }

        /**
         * Finds an create annotation node at the given path below this one.
         */
        public final AnnotationNode createForPath(String path) {
            return createForPath(path.split("/"), 0);
        }

        /**
         * Internal definition of {@link #forPath(String)}.
         * 
         * @param path   the path elements to find
         * @param i      the first index in <code>path</code> to use
         */
        private final AnnotationNode createForPath(String[] path, int i) {
            if (i >= path.length)
                return this;
            AnnotationNode node = lookup(path[i]);
            if (node == null)
                node = addNode(path[i]);
            return node.createForPath(path, i + 1);
        }

		/**
		 * Check if this annotation node represents a value node.
		 */
		public boolean isValue() {
			return false;
		}
		
		/**
		 * Checks if this annotation node represents an existing annotation.
		 */
		public boolean exists() {
			return true;
		}
		
		/**
		 * Get the name associated with this annotation node, if any.
		 * 
		 * In general, any node reachable with a call to forPath() will have a name.
		 * 
		 * @return the name or <code>null</code>, if no name is available
		 */
		public String name() {
			return null;
		}

        /**
         * Iterate over this node's child annotation nodes.
         */
        public final Iterator<AnnotationNode> iterator() {
            Iterator<AnnotationNode> attrIt = attributeIterator();
            Iterator<AnnotationNode> valueIt = valueIterator();
            if (attrIt != NullAnnotationNode.EMPTY_ITERATOR && valueIt != NullAnnotationNode.EMPTY_ITERATOR)
                return new ChainedIterator<AnnotationNode>(attrIt, valueIt);
            else if (attrIt != NullAnnotationNode.EMPTY_ITERATOR)
                return attrIt;
            else
                return valueIt;
        }

        /**
         * Iterate over this node's child annotation nodes that are declared in
         * an attribute looking way.
         */
        public Iterator<AnnotationNode> attributeIterator() {
            return NullAnnotationNode.EMPTY_ITERATOR;
        }

        /**
         * Iterate over this node's child annotation nodes that are declared in
         * a asignment looking way.
         */
        public Iterator<AnnotationNode> valueIterator() {
            return NullAnnotationNode.EMPTY_ITERATOR;
        }

        /**
         * Calculates and returns the evaluated value of this annotation
         * node (if possible).
         */
        public CValue ceval() {
            return CValue.UNKNOWN;
        }

        /**
         * Returns the value for a node that represents a string value.
         */
        public final String string() {
            try {
                return ceval().stringValue();
            } catch (ConstantEvaluationException e) {
                return null;
            }
        }

        /**
         * Check if this node represents a string value.
         */
        public final boolean isStringValue() {
            try {
                CValue val = ceval();
                return val.isString() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a string value, interpreted as 
         * a path of an URI (with protocol file or modelica). A simple path is also 
         * supported, and is interpreted relative to the top containing package, or if 
         * that does not exist, relative to the directory containing the current file.
         */
        public String path() {
            return URIResolver.DEFAULT.resolveInPackage(ast(), string());
        }

        /**
         * Returns the value for a node that represents a list of strings.
         */
        public final String[] stringVector() {
            try {
                CValue val = ceval();
                if (val.isString() && val.isVector()) {
                    return val.stringVector();
                }
            } catch (ConstantEvaluationException e) {}
            return null;
        }

        /**
         * Check if this node represents a list of strings.
         */
        public final boolean isStringVector() {
            try {
                CValue val = ceval();
                return val.isString() && val.isVector();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a list of strings, 
         * or a single string value.
         */
        public final String[] asStringVector() {
            if (isStringVector())
                return stringVector();
            else if (isStringValue())
                return new String[] { string() };
            else
                return null;
        }

        /**
         * Returns the value for a node that represents an integer value.
         */
        public final int integer() {
            try {
                CValue val = ceval();
                if (val.hasIntValue()) {
                    return val.intValue();
                }
            } catch (ConstantEvaluationException e) {}
            return 0;
        }

        /**
         * Check if this node represents an integer value.
         */
        public final boolean isIntegerValue() {
            try {
                CValue val = ceval();
                return val.isInteger() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a real value.
         */
        public final double real() {
            try {
                CValue val = ceval();
                if (val.hasRealValue()) {
                    return val.realValue();
                }
            } catch (ConstantEvaluationException e) {}
            return 0.0;
        }

        /**
         * Check if this node represents a real value.
         */
        public final boolean isRealValue() {
            try {
                CValue val = ceval();
                return val.isReal() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a vector of real values.
         */
        public final double[] realVector() {
            try {
                CValue val = ceval();
                if (val.isReal() && val.isVector()) {
                    return val.realVector();
                }
            } catch (ConstantEvaluationException e) {}
            return null;
        }

        /**
         * Check if this node represents a vector of real values.
         */
        public final boolean isRealVectorValue() {
            try {
                CValue val = ceval();
                return val.isReal() && val.isVector();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a matrix of real values.
         */
        public final double[][] realMatrix() {
            try {
                CValue val = ceval();
                if (val.isReal() && val.isMatrix()) {
                    return val.realMatrix();
                }
            } catch (ConstantEvaluationException e) {}
            return null;
        }

        /**
         * Check if this node represents a matrix of real values.
         */
        public final boolean isRealMatrixValue() {
            try {
                CValue val = ceval();
                return val.isReal() && val.isMatrix();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the value for a node that represents a boolean value.
         */
        public final boolean bool() {
            try {
                CValue val = ceval();
                if (val.hasBooleanValue()) {
                    return val.booleanValue();
                }
            } catch (ConstantEvaluationException e) {}
            return false;
        }

        /**
         * Check if this node represents a boolean value.
         */
        public final boolean isBoolValue() {
            try {
                CValue val = ceval();
                return val.isBoolean() && val.isScalar();
            } catch (ConstantEvaluationException e) {
                return false;
            }
        }

        /**
         * Returns the ast node that this annotation node is connected to.
         */
        protected abstract ASTNode ast();

        /**
         * Returns the exp node that this annotation node is connected to (if possible).
         */
        public SrcExp exp() {
            return null;
        }

        /**
         * Returns the FExp node that this annotation node is connected to (if possible).
         */
        public FExp fExp() {
            return null;
        }

        /**
         * Returns true if the each keyword is set
         * @return true if each is set
         */
        public boolean isEach() {
            return false;
        }

        /**
         * Returns true if the final keyword is set
         * @return true if final is set
         */
        public boolean isFinal() {
            return false;
        }

        /**
         * Returns true if the final keyword is set
         * @return true if final is set
         */
        public int level() {
            return 0;
        }

        /**
         * Returns the vendor specific node for jmodelica. forPath("__Modelon") is done.
         */
        public AnnotationNode vendorNode() {
            return forPath("__Modelon");
        }

        /**
         * Returns the vendor specific node for jmodelica. forPath("__Modelon") is done.
         */
        public AnnotationNode createVendorNode() {
            return createForPath("__Modelon");
        }

        /**
         * Return the string representation of the AST node that this annotation node is connected to.
         */
        public String toString() {
            return (ast() != null) ? ast().toString() : "(no annotation)"; 
        }

        /**
         * Lookup the annotation node with the name <code>name</code> in this
         * annotation node.
         * Default implementation return NO_ANNOTATION node. Sub classes should
         * implement propper behaviour.
         * 
         * An AssignableNullAnnotationNode is created by calling functions if
         * null is returned.
         * 
         * @param name Name of the node.
         * @return An annotation node representation of the node.
         */
        protected AnnotationNode lookup(String name) {
            return NO_ANNOTATION;
        }

        /**
         * Set the expression <code>exp</code> of the node if possible.
         * 
         * @param exp Expresion to set.
         */
        public void setValue(SrcExp exp) {
            throw new AnnotationEditException("Set value is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Set the flat expression <code>exp</code> of the node if possible.
         * 
         * @param exp Flat expresion to set.
         */
        public void setValue(FExp exp) {
            throw new AnnotationEditException("Set value is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Adds a node with the name <code>name</code> to this node if possible.
         * 
         * @param name Name of the new node.
         * @return An annotation node representation of the new node.
         */
        public AnnotationNode addNode(String name) {
            throw new AnnotationEditException("Add node is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Sets the each value for the node (if possible).
         * 
         * @param eachValue New each value that should be set
         */
        public void setEach(boolean eachValue) {
            throw new AnnotationEditException("Set each is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Sets the final value for the node (if possible).
         * 
         * @param finalValue New final value that should be set
         */
        public void setFinal(boolean finalValue) {
            throw new AnnotationEditException("Set final is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

        /**
         * Sets the level for the node (if possible).
         * 
         * @param level New level that should be set
         */
        public void setLevel(int level) {
            throw new AnnotationEditException("Set level is not supported on this type of annotation node (" + getClass().getSimpleName() + ")");
        }

		/**
		 * Iterates over the annotation nodes representing the nodes in the list.
		 */
		protected static class AnnotationIterator implements Iterator<AnnotationNode> {
			private Iterator<? extends ASTNode> it;
			private AnnotationNode next;
			
			public AnnotationIterator(Iterator<? extends ASTNode> it) {
				this.it = it;
				update();
			}
			
			public AnnotationIterator(Iterable<? extends ASTNode> list) {
				this(list.iterator());
			}
			
			public boolean hasNext() {
				return next.exists();
			}
			
			public AnnotationNode next() {
				if (!hasNext())
					throw new NoSuchElementException();
				AnnotationNode res = next;
				update();
				return res;
			}
			
			public void remove() {
				throw new UnsupportedOperationException();
			}
			
			private void update() {
				next = NO_ANNOTATION;
				while (it.hasNext() && !next.exists()) 
					next = it.next().annotationNode();
			}
		}
		
		/**
		 * Represents a non-existing annotation.
		 */
		private static class NullAnnotationNode extends AnnotationNode {
			private static final Iterator<AnnotationNode> EMPTY_ITERATOR = 
				new ArrayList<AnnotationNode>().iterator();
			
			public boolean exists() {
				return false;
			}
			
			public String path() {
				return null;
			}

			protected ASTNode ast() {
				return null;
			}
			
        }
    }

    /**
     * Representation a non-existing annotation but with the possibility to add content.
     */
    public final class AssignableNullAnnotationNode extends AnnotationNode {

        private final AnnotationNode parent;
        protected AnnotationNode realNode;
        private final String name;

        /**
         * Creates an instance form a parent annotation node <code>parent</code> and
         * the path name <code>name</code> of this instance. 
         */
        public AssignableNullAnnotationNode(AnnotationNode parent, String name) {
            this.parent = parent;
            this.name = name;
        }

        @Override
        public boolean exists() {
            return realNode != null;
        }

        public AnnotationNode realNode() {
            if (realNode != null)
                return realNode;
            realNode = parent.createForPath(name);
            return realNode;
        }

        @Override
        public CValue ceval() {
            if (exists())
                return realNode().ceval();
            else
                return super.ceval();
        }

        @Override
        public SrcExp exp() {
            if (exists())
                return realNode().exp();
            else
                return super.exp();
        }

        @Override
        public FExp fExp() {
            if (exists())
                return realNode().fExp();
            else
                return super.fExp();
        }

        @Override
        public boolean isEach() {
            if (exists())
                return realNode().isEach();
            else
                return super.isEach();
        }

        @Override
        public boolean isFinal() {
            if (exists())
                return realNode().isFinal();
            else
                return super.isFinal();
        }
        
        @Override
        public int level() {
            if (exists())
                return realNode().level();
            else
                return super.level();
        }
        
        @Override
        public final void setValue(FExp exp) {
            if (exp != null || exists())
                realNode().setValue(exp);
        }
        
        @Override
        protected AnnotationNode lookup(String path) {
            return realNode == null ? null : realNode.lookup(path);
        }

        @Override
        public AnnotationNode addNode(String path) {
            return realNode().addNode(path);
        }

        @Override
        protected ASTNode ast() {
            return realNode == null ? null : realNode.ast();
        }

        @Override
        public void setEach(boolean eachValue) {
            if (eachValue || exists())
                realNode().setEach(eachValue);
        }

        @Override
        public void setFinal(boolean finalValue) {
            if (finalValue || exists())
                realNode().setFinal(finalValue);
        }

        @Override
        public void setLevel(int level) {
            if (level != 0 || exists())
                realNode().setLevel(level);
        }
    }

    /**
     * Node for representing common entry nodes. These nodes usually only
     * support lookup of sub nodes.
     */
    public abstract class RootAnnotationNode extends AnnotationNode {
        
    }

    /**
     * A null annotation node for a comment, it adds the possibility to add annotation.
     */
    public class CommentAnnotationNode extends RootAnnotationNode {
        
        private SrcComment comment;
        
        /**
         * Constructs an instance with the comment <code>comment</code>.
         */
        public CommentAnnotationNode(SrcComment comment) {
            this.comment = comment;
        }
        
        @Override
        protected AnnotationNode lookup(String path) {
            if (comment.hasSrcAnnotation()) {
                return comment.getSrcAnnotation().annotationNode().lookup(path);
            } else {
                return null;
            }
        }

        @Override
        public AnnotationNode addNode(String path) {
            if (!comment.hasSrcAnnotation()) {
                SrcClassModification cm = new SrcClassModification();
                comment.setSrcAnnotation(new SrcParseAnnotation(cm));
            }
            return comment.getSrcAnnotation().annotationNode().addNode(path);
        }

        @Override
        protected ASTNode ast() {
            return comment;
        }
    
    }
    
    /**
     * A null annotation node for a SrcFullClassDecl, it adds the possibility to add annotation.
     */
    public class FullClassDeclAnnotationNode extends RootAnnotationNode {
 
        private SrcFullClassDecl fullClassDecl;

        /**
         * Constructs an instance with the SrcFullClassDecl <code>fullClassDecl</code>.
         */  
        public FullClassDeclAnnotationNode(SrcFullClassDecl fullClassDecl) {
            this.fullClassDecl = fullClassDecl;
        }

        @Override
        protected ASTNode ast() {
            return fullClassDecl;
        }

        @Override
        protected AnnotationNode lookup(String path) {
            if (fullClassDecl.hasSrcAnnotation()) {
                return fullClassDecl.getSrcAnnotation().annotationNode().lookup(path);
            } else {
                return null;
            }
        }

        @Override
        public AnnotationNode addNode(String path) {
            if (!fullClassDecl.hasSrcAnnotation()) {
                SrcClassModification cm = new SrcClassModification();
                fullClassDecl.setSrcAnnotation(new SrcParseAnnotation(cm));
            }
            return fullClassDecl.getSrcAnnotation().annotationNode().addNode(path);
        }
    }
	/**
	 * Represents an annotation that is represented in the source tree by a SrcClassModification.
	 */
	public class ClassModAnnotationNode extends AnnotationNode {
		
		private SrcClassModification mod;
		
		public ClassModAnnotationNode(SrcClassModification cm) {
			mod = cm;
		}

		public Iterator<AnnotationNode> attributeIterator() {
			return new AnnotationIterator(mod.getSrcArguments());
		}
		
		public String name() {
			return mod.parentAnnotationName();
		}
		
		public SrcClassModification ast() {
			return mod;
		}

        @Override
        protected AnnotationNode lookup(String path) {
            for (SrcArgument arg : mod.getSrcArguments()) 
                if (arg.matches(path))
                    return arg.annotationNode();
            return null;
        }

        @Override
        public AnnotationNode addNode(String path) {
            SrcComponentModification cm = new SrcComponentModification(new SrcNamedAccess(path), new SrcCompleteModification(new SrcClassModification()));
            mod.addSrcArgument(cm);
            return cm.annotationNode();
        }

	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcFunctionCall.
	 */
	public class FCAnnotationNode extends AnnotationNode {
		
		private SrcFunctionCall call;
		
		public FCAnnotationNode(SrcFunctionCall fc) {
			call = fc;
		}

        public Iterator<AnnotationNode> attributeIterator() {
            return new AnnotationIterator(new ChainedIterator(
                    call.getSrcFunctionArguments().getSrcExps().iterator(), 
                    call.getSrcFunctionArguments().getSrcNamedArguments().iterator()));
        }
		
		public String name() {
			return call.getName().name();
		}

		protected ASTNode ast() {
			return call;
		}

        @Override
        protected AnnotationNode lookup(String path) {
            for (SrcNamedArgument arg : call.getSrcFunctionArguments().getSrcNamedArguments()) 
                if (arg.matches(path)) 
                    return arg.annotationNode();
            return null;
        }
	}
	
	public abstract class ExpAnnotationNode extends AnnotationNode {
		
		public abstract SrcExp exp();
		protected abstract void setSrcExp(SrcExp exp);

		public boolean isValue() {
			if (exp() == null)
				return super.isValue();
			else
				return !exp().isAnnotationExp();
		}

		public Iterator<AnnotationNode> valueIterator() {
			return exp() == null || isValue() ? super.valueIterator() : new AnnotationIterator(exp().annotationList());
		}
		
		@Override
		protected abstract ASTNode ast();
		
		@Override
		public void setValue(SrcExp exp) {
			setSrcExp(exp);
		}

        @Override
        public CValue ceval() {
            try {
                return exp() == null ? super.ceval() : exp().ceval();
            } catch (ConstantEvaluationException e) {
                return CValue.UNKNOWN;
            }
        }
        
        public ArrayList<String> stringList() {
			if (exp() == null)
				return super.stringList();
			else
				return exp().avalueStringList();
		}

	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcValueModification.
	 */
	public class ValueModAnnotationNode extends ExpAnnotationNode {
		
		private SrcValueModification mod;
		
		public ValueModAnnotationNode(SrcValueModification vm) {
			mod = vm;
		}
		
		public SrcExp exp() {
			return mod.getSrcExp();
		}
		
		protected void setSrcExp(SrcExp exp) {
			mod.setSrcExp(exp);
		}
		
		@Override
		protected ASTNode ast() {
			return mod;
		}
		
		public String name() {
			return mod.parentAnnotationName();
		}
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcComponentModification.
	 */
	public class ComponentModAnnotationNode extends ExpAnnotationNode {
		
		private SrcComponentModification mod;
		
		public ComponentModAnnotationNode(SrcComponentModification mod) {
			this.mod = mod;
		}
		
		@Override
		public SrcExp exp() {
			if (mod.hasSrcModification() && mod.getSrcModification().annotationNode() instanceof ExpAnnotationNode)
				return ((ExpAnnotationNode) mod.getSrcModification().annotationNode()).exp();
			else
				return null;
		}
		
		@Override
		protected void setSrcExp(SrcExp exp) {
			if (mod.hasSrcModification())
				mod.getSrcModification().annotationNode().setValue(exp);
			else
			    throw new UnsupportedOperationException();
		}
		
		@Override
		protected ASTNode ast() {
			return mod;
		}
		
		@Override
		public String name() {
			return mod.getName().name();
		}
		
		@Override
		public boolean isValue() {
			if (mod.hasSrcModification())
				return mod.getSrcModification().annotationNode().isValue();
			else
				return false;
		}
		
		@Override
		public Iterator<AnnotationNode> attributeIterator() {
			if (mod.hasSrcModification())
				return mod.getSrcModification().annotationNode().attributeIterator();
			else
				return super.attributeIterator();
		}

		@Override
		protected AnnotationNode lookup(String path) {
		    if (mod.hasSrcModification())
		        return mod.getSrcModification().annotationNode().lookup(path);
		    else
				return NO_ANNOTATION;
		}
		
		@Override
		public boolean isEach() {
		    return mod.getEach();
		}
		
		@Override
		public boolean isFinal() {
		    return mod.getFinal();
		}
		
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcCompleteModification.
	 */
	public class CompleteModAnnotationNode extends ExpAnnotationNode {
		
		private SrcCompleteModification mod;
		
		public CompleteModAnnotationNode(SrcCompleteModification mod) {
			this.mod = mod;
		}
		
		@Override
		public SrcExp exp() {
			if (mod.hasSrcValueModification())
				return mod.getSrcValueModification().getSrcExp();
			else
				return null;
		}
		
		@Override
		protected void setSrcExp(SrcExp exp) {
			if (mod.hasSrcValueModification())
				mod.getSrcValueModification().annotationNode().setValue(exp);
			else
				mod.setSrcValueModification(new SrcValueModification(exp));
		}
		
		@Override
		protected ASTNode ast() {
			return mod;
		}
		
		@Override
		public String name() {
			return mod.parentAnnotationName();
		} 
		
		@Override
		public boolean isValue() {
			if (mod.hasSrcValueModification())
				return mod.getSrcValueModification().annotationNode().isValue();
			else
				return false;
		}
		
        @Override
        public Iterator<AnnotationNode> attributeIterator() {
            return mod.getSrcClassModification().annotationNode().iterator();
        }

        @Override
        protected AnnotationNode lookup(String path) {
            return mod.getSrcClassModification().annotationNode().lookup(path);
        }

        @Override
        public AnnotationNode addNode(String path) {
            return mod.getSrcClassModification().annotationNode().addNode(path);
        }
		
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by a SrcNamedArgument.
	 */
	public class NAAnnotationNode extends ExpAnnotationNode {
		
		private SrcNamedArgument arg;
		
		public NAAnnotationNode(SrcNamedArgument na) {
			arg = na;
		}
		
		public SrcExp exp() {
			return arg.getSrcExp();
		}
		
		protected void setSrcExp(SrcExp exp) {
			arg.setSrcExp(exp);
		}
		
		@Override
		protected ASTNode ast() {
			return arg;
		}
		
		public String name() {
			return arg.getName().name();
		}
		
	}
	
	/**
	 * Represents an annotation that is represented in the source tree by an SrcExp.
	 */
	public class EAnnotationNode extends ExpAnnotationNode {
		
		private SrcExp e;
		
		public EAnnotationNode(SrcExp exp) {
			e = exp;
		}
		
		public SrcExp exp() {
			return e;
		}
		
		protected void setSrcExp(SrcExp exp) {
			e = exp; // TODO: This is probably wrong!
		}
		
		@Override
		protected ASTNode ast() {
			return e;
		}
		
	}
	
    public abstract class FExpAnnotationNode extends AnnotationNode {
        
        @Override
        public abstract FExp fExp();
        
        @Override
        public boolean isValue() {
            if (exp() == null)
                return super.isValue();
            else
                return !exp().isAnnotationExp();
        }

        @Override
        public Iterator<AnnotationNode> valueIterator() {
            return fExp() == null || isValue() ? super.valueIterator() : new AnnotationIterator(fExp().annotationList());
        }

        @Override
        public CValue ceval() {
            try {
                return fExp() == null ? super.ceval() : fExp().ceval();
            } catch (ConstantEvaluationException e) {
                return CValue.UNKNOWN;
            }
        }

    }

    public class FAttributeAnnotationNode extends FExpAnnotationNode {
        
        private final FAttribute attr;
        
        public FAttributeAnnotationNode(FAttribute attr) {
            this.attr = attr;
        }
        
        @Override
        public FExp fExp() {
            return attr.hasValue() ? attr.getValue() : null;
        }
        
        @Override
        public CValue ceval() {
            return attr.hasValue() ? attr.getValue().ceval() : super.ceval();
        }
        
        @Override
        protected ASTNode ast() {
            return attr;
        }

        @Override
        public boolean isEach() {
            return attr.hasFEach();
        }

        @Override
        public boolean isFinal() {
            return attr.hasFFinal();
        }

        @Override
        public int level() {
            return attr.getLevel();
        }

        @Override
        public Iterator<AnnotationNode> attributeIterator() {
            return attr.getNumFAttribute() > 0 ? new AnnotationIterator(attr.getFAttributes()) : super.attributeIterator();
        }

        @Override
        protected AnnotationNode lookup(String path) {
            for (FAttribute attr : this.attr.getFAttributes())
                if (attr.matches(path))
                    return attr.annotationNode();
            return null;
        }

        @Override
        public AnnotationNode addNode(String path) {
            FAttribute attr = new FAnnotationAttribute(path);
            this.attr.addFAttribute(attr);
            return new FAttributeAnnotationNode(attr);
        }

        @Override
        public void setValue(FExp exp) {
            if (exp == null)
                attr.setValueOpt(new Opt<FExp>());
            else
                attr.setValue(exp);
        }
        
        @Override
        public void setEach(boolean eachValue) {
            if (eachValue)
                attr.setFEach(new FEach());
            else
                attr.setFEachOpt(new Opt<FEach>());
        }

        @Override
        public void setLevel(int level) {
            attr.setLevel(level);
        }

        @Override
        public String name() {
            return attr.getName().name();
        }
    }

    public class FAttributeListAnnotationNode extends AnnotationNode {
        
        public interface FAttributeList {
            public void addFAttribute(FAttribute attribute);
            public List<FAttribute> getFAttributeList();
            public int getNumFAttribute();
        }
        
        private final FAttributeList attrs;
        
        public FAttributeListAnnotationNode(FAttributeList attrs) {
            this.attrs = attrs;
        }
        
        @Override
        protected ASTNode ast() {
            return attrs.getFAttributeList();
        }

        @Override
        public Iterator<AnnotationNode> attributeIterator() {
            return attrs.getNumFAttribute() > 0 ? new AnnotationIterator(attrs.getFAttributeList()) : super.attributeIterator();
        }

        @Override
        protected AnnotationNode lookup(String path) {
            for (FAttribute attr : attrs.getFAttributeList())
                if (attr.matches(path)) 
                    return attr.annotationNode();
            return null;
        }

        @Override
        public AnnotationNode addNode(String path) {
            FAttribute attr = new FAnnotationAttribute(path);
            attrs.addFAttribute(attr);
            return new FAttributeAnnotationNode(attr);
        }
    }
    
	/**
	 * A runtime exception that is thrown when an action fail while trying
	 * to alter an annotation node and it's underlying structure.
	 */
	public class AnnotationEditException extends RuntimeException {
		
		/**
		 * Constructs an instance from a string <code>s</code>.
		 * 
		 * @param s A string explaining the exception
		 */
		public AnnotationEditException(String s) {
			super(s);
		}
		
		/**
		 * Constructs an instance from a string <code>s</code> and exception
		 * <code>e</code>.
		 * 
		 * @param s A string explaining the exception
		 * @param e An exception that caused this exception
		 */
		public AnnotationEditException(String s, Exception e) {
			super(s, e);
		}
	}
	
	syn boolean SrcArgument.matches(String str) = false;
	eq SrcNamedModification.matches(String str) = getName().name().equals(str);
	
	syn boolean SrcNamedArgument.matches(String str) = getName().name().equals(str);
	
	
	syn boolean SrcExp.isFunctionCall() = false;
	eq SrcFunctionCall.isFunctionCall() = true;
	
	syn boolean SrcExp.isAnnotationExp()     = false;
	eq SrcFunctionCall.isAnnotationExp()     = true;
	eq SrcArrayConstructor.isAnnotationExp() = 
		getSrcFunctionArguments().getNumSrcExp() > 0;
		
    syn boolean FExp.isAnnotationExp() = false;
    eq FFunctionCall.isAnnotationExp() = true;
    eq FArray.isAnnotationExp()        = getNumFExp() > 0;

	syn Iterable<? extends ASTNode> SrcExp.annotationList() = new ArrayList<ASTNode>(0);
	eq SrcArrayConstructor.annotationList()                 = getSrcFunctionArguments().getSrcExps();
	eq SrcFunctionCall.annotationList()                     = Collections.singletonList(this);
	
    syn Iterable<? extends ASTNode> FExp.annotationList() = new ArrayList<ASTNode>(0);
    eq FArray.annotationList()                            = getFExps();
    eq FFunctionCall.annotationList()                     = getArgs();
    
    syn String SrcExp.avalueString()  = null;
	eq SrcStringLitExp.avalueString() = unEscape();
	eq SrcAccessExp.avalueString()    = getSrcAccess().name();
    
    syn ArrayList<String> SrcExp.avalueStringList() = null;
	eq SrcArrayConstructor.avalueStringList() {
		ArrayList<String> l = new ArrayList<String>(getSrcFunctionArguments().getNumSrcExp());
		for (SrcExp e : getSrcFunctionArguments().getSrcExps())
			l.add(e.avalueString());
		return l.contains(null) ? null : l;
	}
    
}

