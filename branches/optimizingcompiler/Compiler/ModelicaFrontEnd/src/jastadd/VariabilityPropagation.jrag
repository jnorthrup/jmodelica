/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect VariabilityPropagation {
	
	public boolean FAbstractEquation.taggedForRemoval = false;
	public boolean FVariable.taggedForRemoval = false;
	
	inh boolean FAbstractEquation.variabilityPropagationEnabled();
	eq Root.getChild().variabilityPropagationEnabled() = false;
	eq FClass.getChild().variabilityPropagationEnabled() = true;
	eq FIfWhenElseEquation.getChild().variabilityPropagationEnabled() = false;
	
	syn boolean FEquation.variabilityPropagationEnabled() =
			super.variabilityPropagationEnabled() && variables().size() == 1;
	syn boolean FFunctionCallEquation.variabilityPropagationEnabled() =
			super.variabilityPropagationEnabled() && variables().size() > 0 && variables().size() == numScalarEquations();
	
	
	
	
	public void FClass.variabilityPropagationIfSet() {
		if (root().options.getBooleanOption("variability_propagation")) {
			beginStep("variabilityPropagationIfSet()");
			variabilityPropagation();
			enableConstantFolding();
			endStep("variabilityPropagationIfSet()");
		}
	}
	
	public void FClass.variabilityPropagation() {

		List<FAbstractEquation> parameterEquations = getFParameterEquations();
		LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet<FAbstractEquation>();
		List<FAbstractEquation> equations = getFEquationBlock(0).getFAbstractEquations();

		// Build worklist
		for (FAbstractEquation equation: equations) {
			if (equation.variabilityPropagationEnabled()) {
				worklist.add(equation);
			}
		}

		// Work
		while(!worklist.isEmpty()) {
			FAbstractEquation equation = worklist.iterator().next();
			equation.variabilityPropagation(worklist,parameterEquations);
			worklist.remove(equation);
		}

		// Clean variables
		ArrayList<FVariable> newVariables = new ArrayList<FVariable>();
		for (FVariable fVariable: getFVariables()) {
			if (!fVariable.taggedForRemoval) {
				newVariables.add(fVariable);
			}
		}
		setFVariableList(new List<FVariable>(newVariables));

		// Clean equations
		ArrayList<FAbstractEquation> newEquations = new ArrayList<FAbstractEquation>();
		for (FAbstractEquation equation: equations) {
			if (!equation.taggedForRemoval) {
				newEquations.add(equation);
			}
		}
		getFEquationBlock(0).setFAbstractEquationList(new List<FAbstractEquation>(newEquations));

	}
	
	public void FAbstractEquation.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			List<FAbstractEquation> parameterEquations) {
		
	}
		
	public void FEquation.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			List<FAbstractEquation> parameterEquations) {
		
		FVariable fVariable;
		FExp solution;
		FTypePrefixVariability solutionVariability;

		if (!variabilityPropagationEnabled()) {
			return;
		}

		fVariable = variables().iterator().next();

		if (!fVariable.canPropagate()) {
			return;
		}

		solution = solution(fVariable.name());
		
		if (!solution.isValidExp()) {
			return;
		}
		
		solutionVariability = solution.variability();

		if (!solutionVariability.parameterOrLess()) {
			// Sometimes combinations of parameters and constants yield 
			// discrete variability. IfExpr. etc.
			return;
		}

		if (solutionVariability.constantVariability()) {
			if (solution.canCeval()) {
				solution = solution.ceval().buildLiteral();
			} else {
				// If we can't evaluate right now, set it as parameter
				solutionVariability = fParameter();
			}
		}

		if (solutionVariability.parameterVariability()) {
			parameterEquations.add(new FEquation(fVariable.createUseExp(), solution));
		}

		this.taggedForRemoval = true;
		fVariable.variabilityPropagation(worklist, solutionVariability, solution);

	}
	
	public void FFunctionCallEquation.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			List<FAbstractEquation> parameterEquations) {
		
		
		FTypePrefixVariability callVariability = getCall().variability();
		CValue val[] = null;
		
		if (!variabilityPropagationEnabled()) {
			return;
		}
		
		for (FFunctionCallLeft left: getLefts()) {
			if (left.hasFExp() && !left.getFExp().canPropagate()) {
				return;
			}
		}
		
		if (!callVariability.parameterOrLess()) {
			return;
		}
		
		if (callVariability.constantVariability()) {
			if (getCall().canCeval()) {
				val = getCall().cevalFunction();
			} else {
				callVariability = fParameter();
			}
		}

		if (callVariability.parameterVariability()) {
			parameterEquations.add(this);
		}
		
		this.taggedForRemoval = true;
		int i = 0;
		for (FFunctionCallLeft left: getLefts()) {
			if (left.hasFExp()) {
				left.getFExp().variabilityPropagation(worklist,callVariability, 
						callVariability.constantVariability() ? val[i].buildLiteral() : null);				
			}
			i++;
		}		
	}
	
	public void FExp.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			FTypePrefixVariability variability,
			FExp bindingExp) {
		
		throw new UnsupportedOperationException();
	}
	
	public void FRecordConstructor.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			FTypePrefixVariability variability,
			FExp bindingExp) {

		FRecordConstructor frc = null;
		if (variability.constantVariability()) {
			frc = (FRecordConstructor) bindingExp;
		}

		for (int i = 0; i < getNumArg(); i++) {
			getArg(i).variabilityPropagation(worklist, variability, 
					variability.constantVariability() ? frc.getArg(i) : null);
		}
	}
	
	public void FArray.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			FTypePrefixVariability variability,
			FExp bindingExp) {
		
		FArray a = null;
		if (variability.constantVariability()) {
			a = (FArray) bindingExp;
		}
		
		for (int i = 0; i < getNumFExp(); i++) {
			getFExp(i).variabilityPropagation(worklist, variability, 
					variability.constantVariability() ? a.getFExp(i) : null);
		}
	}
	
	
	public void FIdUseExp.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			FTypePrefixVariability variability,
			FExp bindingExp) {
		
		myFV().variabilityPropagation(worklist, variability, bindingExp);
	}
	
	
	public void FAbstractVariable.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			FTypePrefixVariability variability,
			FExp bindingExp) {
		
		throw new UnsupportedOperationException();
	}
	
	public void FVariable.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			FTypePrefixVariability variability,
			FExp bindingExp) {
		
		FAbstractEquation equation;
		
		// Declaration
		setFTypePrefixVariability(variability);
		if (variability.constantVariability()) {
			setBindingExp(bindingExp);
		}
		
		// Uses
		for (FIdUseExp use: uses()) {
			if (use.inFEquation()) {
				equation = use.myFEquation();
				equation.variables().remove(this);
				if (equation.variabilityPropagationEnabled()) {
					worklist.add(equation);
				}
			}
		}
		
		// Derivative
		if (isDifferentiatedVariable()) {
			FDerivativeVariable fDerivativeVariable = myDerivativeVariable();
			fDerivativeVariable.taggedForRemoval = true;
			fDerivativeVariable.variabilityPropagation(worklist,FTypePrefixVariability.fConstant(),new FIntegerLitExp(0));				
		}
	}
	
	syn boolean FExp.canPropagate() {
		throw new UnsupportedOperationException();
	}
	eq FRecordConstructor.canPropagate() {
		for (FExp exp: getArgs()) {
			if (!exp.canPropagate()) {
				return false;
			}
		}
		return true;
	}
	eq FArray.canPropagate() {
		for (FExp exp: getFExps()) {
			if (!exp.canPropagate()) {
				return false;
			}
		}
		return true;
	}
	eq FIdUseExp.canPropagate() {
		return myFV().canPropagate();
	}
	syn boolean FAbstractVariable.canPropagate() = false;
	eq FVariable.canPropagate() = !isOutput();
	eq FDerivativeVariable.canPropagate() = false;
}

aspect ConstantFolding {
	public boolean FAbstractExp.constantFoldingEnabled = false;
	
	
	public void FClass.enableConstantFolding() {
		for (FAbstractEquation equation: getFParameterEquations()) {
			equation.enableConstantFolding();
		}
		for (FAbstractEquation equation: equations()) {
			equation.enableConstantFolding();
		}
	}
	
	public void FAbstractEquation.enableConstantFolding() {	

	}
	
	public void FFunctionCallEquation.enableConstantFolding() {
		for (FExp childExp: getCall().childFExps()) {
			childExp.enableConstantFolding();
		}
	}
	
	public void FEquation.enableConstantFolding() {	
		getLeft().enableConstantFolding();
		getRight().enableConstantFolding();
	}
	
	public void FWhenEquation.enableConstantFolding() {
		for (FAbstractEquation equation: getFAbstractEquations()) {
			equation.enableConstantFolding();
		}
	}
	
	public void FExp.enableConstantFolding() {	
		for (FExp childExp: childFExps()) {
			childExp.enableConstantFolding();
		}
	}
	
	public void FIfExp.enableConstantFolding() {
		super.enableConstantFolding();
		if (!constantFoldingEnabled && getIfExp().isConstantExp()) {
			eliminateIfEquation = true;
			is$Final = false;
		}
	}
	
	public void FAbstractExp.enableConstantFolding() {
				
		if (isConstantExp()) {
			constantFoldingEnabled = true;
			is$Final = false;
			return;
		}

		super.enableConstantFolding();
	}

	rewrite FAbstractExp {
		when (constantFoldingEnabled && isConstantExp() && canCeval()) to FExp {
			CValue value = ceval();
			if (value.size().isEmpty()) {
				constantFoldingEnabled = false;
				return this;
			}
			return value.buildLiteral();
		}
	}

}
