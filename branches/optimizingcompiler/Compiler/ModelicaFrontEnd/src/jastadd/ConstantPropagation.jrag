/*
    Copyright (C) 2009 Modelon AB

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, version 3 of the License.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/


aspect VariabilityPropagation {
	
	//
	syn FExp FEquation.solution(FVariable fVariable) = solution(fVariable.name());
	//
	public boolean FVariable.hasFDerivativeVariable() {
		try { 
			myDerivativeVariable();
			return true;
		} catch (ClassCastException e) {
			return false;
		}
	}
	public FDerivativeVariable FVariable.myFDerivativeVariable() {
		return myDerivativeVariable();
	}
	//
	syn FTypePrefixVariability FDerExp.expVariability() = 
			getFIdUse().variability().parameterOrLess() ? fConstant() : getFIdUse().variability();
	syn CValue FDerExp.cevalCalc() = 
			getFIdUse().variability().parameterOrLess() ? new CValueInteger(0) : getFIdUse().ceval();
	//
	
	
	public boolean FAbstractEquation.taggedForRemoval = false;
	public boolean FVariable.taggedForRemoval = false;
	public boolean FAbstractEquation.variabilityPropagationEnabled = false;
	
	
	public void FClass.variabilityPropagationIfSet() {
		if (root().options.getBooleanOption("constant_propagation")) {
			beginStep("variabilityPropagationIfSet()");
			
			List<FAbstractEquation> parameterEquations = getFParameterEquations();			
			LinkedHashSet<FAbstractEquation> worklist = new LinkedHashSet<FAbstractEquation>();
			List<FAbstractEquation> equations = getFEquationBlock(0).getFAbstractEquations();
			
			// Build worklist
			for (FAbstractEquation equation: equations) {
				equation.variabilityPropagationEnabled = true;
				if (equation.variables().size() == 1) {
					worklist.add(equation);
				}
			}
			
			// Work
			while(!worklist.isEmpty()) {
				FAbstractEquation equation = worklist.iterator().next();
				equation.variabilityPropagation(worklist,parameterEquations);
				worklist.remove(equation);
			}
			
			// Clean variables
			for (int i = 0; i < getFVariables().numChildren(); i++) {
				if (getFVariables().getChild(i).taggedForRemoval) {
					getFVariables().removeChild(i);
					i--;
				}
			}
			// Clean equations
			for (int i = 0; i < equations.numChildren(); i++) {
				if (equations.getChild(i).taggedForRemoval) {
					equations.removeChild(i);
					i--;
				}
			}
		
			enableConstantFolding();
			
			endStep("variabilityPropagationIfSet()");
		}
	}
	
	public void FAbstractEquation.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			List<FAbstractEquation> parameterEquations) {
		
	}
	
	public void FEquation.variabilityPropagation(
			LinkedHashSet<FAbstractEquation> worklist,
			List<FAbstractEquation> parameterEquations) {
		
		FVariable fv;
		FExp sol;
		FTypePrefixVariability vari;

		try { // assumes exactly one variable in variables()
			fv = variables().iterator().next();
		} catch (NoSuchElementException e) {
			return; // TODO: log/why are we here?
		}
		
		if (fv.isDerivativeVariable()) {
			return;
		}
		

		sol = solution(fv);
		vari = sol.variability();

		if (!vari.constantVariability() && !vari.parameterVariability()) {
			// TODO: log/why are we here?
			return;
		}

		if (vari.constantVariability()) {

			try {
				CValue cv = sol.ceval();
				if (cv.isUnknown()) {
					return; // TODO: log/why are we here?
				}				
				sol = cv.buildLiteral();

			} catch (ConstantEvaluationException e) { 
				return; // TODO: log/why are we here?
			}

			fv.setBindingExp(sol);
		}

		if (vari.parameterVariability()) {
			parameterEquations.add(new FEquation(fv.createUseExp(), sol));
		}

		this.taggedForRemoval = true;
		fv.setFTypePrefixVariability(vari);

		for (FIdUseExp use: fv.uses()) {
			use.variabilityPropagationGoUp(worklist,fv);
		}
		
		if (fv.hasFDerivativeVariable()) {
			FDerivativeVariable fdv = fv.myFDerivativeVariable();
			fdv.setBindingExp(new FIntegerLitExp(0));
			fdv.setFTypePrefixVariability(FTypePrefixVariability.fConstant());
			fdv.taggedForRemoval = true;
			for (FIdUseExp use: fdv.uses()) {
				use.variabilityPropagationGoUp(worklist,fdv);
			}
		}
	}
	
	public void ASTNode.variabilityPropagationGoUp(
			LinkedHashSet<FAbstractEquation> worklist,
			FVariable fv) {
		
	}
	
	public void FExp.variabilityPropagationGoUp(
			LinkedHashSet<FAbstractEquation> worklist,
			FVariable fv) {
		
		is$Final = false;
		getParent().variabilityPropagationGoUp(worklist, fv);
	}
	
	public void FEquation.variabilityPropagationGoUp(
			LinkedHashSet<FAbstractEquation> worklist,
			FVariable fv) {
		
		variables().remove(fv);
		if (variabilityPropagationEnabled && variables().size() == 1) {
			worklist.add(this);
		}
	}
}

aspect ConstantFolding {
	public boolean FExp.constantFoldingEnabled = false;
	
	syn boolean FExp.constantFoldingEligible() = false;
	eq FIdUseExp.constantFoldingEligible() =  true;
	eq FUnaryExp.constantFoldingEligible() = true;
	eq FBinExp.constantFoldingEligible() = true;
	eq FIfExp.constantFoldingEligible() = true;
		
	public void FClass.enableConstantFolding() {
		super.enableConstantFolding();
	}
	
	public void ASTNode.enableConstantFolding() {
		for (ASTNode n: this)
			n.enableConstantFolding();
	}
	
	public void FRecordDecl.enableConstantFolding() {
		
	}
	
	public void FExp.enableConstantFolding() {
		
		constantFoldingEnabled = true;
		is$Final = false;
		
		if (isConstantExp()) {
			return;
		}

		for (FExp exp: childFExps()) {
			exp.enableConstantFolding();
		}
	}
	
	rewrite FIfExp {
		when (constantFoldingEnabled && getIfExp().isConstantExp() && !getIfExp().ceval().isUnknown()) to FExp {
			return getIfExp().ceval().booleanValue() ? getThenExp() : getElseExp();
		}
	}

	rewrite FExp {
		when (constantFoldingEnabled && constantFoldingEligible() && isConstantExp() && !ceval().isUnknown()) to FExp {
			return ceval().buildLiteral();
		}
	}

}
