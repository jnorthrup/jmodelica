import org.jastadd.ed.core.model.node.IJastAddNode;
import org.jastadd.ed.core.model.node.IASTNode;

aspect Core {

	/*
	 * The IJastAddNode interface must be implemented by ASTNode
	 */
	ASTNode implements IJastAddNode;
  
  	/*
  	 * Default implementations for column and line methods
  	 */
	public int ASTNode.getBeginColumn() {
		return getColumn(getStart());
	}
	public int ASTNode.getBeginLine() {
		return getLine(getStart());
	}
	public int ASTNode.getEndColumn() {
		return getColumn(getEnd());
	}
	public int ASTNode.getEndLine() {
		return getLine(getEnd());
	} 
	
	/*
	 * The default behavior for treeLockObject() is to return the state object
	 */
	syn Object ASTNode.treeLockObject() = state();
		
	
	/*
	 * The IASTNode interface must be implemented by ASTNode
	 */
	ASTNode implements IASTNode;
	
	/*
	 * Default behavior is that a node is not the root of the project AST
	 */
	syn boolean ASTNode.isProjectAST() = false;  
	
	/*
	 * Default behavior for hasLookupKey() and lookupKey() in the IASTNode interface.
	 */
	 syn boolean ASTNode.hasLookupKey() = false;
	 syn String ASTNode.lookupKey() = null;
		
	/*
	 * Default behavior for the replaceWith(IASTNode) method in the IASTNode interface.
	 */ 
	public void ASTNode.replaceWith(IASTNode node) {
		ASTNode child = (ASTNode)node;
		ASTNode parent = getParent();
		if (parent != null) {
			int index = parent.getIndexOfChild(this);
			parent.setChild(child, index);
		}
	}
	
	/*
	 * Default behavior for lookupChildAST(String key) in the IASTNode interface
	 */
	syn IASTNode ASTNode.lookupChildAST(String key) {
	    String thisKey = lookupKey();
		if (hasLookupKey() && thisKey != null && thisKey.equals(key)) {
			return this;
		}
		for (int i = 0; i < getNumChild(); i++) {
			IASTNode childMatch = getChild(i).lookupChildAST(key);
			if (childMatch != null) {
				return childMatch;
			}
		}
		return null;
	}
	
	/* 
	 * The flushAttributes() method in the IASTNode interface.
	 */
	public void ASTNode.flushAttributes() {
		flushCache();
    	for (int i = 0; i < getNumChild(); i++) {
      		if (getChildNoTransform(i) != null) {
        		getChildNoTransform(i).flushAttributes(); 
        	}
        }
	}
	
	/*
	 * JL_ADDED
	 * Synchronized method for adding a new component to a fullclassdecl.
	 */
	public ComponentDecl FullClassDecl.addComponent(String className, String componentName, Placement placement) {
		ComponentDecl componentDecl = new ComponentDecl();
		componentDecl.setClassName(Access.fromClassName(className));
		componentDecl.setVisibilityType(new PublicVisibilityType());
		componentDecl.setName(new IdDecl(componentName));
		componentDecl.setComment(new Comment());
		componentDecl.setCCComment(new Comment());
		componentDecl.annotation().savePlacement(placement);
		
		addNewComponentDecl(componentDecl);
		flushCache();
		classes(); //TODO prob dont need?
		components();
		return componentDecl;
	}
	
	/*
	 * We don't want to flush MSL libraries.
	 */
	public void Program.flushCacheNotLibs() {
		super.flushCache();
	    getInstProgramRoot_computed = false;
	    getInstProgramRoot_value = null;
	    classes_computed = false;
	    classes_value = null;
	    getPredefinedTypeList_computed = false;
	    getPredefinedTypeList_value = null;
	    getEnumBaseDecl_computed = false;
	    getEnumBaseDecl_value = null;
	    getBuiltInFunctionList_computed = false;
	    getBuiltInFunctionList_value = null;
	    getBuiltInTypeList_computed = false;
	    getBuiltInTypeList_value = null;
	    getUnknownClassDecl_computed = false;
	    getUnknownClassDecl_value = null;
	    getUnknownComponentDecl_computed = false;
	    getUnknownComponentDecl_value = null;
	    simpleLookupClassDefaultScope_String_values = null;
	}
	
	/*
	 * Cache the diagram Layer
	 */
    public Layer InstNode.cacheDiagramLayer() {
    	ClassDecl decl = iconClassDecl();
		if (decl == null)
			return Layer.NO_LAYER;
		else
			return decl.cacheDiagramLayer();
	}
	
	private Layer ClassDecl.cachedDiagramLayer = null;
	/*
	 * Cache the diagram Layer
	 */
	public Layer ClassDecl.cacheDiagramLayer() {
		if (cachedDiagramLayer != null)
			return cachedDiagramLayer;
		cachedDiagramLayer = annotation().createDiagramLayer();
		return cachedDiagramLayer;
	}
	
	/*
	 * Cache the icon Layer
	 */
	public Layer InstNode.cacheIconLayer() {
    	ClassDecl decl = iconClassDecl();
		if (decl == null)
			return Layer.NO_LAYER;
		else
			return decl.iconLayer();
	}
	
	private Layer ClassDecl.cachedIconLayer = null;
	/*
	 * Cache the icon Layer
	 */	
	public Layer ClassDecl.cacheIconLayer() {
		if (cachedIconLayer != null)
			return cachedIconLayer;
		cachedIconLayer = annotation().createIconLayer();
		return cachedIconLayer;
	}
	
	/*
	 * Cache the placement
	 */
	public Placement InstComponentDecl.cachePlacement() {
		return getComponentDecl().cachePlacement();
	}
	
	private Placement ComponentDecl.cachedPlacement = null;
	/*
	 * Cache the placement
	 */
	public Placement ComponentDecl.cachePlacement() {
		if (cachedPlacement != null)
			return cachedPlacement;
		try {
			cachedPlacement = annotation().createPlacement(Context.DIAGRAM);
		}
		catch(FailedConstructionException fe) {
			cachedPlacement = new Placement(new Transformation(new Extent(new Point(-10, -10), new Point(10, 10))));
		}
		return cachedPlacement;
	}
	
	public void ComponentDecl.syncSetParameterValue(Stack<String> path, String value) {
		synchronized(state()) {
			setParameterValue(path, value);
		}
	}
}